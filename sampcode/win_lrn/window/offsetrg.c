/*
 * Function (s) demonstrated in this program: OffsetRgn,
 *           BeginPaint, CreateRectRgn, EndPaint, GetSystemMetrics,
 *           InvalidateRect, SelectObject, TextOut, PostQuitMessage
 *
 * This program demonstrates the use of the Windows function OffsetRgn.
 * A handle to a rectangular region is generated by CreateRectRgn.  The
 * contents of this region are filled with a solid backround.  The
 * rectangle is initially located on one side of the client area.  When
 * a button is pressed then the client area is erased and the rectangle
 * is placed on the other side of the client area by the offsetrgn
 * function.  This process can be repeated indefinitely.
 *
 */

#include <windows.h>
#include <string.h>

#define LEFT    0
#define RIGHT   1

long FAR PASCAL WndProc (HWND, unsigned, WORD, LONG);
void WndPaint (HWND hWnd, HDC hDC, BOOL fPosition);

int     PASCAL WinMain (hInstance, hPrevInstance, lpszCmdLine, nCmdShow)
HANDLE     hInstance, hPrevInstance;
LPSTR      lpszCmdLine;
int        nCmdShow;
  {
  static char	szAppName [] = "OffsetRgn";
  HWND          hWnd;
  WNDCLASS      wndclass;
  MSG           msg;

  if (!hPrevInstance)
    {
    wndclass.style         = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc   = WndProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hInstance     = hInstance;
    wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION);
    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
    wndclass.hbrBackground = GetStockObject (WHITE_BRUSH);
    wndclass.lpszMenuName  = NULL;
    wndclass.lpszClassName = szAppName;

    if (!RegisterClass (&wndclass))
      return FALSE;
    }

  hWnd = CreateWindow (szAppName, (LPSTR) "OffsetRgn",
                       WS_OVERLAPPEDWINDOW,
                       CW_USEDEFAULT, 0,
                       CW_USEDEFAULT, 0,
                       NULL, NULL, hInstance, NULL);

  ShowWindow (hWnd, nCmdShow);
  UpdateWindow (hWnd);

  while (GetMessage (&msg, NULL, 0, 0))
    {
    TranslateMessage (&msg);
    DispatchMessage (&msg);
    }
  return msg.wParam;
  }


long    FAR PASCAL WndProc (hWnd, iMessage, wParam, lParam)
HWND     hWnd;
unsigned iMessage;
WORD     wParam;
LONG     lParam;
  {
  HDC      hDC;                 /* For the paint routine */
  PAINTSTRUCT ps;
  RECT     Rect;
  POINT    Point;
  static BOOL fPosition = LEFT; /* The value determines the location of the
                                 * rectangular region.  When LEFT then the
                                 * the region is located toward the top of
                                 * the window.  Otherwise the region is
                                 * located toward the bottom of the window.
                                 */
  switch (iMessage)
    {
    case WM_PAINT:
      hDC = BeginPaint (hWnd, (LPPAINTSTRUCT) & ps);
      WndPaint (hWnd, hDC, fPosition);
      EndPaint (hWnd, (LPPAINTSTRUCT) & ps);
      break;

    case WM_KEYUP:
      if (fPosition == LEFT)
        fPosition = RIGHT;
      else
        fPosition = LEFT;

      GetWindowRect (hWnd, &Rect);

      /* Translate screen coordinates to client coordinates for the *
       * InvalidateRect function.                                   */
      Point.x = Rect.left;
      Point.y = Rect.top;
      ScreenToClient (hWnd, &Point);  /* Translate the upper left hand corner */
      Rect.left = Point.x;
      Rect.top = Point.y;

      Point.x = Rect.right;
      Point.y = Rect.bottom;
      ScreenToClient (hWnd, &Point); /* Translate the upper right hand corner */
      Rect.right = Point.x;
      Rect.bottom = Point.y;

      InvalidateRect (hWnd, &Rect, TRUE);
      break;

    case WM_DESTROY:
      PostQuitMessage (0);
      break;

    default:
      return DefWindowProc (hWnd, iMessage, wParam, lParam);
    }
  return (0L);
  }

void WndPaint (hWnd, hDC, fPosition)
HWND hWnd;
HDC  hDC;
BOOL fPosition;
  {
  HRGN        hRgn;
  short X, Y;

  TextOut (hDC, 10, 10, "Pressing any key will cause the OffsetRgn function", 50);
  TextOut (hDC, 10, 22, "to change the position of the rectangular region.", 49);
  SelectObject (hDC, GetStockObject (GRAY_BRUSH));

  X = GetSystemMetrics (SM_CXSCREEN);
  Y = GetSystemMetrics (SM_CYSCREEN);

  hRgn = CreateRectRgn (X / 4, Y / 4 + 50, X / 2, Y / 2 + 50);

  if (fPosition == LEFT)
/* OffsetRgn moves the region identified by hRgn by the specified  *
     * offsets.  The function moves the region 150 units along the     *
     * x-axis and 0 units along the y-axis.                            */
    OffsetRgn (hRgn, 150, 0);          /* Move rectangle region to the right */

  else
    OffsetRgn (hRgn, -150, 0);          /* Move rectangle region to the left */

/* PaintRgn fills the region specified by hRgn with the brush selected *
   * into the display context.                                           */

  PaintRgn (hDC, hRgn);
  DeleteObject (hRgn);     /*  Delete region from memory  */
  return;
  }
