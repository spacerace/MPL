 
/*
 * C lex
 */
%{
extern  char    *install();
%}
digit   = [0-9];
letter  = [a-zA-Z_$];
name    = letter (letter|digit)*;
integer = digit digit*;
%{
main()
{
        register int    i;
        char            buffer[80];
        extern char     *token();
 
        while (i = yylex()) {
                gettoken(buffer, sizeof buffer);
                printf("yylex returns %d, token = \"%s\"\n",
                        i, buffer);
                if (i == LEXERR) {
                        error("LEXERR -- abort");
                        break;
                }
        }
}
%}
%%
%{
        register int    c;
%}
#DEFINE         { return(__na__); }
#ELSE           { return(__na__); }
#ENDIF          { return(__na__); }
#IFDEF          { return(__na__); }
#INCLUDE        { return(__na__); }
STRUCT          { return(-1); }
AUTO            { return(__na__); }
EXTERN          { return(__na__); }
STATIC          { return(__na__); }
REGISTER        { return(__na__); }
GOTO            { return(__na__); }
RETURN          { return(__na__); }
IF              { return(__na__); }
WHILE           { return(__na__); }
ELSE            { return(__na__); }
SWITCH          { return(__na__); }
CASE            { return(__na__); }
BREAK           { return(__na__); }
CONTINUE        { return(__na__); }
DO              { return(__na__); }
DEFAULT         { return(__na__); }
FOR             { return(__na__); }
SIZEOF          { return(__na__); }
TYPEDEF         { return(__na__); }
UNION           { return(__na__); }
name            {
                        lexval = install();
                        return(6);
                }
integer         {
 
                        lexval = install();
                        return(7);
                }
"<"             { return(__na__); }
"<="            { return(__na__); }
"="             { return(__na__); }
"!="            { return(__na__); }
">="            { return(__na__); }
">"             { return(__na__); }
"<<"            { return(__na__); }
">>"            { return(__na__); }
"=+"            { return(__na__); }
"=-"            { return(__na__); }
"=/"            { return(__na__); }
"=%"            { return(__na__); }
"%"             { return(__na__); }
"/"             { return(__na__); }
"*"             { return(__na__); }
"=*"            { return(__na__); }
"=<<"           { return(__na__); }
"=>>"           { return(__na__); }
"&"             { return(__na__); }
"|"             { return(__na__); }
"=|"            { return(__na__); }
"=&"            { return(__na__); }
"+"             { return(__na__); }
"-"             { return(__na__); }
"++"            { return(__na__); }
"--"            { return(__na__); }
";"             { return(__na__); }
"?"             { return(__na__); }
"."             { return(__na__); }
","             { return(__na__); }
"/*"            {
                        comment("*/");
                        return(LEXSKIP);
                }
"'"             {
                        if ((c = mapch('\'', '\\')) != -1)
                                while (mapch('\'', '\\') != -1)
                                        lexerror("Long character constant");
                        printf("%c", c);
                        return(__na__);
                }
"\""            { return(__na__); }     /* This should call "lexswitch" */
"\n"            { return(__na__); }
" "             { return(__na__); }
"\t"            { return(__na__); }
"||"            { return(__na__); }
"&&"            { return(__na__); }
"("             { return(__na__); }
")"             { return(__na__); }
"["             { return(__na__); }
"]"             { return(__na__); }
"{"             { return(__na__); }
"}"             { return(__na__); }
%%
char *
install()
/*
 * Install the current token in the symbol table
 */
 
{
        register char   *buffer;        /* Where to put the character   */
        register char   *first;         /* -> first byte of the token   */
        char            *last;          /* Can't be in a register       */
        extern char     *token();
 
        first = token(&last);           /* Find first/last of token     */
        if ((buffer = alloc((last - first) + 1)) == NULL) {
                error("Out of space in install");
                exit(1);                
        }
        first = copy(buffer, first, (last - first));
        *first = '\0';
        return(buffer);
}
