%@1@%%@AH@%OS/2 v1.2 Sample Code%@EH@%%@AE@%
%@NL@%
%@NL@%
%@2@%%@AH@%ACCEL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\ACCEL\ACCEL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% *  ACCEL.C -- Sample demonstrating calls included with INCL_WINACCELERATORS%@NL@%
%@AB@% *%@NL@%
%@AB@% *  Overview:%@NL@%
%@AB@% *        Accelerators are used to reduce the number of keystrokes needed to%@NL@%
%@AB@% *  execute a command (hence "accelerating" a user's processing time)%@NL@%
%@AB@% *%@NL@%
%@AB@% *  Strategy:%@NL@%
%@AB@% *        This application allows the user to experiment with various settings,%@NL@%
%@AB@% *  by popping up a dialog box in which the user can specify an accelerator.%@NL@%
%@AB@% *  One possible modification to this program is to have the user hit the%@NL@%
%@AB@% *  desired key sequence, and to use KbdCharIn() to figure out what the key%@NL@%
%@AB@% *  sequence is, and then set the accelerator.  Another is to implement the%@NL@%
%@AB@% *  "Delete" operation, by perhaps listing the accelerators in a list box.%@NL@%
%@AB@% *  This wasn't done primarily because that would require reorganization%@NL@%
%@AB@% *  (compression) of the accelerator table:  it could not be easily done with%@NL@%
%@AB@% *  a WinDeleteAccel call (because such a call does not exist).%@NL@%
%@AB@% */%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_WINACCELERATORS %@NL@%
%@AI@%#define %@AE@%       INCL_WINBUTTONS                        // Needed for checkboxes in dialogs %@NL@%
%@AI@%#define %@AE@%       INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%       INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%       INCL_WINFRAMEMGR                // for SC_MINIMIZE constant %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<malloc.h>                        // Needed for dynamic memory allocation %@NL@%
%@AI@%#include %@AE@%<stdio.h>                        // Needed for sscanf() call %@NL@%
%@AI@%#include %@AE@%"accel.h"                        // Needed for resource IDs %@NL@%
%@AB@%/*%@NL@%
%@AB@% * Globals%@NL@%
%@AB@% */%@AE@%%@NL@%
char        ach[8];                         // Temporary:  used to store Key: field%@NL@%
char        szAppName[]        = "ACCEL.EXE";%@NL@%
char        szClassName[]        = "Accelerator";%@NL@%
char        szMessage[]        = " - Accelerator Table Example";%@NL@%
int        cbSize;                         // Size of Accel. Table in bytes%@NL@%
int        iTemp;                                // Used to store Key: value, if number%@NL@%
void        *pTemp;                         // Used so free() won't give warnings%@NL@%
HAB        hab;%@NL@%
HACCEL        haccSystem;                        // Handle to system accelerator table%@NL@%
HACCEL        haccTable;                        // Handle to app-local acceltable%@NL@%
HMQ     hmqAccel;%@NL@%
HWND        hwndAccel;                        // Client window%@NL@%
HWND        hwndAccelFrame;                 // Frame window%@NL@%
PACCELTABLE        pacctTable;                // Points to table with ACCEL entries%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Macros%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%Message(s) WinMessageBox(HWND_DESKTOP, HWND_DESKTOP, s, \ %@NL@%
                        szAppName, 0, MB_OK | MB_ICONEXCLAMATION)%@NL@%
%@AI@%#define %@AE@%       Check(b)   WinSendDlgItemMsg(hwndDlg, b, \ %@NL@%
                        BM_SETCHECK, MPFROMSHORT(1), 0L)%@NL@%
%@AI@%#define %@AE@%Checked(b) WinSendDlgItemMsg(hwndDlg, b, BM_QUERYCHECK, 0L, 0L) %@NL@%
%@AB@%/*%@NL@%
%@AB@%    Internals%@NL@%
%@AB@%*/%@AE@%%@NL@%
BOOL InitializeAccelTable(void);%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Main routine...initializes window and message queue%@NL@%
%@AB@% */%@AE@%%@NL@%
void cdecl main(void) {%@NL@%
    QMSG qmsg;%@NL@%
    ULONG ctldata;%@NL@%
%@NL@%
    %@AB@%/* Initialize a PM application */%@AE@%%@NL@%
    hab = WinInitialize(0);%@NL@%
    hmqAccel = WinCreateMsgQueue(hab, 0);%@NL@%
%@NL@%
    %@AB@%/* Register the main window's class */%@AE@%%@NL@%
    if (!WinRegisterClass(hab, szClassName, AccelWndProc, CS_SIZEREDRAW, 0))%@NL@%
        return;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Create the window%@NL@%
%@AB@%        We create it without an accelerator table, but we'll load one later%@NL@%
%@AB@%    */%@AE@%%@NL@%
    ctldata = FCF_STANDARD & ~FCF_ACCELTABLE;%@NL@%
    hwndAccelFrame = WinCreateStdWindow(HWND_DESKTOP, WS_VISIBLE, &ctldata,%@NL@%
        szClassName, szMessage, WS_VISIBLE, (HMODULE) NULL, IDR_ACCEL, &hwndAccel);%@NL@%
    WinShowWindow(hwndAccelFrame, TRUE);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Load the accelerator tables%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (!InitializeAccelTable()) {%@NL@%
        Message("Accelerator table not initialized!");%@NL@%
        return;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* Poll messages from event queue */%@AE@%%@NL@%
    while(WinGetMsg(hab, (PQMSG)&qmsg, (HWND)NULL, 0, 0))%@NL@%
        WinDispatchMsg(hab, (PQMSG)&qmsg);%@NL@%
%@NL@%
    %@AB@%/* Clean up */%@AE@%%@NL@%
    if (!WinDestroyAccelTable(haccTable))%@NL@%
        Message("Could not destroy ACCELTABLE");%@NL@%
    WinDestroyWindow(hwndAccelFrame);%@NL@%
    WinDestroyMsgQueue(hmqAccel);%@NL@%
    WinTerminate(hab);%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK AccelWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2) {%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This routine processes WM_PAINT.  It passes%@NL@%
%@AB@% * everything else to the Default Window Procedure.%@NL@%
%@AB@% */%@AE@%%@NL@%
    HPS                hPS;%@NL@%
    RECTL        rcl;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
        case WM_HELP:%@NL@%
            %@AB@%/* If WM_HELP, pop up Help dialog box */%@AE@%%@NL@%
            WinDlgBox(HWND_DESKTOP, hwnd, AboutDlgProc, (HMODULE) NULL, IDD_HELP, NULL);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            switch (COMMANDMSG(&msg)->cmd) {%@NL@%
%@NL@%
                %@AB@%/* On most WM_COMMAND messages, give the About... box */%@AE@%%@NL@%
                case IDM_ABOUT:%@NL@%
                    WinDlgBox(HWND_DESKTOP, hwnd, AboutDlgProc,%@NL@%
                              (HMODULE) NULL, IDD_ABOUT, NULL);%@NL@%
                    break;%@NL@%
%@NL@%
                %@AB@%/* Create your own accelerator dialog */%@AE@%%@NL@%
                case IDM_CREATE:%@NL@%
                    WinDlgBox(HWND_DESKTOP, hwnd, CreateDlgProc,%@NL@%
                              (HMODULE) NULL, IDD_CREATE, NULL);%@NL@%
%@NL@%
                default: break;%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case WM_PAINT:%@NL@%
            %@AB@%/* Open the presentation space */%@AE@%%@NL@%
            hPS = WinBeginPaint(hwnd, NULL, &rcl);%@NL@%
%@NL@%
            %@AB@%/* Fill the background with Dark Blue */%@AE@%%@NL@%
            WinFillRect(hPS, &rcl, CLR_DARKBLUE);%@NL@%
%@NL@%
            %@AB@%/* Finish painting */%@AE@%%@NL@%
            WinEndPaint(hPS);%@NL@%
            break;%@NL@%
%@NL@%
        default: return WinDefWindowProc(hwnd, msg, mp1, mp2); break;%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK AboutDlgProc(hwndDlg, msg, mp1, mp2)%@NL@%
%@AB@%/*%@NL@%
%@AB@%    About... dialog procedure%@NL@%
%@AB@%*/%@AE@%%@NL@%
HWND hwndDlg;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    switch(msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case DID_OK: WinDismissDlg(hwndDlg, TRUE);%@NL@%
                default: break;%@NL@%
            }%@NL@%
        default: return WinDefDlgProc(hwndDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK CreateDlgProc(hwndDlg, msg, mp1, mp2)%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Create Accelerator dialog procedure%@NL@%
%@AB@%*/%@AE@%%@NL@%
HWND hwndDlg;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    switch(msg) {%@NL@%
        case WM_INITDLG:%@NL@%
            %@AB@%/* Set the defaults */%@AE@%%@NL@%
            Check(IDD_CHAR); Check(IDD_CMD);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case DID_OK:%@NL@%
                    %@AB@%/* Get the accelerator table (allocate an extra space) */%@AE@%%@NL@%
                    cbSize = WinCopyAccelTable(haccTable, NULL, 0);%@NL@%
                    pTemp = (void *) malloc(cbSize + sizeof(ACCEL));%@NL@%
                    pacctTable = (PACCELTABLE) pTemp;%@NL@%
                    cbSize = WinCopyAccelTable(haccTable, pacctTable, cbSize);%@NL@%
                    %@NL@%
%@AI@%#define %@AE@%accNew        pacctTable->aaccel[pacctTable->cAccel] %@NL@%
%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                        Command:%@NL@%
%@AB@%                            if SYSCOMMAND, make the window minimize.%@NL@%
%@AB@%                            if HELP, we'll pop up a dialog box.%@NL@%
%@AB@%                            otherwise, pop up the About... dialog box.%@NL@%
%@AB@%                    */%@AE@%%@NL@%
                    if (Checked(IDD_SYSCMD)) accNew.cmd = SC_MINIMIZE;%@NL@%
                    else accNew.cmd = IDM_ABOUT;%@NL@%
%@NL@%
                    %@AB@%/* Get the states from the dialog box */%@AE@%%@NL@%
                    accNew.fs = 0;%@NL@%
                    if (Checked(IDD_ALT))        accNew.fs |= AF_ALT;%@NL@%
                    if (Checked(IDD_CHAR))        accNew.fs |= AF_CHAR;%@NL@%
                    if (Checked(IDD_CONTROL))        accNew.fs |= AF_CONTROL;%@NL@%
                    if (Checked(IDD_FHELP))        accNew.fs |= AF_HELP;%@NL@%
                    if (Checked(IDD_LONEKEY))        accNew.fs |= AF_LONEKEY;%@NL@%
                    if (Checked(IDD_SCANCODE))        accNew.fs |= AF_SCANCODE;%@NL@%
                    if (Checked(IDD_SHIFT))        accNew.fs |= AF_SHIFT;%@NL@%
                    if (Checked(IDD_SYSCMD))        accNew.fs |= AF_SYSCOMMAND;%@NL@%
                    if (Checked(IDD_VKEY))        accNew.fs |= AF_VIRTUALKEY;%@NL@%
%@NL@%
                    %@AB@%/* Get the key to be defined */%@AE@%%@NL@%
                    WinQueryDlgItemText(hwndDlg, IDD_ENTRY, 8, ach);%@NL@%
                    if (('0' <= ach[0]) && (ach[0] <= '9')) {%@NL@%
                        sscanf(ach, "%i", &iTemp);%@NL@%
                        accNew.key = (USHORT) iTemp;%@NL@%
                    }%@NL@%
                    else accNew.key = (USHORT) ach[0];%@NL@%
%@NL@%
                    %@AB@%/* Increment the count of accelerator records */%@AE@%%@NL@%
                    pacctTable->cAccel++;%@NL@%
%@NL@%
                    %@AB@%/* Cleanup, then create a new accelerator table */%@AE@%%@NL@%
                    WinDestroyAccelTable(haccTable);%@NL@%
                    haccTable = WinCreateAccelTable(hab, pacctTable);%@NL@%
%@NL@%
                    %@AB@%/* Set the new accelerator table, and clean up */%@AE@%%@NL@%
                    WinSetAccelTable(hab, haccTable, hwndAccelFrame);%@NL@%
                    free(pTemp);%@NL@%
%@NL@%
                case DID_CANCEL:%@NL@%
                    WinDismissDlg(hwndDlg, TRUE);%@NL@%
%@NL@%
                default: break;%@NL@%
            }%@NL@%
        default: return WinDefDlgProc(hwndDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
BOOL InitializeAccelTable(void) {%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Initialize the accelerator table by loading it from the%@NL@%
%@AB@%        resource file.        Note that you can load an accelerator%@NL@%
%@AB@%        table from a DLL, if you change the NULL parameter.%@NL@%
%@AB@%        The system accelerator table is accessible after this%@NL@%
%@AB@%        call:  one possible use for this would be a List...%@NL@%
%@AB@%        dialog box, which would list all system & app. accelerators.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    haccSystem = WinQueryAccelTable(hab, NULL);%@NL@%
    haccTable = WinLoadAccelTable(hab, 0, IDR_ACCEL);%@NL@%
    return WinSetAccelTable(hab, haccTable, hwndAccelFrame);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%APP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\MDI\APP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* app.c - MDI Sample application%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINCOMMON %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINRECTANGLES %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%INCL_WINSCROLLBARS %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"app.h" %@NL@%
%@AI@%#include %@AE@%"appdata.h" %@NL@%
%@AI@%#include %@AE@%"mdi.h" %@NL@%
%@AI@%#include %@AE@%"mdidata.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Function prototypes%@NL@%
%@AB@%*/%@AE@%%@NL@%
BOOL AppInit(VOID);%@NL@%
BOOL MDIInit(VOID);%@NL@%
VOID AppTerminate(VOID);%@NL@%
VOID MDITerminate(VOID);%@NL@%
BOOL AppNewDocument(USHORT, PSZ);%@NL@%
VOID TrackSplitbars(HWND, USHORT, SHORT, SHORT);%@NL@%
VOID MDIDesktopSize(HWND, MPARAM, MPARAM);%@NL@%
VOID MDIDesktopSetFocus(HWND, MPARAM); %@NL@%
VOID MDIDesktopActivateDoc(SHORT idMenuitem);%@NL@%
BOOL AppNewDocument(USHORT, PSZ);%@NL@%
NPDOC MDINewDocument(USHORT fsStyle, PSZ pszClassName);%@NL@%
VOID MDISetInitialDocPos(HWND hwndNewFrame);%@NL@%
%@NL@%
VOID AddToWindowMenu(NPDOC);%@NL@%
%@NL@%
%@NL@%
%@NL@%
int cdecl main(void)%@NL@%
{%@NL@%
    QMSG qmsg;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Initialize the application globals%@NL@%
%@AB@%     * and create the main window.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (AppInit() == FALSE) {%@NL@%
        WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
        return(0);%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Initialize the MDI globals etc..%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (MDIInit() == FALSE) {%@NL@%
        WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
        WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
        return(0);%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Create an initial, untitled document.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    AppNewDocument(DS_HORZSPLITBAR | DS_VERTSPLITBAR, szDocClass);%@NL@%
%@NL@%
    while (WinGetMsg(NULL, (PQMSG)&qmsg, NULL, 0, 0)) {%@NL@%
        WinDispatchMsg(NULL, (PQMSG)&qmsg);%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Do the clean-up of the MDI code.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    MDITerminate();%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Do the clean-up of the Application.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    AppTerminate();%@NL@%
%@NL@%
    DosExit(EXIT_PROCESS, 0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY MDIWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    RECTL rclPaint, rclWindow;%@NL@%
    POINTL ptlPatternRef;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        hps = WinBeginPaint(hwnd, (HPS)NULL, &rclPaint);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Set the pattern to be at the top-left%@NL@%
%@AB@%         * since we're top-left aligning the bits.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinQueryWindowRect(hwnd, (PRECTL)&rclWindow);%@NL@%
        ptlPatternRef.x = rclWindow.xLeft;%@NL@%
        ptlPatternRef.y = rclWindow.yTop;%@NL@%
        GpiSetPatternRefPoint(hps, &ptlPatternRef);%@NL@%
%@NL@%
        WinFillRect(hps, &rclPaint, SYSCLR_APPWORKSPACE);%@NL@%
%@NL@%
        WinEndPaint(hps);%@NL@%
        break;%@NL@%
%@NL@%
%@AI@%#if %@AE@%0 %@NL@%
    case WM_SIZE:%@NL@%
%@NL@%
        %@AB@%/* HACK -- only reposition the windows if it is not going to or coming%@NL@%
%@AB@%        from a minimized position, it would be better to what%@NL@%
%@AB@%        WM_WINDOWPOSCHANGED and pay attention to the fs fields of the SWP%@NL@%
%@AB@%        structure */%@AE@%%@NL@%
%@NL@%
        if ( SHORT1FROMMP(mp1) && SHORT2FROMMP(mp1) &&%@NL@%
             SHORT1FROMMP(mp2) && SHORT2FROMMP(mp2) ) {%@NL@%
            MDIDesktopSize ( hwnd, mp1, mp2 );%@NL@%
        }%@NL@%
    break;%@NL@%
%@NL@%
%@AI@%#else %@AE@%%@NL@%
    case WM_SIZE:%@NL@%
        MDIDesktopSize ( hwnd, mp1, mp2 );%@NL@%
        break;%@NL@%
%@AI@%#endif %@AE@%%@NL@%
%@NL@%
    case WM_SETFOCUS:%@NL@%
        MDIDesktopSetFocus(hwnd, mp2);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1)) {%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Pass these accelerators onto the active document's%@NL@%
%@AB@%         * frame so it can process it.%@NL@%
%@AB@%         *%@NL@%
%@AB@%         * These are the CMD_ values from the document system%@NL@%
%@AB@%         * menu.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        case CMD_DOCRESTORE:%@NL@%
            WinSendMsg(hwndActiveDoc, WM_SYSCOMMAND, (MPARAM)SC_RESTORE, mp2);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_DOCNEXT:%@NL@%
            WinSendMsg(hwndActiveDoc, WM_SYSCOMMAND, (MPARAM)SC_NEXT, mp2);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_DOCMINIMIZE:%@NL@%
            WinSendMsg(hwndActiveDoc, WM_SYSCOMMAND, (MPARAM)SC_MINIMIZE, mp2);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_DOCCLOSE:%@NL@%
            WinSendMsg(hwndActiveDoc, WM_SYSCOMMAND, (MPARAM)SC_CLOSE, mp2);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_DOCSPLIT:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Call TrackSplitbars() with -1 for xMouse to tell%@NL@%
%@AB@%             * it to reposition the pointer to where the%@NL@%
%@AB@%             * splitbars currently are.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinSetPointer(HWND_DESKTOP, hptrHVSplit);%@NL@%
            TrackSplitbars(WinWindowFromID(hwndActiveDoc, FID_CLIENT),%@NL@%
                    SPS_VERT | SPS_HORZ, -1, -1);%@NL@%
            WinSetPointer(HWND_DESKTOP, hptrArrow);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_NEW:%@NL@%
            if (AppNewDocument(DS_HORZSPLITBAR | DS_VERTSPLITBAR, szDocClass) == FALSE)%@NL@%
                WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_CLOSE:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Close the active document.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (hwndActiveDoc)%@NL@%
                WinSendMsg(hwndActiveDoc, WM_CLOSE, 0L, 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_ABOUT:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Put up the About... dialog box%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinDlgBox(HWND_DESKTOP, hwnd, AboutDlgProc, NULL, IDD_ABOUT, NULL);%@NL@%
            break;%@NL@%
        %@NL@%
        case CMD_EXIT:%@NL@%
            WinPostMsg(hwnd, WM_QUIT, 0L, 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_ARRANGETILED:%@NL@%
            ArrangeWindows(AWP_TILED);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_ARRANGECASCADED:%@NL@%
            ArrangeWindows(AWP_CASCADED);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * The means a window title was selected from%@NL@%
%@AB@%             * the window menu.  Have the MDI code activate%@NL@%
%@AB@%             * the correct window based on the menuitem ID.%@NL@%
%@AB@%             *%@NL@%
%@AB@%             * WARNING: Be sure to keep you applications%@NL@%
%@AB@%             * menuitem IDs < CMD_WINDOWITEMS.%@NL@%
%@AB@%             */%@AE@%%@NL@%
%@NL@%
            %@AB@%/* MULTIPLEMENU */%@AE@%%@NL@%
            %@AB@%/*  Also in here we need to pass document unique WM_COMMAND%@NL@%
%@AB@%                messages on down to the document's client procs */%@AE@%%@NL@%
%@NL@%
            if (SHORT1FROMMP(mp1) >= CMD_WINDOWITEMS)%@NL@%
                MDIDesktopActivateDoc(SHORT1FROMMP(mp1));%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return (0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
BOOL AppNewDocument(USHORT fsStyle, PSZ pszClassName)%@NL@%
{%@NL@%
    register NPDOC npdocNew;%@NL@%
    HWND hwndFrame, hwndClient;%@NL@%
    HWND hwndHScroll, hwndVScroll;%@NL@%
%@NL@%
    npdocNew = MDINewDocument(fsStyle, pszClassName);%@NL@%
%@NL@%
    npdocNew->clrBackground = clrNext++;%@NL@%
    if (clrNext > CLR_PALEGRAY)%@NL@%
        clrNext = CLR_BACKGROUND;%@NL@%
%@NL@%
    hwndFrame = npdocNew->hwndFrame;%@NL@%
    hwndClient = WinWindowFromID(hwndFrame, FID_CLIENT);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Setup the scrollbars.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    hwndHScroll = WinWindowFromID(hwndFrame, FID_HORZSCROLL);%@NL@%
    WinSendMsg(hwndHScroll, SBM_SETSCROLLBAR, MPFROMSHORT(0),%@NL@%
            MPFROM2SHORT(0, 600));%@NL@%
    hwndHScroll = WinWindowFromID(hwndFrame, ID_HORZSCROLL2);%@NL@%
    WinSendMsg(hwndHScroll, SBM_SETSCROLLBAR, MPFROMSHORT(0),%@NL@%
            MPFROM2SHORT(0, 600));%@NL@%
%@NL@%
    hwndVScroll = WinWindowFromID(hwndFrame, FID_VERTSCROLL);%@NL@%
    WinSendMsg(hwndVScroll, SBM_SETSCROLLBAR, MPFROMSHORT(0),%@NL@%
            MPFROM2SHORT(0, 600));%@NL@%
    hwndVScroll = WinWindowFromID(hwndFrame, ID_VERTSCROLL2);%@NL@%
    WinSendMsg(hwndVScroll, SBM_SETSCROLLBAR, MPFROMSHORT(0),%@NL@%
            MPFROM2SHORT(0, 600));%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Set the focus the client so the new window will be%@NL@%
%@AB@%     * active when we show it.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinSetFocus(HWND_DESKTOP, hwndClient);%@NL@%
%@NL@%
    AddToWindowMenu(npdocNew);    %@AB@%/* Moved here from end of%@NL@%
%@AB@%                                  MdiNewDocument routine so that the doc has%@NL@%
%@AB@%                                  been activated, and therefore the main%@NL@%
%@AB@%                                  window has a menu before attempting to add%@NL@%
%@AB@%                                  the doc to the main window's menu */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Set the initial position of the frame window and make it visible.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    MDISetInitialDocPos(hwndFrame);%@NL@%
%@NL@%
    return (TRUE);%@NL@%
}%@NL@%
%@NL@%
MRESULT EXPENTRY AboutDlgProc(HWND hDlg, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
%@AB@%/*%@NL@%
%@AB@%    About... dialog procedure%@NL@%
%@AB@%*/%@AE@%%@NL@%
{%@NL@%
    switch(msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case DID_OK: WinDismissDlg(hDlg, TRUE); break;%@NL@%
                default: break;%@NL@%
            }%@NL@%
        default: return WinDefDlgProc(hDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%APPDATA.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\MDI\APPDATA.C%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINCOMMON %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINACCELERATORS %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"app.h" %@NL@%
%@AI@%#include %@AE@%"mdi.h" %@NL@%
%@NL@%
char szMDIClass[] = "PM MDI Sample App";%@NL@%
char szDocClass[] = "PM MDI Document";%@NL@%
USHORT cxBorder, cyBorder, cyHScroll, cxVScroll, cyVScrollArrow;%@NL@%
USHORT cxScreen, cyScreen, cyIcon, cxByteAlign, cyByteAlign;%@NL@%
USHORT cxSizeBorder, cySizeBorder;%@NL@%
ULONG clrNext = CLR_BACKGROUND;%@NL@%
LONG rglDevCaps[(CAPS_VERTICAL_FONT_RES - CAPS_FAMILY)];%@NL@%
%@NL@%
%@AB@%/* Main globals */%@AE@%%@NL@%
HAB  hab;%@NL@%
HHEAP hHeap;%@NL@%
HMQ  hmqMDI;%@NL@%
HWND hwndMDI, hwndMDIFrame;%@NL@%
HWND hwndActiveDoc;%@NL@%
FONTMETRICS fmSystemFont;%@NL@%
NPDOC npdocFirst = NULL;%@NL@%
%@NL@%
%@AB@%/* Menu globals */%@AE@%%@NL@%
%@NL@%
%@NL@%
HWND hwndSysMenu;%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%APPDOC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\MDI\APPDOC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    appdoc.c - MDI application%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINCOMMON %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINACCELERATORS %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%INCL_WINSCROLLBARS %@NL@%
%@AI@%#define %@AE@%INCL_WINRECTANGLES %@NL@%
%@AI@%#define %@AE@%INCL_WINCOUNTRY %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@AI@%#define %@AE@%INCL_GPILOGCOLORTABLE %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%"app.h" %@NL@%
%@AI@%#include %@AE@%"appdata.h" %@NL@%
%@AI@%#include %@AE@%"mdi.h" %@NL@%
%@AI@%#include %@AE@%"mdidata.h" %@NL@%
%@NL@%
%@AB@%/* Function prototypes */%@AE@%%@NL@%
VOID AppHScroll(HWND hwnd, MPARAM mp1, MPARAM mp2);%@NL@%
VOID AppVScroll(HWND hwnd, MPARAM mp1, MPARAM mp2);%@NL@%
VOID AppEraseBackground(HWND hwnd, HPS hps);%@NL@%
VOID AppPaint(HWND hwnd);%@NL@%
VOID MDIClose(HWND hwndClient);%@NL@%
BOOL MDICreate(HWND);%@NL@%
BOOL MDIDestroy(HWND);%@NL@%
BOOL MDIActivate(HWND, BOOL);%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * The array of RGB values for the rounded%@NL@%
%@AB@% * rectangles.%@NL@%
%@AB@% */%@AE@%%@NL@%
LONG aclrRGB[16] = {%@NL@%
    RGB_RED, RGB_WHITE, RGB_GREEN, RGB_BLACK,%@NL@%
    RGB_BLUE, RGB_WHITE, RGB_YELLOW, RGB_BLACK,%@NL@%
    RGB_CYAN, RGB_BLACK, RGB_PINK, RGB_BLACK,%@NL@%
    RGB_WHITE, RGB_PINK, RGB_BLACK, RGB_RED%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY DocWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CREATE:%@NL@%
        if (MDICreate(hwnd) == FALSE)%@NL@%
            return ( (MRESULT) TRUE);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
        MDIDestroy(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CLOSE:%@NL@%
        MDIClose(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_HSCROLL:%@NL@%
        AppHScroll(hwnd, mp1, mp2);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_VSCROLL:%@NL@%
        AppVScroll(hwnd, mp1, mp2);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_ERASEBACKGROUND:%@NL@%
        AppEraseBackground(hwnd, (HPS)mp1);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        AppPaint(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_ACTIVATE:%@NL@%
        MDIActivate(hwnd, (BOOL)SHORT1FROMMP(mp1));%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return (0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID AppEraseBackground(HWND hwnd, HPS hps)%@NL@%
{%@NL@%
    RECTL rclPaint;%@NL@%
    HWND hwndFrame, hwndClient;%@NL@%
    register NPDOC npdoc;%@NL@%
%@NL@%
    npdoc = NPDOCFROMCLIENT(hwnd);%@NL@%
    hwndFrame = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * We know the main client is around so%@NL@%
%@AB@%     * go ahead and erase it.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinQueryWindowRect(hwnd, &rclPaint);%@NL@%
    WinMapWindowPoints(hwnd, hwndFrame, (PPOINTL)&rclPaint, 2);%@NL@%
    WinFillRect(hps, &rclPaint, npdoc->clrBackground);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now check to see which of the other client windows%@NL@%
%@AB@%     * are around and erase them.%@NL@%
%@AB@%     *%@NL@%
%@AB@%     * We do all this to avoid erasing the splitbars.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (npdoc->fs & DF_SPLITVERT) {%@NL@%
%@NL@%
        hwndClient = WinWindowFromID(hwndFrame, ID_CLIENT2);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * If it became invisible due to the frame%@NL@%
%@AB@%         * window getting too small, then don't%@NL@%
%@AB@%         * bother drawing.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (WinIsWindowVisible(hwndClient) != FALSE) {%@NL@%
            WinQueryWindowRect(hwndClient, &rclPaint);%@NL@%
            WinMapWindowPoints(hwndClient, hwndFrame,%@NL@%
                    (PPOINTL)&rclPaint, 2);%@NL@%
            WinFillRect(hps, &rclPaint, npdoc->clrBackground);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (npdoc->fs & DF_SPLITHORZ) {%@NL@%
%@NL@%
        hwndClient = WinWindowFromID(hwndFrame, ID_CLIENT3);%@NL@%
        if (WinIsWindowVisible(hwndClient) != FALSE) {%@NL@%
            WinQueryWindowRect(hwndClient, &rclPaint);%@NL@%
            WinMapWindowPoints(hwndClient, hwndFrame,%@NL@%
                    (PPOINTL)&rclPaint, 2);%@NL@%
            WinFillRect(hps, &rclPaint, npdoc->clrBackground);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If we're split in both directions, then there's%@NL@%
%@AB@%     * a ID_CLIENT4 window.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((npdoc->fs & (DF_SPLITHORZ | DF_SPLITVERT)) ==%@NL@%
            (DF_SPLITHORZ | DF_SPLITVERT)) {%@NL@%
%@NL@%
        hwndClient = WinWindowFromID(hwndFrame, ID_CLIENT4);%@NL@%
        if (WinIsWindowVisible(hwndClient) != FALSE) {%@NL@%
            WinQueryWindowRect(hwndClient, &rclPaint);%@NL@%
            WinMapWindowPoints(hwndClient, hwndFrame,%@NL@%
                    (PPOINTL)&rclPaint, 2);%@NL@%
            WinFillRect(hps, &rclPaint, npdoc->clrBackground);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID AppHScroll(HWND hwnd, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    HWND hwndFrame;%@NL@%
    NPDOC npdoc;%@NL@%
    RECTL rclPaintBottom, rclPaintTop;%@NL@%
    RECTL rclWindowBottom, rclWindowTop;%@NL@%
    HWND hwndClientBottom, hwndClientTop;%@NL@%
    HWND hwndScrollbar;%@NL@%
    register NPVIEW npviewBottom, npviewTop;%@NL@%
    SHORT posSlider, xOriginOld;%@NL@%
    USHORT cmd, idScrollbar;%@NL@%
%@NL@%
    hwndFrame = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
    npdoc = NPDOCFROMCLIENT(hwnd);%@NL@%
%@NL@%
    idScrollbar = SHORT1FROMMP(mp1);%@NL@%
%@NL@%
    switch (idScrollbar) {%@NL@%
%@NL@%
    case FID_HORZSCROLL:%@NL@%
        hwndClientTop = hwnd;%@NL@%
        if (npdoc->fs & DF_SPLITHORZ) {%@NL@%
            hwndClientBottom = WinWindowFromID(hwndFrame, ID_CLIENT3);%@NL@%
        } else {%@NL@%
            hwndClientBottom = NULL;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case ID_HORZSCROLL2:%@NL@%
        hwndClientTop = WinWindowFromID(hwndFrame, ID_CLIENT2);%@NL@%
        if (npdoc->fs & DF_SPLITHORZ) {%@NL@%
            hwndClientBottom = WinWindowFromID(hwndFrame, ID_CLIENT4);%@NL@%
        } else {%@NL@%
            hwndClientBottom = NULL;%@NL@%
        }%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    hwndScrollbar = WinWindowFromID(hwndFrame, idScrollbar);%@NL@%
%@NL@%
    npviewTop = NPVIEWFROMCLIENT(hwndClientTop);%@NL@%
    WinQueryWindowRect(hwndClientTop, &rclWindowTop);%@NL@%
%@NL@%
    if (hwndClientBottom != NULL) {%@NL@%
        npviewBottom = NPVIEWFROMCLIENT(hwndClientBottom);%@NL@%
        WinQueryWindowRect(hwndClientBottom, &rclWindowBottom);%@NL@%
    }%@NL@%
%@NL@%
    posSlider = (SHORT) (ULONG) WinSendMsg(hwndScrollbar, SBM_QUERYPOS, NULL, NULL);%@NL@%
%@NL@%
    cmd = SHORT2FROMMP(mp2);%@NL@%
    switch (cmd) {%@NL@%
%@NL@%
    case SB_LINELEFT:%@NL@%
        posSlider -= 16;%@NL@%
        break;%@NL@%
%@NL@%
    case SB_LINERIGHT:%@NL@%
        posSlider += 16;%@NL@%
        break;%@NL@%
%@NL@%
    case SB_PAGELEFT:%@NL@%
        posSlider -= ((SHORT)rclWindowTop.xRight - 16);%@NL@%
        break;%@NL@%
%@NL@%
    case SB_PAGERIGHT:%@NL@%
        posSlider += ((SHORT)rclWindowTop.xRight - 16);%@NL@%
        break;%@NL@%
%@NL@%
    case SB_SLIDERPOSITION:%@NL@%
        posSlider = SHORT1FROMMP(mp2);%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    WinSendMsg(hwndScrollbar, SBM_SETPOS, MPFROMSHORT(posSlider), NULL);%@NL@%
%@NL@%
    xOriginOld = npviewTop->xOrigin;%@NL@%
    npviewTop->xOrigin = (SHORT) (ULONG) WinSendMsg(hwndScrollbar, SBM_QUERYPOS, NULL, NULL);%@NL@%
    WinScrollWindow(hwndClientTop, xOriginOld - npviewTop->xOrigin, 0,%@NL@%
            NULL, NULL, NULL, &rclPaintTop, NULL);%@NL@%
%@NL@%
    if (hwndClientBottom != NULL) {%@NL@%
        xOriginOld = npviewBottom->xOrigin;%@NL@%
        npviewBottom->xOrigin = npviewTop->xOrigin;%@NL@%
        WinScrollWindow(hwndClientBottom, xOriginOld - npviewBottom->xOrigin,%@NL@%
                0, NULL, NULL, NULL, &rclPaintBottom, NULL);%@NL@%
    }%@NL@%
%@NL@%
    WinMapWindowPoints(hwndClientTop, hwndFrame, (PPOINTL)&rclPaintTop, 2);%@NL@%
    WinInvalidateRect(hwndFrame, &rclPaintTop, TRUE);%@NL@%
%@NL@%
    if (hwndClientBottom != NULL) {%@NL@%
        WinMapWindowPoints(hwndClientBottom, hwndFrame, (PPOINTL)&rclPaintBottom, 2);%@NL@%
        WinInvalidateRect(hwndFrame, &rclPaintBottom, TRUE);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID AppVScroll(HWND hwnd, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    HWND hwndFrame;%@NL@%
    NPDOC npdoc;%@NL@%
    RECTL rclPaintRight, rclPaintLeft;%@NL@%
    RECTL rclWindowRight, rclWindowLeft;%@NL@%
    HWND hwndClientRight, hwndClientLeft;%@NL@%
    HWND hwndScrollbar;%@NL@%
    register NPVIEW npviewRight, npviewLeft;%@NL@%
    SHORT posSlider, yOriginOld;%@NL@%
    USHORT cmd, idScrollbar;%@NL@%
%@NL@%
    hwndFrame = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
    npdoc = NPDOCFROMCLIENT(hwnd);%@NL@%
%@NL@%
    idScrollbar = SHORT1FROMMP(mp1);%@NL@%
%@NL@%
    switch (idScrollbar) {%@NL@%
%@NL@%
    case FID_VERTSCROLL:%@NL@%
        hwndClientLeft = hwnd;%@NL@%
        if (npdoc->fs & DF_SPLITVERT) {%@NL@%
            hwndClientRight = WinWindowFromID(hwndFrame, ID_CLIENT2);%@NL@%
        } else {%@NL@%
            hwndClientRight = NULL;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case ID_VERTSCROLL2:%@NL@%
        hwndClientLeft = WinWindowFromID(hwndFrame, ID_CLIENT3);%@NL@%
        if (npdoc->fs & DF_SPLITVERT) {%@NL@%
            hwndClientRight = WinWindowFromID(hwndFrame, ID_CLIENT4);%@NL@%
        } else {%@NL@%
            hwndClientRight = NULL;%@NL@%
        }%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    hwndScrollbar = WinWindowFromID(hwndFrame, idScrollbar);%@NL@%
%@NL@%
    npviewLeft = NPVIEWFROMCLIENT(hwndClientLeft);%@NL@%
    WinQueryWindowRect(hwndClientLeft, &rclWindowLeft);%@NL@%
%@NL@%
    if (hwndClientRight != NULL) {%@NL@%
        npviewRight = NPVIEWFROMCLIENT(hwndClientRight);%@NL@%
        WinQueryWindowRect(hwndClientRight, &rclWindowRight);%@NL@%
    }%@NL@%
%@NL@%
    posSlider = (SHORT) (ULONG) WinSendMsg(hwndScrollbar, SBM_QUERYPOS, NULL, NULL);%@NL@%
%@NL@%
    cmd = SHORT2FROMMP(mp2);%@NL@%
    switch (cmd) {%@NL@%
%@NL@%
    case SB_LINEUP:%@NL@%
        posSlider -= 16;%@NL@%
        break;%@NL@%
%@NL@%
    case SB_LINEDOWN:%@NL@%
        posSlider += 16;%@NL@%
        break;%@NL@%
%@NL@%
    case SB_PAGEUP:%@NL@%
        posSlider -= ((SHORT)rclWindowLeft.yTop - 16);%@NL@%
        break;%@NL@%
%@NL@%
    case SB_PAGEDOWN:%@NL@%
        posSlider += ((SHORT)rclWindowLeft.yTop - 16);%@NL@%
        break;%@NL@%
%@NL@%
    case SB_SLIDERPOSITION:%@NL@%
        posSlider = SHORT1FROMMP(mp2);%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    WinSendMsg(hwndScrollbar, SBM_SETPOS, MPFROMSHORT(posSlider), NULL);%@NL@%
%@NL@%
    yOriginOld = npviewLeft->yOrigin;%@NL@%
    npviewLeft->yOrigin = (SHORT) (ULONG) WinSendMsg(hwndScrollbar, SBM_QUERYPOS, NULL, NULL);%@NL@%
    WinScrollWindow(hwndClientLeft, 0,  npviewLeft->yOrigin - yOriginOld,%@NL@%
            NULL, NULL, NULL, &rclPaintLeft, NULL);%@NL@%
%@NL@%
    if (hwndClientRight != NULL) {%@NL@%
        yOriginOld = npviewRight->yOrigin;%@NL@%
        npviewRight->yOrigin = npviewLeft->yOrigin;%@NL@%
        WinScrollWindow(hwndClientRight, 0, npviewRight->yOrigin - yOriginOld,%@NL@%
                NULL, NULL, NULL, &rclPaintRight, NULL);%@NL@%
    }%@NL@%
%@NL@%
    WinMapWindowPoints(hwndClientLeft, hwndFrame, (PPOINTL)&rclPaintLeft, 2);%@NL@%
    WinInvalidateRect(hwndFrame, &rclPaintLeft, TRUE);%@NL@%
%@NL@%
    if (hwndClientRight != NULL) {%@NL@%
        WinMapWindowPoints(hwndClientRight, hwndFrame, (PPOINTL)&rclPaintRight, 2);%@NL@%
        WinInvalidateRect(hwndFrame, &rclPaintRight, TRUE);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID AppPaint(HWND hwnd)%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    RECTL rclPaint, rclWindow, rclTest, rclDst;%@NL@%
    POINTL ptl, ptlPatternRef;%@NL@%
    register NPVIEW npview;%@NL@%
    AREABUNDLE abnd;%@NL@%
    LONG clrStart, clrEnd, clrInc, clr;%@NL@%
    SHORT i, j;%@NL@%
%@NL@%
    hps = WinBeginPaint(hwnd, (HPS)NULL, &rclPaint);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Go into RGB mode.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    GpiCreateLogColorTable(hps, 0L, LCOLF_RGB, 0L, 0L, NULL);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Make rclPaint an inclusive-inclusive rectangle%@NL@%
%@AB@%     * since that's how GpiBox() will be output.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    rclPaint.xLeft--;%@NL@%
    rclPaint.yBottom--;%@NL@%
%@NL@%
    npview = NPVIEWFROMCLIENT(hwnd);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Set the pattern to be at the top-left%@NL@%
%@AB@%     * since we're top-left aligning the bits.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinQueryWindowRect(hwnd, (PRECTL)&rclWindow);%@NL@%
    ptlPatternRef.x = rclWindow.xLeft - npview->xOrigin;%@NL@%
    ptlPatternRef.y = rclWindow.yTop + npview->yOrigin;%@NL@%
    GpiSetPatternRefPoint(hps, &ptlPatternRef);%@NL@%
%@NL@%
    for (i = 0; i < 8; i++) {%@NL@%
%@NL@%
        clr = clrStart = aclrRGB[i * 2];%@NL@%
        clrEnd = aclrRGB[(i * 2) + 1];%@NL@%
        clrInc = (clrEnd - clrStart) / 8;%@NL@%
%@NL@%
        for (j = 0; j < 8; j++) {%@NL@%
            abnd.lColor = clr + (j * clrInc);%@NL@%
            GpiSetAttrs(hps, PRIM_AREA, ABB_COLOR, 0L, (PBUNDLE)&abnd);%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Only draw the box if it's going to%@NL@%
%@AB@%             * be visible in the update region.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinSetRect(NULL, &rclTest, 10 + (i * 75),%@NL@%
                    (SHORT)rclWindow.yTop - 75 - (j * 75), 75 + (i * 75),%@NL@%
                    (SHORT)rclWindow.yTop - 10 - (j * 75));%@NL@%
%@NL@%
            WinOffsetRect(NULL, &rclTest, -npview->xOrigin, npview->yOrigin);%@NL@%
%@NL@%
            if (WinIntersectRect(NULL, &rclDst, &rclTest, &rclPaint)) {%@NL@%
%@NL@%
                ptl.x = rclTest.xLeft;%@NL@%
                ptl.y = rclTest.yTop;%@NL@%
                GpiSetCurrentPosition(hps, (PPOINTL)&ptl);%@NL@%
%@NL@%
                ptl.x = rclTest.xRight;%@NL@%
                ptl.y = rclTest.yBottom;%@NL@%
                GpiBox(hps, DRO_OUTLINEFILL, (PPOINTL)&ptl, 40L, 40L);%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    WinEndPaint(hps);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%APPINIT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\MDI\APPINIT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    mdiinit.c - MDI initialization funtions.%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINCOMMON %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINRECTANGLES %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%INCL_GPILCIDS %@NL@%
%@AI@%#define %@AE@%INCL_DEV %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"app.h" %@NL@%
%@AI@%#include %@AE@%"appdata.h" %@NL@%
%@AI@%#include %@AE@%"mdi.h" %@NL@%
%@AI@%#include %@AE@%"mdidata.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/* Function prototypes */%@AE@%%@NL@%
BOOL RegisterWindowClasses(VOID);%@NL@%
VOID InitSysValues(VOID);%@NL@%
%@NL@%
%@NL@%
BOOL AppInit(VOID)%@NL@%
{%@NL@%
    ULONG ctlData;%@NL@%
    HPS hps;%@NL@%
    HDC hdc;%@NL@%
%@NL@%
    hab = WinInitialize(0);%@NL@%
%@NL@%
    hmqMDI = WinCreateMsgQueue(hab, 0);%@NL@%
%@NL@%
    if (!RegisterWindowClasses())%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    ctlData = FCF_TITLEBAR | FCF_MINMAX | FCF_SIZEBORDER | FCF_SYSMENU |%@NL@%
              FCF_MENU | FCF_TASKLIST | FCF_SHELLPOSITION | FCF_ICON;%@NL@%
%@NL@%
    hwndMDIFrame = WinCreateStdWindow(HWND_DESKTOP, WS_VISIBLE,%@NL@%
            (VOID FAR *)&ctlData, szMDIClass, (PSZ)NULL,%@NL@%
            WS_VISIBLE | WS_CLIPCHILDREN, NULL, IDR_MDI,%@NL@%
            (HWND FAR *)&hwndMDI);%@NL@%
%@NL@%
%@NL@%
    if (hwndMDIFrame == NULL)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
%@AB@%/* MULTIPLEMENU */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Remember the first menu so we can put it back when all the documents are%@NL@%
%@AB@%       closed */%@AE@%%@NL@%
    hwndFirstMenu=WinWindowFromID(hwndMDIFrame, FID_MENU);%@NL@%
%@NL@%
    hHeap = WinCreateHeap(0, 0, 0, 0, 0, 0);%@NL@%
%@NL@%
    if (hHeap == NULL)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    hps = WinGetPS(hwndMDI);%@NL@%
%@NL@%
    hdc = GpiQueryDevice(hps);%@NL@%
    DevQueryCaps(hdc, CAPS_FAMILY, CAPS_VERTICAL_FONT_RES, (PLONG)rglDevCaps);%@NL@%
%@NL@%
    WinReleasePS(hps);%@NL@%
%@NL@%
    InitSysValues();%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID InitSysValues(VOID)%@NL@%
{%@NL@%
    cyTitlebar = (SHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYTITLEBAR);%@NL@%
    cyIcon = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYICON);%@NL@%
%@NL@%
    cxBorder = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CXBORDER);%@NL@%
    cyBorder = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYBORDER);%@NL@%
%@NL@%
    cxSizeBorder = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CXSIZEBORDER);%@NL@%
    cySizeBorder = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYSIZEBORDER);%@NL@%
%@NL@%
    cxByteAlign = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CXBYTEALIGN);%@NL@%
    cyByteAlign = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYBYTEALIGN);%@NL@%
%@NL@%
    cxVScroll = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYHSCROLL);%@NL@%
    cyVScrollArrow = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYVSCROLLARROW);%@NL@%
    cyHScroll = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CXVSCROLL);%@NL@%
%@NL@%
    cxScreen = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CXSCREEN);%@NL@%
    cyScreen = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN);%@NL@%
%@NL@%
    cxMinmaxButton = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CXMINMAXBUTTON);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
BOOL RegisterWindowClasses(VOID)%@NL@%
{%@NL@%
    if (!WinRegisterClass(NULL, szMDIClass, (PFNWP)MDIWndProc,%@NL@%
            CS_SYNCPAINT, 0))%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    if (!WinRegisterClass(NULL, szDocClass, (PFNWP)DocWndProc,%@NL@%
            0L, sizeof(NPVIEW)))%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID AppTerminate(VOID)%@NL@%
{%@NL@%
    WinDestroyWindow(hwndMDIFrame);%@NL@%
%@NL@%
    WinDestroyHeap(hHeap);%@NL@%
%@NL@%
    WinDestroyMsgQueue(hmqMDI);%@NL@%
%@NL@%
    WinTerminate(hab);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ARRANGE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\MDI\ARRANGE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* ARRANGE.c - This file contains code to do window arrangment.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINCOMMON %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINRECTANGLES %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"app.h" %@NL@%
%@AI@%#include %@AE@%"appdata.h" %@NL@%
%@AI@%#include %@AE@%"mdi.h" %@NL@%
%@AI@%#include %@AE@%"mdidata.h" %@NL@%
%@NL@%
%@NL@%
MINMAXFIX  %@AB@%/* add hack to keep the min/max icons in sync with reality */%@AE@%%@NL@%
%@NL@%
%@AB@%/* internal function prototypes */%@AE@%%@NL@%
BOOL SetTilePositions(PRECTL prc, SHORT cWnd, PSWP aswp);%@NL@%
SHORT CeilSquareRoot(USHORT us);%@NL@%
BOOL SetCascadePositions(PRECTL prc, SHORT cWnd, PSWP aswp);%@NL@%
BOOL SetCascadeParams(PRECTL prc, SHORT *pxEdge, SHORT *pyEdge,%@NL@%
                      SHORT *pxDelta, SHORT *pyDelta, SHORT *cMaxWnd);%@NL@%
BOOL GetArrangeSwp(USHORT *, SWP *, USHORT *, SWP *);%@NL@%
BOOL GetArrangeRectangle(PRECTL, BOOL);%@NL@%
BOOL ArrangeIconPositions(USHORT, PSWP);%@NL@%
%@NL@%
%@AB@%/* internal constants */%@AE@%%@NL@%
%@AI@%#define %@AE@%CASC_EDGE_NUM       2 %@NL@%
%@AI@%#define %@AE@%CASC_EDGE_DENOM     3 %@NL@%
%@NL@%
%@AB@%/* local constants */%@AE@%%@NL@%
%@AI@%#define %@AE@%ICON_PARK_NUM       5 %@NL@%
%@AI@%#define %@AE@%ICON_PARK_DENOM     3 %@NL@%
%@AI@%#define %@AE@%CLASS_NAME_LENGTH   8 %@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* ArrangeWindowPositions%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function sets positions for arranging windows nicely in a rectangle.%@NL@%
%@AB@%* The hwnd field of each SWP structure should be set by the user, either%@NL@%
%@AB@%* before or after calling this function.  The function sets all other%@NL@%
%@AB@%* fields.  The SWP array can then be passed to WinSetMultWindowPos() to do%@NL@%
%@AB@%* the physical arrangement.  There are two arrangement styles available,%@NL@%
%@AB@%* AWP_TILED and AWP_CASCADED.%@NL@%
%@AB@%*%@NL@%
%@AB@%* AWP_TILED:%@NL@%
%@AB@%*%@NL@%
%@AB@%* The tiles are generated by rows, top left (first) to bottom right (last).%@NL@%
%@AB@%* Each row has the same number of tiles.  The number of tiles in each%@NL@%
%@AB@%* column will differ by at most one, with each column containing one fewer%@NL@%
%@AB@%* tile to the left of the other columns.%@NL@%
%@AB@%*%@NL@%
%@AB@%* AWP_CASCADED:%@NL@%
%@AB@%*%@NL@%
%@AB@%* The windows are generated bottom right (first) to top left (last).%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   prc:    rectangle to contain the tiled windows%@NL@%
%@AB@%*   cWnd:   number of windows to tile%@NL@%
%@AB@%*   aswp:   array of SWP structures, one for each tile window%@NL@%
%@AB@%*   fStyle: the style to arrange the windows%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL ArrangeWindowPositions(PRECTL prc, SHORT cWnd, PSWP aswp, USHORT fStyle)%@NL@%
{%@NL@%
    %@AB@%/* check validity of input rectangle */%@AE@%%@NL@%
    if ((prc->xRight - prc->xLeft < 1) || (prc->yTop - prc->yBottom < 1)) {%@NL@%
        return FALSE;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* set window positions */%@AE@%%@NL@%
    switch (fStyle) {%@NL@%
    case AWP_TILED:%@NL@%
        return SetTilePositions(prc, cWnd, aswp);%@NL@%
    case AWP_CASCADED:%@NL@%
        return SetCascadePositions(prc, cWnd, aswp);%@NL@%
    default:%@NL@%
        return FALSE;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* SetTilePositions%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function sets positions for tiling windows in a rectangle.%@NL@%
%@AB@%*%@NL@%
%@AB@%* NOTE:%@NL@%
%@AB@%*   There are a few subtleties to this code:%@NL@%
%@AB@%*%@NL@%
%@AB@%*   The algorithm lays tiles in a modified NxN grid.  It can be shown%@NL@%
%@AB@%*   that any positive number of tiles can be laid out in such a grid of%@NL@%
%@AB@%*   N columns so that each column has at least N-2 tiles and no column%@NL@%
%@AB@%*   has more than one tile more than any other.  Proof left to the%@NL@%
%@AB@%*   interested reader.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   The tiles coordinates are not generated by stepping over a fixed%@NL@%
%@AB@%*   interval since this will not usually fill the rectangle completely.%@NL@%
%@AB@%*   Thus the offset at each step is calculated from the previous tile%@NL@%
%@AB@%*   to the correct fractional position within the whole rectangle.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Since the last "row" of tiles may not have any members in the beginning%@NL@%
%@AB@%*   columns, these tiles are addressed differently in the SWP array to%@NL@%
%@AB@%*   account for the "missing" tiles.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   prc:        rectangle to contain the tiled windows%@NL@%
%@AB@%*   cWnd:        number of windows to tile the rectangle with%@NL@%
%@AB@%*   aswp:        array of SWP structures, one for each tile window%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL SetTilePositions(PRECTL prc, SHORT cWnd, PSWP aswp)%@NL@%
{%@NL@%
    register SHORT usRoot;%@NL@%
    register SHORT cExtras;%@NL@%
    SHORT iChange;%@NL@%
    SHORT cDiff;%@NL@%
    SHORT x, y, cx, cy;%@NL@%
    SHORT iRow, iCol;%@NL@%
%@NL@%
    %@AB@%/* get grid dimensions */%@AE@%%@NL@%
    usRoot = CeilSquareRoot(cWnd);%@NL@%
    cExtras = usRoot * usRoot - cWnd;%@NL@%
%@NL@%
    %@AB@%/* find column where number of rows increases and find initial%@NL@%
%@AB@%       difference of rows versus columns */%@AE@%%@NL@%
    if (cExtras >= usRoot) {%@NL@%
        iChange = cExtras - usRoot;%@NL@%
        cDiff = 2;%@NL@%
    } else {%@NL@%
        iChange = cExtras;%@NL@%
        cDiff = 1;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* assign x coordinates */%@AE@%%@NL@%
    x = (SHORT)prc->xLeft;%@NL@%
    cx = 0;%@NL@%
    for (iCol = 0; iCol < usRoot; iCol++) {%@NL@%
        x += cx - cxBorder;%@NL@%
        cx = ((SHORT)prc->xLeft) +%@NL@%
             (((SHORT)(prc->xRight - prc->xLeft)) * (iCol + 1)) / usRoot -%@NL@%
             x + cxBorder;%@NL@%
        for (iRow = 0; iRow < usRoot - cDiff; iRow++) {%@NL@%
            aswp[iRow * usRoot + iCol].x = x;%@NL@%
            aswp[iRow * usRoot + iCol].cx = cx;%@NL@%
            aswp[iRow * usRoot + iCol].fs = SWP_SIZE | SWP_MOVE;%@NL@%
        }%@NL@%
        %@AB@%/* assign "extra" row */%@AE@%%@NL@%
        if (iCol >= iChange) {%@NL@%
            aswp[iRow * usRoot + iCol - iChange].x = x;%@NL@%
            aswp[iRow * usRoot + iCol - iChange].cx = cx;%@NL@%
            aswp[iRow * usRoot + iCol - iChange].fs = SWP_SIZE | SWP_MOVE;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* assign y coordinates, columns without extra row */%@AE@%%@NL@%
    y = (SHORT)prc->yBottom;%@NL@%
    cy = 0;%@NL@%
    for (iRow = usRoot - cDiff - 1; iRow >= 0; iRow--) {%@NL@%
        y += cy - cyBorder;%@NL@%
        cy = ((SHORT)prc->yBottom) +%@NL@%
             (((SHORT)(prc->yTop - prc->yBottom)) * (usRoot - cDiff - iRow)) /%@NL@%
                (usRoot - cDiff) - y + cyBorder;%@NL@%
        for (iCol = 0; iCol < iChange; iCol++) {%@NL@%
            aswp[iRow * usRoot + iCol].y = y;%@NL@%
            aswp[iRow * usRoot + iCol].cy = cy;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* assign y coordinates, columns with extra row */%@AE@%%@NL@%
    %@AB@%/* do last row first (different offsets) */%@AE@%%@NL@%
    y = (SHORT)prc->yBottom - cyBorder;%@NL@%
    cy = ((SHORT)(prc->yTop - prc->yBottom)) / (usRoot - cDiff + 1) +%@NL@%
         2 * cyBorder;%@NL@%
    for (iCol = iChange; iCol < usRoot; iCol++) {%@NL@%
        aswp[usRoot * (usRoot - cDiff) + iCol - iChange].y = y;%@NL@%
        aswp[usRoot * (usRoot - cDiff) + iCol - iChange].cy = cy;%@NL@%
    }%@NL@%
    for (iRow = usRoot - cDiff - 1; iRow >= 0; iRow--) {%@NL@%
        y += cy - cyBorder;%@NL@%
        cy = ((SHORT)(prc->yBottom)) +%@NL@%
                (((SHORT)(prc->yTop - prc->yBottom)) * (usRoot - cDiff - iRow + 1))%@NL@%
                / (usRoot - cDiff + 1) - y + cyBorder;%@NL@%
        for (iCol = iChange; iCol < usRoot; iCol++) {%@NL@%
            aswp[iRow * usRoot + iCol].y = y;%@NL@%
            aswp[iRow * usRoot + iCol].cy = cy;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* CeilSquareRoot%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function returns the smallest integer greater or equal to the square%@NL@%
%@AB@%* root of an unsigned 16 bit integer.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameter:%@NL@%
%@AB@%*   us: value to take the root of%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
SHORT CeilSquareRoot(register USHORT us)%@NL@%
{%@NL@%
    register SHORT i;%@NL@%
%@NL@%
    %@AB@%/* prevent overflow of large numbers */%@AE@%%@NL@%
    if (us > 0xFE * 0xFE)%@NL@%
        return 0xFF;%@NL@%
%@NL@%
    %@AB@%/* iterate up past root */%@AE@%%@NL@%
    for (i = 0; i*i < (SHORT) us; i++)%@NL@%
        ;%@NL@%
    return i;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* SetCascadePositions%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function sets positions for cascading windows in a rectangle.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   prc:        rectangle to contain the cascaded windows%@NL@%
%@AB@%*   cWnd:        number of windows to cascade%@NL@%
%@AB@%*   aswp:        array of SWP structures, one for each cascaded window%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL SetCascadePositions(PRECTL prc, SHORT cWnd, PSWP aswp)%@NL@%
{%@NL@%
    SHORT xEdge, yEdge;%@NL@%
    SHORT xDelta, yDelta;%@NL@%
    SHORT cMaxWnd;%@NL@%
    register SHORT x, y;%@NL@%
    SHORT i, j;%@NL@%
    RECTL rc;%@NL@%
%@NL@%
    %@AB@%/* set cascade parameters */%@AE@%%@NL@%
    rc.xLeft = prc->xLeft - cxBorder;%@NL@%
    rc.xRight = prc->xRight + cyBorder;%@NL@%
    rc.yBottom = prc->yBottom - cyBorder;%@NL@%
    rc.yTop = prc->yTop + cyBorder;%@NL@%
    if (!SetCascadeParams((PRECTL)&rc, &xEdge, &yEdge, &xDelta, &yDelta,%@NL@%
                          &cMaxWnd)) {%@NL@%
        return FALSE;%@NL@%
    }%@NL@%
%@NL@%
    if (cWnd <= cMaxWnd) {%@NL@%
        %@AB@%/* only one run needed; move to top left corner */%@AE@%%@NL@%
        x = (SHORT)rc. xLeft;%@NL@%
        y = (SHORT)rc. yTop - yEdge;%@NL@%
        for (i = cWnd - 1; i >= 0; i--) {%@NL@%
            aswp[i].x = x;%@NL@%
            aswp[i].y = y;%@NL@%
            aswp[i].cx = xEdge;%@NL@%
            aswp[i].cy = yEdge;%@NL@%
            aswp[i].fs = SWP_SIZE | SWP_MOVE;%@NL@%
            x += xDelta;%@NL@%
            y -= yDelta;%@NL@%
        }%@NL@%
%@NL@%
    } else {%@NL@%
%@NL@%
        %@AB@%/* multiple runs necessary; start at bottom right, iterate up to%@NL@%
%@AB@%           top left */%@AE@%%@NL@%
%@NL@%
        i = 0;%@NL@%
%@NL@%
        while (i < cWnd) {%@NL@%
%@NL@%
            %@AB@%/* even run */%@AE@%%@NL@%
            x = ((SHORT)rc. xLeft) + (cMaxWnd-1) * xDelta;%@NL@%
            y = ((SHORT)rc. yTop) - yEdge - (cMaxWnd-1) * yDelta;%@NL@%
            for (j = 0; j < cMaxWnd; j++) {%@NL@%
                aswp[i].x = x;%@NL@%
                aswp[i].y = y;%@NL@%
                aswp[i].cx = xEdge;%@NL@%
                aswp[i].cy = yEdge;%@NL@%
                aswp[i].fs = SWP_SIZE | SWP_MOVE;%@NL@%
                x -= xDelta;%@NL@%
                y += yDelta;%@NL@%
                if (++i >= cWnd)%@NL@%
                    break;%@NL@%
            }%@NL@%
%@NL@%
            if (i >= cWnd)%@NL@%
                break;%@NL@%
%@NL@%
            %@AB@%/* odd run, offset by half delta y, one and one half delta x */%@AE@%%@NL@%
            x = ((SHORT)rc. xLeft) + (cMaxWnd-1) * xDelta + xDelta/2;%@NL@%
            y = ((SHORT)rc. yTop) - yEdge - (cMaxWnd-1) * yDelta + yDelta/2;%@NL@%
            for (j = 0; j < cMaxWnd - 1; j++) {%@NL@%
                aswp[i].x = x;%@NL@%
                aswp[i].y = y;%@NL@%
                aswp[i].cx = xEdge;%@NL@%
                aswp[i].cy = yEdge;%@NL@%
                aswp[i].fs = SWP_SIZE | SWP_MOVE;%@NL@%
                x -= xDelta;%@NL@%
                y += yDelta;%@NL@%
                if (++i >= cWnd)%@NL@%
                    break;%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* SetCascadeParams%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function sets parameters for cascading windows.        The window edges%@NL@%
%@AB@%* are based on a fraction CASC_EDGE_NUM/CASC_EDGE_DENOM of the rectangle.%@NL@%
%@AB@%* The x delta is four system font characters across, the y delta is two%@NL@%
%@AB@%* system lines high.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   prc:        rectangle to contain the windows%@NL@%
%@AB@%*   pxEdge:        width of the cascaded windows%@NL@%
%@AB@%*   pyEdge:        height of the cascaded windows%@NL@%
%@AB@%*   pxDelta:        x cascade offset%@NL@%
%@AB@%*   pyDelta:        y cascade offset%@NL@%
%@AB@%*   pcMaxWnd:        maximum number of windows in a cascade%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL SetCascadeParams(PRECTL prc, SHORT *pxEdge, SHORT *pyEdge, SHORT *pxDelta,%@NL@%
        SHORT *pyDelta, SHORT *pcMaxWnd)%@NL@%
{%@NL@%
    register SHORT xEdge, yEdge;%@NL@%
    SHORT xDelta, yDelta;%@NL@%
    SHORT cMaxWnd;%@NL@%
%@NL@%
    %@AB@%/* get x and y deltas from system values */%@AE@%%@NL@%
    xDelta = LOUSHORT(WinQuerySysValue(HWND_DESKTOP, SV_CXSIZEBORDER)) +%@NL@%
             LOUSHORT(WinQuerySysValue(HWND_DESKTOP, SV_CXMINMAXBUTTON)) / 2 + 2;%@NL@%
    yDelta = LOUSHORT(WinQuerySysValue(HWND_DESKTOP, SV_CYSIZEBORDER)) +%@NL@%
             LOUSHORT(WinQuerySysValue(HWND_DESKTOP, SV_CYTITLEBAR))%@NL@%
             - cyBorder;%@NL@%
%@NL@%
    %@AB@%/* get initial cut at yEdge using fraction */%@AE@%%@NL@%
    yEdge = (((SHORT)(prc->yTop - prc->yBottom)) * CASC_EDGE_NUM) /%@NL@%
            CASC_EDGE_DENOM;%@NL@%
%@NL@%
    %@AB@%/* determine maximum number of deltas used per run */%@AE@%%@NL@%
    cMaxWnd = (((SHORT)(prc->yTop - prc->yBottom)) - yEdge) / yDelta;%@NL@%
%@NL@%
    %@AB@%/* set x and y edges so full cascade will fill rectangle completely */%@AE@%%@NL@%
    xEdge = ((SHORT)(prc->xRight - prc->xLeft)) - xDelta/2 - cMaxWnd * xDelta;%@NL@%
    yEdge = ((SHORT)(prc->yTop - prc->yBottom)) - cMaxWnd * yDelta;%@NL@%
%@NL@%
    %@AB@%/* check that values are reasonable */%@AE@%%@NL@%
    if (cMaxWnd < 1 || xEdge < 1 || yEdge < 1) {%@NL@%
        return FALSE;%@NL@%
    }%@NL@%
%@NL@%
    *pxEdge = xEdge;%@NL@%
    *pyEdge = yEdge;%@NL@%
    *pxDelta = xDelta;%@NL@%
    *pyDelta = yDelta;%@NL@%
    %@AB@%/* return cMaxWnd as the maximum number of windows in a cascade */%@AE@%%@NL@%
    *pcMaxWnd = cMaxWnd + 1;%@NL@%
%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* ArrangeWindows%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function arranges application document windows.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns:%@NL@%
%@AB@%*   TRUE if successful%@NL@%
%@AB@%*   FALSE otherwise%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL ArrangeWindows(USHORT fStyle)%@NL@%
{%@NL@%
    USHORT cswpWnd, cswpIcon;%@NL@%
    RECTL rcl;%@NL@%
    register BOOL fReturn = FALSE;%@NL@%
    SWP NEAR *npswpWnd;%@NL@%
    SWP NEAR *npswpIcon;%@NL@%
%@NL@%
    npswpWnd = (SWP NEAR *) WinAllocMem(hHeap, sizeof(SWP) * cDocs);%@NL@%
    npswpIcon = (SWP NEAR *) WinAllocMem(hHeap, sizeof(SWP) * cDocs);%@NL@%
%@NL@%
    GetArrangeSwp(&cswpWnd, npswpWnd, &cswpIcon, npswpIcon);%@NL@%
%@NL@%
    GetArrangeRectangle((PRECTL)&rcl, (BOOL)cswpIcon);%@NL@%
%@NL@%
    %@AB@%/* set window positions */%@AE@%%@NL@%
    if (!ArrangeWindowPositions((PRECTL)&rcl, cswpWnd, (PSWP)npswpWnd, fStyle) ||%@NL@%
        !ArrangeIconPositions(cswpIcon, (PSWP)npswpIcon)) {%@NL@%
        goto ARRANGE_CLEANUP;%@NL@%
    }%@NL@%
%@NL@%
%@AI@%#if %@AE@%1 %@NL@%
    %@AB@%/* rearrange the windows */%@AE@%%@NL@%
    WinSetMultWindowPos(NULL, (PSWP)npswpWnd, cswpWnd);%@NL@%
    WinSetMultWindowPos(NULL, (PSWP)npswpIcon, cswpIcon);%@NL@%
%@AI@%#endif %@AE@%%@NL@%
    fReturn = TRUE;%@NL@%
%@NL@%
ARRANGE_CLEANUP:%@NL@%
    WinFreeMem(hHeap, (NPBYTE)npswpWnd, sizeof(SWP) * cDocs);%@NL@%
    WinFreeMem(hHeap, (NPBYTE)npswpIcon, sizeof(SWP) * cDocs);%@NL@%
%@NL@%
    return fReturn;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* GetArrangeHandles%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function generates the handles of all windows to be arranged and%@NL@%
%@AB@%* creates an array of SWP structures containing those handles.  Minimized%@NL@%
%@AB@%* and non-minimized windows are separated.  Non-frame, invisible and%@NL@%
%@AB@%* non-sizeable windows are ignored.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameter:%@NL@%
%@AB@%*   npcswpWnd:        number of nonminimized windows found%@NL@%
%@AB@%*   npswpWnd:         array of SWP structures for nonminimized windows%@NL@%
%@AB@%*   npcswpIcon:       number of minimized windows found%@NL@%
%@AB@%*   npswpIcon:        array of SWP structures for minimized windows%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns:%@NL@%
%@AB@%*   TRUE if successful%@NL@%
%@AB@%*   FALSE otherwise%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL GetArrangeSwp(USHORT *npcswpWnd, SWP *npswpWnd, USHORT *npcswpIcon,%@NL@%
        SWP *npswpIcon)%@NL@%
{%@NL@%
    register USHORT cWnd, cIcon;%@NL@%
    ULONG ulStyle;%@NL@%
    HWND hwnd;%@NL@%
    register NPDOC npdoc;%@NL@%
%@NL@%
    cWnd = 0;%@NL@%
    cIcon = 0;%@NL@%
%@NL@%
    %@AB@%/* enumerate windows and selectively add them to the arrange lists */%@AE@%%@NL@%
    for (hwnd = WinQueryWindow(hwndMDI, QW_TOP, FALSE);%@NL@%
         hwnd;%@NL@%
         hwnd = WinQueryWindow(hwnd, QW_NEXT, FALSE)) {%@NL@%
%@NL@%
        %@AB@%/* make sure the window is visible and owned by the app client window */%@AE@%%@NL@%
        ulStyle = WinQueryWindowULong(hwnd, QWL_STYLE);%@NL@%
        if (WinQueryWindow(hwnd, QW_OWNER, FALSE) ||%@NL@%
            !(ulStyle & WS_VISIBLE)) {%@NL@%
            continue;%@NL@%
        }%@NL@%
%@NL@%
        if (ulStyle & WS_MINIMIZED) {%@NL@%
            npswpIcon->hwnd = hwnd;%@NL@%
            npswpIcon++;%@NL@%
            cIcon++;%@NL@%
        } else {%@NL@%
            %@AB@%/* restore maximized windows */%@AE@%%@NL@%
            if (ulStyle & WS_MAXIMIZED) {%@NL@%
%@NL@%
%@AI@%#ifdef %@AE@%MINMAXFIX %@NL@%
                %@AB@%/* Bring the min/max buttons back to life for a moment so%@NL@%
%@AB@%                   they stay in sync when the window is restored.  Then put%@NL@%
%@AB@%                   them back to the object window 07-Sep-1989 johnba%@NL@%
%@AB@%                */%@AE@%%@NL@%
%@NL@%
                npdoc = NPDOCFROMCLIENT(WinWindowFromID(hwnd,FID_CLIENT));%@NL@%
                WinSetParent(npdoc->hwndMinmax, hwnd, FALSE);%@NL@%
%@AI@%#endif %@AE@%%@NL@%
                WinSetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_RESTORE );%@NL@%
%@AI@%#ifdef %@AE@%MINMAXFIX %@NL@%
%@NL@%
%@NL@%
                if (hwndActiveDoc != hwnd) {%@NL@%
                    WinSetParent(npdoc->hwndMinmax, HWND_OBJECT, FALSE);%@NL@%
                    WinSendMsg(hwnd, WM_UPDATEFRAME, 0L, 0L);%@NL@%
                    }%@NL@%
%@AI@%#endif %@AE@%%@NL@%
                }%@NL@%
            npswpWnd->hwnd = hwnd;%@NL@%
            npswpWnd++;%@NL@%
            cWnd++;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    *npcswpWnd = cWnd;%@NL@%
    *npcswpIcon = cIcon;%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* GetArrangeRectangle%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function determines the area in which task windows are arranged.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameter:%@NL@%
%@AB@%*   prc:        the generated area rectangle%@NL@%
%@AB@%*   fIconPark:        specifies if room should be made for icon parking lot%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns:%@NL@%
%@AB@%*   TRUE if successful%@NL@%
%@AB@%*   FALSE otherwise%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL GetArrangeRectangle(PRECTL prc, BOOL fIconPark)%@NL@%
{%@NL@%
    register USHORT yIcon;%@NL@%
    register SHORT cxBorderInset;%@NL@%
%@NL@%
    %@AB@%/* get dimensions of desktop window */%@AE@%%@NL@%
    WinQueryWindowRect(hwndMDI, prc);%@NL@%
%@NL@%
    cxBorderInset = (SHORT)(WinQuerySysValue(HWND_DESKTOP, SV_CXBYTEALIGN) -%@NL@%
                       WinQuerySysValue(HWND_DESKTOP, SV_CXSIZEBORDER));%@NL@%
    WinInflateRect(NULL, prc, -cxBorderInset, -cxBorderInset * %@NL@%
            (cyBorder / cxBorder));%@NL@%
%@NL@%
    if (fIconPark) {%@NL@%
        %@AB@%/* make room for single row of icon carpark */%@AE@%%@NL@%
        yIcon = LOUSHORT(WinQuerySysValue(HWND_DESKTOP, SV_CYICON));%@NL@%
        prc->yBottom += (yIcon * ICON_PARK_NUM) / ICON_PARK_DENOM;%@NL@%
    }%@NL@%
%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* ArrangeIconPositions%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function sets positions for minimized windows.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   cIcon:        number of icons to position%@NL@%
%@AB@%*   aswp:        array of SetWindowPos structures for those icons%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns:%@NL@%
%@AB@%*   TRUE if successful%@NL@%
%@AB@%*   FALSE otherwise%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL ArrangeIconPositions(USHORT cIcon, PSWP aswpIcon)%@NL@%
{%@NL@%
    register USHORT i;%@NL@%
%@NL@%
    for (i = 0; i < cIcon; i++) {%@NL@%
        aswpIcon[i].x = 0;%@NL@%
        aswpIcon[i].y = 0;%@NL@%
        aswpIcon[i].fs = SWP_MOVE;%@NL@%
    }%@NL@%
%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%AVIO.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\BROWSE\AVBROWSE\AVIO.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    avio.c -- AVIO action routines%@NL@%
%@AB@%%@NL@%
%@AB@%    Implements scrollbars, sets up an AVIO Presentation Space%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@% INCL_AVIO %@NL@%
%@AI@%#define %@AE@%        INCL_DEV %@NL@%
%@AI@%#define %@AE@% INCL_VIO %@NL@%
%@AI@%#define %@AE@% INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@% INCL_WINSYS %@NL@%
%@AI@%#define %@AE@% INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@% INCL_WINTRACKRECT %@NL@%
%@AI@%#define %@AE@% INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@% INCL_WINSCROLLBARS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
<string.h>        %@AB@%/* One strlen() call in the Blast() macro */%@AE@%%@NL@%
"avio.h"        %@AB@%/* Get Avio-prefixed routine prototypes   */%@AE@%%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Constants%@NL@%
%@AB@%*/%@AE@%%@NL@%
char        Blank[2] = { 0x20, 0x07 };        %@AB@%/* <Space> + EGA white attribute */%@AE@%%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Macros to make the code more readable%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AB@%/* Upper and Lower Bound Calculations */%@AE@%%@NL@%
%@AI@%#define %@AE@%       Abs(a)                (((a) > 0) ? (a) : (-(a))) %@NL@%
%@AI@%#define %@AE@%       Min(a,b)        (((a) < (b)) ? (a) : (b)) %@NL@%
%@AI@%#define %@AE@%       Max(a,b)        (((a) > (b)) ? (a) : (b)) %@NL@%
%@AI@%#define %@AE@%LowerBound(pos, disp, lbound) Max(pos - disp, lbound) %@NL@%
%@AI@%#define %@AE@%UpperBound(pos, disp, ubound) Min(pos + disp, ubound) %@NL@%
%@NL@%
%@AB@%/* Scroll Bar Abbreviations */%@AE@%%@NL@%
%@AI@%#define %@AE@%DisableSB(hSB)        WinSetParent(hSB, HWND_OBJECT, TRUE) %@NL@%
%@AI@%#define %@AE@%EnableSB(hSB)         WinSetParent(hSB, hWndFrame,   TRUE) %@NL@%
%@AI@%#define %@AE@%SetScroll(h, pos, max) \ %@NL@%
    WinSendMsg(h, SBM_SETSCROLLBAR, MPFROM2SHORT(pos, 0), MPFROM2SHORT(0, max))%@NL@%
%@NL@%
%@AB@%/* Scrollbar redraw macros */%@AE@%%@NL@%
%@AI@%#define %@AE@%UpdateOn(c, hsb)        if (!(++c)) WinEnableWindowUpdate(hsb, TRUE) %@NL@%
%@AI@%#define %@AE@%UpdateOff(c, hsb)        if (!(c--)) WinEnableWindowUpdate(hsb, FALSE) %@NL@%
%@AI@%#define %@AE@%       UpdateFrame(sb)        \ %@NL@%
        WinSendMsg(hWndFrame, WM_UPDATEFRAME, MPFROMLONG(sb), 0L)%@NL@%
%@NL@%
%@AB@%/* Scrolling Macros */%@AE@%%@NL@%
ClearScreen()        ScrollUp(-1)        %@AB@%/* Scroll up an "infinite" # lines */%@AE@%%@NL@%
%@AI@%#define %@AE@%ScrollDown(n)        VioScrollDn(0, 0, -1, -1, n, Blank, hVPS) %@NL@%
%@AI@%#define %@AE@%ScrollUp(n)        VioScrollUp(0, 0, -1, -1, n, Blank, hVPS) %@NL@%
%@NL@%
%@AB@%/* RectL -> SWP conversion macros */%@AE@%%@NL@%
%@AI@%#define %@AE@%       lcx(r)                ((r.xRight - r.xLeft) + 1) %@NL@%
%@AI@%#define %@AE@%       lcy(r)                ((r.yTop - r.yBottom) + 1) %@NL@%
%@NL@%
%@AB@%/* Miscellaneous macros */%@AE@%%@NL@%
%@AI@%#define %@AE@%Blast(l, x, y)        VioWrtCharStr(l, Min((SHORT) strlen(l), cxChScreen), x, y, hVPS) %@NL@%
%@AI@%#define %@AE@%CalcChars(sPg, sCh) \ %@NL@%
    ((sCh) ? (Max(((sPg) / (sCh)), 0)) : 0)%@NL@%
%@AI@%#define %@AE@%       SetCellSize(h,w) VioSetDeviceCellSize(h, w, hVPS) %@NL@%
%@AI@%#define %@AE@%       Value(value)        WinQuerySysValue(HWND_DESKTOP, value) %@NL@%
%@AB@%/*%@NL@%
%@AB@%    File-Local Variables%@NL@%
%@AB@%*/%@AE@%%@NL@%
HDC        hDC;                %@AB@%/* Device Context */%@AE@%%@NL@%
HVPS        hVPS;                %@AB@%/* Virtual PS */%@AE@%%@NL@%
int        iTopLine;        %@AB@%/* PS Line of window corner */%@AE@%%@NL@%
int        iCurCol;         %@AB@%/* Current column of window corner */%@AE@%%@NL@%
int        cxChPage;        %@AB@%/* Width and height of our window, in characters */%@AE@%%@NL@%
int        cyChPage;%@NL@%
int        iMaxHorz;        %@AB@%/* Scroll bar upper bounds */%@AE@%%@NL@%
int        iMaxVert;        %@NL@%
BOOL        fNeedHorz;        %@AB@%/* Do we need the scroll bars or not? */%@AE@%%@NL@%
BOOL        fNeedVert;%@NL@%
HWND        hWndHorzSB;        %@AB@%/* Window handles of ScrollBar windows */%@AE@%%@NL@%
HWND        hWndVertSB;%@NL@%
extern        HWND        hWndFrame;        %@AB@%/* Client, frame windows */%@AE@%%@NL@%
extern        HWND        hWndClient;%@NL@%
PFNWP        pfnOldClient;        %@AB@%/* Old Client Window Procedure pointer */%@AE@%%@NL@%
PFNWP        pfnOldFrame;        %@AB@%/* Old Frame  Window Procedure pointer */%@AE@%%@NL@%
SHORT        cyChPS;                %@AB@%/* Number of rows in AVIO PS */%@AE@%%@NL@%
SHORT        cxChPS;                %@AB@%/* Number of cols in AVIO PS */%@AE@%%@NL@%
SHORT        cyChScreen;                %@AB@%/* Number of rows in display space */%@AE@%%@NL@%
SHORT        cxChScreen;                %@AB@%/* Number of cols in display space */%@AE@%%@NL@%
PFNQL        pfnQueryLine;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Measurements used to help make the window look nice%@NL@%
%@AB@%*/%@AE@%%@NL@%
LONG        cxConstant, cyConstant;                        %@AB@%/* Miscellaneous frame lens */%@AE@%%@NL@%
int        cxMaxFrame, cyMaxFrame;                        %@AB@%/* Maximum frame widths */%@AE@%%@NL@%
LONG        lChWidth,   lChHeight;%@NL@%
SHORT        cxMaxClient, cyMaxClient;                %@AB@%/* Client area bounds  */%@AE@%%@NL@%
BOOL        fCreatedPS;                                %@AB@%/* AVIO PS created */%@AE@%%@NL@%
int        cHUpdate = -1;                                %@AB@%/* Keep track of updates */%@AE@%%@NL@%
int        cVUpdate = -1;%@NL@%
%@AB@%/*%@NL@%
%@AB@%   Local prototypes%@NL@%
%@AB@%*/%@AE@%%@NL@%
void FixScroll(BOOL, BOOL, HWND, ULONG, int *, int, int *);%@NL@%
void UpdateScrollBars(RECTL);%@NL@%
void Refresh(void);%@NL@%
void Update(USHORT, USHORT, USHORT);%@NL@%
%@AB@%/*%@NL@%
%@AB@%    The actual routines%@NL@%
%@AB@%*/%@AE@%%@NL@%
void AvioInit(PLBINFO plbi) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Initialize Presentation Space, Device Context, Scroll Bars%@NL@%
%@AB@%*/%@AE@%%@NL@%
    VIOCURSORINFO vci;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Initialize the line buffer info %@NL@%
%@AB@%    */%@AE@%%@NL@%
    cyChScreen        = plbi->sRows;%@NL@%
    cxChScreen        = plbi->sCols;%@NL@%
    cyChPS        = plbi->sPSrows;%@NL@%
    cxChPS        = plbi->sPScols;%@NL@%
    pfnQueryLine = plbi->pfnQL;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        One Time Initializations...%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (!fCreatedPS) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%           Create the AVIO Presentation Space, with one attribute byte%@NL@%
%@AB@%        */%@AE@%%@NL@%
        hDC = WinOpenWindowDC(hWndClient);        %@AB@%/* Open the device context */%@AE@%%@NL@%
        VioCreatePS(&hVPS, cyChPS, cxChPS + 1, 0, 1, 0);%@NL@%
        VioAssociate(hDC, hVPS);                %@AB@%/* Link the PS with the DC */%@AE@%%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Turn off the cursor (set invisible attribute)%@NL@%
%@AB@%        */%@AE@%%@NL@%
        VioGetCurType(&vci, hVPS);%@NL@%
        vci.attr = -1;%@NL@%
        VioSetCurType(&vci, hVPS);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Measure the frame components%@NL@%
%@AB@%        */%@AE@%%@NL@%
        cxConstant = 0;%@NL@%
        cyConstant = Value(SV_CYTITLEBAR) + Value(SV_CYMENU);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Snag scroll bar info%@NL@%
%@AB@%        */%@AE@%%@NL@%
        hWndHorzSB        = WinWindowFromID(hWndFrame,  FID_HORZSCROLL);%@NL@%
        hWndVertSB        = WinWindowFromID(hWndFrame,  FID_VERTSCROLL);%@NL@%
        fNeedHorz        = fNeedVert        = TRUE;%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Setup the Client and Frame routines%@NL@%
%@AB@%        */%@AE@%%@NL@%
        pfnOldFrame        = WinSubclassWindow(hWndFrame,  AvioFrameWndProc);%@NL@%
        pfnOldClient        = WinSubclassWindow(hWndClient, AvioClientWndProc);%@NL@%
        fCreatedPS        = TRUE;%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Repaint the screen%@NL@%
%@AB@%    */%@AE@%%@NL@%
    iTopLine = iCurCol = 0;%@NL@%
    AvioStartup(plbi->fLargeFont);%@NL@%
}%@NL@%
%@NL@%
void AvioStartup(BOOL fLargeFont) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Clear the screen, set the font, redraw the area%@NL@%
%@AB@%*/%@AE@%%@NL@%
    RECTL rclFrame;%@NL@%
%@NL@%
    ClearScreen();%@NL@%
    AvioLargeFont(fLargeFont);%@NL@%
    WinQueryWindowRect(hWndFrame, &rclFrame);%@NL@%
    UpdateScrollBars(rclFrame);%@NL@%
    Update(0, cyChPS, 0);%@NL@%
}%@NL@%
%@NL@%
void AvioScroll(USHORT SB_Command, USHORT Position, BOOL Horizontal) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Process the scroll bar messages%@NL@%
%@AB@%%@NL@%
%@AB@%    These routines are symmetric; in fact, SB_LINELEFT = SB_LINEUP, etc...%@NL@%
%@AB@%    so one might note that this could be condensed.  It's left expanded for%@NL@%
%@AB@%    speed and clarity.  The scrollbar values are bounded to stay inside%@NL@%
%@AB@%    the Presentation Space.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (Horizontal) {  %@AB@%/* Horizontal Scroll Bar */%@AE@%%@NL@%
        switch (SB_Command) {%@NL@%
            case SB_LINELEFT:%@NL@%
                iCurCol = LowerBound(iCurCol, 1, 0); break;%@NL@%
            case SB_LINERIGHT:%@NL@%
                iCurCol = UpperBound(iCurCol, 1, iMaxHorz); break;%@NL@%
            case SB_PAGELEFT:%@NL@%
                iCurCol = LowerBound(iCurCol, cxChPage, 0); break;%@NL@%
            case SB_PAGERIGHT:%@NL@%
                iCurCol = UpperBound(iCurCol, cxChPage, iMaxHorz); break;%@NL@%
            case SB_SLIDERTRACK:%@NL@%
                iCurCol = (SHORT) Position;%@NL@%
            default: break;%@NL@%
        }%@NL@%
        if (SB_Command != SB_SLIDERTRACK)%@NL@%
            SetScroll(hWndHorzSB, iCurCol, iMaxHorz);%@NL@%
%@NL@%
    } else { %@AB@%/* Vertical Scroll Bar */%@AE@%%@NL@%
        switch (SB_Command) {%@NL@%
            case SB_LINEUP:%@NL@%
                iTopLine = LowerBound(iTopLine, 1, 0); break;%@NL@%
            case SB_LINEDOWN:%@NL@%
                iTopLine = UpperBound(iTopLine, 1, iMaxVert); break;%@NL@%
            case SB_PAGEUP:%@NL@%
                iTopLine = LowerBound(iTopLine, cyChPage, 0); break;%@NL@%
            case SB_PAGEDOWN:%@NL@%
                iTopLine = UpperBound(iTopLine, cyChPage, iMaxVert);break;%@NL@%
            case SB_SLIDERTRACK:%@NL@%
                iTopLine = (SHORT) Position;%@NL@%
            default: break;%@NL@%
        }%@NL@%
        if (SB_Command != SB_SLIDERTRACK)%@NL@%
            SetScroll(hWndVertSB, iTopLine, iMaxVert);%@NL@%
    }%@NL@%
    Refresh();%@NL@%
}%@NL@%
%@NL@%
MRESULT AvioSize(HWND hWnd, USHORT msg, MPARAM mp1, MPARAM mp2) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Do the default AVIO sizing, and kyfe a few values%@NL@%
%@AB@%*/%@AE@%%@NL@%
    RECTL rclFrame;%@NL@%
%@NL@%
    if (!fCreatedPS) return 0L;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Update the scroll bars, and the screen%@NL@%
%@AB@%    */%@AE@%%@NL@%
    WinQueryWindowRect(hWndFrame, &rclFrame);%@NL@%
    UpdateScrollBars(rclFrame);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Now, do the normal AVIO processing%@NL@%
%@AB@%    */%@AE@%%@NL@%
    return WinDefAVioWindowProc(hWnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
void Update(USHORT usLineNum, USHORT usHowMany, USHORT usStartLine) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Updates N lines starting from START line on screen.%@NL@%
%@AB@%    Starts at saved line LINENUM.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    USHORT        i;                                %@AB@%/* Loop index variable */%@AE@%%@NL@%
    USHORT        usWhichLine = usLineNum;        %@AB@%/* Line number to be queried */%@AE@%%@NL@%
    char        *szLine;%@NL@%
%@NL@%
    for (i = usStartLine; i < (usStartLine + usHowMany); i++) {%@NL@%
        szLine = (*pfnQueryLine)(usWhichLine++);        %@AB@%/* Get the line */%@AE@%%@NL@%
        if (szLine) Blast(szLine, i, 0);                %@AB@%/* Print it out */%@AE@%%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
void Refresh(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Do the origin shifting and screen updating%@NL@%
%@AB@%*/%@AE@%%@NL@%
    SHORT  Delta;%@NL@%
    int static iOldTopLine = 0;%@NL@%
%@NL@%
    VioSetOrg(0, iCurCol, hVPS); %@AB@%/* Get the free AVIO horizontal shift */%@AE@%%@NL@%
    Delta = iTopLine - iOldTopLine; %@AB@%/* Compute vertical shift */%@AE@%%@NL@%
    if (Abs(Delta) < cyChPS) {%@NL@%
        if (Delta < 0) {         %@AB@%/* Scroll Up -- make Delta positive*/%@AE@%%@NL@%
            ScrollDown(-Delta);%@NL@%
            Update(iTopLine, -Delta, 0);%@NL@%
        } else {                %@AB@%/* Scroll Down by Delta */%@AE@%%@NL@%
            ScrollUp(Delta);%@NL@%
            Update(iTopLine + cyChPS - Delta, Delta, cyChPS - Delta);%@NL@%
        }%@NL@%
    } else AvioRedraw();        %@AB@%/* Redo the entire screen */%@AE@%%@NL@%
    iOldTopLine = iTopLine;%@NL@%
}%@NL@%
%@NL@%
void AvioClose(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Termination routines%@NL@%
%@AB@%*/%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Destroy the Presentation Space%@NL@%
%@AB@%    */%@AE@%%@NL@%
    VioAssociate(NULL, hVPS);%@NL@%
    VioDestroyPS(hVPS);%@NL@%
    fCreatedPS = FALSE;%@NL@%
}%@NL@%
%@NL@%
void AvioPaint(HWND hWnd) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Paint the AVIO presentation space by telling it to show itself.%@NL@%
%@AB@%    A possible optimization here is to repaint only the update region.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    static HPS         hPS;%@NL@%
    static RECTL RectL;%@NL@%
%@NL@%
    hPS = WinBeginPaint(hWnd, (HPS) NULL, &RectL);%@NL@%
    VioShowPS(cyChPS, cxChPS, 0, hVPS);%@NL@%
    WinEndPaint(hPS);%@NL@%
} %@NL@%
%@NL@%
MRESULT AvioMinMax(PSWP pSWP) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Handle WM_MINMAX messages, to make sure frame doesn't get too big%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (pSWP->fs & (SWP_MAXIMIZE | SWP_RESTORE)) {%@NL@%
        if (pSWP->fs & SWP_MAXIMIZE) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Save cx, cy values for later origin displacement%@NL@%
%@AB@%            */%@AE@%%@NL@%
            int Oldcx = pSWP->cx;%@NL@%
            int Oldcy = pSWP->cy;%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Displace, and change to maximum size%@NL@%
%@AB@%            */%@AE@%%@NL@%
            pSWP->x += (Oldcx -%@NL@%
                (pSWP->cx = cxMaxFrame + (int) (Value(SV_CXSIZEBORDER) << 1)));%@NL@%
            pSWP->y += (Oldcy -%@NL@%
                (pSWP->cy = cyMaxFrame + (int) (Value(SV_CYSIZEBORDER) << 1)));%@NL@%
        }%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Now, fix the scroll bars%@NL@%
%@AB@%        */%@AE@%%@NL@%
        AvioAdjustFramePos(pSWP);%@NL@%
        return (MRESULT) TRUE;%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
void AvioClear(void) { ClearScreen(); }%@NL@%
%@NL@%
void AvioAdjustFramePos(PSWP pSWP) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Trap WM_ADJUSTWINDOWPOS messages to the frame with this routine.%@NL@%
%@AB@%    Keep the window sized right, and control scrollbar visibility.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    RECTL rclFrame;%@NL@%
%@NL@%
    if (!(pSWP->cx && pSWP->cy)) return;         %@AB@%/* Null area... */%@AE@%%@NL@%
    if (pSWP->fs & SWP_MINIMIZE) return;        %@AB@%/* Iconic... */%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Make sure the dimensions are in range%@NL@%
%@AB@%    */%@AE@%%@NL@%
    pSWP->cx = Min(pSWP->cx, (cxMaxFrame + (SHORT)(Value(SV_CXSIZEBORDER)<<1)));%@NL@%
    pSWP->cy = Min(pSWP->cy, (cyMaxFrame + (SHORT)(Value(SV_CYSIZEBORDER)<<1)));%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Update the scroll bars%@NL@%
%@AB@%    */%@AE@%%@NL@%
    rclFrame.xLeft        = (LONG) pSWP->x;%@NL@%
    rclFrame.xRight        = (LONG) (pSWP->x + pSWP->cx - 1);%@NL@%
    rclFrame.yBottom        = (LONG) pSWP->y;%@NL@%
    rclFrame.yTop        = (LONG) (pSWP->y + pSWP->cy - 1);%@NL@%
    UpdateScrollBars(rclFrame);%@NL@%
%@NL@%
    return; %@NL@%
}%@NL@%
%@NL@%
void AvioTrackFrame(HWND hWnd, MPARAM mpTrackFlags) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Takes action on WM_TRACKFRAME message%@NL@%
%@AB@%*/%@AE@%%@NL@%
    static TRACKINFO tiTrackInfo;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Get the tracking information in the TrackInfo structure%@NL@%
%@AB@%    */%@AE@%%@NL@%
    WinSendMsg(hWnd, WM_QUERYTRACKINFO, mpTrackFlags, &tiTrackInfo);%@NL@%
    WinTrackRect(hWnd, NULL, &tiTrackInfo);%@NL@%
}%@NL@%
%@NL@%
void AvioQueryTrackInfo(PTRACKINFO pTI) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Routine which processes WM_QUERYTRACKINFO messages to the frame.%@NL@%
%@AB@%    Call this routine after the default one to change various parameters.%@NL@%
%@AB@%%@NL@%
%@AB@%    Note:  In reality, since we have a menu bar, we should make the%@NL@%
%@AB@%    minimum width of the window something such that it does not "fold."%@NL@%
%@AB@%*/%@AE@%%@NL@%
    BOOL fMove;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Get the grid set up for byte alignment (unless moving)%@NL@%
%@AB@%%@NL@%
%@AB@%        cxGrid is set to half character width so that arrow keys%@NL@%
%@AB@%        will function when sizing (they try to size by half a%@NL@%
%@AB@%        character)%@NL@%
%@AB@%    */%@AE@%%@NL@%
    fMove = ((pTI->fs & TF_MOVE) == TF_MOVE);%@NL@%
    pTI->fs     |= TF_GRID;%@NL@%
    pTI->cxGrid  = (fMove) ? 1 : ((SHORT) lChWidth);%@NL@%
    pTI->cyGrid  = (fMove) ? 1 : ((SHORT) lChHeight);%@NL@%
    pTI->cxKeyboard        =        (SHORT) lChWidth;%@NL@%
    pTI->cyKeyboard        =        (SHORT) lChHeight;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Bound the frame.%@NL@%
%@AB@%        Maximum:        Sizing Border, Scrollbars, Title, Menus, client region%@NL@%
%@AB@%    */%@AE@%%@NL@%
    pTI->ptlMaxTrackSize.x = (LONG) (pTI->cxBorder << 1) + (LONG) cxMaxFrame;%@NL@%
    pTI->ptlMaxTrackSize.y = (LONG) (pTI->cyBorder << 1) + (LONG) cyMaxFrame;%@NL@%
}%@NL@%
%@NL@%
void AvioRedraw(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Clear, then redraw the entire Presentation Space%@NL@%
%@AB@%*/%@AE@%%@NL@%
    ClearScreen();%@NL@%
    Update(iTopLine, cyChPS, 0);%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK AvioClientWndProc%@NL@%
        (HWND hWnd, USHORT msg, MPARAM mp1, MPARAM mp2) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%     Window Procedure which traps messages to the Client area%@NL@%
%@AB@%*/%@AE@%%@NL@%
     switch (msg) {%@NL@%
          case WM_PAINT:                %@AB@%/* Paint the AVIO way! */%@AE@%%@NL@%
                AvioPaint(hWnd);%@NL@%
                break;%@NL@%
%@NL@%
          case WM_SIZE:                        %@AB@%/* Size the AVIO way!  */%@AE@%%@NL@%
                return AvioSize(hWnd, msg, mp1, mp2);%@NL@%
                break;%@NL@%
%@NL@%
          case WM_HSCROLL:%@NL@%
                AvioScroll(HIUSHORT(mp2), LOUSHORT(mp2), TRUE);%@NL@%
                break;%@NL@%
%@NL@%
          case WM_VSCROLL:%@NL@%
                AvioScroll(HIUSHORT(mp2), LOUSHORT(mp2), FALSE);%@NL@%
                break;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
                break;%@NL@%
%@NL@%
          case WM_TRACKFRAME:%@NL@%
                AvioTrackFrame(hWnd, mp1);%@NL@%
                break;%@NL@%
%@NL@%
          case WM_MINMAXFRAME:                %@AB@%/* Limit Maximized window size */%@AE@%%@NL@%
                AvioMinMax((PSWP) mp1);%@NL@%
%@NL@%
                %@AB@%/* fall through */%@AE@%%@NL@%
%@NL@%
          default: return (*pfnOldClient)(hWnd, msg, mp1, mp2);%@NL@%
     }%@NL@%
     return 0;%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK AvioFrameWndProc(HWND hWnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Force the frame to stay small enough (no larger than the PS)%@NL@%
%@AB@%*/%@AE@%%@NL@%
{%@NL@%
    BOOL rc;                %@AB@%/* Return code from WM_QUERYTRACKINFO */%@AE@%%@NL@%
%@NL@%
    switch(msg) {%@NL@%
        case WM_ADJUSTWINDOWPOS:        %@AB@%/* Calculate scroll bar adjustments */%@AE@%%@NL@%
            AvioAdjustFramePos(mp1);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_QUERYTRACKINFO:                %@AB@%/* Get default, then process message */%@AE@%%@NL@%
            rc = (BOOL) SHORT1FROMMR((*pfnOldFrame)(hWnd, msg, mp1, mp2));%@NL@%
            AvioQueryTrackInfo((PTRACKINFO) mp2);%@NL@%
            return (MRESULT) rc;%@NL@%
%@NL@%
        default: break;%@NL@%
    }%@NL@%
    return (*pfnOldFrame)(hWnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
void UpdateScrollBars(RECTL rclClient) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    This routine fixes up the scroll bars when the window is resized, or%@NL@%
%@AB@%    when the font size is changed.%@NL@%
%@AB@%%@NL@%
%@AB@%    Parameters:        The dimensions of the frame window%@NL@%
%@AB@%    Result:        Updates the scrollbars, enabling/disabling as needed%@NL@%
%@AB@%*/%@AE@%%@NL@%
    BOOL    fNeededHorz = fNeedHorz;  %@AB@%/* Did we need the scrollbars then? */%@AE@%%@NL@%
    BOOL    fNeededVert = fNeedVert;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Compute the client rectangle, without the scrollbars%@NL@%
%@AB@%    */%@AE@%%@NL@%
    WinCalcFrameRect(hWndFrame, &rclClient, TRUE);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Compute page width -- do we need the horizontal scroll bar?%@NL@%
%@AB@%    */%@AE@%%@NL@%
    cxChPage         = (int) CalcChars(lcx(rclClient), lChWidth);%@NL@%
    fNeedHorz = ((iMaxHorz = Max(cxChScreen - cxChPage,  0)) > 0);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Compute page height -- do we need the vertical scroll bar?%@NL@%
%@AB@%    */%@AE@%%@NL@%
    cyChPage         = (int) CalcChars(lcy(rclClient), lChHeight);%@NL@%
    fNeedVert = ((iMaxVert = Max(cyChScreen - cyChPage, 0)) > 0);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Maintain scrollbar integrity%@NL@%
%@AB@%    */%@AE@%%@NL@%
    iCurCol        = Min(iCurCol, iMaxHorz);%@NL@%
    iTopLine        = Min(iTopLine, iMaxVert);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Now, update the scrollbars as necessary%@NL@%
%@AB@%    */%@AE@%%@NL@%
    FixScroll(fNeededHorz, fNeedHorz, hWndHorzSB,%@NL@%
              FCF_HORZSCROLL, &iCurCol, iMaxHorz, &cHUpdate);%@NL@%
%@NL@%
    FixScroll(fNeededVert, fNeedVert, hWndVertSB,%@NL@%
              FCF_VERTSCROLL, &iTopLine, iMaxVert, &cVUpdate);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Now, update the screen to be visually consistent%@NL@%
%@AB@%    */%@AE@%%@NL@%
    Refresh();%@NL@%
}%@NL@%
%@NL@%
void FixScroll(fNeeded, fNeed, hWnd, flScroll, piPos, iMax, pc)%@NL@%
%@AB@%/*%@NL@%
%@AB@%    This routine makes the necessary scrollbar adjustments, and%@NL@%
%@AB@%    also enables/disables them.%@NL@%
%@AB@%*/%@AE@%%@NL@%
BOOL        fNeeded;            %@AB@%/* Whether we used to need the scrollbar */%@AE@%%@NL@%
BOOL        fNeed;                    %@AB@%/* Whether we need the scrollbar now */%@AE@%%@NL@%
HWND        hWnd;                    %@AB@%/* Handle to the scrollbar window */%@AE@%%@NL@%
ULONG        flScroll;            %@AB@%/* FCF_xxxxSCROLL flag (for the scrollbar) */%@AE@%%@NL@%
int        *piPos;             %@AB@%/* Current location of scrollbar thumb */%@AE@%%@NL@%
int        iMax;                    %@AB@%/* New maximum for the scrollbar */%@AE@%%@NL@%
int        *pc;                    %@AB@%/* Counter for WinEnableWindowUpdate recursion */%@AE@%%@NL@%
{%@NL@%
    if (fNeed) {    %@AB@%/* Enable the scroll bar -- we didn't need it before */%@AE@%%@NL@%
        if (!fNeeded) {%@NL@%
            EnableSB(hWnd);%@NL@%
            UpdateOff((*pc), hWnd);%@NL@%
            UpdateFrame(flScroll);%@NL@%
            UpdateOn((*pc), hWnd);%@NL@%
        }%@NL@%
        SetScroll(hWnd, (*piPos) = Min((*piPos), iMax), iMax);%@NL@%
    } else {            %@AB@%/* Disable the scroll bar, we no longer need it */%@AE@%%@NL@%
        if (fNeeded) {%@NL@%
            DisableSB(hWnd);%@NL@%
            UpdateOff((*pc), hWnd);%@NL@%
            UpdateFrame(flScroll);%@NL@%
            UpdateOn((*pc), hWnd);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
void AvioLargeFont(BOOL fLargeFont) {%@NL@%
    static BOOL fFirst = TRUE;                                    // Need to init?%@NL@%
    static LONG lSmallHt, lSmallWd, lLargeHt, lLargeWd;     // Font sizes%@NL@%
    SWP swp;%@NL@%
%@NL@%
    if (fFirst) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            The first time through, get the small and large font sizes%@NL@%
%@AB@%        */%@AE@%%@NL@%
        DevQueryCaps(hDC, CAPS_CHAR_HEIGHT,                1L, &lLargeHt);%@NL@%
        DevQueryCaps(hDC, CAPS_CHAR_WIDTH,                1L, &lLargeWd);%@NL@%
        DevQueryCaps(hDC, CAPS_SMALL_CHAR_HEIGHT,        1L, &lSmallHt);%@NL@%
        DevQueryCaps(hDC, CAPS_SMALL_CHAR_WIDTH,        1L, &lSmallWd);%@NL@%
        fFirst = FALSE;%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Set the character size with VioSetDeviceCellSize%@NL@%
%@AB@%    */%@AE@%%@NL@%
    SetCellSize( (SHORT) (lChHeight = ((fLargeFont) ? lLargeHt : lSmallHt)),%@NL@%
                 (SHORT) (lChWidth  = ((fLargeFont) ? lLargeWd : lSmallWd)) );%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Compute maximum size of client area%@NL@%
%@AB@%    */%@AE@%%@NL@%
    cxMaxClient        = (cxChPS * (SHORT) lChWidth);%@NL@%
    cxMaxFrame        = cxMaxClient + (SHORT) cxConstant;%@NL@%
    cyMaxClient = (cyChPS * (SHORT) lChHeight);%@NL@%
    cyMaxFrame  = cyMaxClient + (SHORT) cyConstant;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Send a WM_ADJUSTFRAMEPOS message%@NL@%
%@AB@%    */%@AE@%%@NL@%
    WinQueryWindowPos(hWndFrame, &swp);%@NL@%
    if (swp.fs & SWP_MAXIMIZE) {%@NL@%
        AvioMinMax(&swp);%@NL@%
        WinSetMultWindowPos(hWndFrame, &swp, 1);%@NL@%
    } else {%@NL@%
        swp.fs = SWP_ACTIVATE | SWP_MOVE | SWP_SHOW | SWP_SIZE;%@NL@%
        WinSetWindowPos(hWndFrame, NULL, swp.x, swp.y,%@NL@%
            Min(cxMaxFrame, swp.cx), Min(cyMaxFrame, swp.cy), swp.fs);%@NL@%
    }%@NL@%
    AvioAdjustFramePos(&swp);                %@AB@%/* Fix up the frame, scroll bars */%@AE@%%@NL@%
    AvioPaint(hWndClient);                %@AB@%/* Repaint with new characters   */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%AVIO.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\COMTALK\AVIO.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%        avio.c -- AVIO handling routines%@NL@%
%@AB@%        For a cleaner implementation, look at the BROWSE application.%@NL@%
%@AB@%%@NL@%
%@AB@%        Implements scrollbars, sets up an AVIO Presentation Space%@NL@%
%@AB@%        Intrinsically linked with a circular queue routine%@NL@%
%@AB@%%@NL@%
%@AB@%        Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@% INCL_AVIO %@NL@%
%@AI@%#define %@AE@%        INCL_DEV %@NL@%
%@AI@%#define %@AE@% INCL_VIO %@NL@%
%@AI@%#define %@AE@%        INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"global.h" %@NL@%
"circleq.h"        %@AB@%/* Get Circular Buffer routines */%@AE@%%@NL@%
"avio.h"        %@AB@%/* Prototype our routines */%@AE@%%@NL@%
<stdio.h>        %@AB@%/* Needed to open LOG file */%@AE@%%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Constants%@NL@%
%@AB@%*/%@AE@%%@NL@%
AVIO_PS_ROWS        25        %@AB@%/* Dimensions of the AVIO PS */%@AE@%%@NL@%
%@AI@%#define %@AE@%AVIO_PS_COLUMNS        MAXLINELEN %@NL@%
       CATTRBYTES        1        %@AB@%/* 1 or 3 attribute bytes/cell */%@AE@%%@NL@%
       DEFPAGEWIDTH        5        %@AB@%/* Default pagesizes */%@AE@%%@NL@%
%@AI@%#define %@AE@%       DEFPAGEHEIGHT        5 %@NL@%
%@NL@%
char        Blank[2] = { 0x20, 0x07 };%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Macros to make the code more readable%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AB@%/* Upper and Lower Bound Calculations */%@AE@%%@NL@%
%@AI@%#define %@AE@%       Abs(a)                (((a) > 0) ? (a) : (-(a))) %@NL@%
%@AI@%#define %@AE@%LowerBound(pos, disp, lbound) Max(pos - disp, lbound) %@NL@%
%@AI@%#define %@AE@%UpperBound(pos, disp, ubound) Min(pos + disp, ubound) %@NL@%
%@NL@%
%@AB@%/* Scroll Bar Abbreviations */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%       DisableSB(hSB)        WinSetParent(hSB,  HWND_OBJECT, FALSE) %@NL@%
%@AI@%#define %@AE@%       EnableSB(hSB)        WinSetParent(hSB, hWndSBParent, FALSE) %@NL@%
%@AI@%#define %@AE@%       HBarHeight()        (fNeedHorz ? lHSBHeight : 0L) %@NL@%
%@AI@%#define %@AE@%       VBarWidth()        (fNeedVert ? lVSBWidth  : 0L) %@NL@%
%@AI@%#define %@AE@%SetScroll(h, pos, max) \ %@NL@%
    WinSendMsg(h, SBM_SETSCROLLBAR, MPFROM2SHORT(pos, 0), MPFROM2SHORT(0, max))%@NL@%
%@AI@%#define %@AE@%       UpdateFrame(sb)        \ %@NL@%
    WinSendMsg(hWndSBParent, WM_UPDATEFRAME, MPFROMLONG(sb), 0L)%@NL@%
%@AI@%#define %@AE@%       UpdateOff(w)        WinEnableWindowUpdate(w, FALSE) %@NL@%
%@AI@%#define %@AE@%       UpdateOn(w)        WinEnableWindowUpdate(w, TRUE) %@NL@%
%@NL@%
%@AB@%/* Scrolling Macros */%@AE@%%@NL@%
%@AI@%#define %@AE@%       ClearScreen()        ScrollUp(-1) %@NL@%
%@AI@%#define %@AE@%ScrollDown(n)        VioScrollDn(0, 0, -1, -1, n, Blank, hVPS) %@NL@%
%@AI@%#define %@AE@%       ScrollUp(n)        VioScrollUp(0, 0, -1, -1, n, Blank, hVPS) %@NL@%
%@AI@%#define %@AE@%       SetCursor(x, y)        VioSetCurPos((USHORT) x, (USHORT) y, hVPS) %@NL@%
%@NL@%
%@AB@%/* Miscellaneous */%@AE@%%@NL@%
%@AB@%/*%@NL@%
%@AB@%    If partial ANSI emulation is desired, use:%@NL@%
%@AB@%        VioSetCurPos((USHORT) x, (USHORT) y, hVPS); \%@NL@%
%@AB@%        VioWrtTTY(l->szText, l->cch, hVPS)%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%Blast(l, x, y)        VioWrtCharStr(l->szText, l->cch, x, y, hVPS) %@NL@%
%@AB@%/*%@NL@%
%@AB@%    Calculate the number of characters in a page%@NL@%
%@AB@%    For nicer behavior, you can do rounding here%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%CalcChars(pPg, pCh, default) \ %@NL@%
        ((pCh) ? (Max((int) ((pPg) / ((SHORT) pCh)), 0)) : (default))%@NL@%
%@AI@%#define %@AE@%       Value(value)        WinQuerySysValue(HWND_DESKTOP, value) %@NL@%
%@AB@%/*%@NL@%
%@AB@%    File-Local Variables%@NL@%
%@AB@%*/%@AE@%%@NL@%
HDC        hDC;                %@AB@%/* Device Context */%@AE@%%@NL@%
HVPS        hVPS;                %@AB@%/* Virtual PS */%@AE@%%@NL@%
int        iTopLine;        %@AB@%/* PS Line of window corner */%@AE@%%@NL@%
int        iCurCol;         %@AB@%/* Current column of window corner */%@AE@%%@NL@%
int        cchPgWidth;        %@AB@%/* Width and height of our window */%@AE@%%@NL@%
int        cchPgHeight;%@NL@%
int        cchMaxHorz;        %@AB@%/* Scroll bar upper bounds */%@AE@%%@NL@%
int        cchMaxVert;        %@NL@%
BOOL        fNeedHorz;        %@AB@%/* Do we need the scroll bars or not? */%@AE@%%@NL@%
BOOL        fNeedVert;%@NL@%
HWND        hWndHScroll;        %@AB@%/* Window handles of ScrollBar windows */%@AE@%%@NL@%
HWND        hWndVScroll;%@NL@%
HWND        hWndSBParent;        %@AB@%/* Could mooch off the value in main(), but won't */%@AE@%%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Measurements used to help make the window look nice%@NL@%
%@AB@%*/%@AE@%%@NL@%
LONG        lChWidth,   lChHeight;                        %@AB@%/* Character size */%@AE@%%@NL@%
LONG        lHSBHeight, lVSBWidth;                        %@AB@%/* Scrollbar measurements */%@AE@%%@NL@%
LONG        lMiscWidth, lMiscHeight;                %@AB@%/* Border, titlebar, ... */%@AE@%%@NL@%
int        iMaxWidth,  iMaxHeight;                        %@AB@%/* Client area bounds  */%@AE@%%@NL@%
int        iMaxFrameWidth, iMaxFrameHeight;        %@AB@%/* Frame window bounds */%@AE@%%@NL@%
BOOL        fCreated;                                %@AB@%/* AVIO PS created */%@AE@%%@NL@%
int        rc;                                        %@AB@%/* Return code */%@AE@%%@NL@%
VIOCURSORINFO vci;%@NL@%
%@AB@%/*%@NL@%
%@AB@%   Local prototypes%@NL@%
%@AB@%*/%@AE@%%@NL@%
void GetMeasurements(void);%@NL@%
void Update(USHORT, USHORT, USHORT, BOOL);%@NL@%
void Refresh(BOOL);%@NL@%
void WantCursor(BOOL);%@NL@%
void SetScrollPos(void);%@NL@%
void SetScrollPosHorz(void);%@NL@%
void SetScrollPosVert(void);%@NL@%
%@AB@%/*%@NL@%
%@AB@%    The actual routines%@NL@%
%@AB@%*/%@AE@%%@NL@%
void GetMeasurements(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Get display parameters%@NL@%
%@AB@%*/%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Scroll bar widths and heights%@NL@%
%@AB@%    */%@AE@%%@NL@%
    lHSBHeight        = Value(SV_CYHSCROLL);%@NL@%
    lVSBWidth        = Value(SV_CXVSCROLL);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Non-PS widths and heights%@NL@%
%@AB@%    */%@AE@%%@NL@%
    lMiscHeight        = (Value(SV_CYSIZEBORDER) << 1)        %@AB@%/* A border on each side */%@AE@%%@NL@%
                + Value(SV_CYTITLEBAR)                %@AB@%/* The title bar...      */%@AE@%%@NL@%
                + Value(SV_CYMENU)                %@AB@%/* ...and the menu bar   */%@AE@%%@NL@%
                + Value(SV_CYBYTEALIGN);        %@AB@%/* ...and alignment         */%@AE@%%@NL@%
                %@NL@%
    lMiscWidth        = (Value(SV_CXSIZEBORDER) << 1);%@AB@%/* A border on each side */%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Height and width of characters%@NL@%
%@AB@%    */%@AE@%%@NL@%
    rc = DevQueryCaps(hDC, CAPS_CHAR_HEIGHT, 1L, &lChHeight);%@NL@%
    rc = DevQueryCaps(hDC, CAPS_CHAR_WIDTH,  1L, &lChWidth);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Compute size of client and frame windows%@NL@%
%@AB@%    */%@AE@%%@NL@%
    iMaxWidth                = (AVIO_PS_COLUMNS        * (int) lChWidth);%@NL@%
    iMaxHeight                = (AVIO_PS_ROWS                * (int) lChHeight);%@NL@%
    iMaxFrameWidth        = (iMaxWidth                + (int) lMiscWidth);%@NL@%
    iMaxFrameHeight        = (iMaxHeight                + (int) lMiscHeight);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Compute cursor attributes%@NL@%
%@AB@%    */%@AE@%%@NL@%
    vci.yStart        = (USHORT) 0;%@NL@%
    vci.cEnd        = (USHORT) lChHeight - 1;%@NL@%
    vci.cx        = 0;%@NL@%
}%@NL@%
%@NL@%
void AvioInit(HWND hWndFrame, HWND hWndClient) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Initialize Presentation Space, Device Context, Scroll Bars%@NL@%
%@AB@%*/%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Create the AVIO Presentation Space%@NL@%
%@AB@%    */%@AE@%%@NL@%
    hDC = WinOpenWindowDC(hWndClient);%@NL@%
    VioCreatePS(&hVPS, AVIO_PS_ROWS, AVIO_PS_COLUMNS, 0, CATTRBYTES, 0);%@NL@%
    VioAssociate(hDC, hVPS);%@NL@%
    fCreated = TRUE;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Turn on the cursor and home it%@NL@%
%@AB@%    */%@AE@%%@NL@%
    WantCursor(TRUE);%@NL@%
    SetCursor(0, 0);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Snag scroll bar info%@NL@%
%@AB@%    */%@AE@%%@NL@%
    hWndHScroll  = WinWindowFromID(hWndFrame,  FID_HORZSCROLL);%@NL@%
    hWndVScroll  = WinWindowFromID(hWndFrame,  FID_VERTSCROLL);%@NL@%
    hWndSBParent = WinQueryWindow(hWndHScroll, QW_PARENT, FALSE);%@NL@%
    fNeedHorz         = fNeedVert  = TRUE;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Get character height in pixels, etc...%@NL@%
%@AB@%    */%@AE@%%@NL@%
    GetMeasurements();%@NL@%
}%@NL@%
%@NL@%
void AvioStartup(HWND hWndClient) {%@NL@%
    SWP swp;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Initialize the queue%@NL@%
%@AB@%    */%@AE@%%@NL@%
    QueInit();%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Initialize the screen%@NL@%
%@AB@%    */%@AE@%%@NL@%
    ClearScreen();%@NL@%
    WinQueryWindowPos(hWndClient, &swp);%@NL@%
    AvioSize(hWndClient, WM_NULL, NULL, MPFROM2SHORT(swp.cx, swp.cy));%@NL@%
}%@NL@%
%@NL@%
void AvioScroll(USHORT SB_Command, USHORT usPosition, BOOL fHorizontal) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Process the scroll bar messages%@NL@%
%@AB@%%@NL@%
%@AB@%    These routines are symmetric; in fact, SB_LINELEFT = SB_LINEUP, etc...%@NL@%
%@AB@%    so one might note that this could be condensed.  It's left expanded for%@NL@%
%@AB@%    speed and clarity.  I bound the values each way so that we stay inside%@NL@%
%@AB@%    the AVIO presentation space.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (fHorizontal) {  %@AB@%/* Horizontal Scroll Bar */%@AE@%%@NL@%
        switch (SB_Command) {%@NL@%
            case SB_LINELEFT:%@NL@%
                iCurCol = LowerBound(iCurCol, 1, 0); break;%@NL@%
            case SB_LINERIGHT:%@NL@%
                iCurCol = UpperBound(iCurCol, 1, cchMaxHorz); break;%@NL@%
            case SB_PAGELEFT:%@NL@%
                iCurCol = LowerBound(iCurCol, cchPgWidth, 0); break;%@NL@%
            case SB_PAGERIGHT:%@NL@%
                iCurCol = UpperBound(iCurCol, cchPgWidth, cchMaxHorz); break;%@NL@%
            case SB_SLIDERTRACK:%@NL@%
                iCurCol = (SHORT) usPosition;%@NL@%
            default: break;%@NL@%
        }%@NL@%
        if (SB_Command != SB_SLIDERTRACK)%@NL@%
            SetScroll(hWndHScroll, iCurCol, cchMaxHorz);%@NL@%
%@NL@%
    } else { %@AB@%/* Vertical Scroll Bar */%@AE@%%@NL@%
        switch (SB_Command) {%@NL@%
            case SB_LINEUP:%@NL@%
                iTopLine = LowerBound(iTopLine, 1, 0); break;%@NL@%
            case SB_LINEDOWN:%@NL@%
                iTopLine = UpperBound(iTopLine, 1, cchMaxVert); break;%@NL@%
            case SB_PAGEUP:%@NL@%
                iTopLine = LowerBound(iTopLine, cchPgHeight, 0); break;%@NL@%
            case SB_PAGEDOWN:%@NL@%
                iTopLine = UpperBound(iTopLine, cchPgHeight, cchMaxVert); break;%@NL@%
            case SB_SLIDERTRACK:%@NL@%
                iTopLine = (SHORT) usPosition;%@NL@%
            default: break;%@NL@%
        }%@NL@%
        if (SB_Command != SB_SLIDERTRACK)%@NL@%
            SetScroll(hWndVScroll, iTopLine, cchMaxVert);%@NL@%
    }%@NL@%
    Refresh(FALSE);%@NL@%
}%@NL@%
%@NL@%
MRESULT AvioSize(HWND hWnd, USHORT msg, MPARAM mp1, MPARAM mp2) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Do the default AVIO sizing, and kyfe a few values%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (!fCreated) return 0L;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Compute height and width of page in characters%@NL@%
%@AB@%%@NL@%
%@AB@%        The scrollbars have already been subtracted out,%@NL@%
%@AB@%        since we are called by the client area.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    cchPgHeight = CalcChars(SHORT2FROMMP(mp2), lChHeight, DEFPAGEHEIGHT); %@NL@%
    cchPgWidth  = CalcChars(SHORT1FROMMP(mp2), lChWidth,  DEFPAGEWIDTH);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Adjust scrollbar maximums%@NL@%
%@AB@%    */%@AE@%%@NL@%
    cchMaxVert = Max(AVIO_PS_ROWS    - cchPgHeight, 0);%@NL@%
    cchMaxHorz = Max(AVIO_PS_COLUMNS -  cchPgWidth, 0);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Maintain scrollbar integrity%@NL@%
%@AB@%    */%@AE@%%@NL@%
    fNeedHorz = (cchMaxHorz > 0);%@NL@%
    fNeedVert = (cchMaxVert > 0);%@NL@%
    SetScroll(hWndHScroll, iCurCol  = Min(iCurCol, cchMaxHorz), cchMaxHorz);%@NL@%
    SetScroll(hWndVScroll, iTopLine = Min(iTopLine,cchMaxVert), cchMaxVert);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Do the Scroll Bar shifting%@NL@%
%@AB@%    */%@AE@%%@NL@%
    Refresh(FALSE);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Now, do the normal AVIO processing%@NL@%
%@AB@%    */%@AE@%%@NL@%
    return WinDefAVioWindowProc(hWnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
void Update%@NL@%
    (USHORT usLineNum, USHORT usHowMany, USHORT usStartLine, BOOL fForced) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Updates usHowMany lines starting from usStartLine on screen.%@NL@%
%@AB@%    Starts at saved line usLineNum.  If fForced is set, all lines%@NL@%
%@AB@%    in range are displayed; otherwise it's lazy.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    USHORT        i;                                %@AB@%/* Loop index */%@AE@%%@NL@%
    USHORT        usWhichLine = usLineNum;        %@AB@%/* Line to be queried */%@AE@%%@NL@%
    Line        l;                                %@AB@%/* Line to be output */%@AE@%%@NL@%
%@NL@%
    for (i = usStartLine; i < (usStartLine + usHowMany); i++) {%@NL@%
        l = QueQuery(usWhichLine++);                %@AB@%/* Get the line */%@AE@%%@NL@%
        if (!l->fDrawn || fForced) {%@NL@%
            if (l->cch) Blast(l, i, 0);                %@AB@%/* Print it out */%@AE@%%@NL@%
            if (!l->fComplete) SetCursor(i, l->cch);%@NL@%
            l->fDrawn = TRUE;%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
void Refresh(BOOL fRedraw) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    fRedraw forces full redraw if set %@NL@%
%@AB@%*/%@AE@%%@NL@%
    SHORT  sDelta;%@NL@%
    int static iOldTopLine = -AVIO_PS_ROWS;%@NL@%
%@NL@%
    VioSetOrg(0, iCurCol, hVPS); %@AB@%/* Get the free AVIO horizontal shift */%@AE@%%@NL@%
    sDelta = iTopLine - iOldTopLine; %@AB@%/* Compute vertical shift */%@AE@%%@NL@%
    if ((Abs(sDelta) < AVIO_PS_ROWS) && !fRedraw) {%@NL@%
        if (sDelta < 0) {         %@AB@%/* Scroll Up -- make sDelta positive*/%@AE@%%@NL@%
            ScrollDown(-sDelta);%@NL@%
            Update(iTopLine, -sDelta, 0, TRUE);%@NL@%
        } else {                %@AB@%/* Scroll Down by sDelta */%@AE@%%@NL@%
            ScrollUp(sDelta);%@NL@%
            Update(iTopLine + cchPgHeight - sDelta, sDelta,%@NL@%
                                cchPgHeight - sDelta, TRUE);%@NL@%
        }%@NL@%
    } else AvioRedraw();        %@AB@%/* Redo the entire screen */%@AE@%%@NL@%
    iOldTopLine = iTopLine;%@NL@%
}%@NL@%
%@NL@%
void AvioClose (void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Termination routines%@NL@%
%@AB@%*/%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Destroy the Presentation Space%@NL@%
%@AB@%    */%@AE@%%@NL@%
    VioAssociate(NULL, hVPS);%@NL@%
    VioDestroyPS(hVPS);%@NL@%
    fCreated = FALSE;%@NL@%
}%@NL@%
%@NL@%
void AvioPaint(HWND hWnd) {%@NL@%
    static HPS   hPS;%@NL@%
    static RECTL rcl;%@NL@%
%@NL@%
    hPS = WinBeginPaint(hWnd, NULL, &rcl);%@NL@%
    VioShowPS(AVIO_PS_ROWS, AVIO_PS_COLUMNS, 0, hVPS);%@NL@%
    WinEndPaint(hPS);%@NL@%
} %@NL@%
%@NL@%
MRESULT AvioMinMax(PSWP pSWP) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Control Maximizing%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (pSWP->fs & (SWP_MAXIMIZE | SWP_RESTORE)) {%@NL@%
        if (pSWP->fs & SWP_MAXIMIZE) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Save cx, cy values for later origin displacement%@NL@%
%@AB@%            */%@AE@%%@NL@%
            int iOldcx = pSWP->cx;%@NL@%
            int iOldcy = pSWP->cy;%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Displace, and change to maximum size%@NL@%
%@AB@%            */%@AE@%%@NL@%
            pSWP->x += (iOldcx - (pSWP->cx = iMaxFrameWidth));%@NL@%
            pSWP->y += (iOldcy - (pSWP->cy = iMaxFrameHeight));%@NL@%
        }%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Now, fix the scroll bars%@NL@%
%@AB@%        */%@AE@%%@NL@%
        AvioAdjustFrame(pSWP);%@NL@%
        return (MRESULT) TRUE;%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
void AvioClear(void) { ClearScreen(); }%@NL@%
%@NL@%
void AvioAdjustFrame(PSWP pSWP) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Trap WM_ADJUSTWINDOWPOS messages to the frame with this routine.%@NL@%
%@AB@%    Keep the window sized right, and control scrollbar visibility.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    BOOL fNeededHorz = fNeedHorz;%@NL@%
    BOOL fNeededVert = fNeedVert;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Do scrollbar enable/disable calculations (but don't update the screen)%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (pSWP->fs & SWP_MINIMIZE) fNeedHorz = fNeedVert = FALSE;%@NL@%
    if ((pSWP->cx * pSWP->cy) == 0) return;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Do we need them?%@NL@%
%@AB@%    */%@AE@%%@NL@%
    fNeedVert = (pSWP->cy < (SHORT) (iMaxFrameHeight));%@NL@%
    fNeedHorz = (pSWP->cx < (SHORT) (iMaxFrameWidth  + VBarWidth()));%@NL@%
    fNeedVert = (pSWP->cy < (SHORT) (iMaxFrameHeight + HBarHeight()));%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Do width calculations to make sure we're staying small enough.%@NL@%
%@AB@%    The Tracking Rectangle shouldn't allow us to get too big.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Check if we're stretching too far%@NL@%
%@AB@%    */%@AE@%%@NL@%
    pSWP->cx = Min(pSWP->cx, iMaxFrameWidth  + (int) VBarWidth());%@NL@%
    pSWP->cy = Min(pSWP->cy, iMaxFrameHeight + (int) HBarHeight());%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        ...if so, fix, then add them!%@NL@%
%@AB@%    */%@AE@%%@NL@%
    AvioSize(NULL, WM_NULL, NULL, MPFROM2SHORT(%@NL@%
        pSWP->cx - (int) (lMiscWidth + VBarWidth()),%@NL@%
        pSWP->cy - (int) (lMiscHeight + HBarHeight()) ));%@NL@%
%@NL@%
    if (fNeedHorz) {%@NL@%
        if (!fNeededHorz) {%@NL@%
            EnableSB(hWndHScroll);%@NL@%
            UpdateOff(hWndHScroll);%@NL@%
            UpdateFrame(FCF_HORZSCROLL);%@NL@%
            UpdateOn(hWndHScroll);%@NL@%
        }%@NL@%
    } else {%@NL@%
        if (fNeededHorz) {%@NL@%
            DisableSB(hWndHScroll);%@NL@%
            UpdateOff(hWndHScroll);%@NL@%
            UpdateFrame(FCF_HORZSCROLL);%@NL@%
            UpdateOn(hWndHScroll);%@NL@%
        }%@NL@%
    }%@NL@%
    if (fNeedVert) {%@NL@%
        if (!fNeededVert) {%@NL@%
             EnableSB(hWndVScroll);%@NL@%
             UpdateOff(hWndVScroll);%@NL@%
             UpdateFrame(FCF_VERTSCROLL);%@NL@%
             UpdateOn(hWndVScroll);%@NL@%
        }%@NL@%
    } else {%@NL@%
        if (fNeededVert) {%@NL@%
             DisableSB(hWndVScroll);%@NL@%
             UpdateOff(hWndVScroll);%@NL@%
             UpdateFrame(FCF_VERTSCROLL);%@NL@%
             UpdateOn(hWndVScroll);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
void AvioTrackFrame(HWND hWnd, MPARAM mpTrackFlags) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Takes action on WM_TRACKFRAME message%@NL@%
%@AB@%*/%@AE@%%@NL@%
    static TRACKINFO tiTrackInfo;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Get the tracking information in the TrackInfo structure%@NL@%
%@AB@%    */%@AE@%%@NL@%
    WinSendMsg(hWnd, WM_QUERYTRACKINFO, mpTrackFlags, &tiTrackInfo);%@NL@%
    WinTrackRect(hWnd, NULL, &tiTrackInfo);%@NL@%
}%@NL@%
%@NL@%
void AvioQueryTrackInfo(PTRACKINFO pTI) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Forces the frame to be byte aligned and bounded%@NL@%
%@AB@%*/%@AE@%%@NL@%
    BOOL fMove;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Get the grid set up for byte alignment%@NL@%
%@AB@%%@NL@%
%@AB@%        Set cxGrid to half a character width, because sizing%@NL@%
%@AB@%        from the keyboard tries to move by half characters.%@NL@%
%@AB@%        Also, make sure we can move the window freely.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    fMove = ((pTI->fs & TF_MOVE) == TF_MOVE);%@NL@%
    pTI->fs     |= TF_GRID;%@NL@%
    pTI->cxGrid  = (fMove) ? 1 : ((SHORT) lChWidth);%@NL@%
    pTI->cyGrid  = (fMove) ? 1 : ((SHORT) lChHeight);%@NL@%
    pTI->cxKeyboard = (SHORT) lChWidth;%@NL@%
    pTI->cyKeyboard = (SHORT) lChHeight;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Bound the frame now%@NL@%
%@AB@%    */%@AE@%%@NL@%
    pTI->ptlMinTrackSize.x = (pTI->cxBorder << 1) + lMiscWidth;%@NL@%
    pTI->ptlMinTrackSize.y = (pTI->cyBorder << 1) + lMiscHeight;%@NL@%
    pTI->ptlMaxTrackSize.x = iMaxFrameWidth  + lVSBWidth +  (pTI->cxBorder <<1);%@NL@%
    pTI->ptlMaxTrackSize.y = iMaxFrameHeight + lHSBHeight + (pTI->cyBorder <<1);%@NL@%
}%@NL@%
%@NL@%
BOOL AvioUpdateLines(BOOL fPage, BOOL *fPaging) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Update the display%@NL@%
%@AB@%*/%@AE@%%@NL@%
    int        cLines;%@NL@%
%@NL@%
    cLines = QueUpdateHead(AVIO_PS_ROWS, fPage, *fPaging);%@NL@%
    if (cLines == AVIO_PS_ROWS) *fPaging = TRUE;%@NL@%
    if (cLines > 0) {%@NL@%
        ScrollUp(cLines);%@NL@%
        Update(iTopLine + AVIO_PS_ROWS - cLines, cLines,%@NL@%
                        AVIO_PS_ROWS - cLines, TRUE);%@NL@%
    }%@NL@%
    Update(iTopLine, cchPgHeight, 0, FALSE);%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
void AvioRedraw(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Clear, then redraw the entire Presentation Space%@NL@%
%@AB@%*/%@AE@%%@NL@%
    ClearScreen();%@NL@%
    Update(iTopLine, cchPgHeight, 0, TRUE);%@NL@%
}%@NL@%
%@NL@%
void WantCursor(BOOL fYes) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Do the underscore cursor%@NL@%
%@AB@%*/%@AE@%%@NL@%
    vci.attr        = (USHORT) (fYes ? 0 : -1);%@NL@%
    vci.yStart        = 0;%@NL@%
    vci.cEnd        = (USHORT) lChHeight - 1;%@NL@%
    vci.cx        = 0;%@NL@%
    VioSetCurType(&vci, hVPS);%@NL@%
}%@NL@%
%@NL@%
void AvioPageUp(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Execute the Page Up instruction%@NL@%
%@AB@%*/%@AE@%%@NL@%
    int cLines;%@NL@%
%@NL@%
    cLines = QuePageUp(AVIO_PS_ROWS);%@NL@%
    ScrollDown(cLines);%@NL@%
    Update(iTopLine, cLines, 0, TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIGBEN.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\BIGBEN\BIGBEN.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This example uses a few of the many VIO calls.%@NL@%
%@AB@% * %@NL@%
%@AB@% * This example puts the time on the screen in large numbers.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Created by Microsoft Corp. 1986%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2def.h> %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_DOSDATETIME %@NL@%
%@AI@%#include %@AE@%<bsedos.h> %@NL@%
%@AI@%#define %@AE@%INCL_SUB %@NL@%
%@AI@%#include %@AE@%<bsesub.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%       CHAR_WIDTH        8 %@NL@%
%@AI@%#define %@AE@%       CHAR_HEIGHT        7 %@NL@%
%@NL@%
       CLOCK_ROW        10        %@AB@%/* row to start the clock */%@AE@%%@NL@%
       TOTAL_COLMS        80        %@AB@%/* screen size in colms */%@AE@%%@NL@%
       TOTAL_ROWS        24        %@AB@%/* screen size in rows */%@AE@%%@NL@%
%@NL@%
        %@NL@%
char        BigChars[10][CHAR_HEIGHT][CHAR_WIDTH] = {%@NL@%
%@NL@%
{%@NL@%
        "   00  ",%@NL@%
        "  0  0 ",%@NL@%
        " 0    0",%@NL@%
        " 0    0",%@NL@%
        " 0    0",%@NL@%
        "  0  0 ",%@NL@%
        "   00  "%@NL@%
},%@NL@%
{%@NL@%
        "   1   ",%@NL@%
        "   1   ",%@NL@%
        "   1   ",%@NL@%
        "   1   ",%@NL@%
        "   1   ",%@NL@%
        "   1   ",%@NL@%
        "   1   "%@NL@%
}, %@NL@%
{%@NL@%
        "  2222 ",%@NL@%
        " 2    2",%@NL@%
        "      2",%@NL@%
        "     2 ",%@NL@%
        "   2   ",%@NL@%
        "  2    ",%@NL@%
        " 222222" %@NL@%
},%@NL@%
{%@NL@%
        " 33333 ",%@NL@%
        "      3",%@NL@%
        "      3",%@NL@%
        "   333 ",%@NL@%
        "      3",%@NL@%
        "      3",%@NL@%
        " 33333 " %@NL@%
},%@NL@%
{%@NL@%
        "    44 ",%@NL@%
        "   4 4 ",%@NL@%
        "  4  4 ",%@NL@%
        " 4   4 ",%@NL@%
        " 444444",%@NL@%
        "     4 ",%@NL@%
        "     4 " %@NL@%
},%@NL@%
{%@NL@%
        " 555555",%@NL@%
        " 5     ",%@NL@%
        " 55555 ",%@NL@%
        "      5",%@NL@%
        "      5",%@NL@%
        " 5    5",%@NL@%
        "  5555 " %@NL@%
},%@NL@%
{%@NL@%
        "    6  ",%@NL@%
        "   6   ",%@NL@%
        "  6    ",%@NL@%
        "  6666 ",%@NL@%
        " 6    6",%@NL@%
        " 6    6",%@NL@%
        "  6666 " %@NL@%
},%@NL@%
{%@NL@%
        " 777777",%@NL@%
        "      7",%@NL@%
        "     7 ",%@NL@%
        "    7  ",%@NL@%
        "   7   ",%@NL@%
        "  7    ",%@NL@%
        " 7     "%@NL@%
},%@NL@%
{%@NL@%
        "  8888 ",%@NL@%
        " 8    8",%@NL@%
        " 8    8",%@NL@%
        "  8888 ",%@NL@%
        " 8    8",%@NL@%
        " 8    8",%@NL@%
        "  8888 "%@NL@%
},%@NL@%
{%@NL@%
        "  9999 ",%@NL@%
        " 9    9",%@NL@%
        " 9    9",%@NL@%
        "  9999 ",%@NL@%
        "    9  ",%@NL@%
        "   9   ",%@NL@%
        "  9    "%@NL@%
}%@NL@%
};%@NL@%
%@NL@%
%@NL@%
main(argc, argv)%@NL@%
        int        argc;%@NL@%
        char        *argv[];%@NL@%
{%@NL@%
        unsigned        rc;        %@AB@%/* return code */%@AE@%%@NL@%
        DATETIME Now;         %@AB@%/* time struct for DosGetDateTime */%@AE@%%@NL@%
%@NL@%
        %@AB@%/* clear the screen */%@AE@%%@NL@%
%@NL@%
        VioWrtNCell( " \07", TOTAL_ROWS * TOTAL_COLMS, 0, 0, 0 );%@NL@%
%@NL@%
        %@AB@%/* paint separators between hours and minutes, and minutes and seconds*/%@AE@%%@NL@%
%@NL@%
        VioWrtNCell( "|\07", 1, (CLOCK_ROW + 2), 27, 0 );%@NL@%
        VioWrtNCell( "|\07", 1, (CLOCK_ROW + 5), 27, 0 );%@NL@%
        VioWrtNCell( "|\07", 1, (CLOCK_ROW + 2), 52, 0 );%@NL@%
        VioWrtNCell( "|\07", 1, (CLOCK_ROW + 5), 52, 0 );%@NL@%
         %@NL@%
        for (;;) {%@NL@%
%@NL@%
            %@AB@%/* get the system time */%@AE@%%@NL@%
%@NL@%
            if (rc = DosGetDateTime( &Now))  {%@NL@%
%@NL@%
                printf("DosGetDateTime failed, error: %d\n", rc);%@NL@%
                DosExit(EXIT_PROCESS, 0);%@NL@%
            }%@NL@%
%@NL@%
            %@AB@%/* write the digits out to the screen */%@AE@%%@NL@%
%@NL@%
            LoadNumber(Now.hours / 10, 5, CLOCK_ROW);%@NL@%
            LoadNumber(Now.hours % 10, 15, CLOCK_ROW);%@NL@%
            LoadNumber(Now.minutes / 10, 30, CLOCK_ROW);%@NL@%
            LoadNumber(Now.minutes % 10, 40, CLOCK_ROW);%@NL@%
            LoadNumber(Now.seconds / 10, 55, CLOCK_ROW);%@NL@%
            LoadNumber(Now.seconds % 10, 65, CLOCK_ROW);%@NL@%
%@NL@%
            DosSleep(900L);%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/* display the digit at the given coordinates */%@AE@%%@NL@%
%@NL@%
LoadNumber( dig, x, y )%@NL@%
        unsigned        dig;%@NL@%
        unsigned        x;%@NL@%
        unsigned        y;%@NL@%
{%@NL@%
        int        i;%@NL@%
%@NL@%
        %@AB@%/* write a list of char strings to make up a display number */%@AE@%%@NL@%
%@NL@%
        for (i=0; (i < CHAR_HEIGHT); i++) %@NL@%
%@NL@%
            %@AB@%/* write a character string starting from the coordinates */%@AE@%%@NL@%
%@NL@%
            VioWrtCharStr( BigChars[dig][i], CHAR_WIDTH, y++, x, 0);%@NL@%
} %@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIO.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\BIO\BIO.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*  Biorhythm - Utility to compute personal biorhythm charts.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corp., 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Purpose:%@NL@%
%@AB@%*       Program entry point, initialization and GetMessage loop.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Arguments:%@NL@%
%@AB@%*       None%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (modified):%@NL@%
%@AB@%*       hAB           - Handle to the Anchor Block%@NL@%
%@AB@%*       hMsgQ         - Handle to the application's message queue%@NL@%
%@AB@%*       hwndAppFrame  - Window handle of parent window's frame%@NL@%
%@AB@%*       hwndKidFrame  - Window handle of parent window's frame%@NL@%
%@AB@%*       hwndApp       - Window handle of parent window's client area%@NL@%
%@AB@%*       hwndKid       - Window handle of child window's client area%@NL@%
%@AB@%*       szAppName[10] - RC file program name (Biorhythm).%@NL@%
%@AB@%*       szKidName[10] - RC file child window name (Legend).%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (referenced):%@NL@%
%@AB@%*       tmFontInfo    - Text Metric structure defined during WM_CREATE %@NL@%
%@AB@%*%@NL@%
%@AB@%*   Description:%@NL@%
%@AB@%*       The theory of biorhythms states that life consists of three cycles,%@NL@%
%@AB@%*       physical, emotional and intellectual of 23, 28 and 33 days,%@NL@%
%@AB@%*       respectively.  The cycles each begin on the date of birth.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Limits:%@NL@%
%@AB@%*       The intended use of this program is for the 20th and 21st centuries.%@NL@%
%@AB@%*       The calculations of biorhythms will not be accurate outside of this%@NL@%
%@AB@%*       range due to formulae used to compute days between dates.%@NL@%
%@AB@%*%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stddef.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"bio.h" %@NL@%
%@NL@%
%@AB@%/* Write-once global variables */%@AE@%%@NL@%
HAB     hAB;%@NL@%
HMQ     hMsgQ;%@NL@%
HWND    hwndApp, hwndKid;%@NL@%
HWND    hwndAppFrame, hwndKidFrame;%@NL@%
char    szAppName[10];%@NL@%
char    szKidName[10];%@NL@%
ULONG        AppCtlData = FCF_STANDARD | FCF_VERTSCROLL | FCF_NOBYTEALIGN & ~FCF_SHELLPOSITION;%@NL@%
ULONG        KidCtlData = FCF_TITLEBAR;%@NL@%
PFNWP        OldFrameWndProc;%@NL@%
%@NL@%
%@AB@%/* Read-only global variables */%@AE@%%@NL@%
extern  FONTMETRICS     tmFontInfo;%@NL@%
extern        SHORT                cxLegendField;%@NL@%
extern        SHORT                cxDateField;%@NL@%
%@NL@%
SHORT cdecl main(  )%@NL@%
{%@NL@%
    QMSG        qMsg;%@NL@%
    SHORT       dx, dy, x, y;%@NL@%
    SHORT        cxSizeBorder;%@NL@%
    SHORT        cySizeBorder;%@NL@%
    SHORT        cxBorder;%@NL@%
    SHORT        cyBorder;%@NL@%
%@NL@%
    %@AB@%/* Standard initialization.  Get anchor block and message queue. */%@AE@%%@NL@%
    hAB   = WinInitialize(0);%@NL@%
    hMsgQ = WinCreateMsgQueue( hAB, 0 );%@NL@%
%@NL@%
    %@AB@%/* Get string constants for parent and child window registration%@NL@%
%@AB@%       and creation from resource string table. */%@AE@%%@NL@%
    WinLoadString( hAB, (HMODULE) NULL, IDS_APPNAME, sizeof(szAppName), szAppName );%@NL@%
    WinLoadString( hAB, (HMODULE) NULL, IDS_KIDNAME, sizeof(szKidName), szKidName );%@NL@%
%@NL@%
    %@AB@%/* Register parent window.  Terminate if error. */%@AE@%%@NL@%
    if ( !WinRegisterClass( hAB, szAppName, BioWndProc,%@NL@%
            CS_CLIPCHILDREN | CS_SIZEREDRAW, 0 ) )%@NL@%
        return( FALSE );%@NL@%
%@NL@%
    %@AB@%/* Register child window.  Terminate if error. */%@AE@%%@NL@%
    if ( !WinRegisterClass( hAB, szKidName, KidWndProc, 0, 0 ) )%@NL@%
        return( FALSE );%@NL@%
%@NL@%
    %@AB@%/* Create a parent window of class szAppName */%@AE@%%@NL@%
    hwndAppFrame = WinCreateStdWindow(%@NL@%
        HWND_DESKTOP,%@NL@%
        0L,%@NL@%
        &AppCtlData,%@NL@%
        szAppName,%@NL@%
        NULL,%@NL@%
        0L,%@NL@%
        (HMODULE) NULL,%@NL@%
        ID_BIO,%@NL@%
        (HWND FAR *)&hwndApp%@NL@%
        );%@NL@%
%@NL@%
    %@AB@%/* Create a child window of class KidClass */%@AE@%%@NL@%
    hwndKidFrame = WinCreateStdWindow(%@NL@%
        hwndApp,%@NL@%
        FS_BORDER,%@NL@%
        &KidCtlData,%@NL@%
        szKidName,%@NL@%
        szKidName,%@NL@%
        0L,%@NL@%
        (HMODULE) NULL,%@NL@%
        0,%@NL@%
        (HWND FAR *)&hwndKid%@NL@%
        );%@NL@%
%@NL@%
    %@AB@%/* Subclass frame so that minimum window size can be controled */%@AE@%%@NL@%
    OldFrameWndProc = WinSubclassWindow( hwndAppFrame, FrameWndProc );%@NL@%
%@NL@%
    %@AB@%/* Get the size of the screen and border.  Used to place and size window */%@AE@%%@NL@%
    cxSizeBorder =  (SHORT)WinQuerySysValue( HWND_DESKTOP, SV_CXSIZEBORDER );%@NL@%
    cySizeBorder =  (SHORT)WinQuerySysValue( HWND_DESKTOP, SV_CYSIZEBORDER );%@NL@%
    cxBorder         =  (SHORT)WinQuerySysValue( HWND_DESKTOP, SV_CXBORDER );%@NL@%
    cyBorder         =  (SHORT)WinQuerySysValue( HWND_DESKTOP, SV_CYBORDER );%@NL@%
    x                 =  (SHORT)WinQuerySysValue( HWND_DESKTOP, SV_CXSCREEN );%@NL@%
    y                 =  (SHORT)WinQuerySysValue( HWND_DESKTOP, SV_CYSCREEN );%@NL@%
%@NL@%
    %@AB@%/* Calculate width and height of child window.  Must be able to%@NL@%
%@AB@%       display three lines and wide enough for text and corresponding colored%@NL@%
%@AB@%       line.  Must take into account titlebar and border vertical sizes. */%@AE@%%@NL@%
    dx = cxLegendField * 2;%@NL@%
    dy = (SHORT)(tmFontInfo.lMaxBaselineExt*3 +%@NL@%
         WinQuerySysValue( HWND_DESKTOP, SV_CYTITLEBAR ) +%@NL@%
         WinQuerySysValue( HWND_DESKTOP, SV_CYBORDER ) * 2);%@NL@%
%@NL@%
    %@AB@%/* Place and size parent and child windows, then make them visible.%@NL@%
%@AB@%       WinCreateStdWindow does not include position and size arguments.%@NL@%
%@AB@%       Parent window is thin, but full screen high.  Child window is placed%@NL@%
%@AB@%       10 pixels over and up from the parent window's lower left corner. */%@AE@%%@NL@%
    WinSetWindowPos( hwndAppFrame, NULL,%@NL@%
                     x-(3*cxDateField)+cxSizeBorder,%@NL@%
                     -cySizeBorder,%@NL@%
                     (3*cxDateField),%@NL@%
                     y+2*cySizeBorder,%@NL@%
                     SWP_MOVE | SWP_SIZE | SWP_ACTIVATE | SWP_SHOW );%@NL@%
    WinSetWindowPos( hwndKidFrame, NULL, 10, 10, dx, dy,%@NL@%
                     SWP_MOVE | SWP_SIZE | SWP_ACTIVATE | SWP_SHOW );%@NL@%
%@NL@%
    %@AB@%/* Get messages from application queue and dispatch them for processing */%@AE@%%@NL@%
    while( WinGetMsg( hAB, &qMsg, (HWND)NULL, 0, 0 ) )%@NL@%
    {%@NL@%
        WinDispatchMsg( hAB, &qMsg );%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* Clean up.  All child windows will be destoyed automatically */%@AE@%%@NL@%
    WinDestroyWindow( hwndAppFrame );%@NL@%
    WinDestroyMsgQueue( hMsgQ );%@NL@%
    WinTerminate( hAB );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIOCMD.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\BIO\BIOCMD.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*  BioDlg() - Dialog Box routine.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Purpose:%@NL@%
%@AB@%*       Allow setting of birthdate and viewing date for biorhythm display.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Arguments:%@NL@%
%@AB@%*       hDlg          - Handle of Dialog Box owning message%@NL@%
%@AB@%*       message       - Message itself%@NL@%
%@AB@%*       mp1           - Extra message-dependent info%@NL@%
%@AB@%*       mp2           - Extra message-dependent info%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (modified):%@NL@%
%@AB@%*       Born          - Birthdate in julian days.  Read from OS2.INI.%@NL@%
%@AB@%*       SelectDay     - Current day being tracked, day is highlighted.%@NL@%
%@AB@%*                        This is stored as # days from birthdate.%@NL@%
%@AB@%*                        This is initialized to the current date in WM_CREATE.%@NL@%
%@AB@%*       Day           - Day number from date born which is top line being%@NL@%
%@AB@%*                       displayed.  Initially three days before SelectDay.%@NL@%
%@AB@%*       bBorn         - Boolean indicating whether valid birtdate entered or%@NL@%
%@AB@%*                       defined in OS2.INI.  Nothing graphed until valid.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (referenced):%@NL@%
%@AB@%*       hAB           - Handle to the Anchor Block%@NL@%
%@AB@%*       szAppName[]   - RC file program name (Biorhythm).%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Description:%@NL@%
%@AB@%*       Biorythm cycles start on the date of birth and the state of%@NL@%
%@AB@%*       of these cycles may be viewed on the selected date.  A check%@NL@%
%@AB@%*       box is provided to update (record) the birthdate in the WIN.INI%@NL@%
%@AB@%*       file so that it will be automatically available in subsequent%@NL@%
%@AB@%*       sessions.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Limits:%@NL@%
%@AB@%*       Minor error checking is provided when OK is selected to make%@NL@%
%@AB@%*       sure that the dates specified fall in the 20th and 21st%@NL@%
%@AB@%*       centuries.  No error checking is attempted to verify correct%@NL@%
%@AB@%*       month or day of month entries. %@NL@%
%@AB@%*%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"bio.h" %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AB@%/* Read-only global variables */%@AE@%%@NL@%
extern HAB      hAB;%@NL@%
extern char     szAppName[];%@NL@%
%@NL@%
%@AB@%/* Global variables (modified) */%@AE@%%@NL@%
extern long     SelectDay, Day;%@NL@%
extern double   Born;%@NL@%
extern BOOL     bBorn;%@NL@%
%@NL@%
%@AB@%/* Function prototypes */%@AE@%%@NL@%
void InitBioDlg(HWND);%@NL@%
void BioDlgCmd(HWND, MPARAM);%@NL@%
%@NL@%
MRESULT CALLBACK BioDlg( hDlg, message, mp1, mp2 )%@NL@%
HWND    hDlg;%@NL@%
USHORT  message;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
    switch( message ) {%@NL@%
        case WM_INITDLG:%@NL@%
            InitBioDlg(hDlg);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            BioDlgCmd(hDlg, mp1);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return( WinDefDlgProc( hDlg, message, mp1, mp2 ) );%@NL@%
%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*  About() - General purpose About dialog box.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Purpose:%@NL@%
%@AB@%*       Provide program propoganda.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Arguments:%@NL@%
%@AB@%*       hDlg          - Handle of Dialog Box owning message%@NL@%
%@AB@%*       message       - Message itself%@NL@%
%@AB@%*       mp1           - Extra message-dependent info%@NL@%
%@AB@%*       mp2           - Extra message-dependent info%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
MRESULT CALLBACK About( hWndDlg, message, mp1, mp2 )%@NL@%
HWND   hWndDlg;%@NL@%
USHORT message;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
    switch( message )%@NL@%
    {%@NL@%
      case WM_COMMAND:%@NL@%
        switch( LOUSHORT( mp1 ) )%@NL@%
        {%@NL@%
          case DID_OK:%@NL@%
            WinDismissDlg( hWndDlg, TRUE );%@NL@%
            break;%@NL@%
%@NL@%
          default:%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
      default:%@NL@%
        return( WinDefDlgProc( hWndDlg, message, mp1, mp2 ) );%@NL@%
    }%@NL@%
    return( FALSE );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void InitBioDlg(HWND hDlg) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%     If valid OS2.INI info, fill in birthdate edit fields%@NL@%
%@AB@%*/%@AE@%%@NL@%
    USHORT        year, month;%@NL@%
    double      day;%@NL@%
%@NL@%
    if (bBorn) {%@NL@%
      calendar( Born, (int *)&year, (int *)&month, &day );%@NL@%
      WinSetDlgItemShort( hDlg, ID_BDYEAR, year, FALSE );%@NL@%
      WinSetDlgItemShort( hDlg, ID_BDMONTH, month, FALSE );%@NL@%
      WinSetDlgItemShort( hDlg, ID_BDDAY, (int)day, FALSE );%@NL@%
    }%@NL@%
    %@AB@%/* Display current date or date highlighted */%@AE@%%@NL@%
    calendar( Born+SelectDay, (int *)&year, (int *)&month, &day );%@NL@%
    WinSetDlgItemShort( hDlg, ID_YEAR, year, FALSE );%@NL@%
    WinSetDlgItemShort( hDlg, ID_MONTH, month, FALSE );%@NL@%
    WinSetDlgItemShort( hDlg, ID_DAY, (int)day, FALSE );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void BioDlgCmd(HWND hDlg, MPARAM mp1) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Bio Dialog Box routine WM_COMMAND processor%@NL@%
%@AB@%*/%@AE@%%@NL@%
    USHORT        year, month, iDay;%@NL@%
    double      day;%@NL@%
    char        szBuf[10];%@NL@%
%@NL@%
    switch( LOUSHORT( mp1 ) ) {%@NL@%
        case DID_OK:%@NL@%
            %@AB@%/* Get the birthday edit field values */%@AE@%%@NL@%
            WinQueryDlgItemShort( hDlg, ID_BDYEAR, &year, FALSE );%@NL@%
            WinQueryDlgItemShort( hDlg, ID_BDMONTH, &month, FALSE );%@NL@%
            WinQueryDlgItemShort( hDlg, ID_BDDAY, &iDay, FALSE );%@NL@%
            day = (double)iDay;%@NL@%
            %@AB@%/* Check that date is within acceptable range */%@AE@%%@NL@%
            if (year<1900 || year>2100) {%@NL@%
               WinMessageBox( HWND_DESKTOP, hDlg,%@NL@%
                              "Dates valid from 1900-2100",%@NL@%
                              "Birthday!", 0,%@NL@%
                              MB_OK | MB_ICONEXCLAMATION );%@NL@%
               break;%@NL@%
            }%@NL@%
            %@AB@%/* Get julian date of birth date */%@AE@%%@NL@%
            Born = julian( year, month, day );%@NL@%
%@NL@%
            %@AB@%/* Write birth date to OS2.INI if check box checked */%@AE@%%@NL@%
            if (WinSendDlgItemMsg(hDlg, ID_OS2INI, BM_QUERYCHECK, 0L, 0L)) {%@NL@%
                   sprintf(szBuf, "%d", year);%@NL@%
              WinWriteProfileString( hAB, szAppName, "Year", szBuf );%@NL@%
                   sprintf(szBuf, "%d", month);%@NL@%
              WinWriteProfileString( hAB, szAppName, "Month", szBuf );%@NL@%
                   sprintf(szBuf, "%d", (int)day);%@NL@%
              WinWriteProfileString( hAB, szAppName, "Day", szBuf );%@NL@%
            }%@NL@%
%@NL@%
            %@AB@%/* Get selected day of interest edit field values */%@AE@%%@NL@%
            WinQueryDlgItemShort( hDlg, ID_YEAR, &year, FALSE );%@NL@%
            WinQueryDlgItemShort( hDlg, ID_MONTH, &month, FALSE );%@NL@%
            WinQueryDlgItemShort( hDlg, ID_DAY, &iDay, FALSE );%@NL@%
            day = (double)iDay;%@NL@%
            %@AB@%/* Check that date is within acceptable range */%@AE@%%@NL@%
            if (year<1900 || year>2100) {%@NL@%
               WinMessageBox( HWND_DESKTOP, hDlg,%@NL@%
                              "Dates valid from 1900-2100",%@NL@%
                              "Display Date!", 0,%@NL@%
                              MB_OK | MB_ICONEXCLAMATION );%@NL@%
               break;%@NL@%
            }%@NL@%
%@NL@%
            %@AB@%/* Compute number of days since birth */%@AE@%%@NL@%
                 SelectDay  = (long)(julian( year, month, day ) - Born);%@NL@%
            %@AB@%/* Top date of display is 3 days before selected day */%@AE@%%@NL@%
            Day = SelectDay - 3;%@NL@%
            %@AB@%/* Got a valid birthdate, enable all routines */%@AE@%%@NL@%
            bBorn = TRUE;%@NL@%
            WinDismissDlg( hDlg, TRUE );%@NL@%
            break;%@NL@%
%@NL@%
        case DID_CANCEL:%@NL@%
            %@AB@%/* Exit and ignore entries */%@AE@%%@NL@%
            WinDismissDlg( hDlg, FALSE );%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIOPAINT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\BIO\BIOPAINT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    biopaint.c        -   WM_PAINT processing and calendar conversion routines%@NL@%
%@AB@%%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"bio.h" %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AB@%/* Read-only global variables */%@AE@%%@NL@%
extern double   Born;%@NL@%
extern long     Day, SelectDay;%@NL@%
extern BOOL     bBorn;%@NL@%
extern FONTMETRICS tmFontInfo;%@NL@%
extern int      LinesPerPage;%@NL@%
extern RECTL    rclClient;%@NL@%
extern SHORT        cxDateField;%@NL@%
%@NL@%
%@AB@%/* Read-only static variables */%@AE@%%@NL@%
static double   Cycle[] = { 23.0, 28.0, 33.0 };%@NL@%
static char     cDayOfWeek[] = "MTWTFSS";%@NL@%
extern LONG     Color[];%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*  APPPaint() - Parent window WM_PAINT processing routine.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Purpose:%@NL@%
%@AB@%*       Routine to graph biorhythm cycles and tabulate dates.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Arguments:%@NL@%
%@AB@%*       hWnd          - Handle of Window owning message%@NL@%
%@AB@%*       message       - Message itself%@NL@%
%@AB@%*       mp1           - Extra message-dependent info%@NL@%
%@AB@%*       mp2           - Extra message-dependent info%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (static):%@NL@%
%@AB@%*       Cycle[]       - Array holding period for phy/emot/int: 23,28,33%@NL@%
%@AB@%*       cDayOfWeek[]  - Array of chars holding first letter of days of week.%@NL@%
%@AB@%*       Color[]       - Set of colored pens used to identify cycles.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (referenced):%@NL@%
%@AB@%*       Born          - Birthdate in julian days.  Read from WIN.INI.%@NL@%
%@AB@%*        SelectDay     - Current day being tracked, day is highlighted.%@NL@%
%@AB@%*                        This is stored as the number of days from birthdate.%@NL@%
%@AB@%*                        Initialized to present day in WM_CREATE processing.%@NL@%
%@AB@%*       Day           - Day number from date born which is top line being%@NL@%
%@AB@%*                       displayed.  Initially three days before SelectDay.%@NL@%
%@AB@%*       bBorn         - Boolean indicating whether valid birtdate entered or%@NL@%
%@AB@%*        rclClient     - Size of client area defined by WM_SIZE message%@NL@%
%@AB@%*       LinesPerPage  - Number of system font lines on client area, defined%@NL@%
%@AB@%*                       by WM_SIZE message handling%@NL@%
%@AB@%*       tmFontInfo    - Text Metric structure defined during WM_CREATE %@NL@%
%@AB@%*%@NL@%
%@AB@%*   Description:%@NL@%
%@AB@%*       Tabulates dates and graphs cycles.  On color displays, weekends%@NL@%
%@AB@%*       are written in red.  The update rectangle is used to minimize%@NL@%
%@AB@%*       repaint time of affected client area.%@NL@%
%@AB@%*/%@AE@%%@NL@%
VOID APIENTRY APPPaint( hWnd )%@NL@%
HWND   hWnd;%@NL@%
{%@NL@%
    HPS         hPS;%@NL@%
    POINTL      ptl;%@NL@%
    int         y, i;%@NL@%
    int         start, last;%@NL@%
    char        szDay[16];%@NL@%
    int         Amplitude, offset;%@NL@%
    int         year, month;%@NL@%
    double      day;%@NL@%
    RECTL       rc, rcClip;%@NL@%
    int         DayOfWeek;%@NL@%
    HRGN        hrgnClip;%@NL@%
    POINTL        ptlTextBox[5];%@NL@%
%@NL@%
    hPS = WinBeginPaint( hWnd, NULL, &rcClip );%@NL@%
%@NL@%
    %@AB@%/* Erase client area */%@AE@%%@NL@%
    WinQueryWindowRect( hWnd, &rc );%@NL@%
    WinFillRect( hPS, &rc, CLR_WHITE );%@NL@%
%@NL@%
    %@AB@%/* Label parts of table and graph. */%@AE@%%@NL@%
    ptl.y = rclClient.yTop - tmFontInfo.lMaxBaselineExt + %@AB@%/* Top line */%@AE@%%@NL@%
            tmFontInfo.lMaxDescender;%@NL@%
    ptl.x = 0;%@NL@%
    GpiCharStringAt( hPS, &ptl, 7L, (PCH)"   DATE" );%@NL@%
    ptl.x = cxDateField + tmFontInfo.lAveCharWidth;%@NL@%
    GpiCharStringAt( hPS, &ptl, 3L, (PCH)"LOW" );%@NL@%
    GpiQueryTextBox( hPS, 4L, "HIGH", TXTBOX_COUNT, ptlTextBox );%@NL@%
    ptl.x = rclClient.xRight - ptlTextBox[TXTBOX_CONCAT].x - tmFontInfo.lAveCharWidth;%@NL@%
    GpiCharStringAt( hPS, &ptl, 4L, (PCH)"HIGH" );%@NL@%
%@NL@%
    %@AB@%/* Underline labels from left to right across client area */%@AE@%%@NL@%
    ptl.y = rclClient.yTop - tmFontInfo.lMaxBaselineExt;%@NL@%
    ptl.x = 0;%@NL@%
    GpiMove( hPS, &ptl );%@NL@%
    ptl.x = rclClient.xRight;%@NL@%
    GpiLine( hPS, &ptl );%@NL@%
%@NL@%
    %@AB@%/* Draw a vertical line separator between dates and cycles */%@AE@%%@NL@%
    ptl.y = rclClient.yTop;%@NL@%
    ptl.x = cxDateField;%@NL@%
    GpiMove( hPS, &ptl );%@NL@%
    ptl.y = rclClient.yBottom;%@NL@%
    GpiLine( hPS, &ptl );%@NL@%
%@NL@%
    %@AB@%/* Draw a dotted vertical center line to reference cycles */%@AE@%%@NL@%
    GpiSetLineType( hPS, LINETYPE_DOT );%@NL@%
    ptl.x = (cxDateField + rclClient.xRight) / 2;%@NL@%
    GpiMove( hPS, &ptl );%@NL@%
    ptl.y = rclClient.yTop;%@NL@%
    GpiLine( hPS, &ptl );%@NL@%
    %@AB@%/* (Should not have to restore line type after EndPaint) */%@AE@%%@NL@%
    GpiSetLineType( hPS, LINETYPE_DEFAULT );%@NL@%
%@NL@%
    %@AB@%/* Update only the range of lines which fall into update rectangle */%@AE@%%@NL@%
    start = (int)((rclClient.yTop - rcClip.yTop) / tmFontInfo.lMaxBaselineExt);%@NL@%
    if (start<1)%@NL@%
       start = 1;%@NL@%
    last = (int)((rclClient.yTop - rcClip.yBottom) / tmFontInfo.lMaxBaselineExt);%@NL@%
    if (last>(LinesPerPage-1))%@NL@%
       last = LinesPerPage-1;%@NL@%
    %@NL@%
    %@AB@%/* Set clip rectangle to completely draw entire rectangle representing%@NL@%
%@AB@%       each date affected.  Start drawing one day before and after%@NL@%
%@AB@%       (outside clip rectangle) so that cycle lines will connect correctly%@NL@%
%@AB@%       with unaffected lines. */%@AE@%%@NL@%
    rcClip.yTop = rclClient.yTop - start*tmFontInfo.lMaxBaselineExt;%@NL@%
    start--;%@NL@%
    last++;%@NL@%
    rcClip.yBottom = rclClient.yTop - last*tmFontInfo.lMaxBaselineExt + 1;%@NL@%
    hrgnClip = GpiCreateRegion( hPS, 1L, &rcClip );%@NL@%
    GpiSetClipRegion( hPS, hrgnClip, &hrgnClip );%@NL@%
%@NL@%
    %@AB@%/* List days and date */%@AE@%%@NL@%
    for (y=start; y<=last; y++) {%@NL@%
        %@AB@%/* Get the calendar date from julian day */%@AE@%%@NL@%
        calendar( Born+Day+y-1, &year, &month, &day );%@NL@%
        %@AB@%/* Get offset into days of the week initials array */%@AE@%%@NL@%
        DayOfWeek = (int)((LONG)(Born+Day+y) % 7);%@NL@%
        %@AB@%/* Assemble each of the parts in a buffer */%@AE@%%@NL@%
        sprintf(szDay, " %02d-%02d-%02d",%@NL@%
                month, (int)day, year - (trunc4((double)year / 100)*100) );%@NL@%
        %@AB@%/* If color available, draw weekends in red */%@AE@%%@NL@%
        if (DayOfWeek > 4)%@NL@%
           GpiSetColor( hPS, CLR_RED );%@NL@%
        ptl.x = 0;%@NL@%
        ptl.y = rclClient.yTop - ((y+1)*tmFontInfo.lMaxBaselineExt -%@NL@%
                tmFontInfo.lMaxDescender);%@NL@%
        GpiCharStringAt( hPS, &ptl, 1L, (PCH)&cDayOfWeek[DayOfWeek] );%@NL@%
        GpiQueryWidthTable( hPS, (LONG)'W', 1L, &ptl.x );%@NL@%
        GpiCharStringAt( hPS, &ptl, 9L, (PCH)szDay );%@NL@%
        GpiSetColor( hPS, CLR_BLACK );%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* Amplitude of sin wave is half client area minus space for dates */%@AE@%%@NL@%
    Amplitude = (int)((rclClient.xRight - cxDateField - tmFontInfo.lAveCharWidth) >> 1);%@NL@%
    %@AB@%/* Move to right, make room for column of dates */%@AE@%%@NL@%
    offset = (int)(Amplitude + cxDateField + tmFontInfo.lAveCharWidth - (tmFontInfo.lAveCharWidth>>1));%@NL@%
    for (i=0; i<3 && bBorn; i++ ) {%@NL@%
        GpiSetColor( hPS, Color[i] );%@NL@%
        for (y=start; y<=last; y++) {%@NL@%
            ptl.x = (int)(sin( (y+Day-1)/Cycle[i]*2*3.14159 ) * Amplitude + offset);%@NL@%
            ptl.y = rclClient.yTop - (y*tmFontInfo.lMaxBaselineExt +%@NL@%
                        tmFontInfo.lMaxBaselineExt/2);%@NL@%
            if ((y+Day-1 > 0) && (y>start))%@NL@%
               GpiLine( hPS, &ptl );%@NL@%
            else%@NL@%
               GpiMove( hPS, &ptl );%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* Draw highlight on selected day if visible. */%@AE@%%@NL@%
    if ((SelectDay >= Day) && (SelectDay - Day < LinesPerPage - 1)) {%@NL@%
        rc.xRight = rclClient.xRight;%@NL@%
        rc.xLeft = rclClient.xLeft;%@NL@%
        rc.yTop = rclClient.yTop - (int)(SelectDay - Day + 1) * tmFontInfo.lMaxBaselineExt;%@NL@%
        rc.yBottom = rc.yTop - tmFontInfo.lMaxBaselineExt + 1;%@NL@%
        WinInvertRect( hPS, &rc );%@NL@%
    }%@NL@%
%@NL@%
    WinEndPaint( hPS );%@NL@%
%@NL@%
    return;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*  julian() - Compute julian date from Gregorian calendar date.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Purpose:%@NL@%
%@AB@%*       Provide a standard time base.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Arguments:%@NL@%
%@AB@%*       year          - Calendar year%@NL@%
%@AB@%*       month         - Calendar month%@NL@%
%@AB@%*       day           - Calendar day and fraction%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Return Value:%@NL@%
%@AB@%*       double        - Julian date converted%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Description:%@NL@%
%@AB@%*       Convert Gregorian dates to Julian Days.  Refer to Alamanac for%@NL@%
%@AB@%*       Computers (1978), p. B2, Naval Observatory Pub.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Limits:%@NL@%
%@AB@%*       Valid between ~1900 and 2099.%@NL@%
%@AB@%*%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
double PASCAL julian (year, month, day)%@NL@%
int    year, month;%@NL@%
double day;%@NL@%
{%@NL@%
  double dj;%@NL@%
  double fracDay, intDay;%@NL@%
%@NL@%
  fracDay = modf(day, &intDay);%@NL@%
  dj = (long)367*year - 7*(year + (month+9) / 12) / 4 + 275*month / 9 +%@NL@%
       intDay + 1721013.5 + fracDay;%@NL@%
  return dj;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*  calendar() - Compute Gregorian calendar date from julian date.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Purpose:%@NL@%
%@AB@%*       Provide a standard time base.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Arguments:%@NL@%
%@AB@%*       juldate       - Julian date to convert%@NL@%
%@AB@%*       year          - Calendar year result%@NL@%
%@AB@%*       month         - Calendar month result%@NL@%
%@AB@%*       day           - Calendar day and fraction result%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Return Value:%@NL@%
%@AB@%*       void%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (modified):%@NL@%
%@AB@%*       none%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (referenced):%@NL@%
%@AB@%*       none%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Description:%@NL@%
%@AB@%*       Convert Julian Days to Gregorian date.  Refer to Astronomical%@NL@%
%@AB@%*       Formulae for Calculators (1979), p. 23, by Jean Meeus.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Limits:%@NL@%
%@AB@%*       Valid for positive Julian Day values.%@NL@%
%@AB@%*%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
void PASCAL calendar (juldate, year, month, day)%@NL@%
double juldate;%@NL@%
int *year;%@NL@%
int *month;%@NL@%
double *day;%@NL@%
{%@NL@%
  long b, c, d, e, z, alf;%@NL@%
%@NL@%
  juldate = juldate + 0.5;%@NL@%
  z = trunc4(juldate);%@NL@%
  alf = trunc4((z - 1867216.25)/36524.25);%@NL@%
  b = z + 1 + alf - alf / 4 + 1524;%@NL@%
  c = trunc4((b - 122.1)/365.25);%@NL@%
  d = 365*c + c / 4;%@NL@%
  e = trunc4((b - d)/30.6001);%@NL@%
  *day = b - d - trunc4(30.6001*e) + juldate - z;%@NL@%
  if (e > 13)%@NL@%
      *month = (int)e - 13;%@NL@%
  else%@NL@%
      *month = (int)e - 1;%@NL@%
  if (*month > 2)%@NL@%
      *year = (int)c - 4716;%@NL@%
  else%@NL@%
      *year = (int)c - 4715;%@NL@%
}%@NL@%
%@NL@%
long PASCAL trunc4( dflValue )%@NL@%
double dflValue;%@NL@%
{%@NL@%
   double intValue;%@NL@%
   modf(dflValue, &intValue);%@NL@%
   return (long)intValue;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BMAP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\MSNGR\BMAP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** MODULE Header ******************************\%@NL@%
%@AB@%* Module Name:  bmap.c - Messenger application - bitmap module%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created: 8/1/89  sanfords%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"msngr.h" %@NL@%
%@AI@%#include %@AE@%"string.h" %@NL@%
%@AI@%#ifdef %@AE@%SLOOP %@NL@%
%@AI@%#define %@AE@%BITMAPINFOHEADER2 BITMAPINFOHEADER %@NL@%
%@AI@%#define %@AE@%PBITMAPINFOHEADER2 PBITMAPINFOHEADER %@NL@%
%@AI@%#define %@AE@%BITMAPINFO2 BITMAPINFO %@NL@%
%@AI@%#define %@AE@%PBITMAPINFO2 PBITMAPINFO %@NL@%
%@AI@%#endif %@AE@%%@NL@%
%@NL@%
typedef struct _CDATA {%@NL@%
    RECTL rcl;%@NL@%
    HBITMAP hbm;%@NL@%
    BOOL fSelect;%@NL@%
    BOOL fSelecting;%@NL@%
    NPUSERLIST npUL;%@NL@%
} CDATA;%@NL@%
typedef CDATA *NPCDATA;%@NL@%
%@NL@%
%@NL@%
typedef struct _PKT {%@NL@%
    HBITMAP hbm;%@NL@%
    SHORT cx;%@NL@%
    SHORT cy;%@NL@%
    char szName[MAX_NAMESTR + 1];%@NL@%
} PKT;%@NL@%
typedef PKT *NPPKT;%@NL@%
%@NL@%
extern HWND hwndMsngr;%@NL@%
extern SHORT cyText;%@NL@%
extern HAB hab;%@NL@%
extern HSZ hszAppName;%@NL@%
extern HSZ hszEmailName;%@NL@%
extern char szEmailName[];%@NL@%
extern HWND hwndLB;%@NL@%
extern ITEMLIST msgTopicItemList[];%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * local procs%@NL@%
%@AB@% */%@AE@%%@NL@%
MRESULT bmpInit(HWND hwnd, NPPKT ppktInit);%@NL@%
MRESULT sndBmapInit(HWND hwnd, NPUSERLIST pUserItem);%@NL@%
BOOL sndBmap(NPCDATA pcd);%@NL@%
HBITMAP SnapRegion(HPS hps, PRECTL prcl);%@NL@%
void DrawRgn(HPS hps, PRECTL prcl);%@NL@%
void SortRect(PRECTL prcl, PRECTL prclSorted);%@NL@%
HDC CreateDC(PSZ lpszDriver, HDC hdcCompat);%@NL@%
%@NL@%
%@AI@%#define %@AE@%max(a,b)    (((a) > (b)) ? (a) : (b)) %@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * file globals%@NL@%
%@AB@% */%@AE@%%@NL@%
ATOM fmtBmapPkt;%@NL@%
HPOINTER hptrSelBmap = 0;%@NL@%
HPOINTER hptrBmap = 0;%@NL@%
%@NL@%
void InitBmapModule()%@NL@%
{%@NL@%
    fmtBmapPkt = WinAddAtom(WinQuerySystemAtomTable(), SZBMAPDATA);%@NL@%
    hptrSelBmap = WinLoadPointer(HWND_DESKTOP, (HMODULE)NULL, IDR_SELBMAP);%@NL@%
    hptrBmap = WinLoadPointer(HWND_DESKTOP, NULL, IDD_GETBITMAP);%@NL@%
} %@NL@%
%@NL@%
void CloseBmapModule()%@NL@%
{%@NL@%
    WinDeleteAtom(WinQuerySystemAtomTable(), fmtBmapPkt);%@NL@%
    WinDestroyPointer(hptrSelBmap);%@NL@%
    WinDestroyPointer(hptrBmap);%@NL@%
}%@NL@%
%@NL@%
HDMGDATA bmpXfer(pXferInfo)%@NL@%
PXFERINFO pXferInfo;%@NL@%
{%@NL@%
    PBYTE pbuf;%@NL@%
    PKT pkt;%@NL@%
    PBITMAPINFO pbmi;%@NL@%
    HDC hdc;%@NL@%
    HPS hpsMem;%@NL@%
    SIZEL size;%@NL@%
%@NL@%
    if (pXferInfo->usFmt != fmtBmapPkt)%@NL@%
        return(DDE_NOTPROCESSED);%@NL@%
%@NL@%
    if (pXferInfo->usType == XTYP_POKE) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * we have bitmap bits...stick them into pkt.hbm.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        pbuf = DdeAccessData(pXferInfo->hDmgData);%@NL@%
        %@NL@%
        DdeCopyBlock(pbuf, (PBYTE)&pkt.szName[0], MAX_NAMESTR + 1L);%@NL@%
        pbmi = (PBITMAPINFO)(pbuf + MAX_NAMESTR + 1);%@NL@%
%@NL@%
        pkt.cx = pbmi->cx;%@NL@%
        pkt.cy = pbmi->cy;%@NL@%
        size.cx = (LONG)pkt.cx;%@NL@%
        size.cy = (LONG)pkt.cy;%@NL@%
        hdc = CreateDC((PSZ)"MEMORY", (HDC)NULL);%@NL@%
        hpsMem = GpiCreatePS(hab, hdc, &size,%@NL@%
                PU_ARBITRARY | GPIT_NORMAL | GPIA_ASSOC );%@NL@%
        pkt.hbm = GpiCreateBitmap(hpsMem, (PBITMAPINFOHEADER2)pbmi, CBM_INIT,%@NL@%
                (PBYTE)&pbmi->argbColor[1 << pbmi->cBitCount],%@NL@%
                (PBITMAPINFO2)pbmi);%@NL@%
        GpiAssociate(hpsMem, NULL);%@NL@%
        GpiDestroyPS(hpsMem);%@NL@%
        DevCloseDC(hdc);%@NL@%
        DdeFreeData(pXferInfo->hDmgData);%@NL@%
        %@NL@%
        WinLoadDlg(HWND_DESKTOP, hwndMsngr, BmpDlgProc, 0L, IDD_GETBITMAP,%@NL@%
                (PVOID)&pkt);%@NL@%
        return(1);%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This is the proc used for receiving a bitmap%@NL@%
%@AB@% */%@AE@%%@NL@%
MRESULT EXPENTRY BmpDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    HBITMAP hbm;%@NL@%
    HPS hps;%@NL@%
    WRECT wrc;%@NL@%
    %@NL@%
    switch(msg) {%@NL@%
    case WM_INITDLG:%@NL@%
        return(bmpInit(hwnd, (NPPKT)(SHORT)mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
        if (hbm = ((NPPKT)WinQueryWindowUShort(hwnd, QWS_USER))->hbm)%@NL@%
            GpiDeleteBitmap(hbm);%@NL@%
        WinFreeMem(hheap, (NPBYTE)WinQueryWindowUShort(hwnd, QWS_USER),%@NL@%
                sizeof(PKT));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_WINDOWPOSCHANGED:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * hide the OK button when minimized since it messes up the icon.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((LONG)mp2 & AWP_MINIMIZED)%@NL@%
            WinShowWindow(WinWindowFromID(hwnd, MBID_OK), FALSE);%@NL@%
        else if ((LONG)mp2 & AWP_RESTORED)%@NL@%
            WinShowWindow(WinWindowFromID(hwnd, MBID_OK), TRUE);%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        WinDestroyWindow(hwnd);%@NL@%
        break;%@NL@%
        %@NL@%
    case WM_PAINT:%@NL@%
        WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * draw the bitmap just above the OK button.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
        WinQueryWindowRect(WinWindowFromID(hwnd, MBID_OK), (PRECTL)&wrc);%@NL@%
        WinMapWindowPoints(WinWindowFromID(hwnd, MBID_OK), hwnd, (PPOINTL)&wrc, 2);%@NL@%
        wrc.yBottom = wrc.yTop + cyText / 2;%@NL@%
        hbm = ((NPPKT)WinQueryWindowUShort(hwnd, QWS_USER))->hbm;%@NL@%
        WinDrawBitmap(hps, hbm, (PRECTL)NULL, (PPOINTL)&wrc, 0L, 0L, DBM_NORMAL);%@NL@%
        WinReleasePS(hps);%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
MRESULT bmpInit(hwnd, ppktInit)%@NL@%
HWND hwnd;%@NL@%
NPPKT ppktInit;%@NL@%
{%@NL@%
    char szTitle[MAX_TITLESTR];%@NL@%
    WRECT wrc;%@NL@%
    NPPKT ppkt;%@NL@%
    SHORT cxMin;%@NL@%
%@NL@%
    if (!(ppkt = (NPPKT)WinAllocMem(hheap, sizeof(PKT))))%@NL@%
        return(1);    %@NL@%
    *ppkt = *ppktInit;%@NL@%
    WinSetWindowUShort(hwnd, QWL_USER, (USHORT)ppkt);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * This is required because currently, automatic ICON resource loading%@NL@%
%@AB@%     * is not supported for dialogs.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinSendMsg(hwnd, WM_SETICON, (MPARAM)hptrBmap, 0L);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Set up title.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinQueryWindowText(hwnd, MAX_TITLESTR, (PSZ)szTitle);%@NL@%
    lstrcat(szTitle, szTitle, ppkt->szName);%@NL@%
    WinSetWindowText(hwnd, (PSZ)szTitle);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * resize the dialog so the bitmap just fits.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinQueryWindowRect(hwnd, (PRECTL)&wrc);%@NL@%
    cxMin = wrc.xRight;%@NL@%
    WinQueryWindowRect(WinWindowFromID(hwnd, MBID_OK), (PRECTL)&wrc);%@NL@%
    WinMapWindowPoints(WinWindowFromID(hwnd, MBID_OK), hwnd, (PPOINTL)&wrc, 2);%@NL@%
    WinSetWindowPos(hwnd, NULL, 0, 0, max(wrc.xLeft * 2 + ppkt->cx, cxMin),%@NL@%
            wrc.yTop + ppkt->cy + cyText +%@NL@%
            (SHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYTITLEBAR), SWP_SIZE);%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY SendBitmapDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    NPCDATA pcd;%@NL@%
    POINTL pt;%@NL@%
    HPS hps;%@NL@%
%@NL@%
    pcd = (NPCDATA)WinQueryWindowUShort(hwnd, QWS_USER);%@NL@%
    %@NL@%
    switch (msg) {%@NL@%
    case WM_INITDLG:%@NL@%
        return(sndBmapInit(hwnd, (NPUSERLIST)(SHORT)mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
        WinFreeMem(hheap, (NPBYTE)pcd, sizeof(CDATA));%@NL@%
        break;%@NL@%
        %@NL@%
    case WM_COMMAND:%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
        case IDC_SENDBITMAP:%@NL@%
            if (sndBmap(pcd))%@NL@%
                WinDismissDlg(hwnd, 0);%@NL@%
            break;%@NL@%
            %@NL@%
        case MBID_CANCEL:                    %@NL@%
            WinDismissDlg(hwnd, 0);%@NL@%
            break;%@NL@%
            %@NL@%
        case IDC_SELECT:%@NL@%
            pcd->fSelect = TRUE;%@NL@%
            WinSetCapture(HWND_DESKTOP, hwnd);%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1DOWN:%@NL@%
        if (pcd->fSelect) {%@NL@%
            if (pcd->hbm) {%@NL@%
                GpiDeleteBitmap(pcd->hbm);%@NL@%
                pcd->hbm = NULL;%@NL@%
            }%@NL@%
            WinSetRect(hab, &pcd->rcl, SHORT1FROMMP(mp1), SHORT2FROMMP(mp1),%@NL@%
                    SHORT1FROMMP(mp1), SHORT2FROMMP(mp1));%@NL@%
            WinMapWindowPoints(hwnd, (HWND)HWND_DESKTOP, (PPOINTL)&pcd->rcl, 2);%@NL@%
            hps = WinGetScreenPS(HWND_DESKTOP);%@NL@%
            DrawRgn(hps, &pcd->rcl);%@NL@%
            WinReleasePS(hps);%@NL@%
            pcd->fSelecting = TRUE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_MOUSEMOVE:%@NL@%
        if (pcd->fSelect) {%@NL@%
            WinSetPointer(HWND_DESKTOP, hptrSelBmap);%@NL@%
        } else {%@NL@%
            WinSetPointer(HWND_DESKTOP,%@NL@%
                    WinQuerySysPointer(HWND_DESKTOP, SPTR_ARROW, FALSE));%@NL@%
        }%@NL@%
        if (pcd->fSelecting) {%@NL@%
            hps = WinGetScreenPS(HWND_DESKTOP);%@NL@%
            DrawRgn(hps, &pcd->rcl);    %@AB@%/* erase old rect */%@AE@%%@NL@%
            pt.x = SHORT1FROMMP(mp1);%@NL@%
            pt.y = SHORT2FROMMP(mp1);%@NL@%
            WinMapWindowPoints(hwnd, HWND_DESKTOP, &pt, 1);%@NL@%
            pcd->rcl.xRight = pt.x;%@NL@%
            pcd->rcl.yTop = pt.y;%@NL@%
            DrawRgn(hps, &pcd->rcl);    %@AB@%/* draw new one */%@AE@%%@NL@%
            WinReleasePS(hps);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1UP:%@NL@%
        if (pcd->fSelecting) {%@NL@%
            WinSetCapture(HWND_DESKTOP, (HWND)NULL);%@NL@%
            hps = WinGetScreenPS(HWND_DESKTOP);%@NL@%
            DrawRgn(hps, &pcd->rcl);%@NL@%
            pcd->hbm = SnapRegion(hps, &pcd->rcl);%@NL@%
            WinReleasePS(hps);%@NL@%
            pcd->fSelecting = FALSE;%@NL@%
            pcd->fSelect = FALSE;%@NL@%
            WinEnableWindow(WinWindowFromID(hwnd, IDC_SENDBITMAP),%@NL@%
                    !WinIsRectEmpty(hab, &pcd->rcl));%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
        %@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * returns fFailed%@NL@%
%@AB@% */%@AE@%%@NL@%
MPARAM sndBmapInit(hwnd, pUserItem)%@NL@%
HWND hwnd;%@NL@%
NPUSERLIST pUserItem;%@NL@%
{%@NL@%
    NPCDATA pcd;%@NL@%
    char szTitle[MAX_TITLESTR];%@NL@%
    char szName[MAX_NAMESTR];%@NL@%
    %@NL@%
    if (!(pcd = (NPCDATA)WinAllocMem(hheap, sizeof(CDATA))))%@NL@%
        return(1);%@NL@%
    WinSetRectEmpty(hab, &pcd->rcl);%@NL@%
    pcd->hbm = NULL;%@NL@%
    pcd->fSelect = FALSE;%@NL@%
    pcd->fSelecting = FALSE;%@NL@%
    pcd->npUL = pUserItem;%@NL@%
    if (pcd->npUL->hConvMsg == NULL) {%@NL@%
        NotifyUser(SZCANTCONNECT);%@NL@%
        return(1);%@NL@%
    }%@NL@%
    WinQueryWindowText(hwnd, MAX_TITLESTR, szTitle);%@NL@%
    DdeGetHszString(pcd->npUL->hsz, szName, (LONG)MAX_NAMESTR);%@NL@%
    lstrcat(szTitle, szTitle, szName);%@NL@%
    WinSetWindowText(hwnd, (PSZ)szTitle);%@NL@%
    WinSetWindowUShort(hwnd, QWS_USER, (USHORT)pcd);%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
BOOL sndBmap(pcd)%@NL@%
NPCDATA pcd;%@NL@%
{%@NL@%
    BITMAPINFOHEADER bih;%@NL@%
    SHORT cbBuffer, cbBitmapInfo;%@NL@%
    PBYTE pbBuffer;%@NL@%
    PBITMAPINFO pbmi;%@NL@%
    PSZ pszName;%@NL@%
    SEL sel;%@NL@%
    HPS hps;%@NL@%
    HDC hdc;%@NL@%
    SIZEL size;%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Compute the size of the image-data buffer and the bitmap information%@NL@%
%@AB@%     * structure.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    GpiQueryBitmapParameters(pcd->hbm, &bih);%@NL@%
    cbBuffer = (((bih.cBitCount * bih.cx) + 31) / 32) * 4;%@NL@%
    if (cbBuffer > 0xFFFF / bih.cy / bih.cPlanes) {%@NL@%
        NotifyUser(SZTOOBIG);%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    cbBuffer *= bih.cy * bih.cPlanes;%@NL@%
    cbBitmapInfo = sizeof(BITMAPINFO) +%@NL@%
        (sizeof(RGB) * (1 << bih.cBitCount));%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Allocate memory for the image data-buffer and the bitmap information%@NL@%
%@AB@%     * structure.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    DosAllocSeg(cbBuffer + cbBitmapInfo + MAX_NAMESTR + 1, &sel, 0);%@NL@%
    pszName = (PSZ)MAKEP(sel, 0);%@NL@%
    lstrcpy(pszName, szEmailName);%@NL@%
    pbmi = (PBITMAPINFO)(pszName + MAX_NAMESTR + 1);%@NL@%
    pbBuffer = (PBYTE)&pbmi->argbColor[1 << bih.cBitCount];%@NL@%
    *(PBITMAPINFOHEADER)pbmi = bih;%@NL@%
%@NL@%
    size.cx = (LONG)bih.cx;%@NL@%
    size.cy = (LONG)bih.cy;%@NL@%
    hdc = CreateDC((PSZ)"MEMORY", (HDC)NULL);%@NL@%
    hps = GpiCreatePS(hab, hdc, &size,%@NL@%
            PU_ARBITRARY | GPIT_NORMAL | GPIA_ASSOC );%@NL@%
    GpiSetBitmap(hps, pcd->hbm);%@NL@%
    GpiQueryBitmapBits(hps, 0L, (LONG)bih.cy, (PBYTE)pbBuffer,%@NL@%
            (PBITMAPINFO2)pbmi);%@NL@%
    GpiAssociate(hps, NULL);%@NL@%
    GpiDestroyPS(hps);%@NL@%
    DevCloseDC(hdc);%@NL@%
%@NL@%
    if (!DdeClientXfer(pszName,%@NL@%
            (LONG)(cbBuffer + cbBitmapInfo + MAX_NAMESTR + 1),%@NL@%
            pcd->npUL->hConvMsg,%@NL@%
            msgTopicItemList[IIL_BMPXFER].hszItem,%@NL@%
            fmtBmapPkt, XTYP_POKE, ulTimeout, 0L)) {%@NL@%
        MyPostError(DdeGetLastError());%@NL@%
    }%@NL@%
%@NL@%
    DosFreeSeg(sel);%@NL@%
    GpiDeleteBitmap(pcd->hbm);%@NL@%
    pcd->hbm = NULL;%@NL@%
    WinSetRectEmpty(hab, &pcd->rcl);%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
HBITMAP SnapRegion(hps, prcl)%@NL@%
HPS hps;%@NL@%
PRECTL prcl;%@NL@%
{%@NL@%
    HDC hdc;%@NL@%
    HBITMAP hbm, hbmOld;%@NL@%
    BITMAPINFOHEADER bih;%@NL@%
    POINTL rgpt[3];%@NL@%
    HPS hpsMem;%@NL@%
    SIZEL size;%@NL@%
%@NL@%
    SortRect(prcl, prcl);%@NL@%
    WinInflateRect(hab, prcl, -1, -1);%@NL@%
%@NL@%
    size.cx = (USHORT)(prcl->xRight - prcl->xLeft);%@NL@%
    size.cy = (USHORT)(prcl->yTop - prcl->yBottom);%@NL@%
%@NL@%
    %@AB@%/* Create a memory DC */%@AE@%%@NL@%
    hdc = CreateDC((PSZ)"MEMORY", (HDC)NULL);%@NL@%
%@NL@%
    %@AB@%/* create a memory PS */%@AE@%%@NL@%
    hpsMem = GpiCreatePS(hab, hdc, &size,%@NL@%
            PU_ARBITRARY | GPIT_NORMAL | GPIA_ASSOC );%@NL@%
%@NL@%
    %@AB@%/* Create a bitmap */%@AE@%%@NL@%
    bih.cbFix = sizeof(BITMAPINFOHEADER);%@NL@%
    bih.cx = (SHORT)size.cx;%@NL@%
    bih.cy = (SHORT)size.cy;%@NL@%
    bih.cPlanes = 1;%@NL@%
    bih.cBitCount = 8;%@NL@%
    hbm = GpiCreateBitmap(hpsMem, (PBITMAPINFOHEADER2)&bih, 0L, 0, 0);%@NL@%
    if (hbm == GPI_ERROR) %@NL@%
        return(0);%@NL@%
    %@NL@%
    %@AB@%/* put the bitmap into the memory PS */%@AE@%%@NL@%
    hbmOld = GpiSetBitmap(hpsMem, hbm);%@NL@%
%@NL@%
    %@AB@%/* copy the window to the memory PS */%@AE@%%@NL@%
    rgpt[0].x = 0;%@NL@%
    rgpt[0].y = 0;%@NL@%
    rgpt[1].x = size.cx;%@NL@%
    rgpt[1].y = size.cy;%@NL@%
    rgpt[2].x = prcl->xLeft;%@NL@%
    rgpt[2].y = prcl->yBottom;%@NL@%
    GpiBitBlt(hpsMem, hps, 3L, (PPOINTL)&rgpt[0], ROP_SRCCOPY, 0L);%@NL@%
%@NL@%
    %@AB@%/* free the bitmap */%@AE@%%@NL@%
    GpiSetBitmap(hpsMem, hbmOld);%@NL@%
%@NL@%
    %@AB@%/* destroy the memory DC */%@AE@%%@NL@%
    GpiAssociate(hpsMem, NULL);%@NL@%
    GpiDestroyPS(hpsMem);%@NL@%
    DevCloseDC(hdc);%@NL@%
    return(hbm);%@NL@%
} %@AB@%/* end snapregion */%@AE@%%@NL@%
%@NL@%
%@NL@%
HDC CreateDC(lpszDriver, hdcCompat)%@NL@%
PSZ  lpszDriver;%@NL@%
HDC hdcCompat;%@NL@%
{%@NL@%
    struct {%@NL@%
        ULONG FAR *lpLogAddr;%@NL@%
        PSZ  lpszDriver;%@NL@%
    } opendc;%@NL@%
%@NL@%
    opendc.lpLogAddr = NULL;%@NL@%
    opendc.lpszDriver = lpszDriver;%@NL@%
%@NL@%
    return((HDC)DevOpenDC(hab, OD_MEMORY, (PSZ)"*", 2L,%@NL@%
            (PDEVOPENDATA)&opendc, hdcCompat));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void DrawRgn(hps, prcl)%@NL@%
HPS hps;%@NL@%
PRECTL prcl;%@NL@%
{%@NL@%
    RECTL rclSorted;%@NL@%
    %@NL@%
    SortRect(prcl, &rclSorted);%@NL@%
    WinDrawBorder(hps, &rclSorted, 1, 1, SYSCLR_WINDOW, SYSCLR_WINDOW,%@NL@%
            DB_DESTINVERT | DB_STANDARD);%@NL@%
}%@NL@%
%@NL@%
void SortRect(prcl, prclSorted)%@NL@%
PRECTL prcl;%@NL@%
PRECTL prclSorted;%@NL@%
{%@NL@%
    LONG l;%@NL@%
%@NL@%
    WinCopyRect(hab, prclSorted, prcl);%@NL@%
    if (prclSorted->yTop < prclSorted->yBottom) {%@NL@%
        l = prclSorted->yBottom;%@NL@%
        prclSorted->yBottom = prclSorted->yTop;%@NL@%
        prclSorted->yTop = l;%@NL@%
    }%@NL@%
    %@NL@%
    if (prclSorted->xRight < prclSorted-> xLeft) {%@NL@%
        l = prclSorted->xRight;%@NL@%
        prclSorted->xRight = prclSorted->xLeft;%@NL@%
        prclSorted->xLeft = l;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BROWSE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\BROWSE\AVBROWSE\BROWSE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    browse.c -- AVIO File Browsing Utility%@NL@%
%@AB@%%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%       INCL_WINTRACKRECT %@NL@%
%@AI@%#define %@AE@%       INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%       INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"avio.h" %@NL@%
%@AI@%#include %@AE@%"browse.h" %@NL@%
%@AI@%#include %@AE@%<opendlg.h> %@NL@%
%@AB@%/*%@NL@%
%@AB@%    Constants%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%MAXLINELEN        120 %@NL@%
%@AI@%#define %@AE@%AVIO_PS_ROWS        25 %@NL@%
%@AI@%#define %@AE@%       AVIO_PS_COLS        80 %@NL@%
%@AB@%/*%@NL@%
%@AB@%    Global Variables%@NL@%
%@AB@%*/%@AE@%%@NL@%
FILE        *pfInput;%@NL@%
PFNWP        pfnOldClient;%@NL@%
char        *aszLines[NUM_DATA_LINES];%@NL@%
SHORT        sTopLine = 0;%@NL@%
DLF        dlfInput;%@NL@%
HFILE        hfInput;%@NL@%
USHORT        usAction;%@NL@%
LBINFO        lbiData;%@NL@%
HPOINTER hptrWait;%@NL@%
HPOINTER hptrArrow;%@NL@%
HWND        hWndClient;%@NL@%
HWND        hWndFrame;%@NL@%
BOOL        fLargeFont = FALSE;%@NL@%
SHORT        sMaxLine;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Open the input file%@NL@%
%@AB@%*/%@AE@%%@NL@%
int cdecl main(int argc, char *argv[]) {%@NL@%
     static CHAR szClientClass[] = "Browse";%@NL@%
     static CHAR szCaption[]         = "";%@NL@%
     HAB        hAB;%@NL@%
     HMQ        hmq;%@NL@%
     QMSG        qmsg;%@NL@%
     ULONG        flFrameFlags = FCF_STANDARD | FCF_HORZSCROLL | FCF_VERTSCROLL;%@NL@%
     ULONG         flFrameStyle = WS_VISIBLE | FS_SCREENALIGN;%@NL@%
     char        *szInFile;%@NL@%
%@NL@%
     hAB = WinInitialize(0);%@NL@%
     hmq = WinCreateMsgQueue(hAB, 0);%@NL@%
%@NL@%
     WinRegisterClass(hAB, szClientClass, BrowseWndProc, CS_SYNCPAINT, 0);%@NL@%
%@NL@%
     hWndFrame = WinCreateStdWindow(HWND_DESKTOP, flFrameStyle,%@NL@%
                                    &flFrameFlags, szClientClass, szCaption,%@NL@%
                                     0L, (HMODULE) NULL, ID_RESOURCE, &hWndClient);%@NL@%
     %@AB@%/*%@NL@%
%@AB@%        Get the hourglass and arrow pointers%@NL@%
%@AB@%     */%@AE@%%@NL@%
     hptrWait  = WinQuerySysPointer(HWND_DESKTOP, SPTR_WAIT,  FALSE);%@NL@%
     hptrArrow = WinQuerySysPointer(HWND_DESKTOP, SPTR_ARROW, FALSE);%@NL@%
%@NL@%
     if (argc == 1) pfInput = stdin;%@NL@%
     else {%@NL@%
        if (!(pfInput = fopen(argv[1], "r"))) {%@NL@%
            fprintf(stderr, "***Error:  Could not open %s", szInFile);%@NL@%
            return(-1);%@NL@%
        }%@NL@%
     }%@NL@%
     ReadFile();%@NL@%
     %@AB@%/*%@NL@%
%@AB@%        Setup AVIO PS and force a paint%@NL@%
%@AB@%        Note:  This subclasses the client and frame windows%@NL@%
%@AB@%     */%@AE@%%@NL@%
     lbiData.sPSrows        = AVIO_PS_ROWS;%@NL@%
     lbiData.sPScols        = AVIO_PS_COLS;%@NL@%
     lbiData.sRows        = sTopLine;%@NL@%
     lbiData.sCols        = sMaxLine;%@NL@%
     lbiData.pfnQL        = (PFNQL) RetrieveLine;%@NL@%
     lbiData.fLargeFont        = FALSE;%@NL@%
     AvioInit(&lbiData);%@NL@%
     %@AB@%/*%@NL@%
%@AB@%        Process messages%@NL@%
%@AB@%     */%@AE@%%@NL@%
     while (WinGetMsg(hAB, &qmsg, NULL, 0, 0)) WinDispatchMsg(hAB, &qmsg);%@NL@%
%@NL@%
     %@AB@%/* Blast the AVIO PS */%@AE@%%@NL@%
     AvioClose();%@NL@%
%@NL@%
     WinDestroyWindow(hWndFrame);%@NL@%
     WinDestroyMsgQueue(hmq);%@NL@%
     WinTerminate(hAB);%@NL@%
     return 0;%@NL@%
}%@NL@%
%@NL@%
void ReadFile(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Reads in a file using <stdio.h> fgets() calls.%@NL@%
%@AB@%    It might be wise to put better word wrap facilities here%@NL@%
%@AB@%*/%@AE@%%@NL@%
    char        szLine[MAXLINELEN];%@NL@%
%@NL@%
    %@AB@%/* Put up the hourglass */%@AE@%%@NL@%
    WinSetPointer(HWND_DESKTOP, hptrWait);%@NL@%
%@NL@%
    %@AB@%/* Reinitialize buffer, MaxLineLength */%@AE@%%@NL@%
    for (; sTopLine > 0; ) free(aszLines[--sTopLine]);%@NL@%
    sMaxLine = 0;%@NL@%
%@NL@%
    %@AB@%/* Read in the file */%@AE@%%@NL@%
    while (fgets(szLine, MAXLINELEN, pfInput)) {%@NL@%
%@NL@%
        %@AB@%/* Convert LF (\n) into NULL (\0) */%@AE@%%@NL@%
        if (szLine[strlen(szLine) - 1] == '\n') {%@NL@%
            szLine[strlen(szLine) - 1] = 0;%@NL@%
        } else szLine[MAXLINELEN - 1] = 0;%@NL@%
%@NL@%
        if (StoreLine(szLine)) {%@NL@%
            fprintf(stderr,"***Error:  Line buffer full\n");%@NL@%
            return;%@NL@%
        }%@NL@%
    }%@NL@%
    fclose(pfInput);%@NL@%
%@NL@%
    %@AB@%/* Reset the mouse pointer */%@AE@%%@NL@%
    WinSetPointer(HWND_DESKTOP, hptrArrow);%@NL@%
%@NL@%
    return;%@NL@%
}%@NL@%
%@NL@%
SHORT StoreLine(char *szLine) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Put a line into the line buffer; line numbers are free%@NL@%
%@AB@%    For > 64K data, add code here and in RetrieveLine%@NL@%
%@AB@%*/%@AE@%%@NL@%
    int                i, cLinePos;%@NL@%
    BOOL        fDone;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Check if top line exceeded, or malloc() fails%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (sTopLine == NUM_DATA_LINES)  return -1;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Compute line length with tabs expanded%@NL@%
%@AB@%    */%@AE@%%@NL@%
    cLinePos = 0;%@NL@%
    for (i = 0; i < MAXLINELEN; i++) {%@NL@%
        switch(szLine[i]) {%@NL@%
            case '\0':%@NL@%
                cLinePos++; i = MAXLINELEN;%@NL@%
                break;%@NL@%
            case '\t':%@NL@%
                do {%@NL@%
                    cLinePos++;%@NL@%
                } while (cLinePos % 8);%@NL@%
                break;%@NL@%
%@NL@%
            default:%@NL@%
                cLinePos++;%@NL@%
        }%@NL@%
%@NL@%
    }%@NL@%
    if (cLinePos > sMaxLine) sMaxLine = cLinePos;%@NL@%
    if (!(aszLines[sTopLine] = malloc(cLinePos))) return -1;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Copy szLine into the line buffer.  Expand tabs here.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    i = cLinePos = 0; fDone = FALSE;%@NL@%
    while ((i <= MAXLINELEN) && (!fDone)) {%@NL@%
        switch(szLine[i]) {%@NL@%
            case '\t':%@NL@%
                do {%@NL@%
                    aszLines[sTopLine][cLinePos++] = ' ';%@NL@%
                } while (cLinePos % 8);%@NL@%
                break;%@NL@%
%@NL@%
            default:%@NL@%
                aszLines[sTopLine][cLinePos++] = szLine[i];%@NL@%
                fDone = !szLine[i];%@NL@%
                break;%@NL@%
        }%@NL@%
        i++;%@NL@%
    }%@NL@%
    sTopLine++;%@NL@%
    return 0;%@NL@%
}%@NL@%
%@NL@%
char * _loadds RetrieveLine(USHORT usLineNum) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Return line numbered usLineNum%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if ((SHORT) usLineNum >= sTopLine) {                %@AB@%/* Out of range */%@AE@%%@NL@%
        return NULL;%@NL@%
    }%@NL@%
    return aszLines[usLineNum];%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK BrowseWndProc(hWnd, msg, mp1, mp2)%@NL@%
HWND hWnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Handle the About... and Open... messages%@NL@%
%@AB@%*/%@AE@%%@NL@%
    switch(msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch (COMMANDMSG(&msg)->cmd) {%@NL@%
                case IDM_ABOUT:%@NL@%
                    WinDlgBox(HWND_DESKTOP, hWnd, AboutDlgProc,%@NL@%
                              (HMODULE) NULL, IDD_ABOUT, NULL);%@NL@%
                    return 0;%@NL@%
%@NL@%
                case IDM_OPEN:%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                        Open the file, using the file dialog%@NL@%
%@AB@%                        then reopen it with stdio calls%@NL@%
%@AB@%                    */%@AE@%%@NL@%
                    SetupDLF(&dlfInput, DLG_OPENDLG, &hfInput,%@NL@%
                        "\\*.*", NULL, "Browse Open File",%@NL@%
                        "Select a file to be browsed.");%@NL@%
                    DlgFile(hWnd, &dlfInput);%@NL@%
                    pfInput = fopen(dlfInput.szOpenFile, "r");%@NL@%
                    ReadFile();%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                        Close the opened handle%@NL@%
%@AB@%                    */%@AE@%%@NL@%
                    DosClose(hfInput);%@NL@%
%@NL@%
                    %@AB@%/* Fix up the screen display */%@AE@%%@NL@%
                    lbiData.sRows = sTopLine;%@NL@%
                    lbiData.sCols = sMaxLine;%@NL@%
                    lbiData.fLargeFont = fLargeFont;%@NL@%
                    AvioInit(&lbiData);%@NL@%
%@NL@%
                    return 0;%@NL@%
%@NL@%
                case IDM_FONT:%@NL@%
                    AvioLargeFont(fLargeFont = !fLargeFont);%@NL@%
                       return 0;%@NL@%
%@NL@%
                default: return 0;%@NL@%
            }%@NL@%
            break;%@NL@%
        default: return WinDefWindowProc(hWnd, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK AboutDlgProc(hDlg, msg, mp1, mp2)%@NL@%
%@AB@%/*%@NL@%
%@AB@%    About... dialog procedure%@NL@%
%@AB@%*/%@AE@%%@NL@%
HWND        hDlg;%@NL@%
USHORT        msg;%@NL@%
MPARAM        mp1;%@NL@%
MPARAM        mp2;%@NL@%
{%@NL@%
    switch(msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case DID_OK: WinDismissDlg(hDlg, TRUE); break;%@NL@%
                default: break;%@NL@%
            }%@NL@%
        default: return WinDefDlgProc(hDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BROWSE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\BROWSE\VBROWSE\BROWSE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    VIO File Browsing Application%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%        INCL_KBD %@NL@%
%@AI@%#define %@AE@%        INCL_VIO %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"browse.h" %@NL@%
%@AB@%/*%@NL@%
%@AB@%    Global Variables%@NL@%
%@AB@%*/%@AE@%%@NL@%
FILE        *pfInput;%@NL@%
char        *aszLines[NUM_DATA_LINES];%@NL@%
SHORT        sTopLine= -1;%@NL@%
SHORT        sRows;%@NL@%
SHORT        HorScrollPos=0;%@NL@%
BYTE        abBlank[2] = { 0x20, 0x07 }; %@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Macros for Vio calls%@NL@%
%@AB@%    The last parameter is zero because we're using a VIO PS%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%ClearScreen()        VioScrollDn(0, 0, -1, -1, -1, abBlank, 0) %@NL@%
%@AI@%#define %@AE@%       Move(r,c)        VioSetCurPos(r, c, 0) %@NL@%
%@AI@%#define %@AE@%ScrollDown(n)        VioScrollDn(0, 0, -1, -1,  n, abBlank, 0) %@NL@%
%@AI@%#define %@AE@%ScrollUp(n)        VioScrollUp(0, 0, -1, -1,  n, abBlank, 0) %@NL@%
%@AI@%#define %@AE@%Write(s)        VioWrtTTY(s, strlen(s), 0) %@NL@%
%@AB@%/*%@NL@%
%@AB@%    Macros for bounds checking%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%Abs(x)                (((x) > 0) ? (x) : (-(x))) %@NL@%
%@AI@%#define %@AE@%Max(x, y)        (((x) > (y)) ? (x) : (y)) %@NL@%
%@AI@%#define %@AE@%Min(x, y)        (((x) < (y)) ? (x) : (y)) %@NL@%
%@AI@%#define %@AE@%LowerBound(pos, disp, lbound)        Max(pos - disp, lbound) %@NL@%
%@AI@%#define %@AE@%UpperBound(pos, disp, ubound)        Min(pos + disp, ubound) %@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Functions%@NL@%
%@AB@%*/%@AE@%%@NL@%
int cdecl main(int argc, char *argv[]) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Open the input file and initialize globals%@NL@%
%@AB@%*/%@AE@%%@NL@%
    char        *szFilename;%@NL@%
    VIOMODEINFO        viomiMode;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Open the Input File%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (argc == 1)%@NL@%
        pfInput = stdin;%@NL@%
    else {%@NL@%
        szFilename = argv[1];%@NL@%
        if (!(pfInput = fopen(szFilename,"r"))) {%@NL@%
            fprintf(stderr, "***Error:  Could not open %s", szFilename);%@NL@%
            return(-1);%@NL@%
        }%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Read it into the line buffer%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (ReadFile()) return(-1);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Get the video parameters%@NL@%
%@AB@%    */%@AE@%%@NL@%
    viomiMode.cb = sizeof(viomiMode);%@NL@%
    VioGetMode(&viomiMode, 0);%@NL@%
    sRows = (SHORT) viomiMode.row;%@NL@%
%@NL@%
    DisplayScreen(0, TRUE);%@NL@%
    ManipulateFile();%@NL@%
%@NL@%
    return 0;%@NL@%
}%@NL@%
%@NL@%
SHORT ReadFile(VOID) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Read lines from the file into the line buffer%@NL@%
%@AB@%    If there's an error, abort the program (return -1)%@NL@%
%@AB@%*/%@AE@%%@NL@%
    char szLine[MAXLINELENGTH];%@NL@%
%@NL@%
    while (fgets(szLine, MAXLINELENGTH, pfInput)) {%@NL@%
%@NL@%
        %@AB@%/* Convert LF (\n) character to NULL (\0) */%@AE@%%@NL@%
        if (szLine[strlen(szLine)-1] == '\n')%@NL@%
            szLine[strlen(szLine)-1] = 0;%@NL@%
        else {%@NL@%
            fprintf(stderr,"***Error:  Incomplete line read\n");%@NL@%
            return(-1);%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* Put the line into the line buffer */%@AE@%%@NL@%
        if (StoreLine(szLine)) {%@NL@%
            fprintf(stderr,"***Error:  Line buffer full\n");%@NL@%
            return(-1);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* Close the Input file */%@AE@%%@NL@%
    fclose(pfInput);%@NL@%
    return 0;%@NL@%
}%@NL@%
%@NL@%
VOID ManipulateFile(VOID) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Main loop for display processing%@NL@%
%@AB@%*/%@AE@%%@NL@%
    CHAR    ch;%@NL@%
    SHORT   sLine = 0;%@NL@%
%@NL@%
    %@AB@%/* The main command loop */%@AE@%%@NL@%
    while ((ch = GetKbdInput()) != ESC) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Take user input and compute new top line of screen%@NL@%
%@AB@%            by taking appropriate jump in jumptable.%@NL@%
%@AB@%%@NL@%
%@AB@%            Note:  no horizontal scrolling.%@NL@%
%@AB@%        */%@AE@%%@NL@%
        switch (ch) {%@NL@%
        case LINE_UP:         sLine = LowerBound(sLine, 1, 0);                break;%@NL@%
        case LINE_DOWN:  sLine = UpperBound(sLine, 1, BOTTOM);                break;%@NL@%
        case PAGE_UP:         sLine = LowerBound(sLine, sRows, 0);                break;%@NL@%
        case PAGE_DOWN:  sLine = UpperBound(sLine, sRows, BOTTOM);        break;%@NL@%
        case HOME_KEY:         sLine = 0;                                        break;%@NL@%
        case END_KEY:         sLine = BOTTOM;                                break;%@NL@%
        default:                                                        break;%@NL@%
        }%@NL@%
        DisplayScreen((USHORT) sLine, !ch);%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* Set Cursor to the bottom of the screen */%@AE@%%@NL@%
    Move((USHORT) sRows - 1, 0);%@NL@%
}%@NL@%
%@NL@%
SHORT StoreLine(char *szLine) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Put a line into the line buffer; line numbers are free%@NL@%
%@AB@%    For > 64K data, add code here and in RetrieveLine%@NL@%
%@AB@%*/%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Check if top line exceeded, or if malloc() fails%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if ((sTopLine == NUM_DATA_LINES) ||%@NL@%
        ((aszLines[++sTopLine] = malloc(strlen(szLine) + 1)) == NULL))%@NL@%
%@NL@%
        return -1;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Copy szLine into the line buffer%@NL@%
%@AB@%    */%@AE@%%@NL@%
    strcpy(aszLines[sTopLine], szLine);%@NL@%
    return 0;%@NL@%
}%@NL@%
%@NL@%
SHORT RetrieveLine(char **pszLine , USHORT usLineNum) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Return line numbered usLineNum%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if ((SHORT) usLineNum > sTopLine) return -1;  %@AB@%/* Out of range */%@AE@%%@NL@%
    *pszLine = aszLines[usLineNum];%@NL@%
    return 0;%@NL@%
}%@NL@%
%@NL@%
VOID DisplayScreen(USHORT usDisplayTop, BOOL fForceDraw) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Display lines on the screen, starting at usDisplayTop%@NL@%
%@AB@%    by scrolling, then painting new information%@NL@%
%@AB@%*/%@AE@%%@NL@%
    SHORT            sDelta;%@NL@%
    static USHORT   usOldDispTop;%@NL@%
%@NL@%
    sDelta = usDisplayTop - usOldDispTop;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        If only a few lines need repainting...%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if ((Abs(sDelta) < sRows) && !fForceDraw ) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Moving to a "higher line", so:%@NL@%
%@AB@%                Scroll down by the amount (make the difference positive)%@NL@%
%@AB@%                Paint in the lines at the top%@NL@%
%@AB@%        */%@AE@%%@NL@%
        if (sDelta < 0) {%@NL@%
            ScrollDown(-sDelta);%@NL@%
            Refresh(usDisplayTop, -sDelta, 0);%@NL@%
        } else {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Moving to a "lower line", so:%@NL@%
%@AB@%                Scroll the information up, and paint at the bottom%@NL@%
%@AB@%            */%@AE@%%@NL@%
            ScrollUp(sDelta);%@NL@%
            Refresh(usDisplayTop + sRows - sDelta, sDelta, sRows - sDelta);%@NL@%
        }%@NL@%
    } else {        %@AB@%/* Paint the entire screen */%@AE@%%@NL@%
        ClearScreen();%@NL@%
        Refresh(usDisplayTop, sRows, 0);%@NL@%
    }%@NL@%
    usOldDispTop = usDisplayTop;%@NL@%
}%@NL@%
%@NL@%
VOID Refresh (USHORT iLine, USHORT usLines, USHORT usStart) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Updates usLines lines, starting at line iLine in the line%@NL@%
%@AB@%    buffer, and line usStart on the screen%@NL@%
%@AB@%*/%@AE@%%@NL@%
    USHORT usLine;%@NL@%
    char   *szLine;%@NL@%
%@NL@%
    for (usLine = 0; usLine < usLines; usLine++) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Read the line, set the cursor, print the line%@NL@%
%@AB@%        */%@AE@%%@NL@%
        if (RetrieveLine(&szLine, (iLine + usLine))) break;%@NL@%
        Move((usStart + usLine), 0);%@NL@%
        Write(szLine);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
CHAR GetKbdInput(VOID) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Get chars, then check scan codes and return our own values%@NL@%
%@AB@%*/%@AE@%%@NL@%
    KBDKEYINFO kbciKeyInfo;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Wait for characters%@NL@%
%@AB@%    */%@AE@%%@NL@%
    KbdCharIn(&kbciKeyInfo, IO_WAIT, 0);%@NL@%
%@NL@%
    switch (kbciKeyInfo.chScan) {%@NL@%
        case ESC:                         %@AB@%/* escape */%@AE@%%@NL@%
        case LINE_UP:%@NL@%
        case LINE_DOWN:%@NL@%
        case PAGE_UP:%@NL@%
        case PAGE_DOWN:%@NL@%
        case HOME_KEY:%@NL@%
        case END_KEY:%@NL@%
            return kbciKeyInfo.chScan; break;%@NL@%
        default:%@NL@%
           return((CHAR) NULL); break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CALC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CALC\CALC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header *********************************/%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/* Module Name:  calc.c - Calc application                                      */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/* OS/2 Presentation Manager version of Calc, ported from Windows version     */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/* Created by Microsoft Corporation, 1987                                      */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINCLIPBOARD %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%INCL_GPILCIDS %@NL@%
%@AI@%#define %@AE@%INCL_DEV %@NL@%
%@AI@%#define %@AE@%INCL_ERRORS %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_DOSSEMAPHORES %@NL@%
%@AI@%#define %@AE@%INCL_DOSNLS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%"calc.h" %@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/*  GLOBAL VARIABLES                                                              */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@NL@%
CHAR  chLastKey, chCurrKey;%@NL@%
CHAR  szreg1[20], szreg2[20], szmem[20], szregx[20];%@NL@%
CHAR  szTitle[30], szErrorString[20], szPlusMinus[2];%@NL@%
SHORT sCharWidth, sCharHeight;%@NL@%
extern BOOL fError;%@NL@%
BOOL  fValueInMemory = FALSE;%@NL@%
BOOL  fMDown = FALSE;                       %@AB@%/* TRUE iff 'm' key depressed  */%@AE@%%@NL@%
UCHAR uchMScan = 0;                       %@AB@%/* scan code for 'm' key       */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%TOLOWER(x)   ( (((x) >= 'A') && ((x) <= 'Z')) ? (x)|0x20 : (x)) %@NL@%
%@AI@%#define %@AE@%WIDTHCONST  28 %@NL@%
%@AI@%#define %@AE@%CXCHARS     37 %@NL@%
%@AI@%#define %@AE@%CYCHARS     13 %@NL@%
%@NL@%
HAB hab;%@NL@%
HDC hdcLocal;                            %@AB@%/* Local used for button bitmap */%@AE@%%@NL@%
HPS hpsLocal;%@NL@%
HDC hdcSqr;                            %@AB@%/* Sqr used for square-root bitmap */%@AE@%%@NL@%
HPS hpsSqr;%@NL@%
HBITMAP hbmLocal, hbmSqr;%@NL@%
HMQ  hmqCalc;%@NL@%
HWND hwndCalc, hwndMenu;%@NL@%
HWND hwndCalcFrame;%@NL@%
HPS  hpsCalc;%@NL@%
HDC  hdcCalc;%@NL@%
HPOINTER hptrFinger;%@NL@%
%@NL@%
DEVOPENSTRUC dop =                    %@AB@%/* used by DevOpenDC */%@AE@%%@NL@%
{%@NL@%
    NULL, "DISPLAY", NULL, NULL, NULL, NULL, NULL, NULL, NULL%@NL@%
};%@NL@%
%@NL@%
static char achKeys[25] =               %@AB@%/* keyboard keys */%@AE@%%@NL@%
{%@NL@%
    '\271', '0', '.', '\261', '+', '=',%@NL@%
    '\272', '1', '2', '3', '-', 'c',%@NL@%
    '\273', '4', '5', '6', '*', '%',%@NL@%
    '\274', '7', '8', '9', '/', 'q',%@NL@%
    NULL%@NL@%
};%@NL@%
%@NL@%
static CHAR achDKeys[25] =    %@AB@%/* 4th key is plusminus */%@AE@%%@NL@%
{%@NL@%
    ' ', '0', '.', '+', '+', '=',%@NL@%
    ' ', '1', '2', '3', '-', 'C',%@NL@%
    ' ', '4', '5', '6', '*', '%',%@NL@%
    ' ', '7', '8', '9', '/', ' ',%@NL@%
    NULL%@NL@%
};%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/*  PROCEDURE DECLARATIONS                                                      */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID FarStrcpy( PSZ, PSZ);%@NL@%
MPARAM EXPENTRY AboutDlgProc( HWND, USHORT, MPARAM, MPARAM);%@NL@%
BOOL CalcInit(VOID);%@NL@%
VOID CalcPaint( HWND, HPS);%@NL@%
VOID CalcTextOut( HPS, INT, INT, PCH, INT);%@NL@%
MRESULT EXPENTRY CalcWndProc( HWND, USHORT, MPARAM, MPARAM);%@NL@%
VOID cdecl main(VOID);%@NL@%
VOID DataXCopy( VOID);%@NL@%
VOID DataXPaste( VOID);%@NL@%
VOID DrawNumbers( HPS);%@NL@%
VOID Evaluate(BYTE);%@NL@%
BOOL FlashSqr( HPS, PWPOINT);%@NL@%
VOID FlipKey( HPS, INT, INT);%@NL@%
VOID FrameKey( HPS, INT, INT);%@NL@%
VOID InitCalc( VOID);%@NL@%
BOOL InterpretChar( CHAR);%@NL@%
VOID ProcessKey( PWPOINT);%@NL@%
BOOL PSInit( VOID);%@NL@%
CHAR Translate( PWPOINT);%@NL@%
VOID UpdateDisplay( VOID);%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID CalcTextOut( hps, iX, iY, pch, iCount)%@NL@%
%@NL@%
HPS hps;%@NL@%
INT iX, iY;%@NL@%
PCH pch;%@NL@%
INT iCount;%@NL@%
{%@NL@%
    POINTL ptl;%@NL@%
%@NL@%
    ptl.x = iX;%@NL@%
    ptl.y = iY;%@NL@%
%@NL@%
    GpiSetColor( hps, CLR_BLACK);%@NL@%
    GpiCharStringAt( hps, (PPOINTL)&ptl, (LONG)iCount, (PSZ)pch);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/* Write the appropriate number or error string to the display area              */%@AE@%%@NL@%
%@AB@%/* and mark memory-in-use if appropriate.                                      */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
UpdateDisplay()%@NL@%
{%@NL@%
    RECTL rcl;%@NL@%
%@NL@%
    rcl.xLeft = (6 * sCharWidth);%@NL@%
    rcl.yBottom = 1050 * sCharHeight / 100;%@NL@%
    rcl.xRight = rcl.xLeft + (12 * sCharWidth);%@NL@%
    rcl.yTop = rcl.yBottom + (3 * sCharHeight) / 2;%@NL@%
%@NL@%
    WinFillRect( hpsCalc, &rcl, CLR_WHITE);         %@AB@%/* paint display area white */%@AE@%%@NL@%
    if( fError)%@NL@%
        WinDrawText( hpsCalc%@NL@%
                   , -1%@NL@%
                   , szErrorString%@NL@%
                   , &rcl%@NL@%
                   , CLR_BLACK%@NL@%
                   , CLR_WHITE%@NL@%
                   , DT_RIGHT | DT_VCENTER );%@NL@%
    else%@NL@%
        WinDrawText( hpsCalc%@NL@%
                   , -1%@NL@%
                   , szreg1%@NL@%
                   , &rcl%@NL@%
                   , CLR_BLACK%@NL@%
                   , CLR_WHITE%@NL@%
                   , DT_RIGHT | DT_VCENTER );%@NL@%
%@NL@%
    if (fValueInMemory)                 %@AB@%/* little black square shows mem use */%@AE@%%@NL@%
    {%@NL@%
        rcl.xLeft = (6 * sCharWidth);%@NL@%
        rcl.yBottom = 1050 * sCharHeight / 100;%@NL@%
        rcl.xRight = rcl.xLeft + (sCharWidth / 2);%@NL@%
        rcl.yTop = rcl.yBottom + (sCharHeight / 2);%@NL@%
        WinFillRect( hpsCalc, &rcl, CLR_BLACK);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  Display helpful info                                                      */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
MPARAM EXPENTRY%@NL@%
AboutDlgProc( hwnd, msg, mp1, mp2)%@NL@%
%@NL@%
HWND   hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    if (msg == WM_COMMAND)%@NL@%
    {%@NL@%
        WinDismissDlg(hwnd, TRUE);%@NL@%
        return(MPFROMSHORT(TRUE));%@NL@%
    }%@NL@%
    else return(WinDefDlgProc( hwnd, msg, mp1, mp2));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  General initialization                                                      */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
CalcInit()%@NL@%
{%@NL@%
    hab = WinInitialize( NULL);%@NL@%
%@NL@%
    hmqCalc = WinCreateMsgQueue( hab, 0);%@NL@%
    if( !hmqCalc)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    WinLoadString( NULL, NULL, 1, 30, (PSZ)szTitle);%@NL@%
    WinLoadString( NULL, NULL, 2, 20, (PSZ)szErrorString);%@NL@%
    WinLoadString( NULL, NULL, 3, 2, (PSZ)szPlusMinus);%@NL@%
%@NL@%
    if (!WinRegisterClass( hab, szTitle, CalcWndProc, CS_SIZEREDRAW, 0))%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    hptrFinger = WinLoadPointer( HWND_DESKTOP, (HMODULE)NULL, IDP_FINGER);%@NL@%
%@NL@%
    InitCalc();                         %@AB@%/* arithmetic initialization */%@AE@%%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  main procedure                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID cdecl%@NL@%
main()%@NL@%
{%@NL@%
    QMSG  qmsg;%@NL@%
    ULONG ulFCF;%@NL@%
%@NL@%
    if (!CalcInit()) {                            %@AB@%/* general initialization */%@AE@%%@NL@%
        WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
        goto exit;%@NL@%
    }%@NL@%
%@NL@%
    if (!PSInit()) {                            %@AB@%/* presentation spaces & bitmaps */%@AE@%%@NL@%
        WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
        goto exit;%@NL@%
    }%@NL@%
%@NL@%
    ulFCF = FCF_STANDARD & ~(LONG)(FCF_SIZEBORDER | FCF_MAXBUTTON);%@NL@%
    hwndCalcFrame = WinCreateStdWindow( HWND_DESKTOP%@NL@%
                                      , WS_VISIBLE | FS_BORDER%@NL@%
                                      , &ulFCF%@NL@%
                                      , szTitle%@NL@%
                                      , NULL%@NL@%
                                      , 0L%@NL@%
                                      , NULL%@NL@%
                                      , IDR_CALC%@NL@%
                                      , &hwndCalc);%@NL@%
%@NL@%
    WinSetWindowPos( hwndCalcFrame%@NL@%
                   , (HWND)NULL%@NL@%
                   , 2%@NL@%
                   , 2%@NL@%
                   , CXCHARS * sCharWidth%@NL@%
                   , CYCHARS * sCharHeight%@NL@%
                             + (SHORT)WinQuerySysValue( HWND_DESKTOP%@NL@%
                                                      , SV_CYTITLEBAR )%@NL@%
                             + (SHORT)WinQuerySysValue( HWND_DESKTOP%@NL@%
                                                      , SV_CYMENU )%@NL@%
                   , SWP_MOVE | SWP_SIZE );%@NL@%
%@NL@%
    while (WinGetMsg( hab, &qmsg, NULL, 0, 0))%@NL@%
        WinDispatchMsg( hab, &qmsg);%@NL@%
%@NL@%
exit:                                            %@AB@%/* clean up */%@AE@%%@NL@%
    if (hdcSqr)                             %@AB@%/* square-root bitmap */%@AE@%%@NL@%
    {%@NL@%
        GpiDestroyPS( hpsSqr);%@NL@%
        if (hbmSqr)%@NL@%
            GpiDeleteBitmap( hbmSqr);%@NL@%
    }%@NL@%
%@NL@%
    if (hdcLocal)                            %@AB@%/* keypad button */%@AE@%%@NL@%
    {%@NL@%
        GpiDestroyPS( hpsLocal);%@NL@%
        if (hbmLocal)%@NL@%
            GpiDeleteBitmap( hbmLocal);%@NL@%
    }%@NL@%
%@NL@%
    WinDestroyWindow(hwndCalcFrame);%@NL@%
%@NL@%
    WinDestroyMsgQueue(hmqCalc);%@NL@%
    WinTerminate(hab);%@NL@%
%@NL@%
    DosExit(EXIT_PROCESS, 0);                    %@AB@%/* exit without error */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/* Calc Window Procedure                                                      */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY%@NL@%
CalcWndProc(hwnd, msg, mp1, mp2)%@NL@%
%@NL@%
HWND        hwnd;%@NL@%
USHORT        msg;%@NL@%
MPARAM        mp1;%@NL@%
MPARAM        mp2;%@NL@%
{%@NL@%
    HPS     hps;%@NL@%
    RECTL   rclPaint;%@NL@%
    WPOINT  wpt;%@NL@%
    BOOL    fClip;%@NL@%
    USHORT  usFmtInfo;%@NL@%
    RECTL   rcl;%@NL@%
    SIZEL   sizl;%@NL@%
%@NL@%
    switch (msg)%@NL@%
    {%@NL@%
    case WM_CREATE:%@NL@%
        hdcCalc = WinOpenWindowDC( hwnd);%@NL@%
        WinQueryWindowRect( hwnd, &rcl);%@NL@%
        sizl.cx = rcl.xRight - rcl.xLeft;%@NL@%
        sizl.cy = rcl.yTop - rcl.yBottom;%@NL@%
        hpsCalc = GpiCreatePS( hab%@NL@%
                             , hdcCalc%@NL@%
                             , &sizl%@NL@%
                             , GPIA_ASSOC | PU_PELS );%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
        WinDestroyPointer(hptrFinger);%@NL@%
        GpiDestroyPS( hpsSqr);%@NL@%
        GpiDeleteBitmap( hbmSqr);%@NL@%
        GpiDestroyPS( hpsLocal);%@NL@%
        GpiDeleteBitmap( hbmLocal);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_INITMENU:%@NL@%
        fClip = FALSE;%@NL@%
        if (WinOpenClipbrd( hab))%@NL@%
        {%@NL@%
            fClip = WinQueryClipbrdFmtInfo( hab, CF_TEXT, &usFmtInfo);%@NL@%
            WinCloseClipbrd( hab);%@NL@%
        }%@NL@%
        WinSendMsg((HWND)mp2, MM_SETITEMATTR,%@NL@%
                   (MPARAM) MAKELONG(CMD_PASTE, TRUE),%@NL@%
                   (MPARAM) MAKELONG(MIA_DISABLED, fClip ? 0 : MIA_DISABLED));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        hps = WinBeginPaint(hwnd, NULL, &rclPaint);%@NL@%
        CalcPaint( hwnd, hps);                            %@AB@%/* re-draw calculator */%@AE@%%@NL@%
        WinEndPaint(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        if (fError)%@NL@%
            break;%@NL@%
        switch(LOUSHORT(mp1))%@NL@%
        {%@NL@%
        case CMD_COPY:%@NL@%
            DataXCopy();                    %@AB@%/* copy to clipboard */%@AE@%%@NL@%
            break;%@NL@%
        case CMD_PASTE:%@NL@%
            DataXPaste();                    %@AB@%/* paste from clipboard */%@AE@%%@NL@%
            break;%@NL@%
        case CMD_EXIT:%@NL@%
            WinPostMsg( hwndCalcFrame, WM_QUIT, 0L, 0L);%@NL@%
            break;%@NL@%
        case CMD_ABOUT:%@NL@%
            WinDlgBox( HWND_DESKTOP%@NL@%
                     , hwndCalcFrame%@NL@%
                     , (PFNWP)AboutDlgProc%@NL@%
                     , NULL%@NL@%
                     , 1%@NL@%
                     , (PSZ)NULL );%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CLOSE:%@NL@%
        WinPostMsg(hwndCalcFrame, WM_QUIT, 0L, 0L);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_MOUSEMOVE:%@NL@%
        WinSetPointer( HWND_DESKTOP, hptrFinger);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1DOWN:%@NL@%
        wpt.x = LOUSHORT(mp1);%@NL@%
        wpt.y = HIUSHORT(mp1);%@NL@%
        ProcessKey( &wpt);%@NL@%
        goto dwp;%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CHAR:%@NL@%
        if (SHORT1FROMMP(mp1) & KC_KEYUP)%@NL@%
        {%@NL@%
            if (CHAR4FROMMP(mp1) == uchMScan)%@NL@%
                   fMDown = FALSE;                 %@AB@%/* 'm' key went up */%@AE@%%@NL@%
        }%@NL@%
        else %@NL@%
        {%@NL@%
                if (SHORT1FROMMP(mp1) & KC_CHAR)%@NL@%
      {%@NL@%
             if (InterpretChar((UCHAR)SHORT1FROMMP(mp2)))%@NL@%
                  {        %@NL@%
                                UpdateDisplay();%@NL@%
                  }%@NL@%
             else %@NL@%
                  {%@NL@%
                                  if (((UCHAR)SHORT1FROMMP(mp2)== 'm') || ((UCHAR)SHORT1FROMMP(mp2)== 'M'))%@NL@%
                            {%@NL@%
                                        uchMScan = CHAR4FROMMP(mp1);           %@AB@%/* save 'm' key scan code  */%@AE@%%@NL@%
                                        fMDown = TRUE;                           %@AB@%/* 'm' key went down       */%@AE@%%@NL@%
                            }%@NL@%
        }%@NL@%
                }%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_ACTIVATE:%@NL@%
        if (HIUSHORT(mp1))%@NL@%
            WinSetFocus( HWND_DESKTOP, hwndCalc);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_SETFOCUS:%@NL@%
        if ((HWNDFROMMP(mp1)==hwndCalc) && !mp2);%@NL@%
            fMDown = FALSE;                        %@AB@%/* since we are losing focus */%@AE@%%@NL@%
        break;%@NL@%
%@NL@%
dwp:%@NL@%
    default:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  translate & interpret keys (ie. locate in logical keyboard)               */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
InterpretChar( ch)%@NL@%
%@NL@%
CHAR ch;%@NL@%
{%@NL@%
    BOOL fDone;%@NL@%
    NPCH pchStep;%@NL@%
    INT  i;%@NL@%
%@NL@%
    fDone = FALSE;%@NL@%
    pchStep = achKeys;%@NL@%
    switch (ch)%@NL@%
    {%@NL@%
    case 'n':%@NL@%
        ch = szPlusMinus[0];%@NL@%
        break;%@NL@%
    case 27:                        %@AB@%/* xlate Escape into 'c' */%@AE@%%@NL@%
        ch = 'c';%@NL@%
        break;%@NL@%
    case '\r':                      %@AB@%/* xlate Enter into '=' */%@AE@%%@NL@%
        ch = '=';%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    if (fMDown)                     %@AB@%/* Do memory keys */%@AE@%%@NL@%
    {%@NL@%
        switch (ch)%@NL@%
        {%@NL@%
        case 'c':%@NL@%
        case 'C':%@NL@%
            ch = '\274';%@NL@%
            break;%@NL@%
        case 'r':%@NL@%
        case 'R':%@NL@%
            ch = '\273';%@NL@%
            break;%@NL@%
        case '+':%@NL@%
            ch = '\272';%@NL@%
            break;%@NL@%
        case '-':%@NL@%
            ch = '\271';%@NL@%
            break;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    while (!fDone && *pchStep)%@NL@%
    {%@NL@%
        if ((CHAR) *pchStep++ == ch)%@NL@%
            fDone = TRUE;                %@AB@%/* char found in logical keyboard */%@AE@%%@NL@%
    }%@NL@%
    if (fDone)%@NL@%
    {%@NL@%
        chLastKey = chCurrKey;%@NL@%
        i = pchStep - achKeys - 1;%@NL@%
        FlipKey( hpsCalc, i/6, i%6);%@NL@%
        Evaluate( achKeys[i]);%@NL@%
    }%@NL@%
    return (fDone);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  briefly reverse the shading on one of the keys                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
FlipKey( hps, iRow, iCol)%@NL@%
%@NL@%
HPS hps;%@NL@%
INT iRow, iCol;%@NL@%
{%@NL@%
    RECTL rcl;%@NL@%
%@NL@%
    rcl.xLeft = (iCol * 6 * sCharWidth) + (14 * sCharWidth / 10);%@NL@%
    rcl.yBottom = (165 * sCharHeight / 100) + (2 * iRow * sCharHeight);%@NL@%
    rcl.xRight = rcl.xLeft + (11 * sCharWidth / 3);%@NL@%
    rcl.yTop = rcl.yBottom + (7 * sCharHeight / 4);%@NL@%
    WinInvertRect( hps, &rcl);%@NL@%
    DosSleep( 50L);%@NL@%
    WinInvertRect( hps, &rcl);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  compute whether a point is over a button and flash the button if so       */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
FlashSqr( hps, pwpt)%@NL@%
%@NL@%
HPS         hps;%@NL@%
PWPOINT  pwpt;%@NL@%
{%@NL@%
    INT  iRow, iCol;%@NL@%
    BOOL fDone;%@NL@%
%@NL@%
    %@AB@%/* find x range */%@AE@%%@NL@%
    fDone = FALSE;%@NL@%
    iCol = 0;%@NL@%
    iRow = 3;%@NL@%
    while (!fDone && iCol<6)%@NL@%
    {%@NL@%
        if (pwpt->x <        (iCol * 6 * sCharWidth)%@NL@%
                       + (14 * sCharWidth / 10)%@NL@%
                       + (11*sCharWidth/3)         )%@NL@%
        {%@NL@%
            if (pwpt->x > (iCol * 6 * sCharWidth) + (14 * sCharWidth / 10))%@NL@%
                fDone = TRUE;%@NL@%
            else%@NL@%
                return FALSE;%@NL@%
        }%@NL@%
        else%@NL@%
            iCol++;%@NL@%
    }%@NL@%
    if (!fDone)%@NL@%
        return FALSE;%@NL@%
    fDone = FALSE;%@NL@%
    while (!fDone && iRow >= 0)%@NL@%
    {%@NL@%
        if (pwpt->y > ((165 * sCharHeight / 100) + (2 * iRow * sCharHeight)))%@NL@%
        {%@NL@%
            if (pwpt->y <   (165 * sCharHeight / 100)%@NL@%
                           + (2 * iRow * sCharHeight)%@NL@%
                           + (7 * sCharHeight / 4)     )%@NL@%
                fDone = TRUE;%@NL@%
            else%@NL@%
                return FALSE;%@NL@%
        }%@NL@%
        else%@NL@%
            iRow--;%@NL@%
    }%@NL@%
    if (!fDone)%@NL@%
        return FALSE;%@NL@%
    pwpt->x = iCol;%@NL@%
    pwpt->y = iRow;%@NL@%
    FlipKey( hps, iRow, iCol);%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  which key is point on?                                                      */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
CHAR%@NL@%
Translate( pwpt)%@NL@%
%@NL@%
PWPOINT pwpt;%@NL@%
{%@NL@%
    return( achKeys[ pwpt->y * 6 + pwpt->x]);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  invoke flashing, point-to-key translation, and result-display update      */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
ProcessKey( pwpt)%@NL@%
%@NL@%
PWPOINT pwpt;%@NL@%
{%@NL@%
    BOOL fFlashed;%@NL@%
%@NL@%
    chLastKey = chCurrKey;%@NL@%
    fFlashed = FlashSqr( hpsCalc, pwpt);%@NL@%
%@NL@%
    if (fFlashed)%@NL@%
        Evaluate( (BYTE)Translate( pwpt));%@NL@%
    UpdateDisplay();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  draw a blank key                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
FrameKey(hps, iRow, iCol)%@NL@%
%@NL@%
HPS hps;%@NL@%
INT iRow, iCol;%@NL@%
{%@NL@%
    POINTL aptl[3];%@NL@%
%@NL@%
    aptl[0].x = (iCol * 6 * sCharWidth) + (14 * sCharWidth / 10);%@NL@%
    aptl[0].y = (165 * sCharHeight / 100) + (2 * iRow * sCharHeight);%@NL@%
    aptl[1].x = (11 * sCharWidth / 3) + (aptl[0].x);%@NL@%
    aptl[1].y = (7 * sCharHeight / 4) + (aptl[0].y);%@NL@%
    aptl[2].x = 0;%@NL@%
    aptl[2].y = 0;%@NL@%
    GpiBitBlt( hps, hpsLocal, 3L, aptl, ROP_SRCCOPY, BBO_IGNORE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  draw the keys and fill in numbers                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
DrawNumbers(hps)%@NL@%
%@NL@%
HPS hps;%@NL@%
{%@NL@%
    INT iRow, iCol;%@NL@%
%@NL@%
    %@AB@%/* Draw the keys and fill in the numbers we can */%@AE@%%@NL@%
    for (iRow = 0; iRow < 4; iRow++)%@NL@%
    {%@NL@%
        for (iCol = 0; iCol < 6; iCol++)%@NL@%
        {%@NL@%
            FrameKey( hps, iRow, iCol);%@NL@%
            CalcTextOut( hps%@NL@%
                       ,   (iCol * 6 * sCharWidth)%@NL@%
                         + (WIDTHCONST * sCharWidth / 10)%@NL@%
                       , (iRow + 1) * 2 * sCharHeight%@NL@%
                       , (PSZ)(achDKeys + (iRow * 6) + iCol)%@NL@%
                       , 1 );%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  redraw the whole calculator                                               */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
CalcPaint( hwnd, hps)%@NL@%
%@NL@%
HWND hwnd;%@NL@%
HPS  hps;%@NL@%
{%@NL@%
    RECTL      rclDst;%@NL@%
    CHARBUNDLE cbnd;%@NL@%
    INT        iX, iY;%@NL@%
%@NL@%
    WinQueryWindowRect( hwnd, &rclDst);%@NL@%
    WinFillRect( hps, &rclDst, CLR_GREEN);%@NL@%
%@NL@%
    DrawNumbers(hps);%@NL@%
    CalcTextOut(hps, iX = (11 * sCharWidth / 5) + 1, iY = 2 * sCharHeight,%@NL@%
               (PSZ)"M-", 2);%@NL@%
    CalcTextOut(hps, iX, iY + 2 * sCharHeight, (PSZ)"M+", 2);%@NL@%
    CalcTextOut(hps, iX, iY + 4 * sCharHeight, (PSZ)"MR", 2);%@NL@%
    CalcTextOut(hps, iX, iY + 6 * sCharHeight, (PSZ)"MC", 2);%@NL@%
%@NL@%
    %@AB@%/* Draw the minus of the plus/minus button */%@AE@%%@NL@%
    cbnd.usBackMixMode = FM_LEAVEALONE;%@NL@%
    GpiSetAttrs( hps, PRIM_CHAR, CBB_BACK_MIX_MODE, 0L, &cbnd);%@NL@%
    iX =  (3 * 6 * sCharWidth) + (WIDTHCONST * sCharWidth / 10);%@NL@%
    CalcTextOut( hps, iX, iY + sCharHeight / 4, (PSZ)"_", 1);%@NL@%
%@NL@%
    %@AB@%/* Draw the square root bitmap */%@AE@%%@NL@%
    rclDst.xLeft = 160 * sCharWidth / 5;%@NL@%
    rclDst.yBottom = 31 * sCharHeight / 4;%@NL@%
    rclDst.xRight = rclDst.xLeft + 2 * sCharWidth;%@NL@%
    rclDst.yTop = rclDst.yBottom + (3 * sCharHeight / 2);%@NL@%
    WinDrawBitmap( hps%@NL@%
                 , hbmSqr%@NL@%
                 , NULL%@NL@%
                 , (PPOINTL)&rclDst%@NL@%
                 , CLR_WHITE%@NL@%
                 , CLR_BLACK%@NL@%
                 , DBM_STRETCH );%@NL@%
%@NL@%
    UpdateDisplay();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*  initialize the bitmaps for a blank key and for the square-root sign       */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
PSInit()%@NL@%
{%@NL@%
    HPS              hps;%@NL@%
    FONTMETRICS      fm;%@NL@%
    POINTL             ptl;%@NL@%
    SIZEL             sizl;%@NL@%
    BITMAPINFOHEADER bmp;%@NL@%
    POINTL             aptl[4];%@NL@%
    LONG             alCaps[2];%@NL@%
%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/*        compute the units of horizontal and vertical distance based on font   */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    hps = WinGetPS( HWND_DESKTOP);%@NL@%
    GpiQueryFontMetrics( hps, (LONG)sizeof(FONTMETRICS), &fm);%@NL@%
    sCharHeight = (SHORT)(fm.lEmHeight); %@AB@%/* avg height of uppercase character */%@AE@%%@NL@%
    sCharWidth        = (SHORT)(fm.lEmInc);         %@AB@%/* usually 'M' increment              */%@AE@%%@NL@%
    WinReleasePS( hps);%@NL@%
%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/*        prepare the square root bitmap                                              */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    hdcSqr = DevOpenDC( hab, OD_MEMORY, "*", 3L, (PDEVOPENDATA)&dop, NULL);%@NL@%
    if( !hdcSqr)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    sizl.cx = sizl.cy = 0L;%@NL@%
    hpsSqr = GpiCreatePS( hab%@NL@%
                        , hdcSqr%@NL@%
                        , &sizl%@NL@%
                        , PU_PELS | GPIT_MICRO | GPIA_ASSOC );%@NL@%
    hbmSqr = GpiLoadBitmap( hpsSqr, NULL, IDB_SQR, 0L, 0L);%@NL@%
%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/*        prepare the bitmap of a blank key                                      */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    hdcLocal = DevOpenDC( hab, OD_MEMORY, "*", 3L, (PDEVOPENDATA)&dop, NULL);%@NL@%
    if( !hdcLocal)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    sizl.cx = sizl.cy = 0L;%@NL@%
    hpsLocal = GpiCreatePS( hab%@NL@%
                          , hdcLocal%@NL@%
                          , &sizl%@NL@%
                          , PU_PELS | GPIT_MICRO | GPIA_ASSOC );%@NL@%
    bmp.cbFix = 12;%@NL@%
    bmp.cx = 11 * sCharWidth / 3;%@NL@%
    bmp.cy = sCharHeight * 2;%@NL@%
    DevQueryCaps( hdcLocal, CAPS_COLOR_PLANES, 2L, alCaps);%@NL@%
    bmp.cPlanes = (USHORT)alCaps[0];%@NL@%
    bmp.cBitCount = (USHORT)alCaps[1];%@NL@%
    hbmLocal = GpiCreateBitmap( hpsLocal, &bmp, 0L, NULL, NULL);%@NL@%
    if( !hbmLocal )%@NL@%
        return(FALSE);%@NL@%
    GpiSetBitmap( hpsLocal, hbmLocal);%@NL@%
%@NL@%
    aptl[0].x = aptl[0].y = 0;%@NL@%
    aptl[1].x = 11 * sCharWidth / 3;%@NL@%
    aptl[1].y = 7 * sCharHeight / 4;%@NL@%
    aptl[2].x = aptl[2].y = 0;%@NL@%
    aptl[3].x = aptl[1].x;%@NL@%
    aptl[3].y = aptl[1].y;%@NL@%
    GpiSetColor( hpsLocal, CLR_GREEN);            %@AB@%/* match the background to client */%@AE@%%@NL@%
    GpiBitBlt( hpsLocal, NULL, 2L, aptl, ROP_PATCOPY, BBO_IGNORE);%@NL@%
%@NL@%
    %@AB@%/* Draw the rounded rect */%@AE@%%@NL@%
    ptl.x = 0;%@NL@%
    ptl.y = 0;%@NL@%
    GpiSetCurrentPosition( hpsLocal, &ptl);%@NL@%
    ptl.x = (11 * sCharWidth / 3) - 1;%@NL@%
    ptl.y = (7 * sCharHeight / 4) - 1;%@NL@%
    GpiSetColor( hpsLocal, CLR_WHITE);            %@AB@%/* white interior                      */%@AE@%%@NL@%
    GpiBox( hpsLocal%@NL@%
          , DRO_FILL%@NL@%
          , &ptl%@NL@%
          , (LONG)sCharWidth%@NL@%
          , (LONG)(sCharHeight / 2) );%@NL@%
    ptl.x = 0;%@NL@%
    ptl.y = 0;%@NL@%
    GpiSetCurrentPosition( hpsLocal, &ptl);%@NL@%
    ptl.x = (11 * sCharWidth / 3) - 1;%@NL@%
    ptl.y = (7 * sCharHeight / 4) - 1;%@NL@%
    GpiSetColor( hpsLocal, CLR_BLACK);            %@AB@%/* black border                      */%@AE@%%@NL@%
    GpiBox( hpsLocal%@NL@%
          , DRO_OUTLINE%@NL@%
          , &ptl%@NL@%
          , (LONG)sCharWidth%@NL@%
          , (LONG)(sCharHeight / 2) );%@NL@%
    return( TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CALCMATH.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CALC\CALCMATH.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header *********************************/%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/* Module Name:  calcmath.c - Calc application                                      */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/* OS/2 Presentation Manager version of Calc, ported from Windows version     */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/* Created by Microsoft Corporation, 1987                                      */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINCLIPBOARD %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@NL@%
extern BOOL fValueInMemory;%@NL@%
extern CHAR chLastKey;%@NL@%
extern CHAR szreg1[20], szreg2[20], szmem[20];%@NL@%
extern HWND hwndCalc;%@NL@%
extern CHAR szregx[];%@NL@%
extern HAB  hab;%@NL@%
BOOL   fReadNumber;%@NL@%
CHAR   PendingOperation;%@NL@%
BOOL   fFirstOperand, fError;%@NL@%
CHAR   szresult[20];%@NL@%
SEL    sel;%@NL@%
%@NL@%
%@AI@%#define %@AE@%tolower(x)   (((x) >= 'A') && ((x)<='Z')) ? (x) - 'A' + 'a' : (x) %@NL@%
%@AI@%#define %@AE@%MAXINT        (double)999999999 %@NL@%
%@AI@%#define %@AE@%MININT (double)-999999999 %@NL@%
%@AI@%#define %@AE@%ABS(x)                (((x) >= (double)0) ? (x) : (-(x))) %@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
extern VOID UpdateDisplay( VOID);%@NL@%
extern BOOL InterpretChar( CHAR);%@NL@%
%@NL@%
VOID AppendNumber( BYTE);%@NL@%
VOID BinaryOperator( CHAR);%@NL@%
VOID Clear( VOID);%@NL@%
VOID DataXCopy( VOID);%@NL@%
VOID DataXPaste( VOID);%@NL@%
VOID Equilibrate( VOID);%@NL@%
VOID Evaluate( BYTE);%@NL@%
VOID FarStrcpy( PSZ, PSZ);%@NL@%
NPCH ftoa( double);%@NL@%
VOID InitCalc( VOID);%@NL@%
VOID MClear( VOID);%@NL@%
VOID MMinus( VOID);%@NL@%
VOID MPlus( VOID);%@NL@%
VOID Negate( VOID);%@NL@%
VOID Number( CHAR);%@NL@%
VOID Percent( VOID);%@NL@%
VOID reverse( NPCH);%@NL@%
VOID Simplify( VOID);%@NL@%
VOID SquareRoot( VOID);%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID FarStrcpy( pszDest, pszSrc)%@NL@%
PSZ  pszDest, pszSrc;%@NL@%
{%@NL@%
    while( *pszDest++ = *pszSrc++);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
reverse( s)%@NL@%
%@NL@%
NPCH s;%@NL@%
{%@NL@%
    CHAR ch;%@NL@%
    register INT iHead, iTail;%@NL@%
%@NL@%
    for (iHead = 0, iTail = strlen(s) - 1; iHead<iTail; iHead++, iTail-- ) {%@NL@%
        ch = s[iHead];%@NL@%
        s[iHead] = s[iTail];%@NL@%
        s[iTail] = ch;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
NPCH%@NL@%
ftoa( dblNum)%@NL@%
%@NL@%
double dblNum;%@NL@%
{%@NL@%
    sprintf( szresult, "%.8f", dblNum );%@NL@%
    return (szresult);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Negate()%@NL@%
{%@NL@%
    CHAR sztemp[ 20 ];%@NL@%
%@NL@%
    if (szreg1[0] ==  '-')%@NL@%
        strcpy(szreg1, (&szreg1[1]));                     %@AB@%/* get rid of minus sign */%@AE@%%@NL@%
    else if (szreg1[0] != '0' || (strlen(szreg1) > 2)) { %@AB@%/* can't negate zero */%@AE@%%@NL@%
             sztemp[0] = '-';%@NL@%
             strcpy(&sztemp[1], szreg1);%@NL@%
             strcpy(szreg1, sztemp);%@NL@%
         }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Number( ch)%@NL@%
%@NL@%
CHAR ch;%@NL@%
{%@NL@%
    register INT iLen, iSize;%@NL@%
%@NL@%
    iSize = 9;%@NL@%
    if (szreg1[0] == '-') iSize++;%@NL@%
    if (strchr(szreg1, '.')) iSize++;%@NL@%
    iLen  = strlen(szreg1 );%@NL@%
    if (iLen == iSize) return;%@NL@%
    if (iLen == 1 && szreg1[0] == '0') iLen--;%@NL@%
    szreg1[ iLen ] = ch;%@NL@%
    szreg1[min(iLen + 1, 11)] = 0;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
AppendNumber ( b)%@NL@%
%@NL@%
BYTE b;%@NL@%
{%@NL@%
    if (b == '.') {                    %@AB@%/*        if no decimal, add one at end */%@AE@%%@NL@%
        if (!strchr(szreg1, '.'))   %@NL@%
            strcat(szreg1, ".");%@NL@%
    }%@NL@%
    else if ( b == 0xb1 )%@NL@%
             Negate();%@NL@%
         else%@NL@%
             Number(b);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Equilibrate()%@NL@%
{%@NL@%
    double dblResult;%@NL@%
    double dblX1, dblX2;%@NL@%
%@NL@%
    if (chLastKey == '=') return;%@NL@%
    dblResult = (double)atof(szreg1);%@NL@%
    dblX1 = (double)atof(szreg1);%@NL@%
    dblX2 = (double)atof(szreg2);%@NL@%
%@NL@%
    switch (PendingOperation) {%@NL@%
        case '+':%@NL@%
            if (dblX2>(double)0) {            %@AB@%/* check for overflow */%@AE@%%@NL@%
                if (dblX1>(double)0) {%@NL@%
                    if (dblX1 > (MAXINT - dblX2))%@NL@%
                        fError = TRUE;%@NL@%
                }%@NL@%
            }%@NL@%
            else if (dblX2 < (double)0) {%@NL@%
                     if (dblX1 < (double)0) {%@NL@%
                         if ( dblX1 < (MININT - dblX2))%@NL@%
                             fError = TRUE;%@NL@%
                     }%@NL@%
                 }%@NL@%
            if (!fError)%@NL@%
                dblResult = dblX2 + dblX1;%@NL@%
            break;%@NL@%
        case '-':%@NL@%
            if (dblX2 < (double)0) {%@NL@%
                if (dblX1 > (double)0) {%@NL@%
                    if (dblX1 > (dblX2 - MININT))%@NL@%
                        fError = TRUE;%@NL@%
                }%@NL@%
            }%@NL@%
            else if (dblX2 > (double)0) {%@NL@%
                    if (dblX1 < (double)0) {%@NL@%
                        if (dblX1 < (dblX2 - MAXINT))%@NL@%
                            fError = TRUE;%@NL@%
                    }%@NL@%
                 }%@NL@%
            if (!fError) %@NL@%
                dblResult = dblX2 - dblX1;%@NL@%
            break;%@NL@%
        case '/':%@NL@%
            if (dblX1 == (double)0.0)%@NL@%
                fError = TRUE;%@NL@%
            else if (dblX2 > (double)0) {%@NL@%
                     if (dblX1 > (double)0) {%@NL@%
                         if (dblX1 < (dblX2 / MAXINT))%@NL@%
                             fError = TRUE;%@NL@%
                     }%@NL@%
                     else {  %@AB@%/* dblX1 < 0 here */%@AE@%%@NL@%
                        if (dblX1 > (dblX2 / MININT))%@NL@%
                             fError = TRUE;%@NL@%
                     }%@NL@%
                 }%@NL@%
                 else {  %@AB@%/* dblX2 < 0 here */%@AE@%%@NL@%
                     if (dblX1 < (double)0) {%@NL@%
                         if (dblX1 > (dblX2 / MAXINT))%@NL@%
                             fError = TRUE;%@NL@%
                     }%@NL@%
                     else { %@AB@%/* dblX1 > 0 here */%@AE@%%@NL@%
                         if (dblX1 < (dblX2 / MININT))%@NL@%
                             fError = TRUE;%@NL@%
                     }%@NL@%
                 }%@NL@%
            if (!fError)%@NL@%
                dblResult = dblX2 / dblX1;%@NL@%
            break;%@NL@%
        case '*':%@NL@%
            if (dblX1 == (double)0) return;%@NL@%
            if (ABS(dblX2) > (double)1) {%@NL@%
                if (ABS(dblX1) > (double)1) {%@NL@%
                    if (ABS(dblX1) > (MAXINT / ABS(dblX2)))%@NL@%
                        fError = TRUE;%@NL@%
                    } %@NL@%
                }                    %@NL@%
            if (!fError) dblResult = dblX2 * dblX1;%@NL@%
            break;%@NL@%
        }%@NL@%
    if (!fError) {%@NL@%
        strcpy(szreg1, ftoa((double)dblResult));%@NL@%
        strcpy( szreg2, szreg1 );%@NL@%
        }%@NL@%
    Simplify();%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
SquareRoot()%@NL@%
{%@NL@%
    double dblResult;%@NL@%
%@NL@%
    dblResult = (double)atof(szreg1);%@NL@%
    if (dblResult < 0.0) {%@NL@%
        fError = TRUE;%@NL@%
        return;%@NL@%
    }%@NL@%
    if ((dblResult == 0.0) || ((chLastKey == 'q') && (dblResult == 1.0)))%@NL@%
        return;%@NL@%
    if ((dblResult < (double) 1.00000002) && (dblResult > (double) 1.0))%@NL@%
        dblResult = (double)1.0;%@NL@%
    else%@NL@%
        dblResult = sqrt(dblResult);%@NL@%
    strcpy( szreg1, ftoa((double)dblResult));%@NL@%
    if (atof( szreg1 ) == 0.0)%@NL@%
        strcpy(szreg1, "0.");%@NL@%
    Simplify();%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
BinaryOperator( ch)%@NL@%
%@NL@%
CHAR ch;%@NL@%
{%@NL@%
    if (fFirstOperand) {%@NL@%
        fFirstOperand = FALSE;%@NL@%
        strcpy(szreg2, szreg1);%@NL@%
    }%@NL@%
    else {%@NL@%
        Equilibrate();%@NL@%
    }%@NL@%
    PendingOperation = ch;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Clear()%@NL@%
{%@NL@%
    fReadNumber = FALSE;%@NL@%
    fFirstOperand = TRUE;%@NL@%
    strcpy(szreg1, "0.");%@NL@%
    if (fError || chLastKey == 'c'){%@NL@%
        strcpy(szreg2, "0.");%@NL@%
        PendingOperation = NULL;%@NL@%
    }%@NL@%
    fError = FALSE;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/* trash out trailing zeros, if a '.' is in the number                              */%@AE@%%@NL@%
%@AB@%/* and leading zeros in all cases.                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Simplify()%@NL@%
{%@NL@%
    register INT iLen, iCount;%@NL@%
    CHAR         achLocal[20];%@NL@%
%@NL@%
    iCount = 0;%@NL@%
    strcpy(achLocal, szreg1);%@NL@%
    if (atof(achLocal) != 0.0) {%@NL@%
        while (achLocal[iCount++] == '0');%@NL@%
        strcpy(szreg1, &achLocal[iCount-1] );%@NL@%
    }%@NL@%
    if (strchr(szreg1, '.')) {%@NL@%
        iLen = strlen(szreg1);%@NL@%
        while (szreg1[--iLen] == '0');%@NL@%
        szreg1[min( iLen + 1, 11)] = 0; %@AB@%/* null terminate */%@AE@%%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
DataXPaste()%@NL@%
{%@NL@%
    PSZ           psz;%@NL@%
    ULONG          ulText;%@NL@%
    register CHAR ch;%@NL@%
%@NL@%
    if (WinOpenClipbrd( hab))%@NL@%
    {%@NL@%
        ulText = WinQueryClipbrdData( hab, CF_TEXT);%@NL@%
        if (ulText)%@NL@%
        {%@NL@%
            psz = MAKEP( (SEL)ulText, 0);%@NL@%
            while (*psz)%@NL@%
            {%@NL@%
                ch = (CHAR) (tolower(*psz));%@NL@%
                if (ch == 'm')%@NL@%
                {%@NL@%
                    psz++;%@NL@%
                    switch (tolower(*psz))%@NL@%
                    {%@NL@%
                        case '-':%@NL@%
                            ch = '\271';%@NL@%
                            break;%@NL@%
                        case '+':%@NL@%
                            ch = '\272';%@NL@%
                            break;%@NL@%
                        case 'r':%@NL@%
                            ch = '\273';%@NL@%
                            break;%@NL@%
                        case 'c':%@NL@%
                            ch = '\274';%@NL@%
                            break;%@NL@%
                        default:%@NL@%
                            ch = ' ';%@NL@%
                            break;%@NL@%
                    }%@NL@%
                }%@NL@%
                psz++;%@NL@%
                InterpretChar(ch);%@NL@%
                UpdateDisplay();%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
    WinCloseClipbrd( hab);%@NL@%
    InterpretChar('=');%@NL@%
    UpdateDisplay();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
DataXCopy()%@NL@%
{%@NL@%
    PSZ  pszText;%@NL@%
%@NL@%
    if (WinOpenClipbrd( hab))%@NL@%
    {%@NL@%
        WinEmptyClipbrd( hab);%@NL@%
        DosAllocSeg( 20, (SEL FAR *)&sel, SEG_GIVEABLE);%@NL@%
        if (sel == NULL) return;%@NL@%
        pszText = MAKEP(sel, 0);%@NL@%
        FarStrcpy( pszText, (PSZ)szreg1);%@NL@%
        WinSetClipbrdData( hab, (ULONG)sel, CF_TEXT, CFI_SELECTOR);%@NL@%
        WinCloseClipbrd( hab);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
MPlus()%@NL@%
{%@NL@%
    double dblX1, dblX2, dblResult;%@NL@%
%@NL@%
    dblX2 = atof(szmem);%@NL@%
    dblX1 = atof(szreg1);%@NL@%
%@NL@%
    if (dblX2>(double)0) {            %@AB@%/* check for overflow */%@AE@%%@NL@%
        if (dblX1>(double)0) {%@NL@%
            if (dblX1 > (MAXINT - dblX2))%@NL@%
                fError = TRUE;%@NL@%
        }%@NL@%
    }%@NL@%
    else if (dblX2 < (double)0) {%@NL@%
             if (dblX1 < (double)0) {%@NL@%
                 if ( dblX1 < (MININT - dblX2))%@NL@%
                     fError = TRUE;%@NL@%
             }%@NL@%
         }%@NL@%
    if (!fError) {%@NL@%
        dblResult = dblX2 + dblX1;%@NL@%
        strcpy( szmem, ftoa((double)dblResult));%@NL@%
    }%@NL@%
    if (dblResult == (double)0.0)%@NL@%
         fValueInMemory = FALSE; %@NL@%
    else fValueInMemory = TRUE;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
MClear()%@NL@%
{%@NL@%
     strcpy(szmem, "0.");   %@NL@%
     fValueInMemory = FALSE; %@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
MMinus()%@NL@%
{%@NL@%
    double dblX1, dblX2, dblResult;%@NL@%
%@NL@%
    dblX2 = atof(szmem);%@NL@%
    dblX1 = atof(szreg1);%@NL@%
    if (dblX2 < (double)0) {%@NL@%
        if (dblX1 > (double)0) {%@NL@%
            if (dblX1 > (dblX2 - MININT))%@NL@%
                fError = TRUE;%@NL@%
        }%@NL@%
    }%@NL@%
    else if (dblX2 > (double)0) {%@NL@%
            if (dblX1 < (double)0) {%@NL@%
                if (dblX1 < (dblX2 - MAXINT))%@NL@%
                    fError = TRUE;%@NL@%
            }%@NL@%
         }%@NL@%
    if (!fError) {%@NL@%
        dblResult = dblX2 - dblX1;%@NL@%
        strcpy( szmem, ftoa((double)dblResult));%@NL@%
    }%@NL@%
    if (dblResult == (double)0.0)%@NL@%
         fValueInMemory = FALSE; %@NL@%
    else fValueInMemory = TRUE;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Evaluate( bCommand)%@NL@%
%@NL@%
BYTE bCommand;%@NL@%
{%@NL@%
    switch( bCommand ) {%@NL@%
        case '0': case '1': case '2': case '3': case '4': case '5':%@NL@%
        case '6': case '7': case '8': case '9': case '.': case 0xb1:%@NL@%
        case 'n': %@AB@%/* n = 'negate'  from keyboard */%@AE@%%@NL@%
            if ( fReadNumber )%@NL@%
                AppendNumber( bCommand );%@NL@%
            else {%@NL@%
                      %@AB@%/* if starting a new number */%@AE@%%@NL@%
                if (bCommand != 0xb1)%@NL@%
                    strcpy(szreg1, "0");%@NL@%
                AppendNumber( bCommand );%@NL@%
            }%@NL@%
            if (bCommand != 0xb1)%@NL@%
                fReadNumber = TRUE;%@NL@%
            break;%@NL@%
        case '+': case '-': case '/': case '*': case 'p':%@NL@%
            BinaryOperator(bCommand);%@NL@%
            fReadNumber = FALSE;%@NL@%
            break;%@NL@%
        case '=':%@NL@%
            fReadNumber = FALSE;%@NL@%
            Equilibrate();%@NL@%
            PendingOperation = NULL;%@NL@%
            break;%@NL@%
        case 'q':%@NL@%
            SquareRoot();%@NL@%
            fReadNumber = FALSE;%@NL@%
            break;%@NL@%
        case 0xBB:   %@AB@%/* MR */%@AE@%%@NL@%
            strcpy(szreg1, szmem);%@NL@%
            fReadNumber = FALSE;%@NL@%
            Simplify();%@NL@%
            break;%@NL@%
        case 0xBA: %@AB@%/* M+ */%@AE@%%@NL@%
            MPlus();%@NL@%
            fReadNumber = FALSE;%@NL@%
            Simplify();%@NL@%
            break;%@NL@%
        case 0xB9: %@AB@%/* M- */%@AE@%%@NL@%
            MMinus();%@NL@%
            fReadNumber = FALSE;%@NL@%
            Simplify();%@NL@%
            break;%@NL@%
        case 0xBC:%@NL@%
            MClear(); %@AB@%/* MC */%@AE@%%@NL@%
            break;%@NL@%
        case '%':%@NL@%
            Percent();%@NL@%
            fReadNumber = FALSE;%@NL@%
            break;%@NL@%
        case 'c':%@NL@%
            Clear();%@NL@%
            break;%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Percent()%@NL@%
{%@NL@%
    double dblX1, dblX2, dblResult;%@NL@%
%@NL@%
    dblX1 = atof(szreg1) / 100.0;%@NL@%
    dblX2 = atof(szreg2);%@NL@%
    if (ABS(dblX2) > (double)1) {%@NL@%
        if (ABS(dblX1) > (double)1) {%@NL@%
            if (dblX1 > (MAXINT / dblX2))%@NL@%
                fError = TRUE;%@NL@%
        }%@NL@%
    }%@NL@%
    if (!fError) {%@NL@%
        dblResult = dblX2 * dblX1;%@NL@%
        strcpy( szreg1, ftoa((double)dblResult));%@NL@%
    }%@NL@%
    Simplify();%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
InitCalc()%@NL@%
{%@NL@%
    fReadNumber = FALSE;%@NL@%
    fError = FALSE;%@NL@%
    fFirstOperand = TRUE;%@NL@%
    PendingOperation = 0;%@NL@%
    strcpy(szreg1, "0.");%@NL@%
    strcpy(szmem,  "0.");%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CASCADE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CASCADE\CASCADE.C%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_PM %@NL@%
%@AI@%#include %@AE@%<OS2.H> %@NL@%
%@AI@%#include %@AE@%"Cascade.H" %@NL@%
%@NL@%
char szAppName[] = "Cascade";%@NL@%
char szAppTitle[] = "Cascading Menu Example";%@NL@%
%@NL@%
HAB        hAB;%@NL@%
HMQ        hmqMsgQueue;%@NL@%
HWND        hWndMain,%@NL@%
        hWndFrame;%@NL@%
%@NL@%
int cdecl main()%@NL@%
{%@NL@%
    QMSG    qmsg;%@NL@%
    ULONG   ctlData = FCF_STANDARD & ~FCF_ACCELTABLE;%@NL@%
%@NL@%
    hAB = WinInitialize (0);%@NL@%
%@NL@%
    hmqMsgQueue = WinCreateMsgQueue (hAB, 0);%@NL@%
%@NL@%
    if (!WinRegisterClass (hAB,%@NL@%
                           szAppName,%@NL@%
                           WndProc,%@NL@%
                           CS_SYNCPAINT | CS_SIZEREDRAW,%@NL@%
                           0)) {%@NL@%
        return(0);%@NL@%
    }%@NL@%
%@NL@%
    hWndFrame = WinCreateStdWindow ( HWND_DESKTOP,%@NL@%
                                    WS_VISIBLE,%@NL@%
                                    &ctlData,%@NL@%
                                    szAppName,%@NL@%
                                    NULL,%@NL@%
                                    0L,%@NL@%
                                    0,%@NL@%
                                    ID_RESOURCE,%@NL@%
                                    &hWndMain);%@NL@%
    WinSetWindowText (hWndFrame, szAppTitle);%@NL@%
    WinShowWindow (hWndFrame, TRUE);%@NL@%
%@NL@%
    while ( WinGetMsg (hAB, &qmsg, NULL, 0, 0)) {%@NL@%
        WinDispatchMsg (hAB, &qmsg);%@NL@%
    }%@NL@%
%@NL@%
    WinDestroyWindow   (hWndFrame);%@NL@%
    WinDestroyMsgQueue (hmqMsgQueue);%@NL@%
    WinTerminate       (hAB);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------------------------------*/%@AE@%%@NL@%
%@AB@%/*                                                                     */%@AE@%%@NL@%
%@AB@%/*-------------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
BOOL CheckAll (HWND hMenu, int item, BOOL check);%@NL@%
BOOL CheckAll (HWND hMenu, int item, BOOL check)%@NL@%
{%@NL@%
    int mPos,max,test;%@NL@%
    MENUITEM mi;%@NL@%
    char szText[20];%@NL@%
    MPARAM  mp1, mp2;%@NL@%
%@NL@%
    max =(int) SHORT1FROMMR( WinSendMsg (hMenu, MM_QUERYITEMCOUNT, 0L, 0L) ); %@NL@%
%@NL@%
    for (mPos=0; mPos!=(int) max; mPos++) {%@NL@%
        test =(int) SHORT1FROMMR( WinSendMsg (hMenu, MM_ITEMIDFROMPOSITION, MPFROMSHORT(mPos), 0L) );%@NL@%
        WinSendMsg (hMenu, MM_QUERYITEMTEXT, MPFROM2SHORT(test,sizeof(szText)), MPFROMP(szText));%@NL@%
        if (test == item) {%@NL@%
            mp1 = MPFROM2SHORT (test, TRUE);%@NL@%
            if (check)%@NL@%
                mp2 = MPFROM2SHORT(MIA_CHECKED, MIA_CHECKED);%@NL@%
            else%@NL@%
                mp2 = MPFROM2SHORT(MIA_CHECKED, 0);%@NL@%
            WinPostMsg (hMenu, MM_SETITEMATTR, mp1, mp2);%@NL@%
            return TRUE;%@NL@%
        } else {%@NL@%
            WinSendMsg (hMenu, MM_QUERYITEM, MPFROM2SHORT(test,FALSE), (MPARAM)&mi);%@NL@%
            if (mi.hwndSubMenu) {%@NL@%
                if (CheckAll(mi.hwndSubMenu, item, check)) {%@NL@%
                    mp1 = MPFROM2SHORT (test, TRUE);%@NL@%
                    if (check)%@NL@%
                        mp2 = MPFROM2SHORT(MIA_CHECKED, MIA_CHECKED);%@NL@%
                    else%@NL@%
                        mp2 = MPFROM2SHORT(MIA_CHECKED, 0);%@NL@%
                    WinPostMsg (hMenu, MM_SETITEMATTR, mp1, mp2);%@NL@%
                    return TRUE;%@NL@%
                }%@NL@%
%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------------------------------*/%@AE@%%@NL@%
%@AB@%/*                                                                     */%@AE@%%@NL@%
%@AB@%/*-------------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY WndProc (hWnd, msg, mp1, mp2)%@NL@%
    HWND    hWnd;%@NL@%
    USHORT  msg;%@NL@%
    MPARAM  mp1, mp2;%@NL@%
{%@NL@%
    HPS           hPS;%@NL@%
    HWND   hMenu;%@NL@%
    static int          prevFont = 0;%@NL@%
    int thisItem;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            thisItem = SHORT1FROMMP(mp1);%@NL@%
            switch (thisItem) {%@NL@%
                case IDM_ABOUT:%@NL@%
                    WinMessageBox (HWND_DESKTOP, hWnd,%@NL@%
                        "Sample PM Application",%@NL@%
                        szAppTitle, 1, MB_OK | MB_APPLMODAL | MB_MOVEABLE);%@NL@%
                    break;%@NL@%
                default:%@NL@%
                    if ((thisItem >= IDM_FIRSTFONT) && (thisItem<= IDM_LASTFONT)) {%@NL@%
                        hMenu        = WinWindowFromID (%@NL@%
                                    WinQueryWindow (hWnd, QW_PARENT, FALSE),%@NL@%
                                    FID_MENU);%@NL@%
                        CheckAll (hMenu, prevFont, FALSE);%@NL@%
                        CheckAll (hMenu, thisItem, TRUE);%@NL@%
                        prevFont = thisItem;%@NL@%
                    } else {%@NL@%
                        DosBeep(600,60);%@NL@%
                    }%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case WM_CLOSE:%@NL@%
            WinPostMsg (hWnd, WM_QUIT, 0L, 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_ERASEBACKGROUND:%@NL@%
            return ((MRESULT) TRUE);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_PAINT:%@NL@%
            hPS = WinBeginPaint (hWnd, NULL, (PWRECT)NULL);%@NL@%
            WinEndPaint (hPS);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return (WinDefWindowProc (hWnd, msg, mp1, mp2));%@NL@%
            break;%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CHASER.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CHASER\CHASER.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*  SWARM%@NL@%
%@AB@% *  Created by Microsoft Corp. 1986%@NL@%
%@AB@% *%@NL@%
%@AB@% *  the idea behind this game is as follows:%@NL@%
%@AB@% *%@NL@%
%@AB@% *   You have a collection of objects in the center of the playing field%@NL@%
%@AB@% *   that you are trying to protect (just one object in current version). You%@NL@%
%@AB@% *   control your own movements with the mouse. A number of "chasers" start%@NL@%
%@AB@% *   around the edges of the field and begin moving towards the objects%@NL@%
%@AB@% *   you want to protect. If you move the mouse on top of a chaser and click%@NL@%
%@AB@% *   the left button, the chaser will be killed and disappear from the screen.%@NL@%
%@AB@% *   But as you close in on the chaser, it will detect your presence and try%@NL@%
%@AB@% *   to dodge you. Meanwhile the other chasers will continue to go after%@NL@%
%@AB@% *   your objects. If one of the chasers reaches an object, it will begin%@NL@%
%@AB@% *   dragging it away to the edge of the screen (currently the game just%@NL@%
%@AB@% *   ends when the single object is reached). When all objects are dragged%@NL@%
%@AB@% *   away, the game ends. If a chaser is killed while dragging an object, the%@NL@%
%@AB@% *   object is left where it is and must be protected in place - player cannot%@NL@%
%@AB@% *   move objects. If you kill all the chasers, a new group of faster ones%@NL@%
%@AB@% *   will be spawned (currently the speed is constant). Your score is how%@NL@%
%@AB@% *   many chasers you can kill (no score currently kept), so there is no%@NL@%
%@AB@% *   advantage in sitting on the object for long periods.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Swarm demonstrates several capabilities of OS/2 and the philosphy behind%@NL@%
%@AB@% * them.  This program is made of three components: Initialization, the%@NL@%
%@AB@% * mouse driven thread and the attacker thread.  The attacker thread is%@NL@%
%@AB@% * launched as many times as there are attackers in a game.  Launching%@NL@%
%@AB@% * the attacker several times takes full advantage of the OS to schedule%@NL@%
%@AB@% * resources.  The programmer can think of the problem as only one attacker.%@NL@%
%@AB@% * The system handles multiple instances of the thread.%@NL@%
%@AB@% *%@NL@%
%@AB@% * As the main loop launches threads it puts an ID code into the thread's%@NL@%
%@AB@% * stack.  The code is used to index into the universe data.%@NL@%
%@AB@% *%@NL@%
%@AB@% * A ram semaphore is used to control access to global data.%@NL@%
%@AB@% *%@NL@%
%@AB@% * This demonstration shows the use of the following OS/2 system calls:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Tasking:               VIO API:              Mouse API:%@NL@%
%@AB@% *%@NL@%
%@AB@% *   DosSemRequest()         VioScrollUp()               MouOpen()%@NL@%
%@AB@% *   DosSemClear()         VioWrtCellStr()       MouSetPtrPos()%@NL@%
%@AB@% *   DosCreateThread()         VioSetCurType()       MouReadEventQue()%@NL@%
%@AB@% *   DosExit()                 VioSetMode()%@NL@%
%@AB@% *   DosSleep()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@AI@%#include %@AE@%<os2def.h> %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_DOSSEMAPHORES %@NL@%
%@AI@%#include %@AE@%<bsedos.h> %@NL@%
%@AI@%#define %@AE@%INCL_SUB %@NL@%
%@AI@%#include %@AE@%<bsesub.h> %@NL@%
%@AI@%#include %@AE@%<malloc.h> %@NL@%
%@AI@%#undef %@AE@%NULL %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@% STACKSIZE  200 %@NL@%
%@NL@%
%@AI@%#define %@AE@% DANGERZONE  3 %@NL@%
%@NL@%
%@AI@%#define %@AE@% LONGNAP     500L %@NL@%
%@AI@%#define %@AE@% SHORTNAP    150L %@NL@%
%@NL@%
 WAIT (-1L)                        %@AB@%/* Wait for ram Semaphore */%@AE@%%@NL@%
%@NL@%
 CHASER    8                        %@AB@%/* Number of chasers */%@AE@%%@NL@%
%@NL@%
 SCREEN_HEIGHT           24                %@AB@%/* Default screen size */%@AE@%%@NL@%
%@AI@%#define %@AE@% SCREEN_WIDTH           79 %@NL@%
%@NL@%
 GOAL univ[CHASER]                %@AB@%/* Macros for constant stuff */%@AE@%%@NL@%
%@AI@%#define %@AE@% ME univ[ID] %@NL@%
%@AI@%#define %@AE@% MOUSE univ[CHASER+1] %@NL@%
%@NL@%
 ALIVE 1                        %@AB@%/* Flags for attackers/goal */%@AE@%%@NL@%
%@AI@%#define %@AE@% DEAD 0 %@NL@%
%@NL@%
char   Chaser[2] = { 0xE8, 0x20 };   %@AB@%/* character and attribute */%@AE@%%@NL@%
char        Prize[2] = { 0x03, 0x2C };   %@AB@%/* for our various objects */%@AE@%%@NL@%
char        Blank[2] = { 0x20, 0x22 };%@NL@%
char        Blood[2] = { 0x20, 0x44 };%@NL@%
%@NL@%
struct {                              %@AB@%/* Universe structure and array */%@AE@%%@NL@%
    int     row;                        %@AB@%/* univ[0] = chaser     */%@AE@%%@NL@%
    int     col;                        %@AB@%/* univ[n-1] = chaser     */%@AE@%%@NL@%
    int     state;                        %@AB@%/* univ[n] = GOAL */%@AE@%%@NL@%
} univ[CHASER+1];                        %@AB@%/* univ[n+1]= MOUSE */%@AE@%%@NL@%
%@NL@%
short                ScreenHeight,                %@AB@%/* Screen attributes */%@AE@%%@NL@%
                ScreenWidth;%@NL@%
%@NL@%
HMOU                Mouse;                        %@AB@%/* place for mouse handle */%@AE@%%@NL@%
ULONG                Shortnap;                %@AB@%/* Sleep times for chasers */%@AE@%%@NL@%
ULONG                Longnap;%@NL@%
ULONG                Semaphore = 0;                %@AB@%/* Ram semaphore */%@AE@%%@NL@%
%@NL@%
struct _VIOCURSORINFO        NewCur;         %@AB@%/* struct for setting cursor type */%@AE@%%@NL@%
struct _VIOCURSORINFO        OldCur;%@NL@%
%@NL@%
struct _VIOMODEINFO        modedata;        %@AB@%/* Data saves for VIO mode */%@AE@%%@NL@%
struct _VIOMODEINFO        OldVioMode;%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Define all procedures before main.%@NL@%
%@AB@% */%@AE@%%@NL@%
void Defender();%@NL@%
void CleanUp();%@NL@%
int InitGame();%@NL@%
void chaserthread();%@NL@%
int ParseCmdLine(int,char **);%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * main(ac,av)%@NL@%
%@AB@% *%@NL@%
%@AB@% * Top level procedure and MOUSE thread for the GAME demo.%@NL@%
%@AB@% */%@AE@%%@NL@%
int main(ac, av)%@NL@%
int ac;%@NL@%
char *av[];%@NL@%
{%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Parse the command line and perform some initialization.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (ParseCmdLine(ac,av)) {%@NL@%
        printf("usage: %s [24|43] [F|M|S]\n",av[0]);%@NL@%
        DosExit(EXIT_THREAD,1);%@NL@%
    }%@NL@%
    if (InitGame())                %@AB@%/* Init game, exit if some problem */%@AE@%%@NL@%
        DosExit(EXIT_PROCESS,1);%@NL@%
%@NL@%
    Defender();                 %@AB@%/* Run mouse loop (defend against the swarm) */%@AE@%%@NL@%
%@NL@%
    CleanUp();%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Defender()%@NL@%
%@AB@% *%@NL@%
%@AB@% * This is the main loop of the mouse control thread.%@NL@%
%@AB@% *%@NL@%
%@AB@% * The semaphore is used to prevent the other threads from time slicing %@NL@%
%@AB@% * while this routine is examining and/or modifying the universe.  The %@NL@%
%@AB@% * Semaphore is grabbed after the read of the Mouse queue so we don't tie%@NL@%
%@AB@% * up the attackers while waiting for a mouse event.%@NL@%
%@AB@% */%@AE@%%@NL@%
void Defender()%@NL@%
{%@NL@%
    USHORT ReadType = 1,        %@AB@%/* Wait for mouse events */%@AE@%%@NL@%
           alive,%@NL@%
           i;%@NL@%
    struct _MOUEVENTINFO  MouInfo;    %@AB@%/* mouse event packet structure */%@AE@%%@NL@%
%@NL@%
    alive = CHASER;%@NL@%
%@NL@%
    do {%@NL@%
        MouReadEventQue( &MouInfo, &ReadType, Mouse); %@AB@%/* read where mouse is */%@AE@%%@NL@%
%@NL@%
        DosSemRequest( &Semaphore, WAIT);%@NL@%
%@NL@%
        if( MouInfo.fs & 1) {                      %@AB@%/* If the mouse has moved */%@AE@%%@NL@%
            MOUSE.row = MouInfo.row;%@NL@%
            MOUSE.col = MouInfo.col;%@NL@%
        }%@NL@%
        if( MouInfo.fs & 4 ) {                       %@AB@%/* if left button pressed, */%@AE@%%@NL@%
            for (i = 0; i < CHASER; i++ ) {%@NL@%
                if( ( MOUSE.row == univ[i].row ) &&%@NL@%
                    ( MOUSE.col == univ[i].col ) &&  %@AB@%/* see if we hit one */%@AE@%%@NL@%
                    ( univ[i].state == ALIVE) ) {%@NL@%
                     univ[i].state = DEAD;        %@NL@%
%@NL@%
                     DosBeep(300,75);                     %@AB@%/* make a dying sound */%@AE@%%@NL@%
                     DosBeep(600,75);%@NL@%
                     DosBeep(300,85);%@NL@%
%@NL@%
                     alive--;                    %@AB@%/* Decrease number alive */%@AE@%%@NL@%
                     break;                    %@AB@%/* Can only kill one at a time */%@AE@%%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
        if( MouInfo.fs & 16 )              %@AB@%/* If right button pressed... */%@AE@%%@NL@%
            break;                        %@AB@%/* End game, clean up */%@AE@%%@NL@%
%@NL@%
        DosSemClear(&Semaphore);%@NL@%
    }%@NL@%
    while (GOAL.state == ALIVE && alive);    %@AB@%/* loop till all are dead */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This thread manages the individual attackers.  It is spun off as%@NL@%
%@AB@% * many times as needed for a game.%@NL@%
%@AB@% *%@NL@%
%@AB@% * The interaction of the mouse cursor and the chaser character is sort%@NL@%
%@AB@% * of funny, hence the funny code, below.  The mouse cursor seems to%@NL@%
%@AB@% * remember what was under it when it was written.  Hence we cannot erase%@NL@%
%@AB@% * the chaser if the mouse is "sitting" on it.        If we do, then when the%@NL@%
%@AB@% * mouse moves it will re-write the original object.  This shows up as%@NL@%
%@AB@% * phantom chasers.%@NL@%
%@AB@% */%@AE@%%@NL@%
void far chasethread(ID)               %@AB@%/* code that controls each "chaser" */%@AE@%%@NL@%
int ID;%@NL@%
{%@NL@%
    short  row, col;               %@AB@%/* Our current position */%@AE@%%@NL@%
    short  deltaX, deltaY;     %@AB@%/* how far from the mouse are we? */%@AE@%%@NL@%
    short  danger;               %@AB@%/* flag to indicate not far enough! */%@AE@%%@NL@%
    short  m;                       %@AB@%/* general purpose indexes */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Print out the initial chaser character */%@AE@%%@NL@%
%@NL@%
    VioWrtCellStr( Chaser, 2, ME.row, ME.col, 0 );%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Keep running as long as the goal and myself haven't been killed.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    for (;;) {%@NL@%
%@NL@%
        row = ME.row;                  %@AB@%/* Grab the current position */%@AE@%%@NL@%
        col = ME.col;%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * If mouse is sitting upon the chaser, do nothing.  Allow%@NL@%
%@AB@%         * the player some time to kill the chaser%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((MOUSE.row == row) && (MOUSE.col == col)) {%@NL@%
            DosSleep( 1L );%@NL@%
            continue;%@NL@%
        }%@NL@%
        DosSemRequest(&Semaphore, WAIT);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * If either the GOAL or Myself is dead, exit loop and clean up.%@NL@%
%@AB@%         * This wasn't tested in the for loop since we don't want to exit%@NL@%
%@AB@%         * if the MOUSE is sitting on the chaser.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (ME.state != ALIVE || GOAL.state != ALIVE)%@NL@%
            break;%@NL@%
%@NL@%
        deltaX = MOUSE.col - col;        %@AB@%/* calculate how far we are */%@AE@%%@NL@%
        deltaY = MOUSE.row - row;%@NL@%
%@NL@%
        if (((deltaX < -DANGERZONE) || (DANGERZONE < deltaX)) ||%@NL@%
            ((deltaY < -DANGERZONE) || (DANGERZONE < deltaY))) {%@NL@%
%@NL@%
            danger = 0;%@NL@%
%@NL@%
            if(GOAL.row < row)                    %@AB@%/* Creep towards the GOAL */%@AE@%%@NL@%
                row--;%@NL@%
            else if (GOAL.row > row)%@NL@%
                row++;%@NL@%
            if(GOAL.col < col)%@NL@%
                col--;%@NL@%
            else if(GOAL.col > col)%@NL@%
                col++;%@NL@%
        }%@NL@%
        else {%@NL@%
            danger = 1;                     %@AB@%/* Run away from the mouse */%@AE@%%@NL@%
%@NL@%
            if ((MOUSE.row > row) && (row > 0))%@NL@%
                row--;%@NL@%
            else if ((MOUSE.row < row) && (row < ScreenHeight))%@NL@%
                row++;%@NL@%
            if ((MOUSE.col > col) && (col < ScreenWidth))%@NL@%
                col--;%@NL@%
            else if ((MOUSE.col < col) && (col > 0))%@NL@%
                col++;%@NL@%
        }%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * A quick and Dirty hack to prevent chasers from merging%@NL@%
%@AB@%         */%@AE@%%@NL@%
        for (m = 0; m < CHASER; m++ ) {%@NL@%
            if (univ[m].state == ALIVE &&%@NL@%
                univ[m].row == row &&%@NL@%
                univ[m].col == col &&%@NL@%
                m != ID) {%@NL@%
               row += 1;%@NL@%
               col += 3;%@NL@%
            }%@NL@%
        }%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Zap the old chaser and print the new.  Release the semaphore%@NL@%
%@AB@%         * after this, there can be no undesirable interactions now.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        VioWrtCellStr( Blank, 2, ME.row, ME.col, 0 );%@NL@%
        VioWrtCellStr( Chaser, 2, row, col, 0 );%@NL@%
%@NL@%
        DosSemClear(&Semaphore);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Update the current location%@NL@%
%@AB@%         */%@AE@%%@NL@%
        ME.row = row;%@NL@%
        ME.col = col;%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * See if we have reached the GOAL, if so eat it and exit%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((row == GOAL.row) && (col == GOAL.col)) {%@NL@%
            VioWrtCellStr( Blank, 2, row, col, 0 );%@NL@%
            DosBeep(600,175);%@NL@%
            DosBeep(1200,175);            %@AB@%/* if we reach the prize, let out a yell */%@AE@%%@NL@%
            DosBeep(600,185);            %@AB@%/* paint the screen red and end the game */%@AE@%%@NL@%
            DosBeep(1200,175);%@NL@%
            VioScrollUp( 0, 0, -1, -1, -1, Blood, 0 );%@NL@%
            GOAL.state = DEAD;%@NL@%
        }%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Sleep an amount of time that varies depending%@NL@%
%@AB@%         * upon the danger level%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if( danger )%@NL@%
            DosSleep(Shortnap);%@NL@%
        else%@NL@%
            DosSleep(Longnap);%@NL@%
%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * chaser is now dead or the game is over.%@NL@%
%@AB@%     * Erase its body and terminate the thread.  Release the semaphore.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    DosSemClear(&Semaphore);%@NL@%
%@NL@%
    if (GOAL.state == ALIVE) {%@NL@%
        VioWrtCellStr(Blank, 2, ME.row, ME.col, 0 );%@NL@%
    }%@NL@%
    DosExit( EXIT_THREAD ,0);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * InitGame()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Initialize the GOAL, MOUSE and the CHASERS, launch each chase thread.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns an error if any internal processing errors%@NL@%
%@AB@% */%@AE@%%@NL@%
int InitGame()%@NL@%
{%@NL@%
    struct _PTRLOC InitMouPos;%@NL@%
    void far chasethread();                %@AB@%/* code to control chasers */%@AE@%%@NL@%
    PBYTE Tstack;                        %@AB@%/* stack for new threads */%@AE@%%@NL@%
    unsigned chaseID;%@NL@%
    int i, rc;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Clear the screen.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    VioScrollUp( 0, 0, -1, -1, -1, Blank, 0 );%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Draw the prize%@NL@%
%@AB@%     */%@AE@%%@NL@%
    GOAL.row = ScreenHeight/2;%@NL@%
    GOAL.col = ScreenWidth /2;%@NL@%
    GOAL.state = ALIVE;%@NL@%
    VioWrtCellStr(Prize, 2, GOAL.row, GOAL.col, 0 );%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Open the mouse pointer device and set it's location.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    MouOpen( 0L, &Mouse );%@NL@%
    InitMouPos.row = GOAL.row;%@NL@%
    InitMouPos.col = GOAL.col;%@NL@%
    MouSetPtrPos( &InitMouPos, Mouse);%@NL@%
    MouDrawPtr(Mouse);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * A simple minded initialization for the start of each chaser.%@NL@%
%@AB@%     * Some sort of random placement (based upon system time?) would%@NL@%
%@AB@%     * be nice.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    univ[0].row = 0;  univ[0].col = 0;%@NL@%
    univ[1].row = 0;  univ[1].col = 25;%@NL@%
    univ[2].row = 0;  univ[2].col = 55;%@NL@%
    univ[3].row = 0;  univ[3].col = 79;%@NL@%
    univ[4].row = ScreenHeight;  univ[4].col = 0;%@NL@%
    univ[5].row = ScreenHeight;  univ[5].col = 25;%@NL@%
    univ[6].row = ScreenHeight;  univ[6].col = 55;%@NL@%
    univ[7].row = ScreenHeight;  univ[7].col = 79;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Grab the semaphore to prevent chaser from running until we are done.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    DosSemRequest(&Semaphore, WAIT);%@NL@%
%@NL@%
    for( i = 0; i < CHASER; i++ ) {                %@AB@%/* for each of our threads... */%@AE@%%@NL@%
        univ[i].state = ALIVE;                        %@AB@%/* Set each one alive */%@AE@%%@NL@%
        Tstack = (PBYTE)malloc(sizeof(int) * STACKSIZE);%@NL@%
        if (Tstack == NULL ) {                        %@AB@%/* Create a stack */%@AE@%%@NL@%
            printf( "thread %d stack malloc failed\n", i );%@NL@%
            return(1);%@NL@%
        }%@NL@%
        Tstack += sizeof(int)*STACKSIZE; %@AB@%/* set stack pointer to correct end */%@AE@%%@NL@%
        *--Tstack = HIBYTE(i);%@NL@%
        *--Tstack = LOBYTE(i);                 %@AB@%/* Push the ID on as a parameter */%@AE@%%@NL@%
%@NL@%
        rc = DosCreateThread(chasethread, &chaseID, Tstack);%@NL@%
        if(rc) {%@NL@%
            printf( "create of thread %d failed, error: %d\n", i, rc );%@NL@%
            return (1);%@NL@%
        }%@NL@%
    }%@NL@%
    DosSemClear(&Semaphore);%@NL@%
%@NL@%
    return (0);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * CleanUp()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Routine to reset the Video modes back to where they were.%@NL@%
%@AB@% * (As best as possible).%@NL@%
%@AB@% */%@AE@%%@NL@%
void CleanUp()%@NL@%
{%@NL@%
    char blank[2];%@NL@%
%@NL@%
    DosSleep(1L);             %@AB@%/* Yield the machine so attacker can clean up */%@AE@%%@NL@%
    VioSetMode( &OldVioMode, 0);%@NL@%
%@AB@%/*%@NL@%
%@AB@%    blank[0] = ' ';%@NL@%
%@AB@%    blank[1] = OldVioMode.color;%@NL@%
%@AB@%    VioScrollUp( 0, 0, -1, -1, -1, blank, 0 );%@NL@%
%@AB@%*/%@AE@%%@NL@%
    VioSetCurType( &OldCur, 0);%@NL@%
    DosExit(EXIT_PROCESS,0);              %@AB@%/* Exit and terminate all threads. */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * ParseCmdLine(ac, av)%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parses the command line arguments and sets up the game accordingly%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
int ParseCmdLine(ac,av)%@NL@%
int ac;%@NL@%
char **av;%@NL@%
{%@NL@%
    struct _VIOMODEINFO modedata;%@NL@%
    int    VioMode;%@NL@%
%@NL@%
    Longnap = LONGNAP;%@NL@%
    Shortnap = SHORTNAP;%@NL@%
    ScreenWidth = SCREEN_WIDTH;%@NL@%
    ScreenHeight = SCREEN_HEIGHT;%@NL@%
    VioMode = 25;%@NL@%
%@NL@%
    while(--ac) {%@NL@%
        av++;%@NL@%
        switch(**av) {%@NL@%
            case 'f':%@NL@%
            case 'F':%@NL@%
                Longnap = LONGNAP / 2;%@NL@%
                Shortnap= SHORTNAP/ 2;%@NL@%
                break;%@NL@%
            case 'm':%@NL@%
            case 'M':%@NL@%
                Longnap = LONGNAP;%@NL@%
                Shortnap= SHORTNAP;%@NL@%
                break;%@NL@%
            case 's':%@NL@%
            case 'S':%@NL@%
                Longnap = LONGNAP * 2;%@NL@%
                Shortnap= SHORTNAP* 2;%@NL@%
                break;%@NL@%
            case '4':            %@AB@%/* Assume 43 line mode was wanted */%@AE@%%@NL@%
                ScreenHeight = 42;%@NL@%
                ScreenWidth  = 79;%@NL@%
                VioMode = 43;%@NL@%
                break;%@NL@%
            case '2':%@NL@%
                ScreenHeight = 24;%@NL@%
                ScreenWidth  = 79;%@NL@%
                VioMode = 25;%@NL@%
                break;%@NL@%
            default:%@NL@%
                return(1);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    VioGetCurType(&OldCur, 0);                %@AB@%/* Save old cursor */%@AE@%%@NL@%
%@NL@%
    modedata.cb = sizeof(modedata); %@AB@%/* change mode as needed */%@AE@%%@NL@%
    VioGetMode( &modedata, 0);%@NL@%
    OldVioMode = modedata;%@NL@%
    modedata.row = VioMode;%@NL@%
    VioSetMode( &modedata, 0);%@NL@%
%@NL@%
    NewCur.yStart = 0;%@NL@%
    NewCur.cEnd = 0;%@NL@%
    NewCur.cx = 1;%@NL@%
    NewCur.attr = -1;%@NL@%
%@NL@%
    VioSetCurType( &NewCur, 0 );         %@AB@%/* make cursor go away */%@AE@%%@NL@%
%@NL@%
    return (0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CIRCLEQ.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\COMTALK\CIRCLEQ.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Circular Queue buffer implementation (which gets read by AVIO module)%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_DOSSEMAPHORES %@NL@%
<os2.h>                %@AB@%/* Need USHORT for global.h */%@AE@%%@NL@%
<string.h>                %@AB@%/* One strcpy call */%@AE@%%@NL@%
%@AI@%#include %@AE@%"global.h" %@NL@%
%@AI@%#include %@AE@%"circleq.h" %@NL@%
%@NL@%
       TIMEOUT        1000L                %@AB@%/* A second */%@AE@%%@NL@%
%@NL@%
LineInfo aliRing[QUEUESIZE];        %@AB@%/* The Circular Queue...*/%@AE@%%@NL@%
int  iHead, iTail;%@NL@%
BOOL fFirst;                        %@AB@%/* Are we just starting? */%@AE@%%@NL@%
LONG lSemMyQueue;                %@AB@%/* Queue lock */%@AE@%%@NL@%
%@NL@%
void LineCopy(Line, Line);%@NL@%
void QueFill(void);%@NL@%
%@NL@%
%@AI@%#define %@AE@%QueLock()   DosSemRequest(&lSemMyQueue, -1L) %@NL@%
%@AI@%#define %@AE@%QueUnlock() DosSemClear(&lSemMyQueue) %@NL@%
%@NL@%
%@AI@%#define %@AE@%Fix(n) (((n) >= 0) ? (n) : ((n) + QUEUESIZE)) %@NL@%
%@AI@%#define %@AE@%Circle(x)        ((x) % QUEUESIZE) %@NL@%
%@AI@%#define %@AE@%Incr(x)         (x = Circle(x + 1)) %@NL@%
%@AI@%#define %@AE@%Decr(x)                (x = (x > 0) ? (x - 1) : (QUEUESIZE - 1)) %@NL@%
%@NL@%
void QueFill(void) {%@NL@%
    int i, j;%@NL@%
%@NL@%
    for (i = 0; i < 25; i++) {%@NL@%
        aliRing[i].cch = MAXLINELEN;%@NL@%
        for (j = 0; j < MAXLINELEN; j++)%@NL@%
            aliRing[i].szText[j] = (char) (((i * j) % 10) + '0');%@NL@%
    }%@NL@%
    iHead = 0; iTail = 24;%@NL@%
}%@NL@%
%@NL@%
void QueInit(void) {%@NL@%
    int i;%@NL@%
%@NL@%
    fFirst = TRUE;%@NL@%
    QueLock();%@NL@%
    iHead = 0; iTail = 0;%@NL@%
    for (i = 0; i < QUEUESIZE; i++) aliRing[i].cch = 0;%@NL@%
    QueUnlock();%@NL@%
}%@NL@%
%@NL@%
void QueAdvance(int n) {%@NL@%
    QueLock();%@NL@%
    iHead = Circle(iHead + n);%@NL@%
    QueUnlock();%@NL@%
}%@NL@%
%@NL@%
Line QueQuery(int LineNum) { return &aliRing[Circle(iHead + LineNum)]; }%@NL@%
%@NL@%
BOOL QueInsertLine(Line pli) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Return FALSE if we try to overwrite the head%@NL@%
%@AB@%*/%@AE@%%@NL@%
    QueLock();%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Initialize the queue%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (fFirst) fFirst = FALSE;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Increment TAIL, act if queue full%@NL@%
%@AB@%        Overwrite if last entry was incomplete%@NL@%
%@AB@%    */%@AE@%%@NL@%
    else if (aliRing[iTail].fComplete && (Incr(iTail) == iHead)) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            We are overflowing...%@NL@%
%@AB@%        */%@AE@%%@NL@%
        Decr(iTail);%@NL@%
        QueUnlock();%@NL@%
        return FALSE;%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Insert the element%@NL@%
%@AB@%    */%@AE@%%@NL@%
    LineCopy(pli, &aliRing[iTail]);%@NL@%
    QueUnlock();%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
BOOL QueCompleteLine(void) { return aliRing[iTail].fComplete; }%@NL@%
%@NL@%
void LineCopy(Line pliSrc, Line pliDst) {%@NL@%
    int i;%@NL@%
%@NL@%
    pliDst->fDrawn                = pliSrc->fDrawn;%@NL@%
    pliDst->fComplete                = pliSrc->fComplete;%@NL@%
    pliDst->cch                        = pliSrc->cch;%@NL@%
    for (i = 0; i < (int) pliSrc->cch; i++) pliDst->szText[i] = pliSrc->szText[i];%@NL@%
}%@NL@%
%@NL@%
int QueUpdateHead(int nRows, BOOL bPage, BOOL bPaging) {%@NL@%
    int i, nLines;%@NL@%
%@NL@%
    nLines = Fix(Circle(iTail - iHead));%@NL@%
    nLines = (nLines >= nRows) ? (nLines - nRows + 1) : 0;%@NL@%
    if ((nLines = Min(nLines, nRows)) > 0) {%@NL@%
        if (bPage) {%@NL@%
            if (nLines < nRows) {%@NL@%
                QueLock();%@NL@%
                for (i = nLines; i < nRows; i++)%@NL@%
                    aliRing[Circle(iHead + nRows + i)].cch = 0;%@NL@%
                QueUnlock();%@NL@%
            }%@NL@%
            nLines = nRows;%@NL@%
        }%@NL@%
        else if (bPaging) nLines = 0;%@NL@%
        QueLock();%@NL@%
        iHead = Circle(iHead + nLines);%@NL@%
        QueUnlock();%@NL@%
    }%@NL@%
    return nLines;%@NL@%
}%@NL@%
%@NL@%
Line QueLastLine(void) {%@NL@%
    QueLock();%@NL@%
    aliRing[iTail].szText[aliRing[iTail].cch] = '\0';%@NL@%
    QueUnlock();%@NL@%
    return &aliRing[iTail];%@NL@%
}%@NL@%
%@NL@%
int QuePageUp(int nRows) {%@NL@%
    int i, nLines;%@NL@%
%@NL@%
    QueLock();%@NL@%
    nLines = Min((QUEUESIZE - 1) - Fix(Circle(iTail - iHead)), nRows);%@NL@%
    if (nLines) {%@NL@%
        iHead = Fix(Circle(iHead - nLines));%@NL@%
        for (i = 0; i < nLines; i++)%@NL@%
            aliRing[Circle(iHead + nRows + i)].fDrawn = FALSE;%@NL@%
    }%@NL@%
    QueUnlock();%@NL@%
    return nLines;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CLIPFILE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CLIPVIEW\CLIPFILE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * CLIPFILE.C -- File handling for ClipView%@NL@%
%@AB@% * Created by Microsoft Corporation, 1989%@NL@%
%@AB@% *%@NL@%
%@AB@% * This file contains one routine:  SaveClipboard(), which uses%@NL@%
%@AB@% * the OPENDLG library to put up a File...Save... dialog box.%@NL@%
%@AB@% *%@NL@%
%@AB@% * After getting a file name, it tries to save the current rendered format.%@NL@%
%@AB@% */%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_BITMAPFILEFORMAT %@NL@%
%@AI@%#define %@AE@%       INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%       INCL_GPIMETAFILES %@NL@%
%@AI@%#define %@AE@%       INCL_WINCLIPBOARD %@NL@%
%@AI@%#define %@AE@%       INCL_WINERRORS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<opendlg.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"clipview.h" %@NL@%
%@AB@%/*%@NL@%
%@AB@% * Globals%@NL@%
%@AB@% */%@AE@%%@NL@%
extern HAB        vhab;                        %@AB@%/* Anchor block                */%@AE@%%@NL@%
extern HWND        vhwndClient;                %@AB@%/* Main client area        */%@AE@%%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Macros%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%CHK(f) fSuccess = fSuccess && (f) %@NL@%
%@AI@%#define %@AE@%LOADSTRING(id, sz) WinLoadString(vhab, (HMODULE) NULL, id, MAXLEN, sz) %@NL@%
%@AB@%/*%@NL@%
%@AB@%    Private function prototypes%@NL@%
%@AB@%*/%@AE@%%@NL@%
BOOL SaveText(HFILE hf, PSZ pszText);%@NL@%
%@NL@%
BOOL SaveClipboard(HWND hwnd, USHORT usFormat) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Save the clipboard contents in several formats.%@NL@%
%@AB@%    The "Save BITMAP" code is similar to that in the LINEFRAC sample.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    BOOL                fSuccess = TRUE;     %@AB@%/* Did we succeed in saving? */%@AE@%%@NL@%
    ULONG                hItem;                     %@AB@%/* Handle from QueryClipbrdData */%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Variables needed for File...Save... dialog.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    DLF                 dlf;                     %@AB@%/* Dialog file */%@AE@%%@NL@%
    HFILE                hf;                     %@AB@%/* Handle to output file */%@AE@%%@NL@%
    UCHAR                szExt[8];             %@AB@%/* Default extension */%@AE@%%@NL@%
    UCHAR                szInst[MAXLEN];      %@AB@%/* Instructions */%@AE@%%@NL@%
    UCHAR                szMessage[MAXLEN];   %@AB@%/* Various messages */%@AE@%%@NL@%
    UCHAR                szTitle[MAXTITLELEN];%@AB@%/* Application title */%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Variables needed for saving Metafiles%@NL@%
%@AB@%    */%@AE@%%@NL@%
    HMF                 hmfCopy;             %@AB@%/* Clipboard metafile copy */%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Variables needed for saving BITMAPs%@NL@%
%@AB@%    */%@AE@%%@NL@%
    BITMAPINFOHEADER        bmp;                %@AB@%/* Header to be queried */%@AE@%%@NL@%
    HDC                 hdcMemory;        %@AB@%/* Memory DC for the BITMAP */%@AE@%%@NL@%
    HPS                 hpsMemory;        %@AB@%/* ...and it's associated PS */%@AE@%%@NL@%
    PBITMAPFILEHEADER        pbfh;                %@AB@%/* bmp + color table */%@AE@%%@NL@%
    POINTL                ptlOrigin;        %@AB@%/* Bitmap origin */%@AE@%%@NL@%
    SEL                 selBuffer;        %@AB@%/* Selector to actual BITMAP */%@AE@%%@NL@%
    SEL                 selHeader;        %@AB@%/* Selector for the BMP header */%@AE@%%@NL@%
    SIZEL                sizl;                %@AB@%/* Used in PS creation */%@AE@%%@NL@%
    ULONG                cbBuffer;        %@AB@%/* No. of bytes in buffer */%@AE@%%@NL@%
    USHORT                cbExtra;        %@AB@%/* No. of bytes in "final" segment */%@AE@%%@NL@%
    USHORT                cbHeader;        %@AB@%/* No. of bytes in header */%@AE@%%@NL@%
    USHORT                cbWrite1;        %@AB@%/* No. of bytes to be written... */%@AE@%%@NL@%
    USHORT                cbWrite2;        %@AB@%/* ...in the two-part sel writes */%@AE@%%@NL@%
    USHORT                cbWritten;        %@AB@%/* No. of bytes actually written */%@AE@%%@NL@%
    USHORT                cSegs;                %@AB@%/* No. of segments to write */%@AE@%%@NL@%
    USHORT                i;                %@AB@%/* Which segment is being written? */%@AE@%%@NL@%
    USHORT                usHugeShift;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Open the clipboard%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (!WinOpenClipbrd(vhab))%@NL@%
        return FALSE;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Get the clipboard data%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (hItem = WinQueryClipbrdData(vhab, usFormat)) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Put up the Save... file dialog with the appropriate extensions%@NL@%
%@AB@%        */%@AE@%%@NL@%
        switch (usFormat) {%@NL@%
            case CF_TEXT:%@NL@%
            case CF_DSPTEXT:         strcpy(szExt, "\\*.TXT");  break;%@NL@%
%@NL@%
            case CF_BITMAP:%@NL@%
            case CF_DSPBITMAP:         strcpy(szExt, "\\*.BMP");  break;%@NL@%
%@NL@%
            case CF_METAFILE:%@NL@%
            case CF_DSPMETAFILE: strcpy(szExt, "\\*.MET");  break;%@NL@%
%@NL@%
            default:                 strcpy(szExt, "\\*.*");    break;%@NL@%
        }%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Put the string "Saving Format:  <format>" in the Save dialog box%@NL@%
%@AB@%        */%@AE@%%@NL@%
        GetFormatName(usFormat, szMessage);%@NL@%
        LOADSTRING(IDS_SAVETITLE, szTitle);%@NL@%
        strcat(szTitle, szMessage);%@NL@%
%@NL@%
        LOADSTRING(IDS_APPNAME, szMessage);%@NL@%
        LOADSTRING(IDS_INST, szInst);%@NL@%
%@NL@%
        SetupDLF(&dlf, DLG_SAVEDLG, &hf,%@NL@%
                 (PSZ) szExt, (PSZ) szMessage, (PSZ) szTitle, (PSZ) szInst);%@NL@%
%@NL@%
        dlf.szFileName[0] = dlf.szOpenFile[0] = '\0';%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Put up a Save file dialog, and respond appropriately to%@NL@%
%@AB@%            the return status.%@NL@%
%@AB@%        */%@AE@%%@NL@%
        switch (DlgFile(hwnd, &dlf)) {%@NL@%
            case TDF_ERRMEM:%@NL@%
            case TDF_INVALID:%@NL@%
            case TDF_NOSAVE:%@NL@%
                fSuccess = FALSE;%@NL@%
%@NL@%
                %@AB@%/* fall through... */%@AE@%%@NL@%
            default:%@NL@%
                break;%@NL@%
        }%@NL@%
%@NL@%
        if (fSuccess) {%@NL@%
          switch (usFormat) {%@NL@%
%@NL@%
            case CF_TEXT:%@NL@%
            case CF_DSPTEXT:%@NL@%
                CHK(SaveText(hf, MAKEP((SEL) hItem, 0)));%@NL@%
                DosClose(hf);%@NL@%
                break;%@NL@%
%@NL@%
            case CF_BITMAP:%@NL@%
            case CF_DSPBITMAP:%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Initialize the Memory DC and its PS%@NL@%
%@AB@%                */%@AE@%%@NL@%
                sizl.cx = sizl.cy = 0L;%@NL@%
                hdcMemory = DevOpenDC(vhab, OD_MEMORY, "*", 0L, NULL, NULL);%@NL@%
                hpsMemory = GpiCreatePS(vhab, hdcMemory, &sizl,%@NL@%
                                  GPIA_ASSOC | GPIT_MICRO | PU_PELS);%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Draw the BITMAP into the Memory DC%@NL@%
%@AB@%                */%@AE@%%@NL@%
                CHK(GpiSetBitmap(hpsMemory, (HBITMAP) hItem) != HBM_ERROR);%@NL@%
                ptlOrigin.x = ptlOrigin.y = 0L;%@NL@%
                CHK(WinDrawBitmap(hpsMemory, (HBITMAP) hItem, NULL,%@NL@%
                           &ptlOrigin, CLR_BLACK, CLR_BACKGROUND, DBM_NORMAL));%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Get information about the BITMAP%@NL@%
%@AB@%                */%@AE@%%@NL@%
                CHK(GpiQueryBitmapParameters((HBITMAP) hItem, &bmp) == GPI_OK);%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Compute the size of the buffer, and allocate%@NL@%
%@AB@%                    Make sure that > 64K BITMAPs are handled%@NL@%
%@AB@%                    (this code is from LFFILE.C)%@NL@%
%@AB@%                */%@AE@%%@NL@%
                cbBuffer = ( ((((ULONG)bmp.cBitCount*(ULONG) bmp.cx)+31L)/32L)%@NL@%
                                * 4L * (ULONG) bmp.cy * (ULONG) bmp.cPlanes );%@NL@%
                cSegs   = (USHORT) (cbBuffer >> 16);%@NL@%
                cbExtra = (USHORT) (cbBuffer & 0xFFFFL);%@NL@%
                CHK(!DosAllocHuge(cSegs, cbExtra, &selBuffer, 0, 0));%@NL@%
                CHK(!DosGetHugeShift(&usHugeShift));%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Compute the size of the BITMAPFILEHEADER + color table...%@NL@%
%@AB@%                    ...then allocate it.%@NL@%
%@AB@%                */%@AE@%%@NL@%
                cbHeader = (USHORT) (sizeof(BITMAPFILEHEADER)%@NL@%
                                + (sizeof(RGB) << bmp.cBitCount));%@NL@%
                CHK(!DosAllocSeg(cbHeader, &selHeader, SEG_NONSHARED));%@NL@%
                pbfh = MAKEP(selHeader, 0);%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Copy the BITMAP information from the BITMAPINFOHEADER%@NL@%
%@AB@%                */%@AE@%%@NL@%
                pbfh->bmp.cbFix     = 12;%@NL@%
                pbfh->bmp.cx            = bmp.cx;%@NL@%
                pbfh->bmp.cy            = bmp.cy;%@NL@%
                pbfh->bmp.cPlanes   = bmp.cPlanes;%@NL@%
                pbfh->bmp.cBitCount = bmp.cBitCount;%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Get the actual BITMAP bits%@NL@%
%@AB@%                */%@AE@%%@NL@%
                CHK(GpiQueryBitmapBits(hpsMemory, 0L, (LONG) bmp.cy,%@NL@%
                       MAKEP(selBuffer, 0), (PBITMAPINFO) &(pbfh->bmp))%@NL@%
                    != GPI_ALTERROR);%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Set up the file header%@NL@%
%@AB@%                */%@AE@%%@NL@%
                pbfh->usType            = BFT_BMAP;%@NL@%
                pbfh->cbSize            = cbHeader + cbBuffer;%@NL@%
                pbfh->xHotspot            = bmp.cx / 2;        %@AB@%/* Anywhere will do */%@AE@%%@NL@%
                pbfh->yHotspot            = bmp.cy / 2;%@NL@%
                pbfh->offBits            = cbHeader;%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Blast the BITMAP to a file...%@NL@%
%@AB@%            */%@AE@%%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    ...first, the header...%@NL@%
%@AB@%                */%@AE@%%@NL@%
                CHK(!DosWrite(hf, pbfh, cbHeader, &cbWritten));%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    ...then, the possibly large BITMAP itself%@NL@%
%@AB@%                */%@AE@%%@NL@%
                for (i = 0; i <= cSegs; ++i) {%@NL@%
                    if (i < cSegs) {%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                        If we a 64K segment, write it in two%@NL@%
%@AB@%                        parts.         This must be done because%@NL@%
%@AB@%                        DosWrite() can only write 64K - 1%@NL@%
%@AB@%                        characters at once.%@NL@%
%@AB@%                    */%@AE@%%@NL@%
                        cbWrite1 = cbWrite2 = 0x8000;%@NL@%
                    } else {%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                        The last segment is always small enough%@NL@%
%@AB@%                        to write entirely.%@NL@%
%@AB@%                    */%@AE@%%@NL@%
                        cbWrite1 = cbExtra; cbWrite2 = 0;%@NL@%
                    }%@NL@%
%@NL@%
                    if (cbWrite1) {%@NL@%
                        CHK(!DosWrite(hf,%@NL@%
                                MAKEP((selBuffer + (i << usHugeShift)), 0),%@NL@%
                                cbWrite1, &cbWritten));%@NL@%
                        if (cbWrite2) {%@NL@%
                            CHK(!DosWrite(hf,%@NL@%
                                MAKEP((selBuffer + (i<<usHugeShift)),cbWrite1),%@NL@%
                                cbWrite2, &cbWritten));%@NL@%
                        }%@NL@%
                    }%@NL@%
                }%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Clean up%@NL@%
%@AB@%%@NL@%
%@AB@%                    Error codes are not checked here because the file has%@NL@%
%@AB@%                    already been saved.%@NL@%
%@AB@%                */%@AE@%%@NL@%
                DosClose(hf);%@NL@%
                GpiSetBitmap(hpsMemory, NULL);%@NL@%
                GpiDestroyPS(hpsMemory);%@NL@%
                DevCloseDC(hdcMemory);%@NL@%
                break;%@NL@%
%@NL@%
            case CF_METAFILE:%@NL@%
            case CF_DSPMETAFILE:%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Save metafile%@NL@%
%@AB@%%@NL@%
%@AB@%                    We close and delete the file, because GpiSaveMetaFile()%@NL@%
%@AB@%                    only allows the user to create a new file.%@NL@%
%@AB@%%@NL@%
%@AB@%                    We copy the metafile because GpiSaveMetafile()%@NL@%
%@AB@%                    removes the data from the application's memory.%@NL@%
%@AB@%                */%@AE@%%@NL@%
                DosClose(hf);%@NL@%
                CHK(!DosDelete(dlf.szFileName, 0L));%@NL@%
                CHK((hmfCopy = GpiCopyMetaFile((HMF) hItem)) != GPI_ERROR);%@NL@%
                CHK(GpiSaveMetaFile(hmfCopy, dlf.szFileName) != GPI_ERROR);%@NL@%
                break;%@NL@%
%@NL@%
            default:%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    It may be reasonable to add support for other formats%@NL@%
%@AB@%                    here, by saving a bitmap of the current window contents.%@NL@%
%@AB@%%@NL@%
%@AB@%                    But for now, close the file and return an error message.%@NL@%
%@AB@%                */%@AE@%%@NL@%
                DosClose(hf);%@NL@%
                fSuccess = FALSE;%@NL@%
                break;%@NL@%
          }%@NL@%
        }%@NL@%
    } else%@NL@%
        fSuccess = FALSE;        %@AB@%/* Couldn't query the clipboard format! */%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Clean up%@NL@%
%@AB@%    */%@AE@%%@NL@%
    WinCloseClipbrd(vhab);%@NL@%
    return fSuccess;%@NL@%
}%@NL@%
%@NL@%
BOOL SaveText(HFILE hf, PSZ pszText) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Save text format%@NL@%
%@AB@%%@NL@%
%@AB@%    Count the number of characters, then write them.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    PSZ     pszCounter;     %@AB@%/* Temporary to count chars in sel */%@AE@%%@NL@%
    ULONG   ulcch = 0;            %@AB@%/* The number of characters */%@AE@%%@NL@%
    USHORT  cbWritten;            %@AB@%/* No. of bytes actually written */%@AE@%%@NL@%
%@NL@%
    pszCounter = pszText;%@NL@%
    while (*pszCounter++) ulcch++;%@NL@%
%@NL@%
    return(!DosWrite(hf, pszText, (USHORT) ulcch, &cbWritten));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CLIPVIEW.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CLIPVIEW\CLIPVIEW.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * CLIPVIEW.C -- Clipboard Viewing application%@NL@%
%@AB@% * Created by Microsoft Corporation, 1989%@NL@%
%@AB@% *%@NL@%
%@AB@% * This program registers itself as the clipboard viewer, if no clipboard%@NL@%
%@AB@% * viewer exists.  Then, it intercepts WM_DRAWCLIPBOARD messages.%@NL@%
%@AB@% *%@NL@%
%@AB@% * This file contains the routines which handle the client/frame windows,%@NL@%
%@AB@% * the dialog routines, and the clipboard rendering code.%@NL@%
%@AB@% */%@AE@%%@NL@%
%@AI@%#define %@AE@%       INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%       INCL_GPIMETAFILES %@NL@%
%@AI@%#define %@AE@%INCL_WINATOM %@NL@%
%@AI@%#define %@AE@%       INCL_WINCLIPBOARD %@NL@%
%@AI@%#define %@AE@%       INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%       INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%       INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%       INCL_WINMLE %@NL@%
%@AI@%#define %@AE@%       INCL_WINSCROLLBARS %@NL@%
%@AI@%#define %@AE@%       INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%       INCL_WINWINDOWMGR %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"clipview.h" %@NL@%
%@AB@%/*%@NL@%
%@AB@% * Globals%@NL@%
%@AB@% */%@AE@%%@NL@%
BITMAPINFOHEADER vbmp;                        // Dimensions of current BITMAP%@NL@%
BOOL        vfUpdate        = FALSE;        // Are we updating the clipboard?%@NL@%
BOOL        vfViewBitmap        = FALSE;        // Are we currently viewing a...?%@NL@%
HAB        vhab;                                // Anchor block%@NL@%
HDC        vhdcMemory;                        // A memory DC for BitBlt-ing images%@NL@%
HDC        vhdcWindow        = NULL;         // Client window DC%@NL@%
HMQ        vhmqClip;                        // Message queue%@NL@%
HPS        vhpsMemory;                        // A PS associated with vhdcMemory%@NL@%
HWND        vhwndClient;                        // Main client area%@NL@%
HWND        vhwndClipFrame = NULL;                // Main frame window%@NL@%
HWND        vhwndHSB        = NULL;         // Horizontal scroll bar%@NL@%
HWND        vhwndMLE        = NULL;         // Handle to the MLE%@NL@%
HWND        vhwndTitlebar        = NULL;         // Title-bar handle%@NL@%
HWND        vhwndVSB        = NULL;         // Vertical scroll bar%@NL@%
SHORT        vcMaxHSB;                        // Maximum scroll range for HSB%@NL@%
SHORT        vcMaxVSB;                        // ...and for the VSB%@NL@%
SHORT        vcUpdate        = -1;                // Counter for scroll bar updating%@NL@%
USHORT        vausFormats[MAXFORMATS];        // All available formats%@NL@%
USHORT        vcFmts;                         // How many formats?%@NL@%
USHORT        vusFormat;                        // What is the current format?%@NL@%
USHORT        vfsFmtInfo;                        // Clipboard Format Information%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Macros%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%LOADSTRING(id, sz) WinLoadString(vhab, (HMODULE) NULL, id, MAXLEN, sz) %@NL@%
%@AI@%#define %@AE@%MESSAGE(sz) WinMessageBox(HWND_DESKTOP, vhwndClient, sz, NULL, 0, \ %@NL@%
                        MB_OK | MB_ICONASTERISK | MB_SYSTEMMODAL);%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Main routine...initializes window and message queue%@NL@%
%@AB@% */%@AE@%%@NL@%
int cdecl main( ) {%@NL@%
    QMSG    qmsg;                    %@AB@%/* Message queue */%@AE@%%@NL@%
    ULONG   ctldata;                    %@AB@%/* FCF_ flags */%@AE@%%@NL@%
    BOOL    fViewer;                    %@AB@%/* Does a viewer already exist? */%@AE@%%@NL@%
    UCHAR   szAlready[MAXLEN];            %@AB@%/* Already extant... message */%@AE@%%@NL@%
    UCHAR   szClassName[MAXLEN];    %@AB@%/* New class name */%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Start up our PM application%@NL@%
%@AB@%    */%@AE@%%@NL@%
    vhab = WinInitialize(0);%@NL@%
    vhmqClip = WinCreateMsgQueue(vhab, 0);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        We create the client window first to try to avoid%@NL@%
%@AB@%        synchronization problems.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    LOADSTRING(IDS_CLIPCLASS, szClassName);%@NL@%
    if (!WinRegisterClass( vhab, (PCH)szClassName, (PFNWP)ClipWndProc,%@NL@%
                CS_SIZEREDRAW, 0))%@NL@%
        return( 0 );%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Create the window (hidden)%@NL@%
%@AB@%    */%@AE@%%@NL@%
    ctldata = (FCF_STANDARD | FCF_HORZSCROLL | FCF_VERTSCROLL)%@NL@%
                            & ~(FCF_ACCELTABLE);%@NL@%
%@NL@%
    vhwndClipFrame = WinCreateStdWindow( HWND_DESKTOP, WS_VISIBLE, &ctldata,%@NL@%
                                         szClassName, "",%@NL@%
                                         WS_VISIBLE, (HMODULE) NULL, ID_RESOURCE,%@NL@%
                                         (PHWND) &vhwndClient );%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        If there is no other clipboard viewer...%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (fViewer = !WinQueryClipbrdViewer(vhab, FALSE)) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            ...we'll be the viewer.  Show the clipboard window.%@NL@%
%@AB@%        */%@AE@%%@NL@%
        WinSetClipbrdViewer(vhab, vhwndClient);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Poll messages from event queue%@NL@%
%@AB@%        */%@AE@%%@NL@%
        while( WinGetMsg( vhab, (PQMSG)&qmsg, (HWND)NULL, 0, 0 ) )%@NL@%
            WinDispatchMsg( vhab, (PQMSG)&qmsg );%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Stop being the clipboard viewer.%@NL@%
%@AB@%        */%@AE@%%@NL@%
        if (vhwndMLE)%@NL@%
            WinDestroyWindow(vhwndMLE);%@NL@%
        WinSetClipbrdViewer(vhab, NULL);%@NL@%
    } else {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            ...otherwise, notify the user, then terminate.%@NL@%
%@AB@%        */%@AE@%%@NL@%
        LOADSTRING(IDS_ALREADY, szAlready);%@NL@%
        MESSAGE(szAlready);%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Clean up%@NL@%
%@AB@%    */%@AE@%%@NL@%
    WinDestroyWindow( vhwndClipFrame );%@NL@%
    WinDestroyMsgQueue( vhmqClip );%@NL@%
    WinTerminate( vhab );%@NL@%
%@NL@%
    return !fViewer;%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK ClipWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%%@NL@%
%@AB@% * This routine processes WM_COMMAND, WM_CREATE, WM_DRAWCLIPBOARD, WM_PAINT.%@NL@%
%@AB@% * Everything else is passed to the Default Window Procedure.%@NL@%
%@AB@% */%@AE@%%@NL@%
    HPS                hpsWindow;%@NL@%
    RECTL        rcl;%@NL@%
    SWP         swp;%@NL@%
    SIZEL        sizl;%@NL@%
    UCHAR        szMessage[MAXLEN];%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
        case WM_CREATE:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Create a memory DC/PS to BitBlt BITMAPs around.%@NL@%
%@AB@%            */%@AE@%%@NL@%
            sizl.cx = sizl.cy = 0L;%@NL@%
            vhdcMemory = DevOpenDC(vhab, OD_MEMORY, "*", 0L, NULL, NULL);%@NL@%
            vhpsMemory = GpiCreatePS(vhab, vhdcMemory, &sizl,%@NL@%
                GPIA_ASSOC | GPIF_DEFAULT | GPIT_MICRO | PU_PELS);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            switch (COMMANDMSG(&msg)->cmd) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    About... dialog box%@NL@%
%@AB@%                */%@AE@%%@NL@%
                case IDM_ABOUT:%@NL@%
                    WinDlgBox(HWND_DESKTOP, hwnd, AboutDlgProc,%@NL@%
                              (HMODULE) NULL, IDD_ABOUT, NULL);%@NL@%
                    return 0;%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Render... dialog box%@NL@%
%@AB@%                */%@AE@%%@NL@%
                case IDM_RENDER:%@NL@%
                    WinDlgBox(HWND_DESKTOP, hwnd, RenderDlgProc,%@NL@%
                              (HMODULE) NULL, IDD_RENDER, NULL);%@NL@%
                    return 0;%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Save... dialog box%@NL@%
%@AB@%                */%@AE@%%@NL@%
                case IDM_SAVE:%@NL@%
                    if (!SaveClipboard(hwnd, vusFormat)) {%@NL@%
                        LOADSTRING(IDS_NOTSAVED, szMessage);%@NL@%
                        MESSAGE(szMessage);%@NL@%
                    }%@NL@%
                    return 0;%@NL@%
%@NL@%
                default: break;%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case WM_ERASEBACKGROUND:%@NL@%
            return (MRESULT) TRUE;%@NL@%
            break;%@NL@%
%@NL@%
        case WM_PAINT:%@NL@%
            %@AB@%/* Open the presentation space */%@AE@%%@NL@%
            hpsWindow = WinBeginPaint(hwnd, NULL, &rcl);%@NL@%
%@NL@%
            %@AB@%/* Fill in the background */%@AE@%%@NL@%
            WinFillRect(hpsWindow, &rcl, CLR_BACKGROUND);%@NL@%
%@NL@%
            %@AB@%/* Paint in the clipboard */%@AE@%%@NL@%
            UpdateScreen(hwnd, vusFormat);%@NL@%
%@NL@%
            %@AB@%/* Finish painting */%@AE@%%@NL@%
            WinEndPaint(hpsWindow);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_DRAWCLIPBOARD:%@NL@%
            %@AB@%/* Update the clipboard contents */%@AE@%%@NL@%
            GetAllFormats();%@NL@%
            vfUpdate = TRUE;%@NL@%
            WinPostMsg(hwnd, WM_PAINT, 0L, 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_HSCROLL:%@NL@%
            if (vfViewBitmap) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Handle the appropriate scrolling messages%@NL@%
%@AB@%                */%@AE@%%@NL@%
                DoScrolling(hwnd, TRUE, HIUSHORT(mp2));%@NL@%
            } else%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    If an ownerdraw format, let the owner handle it.%@NL@%
%@AB@%                */%@AE@%%@NL@%
                SendOwnerMsg(WM_HSCROLLCLIPBOARD, (MPARAM) hwnd, mp2);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_VSCROLL:%@NL@%
            if (vfViewBitmap) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Handle the appropriate scrolling messages%@NL@%
%@AB@%                */%@AE@%%@NL@%
                DoScrolling(hwnd, FALSE, HIUSHORT(mp2));%@NL@%
            } else%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    If an ownerdraw format, let the owner handle it.%@NL@%
%@AB@%                */%@AE@%%@NL@%
                SendOwnerMsg(WM_VSCROLLCLIPBOARD, (MPARAM) hwnd, mp2);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_SIZE:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                If the MLE is processing a text selector,%@NL@%
%@AB@%                tell it to resize itself.  If we have%@NL@%
%@AB@%                owner-draw data, tell the clipboard owner.%@NL@%
%@AB@%                If we have a BITMAP, readjust the scroll%@NL@%
%@AB@%                bar ranges.%@NL@%
%@AB@%            */%@AE@%%@NL@%
            if (vhwndMLE) {%@NL@%
                WinQueryWindowPos(vhwndMLE, &swp);%@NL@%
                swp.cx = SHORT1FROMMP(mp2);%@NL@%
                swp.cy = SHORT2FROMMP(mp2);%@NL@%
                WinSetMultWindowPos(vhab, &swp, 1);%@NL@%
            } else if (vfViewBitmap) {%@NL@%
                WinQueryWindowPos(hwnd, &swp);%@NL@%
                if ((vcMaxHSB = vbmp.cx - swp.cx) < 0)%@NL@%
                    vcMaxHSB = 0;%@NL@%
                if ((vcMaxVSB = vbmp.cy - swp.cy) < 0)%@NL@%
                    vcMaxVSB = 0;%@NL@%
                WinSendMsg(vhwndHSB, SBM_SETSCROLLBAR,%@NL@%
                    0L, MPFROM2SHORT(0, vcMaxHSB));%@NL@%
                WinSendMsg(vhwndVSB, SBM_SETSCROLLBAR,%@NL@%
                    MPFROMSHORT(vcMaxVSB),%@NL@%
                    MPFROM2SHORT(0, vcMaxVSB));%@NL@%
            } else {%@NL@%
                rcl.xLeft = rcl.yBottom = 0L;%@NL@%
                rcl.xLeft = (LONG) SHORT1FROMMP(mp2) - 1;%@NL@%
                rcl.yTop  = (LONG) SHORT2FROMMP(mp2) - 1;%@NL@%
                SendOwnerMsg(WM_SIZECLIPBOARD, (MPARAM) hwnd, &rcl);%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return WinDefWindowProc(hwnd, msg, mp1, mp2);%@NL@%
            break;%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK RenderDlgProc(HWND hwndDlg, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Render... dialog procedure%@NL@%
%@AB@%*/%@AE@%%@NL@%
    HWND        hwndListbox;                %@AB@%/* Listbox of possible formats */%@AE@%%@NL@%
    UCHAR        szFmtName[MAXLEN];        %@AB@%/* Format name */%@AE@%%@NL@%
    UCHAR        szMessage[MAXLEN];%@NL@%
    USHORT        i;%@NL@%
    USHORT        usFormat;                %@AB@%/* Format to render */%@AE@%%@NL@%
    MRESULT        mrItem;                 %@AB@%/* Which listbox item selected? */%@AE@%%@NL@%
%@NL@%
    switch(msg) {%@NL@%
%@NL@%
        case WM_INITDLG:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Put all the possible formats into the listbox, and%@NL@%
%@AB@%                select the first item by default.%@NL@%
%@AB@%            */%@AE@%%@NL@%
            hwndListbox = WinWindowFromID(hwndDlg, IDL_RENDER);%@NL@%
            WinSendMsg(hwndListbox, LM_DELETEALL, 0L, 0L);%@NL@%
            for (i = 0; i < vcFmts; i++) {%@NL@%
                GetFormatName(vausFormats[i], szFmtName);%@NL@%
                WinSendMsg(hwndListbox, LM_INSERTITEM,%@NL@%
                        MPFROMSHORT(LIT_END), MPFROMP((PVOID) szFmtName));%@NL@%
            }%@NL@%
            WinSendMsg(hwndListbox, LM_SELECTITEM, 0L, MPFROMSHORT(TRUE));%@NL@%
            break;%@NL@%
%@NL@%
        case WM_CONTROL:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                If the user makes a selection, quit!%@NL@%
%@AB@%            */%@AE@%%@NL@%
            if ((SHORT1FROMMP(mp1) == IDL_RENDER)%@NL@%
                && (SHORT2FROMMP(mp1) == LN_ENTER))%@NL@%
                    WinPostMsg(hwndDlg, WM_COMMAND, MPFROMSHORT(DID_OK), 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case DID_OK:%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                        Since the user chose a selection, try to render it.%@NL@%
%@AB@%                    */%@AE@%%@NL@%
                    hwndListbox = WinWindowFromID(hwndDlg, IDL_RENDER);%@NL@%
                    mrItem = WinSendMsg(hwndListbox, LM_QUERYSELECTION, 0L, 0L);%@NL@%
                    if (mrItem != (MRESULT) LIT_NONE) {%@NL@%
                        usFormat = vausFormats[SHORT1FROMMR(mrItem)];%@NL@%
                        if (usFormat != vusFormat) {%@NL@%
                            %@AB@%/*%@NL@%
%@AB@%                                If the clipboard format is not rendered,%@NL@%
%@AB@%                                tell the user.%@NL@%
%@AB@%                            */%@AE@%%@NL@%
                            vfUpdate = TRUE;%@NL@%
                            if (!UpdateScreen(vhwndClient, usFormat)) {%@NL@%
                                LOADSTRING(IDS_NODISPLAY, szMessage);%@NL@%
                                MESSAGE(szMessage);%@NL@%
                            }%@NL@%
                        }%@NL@%
                    }%@NL@%
%@NL@%
                    %@AB@%/* fall through */%@AE@%%@NL@%
%@NL@%
                case DID_CANCEL:%@NL@%
                    WinDismissDlg(hwndDlg, TRUE);%@NL@%
%@NL@%
                default: break;%@NL@%
            }%@NL@%
        default: return WinDefDlgProc(hwndDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK AboutDlgProc(HWND hwndDlg, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
%@AB@%/*%@NL@%
%@AB@%    About... dialog procedure%@NL@%
%@AB@%*/%@AE@%%@NL@%
    switch(msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case DID_OK: WinDismissDlg(hwndDlg, TRUE);%@NL@%
                default: break;%@NL@%
            }%@NL@%
        default: return WinDefDlgProc(hwndDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
VOID ReadSelector(HWND hwndMLE, PSZ pszText) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Compute the length of the text selector, in bytes.%@NL@%
%@AB@%    Allocate space, and copy the text selector into an MLE.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    IPT ipt;%@NL@%
    ULONG ulcch = 0;%@NL@%
    PSZ        pszCounter;%@NL@%
%@NL@%
    pszCounter = pszText;%@NL@%
    while (*pszCounter++) ulcch++;%@NL@%
    WinSendMsg(hwndMLE, MLM_FORMAT, MPFROMSHORT(MLFIE_CFTEXT), 0L);%@NL@%
    WinSendMsg(hwndMLE, MLM_SETIMPORTEXPORT, pszText, (MPARAM) ulcch);%@NL@%
    WinSendMsg(hwndMLE, MLM_IMPORT, &ipt, (MPARAM) ulcch);%@NL@%
}%@NL@%
%@NL@%
VOID FixFrame(VOID) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    This routine tells the frame to update the scroll bars.%@NL@%
%@AB@%%@NL@%
%@AB@%    First, make it so that the scroll bars cannot update themselves.%@NL@%
%@AB@%    Let the frame update the controls.  Then, re-enable the scroll bars.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (!(vcUpdate--)) {%@NL@%
        WinEnableWindowUpdate(vhwndHSB, FALSE);%@NL@%
        WinEnableWindowUpdate(vhwndVSB, FALSE);%@NL@%
    }%@NL@%
%@NL@%
    WinSendMsg(vhwndClipFrame, WM_UPDATEFRAME, MPFROMLONG(FCF_HORZSCROLL), 0L);%@NL@%
    WinSendMsg(vhwndClipFrame, WM_UPDATEFRAME, MPFROMLONG(FCF_VERTSCROLL), 0L);%@NL@%
%@NL@%
    if (!(++vcUpdate)) {%@NL@%
        WinEnableWindowUpdate(vhwndHSB, TRUE);%@NL@%
        WinEnableWindowUpdate(vhwndVSB, TRUE);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
VOID NeedScrollBars(BOOL fNeed) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    This routine hides changes the scroll bar state to correspond with%@NL@%
%@AB@%    fNeed, showing or hiding them as necessary.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    static BOOL fNeeded = TRUE;                %@AB@%/* The last scroll bar state */%@AE@%%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Get the scroll bar handles, if we haven't already.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (!vhwndHSB) {%@NL@%
        vhwndHSB = WinWindowFromID(vhwndClipFrame, FID_HORZSCROLL);%@NL@%
        vhwndVSB = WinWindowFromID(vhwndClipFrame, FID_VERTSCROLL);%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Case 1:  We need scroll bars, so enable them.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (fNeed) {%@NL@%
        if (!fNeeded) {%@NL@%
            WinSetParent(vhwndHSB, vhwndClipFrame, TRUE);%@NL@%
            WinSetParent(vhwndVSB, vhwndClipFrame, TRUE);%@NL@%
            FixFrame();%@NL@%
        }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Case 2:  We don't need scroll bars, so hide them.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    } else {%@NL@%
        if (fNeeded) {%@NL@%
            WinSetParent(vhwndHSB, HWND_OBJECT, TRUE);%@NL@%
            WinSetParent(vhwndVSB, HWND_OBJECT, TRUE);%@NL@%
            FixFrame();%@NL@%
        }%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Save state for next invocation%@NL@%
%@AB@%    */%@AE@%%@NL@%
    fNeeded = fNeed;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    RenderFormat()%@NL@%
%@AB@%%@NL@%
%@AB@%    Input:                Clipboard format to render, and handle to client area%@NL@%
%@AB@%    Side effects:        Renders the image in the client area%@NL@%
%@AB@%*/%@AE@%%@NL@%
BOOL RenderFormat(HWND hwnd, USHORT usFormat) {%@NL@%
    BOOL    fRendered = TRUE;%@NL@%
    HMF            hmfCopy;%@NL@%
    HPS     hpsWindow;%@NL@%
    LONG    alOptions[8];%@NL@%
    RECTL   rclWindow;%@NL@%
    SIZEL   sizl;%@NL@%
    SWP            swpWindow;%@NL@%
    ULONG   hItem;%@NL@%
    POINTL  aptl[3];%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Open the clipboard%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (!WinOpenClipbrd(vhab))%@NL@%
        return FALSE;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Open up the window DC and PS%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (!vhdcWindow)%@NL@%
        vhdcWindow = WinOpenWindowDC(hwnd);%@NL@%
%@NL@%
    sizl.cx = sizl.cy = 0L;%@NL@%
    hpsWindow = GpiCreatePS(vhab, vhdcWindow, &sizl, GPIA_ASSOC | PU_ARBITRARY);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Enable the scroll bars, if necessary.  This affects the size%@NL@%
%@AB@%        of the client area.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (vfUpdate)%@NL@%
        NeedScrollBars( (vfViewBitmap =%@NL@%
                (usFormat == CF_BITMAP) || (usFormat == CF_DSPBITMAP)) );%@NL@%
%@NL@%
    WinQueryWindowRect(hwnd, &rclWindow);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Get the clipboard data%@NL@%
%@AB@%    */%@AE@%%@NL@%
    WinQueryClipbrdFmtInfo(vhab, usFormat, &vfsFmtInfo);%@NL@%
    if (!(hItem = WinQueryClipbrdData(vhab, usFormat))) {%@NL@%
        fRendered = FALSE;%@NL@%
    } else {%@NL@%
      %@AB@%/*%@NL@%
%@AB@%        Display the new format, as appropriate.%@NL@%
%@AB@%      */%@AE@%%@NL@%
      switch (usFormat) {%@NL@%
        case CF_TEXT:%@NL@%
        case CF_DSPTEXT:%@NL@%
            if (vfUpdate) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Create a new MLE and read the text into it.%@NL@%
%@AB@%                */%@AE@%%@NL@%
                vhwndMLE = WinCreateWindow(hwnd, WC_MLE, "",%@NL@%
                    WS_VISIBLE | MLS_READONLY | MLS_HSCROLL | MLS_VSCROLL,%@NL@%
                    0, 0,%@NL@%
                    (SHORT) rclWindow.xRight, (SHORT) rclWindow.yTop,%@NL@%
                    hwnd, HWND_TOP, 0, NULL, NULL);%@NL@%
%@NL@%
                ReadSelector(vhwndMLE, MAKEP((SEL) hItem, 0));%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case CF_BITMAP:%@NL@%
        case CF_DSPBITMAP:%@NL@%
            if (vfUpdate) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Get the BITMAP dimensions, for scroll bar processing%@NL@%
%@AB@%                */%@AE@%%@NL@%
                if (GpiQueryBitmapParameters((HBITMAP) hItem, &vbmp)%@NL@%
                        != GPI_OK) {%@NL@%
                    return FALSE;%@NL@%
                }%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Set the scroll bar ranges from 0 to vbmp.max - client.max%@NL@%
%@AB@%                */%@AE@%%@NL@%
                WinQueryWindowPos(hwnd, &swpWindow);%@NL@%
%@NL@%
                if ((vcMaxHSB = vbmp.cx - swpWindow.cx) < 0)%@NL@%
                    vcMaxHSB = 0;%@NL@%
                if ((vcMaxVSB = vbmp.cy - swpWindow.cy) < 0)%@NL@%
                    vcMaxVSB = 0;%@NL@%
                WinSendMsg(vhwndHSB, SBM_SETSCROLLBAR,%@NL@%
                    0L, MPFROM2SHORT(0, vcMaxHSB));%@NL@%
                WinSendMsg(vhwndVSB, SBM_SETSCROLLBAR,%@NL@%
                    MPFROMSHORT(vcMaxVSB),%@NL@%
                    MPFROM2SHORT(0, vcMaxVSB));%@NL@%
            }%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Draw the BITMAP, based on the scroll bar settings.%@NL@%
%@AB@%            */%@AE@%%@NL@%
            GpiSetBitmap(vhpsMemory, (HBITMAP) hItem);%@NL@%
%@NL@%
            aptl[0].x = rclWindow.xLeft;        %@AB@%/* Target bottom left */%@AE@%%@NL@%
            aptl[0].y = rclWindow.yBottom;%@NL@%
            aptl[1].x = rclWindow.xRight;        %@AB@%/* Target top right */%@AE@%%@NL@%
            aptl[1].y = rclWindow.yTop;%@NL@%
                                                %@AB@%/* Source bottom left */%@AE@%%@NL@%
            aptl[2].x = (LONG) WinSendMsg(vhwndHSB, SBM_QUERYPOS, 0L, 0L);%@NL@%
            aptl[2].y = vcMaxVSB%@NL@%
                - (LONG) WinSendMsg(vhwndVSB, SBM_QUERYPOS, 0L, 0L);%@NL@%
%@NL@%
            GpiBitBlt(hpsWindow, vhpsMemory, 3L, aptl, ROP_SRCCOPY, 0L);%@NL@%
            GpiSetBitmap(vhpsMemory, NULL);%@NL@%
            break;%@NL@%
%@NL@%
        case CF_METAFILE:%@NL@%
        case CF_DSPMETAFILE:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Set up the alOptions for displaying the metafile, and%@NL@%
%@AB@%                let the system do the rest of the work.%@NL@%
%@AB@%            */%@AE@%%@NL@%
            alOptions[PMF_SEGBASE]            = 0L;%@NL@%
            alOptions[PMF_LOADTYPE]            = LT_DEFAULT;%@NL@%
            alOptions[PMF_RESOLVE]            = 0L;%@NL@%
            alOptions[PMF_LCIDS]            = LC_LOADDISC;%@NL@%
            alOptions[PMF_RESET]            = RES_DEFAULT;%@NL@%
            alOptions[PMF_SUPPRESS]            = SUP_DEFAULT;%@NL@%
            alOptions[PMF_COLORTABLES]            = CTAB_NOMODIFY;%@NL@%
            alOptions[PMF_COLORREALIZABLE]  = CREA_DEFAULT;%@NL@%
            hmfCopy = GpiCopyMetaFile((HMF) hItem);%@NL@%
            GpiPlayMetaFile(hpsWindow, hmfCopy, 8L, alOptions, 0L, 0L, NULL);%@NL@%
            break;%@NL@%
%@NL@%
        case CF_EMPTY:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Don't do anything.%@NL@%
%@AB@%            */%@AE@%%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                If it's an owner-draw format that we can display...%@NL@%
%@AB@%                ...try to get the owner to paint the clipboard.%@NL@%
%@AB@%                (return if we were successful or not)%@NL@%
%@AB@%            */%@AE@%%@NL@%
            fRendered = SendOwnerMsg(WM_PAINTCLIPBOARD, MPFROMHWND(hwnd), 0L);%@NL@%
            break;%@NL@%
      }%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Tell everybody that the client area is valid now%@NL@%
%@AB@%    */%@AE@%%@NL@%
    WinValidateRect(hwnd, (PRECTL) NULL, FALSE);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Clean up%@NL@%
%@AB@%    */%@AE@%%@NL@%
    GpiAssociate(hpsWindow, NULL);%@NL@%
    GpiDestroyPS(hpsWindow);%@NL@%
    WinCloseClipbrd(vhab);%@NL@%
    return fRendered;%@NL@%
}%@NL@%
%@NL@%
BOOL UpdateScreen(HWND hwnd, USHORT usFormat) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Render the format, change the title bar.%@NL@%
%@AB@%    The title bar will look like:  "<appname> (<format>)"%@NL@%
%@AB@%*/%@AE@%%@NL@%
    BOOL  fRendered = TRUE;%@NL@%
    HPS   hpsWindow;%@NL@%
    RECTL rcl;%@NL@%
    UCHAR szFormat[MAXLEN];%@NL@%
    UCHAR szTitle[MAXTITLELEN];%@NL@%
%@NL@%
    if (vfUpdate) {%@NL@%
        %@AB@%/* If the MLE exists, destroy it */%@AE@%%@NL@%
        if (vhwndMLE) {%@NL@%
            WinDestroyWindow(vhwndMLE);%@NL@%
            vhwndMLE = NULL;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* Clear the client area */%@AE@%%@NL@%
        WinQueryWindowRect(hwnd, &rcl);%@NL@%
        WinInvalidateRect(hwnd, &rcl, FALSE);%@NL@%
        hpsWindow = WinBeginPaint(hwnd, NULL, NULL);%@NL@%
        WinFillRect(hpsWindow, &rcl, CLR_BACKGROUND);%@NL@%
        WinEndPaint(hpsWindow);%@NL@%
    }%@NL@%
    if (usFormat)                        // Check that usFormat != CF_EMPTY%@NL@%
        fRendered = RenderFormat(hwnd, usFormat);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Set the title bar appropriately%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (!vhwndTitlebar && vhwndClipFrame)%@NL@%
        vhwndTitlebar = WinWindowFromID(vhwndClipFrame, FID_TITLEBAR);%@NL@%
%@NL@%
    if (vhwndTitlebar) {%@NL@%
        GetFormatName(usFormat, szFormat);%@NL@%
        LOADSTRING(IDS_APPNAME, szTitle);%@NL@%
        strcat(szTitle, "("); strcat(szTitle, szFormat); strcat(szTitle, ")");%@NL@%
        WinSetWindowText(vhwndTitlebar, szTitle);%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Save the rendered format.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    vusFormat = usFormat;%@NL@%
    return fRendered;%@NL@%
}%@NL@%
%@NL@%
VOID GetAllFormats(VOID) {%@NL@%
    USHORT usFormat;                // Temporary used when enumerating%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Put ourselves into a clean state%@NL@%
%@AB@%    */%@AE@%%@NL@%
    usFormat = vcFmts = 0;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Cycle through the available clipboard formats%@NL@%
%@AB@%    */%@AE@%%@NL@%
    while (usFormat = WinEnumClipbrdFmts(vhab, usFormat)) {%@NL@%
        vausFormats[vcFmts++] = usFormat;%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Set the current clipboard format to the first one, if possible%@NL@%
%@AB@%        (in preparation for the WM_PAINT which will follow).%@NL@%
%@AB@%    */%@AE@%%@NL@%
    vusFormat = (vcFmts ? vausFormats[0] : CF_EMPTY);%@NL@%
}%@NL@%
%@NL@%
VOID GetFormatName(USHORT usFormat, UCHAR szFmtName[]) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    GetFormatName()%@NL@%
%@AB@%%@NL@%
%@AB@%    This routine returns a format name in szFmtName which corresponds%@NL@%
%@AB@%    to the format usFormat.  Basically, either we know the format, or%@NL@%
%@AB@%    we get the name from the system atom table.  If we can't find it,%@NL@%
%@AB@%    we set it to CF_UNKNOWN.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    switch (usFormat) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            If we know the format, we can read it from the string table.%@NL@%
%@AB@%        */%@AE@%%@NL@%
        case CF_EMPTY:%@NL@%
        case CF_TEXT:%@NL@%
        case CF_DSPTEXT:%@NL@%
        case CF_BITMAP:%@NL@%
        case CF_DSPBITMAP:%@NL@%
        case CF_METAFILE:%@NL@%
        case CF_DSPMETAFILE:%@NL@%
            LOADSTRING(usFormat, szFmtName);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Get the format name from the system atom table.%@NL@%
%@AB@%                If not found, tag it as an unknown format.%@NL@%
%@AB@%            */%@AE@%%@NL@%
            if (!WinQueryAtomName(WinQuerySystemAtomTable(),%@NL@%
                   usFormat, szFmtName, MAXLEN))%@NL@%
%@NL@%
                LOADSTRING(CF_UNKNOWN, szFmtName);%@NL@%
%@NL@%
            break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
BOOL SendOwnerMsg(USHORT msg, MPARAM mp1, MPARAM mp2) {%@NL@%
    BOOL    rc;%@NL@%
    HWND    hwndOwner;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        If we are an OWNERDISPLAY format,%@NL@%
%@AB@%            lock the owner window, tell it to perform the operation, return%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if ( rc = ( (vfsFmtInfo & CFI_OWNERDISPLAY)%@NL@%
         && (hwndOwner = WinQueryClipbrdOwner(vhab, TRUE)) ) ) {%@NL@%
%@NL@%
        WinSendMsg(hwndOwner, msg, mp1, mp2);%@NL@%
        WinLockWindow(hwndOwner, FALSE);%@NL@%
    }%@NL@%
    return rc;%@NL@%
}%@NL@%
%@NL@%
BOOL DoScrolling(HWND hwnd, BOOL fHorz, USHORT sbCmd) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    This routine depends on the fact that the thumb cannot be set past the%@NL@%
%@AB@%    range of the scroll bar.  Since this is handled in the system SBM_SETPOS%@NL@%
%@AB@%    code already, we need not worry about it.%@NL@%
%@AB@%%@NL@%
%@AB@%    We return TRUE if the scroll bar message is processed.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    HWND   hwndSB;                %@AB@%/* Scroll bar handle */%@AE@%%@NL@%
    USHORT cpels;                %@AB@%/* Page length/width for PAGExxxx commands */%@AE@%%@NL@%
    SWP    swp;                        %@AB@%/* Dimensions of the client area */%@AE@%%@NL@%
    USHORT usOld;                %@AB@%/* The current scroll bar position */%@AE@%%@NL@%
    USHORT usNew;                %@AB@%/* The new scroll bar position */%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Set the scroll bar-specific parameters%@NL@%
%@AB@%    */%@AE@%%@NL@%
    WinQueryWindowPos(hwnd, &swp);%@NL@%
    if (fHorz) {        %@AB@%/* Horizontal scroll bar */%@AE@%%@NL@%
        hwndSB = vhwndHSB;%@NL@%
        cpels = swp.cx;%@NL@%
    } else {                %@AB@%/* Vertical scroll bar */%@AE@%%@NL@%
        hwndSB = vhwndVSB;%@NL@%
        cpels = swp.cy;%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Handle both scroll bars with one common routine%@NL@%
%@AB@%%@NL@%
%@AB@%        Basically, the scroll bar has been set so that %@NL@%
%@AB@%        the thumb value corresponds to the offset that%@NL@%
%@AB@%        the bitmap is drawn from.  So, to scroll by a%@NL@%
%@AB@%        page, compute the number of pels of the page,%@NL@%
%@AB@%        and move the thumb by that amount.%@NL@%
%@AB@%%@NL@%
%@AB@%        This code is simplified by the fact that SB_SETPOS%@NL@%
%@AB@%        will not allow the thumb to be set outside of the%@NL@%
%@AB@%        range of the scroll bar, but will "stop" it at the%@NL@%
%@AB@%        appropriate bound.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    usOld = SHORT1FROMMR( WinSendMsg(hwndSB, SBM_QUERYPOS, 0L, 0L));%@NL@%
%@NL@%
    switch (sbCmd) {%@NL@%
        case SB_PAGERIGHT:        %@AB@%/* SB_PAGEDOWN */%@AE@%%@NL@%
            WinSendMsg(hwndSB, SBM_SETPOS, MPFROMSHORT(usOld + cpels), 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case SB_PAGELEFT:        %@AB@%/* SB_PAGEUP */%@AE@%%@NL@%
            WinSendMsg(hwndSB, SBM_SETPOS, MPFROMSHORT(usOld - cpels), 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case SB_LINERIGHT:        %@AB@%/* SB_LINEDOWN */%@AE@%%@NL@%
            WinSendMsg(hwndSB, SBM_SETPOS, MPFROMSHORT(usOld + LINE), 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case SB_LINELEFT:        %@AB@%/* SB_LINEUP */%@AE@%%@NL@%
            WinSendMsg(hwndSB, SBM_SETPOS, MPFROMSHORT(usOld - LINE), 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case SB_SLIDERPOSITION:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                It would be nice to be consistent with the other%@NL@%
%@AB@%                SB_ cases, but the problem is that when this message%@NL@%
%@AB@%                is sent, the position is *already* set to "usPosition".%@NL@%
%@AB@%%@NL@%
%@AB@%                So, just invalidate the entire region, and hope that most%@NL@%
%@AB@%                of these types of operations will be large scrolls.%@NL@%
%@AB@%            */%@AE@%%@NL@%
            // WinSendMsg(hwndSB, SBM_SETPOS, MPFROMSHORT(LOUSHORT(mp2)), 0L);%@NL@%
            WinInvalidateRect(hwnd, NULL, TRUE);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Now, we find out where the new thumb position is,%@NL@%
%@AB@%        scroll the window contents appropriately, and specify%@NL@%
%@AB@%        SW_INVALIDATERGN so that the remainder will be%@NL@%
%@AB@%        invalidated/repainted.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    usNew = SHORT1FROMMR( WinSendMsg(hwndSB, SBM_QUERYPOS, 0L, 0L));%@NL@%
    if (fHorz)%@NL@%
        WinScrollWindow(hwnd, (SHORT) (usOld - usNew), 0, %@NL@%
            NULL, NULL, NULL, NULL, SW_INVALIDATERGN);%@NL@%
    else%@NL@%
        WinScrollWindow(hwnd, 0, (SHORT) (usNew - usOld),%@NL@%
            NULL, NULL, NULL, NULL, SW_INVALIDATERGN);%@NL@%
%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CLOCK.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CLOCK\CLOCK.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    clock.c        Presentation Manager Analog Clock Application%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_PM %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"res.h" %@NL@%
%@NL@%
extern MRESULT EXPENTRY ClkWndProc ( HWND , USHORT , MPARAM , MPARAM ) ;%@NL@%
%@NL@%
int cdecl main ( int argc , char * argv [ ] ) ;%@NL@%
BOOL ClkInit ( VOID ) ;%@NL@%
HWND hwndFrame ;%@NL@%
HAB hab ;%@NL@%
HMQ hmq ;%@NL@%
HSWITCH hsw ;%@NL@%
extern HPS hps ;%@NL@%
BOOL fStartAsIcon = FALSE ;%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    main(argc, argv)        Main program%@NL@%
%@AB@%*/%@AE@%%@NL@%
int cdecl main ( int argc , char * argv [ ] )%@NL@%
{%@NL@%
    QMSG qmsg ;%@NL@%
%@NL@%
    %@AB@%/* have we been asked to start ourselves as an icon? */%@AE@%%@NL@%
    if (argc > 0) {%@NL@%
        if ( strcmpi ( argv [ 1 ] , "iconic" ) == 0 )%@NL@%
            fStartAsIcon = TRUE ;%@NL@%
    }%@NL@%
%@NL@%
    if ( ClkInit ( ) ) {%@NL@%
%@NL@%
        while ( WinGetMsg ( hab , & qmsg , NULL , 0 , 0 ) )%@NL@%
            WinDispatchMsg ( hab , & qmsg ) ;%@NL@%
%@NL@%
        %@AB@%/* Clean up code */%@AE@%%@NL@%
        GpiDestroyPS( hps );%@NL@%
        WinRemoveSwitchEntry ( hsw ) ;%@NL@%
        WinDestroyWindow ( hwndFrame ) ;%@NL@%
        WinDestroyMsgQueue ( hmq ) ;%@NL@%
        WinTerminate ( hab ) ;%@NL@%
    }%@NL@%
%@NL@%
    return 0 ;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkInit()                Clock Initialization routine%@NL@%
%@AB@%    Returns TRUE if successful.%@NL@%
%@AB@%*/%@AE@%%@NL@%
BOOL ClkInit ( )%@NL@%
{%@NL@%
    %@AB@%/* application name, switch list info, and frame creation flags */%@AE@%%@NL@%
    static PSZ pszClkName = "Clock" ;%@NL@%
    static SWCNTRL swctl = { 0 , 0 , 0 , 0 , 0 , SWL_VISIBLE ,%@NL@%
                             SWL_JUMPABLE , "Clock" , 0 } ;%@NL@%
    static LONG fcf = FCF_SIZEBORDER | FCF_TITLEBAR | FCF_MINMAX%@NL@%
                      | FCF_SYSMENU ;%@NL@%
%@NL@%
    HWND hwndClient ;%@NL@%
    PID pid ;%@NL@%
    TID tid ;%@NL@%
%@NL@%
    if ( ( hab = WinInitialize ( 0 ) ) == NULL )%@NL@%
        return FALSE ;%@NL@%
%@NL@%
    if ( ( hmq = WinCreateMsgQueue ( hab , 0 ) ) == NULL ) {%@NL@%
        WinTerminate ( hab ) ;%@NL@%
        return FALSE ;%@NL@%
    }%@NL@%
%@NL@%
    if ( ! WinRegisterClass ( hab , pszClkName , ClkWndProc ,%@NL@%
                              CS_SIZEREDRAW , 0 ) ) {%@NL@%
        WinDestroyMsgQueue ( hmq ) ;%@NL@%
        WinTerminate ( hab ) ;%@NL@%
        return FALSE ;%@NL@%
    }%@NL@%
%@NL@%
    hwndFrame = WinCreateStdWindow ( HWND_DESKTOP , ( ULONG ) NULL , & fcf ,%@NL@%
                                     pszClkName , pszClkName , WS_VISIBLE ,%@NL@%
                                     (HMODULE) NULL , ID_RESOURCE , & hwndClient ) ;%@NL@%
%@NL@%
    if ( hwndFrame == NULL ) {%@NL@%
        WinDestroyMsgQueue ( hmq ) ;%@NL@%
        WinTerminate ( hab ) ;%@NL@%
        return FALSE ;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* add ourselves to the switch list */%@AE@%%@NL@%
    WinQueryWindowProcess ( hwndFrame , & pid , & tid ) ;%@NL@%
    swctl . hwnd = hwndFrame ;%@NL@%
    swctl . idProcess = pid ;%@NL@%
    hsw = WinAddSwitchEntry ( & swctl ) ;%@NL@%
%@NL@%
    return TRUE ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%COMPORT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\COMTALK\COMPORT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%   comport.c -- This file contains the sources for COM port manipulation.%@NL@%
%@AB@%   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@% INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%        INCL_DOSDEVICES %@NL@%
%@AI@%#define %@AE@%        INCL_DOSDEVIOCTL %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"global.h" %@NL@%
%@AI@%#include %@AE@%"comport.h" %@NL@%
%@AB@%/*%@NL@%
%@AB@%   Constants%@NL@%
%@AB@%*/%@AE@%%@NL@%
       XON        0x11        %@AB@%/* Ctrl Q */%@AE@%%@NL@%
       XOFF        0x13        %@AB@%/* Ctrl S */%@AE@%%@NL@%
char        CRLF[2] = { 0x0d, 0x0a };%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Variables%@NL@%
%@AB@%*/%@AE@%%@NL@%
DCBINFO                dcbinfo;        %@AB@%/* Device control block for Ioctl 53H, 73H */%@AE@%%@NL@%
HFILE                hPort;%@NL@%
LINECONTROL        lnctlBuf;%@NL@%
int                rc;%@NL@%
USHORT                usErrWord;%@NL@%
%@NL@%
int ComFlush(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Flush the COM port with Category 11 functions%@NL@%
%@AB@%*/%@AE@%%@NL@%
    BYTE Data, Zero = 0;%@NL@%
%@NL@%
    %@AB@%/* Call Category 11 Functions 1H, 2H  Flush Input, Output Buffers */%@AE@%%@NL@%
    if (rc = DosDevIOCtl(&Data, &Zero, 0x01, 11, hPort)) return rc;%@NL@%
    if (rc = DosDevIOCtl(&Data, &Zero, 0x02, 11, hPort)) return rc;%@NL@%
    return 0;%@NL@%
}%@NL@%
%@NL@%
int ComInit(COM comTerm) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Open the COM port according to the specifications%@NL@%
%@AB@%*/%@AE@%%@NL@%
    USHORT action;%@NL@%
%@NL@%
    %@AB@%/* Get File Handle for COM port (shared read/write access) */%@AE@%%@NL@%
    if (rc = DosOpen(comTerm.szPort,&hPort, &action, 0L, 0, 0x0001, 0x0042, 0L))%@NL@%
        return rc;%@NL@%
%@NL@%
    %@AB@%/* Call Category 1 Function 41H   Set Baud Rate */%@AE@%%@NL@%
    if (rc = DosDevIOCtl(NULL, &comTerm.usBaud, 0x41, 1, hPort)) return rc;%@NL@%
%@NL@%
    %@AB@%/* Call Category 1 Function 42H   Set Line Characteristics */%@AE@%%@NL@%
    lnctlBuf.bDataBits        = comTerm.bData;%@NL@%
    lnctlBuf.bParity        = comTerm.bParity;%@NL@%
    lnctlBuf.bStopBits        = (BYTE) (comTerm.bStop - 20);        %@AB@%/* IDD_ONESTOP = 20 */%@AE@%%@NL@%
    if (rc = DosDevIOCtl(NULL, &lnctlBuf, 0x42, 1, hPort)) return rc;%@NL@%
%@NL@%
    %@AB@%/* Call Category 1 Function 73H   Query Device Control Block */%@AE@%%@NL@%
    if (rc = DosDevIOCtl(&dcbinfo, 0L, 0x73, 1, hPort)) return rc;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Do we want software handshaking?%@NL@%
%@AB@%    */%@AE@%%@NL@%
    dcbinfo.fbFlowReplace        &= ~(0x03);        %@AB@%/* Clear bits 0 and 1 */%@AE@%%@NL@%
    dcbinfo.fbFlowReplace        |=%@NL@%
        (comTerm.fSoftware)        ? (MODE_AUTO_TRANSMIT | MODE_AUTO_RECEIVE) : 0;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Do we want hardware handshaking?%@NL@%
%@AB@%    */%@AE@%%@NL@%
    %@AB@%/* Turn on DTR, if appropriate */%@AE@%%@NL@%
    dcbinfo.fbCtlHndShake        &= ~(0x03);        %@AB@%/* Clear bits 0 and 1 */%@AE@%%@NL@%
    dcbinfo.fbCtlHndShake        |= ((comTerm.fHardware) ? MODE_DTR_CONTROL : 0);%@NL@%
%@NL@%
    %@AB@%/* Turn on RTS, if appropriate */%@AE@%%@NL@%
    dcbinfo.fbFlowReplace        &= ~(0xc0);        %@AB@%/* Clear bits 6 and 7 */%@AE@%%@NL@%
    dcbinfo.fbFlowReplace        |= ((comTerm.fHardware) ? MODE_RTS_CONTROL : 0);%@NL@%
%@NL@%
    %@AB@%/* Adjust CTS output handshaking */%@AE@%%@NL@%
    dcbinfo.fbCtlHndShake        &= ~MODE_CTS_HANDSHAKE;     %@AB@%/* Clear bit 3 */%@AE@%%@NL@%
    dcbinfo.fbCtlHndShake        |= ((comTerm.fHardware)?MODE_CTS_HANDSHAKE:0);%@NL@%
%@NL@%
    %@AB@%/* Adjust DSR output handshaking */%@AE@%%@NL@%
    dcbinfo.fbCtlHndShake        &= ~MODE_DSR_HANDSHAKE;     %@AB@%/* Clear bit 4 */%@AE@%%@NL@%
    dcbinfo.fbCtlHndShake        |= ((comTerm.fHardware)?MODE_DSR_HANDSHAKE:0);%@NL@%
%@NL@%
    %@AB@%/* Turn off DCD output handshaking */%@AE@%%@NL@%
    dcbinfo.fbCtlHndShake        &= ~MODE_DCD_HANDSHAKE;     %@AB@%/* Clear bit 5 */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Adjust DSR input sensitivity */%@AE@%%@NL@%
    dcbinfo.fbCtlHndShake        &= ~MODE_DSR_SENSITIVITY;   %@AB@%/* Clear bit 6 */%@AE@%%@NL@%
    dcbinfo.fbCtlHndShake        |= ((comTerm.fHardware)?MODE_DSR_SENSITIVITY:0);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Set the line to Wait for Character, Read mode%@NL@%
%@AB@%    */%@AE@%%@NL@%
    dcbinfo.fbTimeout                &= ~(0x06);        %@AB@%/* Clear bits, then set */%@AE@%%@NL@%
    dcbinfo.fbTimeout                |= MODE_WAIT_READ_TIMEOUT;%@NL@%
    dcbinfo.usReadTimeout        = -1;                %@AB@%/* Never! */%@AE@%%@NL@%
 %@NL@%
    %@AB@%/* Call Category 1 Function 53H   Set Device Control Block */%@AE@%%@NL@%
    if (rc = DosDevIOCtl(0L, &dcbinfo, 0x53, 1, hPort)) return rc;%@NL@%
%@NL@%
    %@AB@%/* Get ready to start */%@AE@%%@NL@%
    return ComFlush();%@NL@%
}%@NL@%
%@NL@%
USHORT ComRead(Line pli) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Reads all characters present%@NL@%
%@AB@%    Returns:        0 if successful%@NL@%
%@AB@%                nonzero (Dos Error or Com Error Word) if unsuccessful%@NL@%
%@AB@%*/%@AE@%%@NL@%
    %@AB@%/* Read from the port... And snatch as many as you can! (blocking read) */%@AE@%%@NL@%
    if (rc = DosRead(hPort, pli->szText, MAXLINELEN, &(pli->cch))) return rc;%@NL@%
%@NL@%
    %@AB@%/* Check the COM Error Word */%@AE@%%@NL@%
    if (rc = DosDevIOCtl(&usErrWord, NULL, 0x6d, 1, hPort)) return rc;%@NL@%
%@NL@%
    %@AB@%/* ...then return it */%@AE@%%@NL@%
    return usErrWord;%@NL@%
}%@NL@%
%@NL@%
int ComWrite(char ch) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Write a character at a time%@NL@%
%@AB@%%@NL@%
%@AB@%    Okay as long as you don't type too fast%@NL@%
%@AB@%*/%@AE@%%@NL@%
    USHORT nCharsWritten;%@NL@%
%@NL@%
    return DosWrite(hPort, &ch, 1, &nCharsWritten);%@NL@%
}%@NL@%
%@NL@%
int ComClose(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Close the COM port%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (rc = ComFlush()) return rc;%@NL@%
    return DosClose(hPort);%@NL@%
} %@NL@%
%@NL@%
int ComBreak(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Set BREAK mode ON%@NL@%
%@AB@%*/%@AE@%%@NL@%
    USHORT ComErr;%@NL@%
%@NL@%
    %@AB@%/* Call Category 1 Function 4BH -- Set Break On */%@AE@%%@NL@%
    return DosDevIOCtl(&ComErr, NULL, 0x4b, 1, hPort);%@NL@%
}%@NL@%
%@NL@%
int ComUnbreak(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Set BREAK mode OFF%@NL@%
%@AB@%*/%@AE@%%@NL@%
    USHORT ComErr;%@NL@%
%@NL@%
    %@AB@%/* Call Category 1 Function 45H -- Set Break Off */%@AE@%%@NL@%
    return DosDevIOCtl(&ComErr, NULL, 0x45, 1, hPort);%@NL@%
}%@NL@%
%@NL@%
int ComError(void) { return (int) usErrWord; }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%COMTALK.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\COMTALK\COMTALK.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%   comtalk.c -- Main routines%@NL@%
%@AB@%   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%%@NL@%
%@AB@%   This file contains the sources for the dialog box manipulation, and menu%@NL@%
%@AB@%   managment, and other aspects of interfacing with the user.%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
"comtalk.h"        %@AB@%/* definition of COM from Global, and Resource IDs */%@AE@%%@NL@%
"avio.h"        %@AB@%/* Routines needed to manage AVIO Presentation Space */%@AE@%%@NL@%
"threads.h"        %@AB@%/* Thread initialization and control routines */%@AE@%%@NL@%
<stdio.h>        %@AB@%/* Only needed for file I/O */%@AE@%%@NL@%
<string.h>        %@AB@%/* one strcpy call */%@AE@%%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Variables%@NL@%
%@AB@%*/%@AE@%%@NL@%
CHAR                 szCaption[] = "";%@NL@%
HAB                hAB;%@NL@%
COM                comTerm;%@NL@%
COM                comTemp;%@NL@%
HWND                hWndMenu;%@NL@%
CLASSINFO        clsi;%@NL@%
PFNWP                pfnOldFrameWndProc;%@NL@%
BOOL                fConnected        = FALSE;%@NL@%
BOOL                fPaging;%@NL@%
int                iUpdate;%@NL@%
BOOL                fFreeze                = TRUE;%@NL@%
int                iError;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Macros%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%InRange(x, a, b) ((x >= a) && (x <= b)) %@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Shorthand for sending messages, querying%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%Parent(h) \ %@NL@%
    WinQueryWindow(h, QW_PARENT, FALSE)%@NL@%
%@NL@%
%@AI@%#define %@AE@%EnableMenuItem(id) \ %@NL@%
    WinSendMsg(hWndMenu, MM_SETITEMATTR, MPFROM2SHORT(id, TRUE), \%@NL@%
               MPFROM2SHORT(MIA_DISABLED,0))%@NL@%
%@NL@%
%@AI@%#define %@AE@%DisableMenuItem(id) \ %@NL@%
    WinSendMsg(hWndMenu, MM_SETITEMATTR, MPFROM2SHORT(id, TRUE), \%@NL@%
               MPFROM2SHORT(MIA_DISABLED, MIA_DISABLED))%@NL@%
%@NL@%
%@AI@%#define %@AE@%CheckMenuItem(id) \ %@NL@%
    WinSendMsg(hWndMenu, MM_SETITEMATTR, MPFROM2SHORT(id, TRUE), \%@NL@%
               MPFROM2SHORT(MIA_CHECKED, MIA_CHECKED)) %@NL@%
%@NL@%
%@AI@%#define %@AE@%UnCheckMenuItem(id) \ %@NL@%
    WinSendMsg(hWndMenu, MM_SETITEMATTR, MPFROM2SHORT(id, TRUE), \%@NL@%
               MPFROM2SHORT(MIA_CHECKED, 0))%@NL@%
%@NL@%
%@AI@%#define %@AE@%PushButton(h, id) \ %@NL@%
    WinSendDlgItemMsg(h, id, BM_SETCHECK, MPFROM2SHORT(TRUE, 0), 0L) %@NL@%
%@NL@%
%@AI@%#define %@AE@%Valid(bData, bStop) \ %@NL@%
    (((bData == IDD_FIVE) && (bStop != IDD_TWOSTOP)) \%@NL@%
    || ((bData != IDD_FIVE) && (bStop != IDD_ONEFIVE)))%@NL@%
%@NL@%
%@AI@%#define %@AE@%ErrMsg(h, s) \ %@NL@%
    WinMessageBox(HWND_DESKTOP, h, s, NULL, 0, MB_OK | MB_ICONEXCLAMATION)%@NL@%
%@NL@%
char Ctrl(char ch) {%@NL@%
    return  (CHAR) ((('a' <= ch) && (ch <= 'z')) ?  (ch - 'a' + '\001') :%@NL@%
          ((('A' <= ch) && (ch <= 'Z')) ? (ch - 'A' + '\001') : ch));%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Local/Private routines%@NL@%
%@AB@%*/%@AE@%%@NL@%
void ReadOpts(HWND);%@NL@%
void InitTerm(void);%@NL@%
void Initialize(HWND);%@NL@%
void ChangeSystemMenu(HWND);%@NL@%
BOOL Filter(USHORT, char, USHORT);%@NL@%
%@NL@%
void main (void) {%@NL@%
     static CHAR szClientClass[] = "Terminal";%@NL@%
     HMQ        hmq;%@NL@%
     HWND        hWndClient, hWndFrame;%@NL@%
     QMSG        qmsg;%@NL@%
     ULONG        flFrameFlags = FCF_STANDARD | FCF_HORZSCROLL | FCF_VERTSCROLL;%@NL@%
     ULONG         flFrameStyle = WS_VISIBLE | FS_SCREENALIGN;%@NL@%
     %@NL@%
     hAB = WinInitialize(0);%@NL@%
     hmq = WinCreateMsgQueue(hAB, 0);%@NL@%
%@NL@%
     WinRegisterClass(hAB, szClientClass, ClientWndProc, CS_SYNCPAINT, 0);%@NL@%
%@NL@%
     hWndFrame = WinCreateStdWindow(HWND_DESKTOP, flFrameStyle,%@NL@%
                                    &flFrameFlags, szClientClass, szCaption,%@NL@%
                                     0L, (HMODULE) NULL, ID_RESOURCE, &hWndClient);%@NL@%
%@NL@%
     %@AB@%/* Setup AVIO PS and force a paint */%@AE@%%@NL@%
     AvioInit(hWndFrame, hWndClient);%@NL@%
     WinSendMsg(hWndClient, WM_PAINT, NULL, NULL);%@NL@%
%@NL@%
     %@AB@%/* Try to subclass the Frame window... */%@AE@%%@NL@%
     pfnOldFrameWndProc = WinSubclassWindow(hWndFrame, NewFrameWndProc);%@NL@%
%@NL@%
     while (WinGetMsg(hAB, &qmsg, NULL, 0, 0)) WinDispatchMsg(hAB, &qmsg);%@NL@%
%@NL@%
     %@AB@%/* Blast the AVIO PS */%@AE@%%@NL@%
     AvioClose();%@NL@%
%@NL@%
     WinDestroyWindow(hWndFrame);%@NL@%
     WinDestroyMsgQueue(hmq);%@NL@%
     WinTerminate(hAB);%@NL@%
     DosExit(EXIT_PROCESS, 0);%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK ClientWndProc(HWND hWnd, USHORT msg, MPARAM mp1, MPARAM mp2) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%     Window Procedure which traps messages to the Client area%@NL@%
%@AB@%*/%@AE@%%@NL@%
     switch (msg) {%@NL@%
          case WM_AVIOUPDATE:%@NL@%
                fNoUpdate = AvioUpdateLines(FALSE, &fPaging);%@NL@%
                if (fConnected && fPaging) {%@NL@%
                    CheckMenuItem(IDM_PAGING);%@NL@%
                }%@NL@%
                break;%@NL@%
%@NL@%
          case WM_MSGBOX:%@NL@%
                iUpdate = (int)SHORT1FROMMP( mp2);%@NL@%
                switch ((int)SHORT1FROMMP(mp1)) {%@NL@%
                    case (int) MBE_COMREAD:%@NL@%
                        if (iError = iUpdate) EnableMenuItem(IDM_ERRORS);%@NL@%
                        iUpdate = 0;%@NL@%
                        break;%@NL@%
%@NL@%
                    default:%@NL@%
                        ErrMsg(hWnd, aszMessage[SHORT1FROMMP(mp1)]);%@NL@%
                        break;%@NL@%
                }%@NL@%
                if (iUpdate) {        %@AB@%/* Page down because queue is full */%@AE@%%@NL@%
                    fNoUpdate = AvioUpdateLines(TRUE, &fPaging);%@NL@%
                    if (fConnected && fPaging) CheckMenuItem(IDM_PAGING);%@NL@%
                    else UnCheckMenuItem(IDM_PAGING);%@NL@%
                    ThdReset();%@NL@%
                }%@NL@%
                break;%@NL@%
%@NL@%
          case WM_CREATE:%@NL@%
                ChangeSystemMenu(hWnd);%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Initialize the Dialog Options%@NL@%
%@AB@%                */%@AE@%%@NL@%
                Initialize(hWnd);%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Get the Handle so you can enable/disable menu items%@NL@%
%@AB@%                    Thanks again to Charles Petzold%@NL@%
%@AB@%                */%@AE@%%@NL@%
                hWndMenu = WinWindowFromID(Parent(hWnd), FID_MENU);%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    Disable some entries (can do this in the resource file)%@NL@%
%@AB@%                */%@AE@%%@NL@%
                DisableMenuItem(IDM_CLOSE);%@NL@%
                DisableMenuItem(IDM_BREAK);%@NL@%
                DisableMenuItem(IDM_COMMANDMENU);%@NL@%
                break;%@NL@%
%@NL@%
          case WM_PAINT:                %@AB@%/* Paint the AVIO way! */%@AE@%%@NL@%
                AvioPaint(hWnd);%@NL@%
                break;%@NL@%
%@NL@%
          case WM_SIZE:                        %@AB@%/* Size the AVIO way!  */%@AE@%%@NL@%
                fNoUpdate = AvioUpdateLines(FALSE, &fPaging);%@NL@%
                if (fConnected && fPaging) {%@NL@%
                    CheckMenuItem(IDM_PAGING);%@NL@%
                }%@NL@%
                return AvioSize(hWnd, msg, mp1, mp2);%@NL@%
                break;%@NL@%
%@NL@%
          case WM_HSCROLL:%@NL@%
                AvioScroll(HIUSHORT(mp2), LOUSHORT(mp2), TRUE);%@NL@%
                break;%@NL@%
%@NL@%
          case WM_VSCROLL:%@NL@%
                AvioScroll(HIUSHORT(mp2), LOUSHORT(mp2), FALSE);%@NL@%
                break;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
                return 0;%@NL@%
                break;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
                switch (COMMANDMSG(&msg)->cmd) {%@NL@%
                    case IDM_ABOUT:%@NL@%
                        WinDlgBox(HWND_DESKTOP, hWnd, AboutDlgProc,%@NL@%
                                  (HMODULE) NULL, IDD_ABOUT, NULL);%@NL@%
                        return 0;%@NL@%
%@NL@%
                    case IDM_HELP:%@NL@%
                        WinDlgBox(HWND_DESKTOP, hWnd, AboutDlgProc,%@NL@%
                                  (HMODULE) NULL, IDD_MAINHELPBOX, NULL);%@NL@%
                        return 0;%@NL@%
%@NL@%
                    case IDM_SETTINGS:%@NL@%
                        WinDlgBox(HWND_DESKTOP, hWnd, SetDlgProc,%@NL@%
                                  (HMODULE) NULL, IDD_SET, NULL);%@NL@%
                        return 0;%@NL@%
%@NL@%
                    case IDM_CONNECT:%@NL@%
                        AvioStartup(hWnd);%@NL@%
                        ThdInitialize(hWnd, comTerm);        %@AB@%/* Spawn 3 threads  */%@AE@%%@NL@%
                        %@AB@%/*%@NL@%
%@AB@%                            Disable/Enable Menu Items%@NL@%
%@AB@%                        */%@AE@%%@NL@%
                        DisableMenuItem(IDM_CONNECT);%@NL@%
                        DisableMenuItem(IDM_SETTINGS);%@NL@%
                        DisableMenuItem(IDM_ERRORS);%@NL@%
%@NL@%
                        EnableMenuItem(IDM_CLOSE);%@NL@%
                        EnableMenuItem(IDM_BREAK);%@NL@%
                        EnableMenuItem(IDM_COMMANDMENU);%@NL@%
                        fConnected = TRUE;%@NL@%
                        return 0;%@NL@%
%@NL@%
                    case IDM_CLOSE:%@NL@%
                        fConnected = FALSE;%@NL@%
                        ThdTerminate();                %@AB@%/* Might have to wait? */%@AE@%%@NL@%
                        %@AB@%/*%@NL@%
%@AB@%                            Update menu items%@NL@%
%@AB@%                        */%@AE@%%@NL@%
                        UnCheckMenuItem(IDM_BREAK);%@NL@%
%@NL@%
                        DisableMenuItem(IDM_CLOSE);%@NL@%
                        DisableMenuItem(IDM_BREAK);%@NL@%
                        DisableMenuItem(IDM_COMMANDMENU);%@NL@%
%@NL@%
                        EnableMenuItem(IDM_CONNECT);%@NL@%
                        EnableMenuItem(IDM_SETTINGS);%@NL@%
%@NL@%
                        return 0;%@NL@%
%@NL@%
                    case IDM_BREAK:%@NL@%
                        ThdDoBreak();%@NL@%
                        return 0;%@NL@%
%@NL@%
                    case IDM_ERRORS:%@NL@%
                        if (iError & 1)%@NL@%
                            ErrMsg(hWnd, "Receive Queue Overrun");%@NL@%
                        if (iError & 2)%@NL@%
                            ErrMsg(hWnd, "Receive Hardware Overrun");%@NL@%
                        if (iError & 4)%@NL@%
                            ErrMsg(hWnd, "Parity Error");%@NL@%
                        if (iError & 8)%@NL@%
                            ErrMsg(hWnd, "Framing Error");%@NL@%
                        DisableMenuItem(IDM_ERRORS);%@NL@%
                        return 0;%@NL@%
%@NL@%
                    case IDM_PAGE:%@NL@%
                        fNoUpdate = AvioUpdateLines(TRUE, &fPaging);%@NL@%
                        if (fPaging) CheckMenuItem(IDM_PAGING);%@NL@%
                        else UnCheckMenuItem(IDM_PAGING);%@NL@%
                        return 0;%@NL@%
%@NL@%
                    case IDM_UP:%@NL@%
                        AvioPageUp();%@NL@%
                        return 0;%@NL@%
%@NL@%
                    case IDM_PAGING:%@NL@%
                        if (fPaging = !fPaging) {%@NL@%
                            CheckMenuItem(IDM_PAGING);%@NL@%
                        } else {%@NL@%
                            UnCheckMenuItem(IDM_PAGING);%@NL@%
                        }%@NL@%
                        return 0;%@NL@%
%@NL@%
                    default: return 0;%@NL@%
                }%@NL@%
%@NL@%
          case WM_CHAR:                %@AB@%/* Put characters in typeahead buffer */%@AE@%%@NL@%
                if (fConnected && !(CHARMSG(&msg)->fs & KC_KEYUP)) %@NL@%
                    if (Filter( CHARMSG(&msg)->fs,%@NL@%
                         (char)        CHARMSG(&msg)->chr,%@NL@%
                                CHARMSG(&msg)->vkey))%@NL@%
                        ErrMsg(hWnd, "Error Writing COM Port");%@NL@%
                break;%@NL@%
%@NL@%
          case WM_TRACKFRAME:%@NL@%
                AvioTrackFrame(hWnd, mp1);%@NL@%
                break;%@NL@%
%@NL@%
          case WM_MINMAXFRAME: %@AB@%/* Trap MAXIMIZE messages */%@AE@%%@NL@%
                AvioMinMax((PSWP) mp1);%@NL@%
%@NL@%
          default: return WinDefWindowProc(hWnd, msg, mp1, mp2);%@NL@%
     }%@NL@%
     return 0;%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK AboutDlgProc(HWND hDlg, USHORT msg, MPARAM mp1, MPARAM mp2) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Dialog box control for the ABOUT COMTALK... dialog box%@NL@%
%@AB@%*/%@AE@%%@NL@%
    switch(msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case DID_OK: WinDismissDlg(hDlg, TRUE); break;%@NL@%
                default: break;%@NL@%
            }%@NL@%
        default: return WinDefDlgProc(hDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
void WriteOpts(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Write Settings to file COMTALK.INI%@NL@%
%@AB@%*/%@AE@%%@NL@%
    FILE *fp;%@NL@%
%@NL@%
    fp = fopen("comtalk.ini", "w+");%@NL@%
    fprintf(fp, "%d %d %d %d %d %d %d %s\n", comTerm.usBaud, comTerm.bParity,%@NL@%
                comTerm.bData, comTerm.bStop, comTerm.fWrap,%@NL@%
                comTerm.fHardware, comTerm.fSoftware, comTerm.szPort);%@NL@%
    fclose(fp);%@NL@%
}%@NL@%
%@NL@%
void ReadOpts(HWND hWnd) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Read Settings from COMTALK.INI%@NL@%
%@AB@%*/%@AE@%%@NL@%
    FILE *fp;%@NL@%
%@NL@%
    %@AB@%/* Use InitTerm() if we have reading problems */%@AE@%%@NL@%
    if ((fp = fopen("comtalk.ini", "r")) == NULL) InitTerm();%@NL@%
    else if (fscanf(fp, "%d%d%d%d%d%d%d%s", &comTerm.usBaud, &comTerm.bParity,%@NL@%
        &comTerm.bData, &comTerm.bStop, &comTerm.fWrap,%@NL@%
        &comTerm.fHardware, &comTerm.fSoftware, comTerm.szPort) == EOF)%@NL@%
        InitTerm();%@NL@%
    if (!Valid(comTerm.bData, comTerm.bStop)) {%@NL@%
        ErrMsg(hWnd, "Invalid terminal setting");%@NL@%
        InitTerm();%@NL@%
    }%@NL@%
    fclose(fp);%@NL@%
}%@NL@%
%@NL@%
void InitTerm(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Initialize the TERM structure to DosDevIOCtl defaults%@NL@%
%@AB@%*/%@AE@%%@NL@%
    strcpy(comTerm.szPort, "com1");%@NL@%
    comTerm.usBaud = 9600; comTerm.bParity = IDD_EVENP;%@NL@%
    comTerm.bData = IDD_SEVEN; comTerm.bStop = IDD_ONESTOP;%@NL@%
    comTerm.fWrap = comTerm.fSoftware = TRUE; comTerm.fHardware = FALSE;%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK SetDlgProc(HWND hDlg, USHORT msg, MPARAM mp1, MPARAM mp2) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    The Settings Dialog Box control routine%@NL@%
%@AB@%*/%@AE@%%@NL@%
    BOOL        rc;%@NL@%
    BYTE        bTemp;%@NL@%
%@NL@%
    switch(msg) {%@NL@%
        case WM_INITDLG:%@NL@%
            WinSetDlgItemText(hDlg, IDD_PORT, comTerm.szPort);%@NL@%
            WinSetDlgItemShort(hDlg, IDD_BAUD, comTerm.usBaud, FALSE);%@NL@%
%@NL@%
            PushButton(hDlg, comTerm.bParity);%@NL@%
            PushButton(hDlg, comTerm.bData);%@NL@%
            PushButton(hDlg, comTerm.bStop);%@NL@%
            if (comTerm.fWrap) PushButton(hDlg, IDD_WRAP);%@NL@%
            if (comTerm.fHardware) PushButton(hDlg, IDD_HW);%@NL@%
            if (comTerm.fSoftware) PushButton(hDlg, IDD_SW);%@NL@%
%@NL@%
            comTemp.bParity        = comTerm.bParity;%@NL@%
            comTemp.bData        = comTerm.bData;%@NL@%
            comTemp.bStop        = comTerm.bStop;%@NL@%
            comTemp.fWrap        = comTerm.fWrap;%@NL@%
            comTemp.fHardware        = comTerm.fHardware;%@NL@%
            comTemp.fSoftware   = comTerm.fSoftware;%@NL@%
            break; %@NL@%
%@NL@%
        case WM_HELP:%@NL@%
            WinDlgBox(HWND_DESKTOP, hDlg, AboutDlgProc,%@NL@%
                      (HMODULE) NULL, IDD_SETHELPBOX, NULL);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_CONTROL:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                The fact that these are AutoRadioButtons makes life easy.%@NL@%
%@AB@%            */%@AE@%%@NL@%
            bTemp = (BYTE) SHORT1FROMMP(mp1);        %@AB@%/* Which button pushed? */%@AE@%%@NL@%
            if InRange(bTemp, IDD_NOP, IDD_SPACEP) %@NL@%
                 { %@NL@%
                        comTemp.bParity = bTemp; %@NL@%
            } %@NL@%
                else %@NL@%
                {%@NL@%
                        if InRange(bTemp, IDD_FIVE, IDD_EIGHT) %@NL@%
                        {%@NL@%
                                comTemp.bData = bTemp;%@NL@%
                    } %@NL@%
                        else %@NL@%
                        {%@NL@%
                                if InRange(bTemp, IDD_ONESTOP, IDD_TWOSTOP) %@NL@%
                                {%@NL@%
                                        comTemp.bStop = bTemp;%@NL@%
                                }%@NL@%
                             else %@NL@%
                                {%@NL@%
                                        switch (bTemp) {%@NL@%
                                        case IDD_WRAP: comTemp.fWrap     = !comTemp.fWrap;     break;%@NL@%
                                        case IDD_HW  : comTemp.fHardware = !comTemp.fHardware; break;%@NL@%
                                        case IDD_SW  : comTemp.fSoftware = !comTemp.fSoftware; break;%@NL@%
                                        default:                                               break;%@NL@%
                                    }%@NL@%
                                }%@NL@%
                        }%@NL@%
                }%@NL@%
            break;%@NL@%
        case WM_COMMAND:        %@AB@%/* Ready to exit... */%@AE@%%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case IDD_SAVE:%@NL@%
                case DID_OK:%@NL@%
                    if (!Valid(comTemp.bData, comTemp.bStop)) {%@NL@%
                        ErrMsg(hDlg,"Data and Stop Bits Incompatible");%@NL@%
                        break;        %@AB@%/* No-op...Dialog not dismissed */%@AE@%%@NL@%
                    }%@NL@%
                    WinQueryDlgItemText(hDlg, IDD_PORT, 5, comTerm.szPort);%@NL@%
                    WinQueryDlgItemShort(hDlg, IDD_BAUD, &comTerm.usBaud, rc);%@NL@%
                    comTerm.bParity        = comTemp.bParity;%@NL@%
                    comTerm.bData        = comTemp.bData;%@NL@%
                    comTerm.bStop        = comTemp.bStop;%@NL@%
                    comTerm.fWrap        = comTemp.fWrap;%@NL@%
                    comTerm.fHardware        = comTemp.fHardware;%@NL@%
                    comTerm.fSoftware        = comTemp.fSoftware;%@NL@%
                    if (COMMANDMSG(&msg)->cmd == IDD_SAVE) WriteOpts();%@NL@%
                case DID_CANCEL: WinDismissDlg(hDlg, FALSE);%@NL@%
                default: break;%@NL@%
            }%@NL@%
            break;%@NL@%
        default: return WinDefDlgProc(hDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
void Initialize(HWND hWnd) {%@NL@%
    ReadOpts(hWnd);%@NL@%
    fPaging = FALSE;%@NL@%
}%@NL@%
%@NL@%
void ChangeSystemMenu(HWND hWnd) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Insert items into the System Menu (with thanks to Charles Petzold)%@NL@%
%@AB@%*/%@AE@%%@NL@%
    static CHAR *x[2] = { NULL, "~About ComTalk..." }; %@AB@%/* Items to add */%@AE@%%@NL@%
    static MENUITEM mi[2] = {        %@AB@%/* The RESOURCE definitions */%@AE@%%@NL@%
        MIT_END, MIS_SEPARATOR, 0x0000, 0, NULL, 0,%@NL@%
        MIT_END, MIS_TEXT, 0x0000, IDM_ABOUT, NULL, 0%@NL@%
    };%@NL@%
    HWND        hSM, hSSM;        %@AB@%/* Menu and submenu handles */%@AE@%%@NL@%
    MENUITEM        miSM;                %@AB@%/* System Menu Menuitem     */%@AE@%%@NL@%
    SHORT        idSM;                %@AB@%/* ID of the System Menu    */%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Get ahold of the system menu%@NL@%
%@AB@%    */%@AE@%%@NL@%
    hSM = WinWindowFromID(Parent(hWnd), FID_SYSMENU);%@NL@%
    idSM = SHORT1FROMMR( WinSendMsg(hSM, MM_ITEMIDFROMPOSITION, NULL, NULL));%@NL@%
    WinSendMsg(hSM, MM_QUERYITEM, MPFROM2SHORT(idSM, FALSE), MPFROMP(&miSM));%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Manipulate the System SubMenu%@NL@%
%@AB@%    */%@AE@%%@NL@%
    hSSM = miSM.hwndSubMenu;%@NL@%
    WinSendMsg(hSSM, MM_INSERTITEM, MPFROMP(mi), MPFROMP(x[0]));%@NL@%
    WinSendMsg(hSSM, MM_INSERTITEM, MPFROMP(mi+1), MPFROMP(x[1]));%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK NewFrameWndProc(HWND hWnd, USHORT msg, MPARAM mp1, MPARAM mp2) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Force the frame to stay small enough%@NL@%
%@AB@%*/%@AE@%%@NL@%
    BOOL rc;                %@AB@%/* Return code for WM_QueryTrackInfo */%@AE@%%@NL@%
%@NL@%
    switch(msg) {%@NL@%
        case WM_ADJUSTWINDOWPOS:        %@AB@%/* Calculate, then show scrollbars */%@AE@%%@NL@%
            AvioAdjustFrame(mp1);%@NL@%
            break;%@NL@%
        case WM_QUERYTRACKINFO:%@NL@%
            rc = (BOOL)SHORT1FROMMR ((*pfnOldFrameWndProc)(hWnd, msg, mp1, mp2));%@NL@%
            AvioQueryTrackInfo((PTRACKINFO) mp2);%@NL@%
            return (MRESULT) rc;%@NL@%
        default: break;%@NL@%
    }%@NL@%
    return (*pfnOldFrameWndProc)(hWnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
BOOL Filter(USHORT fs, char ch, USHORT vkey) {%@NL@%
    BOOL rc = FALSE;%@NL@%
%@NL@%
    if (fs & KC_VIRTUALKEY) {%@NL@%
        switch(vkey) {%@NL@%
            case VK_HOME:%@NL@%
                if (fs & KC_CTRL) rc = ThdPutString("\033[2J",4);%@NL@%
                return (rc || ThdPutString("\033[H", 3));%@NL@%
            case VK_UP:%@NL@%
                return ThdPutString("\033[A", 3);%@NL@%
            case VK_DOWN:%@NL@%
                return ThdPutString("\033[B", 3);%@NL@%
            case VK_RIGHT:%@NL@%
                return ThdPutString("\033[C", 3);%@NL@%
            case VK_LEFT:%@NL@%
                return ThdPutString("\033[D", 3);%@NL@%
            default: break;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (fs & KC_CTRL) {%@NL@%
        switch (ch) {%@NL@%
            case 'l':%@NL@%
            case 'L': AvioRedraw();%@NL@%
            case '\0': return FALSE; break;%@NL@%
            default: ch = Ctrl(ch); break;%@NL@%
        }%@NL@%
    } else {%@NL@%
        switch (ch) {%@NL@%
            case '\0': return FALSE; break;%@NL@%
            default: break;%@NL@%
        }%@NL@%
    }%@NL@%
    return(rc || ThdPutChar(ch));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CPGREP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CPGREP\CPGREP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/* cpgrep - string searches%@NL@%
%@AB@% *%@NL@%
%@AB@% * Created by Microsoft Corp. 1986%@NL@%
%@AB@% *%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%               <os2def.h> %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_DOSSEMAPHORES %@NL@%
%@AI@%#define %@AE@%INCL_DOSQUEUES %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSMISC %@NL@%
%@AI@%#include %@AE@%               <bsedos.h> %@NL@%
%@AI@%#include %@AE@%               <stdio.h> %@NL@%
%@AI@%#include %@AE@%               <fcntl.h> %@NL@%
%@AI@%#include %@AE@%               <ctype.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%       BEGLINE                0x40 %@NL@%
%@AI@%#define %@AE@%       DEBUG                0x08 %@NL@%
%@AI@%#define %@AE@%       ENDLINE                0x80 %@NL@%
%@AI@%#define %@AE@%       FILBUFLEN        (SECTORLEN*30) %@NL@%
%@AI@%#define %@AE@%       FILNAMLEN        80 %@NL@%
%@AI@%#define %@AE@%       INVERT                0x10 %@NL@%
%@AI@%#define %@AE@%       ISCOT                0x0002 %@NL@%
%@AI@%#define %@AE@%       LG2SECLEN        9 %@NL@%
%@AI@%#define %@AE@%       LINELEN                128 %@NL@%
%@AI@%#define %@AE@%       LINENOS                0x04 %@NL@%
%@AI@%#define %@AE@%       LNOLEN                8 %@NL@%
%@AI@%#define %@AE@%       MAXSTRLEN        128 %@NL@%
%@AI@%#define %@AE@%       NAMEONLY        0x02 %@NL@%
%@AI@%#define %@AE@%       OUTBUFLEN        (SECTORLEN*4) %@NL@%
%@AI@%#define %@AE@%       SECTORLEN        (1 << LG2SECLEN) %@NL@%
%@AI@%#define %@AE@%       SHOWNAME        0x01 %@NL@%
%@AI@%#define %@AE@%       STKLEN                256 %@NL@%
%@AI@%#define %@AE@%       TIMER                0x20 %@NL@%
%@AI@%#define %@AE@%       TRTABLEN        256 %@NL@%
%@AI@%#define %@AE@%       s_text(x)        (((char *)(x)) - ((x)->s_must)) %@NL@%
%@NL@%
typedef struct stringnode%@NL@%
  {%@NL@%
    struct stringnode        *s_alt;                %@AB@%/* List of alternates */%@AE@%%@NL@%
    struct stringnode        *s_suf;                %@AB@%/* List of suffixes */%@AE@%%@NL@%
    int                        s_must;                %@AB@%/* Length of portion that must match */%@AE@%%@NL@%
  }%@NL@%
                        STRINGNODE;%@NL@%
%@NL@%
char                        filbuf[(FILBUFLEN + 2)*2];%@NL@%
char                        *bufptr[] = { filbuf, filbuf + FILBUFLEN + 2 };%@NL@%
char                        outbuf[OUTBUFLEN*2];%@NL@%
char                        *obuf[] = { outbuf, outbuf + OUTBUFLEN };%@NL@%
char                        *optr[] = { outbuf, outbuf + OUTBUFLEN };%@NL@%
USHORT                        ocnt[] = { OUTBUFLEN, OUTBUFLEN };%@NL@%
int                        oi = 0;%@NL@%
char                        transtab[TRTABLEN] = { 0 };%@NL@%
STRINGNODE                *stringlist[TRTABLEN/2];%@NL@%
USHORT                        arrc;                %@AB@%/* I/O return code for DosRead */%@AE@%%@NL@%
USHORT                        awrc;                %@AB@%/* I/O return code for DosWrite */%@AE@%%@NL@%
int                        casesen = 1;        %@AB@%/* Assume case-sensitivity */%@AE@%%@NL@%
USHORT                        cbread;         %@AB@%/* Bytes read by DosRead */%@AE@%%@NL@%
USHORT                        cbwrite;        %@AB@%/* Bytes written by DosWrite */%@AE@%%@NL@%
int                        clists = 1;        %@AB@%/* One is first available index */%@AE@%%@NL@%
int                        flags;                %@AB@%/* Flags */%@AE@%%@NL@%
int                        lineno;                %@AB@%/* Current line number */%@AE@%%@NL@%
char                        pmode;                %@AB@%/* Protected mode flag */%@AE@%%@NL@%
LONG                        readdone;        %@AB@%/* Async read done semaphore */%@AE@%%@NL@%
LONG                        readpending;        %@AB@%/* Async read pending semaphore */%@AE@%%@NL@%
int                        status = 1;        %@AB@%/* Assume failure */%@AE@%%@NL@%
char                        *t2buf;                %@AB@%/* Async read buffer */%@AE@%%@NL@%
USHORT                        t2buflen;        %@AB@%/* Async read buffer length */%@AE@%%@NL@%
HFILE                        t2fd;                %@AB@%/* Async read file */%@AE@%%@NL@%
char                        *t3buf;                %@AB@%/* Async write buffer */%@AE@%%@NL@%
USHORT                        t3buflen;        %@AB@%/* Async write buffer length */%@AE@%%@NL@%
HFILE                        t3fd;                %@AB@%/* Async write file */%@AE@%%@NL@%
LONG                        writedone;        %@AB@%/* Async write done semaphore */%@AE@%%@NL@%
LONG                        writepending;        %@AB@%/* Async write pending semaphore */%@AE@%%@NL@%
char                        target[MAXSTRLEN];%@NL@%
                                        %@AB@%/* Last string added */%@AE@%%@NL@%
int                        targetlen;        %@AB@%/* Length of last string added */%@AE@%%@NL@%
%@NL@%
int                        countlines();        %@AB@%/* See CPGREPSB.ASM */%@AE@%%@NL@%
int                        countmatched();        %@AB@%/* See CPGREPSB.ASM */%@AE@%%@NL@%
char                        *findlist();        %@AB@%/* See CPGREPSB.ASM */%@AE@%%@NL@%
char                        *findone();        %@AB@%/* See CPGREPSB.ASM */%@AE@%%@NL@%
void                        flush1buf();        %@AB@%/* See below */%@AE@%%@NL@%
int                        grepbuffer();        %@AB@%/* See below */%@AE@%%@NL@%
int                        revfind();        %@AB@%/* See CPGREPSB.ASM */%@AE@%%@NL@%
void                        write1buf();        %@AB@%/* See below */%@AE@%%@NL@%
char                        *(*find)() = findlist;%@NL@%
void                        (*flush1)() = flush1buf;%@NL@%
int                        (*grep)() = grepbuffer;%@NL@%
void                        (*write1)() = write1buf;%@NL@%
%@NL@%
void                        freenode(x)%@NL@%
register STRINGNODE        *x;                %@AB@%/* Pointer to node to free */%@AE@%%@NL@%
  {%@NL@%
    register STRINGNODE        *y;                %@AB@%/* Pointer to next node in list */%@AE@%%@NL@%
%@NL@%
    while(x != NULL)                        %@AB@%/* While not at end of list */%@AE@%%@NL@%
      {%@NL@%
        if(x->s_suf != NULL) freenode(x->s_suf);%@NL@%
                                        %@AB@%/* Free suffix list */%@AE@%%@NL@%
        y = x;                                %@AB@%/* Save pointer */%@AE@%%@NL@%
        x = x->s_alt;                        %@AB@%/* Move down the list */%@AE@%%@NL@%
        free(y);                        %@AB@%/* Free the node */%@AE@%%@NL@%
      }%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
STRINGNODE                *newnode(s,n)%@NL@%
char                        *s;                %@AB@%/* String */%@AE@%%@NL@%
int                        n;                %@AB@%/* Length of string */%@AE@%%@NL@%
  {%@NL@%
    register STRINGNODE        *new;                %@AB@%/* Pointer to new node */%@AE@%%@NL@%
    char                *t;                %@AB@%/* String pointer */%@AE@%%@NL@%
    char                *malloc();        %@AB@%/* Storage allocator */%@AE@%%@NL@%
%@NL@%
    if((t = malloc(sizeof(STRINGNODE) + n + (n & 1))) == NULL)%@NL@%
      {                                        %@AB@%/* If allocation fails */%@AE@%%@NL@%
        fprintf(stderr,"Out of memory\n");%@NL@%
        DosExit( EXIT_PROCESS, 2);        %@AB@%/* Print error message and die */%@AE@%%@NL@%
      }%@NL@%
    if(n & 1) ++t;                        %@AB@%/* END of string word-aligned */%@AE@%%@NL@%
    strncpy(t,s,n);                        %@AB@%/* Copy string text */%@AE@%%@NL@%
    new = (STRINGNODE *)(t + n);        %@AB@%/* Set pointer to node */%@AE@%%@NL@%
    new->s_alt = NULL;                        %@AB@%/* No alternates yet */%@AE@%%@NL@%
    new->s_suf = NULL;                        %@AB@%/* No suffixes yet */%@AE@%%@NL@%
    new->s_must = n;                        %@AB@%/* Set string length */%@AE@%%@NL@%
    return(new);                        %@AB@%/* Return pointer to new node */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        reallocnode(node,s,n)%@NL@%
register STRINGNODE        *node;                %@AB@%/* Pointer to node */%@AE@%%@NL@%
char                        *s;                %@AB@%/* String */%@AE@%%@NL@%
register int                n;                %@AB@%/* Length of string */%@AE@%%@NL@%
  {%@NL@%
    if(n > node->s_must)                %@AB@%/* If node must grow */%@AE@%%@NL@%
      {%@NL@%
        fprintf(stderr,"Internal error\n");%@NL@%
                                        %@AB@%/* Error message */%@AE@%%@NL@%
        DosExit( EXIT_PROCESS, 2);                          %@AB@%/* Error exit */%@AE@%%@NL@%
      }%@NL@%
    node->s_must = n;                        %@AB@%/* Set new length */%@AE@%%@NL@%
    memcpy(s_text(node),s,n);                %@AB@%/* Copy new text */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        addstring(s,n)%@NL@%
char                        *s;                %@AB@%/* String to add */%@AE@%%@NL@%
int                        n;                %@AB@%/* Length of string */%@AE@%%@NL@%
  {%@NL@%
    register STRINGNODE        *cur;                %@AB@%/* Current string */%@AE@%%@NL@%
    register STRINGNODE        **pprev;        %@AB@%/* Pointer to previous link */%@AE@%%@NL@%
    STRINGNODE                *new;                %@AB@%/* New string */%@AE@%%@NL@%
    int                        i;                %@AB@%/* Index */%@AE@%%@NL@%
    int                        j;                %@AB@%/* Count */%@AE@%%@NL@%
    int                        k;                %@AB@%/* Count */%@AE@%%@NL@%
%@NL@%
    if(n <= 0 || n > 127) return;        %@AB@%/* Should never happen */%@AE@%%@NL@%
    i = transtab[*s];                        %@AB@%/* Get current index */%@AE@%%@NL@%
    if(i == 0)                                %@AB@%/* If no existing list */%@AE@%%@NL@%
      {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         *  We have to start a new list%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if((i = clists++) >= TRTABLEN/2)%@NL@%
          {                                %@AB@%/* If too many string lists */%@AE@%%@NL@%
            fprintf(stderr,"Too many string lists\n");%@NL@%
                                        %@AB@%/* Error message */%@AE@%%@NL@%
            DosExit( EXIT_PROCESS, 2);        %@AB@%/* Die */%@AE@%%@NL@%
          }%@NL@%
        stringlist[i] = NULL;                %@AB@%/* Initialize */%@AE@%%@NL@%
        transtab[*s] = i;                %@AB@%/* Set pointer to new list */%@AE@%%@NL@%
        if(!casesen && isalpha(*s)) transtab[*s ^ '\x20'] = i;%@NL@%
                                        %@AB@%/* Set pointer for other case */%@AE@%%@NL@%
      }%@NL@%
    else if(stringlist[i] == NULL) return;%@NL@%
                                        %@AB@%/* Check for existing 1-byte string */%@AE@%%@NL@%
    if(--n == 0)                        %@AB@%/* If 1-byte string */%@AE@%%@NL@%
      {%@NL@%
        freenode(stringlist[i]);        %@AB@%/* Free any existing stuff */%@AE@%%@NL@%
        stringlist[i] = NULL;                %@AB@%/* No record here */%@AE@%%@NL@%
        return;                                %@AB@%/* Done */%@AE@%%@NL@%
      }%@NL@%
    ++s;                                %@AB@%/* Skip first char */%@AE@%%@NL@%
    pprev = stringlist + i;                %@AB@%/* Get pointer to link */%@AE@%%@NL@%
    cur = *pprev;                        %@AB@%/* Get pointer to node */%@AE@%%@NL@%
    while(cur != NULL)                        %@AB@%/* Loop to traverse match tree */%@AE@%%@NL@%
      {%@NL@%
        i = (n > cur->s_must)? cur->s_must: n;%@NL@%
                                        %@AB@%/* Find minimum of string lengths */%@AE@%%@NL@%
        matchstrings(s,s_text(cur),i,&j,&k);%@NL@%
                                        %@AB@%/* Compare the strings */%@AE@%%@NL@%
        if(j == 0)                        %@AB@%/* If complete mismatch */%@AE@%%@NL@%
          {%@NL@%
            if(k < 0) break;                %@AB@%/* Break if insertion point found */%@AE@%%@NL@%
            pprev = &(cur->s_alt);        %@AB@%/* Get pointer to alternate link */%@AE@%%@NL@%
            cur = *pprev;                %@AB@%/* Follow the link */%@AE@%%@NL@%
          }%@NL@%
        else if(i == j)                        %@AB@%/* Else if strings matched */%@AE@%%@NL@%
          {%@NL@%
            if(i == n)                        %@AB@%/* If new is prefix of current */%@AE@%%@NL@%
              {%@NL@%
                reallocnode(cur,s_text(cur),n);%@NL@%
                                        %@AB@%/* Shorten text of node */%@AE@%%@NL@%
                if(cur->s_suf != NULL)        %@AB@%/* If there are suffixes */%@AE@%%@NL@%
                  {%@NL@%
                    freenode(cur->s_suf);%@NL@%
                                        %@AB@%/* Suffixes no longer needed */%@AE@%%@NL@%
                    cur->s_suf = NULL;%@NL@%
                  }%@NL@%
                return;                        %@AB@%/* All done */%@AE@%%@NL@%
              }%@NL@%
            pprev = &(cur->s_suf);        %@AB@%/* Get pointer to suffix link */%@AE@%%@NL@%
            if((cur = *pprev) == NULL) return;%@NL@%
                                        %@AB@%/* Done if current is prefix of new */%@AE@%%@NL@%
            s += i;                        %@AB@%/* Skip matched portion */%@AE@%%@NL@%
            n -= i;%@NL@%
          }%@NL@%
        else                                %@AB@%/* Else partial match */%@AE@%%@NL@%
          {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             *        We must split an existing node.%@NL@%
%@AB@%             *        This is the trickiest case.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            new = newnode(s_text(cur) + j,cur->s_must - j);%@NL@%
                                        %@AB@%/* Unmatched part of current string */%@AE@%%@NL@%
            reallocnode(cur,s_text(cur),j);%@NL@%
                                        %@AB@%/* Set length to matched portion */%@AE@%%@NL@%
            new->s_suf = cur->s_suf;        %@AB@%/* Current string's suffixes */%@AE@%%@NL@%
            if(k < 0)                        %@AB@%/* If new preceded current */%@AE@%%@NL@%
              {%@NL@%
                cur->s_suf = newnode(s + j,n - j);%@NL@%
                                        %@AB@%/* FIrst suffix is new string */%@AE@%%@NL@%
                cur->s_suf->s_alt = new;%@AB@%/* Alternate is part of current */%@AE@%%@NL@%
              }%@NL@%
            else                        %@AB@%/* Else new followed current */%@AE@%%@NL@%
              {%@NL@%
                new->s_alt = newnode(s + j,n - j);%@NL@%
                                        %@AB@%/* Unmatched new string is alternate */%@AE@%%@NL@%
                cur->s_suf = new;        %@AB@%/* New suffix list */%@AE@%%@NL@%
              }%@NL@%
            return;%@NL@%
          }%@NL@%
      }%@NL@%
    *pprev = newnode(s,n);                %@AB@%/* Set pointer to new node */%@AE@%%@NL@%
    (*pprev)->s_alt = cur;                %@AB@%/* Attach alternates */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
int                        addfancy(buffer,buflen,seplist)%@NL@%
register char                *buffer;        %@AB@%/* Buffer */%@AE@%%@NL@%
int                        buflen;                %@AB@%/* Length of buffer */%@AE@%%@NL@%
char                        *seplist;        %@AB@%/* List of separators */%@AE@%%@NL@%
  {%@NL@%
    register char        *bufend;        %@AB@%/* Pointer to end of buffer */%@AE@%%@NL@%
    int                        strcnt = 0;        %@AB@%/* String count */%@AE@%%@NL@%
    int                        len;                %@AB@%/* String length */%@AE@%%@NL@%
    char                c;                %@AB@%/* One char buffer */%@AE@%%@NL@%
%@NL@%
    bufend = buffer + buflen;                %@AB@%/* Set end pointer */%@AE@%%@NL@%
    while(buffer < bufend)                %@AB@%/* Loop through all strings */%@AE@%%@NL@%
      {%@NL@%
        len = strncspn(buffer,seplist,bufend - buffer);%@NL@%
                                        %@AB@%/* Length of string */%@AE@%%@NL@%
        if(flags & ENDLINE)                %@AB@%/* If match must be at end of line */%@AE@%%@NL@%
          {%@NL@%
            c = buffer[len];                %@AB@%/* Save 1st character past string */%@AE@%%@NL@%
            buffer[len++] = '\r';        %@AB@%/* Carriage return marks end of line */%@AE@%%@NL@%
          }%@NL@%
        if(findlist(buffer,buffer + len) == NULL)%@NL@%
          {                                %@AB@%/* If no match within string */%@AE@%%@NL@%
            addstring(buffer,len);        %@AB@%/* Add string to list */%@AE@%%@NL@%
            if(strcnt++ == 0)                %@AB@%/* If first string */%@AE@%%@NL@%
              {%@NL@%
                memcpy(target,buffer,len);%@NL@%
                                        %@AB@%/* Save first string in buffer */%@AE@%%@NL@%
                targetlen = len;        %@AB@%/* Remember length */%@AE@%%@NL@%
              }%@NL@%
          }%@NL@%
        buffer += len;                        %@AB@%/* Skip over string */%@AE@%%@NL@%
        if(flags & ENDLINE) (--buffer)[0] = c;%@NL@%
                                        %@AB@%/* Restore saved character */%@AE@%%@NL@%
        buffer += strnspn(buffer,seplist,bufend - buffer);%@NL@%
                                        %@AB@%/* Skip over trailing separators */%@AE@%%@NL@%
      }%@NL@%
    return(strcnt);                        %@AB@%/* Return string count */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
int                        addplain(buffer,buflen,seplist)%@NL@%
register char                *buffer;        %@AB@%/* String list buffer */%@AE@%%@NL@%
int                        buflen;                %@AB@%/* Buffer length */%@AE@%%@NL@%
char                        *seplist;        %@AB@%/* List of separators */%@AE@%%@NL@%
  {%@NL@%
    int                        strcnt;                %@AB@%/* String count */%@AE@%%@NL@%
    register int        len;                %@AB@%/* String length */%@AE@%%@NL@%
    char                c;                %@AB@%/* One char buffer */%@AE@%%@NL@%
%@NL@%
    strcnt = 0;%@NL@%
    while((len = strncspn(buffer,seplist,buflen)) > 0)%@NL@%
      {                                        %@AB@%/* While not at end of input list */%@AE@%%@NL@%
        if(flags & ENDLINE)                %@AB@%/* If match must be at end of line */%@AE@%%@NL@%
          {%@NL@%
            c = buffer[len];                %@AB@%/* Save 1st character past string */%@AE@%%@NL@%
            buffer[len++] = '\r';        %@AB@%/* Carriage return marks end of line */%@AE@%%@NL@%
          }%@NL@%
        if(strcnt == 0)                        %@AB@%/* Save first string */%@AE@%%@NL@%
          {%@NL@%
            strncpy(target,buffer,len);        %@AB@%/* Save string in buffer */%@AE@%%@NL@%
            targetlen = len;                %@AB@%/* Save string length */%@AE@%%@NL@%
          }%@NL@%
        addstring(buffer,len);                %@AB@%/* Add the string to the table */%@AE@%%@NL@%
        if(flags & ENDLINE) buffer[--len] = c;%@NL@%
                                        %@AB@%/* Restore saved character */%@AE@%%@NL@%
        buffer += len;                        %@AB@%/* Skip the string */%@AE@%%@NL@%
        buflen -= len;%@NL@%
        len = strnspn(buffer,seplist,buflen);%@NL@%
                                        %@AB@%/* Skip separators */%@AE@%%@NL@%
        buffer += len;%@NL@%
        buflen -= len;%@NL@%
        ++strcnt;                        %@AB@%/* Increment string count */%@AE@%%@NL@%
      }%@NL@%
    return(strcnt);                        %@AB@%/* Return string count */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        dumplist(node,indent)%@NL@%
register STRINGNODE        *node;                %@AB@%/* Pointer to list to dump */%@AE@%%@NL@%
int                        indent;                %@AB@%/* Current length of buffer */%@AE@%%@NL@%
  {%@NL@%
    int                        i;                %@AB@%/* Counter */%@AE@%%@NL@%
%@NL@%
    while(node != NULL)                        %@AB@%/* While not at end of list */%@AE@%%@NL@%
      {%@NL@%
        for(i = 0; i < indent; ++i) fputc(' ',stderr);%@NL@%
        fwrite(s_text(node),sizeof(char),node->s_must,stderr);%@NL@%
        fprintf(stderr,"\n");%@NL@%
        if(node->s_suf != NULL)%@NL@%
          dumplist(node->s_suf,indent + node->s_must);%@NL@%
                                        %@AB@%/* Recurse to do suffixes */%@AE@%%@NL@%
        node = node->s_alt;                %@AB@%/* Do next alternate in list */%@AE@%%@NL@%
      }%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        dumpstrings()%@NL@%
  {%@NL@%
    int                        i;                %@AB@%/* Index */%@AE@%%@NL@%
%@NL@%
    for(i = 0; i < TRTABLEN; ++i)        %@AB@%/* Loop through translation table */%@AE@%%@NL@%
      {%@NL@%
        if(transtab[i] == 0) continue;        %@AB@%/* Skip null entries */%@AE@%%@NL@%
        fprintf(stderr,"%c\n",i);        %@AB@%/* Print the first byte */%@AE@%%@NL@%
        dumplist(stringlist[transtab[i]],1);%@NL@%
                                        %@AB@%/* Dump the list */%@AE@%%@NL@%
      }%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
HFILE                        openfile(name)%@NL@%
char                        *name;                %@AB@%/* File name */%@AE@%%@NL@%
  {%@NL@%
    HFILE                fd;                %@AB@%/* File descriptor */%@AE@%%@NL@%
%@NL@%
    if((fd = open(name,0)) == -1)        %@AB@%/* If error opening file */%@AE@%%@NL@%
      {%@NL@%
        fprintf(stderr,"Cannot open %s\r\n",name);%@NL@%
                                        %@AB@%/* Print error message */%@AE@%%@NL@%
      }%@NL@%
    return(fd);                                %@AB@%/* Return file descriptor */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void far                thread2()        %@AB@%/* Read thread */%@AE@%%@NL@%
  {%@NL@%
    while(DosSemRequest( &readpending, -1L) == 0)%@NL@%
      {                                        %@AB@%/* While there is work to do */%@AE@%%@NL@%
        arrc = DosRead( t2fd, t2buf, t2buflen, &cbread);%@NL@%
                                        %@AB@%/* Do the read */%@AE@%%@NL@%
        DosSemClear( &readdone);        %@AB@%/* Signal read completed */%@AE@%%@NL@%
      }%@NL@%
    fprintf(stderr,"Thread 2: DosSemRequest failed\n");%@NL@%
                                        %@AB@%/* Print error message */%@AE@%%@NL@%
    DosExit( EXIT_PROCESS, 2);                %@AB@%/* Die */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void far                thread3()        %@AB@%/* Write thread */%@AE@%%@NL@%
  {%@NL@%
    while(DosSemRequest((long far *) &writepending,-1L) == 0)%@NL@%
      {                                        %@AB@%/* While there is work to do */%@AE@%%@NL@%
        awrc = DosWrite(t3fd, t3buf, t3buflen, &cbwrite);%@NL@%
                                        %@AB@%/* Do the write */%@AE@%%@NL@%
        DosSemClear( &writedone);        %@AB@%/* Signal write completed */%@AE@%%@NL@%
      }%@NL@%
    fprintf(stderr,"Thread 3: DosSemRequest failed\n");%@NL@%
                                        %@AB@%/* Print error message */%@AE@%%@NL@%
    DosExit( EXIT_PROCESS, 2);                %@AB@%/* Die */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        startread(fd,buffer,buflen)%@NL@%
HFILE                        fd;                %@AB@%/* File handle */%@AE@%%@NL@%
char                        *buffer;        %@AB@%/* Buffer */%@AE@%%@NL@%
USHORT                        buflen;         %@AB@%/* Buffer length */%@AE@%%@NL@%
  {%@NL@%
    if(pmode)                                %@AB@%/* If protected mode */%@AE@%%@NL@%
      {%@NL@%
        if(DosSemRequest( &readdone, -1L) != 0)%@NL@%
          {                                %@AB@%/* If we fail to get the semaphore */%@AE@%%@NL@%
            fprintf(stderr,"DosSemRequest failed\n");%@NL@%
                                        %@AB@%/* Error message */%@AE@%%@NL@%
            DosExit( EXIT_PROCESS, 2);        %@AB@%/* Die */%@AE@%%@NL@%
          }%@NL@%
        t2fd = fd;                        %@AB@%/* Set parameters for read */%@AE@%%@NL@%
        t2buf = buffer;%@NL@%
        t2buflen = buflen;%@NL@%
        DosSemClear( &readpending);        %@AB@%/* Wake thread 2 for read */%@AE@%%@NL@%
        DosSleep(0L);                        %@AB@%/* Yield the CPU */%@AE@%%@NL@%
      }%@NL@%
    else arrc = DosRead( fd, buffer, buflen, &cbread);%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
int                        finishread()%@NL@%
  {%@NL@%
    if(pmode && DosSemWait( &readdone, -1L) != 0)%@NL@%
      {                                        %@AB@%/* If protected mode and wait fails */%@AE@%%@NL@%
        fprintf(stderr,"DosSemWait failed\n");%@NL@%
                                        %@AB@%/* Print error message */%@AE@%%@NL@%
        DosExit( EXIT_PROCESS, 2);                          %@AB@%/* Die */%@AE@%%@NL@%
      }%@NL@%
    return((arrc == 0)? cbread: -1);        %@AB@%/* Return number of bytes read */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        startwrite(fd,buffer,buflen)%@NL@%
HFILE                        fd;                %@AB@%/* File handle */%@AE@%%@NL@%
char                        *buffer;        %@AB@%/* Buffer */%@AE@%%@NL@%
USHORT                        buflen;         %@AB@%/* Buffer length */%@AE@%%@NL@%
  {%@NL@%
    if(pmode)                                %@AB@%/* If protected mode */%@AE@%%@NL@%
      {%@NL@%
        if(DosSemRequest( &writedone, -1L) != 0)%@NL@%
          {                                %@AB@%/* If we fail to get the semaphore */%@AE@%%@NL@%
            fprintf(stderr,"DosSemRequest failed\n");%@NL@%
                                        %@AB@%/* Error message */%@AE@%%@NL@%
            DosExit( EXIT_PROCESS, 2);        %@AB@%/* Die */%@AE@%%@NL@%
          }%@NL@%
        t3fd = fd;                        %@AB@%/* Set parameters for write */%@AE@%%@NL@%
        t3buf = buffer;%@NL@%
        t3buflen = buflen;%@NL@%
        DosSemClear( &writepending);        %@AB@%/* Wake thread 3 for read */%@AE@%%@NL@%
        DosSleep(0L);                        %@AB@%/* Yield the CPU */%@AE@%%@NL@%
      }%@NL@%
    else awrc = DosWrite(fd, buffer, buflen, &cbwrite);%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
int                        finishwrite()%@NL@%
  {%@NL@%
    if(pmode && DosSemWait( &writedone, -1L) != 0)%@NL@%
      {                                        %@AB@%/* If protected mode and wait fails */%@AE@%%@NL@%
        fprintf(stderr,"DosSemWait failed\n");%@NL@%
                                        %@AB@%/* Print error message */%@AE@%%@NL@%
        DosExit( EXIT_PROCESS, 2);        %@AB@%/* Die */%@AE@%%@NL@%
      }%@NL@%
    return((awrc == 0)? cbwrite: -1);        %@AB@%/* Return number of bytes written */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        write1nobuf(buffer,buflen)%@NL@%
char                        *buffer;        %@AB@%/* Buffer */%@AE@%%@NL@%
USHORT                        buflen;         %@AB@%/* Buffer length */%@AE@%%@NL@%
  {%@NL@%
    int                        cb;                %@AB@%/* Count of bytes written */%@AE@%%@NL@%
%@NL@%
    if( DosWrite(1, buffer, buflen, &cb) != 0 || cb != buflen)%@NL@%
                                        %@AB@%/* If write fails */%@AE@%%@NL@%
      {%@NL@%
        fprintf(stderr,"write error %d\n",awrc);%@NL@%
                                        %@AB@%/* Print error message */%@AE@%%@NL@%
        DosExit( EXIT_PROCESS, 2);        %@AB@%/* Die */%@AE@%%@NL@%
      }%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        write1buf(buffer,buflen)%@NL@%
char                        *buffer;        %@AB@%/* Buffer */%@AE@%%@NL@%
USHORT                        buflen;         %@AB@%/* Buffer length */%@AE@%%@NL@%
  {%@NL@%
    USHORT                cb;                %@AB@%/* Byte count */%@AE@%%@NL@%
%@NL@%
    while(buflen > 0)                        %@AB@%/* While bytes remain */%@AE@%%@NL@%
      {%@NL@%
        if(awrc != 0)                        %@AB@%/* If previous write failed */%@AE@%%@NL@%
          {%@NL@%
            fprintf(stderr,"write error %d\n",awrc);%@NL@%
                                        %@AB@%/* Print error message */%@AE@%%@NL@%
            DosExit( EXIT_PROCESS, 2);                          %@AB@%/* Die */%@AE@%%@NL@%
          }%@NL@%
        if((cb = ocnt[oi]) == 0)        %@AB@%/* If buffer full */%@AE@%%@NL@%
          {%@NL@%
            startwrite(1,obuf[oi],OUTBUFLEN);%@NL@%
                                        %@AB@%/* Write the buffer */%@AE@%%@NL@%
            ocnt[oi] = OUTBUFLEN;        %@AB@%/* Reset count and pointer */%@AE@%%@NL@%
            optr[oi] = obuf[oi];%@NL@%
            oi ^= 1;                        %@AB@%/* Switch buffers */%@AE@%%@NL@%
            cb = ocnt[oi];                %@AB@%/* Get space remaining */%@AE@%%@NL@%
          }%@NL@%
        if(cb > buflen) cb = buflen;        %@AB@%/* Get minimum */%@AE@%%@NL@%
        memcpy(optr[oi],buffer,cb);        %@AB@%/* Copy bytes to buffer */%@AE@%%@NL@%
        ocnt[oi] -= cb;                        %@AB@%/* Update buffer length and pointers */%@AE@%%@NL@%
        optr[oi] += cb;%@NL@%
        buflen -= cb;%@NL@%
        buffer += cb;%@NL@%
      }%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        flush1nobuf()%@NL@%
  {%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        flush1buf()%@NL@%
  {%@NL@%
    int                        cb;                %@AB@%/* Byte count */%@AE@%%@NL@%
%@NL@%
    if((cb = OUTBUFLEN - ocnt[oi]) > 0)        %@AB@%/* If buffer not empty */%@AE@%%@NL@%
      {%@NL@%
        startwrite(1,obuf[oi],cb);        %@AB@%/* Start write */%@AE@%%@NL@%
        if(finishwrite() != cb)                %@AB@%/* If write failed */%@AE@%%@NL@%
          {%@NL@%
            fprintf(stderr,"write error %d\n",awrc);%@NL@%
                                        %@AB@%/* Print error message */%@AE@%%@NL@%
            DosExit( EXIT_PROCESS, 2);        %@AB@%/* Die */%@AE@%%@NL@%
          }%@NL@%
      }%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
int                        grepnull(cp,endbuf,name)%@NL@%
register char                *cp;                %@AB@%/* Buffer pointer */%@AE@%%@NL@%
char                        *endbuf;        %@AB@%/* End of buffer */%@AE@%%@NL@%
char                        *name;                %@AB@%/* File name */%@AE@%%@NL@%
  {%@NL@%
    return(0);                                %@AB@%/* Do nothing */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
int                        grepbuffer(startbuf,endbuf,name)%@NL@%
char                        *startbuf;        %@AB@%/* Start of buffer */%@AE@%%@NL@%
char                        *endbuf;        %@AB@%/* End of buffer */%@AE@%%@NL@%
char                        *name;                %@AB@%/* File name */%@AE@%%@NL@%
  {%@NL@%
    register char        *cp;                %@AB@%/* Buffer pointer */%@AE@%%@NL@%
    char                *lastmatch;        %@AB@%/* Last matching line */%@AE@%%@NL@%
    int                        linelen;        %@AB@%/* Line length */%@AE@%%@NL@%
    int                        namlen = 0;        %@AB@%/* Length of name */%@AE@%%@NL@%
    char                lnobuf[LNOLEN];        %@AB@%/* Line number buffer */%@AE@%%@NL@%
    char                nambuf[LINELEN];%@AB@%/* Name buffer */%@AE@%%@NL@%
%@NL@%
    cp = startbuf;                        %@AB@%/* Initialize to start of buffer */%@AE@%%@NL@%
    lastmatch = cp;                        %@AB@%/* No previous match yet */%@AE@%%@NL@%
    while((cp = (*find)(cp,endbuf)) != NULL)%@NL@%
      {                                        %@AB@%/* While matches are found */%@AE@%%@NL@%
        if((flags & BEGLINE) && cp[-1] != '\n' && cp > startbuf)%@NL@%
          {                                %@AB@%/* If begin line conditions not met */%@AE@%%@NL@%
            ++cp;                        %@AB@%/* Skip first char of match */%@AE@%%@NL@%
            continue;                        %@AB@%/* Keep looking */%@AE@%%@NL@%
          }%@NL@%
        status = 0;                        %@AB@%/* Match found */%@AE@%%@NL@%
        if(flags & NAMEONLY)                %@AB@%/* If filename only wanted */%@AE@%%@NL@%
          {%@NL@%
            (*write1)(nambuf,sprintf(nambuf,"%s\r\n",name));%@NL@%
                                        %@AB@%/* Print the name */%@AE@%%@NL@%
            return(1);                        %@AB@%/* Punt remainder of buffer */%@AE@%%@NL@%
          }%@NL@%
        cp -= revfind(cp,'\n',cp - startbuf);%@NL@%
                                        %@AB@%/* Point at last linefeed */%@AE@%%@NL@%
        if(*cp == '\n') ++cp;                %@AB@%/* Point at start of line */%@AE@%%@NL@%
        if(flags & SHOWNAME)                %@AB@%/* If name wanted */%@AE@%%@NL@%
          {%@NL@%
            if(namlen == 0) namlen = sprintf(nambuf,"%s:",name);%@NL@%
                                        %@AB@%/* Format name if not done already */%@AE@%%@NL@%
            (*write1)(nambuf,namlen);        %@AB@%/* Show name */%@AE@%%@NL@%
          }%@NL@%
        if(flags & LINENOS)                %@AB@%/* If line number wanted */%@AE@%%@NL@%
          {%@NL@%
            lineno += countlines(lastmatch,cp);%@NL@%
                                        %@AB@%/* Count lines since last match */%@AE@%%@NL@%
            (*write1)(lnobuf,sprintf(lnobuf,"%d:",lineno));%@NL@%
                                        %@AB@%/* Print line number */%@AE@%%@NL@%
            lastmatch = cp;                %@AB@%/* New last match */%@AE@%%@NL@%
          }%@NL@%
        linelen = strncspn(cp,"\n",endbuf - cp) + 1;%@NL@%
                                        %@AB@%/* Calculate line length */%@AE@%%@NL@%
        (*write1)(cp,linelen);                %@AB@%/* Print the line */%@AE@%%@NL@%
        cp += linelen;                        %@AB@%/* Skip the line */%@AE@%%@NL@%
      }%@NL@%
    if(flags & LINENOS) lineno += countlines(lastmatch,endbuf);%@NL@%
                                        %@AB@%/* Count remaining lines in buffer */%@AE@%%@NL@%
    return(0);                                %@AB@%/* Keep searching */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        showv(name,lastmatch,thismatch)%@NL@%
char                        *name;%@NL@%
register char                *lastmatch;%@NL@%
char                        *thismatch;%@NL@%
  {%@NL@%
    register int        linelen;%@NL@%
    int                        namlen = 0;        %@AB@%/* Length of name */%@AE@%%@NL@%
    char                lnobuf[LNOLEN];        %@AB@%/* Line number buffer */%@AE@%%@NL@%
    char                nambuf[LINELEN];%@AB@%/* Name buffer */%@AE@%%@NL@%
%@NL@%
    if(flags & (SHOWNAME | LINENOS))%@NL@%
      {%@NL@%
        while(lastmatch < thismatch)%@NL@%
          {%@NL@%
            if(flags & SHOWNAME)        %@AB@%/* If name wanted */%@AE@%%@NL@%
              {%@NL@%
                if(namlen == 0) namlen = sprintf(nambuf,"%s:",name);%@NL@%
                                        %@AB@%/* Format name if not done already */%@AE@%%@NL@%
                (*write1)(nambuf,namlen);%@NL@%
                                        %@AB@%/* Write the name */%@AE@%%@NL@%
              }%@NL@%
            if(flags & LINENOS)%@NL@%
              {%@NL@%
                (*write1)(lnobuf,sprintf(lnobuf,"%d:",lineno++));%@NL@%
              }%@NL@%
            linelen = strncspn(lastmatch,"\n",thismatch - lastmatch) + 1;%@NL@%
            (*write1)(lastmatch,linelen);%@NL@%
            lastmatch += linelen;%@NL@%
          }%@NL@%
      }%@NL@%
    else (*write1)(lastmatch,thismatch - lastmatch);%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
int                        grepvbuffer(startbuf,endbuf,name)%@NL@%
char                        *startbuf;        %@AB@%/* Start of buffer */%@AE@%%@NL@%
char                        *endbuf;        %@AB@%/* End of buffer */%@AE@%%@NL@%
char                        *name;                %@AB@%/* File name */%@AE@%%@NL@%
  {%@NL@%
    register char        *cp;                %@AB@%/* Buffer pointer */%@AE@%%@NL@%
    register char        *lastmatch;        %@AB@%/* Pointer to line after last match */%@AE@%%@NL@%
%@NL@%
    cp = startbuf;                        %@AB@%/* Initialize to start of buffer */%@AE@%%@NL@%
    lastmatch = cp;%@NL@%
    while((cp = (*find)(cp,endbuf)) != NULL)%@NL@%
      {%@NL@%
        if((flags & BEGLINE) && cp[-1] != '\n' && cp > startbuf)%@NL@%
          {                                %@AB@%/* If begin line conditions not met */%@AE@%%@NL@%
            ++cp;                        %@AB@%/* Skip first char of match */%@AE@%%@NL@%
            continue;                        %@AB@%/* Keep looking */%@AE@%%@NL@%
          }%@NL@%
        status = 1;                        %@AB@%/* Match found */%@AE@%%@NL@%
        if(flags & NAMEONLY) return(1);        %@AB@%/* Skip rest of file if NAMEONLY */%@AE@%%@NL@%
        cp -= revfind(cp,'\n',cp - startbuf);%@NL@%
                                        %@AB@%/* Point at last linefeed */%@AE@%%@NL@%
        if(*cp == '\n') ++cp;                %@AB@%/* Point at start of line */%@AE@%%@NL@%
        showv(name,lastmatch,cp);        %@AB@%/* Show from last match to this */%@AE@%%@NL@%
        cp += strncspn(cp,"\n",endbuf - cp) + 1;%@NL@%
                                        %@AB@%/* Skip over line with match */%@AE@%%@NL@%
        lastmatch = cp;                        %@AB@%/* New "last" match */%@AE@%%@NL@%
        ++lineno;                        %@AB@%/* Increment line count */%@AE@%%@NL@%
      }%@NL@%
    if(!(flags & NAMEONLY)) showv(name,lastmatch,endbuf);%@NL@%
                                        %@AB@%/* Show buffer tail if not NAMEONLY */%@AE@%%@NL@%
    return(0);                                %@AB@%/* Keep searching file */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        qgrep(name,fd)%@NL@%
char                        *name;                %@AB@%/* File name */%@AE@%%@NL@%
HFILE                        fd;                %@AB@%/* File descriptor */%@AE@%%@NL@%
  {%@NL@%
    register int        cb;                %@AB@%/* Byte count */%@AE@%%@NL@%
    register char        *cp;                %@AB@%/* Buffer pointer */%@AE@%%@NL@%
    char                *endbuf;        %@AB@%/* End of buffer */%@AE@%%@NL@%
    int                        taillen;        %@AB@%/* Length of buffer tail */%@AE@%%@NL@%
    int                        bufi;                %@AB@%/* Buffer index */%@AE@%%@NL@%
    char                line[LINELEN];        %@AB@%/* Line buffer */%@AE@%%@NL@%
%@NL@%
    lineno = 1;                                %@AB@%/* File starts on line 1 */%@AE@%%@NL@%
    taillen = 0;                        %@AB@%/* No buffer tail yet */%@AE@%%@NL@%
    bufi = 0;                                %@AB@%/* Initialize buffer index */%@AE@%%@NL@%
    cp = bufptr[0];                        %@AB@%/* Initialize to start of buffer */%@AE@%%@NL@%
    finishread();                        %@AB@%/* Make sure no I/O activity */%@AE@%%@NL@%
    arrc = DosRead( fd, cp, FILBUFLEN, &cbread);%@NL@%
                                        %@AB@%/* Do first read synchronously */%@AE@%%@NL@%
    while((cb = finishread()) + taillen > 0)%@NL@%
      {                                        %@AB@%/* While search incomplete */%@AE@%%@NL@%
        if(cb == 0)                        %@AB@%/* If buffer tail is all that's left */%@AE@%%@NL@%
          {%@NL@%
            taillen = 0;                %@AB@%/* Set tail length to zero */%@AE@%%@NL@%
            *cp++ = '\r';                %@AB@%/* Add end of line sequence */%@AE@%%@NL@%
            *cp++ = '\n';%@NL@%
            endbuf = cp;                %@AB@%/* Note end of buffer */%@AE@%%@NL@%
          }%@NL@%
        else                                %@AB@%/* Else start next read */%@AE@%%@NL@%
          {%@NL@%
            taillen = revfind(cp + cb - 1,'\n',cb);%@NL@%
                                        %@AB@%/* Find length of partial line */%@AE@%%@NL@%
            endbuf = cp + cb - taillen;        %@AB@%/* Get pointer to end of buffer */%@AE@%%@NL@%
            cp = bufptr[bufi ^ 1];        %@AB@%/* Pointer to other buffer */%@AE@%%@NL@%
            memcpy(cp,endbuf,taillen);        %@AB@%/* Copy tail to head of other buffer */%@AE@%%@NL@%
            cp += taillen;                %@AB@%/* Skip over tail */%@AE@%%@NL@%
            startread(fd,cp,(FILBUFLEN - taillen) & (~0 << LG2SECLEN));%@NL@%
                                        %@AB@%/* Start next read */%@AE@%%@NL@%
          }%@NL@%
        if((*grep)(bufptr[bufi],endbuf,name)) return;%@NL@%
                                        %@AB@%/* Done if NAMEONLY and match found */%@AE@%%@NL@%
        bufi ^= 1;                        %@AB@%/* Switch buffers */%@AE@%%@NL@%
      }%@NL@%
    if((flags & (NAMEONLY | INVERT)) == (NAMEONLY | INVERT))%@NL@%
      (*write1)(line,sprintf(line,"%s\r\n",name));%@NL@%
                                        %@AB@%/* Write name if -lv */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        usage(verbose)%@NL@%
int                        verbose;        %@AB@%/* Verbose message flag */%@AE@%%@NL@%
  {%@NL@%
    static char                *opts[] =%@NL@%
      {%@NL@%
        "-? - print this message",%@NL@%
        "-B - match pattern if at beginning of line",%@NL@%
        "-E - match pattern if at end of line",%@NL@%
        "-l - print only file name if file contains match",%@NL@%
        "-n - print line number before each matching line",%@NL@%
        "-v - print only lines not containing a match",%@NL@%
        "-x - print lines that match exactly (-BE)",%@NL@%
        "-y - treat upper and lower case as equivalent",%@NL@%
        "-e - treat next argument as the search string",%@NL@%
        "-f - read search strings from file named by next argument",%@NL@%
        "-i - read file list from file named by next argument",%@NL@%
        0%@NL@%
      };%@NL@%
    register char        **opt = opts;        %@AB@%/* Option list */%@AE@%%@NL@%
%@NL@%
    fprintf(stderr,"usage: CPGREP [-?BElnvxy][-e][-f <file>][-i <file>][<strings>][<files>]\n");%@NL@%
    if(verbose)                                %@AB@%/* If verbose message wanted */%@AE@%%@NL@%
      {%@NL@%
        while(*opt != 0) fprintf(stderr,"%s\n",*opt++);%@NL@%
                                        %@AB@%/* Print option list */%@AE@%%@NL@%
      }%@NL@%
    DosExit( EXIT_PROCESS, 2);                %@AB@%/* Error exit */%@AE@%%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
void                        main(argc,argv)%@NL@%
int                        argc;%@NL@%
char                        **argv;%@NL@%
  {%@NL@%
    register char        *cp;%@NL@%
    HFILE                fd;%@NL@%
    FILE                *fi;%@NL@%
    char                filnam[FILNAMLEN];%@NL@%
    USHORT                handType;%@NL@%
    USHORT                handAttrib;%@NL@%
    int                        i;%@NL@%
    char                *inpfile = NULL;%@NL@%
    int                 j;%@NL@%
    char                *seplist = " \t";%@NL@%
    int                        strcnt;%@NL@%
    char                *strfile = NULL;%@NL@%
    long                start;                %@AB@%/* Start time */%@AE@%%@NL@%
    int                        (*add)();%@NL@%
    BYTE                t2stk[2*STKLEN];  %@AB@%/* Read thread stack */%@AE@%%@NL@%
    BYTE                t3stk[2*STKLEN];  %@AB@%/* Write thread stack */%@AE@%%@NL@%
    long                time();                %@AB@%/* Time and date in seconds */%@AE@%%@NL@%
%@NL@%
    DosGetMachineMode((char far *) &pmode);%@NL@%
    flags = 0;%@NL@%
    for(i = 1; i < argc && argv[i][0] == '-'; ++i)%@NL@%
      {%@NL@%
        switch(argv[i][1])%@NL@%
          {%@NL@%
            case 'f':%@NL@%
            case 'i':%@NL@%
              if(i == argc - 1)%@NL@%
                {%@NL@%
                  fprintf(stderr,"File name missing after -%c\n",argv[i][1]);%@NL@%
                  DosExit( EXIT_PROCESS, 2);%@NL@%
                }%@NL@%
              if(argv[i++][1] == 'i') inpfile = argv[i];%@NL@%
              else strfile = argv[i];%@NL@%
              break;%@NL@%
%@NL@%
            case '?':%@NL@%
            case 'B':%@NL@%
            case 'E':%@NL@%
            case 'N':%@NL@%
            case 'S':%@NL@%
            case 'd':%@NL@%
            case 'l':%@NL@%
            case 'n':%@NL@%
            case 't':%@NL@%
            case 'v':%@NL@%
            case 'x':%@NL@%
            case 'y':%@NL@%
              for(cp = &argv[i][1]; *cp != '\0'; ++cp)%@NL@%
                {%@NL@%
                  switch(*cp)%@NL@%
                    {%@NL@%
                      case '?':%@NL@%
                        usage(1);        %@AB@%/* Verbose usage message */%@AE@%%@NL@%
%@NL@%
                      case 'B':%@NL@%
                        flags |= BEGLINE;%@NL@%
                        break;%@NL@%
%@NL@%
                      case 'E':%@NL@%
                        flags |= ENDLINE;%@NL@%
                        break;%@NL@%
%@NL@%
                      case 'N':%@NL@%
                        grep = grepnull;%@NL@%
                        break;%@NL@%
%@NL@%
                      case 'S':%@NL@%
                        pmode = 0;        %@AB@%/* Force synchronous I/O */%@AE@%%@NL@%
                        break;%@NL@%
%@NL@%
                      case 'd':%@NL@%
                        flags |= DEBUG;%@NL@%
                        break;%@NL@%
%@NL@%
                      case 'l':%@NL@%
                        flags |= NAMEONLY;%@NL@%
                        break;%@NL@%
%@NL@%
                      case 'n':%@NL@%
                        flags |= LINENOS;%@NL@%
                        break;%@NL@%
%@NL@%
                      case 't':%@NL@%
                        flags |= TIMER;%@NL@%
                        break;%@NL@%
%@NL@%
                      case 'v':%@NL@%
                        status = 0;        %@AB@%/* Assume success */%@AE@%%@NL@%
                        flags |= INVERT;%@NL@%
                        grep = grepvbuffer;%@NL@%
                        break;%@NL@%
%@NL@%
                      case 'x':%@NL@%
                        flags |= BEGLINE | ENDLINE;%@NL@%
                        break;%@NL@%
%@NL@%
                      case 'y':%@NL@%
                        casesen = 0;%@NL@%
                        break;%@NL@%
%@NL@%
                      default:%@NL@%
                        fprintf(stderr,"-%c ignored\n",*cp);%@NL@%
                        break;%@NL@%
                    }%@NL@%
                }%@NL@%
              break;%@NL@%
%@NL@%
            case 'e':%@NL@%
              if(strfile == NULL)%@NL@%
                {%@NL@%
                  ++i;%@NL@%
                  seplist = "";                %@AB@%/* Allow anything in string */%@AE@%%@NL@%
                  goto endfor0;%@NL@%
                }%@NL@%
              %@AB@%/* Drop through to "default" */%@AE@%%@NL@%
%@NL@%
            default:%@NL@%
              fprintf(stderr,"%s ignored\n",argv[i]);%@NL@%
              break;%@NL@%
          }%@NL@%
      }%@NL@%
    endfor0:%@NL@%
%@NL@%
    if(i == argc && strfile == NULL) usage(0);%@NL@%
                                        %@AB@%/* Simple usage message if arg error */%@AE@%%@NL@%
    if(flags & TIMER) start = time(NULL);%@NL@%
                                        %@AB@%/* Get start time if timer on */%@AE@%%@NL@%
    if(pmode)                                %@AB@%/* Initialize semaphores and threads */%@AE@%%@NL@%
      {%@NL@%
        TID threadId;%@NL@%
%@NL@%
        DosSemClear( &readdone);%@NL@%
        DosSemClear( &writedone);%@NL@%
        DosSemSet( &readpending);%@NL@%
        DosSemSet( &writepending);%@NL@%
        if(DosCreateThread(thread2, &threadId, t2stk + 2*STKLEN) != 0 ||%@NL@%
           DosCreateThread(thread3, &threadId, t3stk + 2*STKLEN) != 0)%@NL@%
          {                                %@AB@%/* If thread creation fails */%@AE@%%@NL@%
            fprintf(stderr,"Failed to create child threads\n");%@NL@%
                                        %@AB@%/* Print error message */%@AE@%%@NL@%
            DosExit( EXIT_PROCESS, 2);        %@AB@%/* Die */%@AE@%%@NL@%
          }%@NL@%
      }%@NL@%
    setmode(fileno(stdout),O_BINARY);%@NL@%
    add = addplain;                        %@AB@%/* Assume plain string adds */%@AE@%%@NL@%
    if(strfile != NULL)                        %@AB@%/* If strings from file */%@AE@%%@NL@%
      {%@NL@%
        if(!(flags & BEGLINE)) add = addfancy;%@NL@%
                                        %@AB@%/* Try to add intelligently */%@AE@%%@NL@%
        if((fd = open(strfile,0)) == -1)%@NL@%
          {                                %@AB@%/* If open fails */%@AE@%%@NL@%
            fprintf(stderr,"Cannot read strings from %s\n",strfile);%@NL@%
            DosExit( EXIT_PROCESS, 2);                          %@AB@%/* Print message and die */%@AE@%%@NL@%
          }%@NL@%
        for(cp = filbuf, j = 0; (j = read(fd,cp,FILBUFLEN*2 - j)) > 0; cp += j);%@NL@%
                                        %@AB@%/* Read strings file into buffer */%@AE@%%@NL@%
        j = cp - filbuf;                %@AB@%/* Get total length of buffer */%@AE@%%@NL@%
        close(fd);                        %@AB@%/* Close strings file */%@AE@%%@NL@%
        filbuf[j] = '\0';                %@AB@%/* Null-terminate the buffer */%@AE@%%@NL@%
        cp = filbuf;                        %@AB@%/* Set pointer to string list */%@AE@%%@NL@%
        seplist = "\r\n";                %@AB@%/* Only '\r' and '\n' are separators */%@AE@%%@NL@%
      }%@NL@%
    else                                %@AB@%/* Else strings on command line */%@AE@%%@NL@%
      {%@NL@%
        cp = argv[i++];                        %@AB@%/* Set pointer to strings */%@AE@%%@NL@%
        j = strlen(cp);                        %@AB@%/* Get length of strings */%@AE@%%@NL@%
      }%@NL@%
    if((strcnt = (*add)(cp,j,seplist)) == 0)%@NL@%
      {                                        %@AB@%/* If no strings */%@AE@%%@NL@%
        fprintf(stderr,"No search strings\n");%@NL@%
        DosExit( EXIT_PROCESS, 2);        %@AB@%/* Print error message and die */%@AE@%%@NL@%
      }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     *  Check type of handle for std. out.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if(DosQHandType(fileno(stdout), &handType, &handAttrib) != 0)%@NL@%
      {                                        %@AB@%/* If error */%@AE@%%@NL@%
        fprintf(stderr,"Standard output bad handle\n");%@NL@%
                                        %@AB@%/* Print error message */%@AE@%%@NL@%
        DosExit( EXIT_PROCESS, 2);        %@AB@%/* Die */%@AE@%%@NL@%
      }%@NL@%
    if(handType != 0 && (handAttrib & ISCOT))%@NL@%
      {                                 %@AB@%/* If handle is console output */%@AE@%%@NL@%
        write1 = write1nobuf;                %@AB@%/* Use unbuffered output */%@AE@%%@NL@%
        flush1 = flush1nobuf;%@NL@%
      }%@NL@%
%@NL@%
    if(strcnt > 1)                        %@AB@%/* If more than one string */%@AE@%%@NL@%
      {%@NL@%
        if(flags & DEBUG)                %@AB@%/* Print debug info maybe */%@AE@%%@NL@%
          {%@NL@%
            fprintf(stderr,"Here are the strings:\n");%@NL@%
            dumpstrings();%@NL@%
          }%@NL@%
      }%@NL@%
    else if(casesen) find = findone;        %@AB@%/* Else use findone() */%@AE@%%@NL@%
    if(inpfile != NULL)                        %@AB@%/* If file list from file */%@AE@%%@NL@%
      {%@NL@%
        flags |= SHOWNAME;                %@AB@%/* Always show name of file */%@AE@%%@NL@%
        if((fi = fopen(inpfile,"r")) == NULL)%@NL@%
          {                                %@AB@%/* If open fails */%@AE@%%@NL@%
            fprintf(stderr,"Cannot read file list from %s\r\n",inpfile);%@NL@%
                                        %@AB@%/* Error message */%@AE@%%@NL@%
            DosExit( EXIT_PROCESS, 2);        %@AB@%/* Error exit */%@AE@%%@NL@%
          }%@NL@%
        while(fgets(filnam,FILNAMLEN,fi) != NULL)%@NL@%
          {                                %@AB@%/* While there are names */%@AE@%%@NL@%
            filnam[strcspn(filnam,"\r\n")] = '\0';%@NL@%
                                        %@AB@%/* Null-terminate the name */%@AE@%%@NL@%
            if((fd = openfile(filnam)) == -1) continue;%@NL@%
                                        %@AB@%/* Skip file if it cannot be opened */%@AE@%%@NL@%
            qgrep(filnam,fd);                %@AB@%/* Do the work */%@AE@%%@NL@%
            close(fd);                        %@AB@%/* Close the file */%@AE@%%@NL@%
          }%@NL@%
        fclose(fi);                        %@AB@%/* Close the list file */%@AE@%%@NL@%
      }%@NL@%
    else if(i == argc)%@NL@%
      {%@NL@%
        flags &= ~(NAMEONLY | SHOWNAME);%@NL@%
        setmode(fileno(stdin),O_BINARY);%@NL@%
        qgrep(NULL,fileno(stdin));%@NL@%
      }%@NL@%
    if(argc > i + 1) flags |= SHOWNAME;%@NL@%
    for(; i < argc; ++i)%@NL@%
      {%@NL@%
        if((fd = openfile(argv[i])) == -1) continue;%@NL@%
        qgrep(argv[i],fd);%@NL@%
        close(fd);%@NL@%
      }%@NL@%
    (*flush1)();%@NL@%
    if(flags & TIMER) fprintf(stderr,"%ld seconds\n",time(NULL) - start);%@NL@%
                                        %@AB@%/* Print elapsed time if timer on */%@AE@%%@NL@%
    DosExit( EXIT_PROCESS, status);%@NL@%
  }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CPGREPSB.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CPGREP\CPGREPSB.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%; Created by Microsoft Corp. 1986%@AE@%%@NL@%
name cpgrepsub%@NL@%
%@NL@%
retlen        equ        2                        %@AB@%; Size of return address on stack%@AE@%%@NL@%
%@NL@%
dgroup        group        _data%@NL@%
%@NL@%
extrn        _casesen:        word                %@AB@%; Case-sensitivity flag%@AE@%%@NL@%
extrn        _stringlist:        word                %@AB@%; Table of string lists%@AE@%%@NL@%
extrn        _target:        byte                %@AB@%; Target string%@AE@%%@NL@%
extrn        _targetlen:        word                %@AB@%; Length of target string%@AE@%%@NL@%
extrn        _transtab:        byte                %@AB@%; Translation table for _findlist%@AE@%%@NL@%
%@NL@%
%@AB@%;        This segment is puposely word-aligned.  See note%@AE@%%@NL@%
%@AB@%;        in _findlist below.%@AE@%%@NL@%
%@NL@%
_text        segment word public 'code'%@NL@%
        assume        cs:_text, ds:dgroup, es:nothing, ss:dgroup%@NL@%
%@NL@%
%@AB@%; char                        *findone(buffer,bufend)%@AE@%%@NL@%
%@AB@%; char                        *buffer                /* Buffer in which to search */%@AE@%%@NL@%
%@AB@%; char                        *bufend;        /* End of buffer */%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; NOTE: targetlen MUST BE greater than zero%@AE@%%@NL@%
%@NL@%
buffer        equ        word ptr [bp+retlen+2]%@NL@%
bufend        equ        word ptr [bp+retlen+4]%@NL@%
%@NL@%
        EVEN%@NL@%
%@NL@%
        public        _findone%@NL@%
_findone proc        near%@NL@%
        push        bp%@NL@%
        mov        bp,sp%@NL@%
        push        di%@NL@%
        push        si%@NL@%
        push        es%@NL@%
        push        ds                        %@AB@%; ES = DS%@AE@%%@NL@%
        pop        es%@NL@%
        mov        cx,bufend                %@AB@%; CX = end of buffer%@AE@%%@NL@%
        mov        di,buffer                %@AB@%; ES:DI = buffer%@AE@%%@NL@%
        sub        cx,di                        %@AB@%; CX = length of buffer%@AE@%%@NL@%
        jbe        sfnomatch                %@AB@%;  length less than or equal to zero%@AE@%%@NL@%
        mov        dx,_targetlen                %@AB@%; DX = length of target%@AE@%%@NL@%
        dec        dx                        %@AB@%; Decrement it%@AE@%%@NL@%
        sub        cx,dx                        %@AB@%; target must fit in buffer%@AE@%%@NL@%
        jbe        sfnomatch                %@AB@%;  (no match if buffer too short)%@AE@%%@NL@%
%@NL@%
%@AB@%;        CX = buffer length%@AE@%%@NL@%
%@AB@%;        DX = target length (minus first character)%@AE@%%@NL@%
%@AB@%;        ES:DI = buffer pointer%@AE@%%@NL@%
%@NL@%
sf0:        jcxz        sfnomatch                %@AB@%; No match if count zero%@AE@%%@NL@%
        mov        si,offset dgroup:_target %@AB@%; DS:SI = target%@AE@%%@NL@%
        lodsb                                %@AB@%; AL = first byte of target%@AE@%%@NL@%
        repne scasb                        %@AB@%; Look for first character%@AE@%%@NL@%
        jne        sfnomatch                %@AB@%;  jump if not found%@AE@%%@NL@%
        mov        bx,cx                        %@AB@%; BX = buffer length%@AE@%%@NL@%
        mov        ax,di                        %@AB@%; AX = buffer pointer%@AE@%%@NL@%
        mov        cx,dx                        %@AB@%; Get count for cmpsb%@AE@%%@NL@%
        or        cx,cx                        %@AB@%; Zero? (JCXZ doesn't set flag)%@AE@%%@NL@%
        je        sf1                        %@AB@%;  yes, skip compare%@AE@%%@NL@%
        repe cmpsb                        %@AB@%; Do string compare%@AE@%%@NL@%
sf1:        mov        di,ax                        %@AB@%; DI = buffer pointer%@AE@%%@NL@%
        mov        cx,bx                        %@AB@%; CX = buffer length%@AE@%%@NL@%
        jne        sf0                        %@AB@%; Loop if no match%@AE@%%@NL@%
        dec        ax                        %@AB@%; AX = offset of start of match%@AE@%%@NL@%
        jmp        short sf4%@NL@%
%@NL@%
sfnomatch:%@NL@%
        xor        ax,ax                        %@AB@%; No match%@AE@%%@NL@%
sf4:        pop        es%@NL@%
        pop        si%@NL@%
        pop        di%@NL@%
        pop        bp%@NL@%
        ret%@NL@%
_findone endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; int                        revfind(s,c,slen)%@AE@%%@NL@%
%@AB@%; char                        *s;                /* String to search */%@AE@%%@NL@%
%@AB@%; int                        c;                /* Char to search for */%@AE@%%@NL@%
%@AB@%; int                        slen;                /* Length of s */%@AE@%%@NL@%
%@NL@%
s        equ        [bp+retlen+2]%@NL@%
c        equ        [bp+retlen+4]%@NL@%
slen        equ        [bp+retlen+6]%@NL@%
%@NL@%
        EVEN%@NL@%
%@NL@%
        public        _revfind%@NL@%
_revfind proc        near%@NL@%
        push        bp%@NL@%
        mov        bp,sp%@NL@%
        push        di%@NL@%
        push        es%@NL@%
        push        ds%@NL@%
        pop        es%@NL@%
        mov        di,s%@NL@%
        mov        ax,c%@NL@%
        mov        cx,slen%@NL@%
        jcxz        rf1%@NL@%
        std%@NL@%
        repne scasb%@NL@%
        cld%@NL@%
        mov        cx,s%@NL@%
        jne        rf0%@NL@%
        inc        di%@NL@%
rf0:        sub        cx,di%@NL@%
rf1:        mov        ax,cx%@NL@%
        pop        es%@NL@%
        pop        di%@NL@%
        pop        bp%@NL@%
        ret%@NL@%
_revfind endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; int                        countlines(start,finish)%@AE@%%@NL@%
%@AB@%; char                        *start;%@AE@%%@NL@%
%@AB@%; char                        *finish;%@AE@%%@NL@%
%@NL@%
start        equ        [bp+retlen+2]%@NL@%
finish        equ        [bp+retlen+4]%@NL@%
%@NL@%
        EVEN%@NL@%
%@NL@%
        public        _countlines%@NL@%
_countlines proc near%@NL@%
        push        bp%@NL@%
        mov        bp,sp%@NL@%
        push        di%@NL@%
        push        es%@NL@%
        push        ds%@NL@%
        pop        es%@NL@%
        xor        dx,dx                        %@AB@%; Accumulate count in DX%@AE@%%@NL@%
        mov        di,start                %@AB@%; ES:DI points to start%@AE@%%@NL@%
        mov        cx,finish                %@AB@%; Put length in CX%@AE@%%@NL@%
        sub        cx,di%@NL@%
        jbe        cl1                        %@AB@%;  branch if no bytes%@AE@%%@NL@%
        mov        al,0Ah                        %@AB@%; Search for linefeeds%@AE@%%@NL@%
cl0:        jcxz        cl1                        %@AB@%; Exit loop if count zero%@AE@%%@NL@%
        repne scasb                        %@AB@%; Do search%@AE@%%@NL@%
        jne        cl1                        %@AB@%;  branch if none found%@AE@%%@NL@%
        inc        dx                        %@AB@%; Increment count%@AE@%%@NL@%
        jmp        short cl0                %@AB@%; Loop%@AE@%%@NL@%
cl1:        mov        ax,dx                        %@AB@%; Return line count in AX%@AE@%%@NL@%
        pop        es%@NL@%
        pop        di%@NL@%
        pop        bp%@NL@%
        ret%@NL@%
_countlines endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; char                        *findlist(buffer,bufend)%@AE@%%@NL@%
%@AB@%; char                        *buffer;        /* Buffer to search */%@AE@%%@NL@%
%@AB@%; char                        *bufend;        /* End of buffer */%@AE@%%@NL@%
%@NL@%
savesi        equ        word ptr [bp-2]%@NL@%
endbyte        equ        byte ptr [bp-4]%@NL@%
%@NL@%
stringnode struc%@NL@%
        s_alt        dw        ?                %@AB@%; List of alternate portions%@AE@%%@NL@%
        s_suf        dw        ?                %@AB@%; Pointer to suffix string list%@AE@%%@NL@%
        s_must        dw        ?                %@AB@%; Length of portion that must match%@AE@%%@NL@%
stringnode ends%@NL@%
%@NL@%
        EVEN%@NL@%
%@NL@%
flworker dw        findsubi, findsub        %@AB@%; Worker dispatch table%@AE@%%@NL@%
%@NL@%
        public        _findlist%@NL@%
_findlist proc        near%@NL@%
        ASSUME        DS:DGROUP, ES:NOTHING, SS:DGROUP%@NL@%
%@NL@%
        push        bp%@NL@%
        mov        bp,sp%@NL@%
        sub        sp,4                        %@AB@%; Make room for local vars%@AE@%%@NL@%
        push        di%@NL@%
        push        si%@NL@%
        push        ds%@NL@%
        pop        es%@NL@%
    ASSUME        ES:DGROUP%@NL@%
%@NL@%
%@AB@%;        We mark the end of our search buffer with 0FFh so that%@AE@%%@NL@%
%@AB@%;        any comparisons that might run past the end of the buffer%@AE@%%@NL@%
%@AB@%;        will fail on the 0FFh.  We choose 0FFh so that if the%@AE@%%@NL@%
%@AB@%;        comparison fails on it, it will always appear as though%@AE@%%@NL@%
%@AB@%;        the string in the buffer is greater that the string in%@AE@%%@NL@%
%@AB@%;        the search list.  This will prevent us from stopping%@AE@%%@NL@%
%@AB@%;        the search too soon.  Of course, we must restore the byte%@AE@%%@NL@%
%@AB@%;        when we're done.%@AE@%%@NL@%
%@NL@%
        mov        bx,bufend                %@AB@%; BX = end of buffer%@AE@%%@NL@%
        mov        al,0FFh                        %@AB@%; End marker%@AE@%%@NL@%
        xchg        byte ptr [bx],al        %@AB@%; AL = byte after end of buffer%@AE@%%@NL@%
        mov        endbyte,al                %@AB@%; Save the byte%@AE@%%@NL@%
%@NL@%
        mov        cx,bx                        %@AB@%; CX = end of buffer%@AE@%%@NL@%
        mov        si,buffer                %@AB@%; SI = buffer%@AE@%%@NL@%
        sub        cx,si                        %@AB@%; CX = buffer length%@AE@%%@NL@%
        jbe        fl1                        %@AB@%;  no match if empty buffer%@AE@%%@NL@%
        mov        bx,offset dgroup:_transtab %@AB@%; BX = translation table address%@AE@%%@NL@%
%@NL@%
        mov        di,_casesen                %@AB@%; Get flag%@AE@%%@NL@%
        shl        di,1                        %@AB@%; Scale to word index%@AE@%%@NL@%
        call        cs:flworker[di]                %@AB@%; Call helper%@AE@%%@NL@%
        jc        fl1                        %@AB@%;  branch if no match%@AE@%%@NL@%
%@NL@%
%@AB@%;        We have a match%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;        SI = offset of first character past end of matched string%@AE@%%@NL@%
%@AB@%;        savesi = offset of first character past start of matched string%@AE@%%@NL@%
%@NL@%
        mov        ax,savesi                %@AB@%; AX = 1st char past start%@AE@%%@NL@%
        dec        ax                        %@AB@%; AX = start of matched string%@AE@%%@NL@%
        jmp        short fl2%@NL@%
%@NL@%
%@AB@%;        We did not find a match%@AE@%%@NL@%
%@NL@%
fl1:%@NL@%
        xor        ax,ax                        %@AB@%; Return NULL%@AE@%%@NL@%
%@NL@%
%@AB@%;        Restore end byte before leaving%@AE@%%@NL@%
%@NL@%
fl2:%@NL@%
        mov        bx,bufend                %@AB@%; BX = end of buffer%@AE@%%@NL@%
        mov        dl,endbyte                %@AB@%; DL = end byte%@AE@%%@NL@%
        mov        [bx],dl                        %@AB@%; Restore byte%@AE@%%@NL@%
%@NL@%
        pop        si%@NL@%
        pop        di%@NL@%
        mov        sp,bp%@NL@%
        pop        bp%@NL@%
        ret%@NL@%
%@NL@%
_findlist endp%@NL@%
%@NL@%
%@NL@%
%@AB@%;***        findsub - case-sensitive worker for _findlist%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;        This function does most of the work for%@AE@%%@NL@%
%@AB@%;        case-sensitive multi-string searches.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;        ENTRY        BX = address of translation table%@AE@%%@NL@%
%@AB@%;                CX = number of bytes left in buffer%@AE@%%@NL@%
%@AB@%;                DS:SI = buffer pointer%@AE@%%@NL@%
%@AB@%;                SS:BP = pointer to stack frame for _findlist%@AE@%%@NL@%
%@AB@%;        EXIT        Carry set%@AE@%%@NL@%
%@AB@%;                    No match%@AE@%%@NL@%
%@AB@%;                Carry clear%@AE@%%@NL@%
%@AB@%;                    DS:SI = pointer to first character after match%@AE@%%@NL@%
%@AB@%;        USES        AX, CX, DX, DI, SI, Flags%@AE@%%@NL@%
%@NL@%
        EVEN%@NL@%
%@NL@%
        public        findsub, fs0, fs1, fs2, fs3, fs4, fs5, fs6%@NL@%
findsub        proc        near%@NL@%
        ASSUME        DS:DGROUP, ES:DGROUP, SS:DGROUP%@NL@%
%@NL@%
fs0:%@NL@%
        xor        ax,ax                        %@AB@%; AH = 0%@AE@%%@NL@%
%@NL@%
%@AB@%;        AH = 0%@AE@%%@NL@%
%@AB@%;        BX = address of translation table%@AE@%%@NL@%
%@AB@%;        CX = number of bytes left in buffer%@AE@%%@NL@%
%@AB@%;        SI = buffer pointer%@AE@%%@NL@%
%@AB@%;        DS = ES = SS = DGROUP%@AE@%%@NL@%
%@NL@%
fs1:%@NL@%
        lodsb                                %@AB@%; Character in AL%@AE@%%@NL@%
        xlat byte ptr [bx]                %@AB@%; Translate character to index%@AE@%%@NL@%
        or        al,al                        %@AB@%; Zero means invalid 1st byte%@AE@%%@NL@%
        loopz        fs1                        %@AB@%;  if so, try next character%@AE@%%@NL@%
%@NL@%
%@AB@%;        Either the zero bit is set, meaning the buffer is empty,%@AE@%%@NL@%
%@AB@%;        or the zero bit is clear, meaning we have a valid first%@AE@%%@NL@%
%@AB@%;        character.  Either way, CX has been decremented.%@AE@%%@NL@%
%@NL@%
        jz        fs6                        %@AB@%;  branch if buffer empty%@AE@%%@NL@%
        mov        savesi,si                %@AB@%; Save buffer pointer%@AE@%%@NL@%
        shl        ax,1                        %@AB@%; Scale to word index%@AE@%%@NL@%
        mov        di,ax%@NL@%
        mov        di,_stringlist[di]        %@AB@%; DI points to string record%@AE@%%@NL@%
        or        di,di                        %@AB@%; One byte match? (OR clears carry)%@AE@%%@NL@%
        jz        fs3                        %@AB@%;  yes, skip ahead%@AE@%%@NL@%
%@NL@%
%@AB@%;        Loop to search for match.%@AE@%%@NL@%
%@AB@%;        BX = address of translation table%@AE@%%@NL@%
%@AB@%;        DI = pointer to string record%@AE@%%@NL@%
%@AB@%;        SI = pointer into buffer%@AE@%%@NL@%
%@NL@%
fs2:%@NL@%
        mov        cx,[di].s_must                %@AB@%; CX = length of string%@AE@%%@NL@%
        sub        di,cx                        %@AB@%; DI = pointer to string%@AE@%%@NL@%
        mov        dx,si                        %@AB@%; Save pointer to start of suffix%@AE@%%@NL@%
        repe cmpsb                        %@AB@%; Strings match?%@AE@%%@NL@%
        ja        fs4                        %@AB@%;  no, try alternate if follows%@AE@%%@NL@%
        jb        fs5                        %@AB@%;  no, cannot be in this list%@AE@%%@NL@%
        add        di,cx                        %@AB@%; DI = pointer to string record%@AE@%%@NL@%
        mov        di,[di].s_suf                %@AB@%; Get pointer to suffix string list%@AE@%%@NL@%
        or        di,di                        %@AB@%; Is there one? (OR clears carry)%@AE@%%@NL@%
        jnz        fs2                        %@AB@%;  yes, keep looking%@AE@%%@NL@%
%@NL@%
%@AB@%;        Match found%@AE@%%@NL@%
%@NL@%
fs3:%@NL@%
        ret                                %@AB@%;  no, we have a match%@AE@%%@NL@%
%@NL@%
%@AB@%;        Try alternate suffix%@AE@%%@NL@%
%@NL@%
fs4:%@NL@%
        add        di,cx                        %@AB@%; DI = pointer to string record%@AE@%%@NL@%
        mov        di,[di].s_alt                %@AB@%; Get pointer to alternate%@AE@%%@NL@%
        mov        si,dx                        %@AB@%; Restore SI to start of suffix%@AE@%%@NL@%
        or        di,di                        %@AB@%; Is there one?%@AE@%%@NL@%
        jnz        fs2                        %@AB@%;  yes, loop%@AE@%%@NL@%
%@NL@%
%@AB@%;        Try new first character%@AE@%%@NL@%
%@NL@%
fs5:%@NL@%
        mov        cx,bufend                %@AB@%; CX = end of buffer%@AE@%%@NL@%
        mov        si,savesi                %@AB@%; Restore SI to saved value%@AE@%%@NL@%
        sub        cx,si                        %@AB@%; CX = length of buffer%@AE@%%@NL@%
        ja        short fs0                %@AB@%; Try next character in buffer%@AE@%%@NL@%
%@NL@%
%@AB@%;        No match%@AE@%%@NL@%
%@NL@%
fs6:%@NL@%
        stc                                %@AB@%; No match%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
findsub        endp%@NL@%
%@NL@%
%@NL@%
%@AB@%;***        findsubi - case-insensitive worker for _findlist%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;        This function does most of the work for%@AE@%%@NL@%
%@AB@%;        case-insensitive multi-string searches.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;        ENTRY        BX = address of translation table%@AE@%%@NL@%
%@AB@%;                CX = number of bytes left in buffer%@AE@%%@NL@%
%@AB@%;                DS:SI = buffer pointer%@AE@%%@NL@%
%@AB@%;                SS:BP = pointer to stack frame for _findlist%@AE@%%@NL@%
%@AB@%;        EXIT        Carry set%@AE@%%@NL@%
%@AB@%;                    No match%@AE@%%@NL@%
%@AB@%;                Carry clear%@AE@%%@NL@%
%@AB@%;                    DS:SI = pointer to first character after match%@AE@%%@NL@%
%@AB@%;        USES        AX, CX, DX, DI, SI, Flags%@AE@%%@NL@%
%@NL@%
        EVEN%@NL@%
%@NL@%
        public        findsubi%@NL@%
findsubi proc        near%@NL@%
        ASSUME        DS:DGROUP, ES:DGROUP, SS:DGROUP%@NL@%
%@NL@%
fsi0:%@NL@%
        xor        ax,ax                        %@AB@%; AH = 0%@AE@%%@NL@%
%@NL@%
%@AB@%;        AH = 0%@AE@%%@NL@%
%@AB@%;        BX = address of translation table%@AE@%%@NL@%
%@AB@%;        CX = number of bytes left in buffer%@AE@%%@NL@%
%@AB@%;        SI = buffer pointer%@AE@%%@NL@%
%@AB@%;        DS = ES = SS = DGROUP%@AE@%%@NL@%
%@NL@%
fsi1:%@NL@%
        lodsb                                %@AB@%; Character in AL%@AE@%%@NL@%
        xlat byte ptr [bx]                %@AB@%; Translate character to index%@AE@%%@NL@%
        or        al,al                        %@AB@%; Zero means invalid 1st byte%@AE@%%@NL@%
        loopz        fsi1                        %@AB@%;  if so, try next character%@AE@%%@NL@%
%@NL@%
%@AB@%;        Either the zero bit is set, meaning the buffer is empty,%@AE@%%@NL@%
%@AB@%;        or the zero bit is clear, meaning we have a valid first%@AE@%%@NL@%
%@AB@%;        character.  Either way, CX has been decremented.%@AE@%%@NL@%
%@NL@%
        jz        fsi7                        %@AB@%;  branch if buffer empty%@AE@%%@NL@%
        mov        savesi,si                %@AB@%; Save buffer pointer%@AE@%%@NL@%
        shl        ax,1                        %@AB@%; Scale to word index%@AE@%%@NL@%
        mov        di,ax%@NL@%
        mov        di,_stringlist[di]        %@AB@%; DI points to string record%@AE@%%@NL@%
        or        di,di                        %@AB@%; One byte match? (OR clears carry)%@AE@%%@NL@%
        jz        fsi4                        %@AB@%;  yes, skip ahead%@AE@%%@NL@%
%@NL@%
%@AB@%;        Loop to search for match.%@AE@%%@NL@%
%@AB@%;        BX = address of translation table%@AE@%%@NL@%
%@AB@%;        DI = pointer to string record%@AE@%%@NL@%
%@AB@%;        SI = pointer into buffer%@AE@%%@NL@%
%@NL@%
fsi2:%@NL@%
        mov        cx,[di].s_must                %@AB@%; CX = length of string%@AE@%%@NL@%
        sub        di,cx                        %@AB@%; DI = pointer to string%@AE@%%@NL@%
        mov        dx,si                        %@AB@%; Save pointer to start of suffix%@AE@%%@NL@%
fsi3:        lodsb                                %@AB@%; Byte in AL, SI = SI + 1%@AE@%%@NL@%
        mov        ah,[di]                        %@AB@%; Byte in AH, DI = DI + 1%@AE@%%@NL@%
        inc        di%@NL@%
        or        ax,2020h                %@AB@%; Fold bytes onto lower case%@AE@%%@NL@%
        cmp        al,ah                        %@AB@%; Compare bytes%@AE@%%@NL@%
        loope        fsi3                        %@AB@%; Loop while same%@AE@%%@NL@%
        ja        fsi5                        %@AB@%;  no, try alternate if follows%@AE@%%@NL@%
        jb        fsi6                        %@AB@%;  no, cannot be in this list%@AE@%%@NL@%
        add        di,cx                        %@AB@%; DI = pointer to string record%@AE@%%@NL@%
        mov        di,[di].s_suf                %@AB@%; Get pointer to suffix string list%@AE@%%@NL@%
        or        di,di                        %@AB@%; Is there one? (OR clears carry)%@AE@%%@NL@%
        jnz        fsi2                        %@AB@%;  yes, keep looking%@AE@%%@NL@%
%@NL@%
%@AB@%;        Match found%@AE@%%@NL@%
%@NL@%
fsi4:%@NL@%
        ret                                %@AB@%;  no, we have a match%@AE@%%@NL@%
%@NL@%
%@AB@%;        Try alternate suffix%@AE@%%@NL@%
%@NL@%
fsi5:%@NL@%
        add        di,cx                        %@AB@%; DI = pointer to string record%@AE@%%@NL@%
        mov        di,[di].s_alt                %@AB@%; Get pointer to alternate%@AE@%%@NL@%
        mov        si,dx                        %@AB@%; Restore SI to start of suffix%@AE@%%@NL@%
        or        di,di                        %@AB@%; Is there one?%@AE@%%@NL@%
        jnz        fsi2                        %@AB@%;  yes, loop%@AE@%%@NL@%
%@NL@%
%@AB@%;        Try new first character%@AE@%%@NL@%
%@NL@%
fsi6:%@NL@%
        mov        cx,bufend                %@AB@%; CX = end of buffer%@AE@%%@NL@%
        mov        si,savesi                %@AB@%; Restore SI to saved value%@AE@%%@NL@%
        sub        cx,si                        %@AB@%; CX = length of buffer%@AE@%%@NL@%
        ja        short fsi0                %@AB@%; Try next character in buffer%@AE@%%@NL@%
%@NL@%
%@AB@%;        No match%@AE@%%@NL@%
%@NL@%
fsi7:%@NL@%
        stc                                %@AB@%; No match%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
findsubi endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; int                        strnspn(s,t,n)%@AE@%%@NL@%
%@AB@%; char                        *s;                /* String to search */%@AE@%%@NL@%
%@AB@%; char                        *t;                /* Target list */%@AE@%%@NL@%
%@AB@%; int                        n;                /* Length of s */%@AE@%%@NL@%
%@NL@%
s        equ        word ptr [bp+retlen+2]%@NL@%
t        equ        word ptr [bp+retlen+4]%@NL@%
n        equ        word ptr [bp+retlen+6]%@NL@%
%@NL@%
        EVEN%@NL@%
%@NL@%
        public        _strnspn%@NL@%
_strnspn proc        near%@NL@%
        push        bp%@NL@%
        mov        bp,sp%@NL@%
        push        di%@NL@%
        push        si%@NL@%
        push        ds%@NL@%
        pop        es%@NL@%
        cld%@NL@%
        mov        bx,t                        %@AB@%; BX = t%@AE@%%@NL@%
        mov        di,bx                        %@AB@%; DI = t%@AE@%%@NL@%
        xor        al,al                        %@AB@%; Search for 0 byte%@AE@%%@NL@%
        mov        cx,0FFFFh%@NL@%
        repne scasb%@NL@%
        dec        di                        %@AB@%; Back up to 0%@AE@%%@NL@%
        sub        di,bx                        %@AB@%; DI = length of t%@AE@%%@NL@%
        jz        spn1                        %@AB@%; Done if length of t is 0%@AE@%%@NL@%
        mov        dx,di                        %@AB@%; DX = length of t%@AE@%%@NL@%
        mov        si,s                        %@AB@%; SI = s%@AE@%%@NL@%
        mov        cx,n                        %@AB@%; CX = length of s%@AE@%%@NL@%
        jcxz        spn1                        %@AB@%; Check for null string%@AE@%%@NL@%
        push        bp%@NL@%
spn0:        lodsb                                %@AB@%; AL = next char in s%@AE@%%@NL@%
        mov        bp,cx                        %@AB@%; BP = length of s%@AE@%%@NL@%
        mov        cx,dx                        %@AB@%; CX = length of t%@AE@%%@NL@%
        mov        di,bx                        %@AB@%; DI = t%@AE@%%@NL@%
        repne scasb                        %@AB@%; Scan until match found%@AE@%%@NL@%
        mov        cx,bp                        %@AB@%; CX = length of s%@AE@%%@NL@%
        loope        spn0                        %@AB@%; Loop if match found%@AE@%%@NL@%
        pop        bp%@NL@%
        je        spn1                        %@AB@%; Skip ahead if end of s reached%@AE@%%@NL@%
        dec        si                        %@AB@%; Back up one char%@AE@%%@NL@%
spn1:        sub        si,s                        %@AB@%; SI = length of prefix%@AE@%%@NL@%
        mov        ax,si                        %@AB@%; AX = length of prefix%@AE@%%@NL@%
        pop        si%@NL@%
        pop        di%@NL@%
        pop        bp%@NL@%
        ret%@NL@%
_strnspn endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; int                        strncspn(s,t,n)%@AE@%%@NL@%
%@AB@%; char                        *s;                /* String to search */%@AE@%%@NL@%
%@AB@%; char                        *t;                /* Target list */%@AE@%%@NL@%
%@AB@%; int                        n;                /* Length of s */%@AE@%%@NL@%
%@NL@%
        EVEN%@NL@%
%@NL@%
        public        _strncspn%@NL@%
_strncspn proc        near%@NL@%
        push        bp%@NL@%
        mov        bp,sp%@NL@%
        push        di%@NL@%
        push        si%@NL@%
        push        ds%@NL@%
        pop        es%@NL@%
        cld%@NL@%
        mov        bx,t                        %@AB@%; BX = t%@AE@%%@NL@%
        mov        di,bx                        %@AB@%; DI = t%@AE@%%@NL@%
        xor        al,al                        %@AB@%; Search for 0 byte%@AE@%%@NL@%
        mov        cx,0FFFFh%@NL@%
        repne scasb%@NL@%
        dec        di                        %@AB@%; Back up to 0%@AE@%%@NL@%
        sub        di,bx                        %@AB@%; DI = length of t%@AE@%%@NL@%
        mov        ax,n                        %@AB@%; Assume length of t is 0%@AE@%%@NL@%
        jz        cspn2                        %@AB@%; Done if length of t is 0%@AE@%%@NL@%
        mov        dx,di                        %@AB@%; DX = length of t%@AE@%%@NL@%
        mov        si,s                        %@AB@%; SI = s%@AE@%%@NL@%
        mov        cx,ax                        %@AB@%; CX = length of s%@AE@%%@NL@%
        jcxz        cspn1                        %@AB@%; Check for null string%@AE@%%@NL@%
        push        bp%@NL@%
cspn0:        lodsb                                %@AB@%; AL = next char in s%@AE@%%@NL@%
        mov        bp,cx                        %@AB@%; BP = length of s%@AE@%%@NL@%
        mov        cx,dx                        %@AB@%; CX = length of t%@AE@%%@NL@%
        mov        di,bx                        %@AB@%; DI = t%@AE@%%@NL@%
        repne scasb                        %@AB@%; Scan until match found%@AE@%%@NL@%
        mov        cx,bp                        %@AB@%; CX = length of s%@AE@%%@NL@%
        loopne        cspn0                        %@AB@%; Loop if match not found%@AE@%%@NL@%
        pop        bp%@NL@%
        jne        cspn1                        %@AB@%; Skip ahead if end of s reached%@AE@%%@NL@%
        dec        si                        %@AB@%; Back up one char%@AE@%%@NL@%
cspn1:        sub        si,s                        %@AB@%; SI = length of prefix%@AE@%%@NL@%
        mov        ax,si                        %@AB@%; AX = length of prefix%@AE@%%@NL@%
cspn2:        pop        si%@NL@%
        pop        di%@NL@%
        pop        bp%@NL@%
        ret%@NL@%
_strncspn endp%@NL@%
%@NL@%
%@NL@%
%@AB@%;        cmpsen - case-sensitive comparison%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;        ENTRY        DS:SI = buffer%@AE@%%@NL@%
%@AB@%;                ES:DI = string%@AE@%%@NL@%
%@AB@%;                CX = length of string%@AE@%%@NL@%
%@AB@%;        EXIT        CX = length of string unused%@AE@%%@NL@%
%@AB@%;                DI = unused portion of string%@AE@%%@NL@%
%@AB@%;                Z set%@AE@%%@NL@%
%@AB@%;                    match found%@AE@%%@NL@%
%@AB@%;                Z clear%@AE@%%@NL@%
%@AB@%;                    no match%@AE@%%@NL@%
%@AB@%;        USES        CX, DI, SI, Flags%@AE@%%@NL@%
%@NL@%
        EVEN%@NL@%
%@NL@%
cmpsen        proc        near%@NL@%
        repe cmpsb%@NL@%
        ret%@NL@%
cmpsen        endp%@NL@%
%@NL@%
%@NL@%
%@AB@%;        cmpinsen - case-insensitive comparison%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;        ENTRY        DS:SI = buffer%@AE@%%@NL@%
%@AB@%;                ES:DI = string%@AE@%%@NL@%
%@AB@%;                CX = length of string%@AE@%%@NL@%
%@AB@%;        EXIT        CX = length of string unused%@AE@%%@NL@%
%@AB@%;                DI = unused portion of string%@AE@%%@NL@%
%@AB@%;                Z set%@AE@%%@NL@%
%@AB@%;                    match found%@AE@%%@NL@%
%@AB@%;                Z clear%@AE@%%@NL@%
%@AB@%;                    no match%@AE@%%@NL@%
%@AB@%;        USES        AX, CX, DI, SI, Flags%@AE@%%@NL@%
%@NL@%
        EVEN%@NL@%
%@NL@%
cmpinsen proc        near%@NL@%
cmpi0:        lodsb                                %@AB@%; Byte in AL, SI = SI + 1%@AE@%%@NL@%
        mov        ah,[di]                        %@AB@%; Byte in AH, DI = DI + 1%@AE@%%@NL@%
        inc        di%@NL@%
        or        ax,2020h                %@AB@%; Fold bytes onto lower case%@AE@%%@NL@%
        cmp        al,ah                        %@AB@%; Compare bytes%@AE@%%@NL@%
        loope        cmpi0                        %@AB@%; Loop while same%@AE@%%@NL@%
        ret%@NL@%
cmpinsen endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; void                        matchstrings(s1,s2,len,nmatched,leg)%@AE@%%@NL@%
%@AB@%; char                        *s1;                /* First string */%@AE@%%@NL@%
%@AB@%; char                        *s2;                /* Second string */%@AE@%%@NL@%
%@AB@%; int                        len;                /* Length */%@AE@%%@NL@%
%@AB@%; int                        *nmatched;        /* Number of bytes matched */%@AE@%%@NL@%
%@AB@%; int                        *leg;                /* Less than, equal, greater than */%@AE@%%@NL@%
%@NL@%
cm_s1                equ        word ptr [bp+retlen+2]%@NL@%
cm_s2                equ        word ptr [bp+retlen+4]%@NL@%
cm_len                equ        word ptr [bp+retlen+6]%@NL@%
cm_nmatched        equ        word ptr [bp+retlen+8]%@NL@%
cm_leg                equ        word ptr [bp+retlen+10]%@NL@%
%@NL@%
        EVEN%@NL@%
%@NL@%
        public        _matchstrings%@NL@%
_matchstrings proc near%@NL@%
        ASSUME        DS:DGROUP, ES:NOTHING, SS:DGROUP%@NL@%
%@NL@%
        push        bp%@NL@%
        mov        bp,sp%@NL@%
        push        di%@NL@%
        push        si%@NL@%
        push        ds%@NL@%
        pop        es%@NL@%
    ASSUME        ES:DGROUP%@NL@%
        mov        di,cm_s2%@NL@%
        mov        si,cm_s1%@NL@%
        mov        cx,cm_len%@NL@%
        cmp        _casesen,0%@NL@%
        je        cm0%@NL@%
        call        cmpsen%@NL@%
        jmp        short cm1%@NL@%
cm0:        call        cmpinsen%@NL@%
cm1:        mov        bx,cm_leg%@NL@%
        mov        word ptr [bx],0                %@AB@%; Assume equal%@AE@%%@NL@%
        jz        cm2                        %@AB@%;  yes, skip ahead%@AE@%%@NL@%
        mov        word ptr [bx],1                %@AB@%; Assume greater than%@AE@%%@NL@%
        jg        cm1a                        %@AB@%;  yes, skip ahead%@AE@%%@NL@%
        mov        word ptr [bx],-1        %@AB@%; Less than%@AE@%%@NL@%
cm1a:        dec        si%@NL@%
cm2:        sub        si,cm_s1%@NL@%
        mov        bx,cm_nmatched%@NL@%
        mov        [bx],si%@NL@%
        pop        si%@NL@%
        pop        di%@NL@%
        pop        bp%@NL@%
        ret%@NL@%
%@NL@%
_matchstrings endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; int                        strcmp(s1,s2)%@AE@%%@NL@%
%@AB@%; char                        *s1;                /* First string */%@AE@%%@NL@%
%@AB@%; char                        *s2;                /* Second string */%@AE@%%@NL@%
%@NL@%
        public        _strcmp%@NL@%
_strcmp        proc        near%@NL@%
        push        bp%@NL@%
        mov        bp,sp%@NL@%
        push        di%@NL@%
        push        si%@NL@%
        push        ds%@NL@%
        pop        es%@NL@%
        mov        si,[bp+4]                %@AB@%; DS:SI = s1%@AE@%%@NL@%
        mov        di,[bp+6]                %@AB@%; ES:DI = s2%@AE@%%@NL@%
sc0:        lodsb                                %@AB@%; AL = *s1++%@AE@%%@NL@%
        scasb                                %@AB@%; AL - *s2++%@AE@%%@NL@%
        jne        sc1                        %@AB@%;  branch if no match%@AE@%%@NL@%
        or        al,al                        %@AB@%; End of s1?%@AE@%%@NL@%
        jne        sc0                        %@AB@%;  no, loop%@AE@%%@NL@%
        cbw                                %@AB@%; AX = 0%@AE@%%@NL@%
        jmp        short sc2                %@AB@%; Exit%@AE@%%@NL@%
sc1:        mov        ax,1                        %@AB@%; Assume s1 > s2%@AE@%%@NL@%
        jg        sc2                        %@AB@%;  yes, branch%@AE@%%@NL@%
        neg        ax                        %@AB@%; s1 < s2%@AE@%%@NL@%
sc2:        pop        si%@NL@%
        pop        di%@NL@%
        pop        bp%@NL@%
        ret%@NL@%
_strcmp        endp%@NL@%
%@NL@%
%@NL@%
        public        _bpt%@NL@%
_bpt        proc        near%@NL@%
        int        3%@NL@%
        ret%@NL@%
_bpt        endp%@NL@%
%@NL@%
_text        ends%@NL@%
%@NL@%
_data        segment word public 'data'%@NL@%
_data        ends%@NL@%
%@NL@%
end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DATA.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\OPENDLG\DATA.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* DATA.C -- This file contains per process global variables%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%NO_DOS %@NL@%
%@AI@%#define %@AE@%NO_GPI %@NL@%
%@AI@%#include %@AE@%"tool.h" %@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%   This library uses a NON SHARED DATA selector.  This means each%@NL@%
%@AB@%   process using the library gets its own selector, and also that%@NL@%
%@AB@%   values cannot be shared and must be recreated for each process.%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
HMODULE vhModule;            %@AB@%/* Library module handle */%@AE@%%@NL@%
HHEAP  vhheap;               %@AB@%/* Library heap */%@AE@%%@NL@%
%@NL@%
PSTR   vrgsz[CSTRINGS];      %@AB@%/* Array of pointer to our strings (indexed%@NL@%
%@AB@%                                by IDS_... */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DCALC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CALC\DCALC\DCALC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name:        dcalc.c - Dialog form of the Calc application%@NL@%
%@AB@%*%@NL@%
%@AB@%* OS/2 Presentation Manager version of Calc, ported from Windows version%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DEV %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_DOSSEMAPHORES %@NL@%
%@AI@%#define %@AE@%INCL_DOSNLS %@NL@%
%@AI@%#define %@AE@%INCL_ERRORS %@NL@%
%@AI@%#define %@AE@%INCL_WINBUTTONS %@NL@%
%@AI@%#define %@AE@%INCL_WINCLIPBOARD %@NL@%
%@AI@%#define %@AE@%INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINSWITCHLIST %@NL@%
%@AI@%#define %@AE@%INCL_WINTRACKRECT %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%"dcalc.h" %@NL@%
%@NL@%
%@AB@%/************* GLOBAL VARIABLES         */%@AE@%%@NL@%
%@NL@%
char chLastKey, currkey;%@NL@%
char szCalcClass[] = "Calculator";%@NL@%
char szTitle[30];%@NL@%
char szreg1[20], szreg2[20], szmem[20], szregx[20];%@NL@%
%@AB@%/* hope 20 is enough for kanji error string */%@AE@%%@NL@%
char szErrorString[20], szPlusMinus[2];%@NL@%
short charwidth, charheight;%@NL@%
int aspectx, aspecty, nchszstr;%@NL@%
extern BOOL fError  = FALSE;%@NL@%
BOOL fValueInMemory = FALSE;%@NL@%
BOOL fMDown = FALSE;%@NL@%
UCHAR mScan = 0;%@NL@%
%@NL@%
%@AI@%#define %@AE@%TOLOWER(x)   ( (((x) >= 'A') && ((x) <= 'Z')) ? (x)|0x20 : (x)) %@NL@%
%@AI@%#define %@AE@%WIDTHCONST  28 %@NL@%
%@AI@%#define %@AE@%CXCHARS     37 %@NL@%
%@AI@%#define %@AE@%CYCHARS     13 %@NL@%
%@NL@%
HAB hab;%@NL@%
HDC hdcLocal;                            %@AB@%/* Local used for button bitmap */%@AE@%%@NL@%
HPS hpsLocal;%@NL@%
HDC hdcSqr;                            %@AB@%/* Sqr used for square-root bitmap */%@AE@%%@NL@%
HPS hpsSqr;%@NL@%
HBITMAP hbmLocal, hbmSqr;%@NL@%
HMQ  hmqCalc            = NULL;%@NL@%
%@NL@%
HWND hwndCalc            = NULL,%@NL@%
     hwndMenu            = NULL;%@NL@%
%@NL@%
HPOINTER hptrFinger = NULL,%@NL@%
         hptrIcon   = NULL;%@NL@%
%@NL@%
DEVOPENSTRUC dop =                    %@AB@%/* used by DevOpenDC */%@AE@%%@NL@%
{%@NL@%
    NULL, "DISPLAY", NULL, NULL, NULL, NULL, NULL, NULL, NULL%@NL@%
};%@NL@%
%@NL@%
static char bButtonValues[] =            %@AB@%/* Button values */%@AE@%%@NL@%
{%@NL@%
    0xBC, 0xBB, 0xBA, 0xB9,  '0',  '1',  '2',  '3',  '4',%@NL@%
     '5',  '6',  '7',  '8',  '9',  '.',  '/',  '*',  '-',%@NL@%
     '+',  'q',  '%',  'c',  '=', 0xB1, NULL%@NL@%
};%@NL@%
%@NL@%
%@AB@%/************* PROCEDURE DECLARATIONS   */%@AE@%%@NL@%
%@NL@%
MPARAM EXPENTRY AboutDlgProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
BOOL CalcInit(VOID);%@NL@%
VOID CalcPaint( HWND, HPS);%@NL@%
MRESULT EXPENTRY fnDlgCalc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
VOID cdecl main(VOID);%@NL@%
VOID DataXCopy( VOID);%@NL@%
VOID DataXPaste( VOID);%@NL@%
VOID DrawNumbers( HPS);%@NL@%
VOID Evaluate(BYTE);%@NL@%
VOID InitCalc( VOID);%@NL@%
BOOL InterpretChar( CHAR);%@NL@%
VOID ProcessKey(HWND, WPOINT *);%@NL@%
char Translate(WPOINT *);%@NL@%
VOID UpdateDisplay( VOID);%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/********************************************************************%@NL@%
%@AB@%   Write the appropriate number or error string to the display area%@NL@%
%@AB@%   and mark memory-in-use if appropriate.%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
BYTE aszDisplayBuff[20];%@NL@%
%@NL@%
VOID UpdateDisplay()%@NL@%
{%@NL@%
    strcpy(aszDisplayBuff, fError? "Error" :szreg1);%@NL@%
    strcat(aszDisplayBuff, fValueInMemory? " M" : "  ");%@NL@%
%@NL@%
    WinSetDlgItemText(hwndCalc, TXT_RESULT_DISPLAY, aszDisplayBuff);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/**********************************************************************%@NL@%
%@AB@%    Display helpful info%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
MPARAM EXPENTRY AboutDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    if (msg == WM_COMMAND)%@NL@%
    {%@NL@%
        WinDismissDlg(hwnd, TRUE);%@NL@%
        return(MPFROMSHORT(TRUE));%@NL@%
    }%@NL@%
    else return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/**********************************************************************%@NL@%
%@AB@%    General initialization%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
BOOL CalcInit()%@NL@%
{%@NL@%
    hab = WinInitialize(0);%@NL@%
%@NL@%
    hmqCalc = WinCreateMsgQueue( hab, 0);%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/**********************************************************************%@NL@%
%@AB@%    main procedure%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID cdecl main()%@NL@%
{%@NL@%
    QMSG qmsg;%@NL@%
%@NL@%
    if (!CalcInit()) {                            %@AB@%/* general initialization */%@AE@%%@NL@%
        WinAlarm(HWND_DESKTOP, 0xffff);%@NL@%
        goto exit;%@NL@%
    }%@NL@%
%@NL@%
    WinLoadDlg(HWND_DESKTOP, HWND_DESKTOP, fnDlgCalc, NULL, CALCDLG, NULL);%@NL@%
%@NL@%
    if (hwndCalc)%@NL@%
        while (WinGetMsg( hab, (PQMSG)&qmsg, NULL, 0, 0))%@NL@%
            WinDispatchMsg( hab, (PQMSG)&qmsg);%@NL@%
%@NL@%
exit:                                            %@AB@%/* clean up */%@AE@%%@NL@%
%@NL@%
    if (hwndMenu)      WinDestroyWindow(hwndMenu);%@NL@%
%@NL@%
    WinDestroyMsgQueue(hmqCalc);%@NL@%
    WinTerminate(hab);%@NL@%
%@NL@%
    DosExit(EXIT_PROCESS, 0);                    %@AB@%/* exit without error */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*************************************************************************%@NL@%
%@AB@%   Calc Dialog Window Procedure%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@NL@%
USHORT        idProcess, idThread;%@NL@%
SWCNTRL swc;%@NL@%
HSWITCH hsw;%@NL@%
USHORT        usWidthCalc, usHeightCalc;%@NL@%
%@NL@%
MRESULT EXPENTRY fnDlgCalc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    RECTL rectl;%@NL@%
    BOOL fClip;%@NL@%
    USHORT fi, idCtrl;%@NL@%
    MRESULT mresult;%@NL@%
    USHORT  afSWP;%@NL@%
    PSWP    pswp;%@NL@%
%@NL@%
    static BOOL fMinimized;%@NL@%
%@NL@%
%@NL@%
    switch (msg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
%@NL@%
%@AB@%/* Set up the global state assumed by the dialog.%@NL@%
%@AB@% */%@AE@%%@NL@%
        hwndCalc = hwnd;%@NL@%
        hwndMenu = WinLoadMenu(hwnd, NULL, IDR_CALC);%@NL@%
%@NL@%
        fMinimized = FALSE;%@NL@%
%@NL@%
        hptrFinger = WinLoadPointer(HWND_DESKTOP, (HMODULE)NULL, IDP_FINGER);%@NL@%
        hptrIcon   = WinLoadPointer(HWND_DESKTOP, (HMODULE)NULL, IDR_CALC);%@NL@%
%@NL@%
        WinSetWindowULong(hwndCalc, QWL_STYLE,%@NL@%
                          FS_ICON | WinQueryWindowULong(hwndCalc, QWL_STYLE)%@NL@%
                         );%@NL@%
%@NL@%
        WinSendMsg(hwndCalc, WM_SETICON,     (MPARAM) hptrIcon, 0L);%@NL@%
        WinSendMsg(hwndCalc, WM_UPDATEFRAME, (MPARAM) 0L,        0L);%@NL@%
%@NL@%
        WinQueryWindowRect(hwndCalc, &rectl);%@NL@%
         usWidthCalc= (SHORT) (rectl.xRight - rectl.xLeft);%@NL@%
        usHeightCalc= (SHORT) (rectl.yTop   - rectl.yBottom);%@NL@%
%@NL@%
        WinQueryWindowProcess(hwndCalc, &idProcess, &idThread);%@NL@%
%@NL@%
        WinLoadString(NULL, NULL, 1, 30, (PSZ)szTitle);%@NL@%
        WinLoadString(NULL, NULL, 2, 20, (PSZ)szErrorString);%@NL@%
        WinLoadString(NULL, NULL, 3, 2,  (PSZ)szPlusMinus);%@NL@%
%@NL@%
        strcpy(swc.szSwtitle, szTitle);%@NL@%
        swc.hwnd          = hwndCalc;%@NL@%
        swc.hwndIcon          = hptrIcon;%@NL@%
        swc.hprog          = (ULONG)NULL;%@NL@%
        swc.idProcess          = idProcess;%@NL@%
        swc.idSession          = (USHORT)0;%@NL@%
        swc.uchVisibility = SWL_VISIBLE;%@NL@%
        swc.fbJump          = SWL_JUMPABLE;%@NL@%
        hsw                  = WinAddSwitchEntry((PSWCNTRL)&swc);%@NL@%
%@NL@%
        InitCalc();                            %@AB@%/* arithmetic initialization */%@AE@%%@NL@%
%@NL@%
        WinSetActiveWindow(HWND_DESKTOP, hwndCalc);%@NL@%
%@NL@%
        WinSetFocus(HWND_DESKTOP, hwndCalc);%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    case WM_MINMAXFRAME:%@NL@%
%@NL@%
        pswp= PVOIDFROMMP(mp1);%@NL@%
%@NL@%
        if (pswp->fs & SWP_MINIMIZE) fMinimized= TRUE;%@NL@%
        else%@NL@%
            if (pswp->fs & SWP_RESTORE) fMinimized= FALSE;%@NL@%
%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
%@NL@%
        WinDestroyPointer(hptrIcon  );        hptrIcon  = NULL;%@NL@%
        WinDestroyPointer(hptrFinger);        hptrFinger= NULL;%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    case WM_INITMENU:%@NL@%
%@NL@%
        fClip = FALSE;%@NL@%
%@NL@%
        if (WinOpenClipbrd(NULL))%@NL@%
        {%@NL@%
            fClip = WinQueryClipbrdFmtInfo(NULL, CF_TEXT, (USHORT FAR *)&fi);%@NL@%
            WinCloseClipbrd(NULL);%@NL@%
        }%@NL@%
%@NL@%
        WinSendMsg((HWND)mp2, MM_SETITEMATTR,%@NL@%
                   (MPARAM) MAKELONG(CMD_PASTE, TRUE),%@NL@%
                   (MPARAM) MAKELONG(MIA_DISABLED, fClip ? 0 : MIA_DISABLED));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_ADJUSTWINDOWPOS:%@NL@%
%@NL@%
        mresult= WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
%@NL@%
        if (fMinimized) return(mresult);%@NL@%
%@NL@%
        afSWP= (pswp= (PSWP) mp1)->fs;%@NL@%
%@NL@%
        if (         afSWP & (SWP_SIZE     | SWP_MAXIMIZE)%@NL@%
            && !(afSWP &  SWP_MINIMIZE)%@NL@%
           )%@NL@%
        {%@NL@%
            pswp->y += pswp->cy - usHeightCalc;%@NL@%
            pswp->cx =        usWidthCalc;%@NL@%
            pswp->cy = usHeightCalc;%@NL@%
        }%@NL@%
%@NL@%
        return(mresult);%@NL@%
%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
%@NL@%
        fError = FALSE;%@NL@%
%@NL@%
        idCtrl= SHORT1FROMMP(mp1);%@NL@%
%@NL@%
        if (   SHORT1FROMMP(mp2) == BN_CLICKED%@NL@%
            && idCtrl >= BUTTON_MC%@NL@%
            && idCtrl <= BUTTON_CHANGE_SIGN%@NL@%
           )%@NL@%
        {%@NL@%
            Evaluate(bButtonValues[idCtrl-BUTTON_MC]);%@NL@%
            UpdateDisplay();%@NL@%
        }%@NL@%
        else%@NL@%
            switch(idCtrl)%@NL@%
            {%@NL@%
            case CMD_COPY:%@NL@%
                DataXCopy();                        %@AB@%/* copy to clipboard */%@AE@%%@NL@%
                break;%@NL@%
            case CMD_PASTE:%@NL@%
                DataXPaste();                        %@AB@%/* paste from clipboard */%@AE@%%@NL@%
                break;%@NL@%
            case CMD_EXIT:%@NL@%
                WinPostMsg(hwndCalc, WM_QUIT, 0L, 0L);%@NL@%
                break;%@NL@%
            case CMD_ABOUT:%@NL@%
                WinDlgBox(HWND_DESKTOP, hwndCalc, (PFNWP)AboutDlgProc, NULL,%@NL@%
                          1, (PSZ)NULL);%@NL@%
                break;%@NL@%
            }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CLOSE:%@NL@%
        WinPostMsg(hwndCalc, WM_QUIT, 0L, 0L);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CONTROLPOINTER:%@NL@%
        if (!fMinimized) return(hptrFinger);%@NL@%
        else return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
%@NL@%
    case WM_MOUSEMOVE:%@NL@%
        if (!fMinimized) WinSetPointer(HWND_DESKTOP, hptrFinger);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1DOWN:%@NL@%
%@NL@%
        return(WinDefDlgProc(hwnd, WM_TRACKFRAME, (MPARAM) TF_MOVE, mp2));%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CHAR:%@NL@%
%@NL@%
        fError = FALSE;%@NL@%
        if (SHORT1FROMMP(mp1) & KC_KEYUP)%@NL@%
        {%@NL@%
            if (CHAR4FROMMP(mp1) == mScan)%@NL@%
                   fMDown = FALSE;                 %@AB@%/* 'm' key went up */%@AE@%%@NL@%
        }%@NL@%
        else %@NL@%
        {%@NL@%
                if (SHORT1FROMMP(mp1) & KC_CHAR)%@NL@%
      {%@NL@%
             if (InterpretChar((UCHAR)(ULONG)(mp2)))%@NL@%
                  {        %@NL@%
                                UpdateDisplay();%@NL@%
                  }%@NL@%
             else %@NL@%
                  {%@NL@%
                                  if (((UCHAR)(ULONG)(mp2)== 'm') || ((UCHAR)(ULONG)(mp2)== 'M'))%@NL@%
                            {%@NL@%
                                        mScan = CHAR4FROMMP(mp1);           %@AB@%/* save 'm' key scan code  */%@AE@%%@NL@%
                                        fMDown = TRUE;                           %@AB@%/* 'm' key went down       */%@AE@%%@NL@%
                            }%@NL@%
        }%@NL@%
                }%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
%@NL@%
    case WM_ERASEBACKGROUND:%@NL@%
        if (WinQueryWindowULong(hwnd, QWL_STYLE) & WS_MINIMIZED)%@NL@%
            WinValidateRect(hwnd, (PRECTL) mp2, TRUE);%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_SETFOCUS:%@NL@%
        if ((HWNDFROMMP(mp1)==hwndCalc) && !mp2);%@NL@%
            fMDown = FALSE;                        %@AB@%/* since we are losing focus */%@AE@%%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*************************************************************************%@NL@%
%@AB@%    translate & interpret keys (ie. locate in logical keyboard)%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
BOOL InterpretChar(ch)%@NL@%
register CHAR ch;%@NL@%
{%@NL@%
    BOOL fDone;%@NL@%
    CHAR *chstep;%@NL@%
%@NL@%
    fDone = FALSE;%@NL@%
    chstep = bButtonValues;%@NL@%
    switch (ch)%@NL@%
    {%@NL@%
    case 'n':%@NL@%
        ch = szPlusMinus[0];%@NL@%
        break;%@NL@%
    case 27:                        %@AB@%/* xlate Escape into 'c' */%@AE@%%@NL@%
        ch = 'c';%@NL@%
        break;%@NL@%
    case '\r':                      %@AB@%/* xlate Enter into '=' */%@AE@%%@NL@%
        ch = '=';%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    if (fMDown)                     %@AB@%/* Do memory keys */%@AE@%%@NL@%
    {%@NL@%
        switch (ch)%@NL@%
        {%@NL@%
        case 'c':%@NL@%
        case 'C':%@NL@%
            ch = '\274';%@NL@%
            break;%@NL@%
        case 'r':%@NL@%
        case 'R':%@NL@%
            ch = '\273';%@NL@%
            break;%@NL@%
        case '+':%@NL@%
            ch = '\272';%@NL@%
            break;%@NL@%
        case '-':%@NL@%
            ch = '\271';%@NL@%
            break;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    while (!fDone && *chstep)%@NL@%
    {%@NL@%
        if (*chstep++ == ch)%@NL@%
            fDone = TRUE;                %@AB@%/* char found in logical keyboard */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    if (fDone)%@NL@%
    {%@NL@%
        Evaluate(ch);%@NL@%
    }%@NL@%
%@NL@%
    return (fDone);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DDEML.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\DDEML.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name: DDE.C%@NL@%
%@AB@%*%@NL@%
%@AB@%* DDE Manager main module - Contains all exported Dde functions.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created: 12/12/88 Sanford Staab%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%* 4/5/89        sanfords        removed need for hwndFrame registration parameter%@NL@%
%@AB@%* 6/5/90        sanfords        Fixed callbacks so they are blocked during%@NL@%
%@AB@%*                               timeouts.%@NL@%
%@AB@%*                               Fixed SendDDEInit allocation bug.%@NL@%
%@AB@%*                               Added hApp to ConvInfo structure.%@NL@%
%@AB@%*                               Allowed QueryConvInfo() to work on server hConvs.%@NL@%
%@AB@%*                               Added FindFrame() to provide an hApp for Server%@NL@%
%@AB@%*                               hConvs.%@NL@%
%@AB@%* 6/14/90       sanfords        Altered hDatas so they will work when shared%@NL@%
%@AB@%*                               between threads of the same process.  Also%@NL@%
%@AB@%*                               added optimization to only have the hsz%@NL@%
%@AB@%*                               in the hData for local conversations.%@NL@%
%@AB@%* 6/21/90       sanfords        Renamed APIs to Dde....%@NL@%
%@AB@%*                               Finished DdeAppNameServer() implementation.%@NL@%
%@AB@%*                       %@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"ddemlp.h"  %@NL@%
%@AI@%#include %@AE@%"version.h" %@NL@%
%@NL@%
%@AB@%/****** Globals *******/%@AE@%%@NL@%
%@NL@%
HMODULE hmodDmg = 0;        %@AB@%/* initialized by LoadProc on DLL initialization */%@AE@%%@NL@%
PFNWP lpfnFrameWndProc = 0;             %@AB@%/* system Frame window procedure */%@AE@%%@NL@%
%@NL@%
HHEAP hheapDmg = 0;                     %@AB@%/* main DLL heap */%@AE@%%@NL@%
%@NL@%
PHATOMTBL aAtbls;%@NL@%
USHORT cAtbls = 0;%@NL@%
USHORT iAtblCurrent = 0;%@NL@%
USHORT   cMonitor = 0;%@NL@%
DOSFSRSEM FSRSemDmg;                    %@AB@%/* used to protect globals */%@AE@%%@NL@%
USHORT cAtoms = 0;                      %@AB@%/* for debugging! */%@AE@%%@NL@%
%@NL@%
PAPPINFO pAppInfoList = NULL;           %@AB@%/* registered thread data list */%@AE@%%@NL@%
USHORT usHugeShift;                     %@AB@%/* for huge segment support */%@AE@%%@NL@%
USHORT usHugeAdd;                       %@AB@%/* for huge segment support */%@AE@%%@NL@%
COUNTRYCODE syscc;%@NL@%
%@NL@%
BOOL fInSubset(PCQDATA pcqd, ULONG afCmd);%@NL@%
%@NL@%
%@AB@%/* PUBDOC START *\%@NL@%
%@AB@%DLL overview:%@NL@%
%@AB@%%@NL@%
%@AB@%This DLL supports standard DDE communication on behalf of its client%@NL@%
%@AB@%applications.  It is compatable with most existing DDE programs.  The%@NL@%
%@AB@%API interface features object-like abstractions that allow its implementation%@NL@%
%@AB@%on and across a variety of platforms.%@NL@%
%@AB@%%@NL@%
%@AB@%Main features:%@NL@%
%@AB@%%@NL@%
%@AB@%  * HSZ manager:    Allows more efficient handling of numerous character%@NL@%
%@AB@%                    strings without the limitations of the atom manager.%@NL@%
%@AB@%                    %@NL@%
%@AB@%  * HDATA manager:  Data container objects allow easy filling, accessing%@NL@%
%@AB@%                    and reuse of huge amounts of data and allow a%@NL@%
%@AB@%                    server to efficiently support several clients.%@NL@%
%@AB@%                    %@NL@%
%@AB@%  * Controled initiates: Supports client to multi-server initiates and%@NL@%
%@AB@%                    allows a client application to pick and choose which%@NL@%
%@AB@%                    conversations to keep.%@NL@%
%@AB@%%@NL@%
%@AB@%  * Debugging support: Allows monitoring applications to be easily written%@NL@%
%@AB@%                    and provides readable error messages.  %@NL@%
%@AB@%%@NL@%
%@AB@%  * Huge Segment support: Exports a useful huge segment copy function and%@NL@%
%@AB@%                    properly handles huge data transfers.%@NL@%
%@AB@%%@NL@%
%@AB@%  * Synchronous communication:  Clients may use a very simple form of%@NL@%
%@AB@%                    transaction processing that requires little application%@NL@%
%@AB@%                    support.%@NL@%
%@AB@%%@NL@%
%@AB@%  * Asynchronous communication:  Clients may opt to use queued transfers%@NL@%
%@AB@%                    freeing them to do other tasks in parellel with DDE.%@NL@%
%@AB@%%@NL@%
%@AB@%  * Callback control:  Applications may selectively suspend DLL callbacks%@NL@%
%@AB@%                    to themselves when in time critical sections.  Selected%@NL@%
%@AB@%                    conversations can be blocked while being serviced so%@NL@%
%@AB@%                    others can be processed by the same thread.%@NL@%
%@AB@%%@NL@%
%@AB@%  * registration notification: All applications using this DLL are notified%@NL@%
%@AB@%                    whenever any other application registers or unregisters%@NL@%
%@AB@%                    itself with this DLL.  This enables nameserver support%@NL@%
%@AB@%                    for DDE.%@NL@%
%@AB@%%@NL@%
%@AB@%  * multiple DDE entity support:  An application can register itself with%@NL@%
%@AB@%                    any number of application names and can change what%@NL@%
%@AB@%                    application names it responds to at any time.  Each%@NL@%
%@AB@%                    registered thread is a seperate DDE entity.%@NL@%
%@AB@%%@NL@%
%@AB@%  * advise loop control:  Advise loops are tracked by the DLL, however%@NL@%
%@AB@%                    server applications have complete control over%@NL@%
%@AB@%                    advise loop initiation.%@NL@%
%@AB@%%@NL@%
%@AB@%  * network agent support: Special agent applications can register with this%@NL@%
%@AB@%                    DLL to represent multiple applications on other machines%@NL@%
%@AB@%                    or platforms.%@NL@%
%@AB@%                    %@NL@%
%@AB@%API specifications:%@NL@%
%@AB@%%@NL@%
%@AB@%Callback function:%@NL@%
%@AB@%    %@NL@%
%@AB@%EXPENTRY Callback(%@NL@%
%@AB@%HCONV hConv,        // holds server conversation handle in most cases%@NL@%
%@AB@%HSZ hszTopic,       // holds topic hsz for transaction%@NL@%
%@AB@%HSZ hszItem,        // holds item or application hsz for transaction%@NL@%
%@AB@%USHORT usFormat,    // holds data format when applicable%@NL@%
%@AB@%USHORT usType,      // holds transaction type code%@NL@%
%@AB@%HDMGDATA hDmgData); // holds incomming data in most cases%@NL@%
%@AB@%%@NL@%
%@AB@%This is the definition of the data call-back function that an%@NL@%
%@AB@%application must export so that the DDE can initiate interaction%@NL@%
%@AB@%with the application when necessary.  This function is refered to in%@NL@%
%@AB@%the DdeInitialize() call.%@NL@%
%@AB@%%@NL@%
%@AB@%The application callback function is very much like a PM window %@NL@%
%@AB@%procedure for DDE.  The usType specifies the type of transaction being %@NL@%
%@AB@%done.  By ANDing this parameter with XCLASS_MASK and comparing the %@NL@%
%@AB@%result with the XCLASS_ constants, the transaction return type %@NL@%
%@AB@%expected can be classified.%@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_ constants also may contain the XTYPF_NOBLOCK flag.  The presence%@NL@%
%@AB@%of this flag indicates that the CBR_BLOCK return value from the callback%@NL@%
%@AB@%will not be honored by the DDE.  (see DdeEnableCallback() for more%@NL@%
%@AB@%information on this concept.)%@NL@%
%@AB@%%@NL@%
%@AB@%The various transactions are explained below:%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%-----XCLASS_NOTIFICATION class:%@NL@%
%@AB@%    These are strictly notification messages to an application.  The return%@NL@%
%@AB@%    value is ignored except in the case of CBR_BLOCK. (if the notification%@NL@%
%@AB@%    is blockable)%@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_RTNPKT%@NL@%
%@AB@%%@NL@%
%@AB@%   This transaction is sent to agent applications.  hDmgData contains a %@NL@%
%@AB@%   packet to send to the agent who's handle is in the hszItem parameter.  %@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_REGISTER%@NL@%
%@AB@%%@NL@%
%@AB@%   Another server name has just been registered with the DLL application %@NL@%
%@AB@%   name server.  hszItem is set to the application name being %@NL@%
%@AB@%   registered.  If this is NULL, an application has registered itself as %@NL@%
%@AB@%   WILD.  hDmgData is set to the application handle that registered.%@NL@%
%@AB@%   This is not blockable by CBR_BLOCK because no hConv is %@NL@%
%@AB@%   associated with it.  Only if all callbacks are disabled is this %@NL@%
%@AB@%   transaction blocked.%@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_UNREGISTER%@NL@%
%@AB@%%@NL@%
%@AB@%   Another server application has just unregistered a name with this %@NL@%
%@AB@%   DLL.  hszItem is set to the application name being unregistered.%@NL@%
%@AB@%   hDmgData is set to the app handle of the unregistering application.%@NL@%
%@AB@%   This is not blockable by CBR_BLOCK because no hConv is associated %@NL@%
%@AB@%   with it.  Only if all callbacks are disabled is this transaction %@NL@%
%@AB@%   blocked.%@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_INIT_CONFIRM%@NL@%
%@AB@%%@NL@%
%@AB@%   Sent to let a server know that a conversation on application hszItem %@NL@%
%@AB@%   and Topic hszTopic has been established on hConv.  hConv uniquely %@NL@%
%@AB@%   identifies this conversation from the server's prospective.  This %@NL@%
%@AB@%   call cannot be blocked because it is part of the DDE initiate %@NL@%
%@AB@%   sequence.  This callback is generated by the results of XTYP_INIT and %@NL@%
%@AB@%   XTYP_WILDINIT callbacks.  %@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_TERM%@NL@%
%@AB@%%@NL@%
%@AB@%   This is a notification telling a server application that a %@NL@%
%@AB@%   conversation has been terminated.  hConv is set to identify which %@NL@%
%@AB@%   conversation was terminated.  %@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_ADVSTOP%@NL@%
%@AB@%%@NL@%
%@AB@%   This notifies a server that an advise loop is stopping.  hszTopic, %@NL@%
%@AB@%   hszItem, and usFormat identify the advise loop within hConv.  %@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_XFERCOMPLETE%@NL@%
%@AB@%%@NL@%
%@AB@%   This notifictaion is sent to a client when an asynchronous data %@NL@%
%@AB@%   DdeClientXfer() transaction is completed.  hDmgData is the client %@NL@%
%@AB@%   queue ID of the completed transaction.  hConv is the client %@NL@%
%@AB@%   conversation handle.  %@NL@%
%@AB@%    %@NL@%
%@AB@%XTYP_MONITOR%@NL@%
%@AB@%%@NL@%
%@AB@%   This notifies an app registered as DMGCMD_MONITOR of DDE data that is %@NL@%
%@AB@%   being transmitted.  hDmgData contains a text string representing the %@NL@%
%@AB@%   transaction suitable for printing on a terminal, file, or window.  %@NL@%
%@AB@%   Note that this monitors ALL DDE communication and may be extensive.  %@NL@%
%@AB@%   This call cannot be delayed by disabled callbacks.  This transaction %@NL@%
%@AB@%   is not blockable.  %@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_ACK%@NL@%
%@AB@%%@NL@%
%@AB@%   This notifies a server that it has received an acknowledge from data %@NL@%
%@AB@%   it has sent a client.  The hConv, topic, item, and format are set %@NL@%
%@AB@%   apropriately.  LOUSHORT(hDmgData) will contain the dde flags from the %@NL@%
%@AB@%   ack.  %@NL@%
%@AB@%%@NL@%
%@AB@%-----XCLASS_DATA class:%@NL@%
%@AB@%%@NL@%
%@AB@%   Transactions in this class are expected to return an HDMGDATA or 0 as %@NL@%
%@AB@%   apropriate.  %@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_PKT%@NL@%
%@AB@%%@NL@%
%@AB@%   This transaction is sent to agent applications.  hDmgData contains a %@NL@%
%@AB@%   packet to send.  hszItem contains the agent handle to send the data %@NL@%
%@AB@%   to.  hConv is set to the associated conversation handle.  The return %@NL@%
%@AB@%   packet received from the partner agent should be returned.  This %@NL@%
%@AB@%   call is blockable.%@NL@%
%@AB@%%@NL@%
%@AB@%   If blocked, the conversation will be unblocked and processed by %@NL@%
%@AB@%   DdeProcessPkt() when the return packet is received.  It is a good %@NL@%
%@AB@%   idea for the agent to remember the hConv parameter in case the return %@NL@%
%@AB@%   packet does not arrive within a reasonable amount of time via %@NL@%
%@AB@%   XTYP_RTNPKT.  If an agent determines that it wishes to kill a %@NL@%
%@AB@%   conversation, it should call DdeDisconnect().  %@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_REQUEST%@NL@%
%@AB@%XTYP_ADVREQ%@NL@%
%@AB@%%@NL@%
%@AB@%   Data is being requested from a server application.  The function %@NL@%
%@AB@%   should create a hDmgData using the DdePutData() function and %@NL@%
%@AB@%   return it.  XTYP_ADVREQ origonates from a DdePostAdvise() call %@NL@%
%@AB@%   while XTYP_REQUEST origonates from a client data request.  %@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_WILDINIT%@NL@%
%@AB@%%@NL@%
%@AB@%   This is asking a DDE server permission to make multiple connections %@NL@%
%@AB@%   with a specific client.%@NL@%
%@AB@%%@NL@%
%@AB@%   hszItem may be the application name the client is requesting or it %@NL@%
%@AB@%   may be NULL indicating a wild application name.  hszTopic may be the %@NL@%
%@AB@%   Topic requested or NULL indicating a wild topic.  If not NULL, %@NL@%
%@AB@%   hDmgData contains a CONVCONTEXT structure.  All other parameters are %@NL@%
%@AB@%   0 or NULL.%@NL@%
%@AB@%%@NL@%
%@AB@%   For local initiates, (initiates with the server application itself) %@NL@%
%@AB@%   The server should return a 0 terminated (ie hszApp = hszTopic = 0) %@NL@%
%@AB@%   array of HSZPAIR structures using DdePutData() and %@NL@%
%@AB@%   DdeAddData().  Each hsz pair represents an app/topic the server %@NL@%
%@AB@%   wishes to support.  Each created conversation will result in an %@NL@%
%@AB@%   XTYP_INIT_CONFIRM notification.  If 0 is returned, no connections are %@NL@%
%@AB@%   made with the requesting client.  This call is made even if callbacks %@NL@%
%@AB@%   are disabled due the the synchronous nature of DDE initiates.  This %@NL@%
%@AB@%   callback cannot be blocked by returning CBR_BLOCK.  %@NL@%
%@AB@%%@NL@%
%@AB@%   Agent applications may also process this transaction as a %@NL@%
%@AB@%   representative initiate.  The agent is expected to package this %@NL@%
%@AB@%   transaction using DdeCreateInitPkt() and broadcast it to all %@NL@%
%@AB@%   apropriate agents along its communication channel.  It then must %@NL@%
%@AB@%   collect the return packets and for each packet and call %@NL@%
%@AB@%   DdeProcessPkt().  Representative initiates are synchronous in that %@NL@%
%@AB@%   the agent cannot return from this callback until all initiate return %@NL@%
%@AB@%   packets are returned.  Representative initiates do NOT result in any %@NL@%
%@AB@%   XTYP_INIT_CONFIRM notifications to the agent.  The agent is then free %@NL@%
%@AB@%   to process this transaction for local connections as described.  %@NL@%
%@AB@%%@NL@%
%@AB@%-----XCLASS_BOOL class:%@NL@%
%@AB@%%@NL@%
%@AB@%   Transactions in this class expect a BOOL return of TRUE or FALSE.  %@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_INIT%@NL@%
%@AB@%%@NL@%
%@AB@%   This is a query asking a DDE server permission to connect to a %@NL@%
%@AB@%   specific client.  hszItem is set to the Application name.  hszTopic %@NL@%
%@AB@%   is set to the topic name.  hDmgData if not NULL, contains CONVCONTEXT %@NL@%
%@AB@%   data.  All other parameters are 0 or NULL.  A TRUE return value %@NL@%
%@AB@%   allows the Dde to start up a server on the app/topic specified.  %@NL@%
%@AB@%   This will result in an XTYP_INIT_CONFIRM callback.  This call is made %@NL@%
%@AB@%   even if callbacks are disabled due the the synchronous nature of DDE %@NL@%
%@AB@%   initiates.  %@NL@%
%@AB@%    %@NL@%
%@AB@%   Agent applications may process this transaction as a representative %@NL@%
%@AB@%   transaction.  The agent is expected to package this transaction using %@NL@%
%@AB@%   DdeCreateInitPkt() and broadcast it to all apropriate agents along %@NL@%
%@AB@%   its communication channel.  It then must collect the return packets %@NL@%
%@AB@%   and for each packet call DdeProcessPkt().  This will NOT result in %@NL@%
%@AB@%   any XTYP_INIT_CONFIRM notifications to the agent.  The agent is then %@NL@%
%@AB@%   free to process this transaction for local connections.  %@NL@%
%@AB@%%@NL@%
%@AB@%    A FALSE return implies no local initiate permissions are granted.%@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_ADVSTART%@NL@%
%@AB@%%@NL@%
%@AB@%   This transaction requests permission to start a DDE advise loop with %@NL@%
%@AB@%   a server.  The hszTopic, hszItem, and usFormat identify the advise %@NL@%
%@AB@%   loop.  If FALSE is returned, the advise loop will not be started.  %@NL@%
%@AB@%%@NL@%
%@AB@%-----XCLASS_FLAGS Class:%@NL@%
%@AB@%%@NL@%
%@AB@%   Transactions in this class have hDmgData set.  An application should %@NL@%
%@AB@%   use the DLL Data functions to extract the data from hDmgData.  The %@NL@%
%@AB@%   return value should be the DDE fsStatus flags the app desires to %@NL@%
%@AB@%   return to the client application.  If DDE_FACK is set, DDE_FBUSY and %@NL@%
%@AB@%   DDE_FNOTPROCESSED are ignored.  %@NL@%
%@AB@%%@NL@%
%@AB@%   The only flags the Dde expects to be returned are:%@NL@%
%@AB@%        DDE_FACK%@NL@%
%@AB@%        DDE_FBUSY%@NL@%
%@AB@%        DDE_FNOTPROCESSED%@NL@%
%@AB@%        any DDE_APPSTATUS bits%@NL@%
%@AB@%        %@NL@%
%@AB@%   All other bits will be stripped out by the Dde before sending an %@NL@%
%@AB@%   ack message.  %@NL@%
%@AB@%%@NL@%
%@AB@%   A 0 return is equivalent to DDE_NOTPROCESSED.  %@NL@%
%@AB@%%@NL@%
%@AB@%XTYP_EXEC%@NL@%
%@AB@%%@NL@%
%@AB@%   hDmgData contains an execute string from a client.  hConv, hszTopic, %@NL@%
%@AB@%   hszItem are set.  If the WM_DDE_EXECUTE message received had the same %@NL@%
%@AB@%   string for the itemname as for the data, hszItem will be 0L.  This %@NL@%
%@AB@%   provides for EXCEL EXECUTE compatibility without requireing the %@NL@%
%@AB@%   creation of an HSZ for the data string.  Applications are advised to %@NL@%
%@AB@%   ignore the hszItem parameter for execute transactions since newer DDE %@NL@%
%@AB@%   specifications ignore this value.  %@NL@%
%@AB@%  %@NL@%
%@AB@%XTYP_POKE%@NL@%
%@AB@%%@NL@%
%@AB@%   Similar to XTYP_EXEC but hDmgData contains data poked to the server.  %@NL@%
%@AB@%  %@NL@%
%@AB@%XTYP_ADVDATA - advise data for a client!%@NL@%
%@AB@%%@NL@%
%@AB@%   Note that XTYP_ADVDATA is for advise loop data intended for the %@NL@%
%@AB@%   CLIENT not the server.  If the advise loop in progress is of the %@NL@%
%@AB@%   NODATA type, hDmgData will be 0.  %@NL@%
%@AB@%%@NL@%
%@AB@%-----Agent Transfers:%@NL@%
%@AB@%%@NL@%
%@AB@%   A DDE agent application is one which registers itself with the %@NL@%
%@AB@%   DMGCMD_AGENT flag.  Agent applications represent any number of other %@NL@%
%@AB@%   applications across its communications channel.  Agent applications %@NL@%
%@AB@%   are only allowed to communicate locally with other non-agent %@NL@%
%@AB@%   applications.  This prevents communication loops from forming across %@NL@%
%@AB@%   communication channels.  Any number of agents may register with the %@NL@%
%@AB@%   DLL but each agent should represent a different communication %@NL@%
%@AB@%   channel, one which is orthogonal to all other agents.  It is the %@NL@%
%@AB@%   users responsability to only start up orthogonal agents.  %@NL@%
%@AB@%%@NL@%
%@AB@%   Agents are responsible for handling and updating any DDE nameservers %@NL@%
%@AB@%   associated with their communicaton channels.  Since agent %@NL@%
%@AB@%   applications can converse directly with non-agent applications, they %@NL@%
%@AB@%   can set up advise loops on the SysTopic/Topics items of local %@NL@%
%@AB@%   applications to update the nameserver for the communication channel %@NL@%
%@AB@%   if they wish to support DDE topics.  This may be impossible with some %@NL@%
%@AB@%   DDE applications which either do not support the SysTopic/Topics item %@NL@%
%@AB@%   or which have an unenumerable set of topics they support.  For %@NL@%
%@AB@%   application name servers the DdeAppNameServer() function is %@NL@%
%@AB@%   provided to give agents a local application name server from which to %@NL@%
%@AB@%   draw on.  %@NL@%
%@AB@%%@NL@%
%@AB@%   In general, an agent administers two classes of conversations.  One %@NL@%
%@AB@%   is direct conversations with itself and local non-agent applications.  %@NL@%
%@AB@%   These transactions would be handled by the agent exactly like any %@NL@%
%@AB@%   non-agent application would handle them.  %@NL@%
%@AB@%%@NL@%
%@AB@%   The other class is representative conversations which the agent %@NL@%
%@AB@%   passes over its communication channel.  In general, representative %@NL@%
%@AB@%   conversation callbacks to the agent are only XTYP_PKT or XTYP_RTNPKT %@NL@%
%@AB@%   type transactions or specially handled initiate transactions.  %@NL@%
%@AB@%%@NL@%
%@AB@%   Agent applications are responsible for providing a unique ULONG agent %@NL@%
%@AB@%   handle for every agent it is communicating with on its communication %@NL@%
%@AB@%   channel.  The handle is provided by the agent whenever it calls %@NL@%
%@AB@%   DdeProcessPkt().  Agent handles need not be global to the channel %@NL@%
%@AB@%   since only the agent that created the handle will be expected to use %@NL@%
%@AB@%   it.  Agent handles should not change over the life of a conversation.%@NL@%
%@AB@%%@NL@%
%@AB@%   Should it be necessary to allow agents to alter or convert packet %@NL@%
%@AB@%   data, the format of the packets can be documented later.  %@NL@%
%@AB@%%@NL@%
%@AB@%   To show how an agent would handle its callback function, the %@NL@%
%@AB@%   following pseudo code is offered as a model: %@NL@%
%@AB@%%@NL@%
%@AB@%ReceivePkt(pBits, cb, hAgentFrom)    \\ gets called when a packet arrives %@NL@%
%@AB@%{%@NL@%
%@AB@%    hPkt = DdePutData(pBits, cb, 0, 0, 0, 0);%@NL@%
%@AB@%    if (hDmgData = ProcessPkt(hPkt, hAgentFrom))%@NL@%
%@AB@%        PassPkt(hDmgData, hAgentFrom);  \\ agent function to send pkt %@NL@%
%@AB@%}%@NL@%
%@AB@%    %@NL@%
%@AB@%AgentCallback(hConv, hszTopic, hszItem, usFormat, usType, hDmgData)%@NL@%
%@AB@%{%@NL@%
%@AB@%    switch (usType) {%@NL@%
%@AB@%    case XTYP_INIT:%@NL@%
%@AB@%    case XTYP_WILDINIT:%@NL@%
%@AB@%        \\%@NL@%
%@AB@%        \\ process representative initiates%@NL@%
%@AB@%        \\%@NL@%
%@AB@%        QueryInterestedAgents(hszApp, hszTopic, pAgents);%@NL@%
%@AB@%        hDmgData = DdeCreateInitPkt(hszTopic, hszItem, hDmgData);%@NL@%
%@AB@%        BroadcastPkt(hDmgData, pAgents);%@NL@%
%@AB@%        \\%@NL@%
%@AB@%        \\ agent blocks here till all are in or timeout.%@NL@%
%@AB@%        \\ Packets get sent to ReceivePkt()%@NL@%
%@AB@%        \\%@NL@%
%@AB@%        CollectRtnPkts(pAgents); %@NL@%
%@AB@%        \\  %@NL@%
%@AB@%        \\ now agent does his own processing of local inits.%@NL@%
%@AB@%        \\ retval == 0 if not interested.%@NL@%
%@AB@%        \\%@NL@%
%@AB@%        return(retval);%@NL@%
%@AB@%        break;%@NL@%
%@AB@%%@NL@%
%@AB@%    case XTYP_RTNPKT:%@NL@%
%@AB@%        RemoveFromDeadCheckQ(hConv);%@NL@%
%@AB@%        PassPkt(hDmgData, hszItem); \\ hDmgData==Pkt, hszItem==hAgentTo %@NL@%
%@AB@%        return(0);%@NL@%
%@AB@%        break;%@NL@%
%@AB@%        %@NL@%
%@AB@%    case XTYP_PKT:%@NL@%
%@AB@%        if (FindIgnoreList(hConv) { \\ was this unblocked due to no rtn pkt? %@NL@%
%@AB@%            RemoveFromIgnoreList(hConv);%@NL@%
%@AB@%            return(0);  \\ rtn pkt failure.%@NL@%
%@AB@%        }%@NL@%
%@AB@%        if (!PassPkt(hDmgData, hszItem))  \\ hDmgData==Pkt, hszItem==hAgentTo %@NL@%
%@AB@%            return(0);  \\ packet send failure. %@NL@%
%@AB@%        AddToDeadCheckQ(hConv, timenow());%@NL@%
%@AB@%        return(CBR_BLOCK);  \\ will be unblocked and handled by ProcessPkt() %@NL@%
%@AB@%        break;%@NL@%
%@AB@%%@NL@%
%@AB@%    case XTYP_REGISTER:%@NL@%
%@AB@%    case XTYP_UNREGISTER:%@NL@%
%@AB@%        \\%@NL@%
%@AB@%        \\ agent updates its communications name server.%@NL@%
%@AB@%        \\%@NL@%
%@AB@%        return(0);%@NL@%
%@AB@%        break;%@NL@%
%@AB@%%@NL@%
%@AB@%    default:%@NL@%
%@AB@%        \\%@NL@%
%@AB@%        \\ the rest would reference local conversatoins that the agent%@NL@%
%@AB@%        \\ is maintaining.%@NL@%
%@AB@%        \\%@NL@%
%@AB@%        break;%@NL@%
%@AB@%    }%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%UnblockDeadTransaction(hConv) \\ called when no rtn pkt for hConv has been%@NL@%
%@AB@%                              \\ received for a long time. %@NL@%
%@AB@%{%@NL@%
%@AB@%    RemoveFromDeadCheckQ(hConv);%@NL@%
%@AB@%    AddToIgnoreList(hConv);%@NL@%
%@AB@%    DdeEnableCallback(CBK_ENABLE, hConv);%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%\* PUBDOC END */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* USHORT EXPENTRY DdeInitialize(pfnCallback, afCmd, ulRes)%@NL@%
%@AB@%* PFNCALLBACK pfnCallback;  // address to application callback function%@NL@%
%@AB@%* ULONG afCmd;              // registration command flags%@NL@%
%@AB@%* ULONG ulRes;              // currently reserved, must be 0L.%@NL@%
%@AB@%* %@NL@%
%@AB@%*     This API is used to initialize the DDEML for an application thread.%@NL@%
%@AB@%* %@NL@%
%@AB@%*     afCmd - is a set of DMGCMD_ flags for special initialization instructions.%@NL@%
%@AB@%* %@NL@%
%@AB@%*     DMGCMD_AGENT%@NL@%
%@AB@%*         The registering application represents more than one DDE application.%@NL@%
%@AB@%*         Agents are never allowed to establish a conversation with%@NL@%
%@AB@%*         another agent.  See Agent Transactions.%@NL@%
%@AB@%* %@NL@%
%@AB@%*     DMGCMD_MONITOR%@NL@%
%@AB@%*%@NL@%
%@AB@%*         This defines the registered application as a DDE transaction %@NL@%
%@AB@%*         monitor.  This is primarily used for debugging DDE %@NL@%
%@AB@%*         applications.  A monitoring application will have its Callback %@NL@%
%@AB@%*         function called every time a DDE message is sent.%@NL@%
%@AB@%* %@NL@%
%@AB@%*         This flag is exclusive of all others.  No other flags should be%@NL@%
%@AB@%*         or'ed in with this one.%@NL@%
%@AB@%* %@NL@%
%@AB@%*    DMGCMD_CLIENTONLY%@NL@%
%@AB@%*        This should be specified when the application only intends to%@NL@%
%@AB@%*        be a DDE client.  This reduces the resource consumption of the DLL.%@NL@%
%@AB@%*        %@NL@%
%@AB@%*     Registration is on a per-thread basis.  Thus a multi-threaded application%@NL@%
%@AB@%*     could register several threads as seperate DDE entities.  %@NL@%
%@AB@%* %@NL@%
%@AB@%*     returns any applicable DMGERR_ error code or 0 on success.%@NL@%
%@AB@%*%@NL@%
%@AB@%*     Most other DLL APIs will fail if the calling thread has not called this.%@NL@%
%@AB@%* %@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%* %@NL@%
%@AB@%* Registration causes the following windows to be created:%@NL@%
%@AB@%* %@NL@%
%@AB@%* HWND_OBJECT%@NL@%
%@AB@%*   hwndDmg(s)%@NL@%
%@AB@%*       hwndClient(s)%@NL@%
%@AB@%*   hwndTopicServer(s)%@NL@%
%@AB@%*       hwndServer(s)%@NL@%
%@AB@%*   hwndMonitor(s)%@NL@%
%@AB@%* HWND_DESKTOP%@NL@%
%@AB@%*   hwndFrame(s)%@NL@%
%@AB@%* %@NL@%
%@AB@%*   See api.doc file for usage info.%@NL@%
%@AB@%* %@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/14/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
USHORT EXPENTRY DdeInitialize(pfnCallback, afCmd, ulRes)%@NL@%
PFNCALLBACK pfnCallback;%@NL@%
ULONG afCmd;%@NL@%
ULONG ulRes; %@NL@%
{%@NL@%
    if (ulRes != 0L || CheckSel(SELECTOROF(pfnCallback)) == 0)%@NL@%
        return(DMGERR_INVALIDPARAMETER);%@NL@%
%@NL@%
    return(Register(pfnCallback, afCmd, ulRes, FALSE));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
USHORT EXPENTRY Register(pfnCallback, afCmd, ulRes, f32bit)%@NL@%
PFNCALLBACK pfnCallback;%@NL@%
ULONG afCmd;%@NL@%
ULONG ulRes;%@NL@%
BOOL f32bit;    %@AB@%/* set if calling app is a 32bit app. */%@AE@%%@NL@%
{%@NL@%
    BOOL        fInit;%@NL@%
    PAPPINFO    pai = 0L, paiT;%@NL@%
    PIDINFO     pidInfo;%@NL@%
    USHORT      usRet = DMGERR_PMWIN_ERROR;%@NL@%
    ULONG       ctlFlags;%@NL@%
    CLASSINFO   ci;%@NL@%
    USHORT      cb;%@NL@%
%@NL@%
    UNUSED ulRes;%@NL@%
%@NL@%
    SemEnter();%@NL@%
    if (fInit = (hheapDmg == 0L)) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * First time only%@NL@%
%@AB@%         */%@AE@%%@NL@%
        syscc.codepage = syscc.country = 0;%@NL@%
        DosGetCtryInfo(sizeof(COUNTRYCODE), &syscc, (PCOUNTRYINFO)&syscc, &cb);%@NL@%
        if (DosGetHugeShift(&usHugeShift))%@NL@%
            goto Abort;%@NL@%
        usHugeAdd = (1 << usHugeShift) - 1;%@NL@%
        if (!(hheapDmg = MyCreateHeap(0, 4096, 0, 0, 0, HEAPFLAGS)))%@NL@%
            goto Abort;%@NL@%
        if (!WinQueryClassInfo(DMGHAB, WC_FRAME, &ci))%@NL@%
            goto Abort;%@NL@%
        lpfnFrameWndProc = ci.pfnWindowProc;%@NL@%
        if (!AddAtomTable(TRUE)) %@NL@%
            goto Abort;%@NL@%
    } else {%@NL@%
        %@NL@%
        if ((pai = GetCurrentAppInfo(FALSE)) != NULL) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * re-registration%@NL@%
%@AB@%             */%@AE@%%@NL@%
            return(DMGERR_DLL_USAGE);%@NL@%
        }%@NL@%
        %@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * share the main heap with this process.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (DosGetSeg(SELECTOROF(hheapDmg))) {%@NL@%
            SemLeave();%@NL@%
            return(DMGERR_PMWIN_ERROR);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
        %@NL@%
    if (DosGetPID(&pidInfo))%@NL@%
        goto Abort;%@NL@%
%@NL@%
    if (!(pai = (PAPPINFO)FarAllocMem(hheapDmg, sizeof(APPINFO))))%@NL@%
        goto Abort;%@NL@%
        %@NL@%
    if (!(pai->hheapApp = MyCreateHeap(0, 4096, 0, 0, 0, HEAPFLAGS))) {%@NL@%
        FarFreeMem(hheapDmg, pai, sizeof(APPINFO));%@NL@%
        pai = 0L;%@NL@%
        goto Abort;%@NL@%
    }%@NL@%
%@NL@%
    pai->pAppNamePile = NULL;   %@AB@%/* responds to nothing */%@AE@%%@NL@%
    pai->pSvrTopicList = CreateLst(pai->hheapApp, sizeof(HWNDHSZLI));%@NL@%
    pai->pHDataPile = CreatePile(pai->hheapApp, sizeof(HDMGDATA), 8);%@NL@%
    pai->afCmd = (USHORT)afCmd | (f32bit ? DMGCMD_32BIT : 0);%@NL@%
    pai->hwndDmg =%@NL@%
    pai->hwndFrame =%@NL@%
    pai->hwndMonitor =%@NL@%
    pai->hwndTimer = 0;%@NL@%
    pai->pid = pidInfo.pid;%@NL@%
    pai->tid = pidInfo.tid;%@NL@%
    pai->pfnCallback = pfnCallback;%@NL@%
    pai->cInCallback = 0;%@NL@%
    pai->LastError = DMGERR_NO_ERROR;%@NL@%
    pai->fEnableCB = TRUE;%@NL@%
    pai->plstCB = CreateLst(pai->hheapApp, sizeof(CBLI));%@NL@%
    pai->plstCBExceptions = NULL;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * make nextThread link.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    paiT = pAppInfoList;%@NL@%
    while (paiT && paiT->pid != pai->pid) {%@NL@%
        paiT = paiT->next;%@NL@%
    }%@NL@%
    pai->nextThread = paiT; %@AB@%/* paiT is NULL or of the same process */%@AE@%%@NL@%
    %@NL@%
    if (paiT) {%@NL@%
        while (paiT->nextThread->tid != pai->nextThread->tid) {%@NL@%
            paiT = paiT->nextThread;%@NL@%
        }%@NL@%
        paiT->nextThread = pai;%@NL@%
    } else {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * We must reregister each class for each process that invokes this%@NL@%
%@AB@%         * DLL because we can't register public classes unless we are the%@NL@%
%@AB@%         * shell.%@NL@%
%@AB@%         * Since pai->nextThread is NULL, this is a new process.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinRegisterClass(0, SZCLIENTCLASS, ClientWndProc, 0L, 4);%@NL@%
        WinRegisterClass(0, SZSERVERCLASS, ServerWndProc, 0L, 4);%@NL@%
        WinRegisterClass(0, SZDMGCLASS, DmgWndProc, 0L, 4);%@NL@%
        WinRegisterClass(0, SZDEFCLASS, WinDefWindowProc, 0L, 4);%@NL@%
    }%@NL@%
    %@NL@%
    pai->next = pAppInfoList;%@NL@%
    pAppInfoList = pai;%@NL@%
    %@NL@%
    if ((pai->hwndDmg = WinCreateWindow(HWND_OBJECT, SZDMGCLASS, "", 0L,%@NL@%
            0, 0, 0, 0, (HWND)NULL, HWND_BOTTOM, WID_APPROOT, 0L, 0L)) == 0L) {%@NL@%
        goto Abort;%@NL@%
    }%@NL@%
%@NL@%
    if (pai->afCmd & DMGCMD_MONITOR) {%@NL@%
        WinRegisterClass(0, SZMONITORCLASS, MonitorWndProc, 0L, 4);%@NL@%
        if ((pai->hwndMonitor = WinCreateWindow(HWND_OBJECT, SZMONITORCLASS, NULL,%@NL@%
                0L, 0, 0, 0, 0, (HWND)NULL, HWND_BOTTOM, WID_MONITOR, 0L, 0L))%@NL@%
                == 0L) {%@NL@%
            goto Abort;%@NL@%
        }%@NL@%
        if (++cMonitor) {%@NL@%
            WinSetHook(DMGHAB, NULL, HK_INPUT, (PFN)DdePostHookProc, hmodDmg);%@NL@%
            WinSetHook(DMGHAB, NULL, HK_SENDMSG, (PFN)DdeSendHookProc, hmodDmg);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * create an invisible top-level frame for initiates. (if server ok)%@NL@%
%@AB@%     */%@AE@%%@NL@%
    usRet = DMGERR_PMWIN_ERROR;%@NL@%
    if (!(afCmd & DMGCMD_CLIENTONLY)) {%@NL@%
        ctlFlags = 0;%@NL@%
        if ((pai->hwndFrame = WinCreateStdWindow(HWND_DESKTOP, 0L, &ctlFlags,%@NL@%
                (PSZ)NULL, "", 0L, (HMODULE)NULL, 0, (PHWND)NULL)) == (HWND)NULL)%@NL@%
            goto Abort;%@NL@%
        WinSubclassWindow(pai->hwndFrame, subframeWndProc);%@NL@%
    }%@NL@%
%@NL@%
    DosExitList(EXLST_ADD, (PFNEXITLIST)ExlstAbort);%@NL@%
%@NL@%
    SemLeave();%@NL@%
%@NL@%
    return(DMGERR_NO_ERROR);%@NL@%
%@NL@%
Abort:%@NL@%
    SemLeave();%@NL@%
%@NL@%
    if (pai)%@NL@%
        DdeUninitialize();%@NL@%
    else if (fInit && hheapDmg)%@NL@%
        hheapDmg = MyDestroyHeap(hheapDmg);%@NL@%
    return(usRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* BOOL EXPENTRY DdeUninitialize(void);%@NL@%
%@AB@%*     This uninitializes an application thread from the DDEML.%@NL@%
%@AB@%*     All DLL resources associated with the application are destroyed.%@NL@%
%@AB@%*     Most other APIs will fail if called after this API by the same thread.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/14/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL EXPENTRY DdeUninitialize()%@NL@%
{%@NL@%
    PAPPINFO pai, paiT;%@NL@%
    PMYDDES pmyddes;%@NL@%
    PIDINFO pi;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == NULL)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    DosExitList(EXLST_REMOVE, (PFNEXITLIST)ExlstAbort);%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * get us out of the semaphore!%@NL@%
%@AB@%     * !!! NOTE: semaphore tid id -1 during exitlist processing!%@NL@%
%@AB@%     */%@AE@%%@NL@%
    DosGetPID(&pi);%@NL@%
    if (FSRSemDmg.cUsage > 0 && FSRSemDmg.pid == pi.pid &&%@NL@%
            (FSRSemDmg.tid == pi.tid || FSRSemDmg.tid == -1)) {%@NL@%
        while (FSRSemDmg.cUsage) {%@NL@%
            SemLeave();%@NL@%
        }%@NL@%
    }%@NL@%
    %@NL@%
    if (pai->hwndTimer)%@NL@%
        WinSendMsg(pai->hwndTimer, WM_TIMER, MPFROMSHORT(TID_ABORT), 0L);%@NL@%
%@NL@%
    if (pai->hwndMonitor) {%@NL@%
        DestroyWindow(pai->hwndMonitor);%@NL@%
        if (!--cMonitor) {%@NL@%
            WinReleaseHook(DMGHAB, NULL, HK_INPUT, (PFN)DdePostHookProc, hmodDmg);%@NL@%
            WinReleaseHook(DMGHAB, NULL, HK_SENDMSG, (PFN)DdeSendHookProc, hmodDmg);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * inform others of DeRegistration%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pai->pAppNamePile != NULL) %@NL@%
        DdeAppNameServer(NULL, ANS_UNREGISTER);%@NL@%
        %@NL@%
    UnlinkAppInfo(pai);%@NL@%
%@NL@%
    DestroyWindow(pai->hwndDmg);%@NL@%
    DestroyWindow(pai->hwndFrame);%@NL@%
    DestroyHwndHszList(pai->pSvrTopicList);%@NL@%
    while (PopPileSubitem(pai->pHDataPile, (PBYTE)&pmyddes)) {%@NL@%
        if (CheckSel(SELECTOROF(pmyddes)) > sizeof(MYDDES) &&%@NL@%
                pmyddes->magic == MYDDESMAGIC &&%@NL@%
                pmyddes->pai == pai) {%@NL@%
            pmyddes->fs &= ~HDATA_APPOWNED;%@NL@%
        }%@NL@%
        FreeData(pmyddes, pai);%@NL@%
    }%@NL@%
    DestroyPile(pai->pHDataPile);%@NL@%
    if (pai->nextThread) {%@NL@%
        paiT = pai;%@NL@%
        while (paiT->nextThread != pai) {%@NL@%
            paiT = paiT->nextThread;%@NL@%
        } %@NL@%
        paiT->nextThread = pai->nextThread;%@NL@%
        if (paiT->nextThread == paiT) {%@NL@%
            paiT->nextThread = NULL;%@NL@%
        }%@NL@%
    }%@NL@%
    MyDestroyHeap(pai->hheapApp);%@NL@%
    %@NL@%
    DestroyPile(pai->pAppNamePile);%@NL@%
    FarFreeMem(hheapDmg, (PBYTE)pai, sizeof(APPINFO));%@NL@%
%@NL@%
    if (pAppInfoList == NULL) {     %@AB@%/* last guy out? - turn the lights out. */%@AE@%%@NL@%
        while (cAtbls--)%@NL@%
            WinDestroyAtomTable(aAtbls[cAtbls]);%@NL@%
        hheapDmg = MyDestroyHeap(hheapDmg);%@NL@%
    } else %@NL@%
        DosFreeSeg(SELECTOROF(hheapDmg));%@NL@%
%@NL@%
    SemCheckOut();%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HCONVLIST EXPENTRY DdeBeginEnumServers(%@NL@%
%@AB@%* HSZ hszAppName,    // app name to connect to, NULL is wild.                   %@NL@%
%@AB@%* HSZ hszTopic,      // topic name to connect to, NULL is wild.                 %@NL@%
%@AB@%* HCONV hConvList,   // previous hConvList for reenumeration, NULL for initial. %@NL@%
%@AB@%* PCONVCONTEXT pCC,  // language info or NULL for system default.               %@NL@%
%@AB@%* HAPP hApp);        // target application handle or NULL for broadcast init.   %@NL@%
%@AB@%*%@NL@%
%@AB@%*   hszAppName - the DDE application name to connect to - may be 0 for wild.%@NL@%
%@AB@%*   hszTopic - the DDE topic name to connect to - may be 0 for wild.%@NL@%
%@AB@%*   hConvList - The conversation list handle to use for reenumeration.%@NL@%
%@AB@%*       If this is 0, a new hConvList is created.%@NL@%
%@AB@%*   pCC - pointer to CONVCONTEXT structure which provides conversation%@NL@%
%@AB@%*       information needed for international support.  All DDEFMT_TEXT%@NL@%
%@AB@%*       strings within any conversation started by this call should use%@NL@%
%@AB@%*       the codepage referenced in this structure.%@NL@%
%@AB@%*       If NULL is given, the current system values are used.%@NL@%
%@AB@%*   hApp - if not NULL, this directs initiates to only be sent to hApp.%@NL@%
%@AB@%*%@NL@%
%@AB@%*       This routine connects all available conversations on the given %@NL@%
%@AB@%*       app/topic pair.  Hsz values of 0 indicate wild names.  On reenumeration%@NL@%
%@AB@%*       old hConv's are kept and any new ones created are added to the%@NL@%
%@AB@%*       list.  Duplicate connections are avoided where possible.  A%@NL@%
%@AB@%*       duplicate connection is one which is to the same process and%@NL@%
%@AB@%*       thread on the same application/topic names.  If hApp is provided,%@NL@%
%@AB@%*       initiates are given only to that application.%@NL@%
%@AB@%*       Reenumeration is primarily intended as a response%@NL@%
%@AB@%*       to registration of a new app name to the system.  Reenumeration%@NL@%
%@AB@%*       also removes any terminated conversations from the list.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   returns NULL on failure, hConvList on success.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/14/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HCONVLIST EXPENTRY DdeBeginEnumServers(hszAppName, hszTopic, hConvList,%@NL@%
        pCC, hApp)%@NL@%
HSZ hszAppName;     %@NL@%
HSZ hszTopic;       %@NL@%
HWND hConvList;     %@NL@%
PCONVCONTEXT pCC;   %@NL@%
HAPP hApp;          %@NL@%
{%@NL@%
    PAPPINFO            pai;%@NL@%
    HCONV               hConv, hConvNext, hConvNew;%@NL@%
    HCONVLIST           hConvListNew;%@NL@%
    PCLIENTINFO         pciOld, pciNew;%@NL@%
    PID                 pidOld, pidNew;%@NL@%
    TID                 tidOld, tidNew;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == 0)%@NL@%
        return(0);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * destroy any dead old clients%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (hConvList) {%@NL@%
        hConv = WinQueryWindow(hConvList, QW_TOP, FALSE);%@NL@%
        while (hConv != NULL) {%@NL@%
            hConvNext = WinQueryWindow(hConv, QW_NEXT, FALSE);%@NL@%
            if (!((USHORT)WinSendMsg(hConv, UM_QUERY, MPFROMSHORT(Q_STATUS), 0L) &%@NL@%
                    ST_CONNECTED))%@NL@%
                WinDestroyWindow(hConv);%@NL@%
            hConv = hConvNext;%@NL@%
        }%@NL@%
    }%@NL@%
    %@NL@%
    if ((hConvListNew = WinCreateWindow(pai->hwndDmg, SZDEFCLASS, "", 0L,%@NL@%
            0, 0, 0, 0, (HWND)NULL, HWND_BOTTOM, WID_CLROOT, 0L, 0L)) == NULL) {%@NL@%
        pai->LastError = DMGERR_PMWIN_ERROR;%@NL@%
        return(0L);%@NL@%
    }%@NL@%
    %@NL@%
    hConvNew = GetDDEClientWindow(hConvListNew, (HWND)hApp, NULL, hszAppName,%@NL@%
            hszTopic, pCC);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If no new hConvs created, quit now.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (hConvNew == NULL) {%@NL@%
        if (hConvList && WinQueryWindow(hConvList, QW_TOP, FALSE) == NULL) {%@NL@%
            DestroyWindow(hConvList);%@NL@%
            hConvList = NULL;%@NL@%
        }%@NL@%
        if (hConvList == NULL)%@NL@%
            pai->LastError = DMGERR_NO_CONV_ESTABLISHED;%@NL@%
        return(hConvList);%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * remove any new ones that duplicate old existing ones%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (hConvList && (hConv = WinQueryWindow(hConvList, QW_TOP, FALSE))) {%@NL@%
        while (hConv) {%@NL@%
            hConvNext = WinQueryWindow(hConv, QW_NEXT, FALSE);%@NL@%
            pciOld = (PCLIENTINFO)WinQueryWindowULong(hConv, QWL_USER);%@NL@%
            if (!WinIsWindow(DMGHAB, pciOld->ci.hwndPartner)) {%@NL@%
                WinDestroyWindow(hConv);%@NL@%
                hConv = hConvNext;%@NL@%
                continue;%@NL@%
            }%@NL@%
            WinQueryWindowProcess(pciOld->ci.hwndPartner, &pidOld, &tidOld);%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * destroy any new clients that are duplicates of the old ones.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            hConvNew = WinQueryWindow(hConvListNew, QW_TOP, FALSE);%@NL@%
            while (hConvNew) {%@NL@%
                hConvNext = WinQueryWindow(hConvNew, QW_NEXT, FALSE);%@NL@%
                pciNew = (PCLIENTINFO)WinQueryWindowULong(hConvNew, QWL_USER);%@NL@%
                WinQueryWindowProcess(pciNew->ci.hwndPartner, &pidNew, &tidNew);%@NL@%
                if (pciOld->ci.hszServerApp == pciNew->ci.hszServerApp &&%@NL@%
                        pciOld->ci.hszTopic == pciNew->ci.hszTopic &&%@NL@%
                        pidOld == pidNew &&%@NL@%
                        tidOld == tidNew) {%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                     * assume same app, same topic, same process, same thread%@NL@%
%@AB@%                     * is a duplicate.%@NL@%
%@AB@%                     */%@AE@%%@NL@%
                    WinDestroyWindow(hConvNew);%@NL@%
                }%@NL@%
                hConvNew = hConvNext;%@NL@%
            }%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * move the unique old client to the new list%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinSetParent(hConv, hConvListNew, FALSE);%@NL@%
            hConv = hConvNext;%@NL@%
        }%@NL@%
        WinDestroyWindow(hConvList);%@NL@%
    }%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If none are left, fail because no conversations were established.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (WinQueryWindow(hConvListNew, QW_TOP, FALSE) == NULL) {%@NL@%
        DestroyWindow(hConvListNew);%@NL@%
        pai->LastError = DMGERR_NO_CONV_ESTABLISHED;%@NL@%
        return(NULL);%@NL@%
    } else {%@NL@%
        return(hConvListNew);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HCONV EXPENTRY DdeGetNextServer(%@NL@%
%@AB@%* HCONVLIST hConvList,  // conversation list being traversed%@NL@%
%@AB@%* HCONV hConvPrev)      // previous conversation extracted or NULL for first%@NL@%
%@AB@%*%@NL@%
%@AB@%* hConvList - handle of conversation list returned by DdeBeginEnumServers().%@NL@%
%@AB@%* hConvPrev - previous hConv returned by this API or 0 to start from the top%@NL@%
%@AB@%*   of hConvList.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This API returns the next conversation handle associated with hConvList.%@NL@%
%@AB@%* A 0 is returned if hConvPrev was the last conversation or if hConvList%@NL@%
%@AB@%* has no active conversations within it.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/14/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HCONV EXPENTRY DdeGetNextServer(hConvList, hConvPrev)%@NL@%
HCONVLIST hConvList;%@NL@%
HCONV hConvPrev;%@NL@%
{%@NL@%
    if (!WinIsWindow(DMGHAB, hConvList))%@NL@%
        return(NULL);%@NL@%
    if (hConvPrev == NULL)%@NL@%
        return(WinQueryWindow(hConvList, QW_TOP, FALSE));%@NL@%
    else%@NL@%
        return(WinQueryWindow(hConvPrev, QW_NEXT, FALSE));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* BOOL EXPENTRY DdeEndEnumServers(hConvList)%@NL@%
%@AB@%* HCONVLIST hConvList;  // conversation list to destroy.%@NL@%
%@AB@%*%@NL@%
%@AB@%* hConvList - a conversation list handle returned by DdeBeginEnumServers().%@NL@%
%@AB@%*%@NL@%
%@AB@%* This API destroys hConvList and terminates all conversations associated%@NL@%
%@AB@%* with it.  If an application wishes to save selected conversations within%@NL@%
%@AB@%* hConvList, it should call DdeDisconnect() on all hConv's it does not%@NL@%
%@AB@%* want to use and not call this API.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/14/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL EXPENTRY DdeEndEnumServers(hConvList)%@NL@%
HCONVLIST hConvList;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
    HCONV hConv, hConvNext;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == NULL)%@NL@%
        return(FALSE);%@NL@%
    if (WinIsWindow(DMGHAB, hConvList)) {%@NL@%
        hConv = WinQueryWindow(hConvList, QW_TOP, FALSE);%@NL@%
        while (hConv != NULL) {%@NL@%
            hConvNext = WinQueryWindow(hConv, QW_NEXT, FALSE);%@NL@%
            DestroyWindow(hConv);%@NL@%
            hConv = hConvNext;%@NL@%
        }%@NL@%
        DestroyWindow(hConvList);%@NL@%
    }%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HCONV EXPENTRY DdeConnect(hszAppName, hszTopic, pCC, hApp)%@NL@%
%@AB@%* HSZ hszAppName;   // app name to connect to, NULL is wild.%@NL@%
%@AB@%* HSZ hszTopic;     // topic name to connect to, NULL is wild.%@NL@%
%@AB@%* PCONVCONTEXT pCC; // language information or NULL for sys default.%@NL@%
%@AB@%* HAPP hApp;        // target application or NULL for broadcast.%@NL@%
%@AB@%*%@NL@%
%@AB@%* hszAppName - DDE application name to connect to.%@NL@%
%@AB@%* hszTopic - DDE Topic name to connect to.%@NL@%
%@AB@%* pCC - CONVCONTEXT information pertinant to this conversation.%@NL@%
%@AB@%*       If NULL, the current system information is used.%@NL@%
%@AB@%* hApp - if not NULL, directs connection to a specific app.%@NL@%
%@AB@%*%@NL@%
%@AB@%* returns - the conversation handle of the connected conversation or 0 on error.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function allows the simpler aproach of allowing a client to%@NL@%
%@AB@%* talk to the first server it finds on a topic.  It is most efficient when%@NL@%
%@AB@%* an hApp is provided.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/16/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HCONV EXPENTRY DdeConnect(hszAppName, hszTopic, pCC, hApp)%@NL@%
HSZ hszAppName;%@NL@%
HSZ hszTopic;%@NL@%
PCONVCONTEXT pCC;%@NL@%
HAPP hApp;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
    HCONV hConv;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == NULL)%@NL@%
        return(0);%@NL@%
        %@NL@%
    hConv = GetDDEClientWindow(pai->hwndDmg, NULL, (HWND)hApp, hszAppName,%@NL@%
            hszTopic, pCC);%@NL@%
            %@NL@%
    if (hConv == 0)%@NL@%
        pai->LastError = DMGERR_NO_CONV_ESTABLISHED;%@NL@%
        %@NL@%
    return(hConv);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* BOOL EXPENTRY DdeDisconnect(hConv)%@NL@%
%@AB@%* hConv; // conversation handle of conversation to terminate.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This API terminates a conversation started by either DdeConnect() or%@NL@%
%@AB@%* DdeBeginEnumServers().  hConv becomes invalid after this call.%@NL@%
%@AB@%*%@NL@%
%@AB@%* If hConv is a server conversation, any transactions for that conversation%@NL@%
%@AB@%* found on the server callback queue will be deleted prior to terminating%@NL@%
%@AB@%* the conversation.%@NL@%
%@AB@%*%@NL@%
%@AB@%* If hConv is a client conversation, any transactions on the Client Queue%@NL@%
%@AB@%* are purged before termination.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Note that client conversations that are terminated from the server end%@NL@%
%@AB@%* go into a dormant state but are still available so that DdeQueryConvInfo()%@NL@%
%@AB@%* can be used to determine why a conversation is not working.%@NL@%
%@AB@%* Server conversations will destroy themselves if terminated from a client.%@NL@%
%@AB@%*%@NL@%
%@AB@%* returns fSuccess%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/16/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL EXPENTRY DdeDisconnect(hConv)%@NL@%
HCONV hConv;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == NULL)%@NL@%
        return(FALSE);%@NL@%
        %@NL@%
    if (!WinIsWindow(DMGHAB, hConv)) {%@NL@%
        pai->LastError = DMGERR_NO_CONV_ESTABLISHED;%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    SemCheckOut();%@NL@%
    return((BOOL)WinSendMsg(hConv, UMCL_TERMINATE, 0L, 0L));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* BOOL EXPENTRY DdeQueryConvInfo(hConv, pConvInfo, idXfer)%@NL@%
%@AB@%* HCONV hConv;          // conversation hand to get info on.%@NL@%
%@AB@%* PCONVINFO pConvInfo;  // structure to hold info.%@NL@%
%@AB@%* ULONG idXfer;         // transaction ID if async, QID_SYNC if not.%@NL@%
%@AB@%*%@NL@%
%@AB@%* hConv - conversation handle of a conversation to query.%@NL@%
%@AB@%* pConvInfo - pointer to CONVINFO structure.%@NL@%
%@AB@%* idXfer - Should be a QID_ constant or an ID returned from DdeCheckQueue().%@NL@%
%@AB@%*       if id is QID_SYNC, then the synchronous conversation state is returned.%@NL@%
%@AB@%*%@NL@%
%@AB@%* returns - fSuccess.  The CONVINFO structure is filled in with the%@NL@%
%@AB@%*     conversation's status on success.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Note that a client conversation may have several transactions in progress%@NL@%
%@AB@%* at the same time.  idXfer is used to choose which transaction to refer to.%@NL@%
%@AB@%*%@NL@%
%@AB@%* hConv may be a client or server conversation handle.  Server conversation%@NL@%
%@AB@%* handles ignore idXfer.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/14/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL EXPENTRY DdeQueryConvInfo(hConv, pConvInfo, idXfer)%@NL@%
HCONV hConv;%@NL@%
PCONVINFO pConvInfo;%@NL@%
ULONG idXfer;%@NL@%
{%@NL@%
    PCLIENTINFO pci;%@NL@%
    PAPPINFO pai;%@NL@%
    PXADATA pxad;%@NL@%
    PCQDATA pqd;%@NL@%
    BOOL fClient;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(FALSE)) == 0)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    SemCheckOut();%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * note that pci may actually be a psi if fClient is false.  Since%@NL@%
%@AB@%     * the common info portions are identical, we don't care except%@NL@%
%@AB@%     * where data is extracted from non-common portions.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!WinIsWindow(DMGHAB, hConv) ||%@NL@%
            !(pci = (PCLIENTINFO)WinSendMsg(hConv, UM_QUERY, (MPARAM)Q_ALL, 0L)) ||%@NL@%
            !WinIsWindow(DMGHAB, pci->ci.hwndPartner)) {%@NL@%
        pai->LastError = DMGERR_NO_CONV_ESTABLISHED;%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    %@NL@%
    fClient = (BOOL)WinSendMsg(hConv, UM_QUERY, (MPARAM)Q_CLIENT, 0L);%@NL@%
    %@NL@%
    if (idXfer == QID_SYNC || !fClient) {%@NL@%
        pxad = &pci->ci.xad;%@NL@%
    } else {%@NL@%
        if (pci->pQ != NULL &&%@NL@%
                (pqd = (PCQDATA)Findqi(pci->pQ, idXfer))) {%@NL@%
            pxad = &pqd->xad;%@NL@%
        } else {%@NL@%
            pai->LastError = DMGERR_UNFOUND_QUEUE_ID;%@NL@%
            return(FALSE);%@NL@%
        }%@NL@%
    }%@NL@%
    SemEnter();%@NL@%
    pConvInfo->cb = sizeof(CONVINFO);%@NL@%
    pConvInfo->hConvPartner = IsDdeWindow(pci->ci.hwndPartner);%@NL@%
    pConvInfo->hszAppName = pci->ci.hszServerApp;%@NL@%
    pConvInfo->hszAppPartner = fClient ? pci->ci.hszServerApp : 0;%@NL@%
    pConvInfo->hszTopic = pci->ci.hszTopic;%@NL@%
    pConvInfo->hAgent = pci->ci.hAgent;%@NL@%
    pConvInfo->hApp = pci->ci.hwndFrame;%@NL@%
    if (fClient) {%@NL@%
        pConvInfo->hszItem = pxad->pXferInfo->hszItem;%@NL@%
        pConvInfo->usFmt = pxad->pXferInfo->usFmt;%@NL@%
        pConvInfo->usType = pxad->pXferInfo->usType;%@NL@%
        pConvInfo->usConvst = pxad->state;%@NL@%
        pConvInfo->LastError = pxad->LastError;%@NL@%
    } else {%@NL@%
        pConvInfo->hszItem = NULL;%@NL@%
        pConvInfo->usFmt = 0;%@NL@%
        pConvInfo->usType = 0;%@NL@%
        pConvInfo->usConvst = pci->ci.xad.state;%@NL@%
        pConvInfo->LastError = pci->ci.pai->LastError;%@NL@%
    }%@NL@%
    pConvInfo->usStatus = pci->ci.fs;%@NL@%
    pConvInfo->fsContext = pci->ci.cc.fsContext;%@NL@%
    pConvInfo->idCountry = pci->ci.cc.idCountry;%@NL@%
    pConvInfo->usCodepage = pci->ci.cc.usCodepage;%@NL@%
    SemLeave();%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* BOOL EXPENTRY DdePostAdvise(hszTopic, hszItem)%@NL@%
%@AB@%* HSZ hszTopic;     // topic of changed data, NULL is all topics%@NL@%
%@AB@%* HSZ hszItem;      // item of changed data, NULL is all items%@NL@%
%@AB@%*%@NL@%
%@AB@%* Causes any clients who have advise loops running on the topic/item name%@NL@%
%@AB@%* specified to receive the apropriate data messages they require.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This should be called by a server application anytime data associated with%@NL@%
%@AB@%* a particular topic/item changes.  This call results in XTYP_ADVREQ%@NL@%
%@AB@%* callbacks being generated.%@NL@%
%@AB@%*%@NL@%
%@AB@%* hszTopic and/or hszItem may be NULL if all topics or items are to be updated.%@NL@%
%@AB@%* This will result in callbacks for all active advise loops that fit the%@NL@%
%@AB@%* hszTopic/hszItem pair.%@NL@%
%@AB@%* %@NL@%
%@AB@%* The API is intended for SERVERS only!%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/16/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL EXPENTRY DdePostAdvise(hszTopic, hszItem)%@NL@%
HSZ hszTopic;%@NL@%
HSZ hszItem;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
    HWND hwndTopic;%@NL@%
    HWND hwndSvr;%@NL@%
%@NL@%
    // LATER - add wild hsz support%@NL@%
    %@NL@%
    if (((pai = GetCurrentAppInfo(TRUE)) == 0))%@NL@%
        return(FALSE);%@NL@%
        %@NL@%
    if (pai->afCmd & DMGCMD_CLIENTONLY) {%@NL@%
        pai->LastError = DMGERR_DLL_USAGE;%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
        %@NL@%
    if ((hwndTopic = HwndFromHsz((HSZ)hszTopic, pai->pSvrTopicList)) == 0)%@NL@%
        return(TRUE);%@NL@%
%@NL@%
    hwndSvr = WinQueryWindow(hwndTopic, QW_TOP, FALSE);%@NL@%
    while (hwndSvr) {%@NL@%
        WinPostMsg(hwndSvr, UMSR_POSTADVISE, MPFROMSHORT(hszItem), 0L);%@NL@%
        hwndSvr = WinQueryWindow(hwndSvr, QW_NEXT, FALSE);%@NL@%
    }%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HDMGDATA EXPENTRY DdeClientXfer(pSrc, cb, hConv, hszItem, usFmt,%@NL@%
%@AB@%*         usType, ulTimeout, pidXfer)%@NL@%
%@AB@%* PBYTE pSrc;       // data source, or NULL for non-data cases.%@NL@%
%@AB@%* ULONG cb;         // data size or 0 for non-data cases.%@NL@%
%@AB@%* HCONV hConv;      // associated conversation handle%@NL@%
%@AB@%* HSZ hszItem;      // item of transaction%@NL@%
%@AB@%* USHORT usFmt;     // format for transaction%@NL@%
%@AB@%* USHORT usType;    // transaction type code%@NL@%
%@AB@%* ULONG ulTimeout;  // timeout for synchronous, TIMEOUT_ASSYNC otherwise.%@NL@%
%@AB@%* PULONG pidXfer;   // OUTPUT: assync transfer id, NULL for no output.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This API initiates a transaction from a client to the server connected%@NL@%
%@AB@%* via the conversation specified by hConv.%@NL@%
%@AB@%* %@NL@%
%@AB@%* Currently usType may be:%@NL@%
%@AB@%*     XTYP_REQUEST%@NL@%
%@AB@%*     XTYP_POKE%@NL@%
%@AB@%*     XTYP_EXEC%@NL@%
%@AB@%*     XTYP_ADVSTART%@NL@%
%@AB@%*     XTYP_ADVSTART | XTYPF_NODATA%@NL@%
%@AB@%*     XTYP_ADVSTART | XTYPF_ACKREQ%@NL@%
%@AB@%*     XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ%@NL@%
%@AB@%*     XTYP_ADVSTOP%@NL@%
%@AB@%*%@NL@%
%@AB@%* ulTimeout specifies the maximum time to wait for a response in miliseconds%@NL@%
%@AB@%* and applies to synchronous transactions only.%@NL@%
%@AB@%* if ulTimeout is TIMEOUT_ASSYNC, then the transfer is asynchronous and%@NL@%
%@AB@%* pidXfer may point to where to place the client transaction queue item%@NL@%
%@AB@%* ID created by this request.%@NL@%
%@AB@%* pidXfer may be NULL if no ID is desired.%@NL@%
%@AB@%* %@NL@%
%@AB@%* If usType is XTYP_REQUEST, synchronous transfers return a valid hDmgData%@NL@%
%@AB@%* on success which holds the data received from the request.%@NL@%
%@AB@%*%@NL@%
%@AB@%* if usType is XTYP_EXEC and hszItem==NULL (wild) and usFmt==DDEFMT_TEXT,%@NL@%
%@AB@%* the item name will be changed to the same as the text data.%@NL@%
%@AB@%* This allows for EXCEL and porthole WINDOWS compatability%@NL@%
%@AB@%* for XTYP_EXEC transactions.  It is suggested that applications always set%@NL@%
%@AB@%* hszItem to NULL for XTYP_EXEC transactions and that servers ignore the%@NL@%
%@AB@%* hszItem perameter in their callback for execute transactions.%@NL@%
%@AB@%*%@NL@%
%@AB@%* returns hDmgData or ACK DDE flags on Success, 0 on failure.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Note: the hDmgData passed in by this call is only valid for the duration%@NL@%
%@AB@%* of the callback.%@NL@%
%@AB@%* %@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/14/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA EXPENTRY DdeClientXfer(pSrc, cb, hConv, hszItem, usFmt,%@NL@%
        usType, ulTimeout, pidXfer)%@NL@%
PBYTE pSrc;%@NL@%
ULONG cb;%@NL@%
HCONV hConv;%@NL@%
HSZ hszItem;%@NL@%
USHORT usFmt;%@NL@%
USHORT usType;%@NL@%
ULONG ulTimeout;%@NL@%
PULONG pidXfer;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
    XFERINFO xi;%@NL@%
    HDMGDATA hDmgData;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == NULL)%@NL@%
        return(0);%@NL@%
%@NL@%
    if (!WinIsWindow(DMGHAB, hConv)) {%@NL@%
        pai->LastError = DMGERR_NO_CONV_ESTABLISHED;%@NL@%
        return(0);%@NL@%
    }%@NL@%
    %@NL@%
    SemCheckOut();%@NL@%
    %@NL@%
    switch (usType) {%@NL@%
    case XTYP_REQUEST:%@NL@%
    case XTYP_POKE:%@NL@%
    case XTYP_EXEC:%@NL@%
    case XTYP_ADVSTART:%@NL@%
    case XTYP_ADVSTART | XTYPF_NODATA:%@NL@%
    case XTYP_ADVSTART | XTYPF_ACKREQ:%@NL@%
    case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:%@NL@%
    case XTYP_ADVSTOP:%@NL@%
        xi.pidXfer = pidXfer;%@NL@%
        xi.ulTimeout = ulTimeout;%@NL@%
        xi.usType = usType;%@NL@%
        xi.usFmt = usFmt;%@NL@%
        xi.hszItem = hszItem;%@NL@%
        xi.hConv = hConv;%@NL@%
        xi.cb = cb;%@NL@%
        xi.pData = pSrc;        %@NL@%
        hDmgData = (HDMGDATA)WinSendMsg(hConv, UMCL_XFER, (MPARAM)&xi, 0L);%@NL@%
        if (ulTimeout == TIMEOUT_ASYNC) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Increment the count of hszItem incase the app frees it on%@NL@%
%@AB@%             * return.  This will be decremented when the client Queue%@NL@%
%@AB@%             * entry is removed.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            IncHszCount(hszItem);%@NL@%
        }%@NL@%
        %@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * add the hDmgData to the client's list of handles he needs%@NL@%
%@AB@%         * to eventually free.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((usType & XCLASS_DATA) && (CheckSel(SELECTOROF(hDmgData)))) {%@NL@%
            AddPileItem(pai->pHDataPile, (PBYTE)&hDmgData, CmpULONG);%@NL@%
            if (((PMYDDES)hDmgData)->magic == MYDDESMAGIC) {%@NL@%
                ((PMYDDES)hDmgData)->fs |= HDATA_READONLY;%@NL@%
            }%@NL@%
        }%@NL@%
        %@NL@%
        return(hDmgData);%@NL@%
    }%@NL@%
    pai->LastError = DMGERR_INVALIDPARAMETER;%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* USHORT EXPENTRY DdeGetLastError(void)%@NL@%
%@AB@%*%@NL@%
%@AB@%* This API returns the most recent error registered by the DDE manager for%@NL@%
%@AB@%* the current thread.  This should be called anytime a DDE manager API%@NL@%
%@AB@%* returns in a failed state.%@NL@%
%@AB@%*%@NL@%
%@AB@%* returns an error code which corresponds to a DMGERR_ constant found in%@NL@%
%@AB@%* ddeml.h.  This error code may be passed on to DdePostError() to%@NL@%
%@AB@%* show the user the reason for the error or to DdeGetErrorString() to convert%@NL@%
%@AB@%* the error code into an apropriate string.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/14/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
USHORT EXPENTRY DdeGetLastError(void)%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
    SHORT err = DMGERR_DLL_NOT_INITIALIZED;%@NL@%
%@NL@%
    pai = GetCurrentAppInfo(FALSE);%@NL@%
%@NL@%
    if (pai) {%@NL@%
        err = pai->LastError;%@NL@%
        pai->LastError = DMGERR_NO_ERROR;%@NL@%
    }%@NL@%
    return(err);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* void EXPENTRY DdePostError(err)%@NL@%
%@AB@%* ULONG err;    // error code to post.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This API puts up a message box describing the error who's code was%@NL@%
%@AB@%* passed in.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/20/88    sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void EXPENTRY DdePostError(err)%@NL@%
USHORT err;%@NL@%
{%@NL@%
    char szError[MAX_ERRSTR + 1];%@NL@%
%@NL@%
    if (err < DMGERR_FIRST || err > DMGERR_LAST)%@NL@%
        return;%@NL@%
    WinLoadString(DMGHAB, hmodDmg, err, MAX_ERRSTR + 1, szError);%@NL@%
    WinMessageBox(HWND_DESKTOP, NULL, szError, SZERRCAPTION, 0,%@NL@%
            MB_OK | MB_ICONHAND | MB_SYSTEMMODAL);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* USHORT EXPENTRY DdeGetErrorString(err, cbMax, psz)%@NL@%
%@AB@%* USHORT err;       // error code to convert%@NL@%
%@AB@%* USHORT cbMax;     // size of string buffer provided by caller%@NL@%
%@AB@%* PSZ psz;          // string buffer address.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function fills psz with the error string referenced by err of up%@NL@%
%@AB@%* to cbMax characters.  All error strings are <= MAX_ERRSTR in length.%@NL@%
%@AB@%* (not counting the NULL terminator.)%@NL@%
%@AB@%*%@NL@%
%@AB@%* returns length of copied string without NULL terminator or 0 on failure.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/20/88    sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
USHORT EXPENTRY DdeGetErrorString(err, cbMax, psz)%@NL@%
USHORT err;%@NL@%
USHORT cbMax;%@NL@%
PSZ psz;%@NL@%
{%@NL@%
    if (err < DMGERR_FIRST || err > DMGERR_LAST)%@NL@%
        return(0);%@NL@%
    return(WinLoadString(DMGHAB, hmodDmg, err, cbMax, psz));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*\%@NL@%
%@AB@%* HDATA stuff:%@NL@%
%@AB@%* %@NL@%
%@AB@%* Each thread has an hData list that contains all the hData's it has%@NL@%
%@AB@%* been given by the DLL.   This list indicates what hData's an app can%@NL@%
%@AB@%* and must eventually free.%@NL@%
%@AB@%* %@NL@%
%@AB@%* If an app has multiple threads registered, each threads pai's are linked%@NL@%
%@AB@%* via the nextThread pointer.  The links are circular so the TID%@NL@%
%@AB@%* should be used to know when all the lists are traversed.%@NL@%
%@AB@%* %@NL@%
%@AB@%* Each hData contains the following flags:%@NL@%
%@AB@%* %@NL@%
%@AB@%* HDATA_READONLY - set on any hData given to the DLL or created by the DLL.%@NL@%
%@AB@%*         This prevents AddData from working.%@NL@%
%@AB@%*         %@NL@%
%@AB@%* HDATA_APPOWNED - set at creation time by app so app will keep access%@NL@%
%@AB@%*         until it frees it or unregistration happens.%@NL@%
%@AB@%*         This prevents the DLL from freeing the hData before an app is%@NL@%
%@AB@%*         through with it.%@NL@%
%@AB@%* %@NL@%
%@AB@%* HDATA_APPFREEABLE - set at creation time if logged into thread list.%@NL@%
%@AB@%* %@NL@%
%@AB@%* Each hData also contains the pai of the thread that created the hData.%@NL@%
%@AB@%*         (set by PutData)  If APPOWNED is set, this identifies the%@NL@%
%@AB@%*         owner thread as well.%@NL@%
%@AB@%* %@NL@%
%@AB@%* %@NL@%
%@AB@%* General rules for apps:%@NL@%
%@AB@%* %@NL@%
%@AB@%*         hDatas from DLL calls are the apps responsibility to free and are%@NL@%
%@AB@%*                 only valid till passed back into the DLL or freed.%@NL@%
%@AB@%*         hDatas from callback calls are only valid during the callback.%@NL@%
%@AB@%*         hDatas created by an app but not APPOWNED are only valid till%@NL@%
%@AB@%*                 passed into the DLL.%@NL@%
%@AB@%*         hDatas created by an app that are APPOWNED are valid until%@NL@%
%@AB@%*                 the creating thread frees it or till that thread unregisters%@NL@%
%@AB@%*                 itself.%@NL@%
%@AB@%*         A process will not loose access to an hData untill all threads that%@NL@%
%@AB@%*                 have received the hData have freed it or passed it back to%@NL@%
%@AB@%*                 the DLL (via callback)%@NL@%
%@AB@%* %@NL@%
%@AB@%*         %@NL@%
%@AB@%* Register:                                                       DONE%@NL@%
%@AB@%*         creates hDataList for app/thread.%@NL@%
%@AB@%*         creates nextThread links if applicable.%@NL@%
%@AB@%* %@NL@%
%@AB@%* DdePutData:                                                  DONE%@NL@%
%@AB@%*         Only allows HDATA_APPOWNED flag%@NL@%
%@AB@%*         sets HDATA_APPFREEABLE flag%@NL@%
%@AB@%*         ...Falls into....%@NL@%
%@AB@%* PutData:                                                        DONE%@NL@%
%@AB@%*         Allocates selector%@NL@%
%@AB@%*         sets creator pai%@NL@%
%@AB@%*         sets HDATA_ flags specified%@NL@%
%@AB@%*         if (HDATA_APPFREEABLE)%@NL@%
%@AB@%*             adds to hDataList. %@NL@%
%@AB@%* %@NL@%
%@AB@%* DdeAddData:                                                  DONE%@NL@%
%@AB@%*         fails if HDATA_READONLY or a non-dll type selector%@NL@%
%@AB@%* %@NL@%
%@AB@%* Callback:                                                       DONE%@NL@%
%@AB@%*         Entry:%@NL@%
%@AB@%*             for hData to callback:%@NL@%
%@AB@%*                 Sets HDATA_READONLY if hData valid DLL type selector.%@NL@%
%@AB@%*                 (does NOT add hData to thread list so he can't free it during%@NL@%
%@AB@%*                  the callback)%@NL@%
%@AB@%*                  %@NL@%
%@AB@%*         Exit:%@NL@%
%@AB@%*             for hData to callback:%@NL@%
%@AB@%*                 nothing.%@NL@%
%@AB@%*             for hData from callback:%@NL@%
%@AB@%*                 verifies creator == current%@NL@%
%@AB@%* %@NL@%
%@AB@%* DdeCreateInitPkt:                                            DONE%@NL@%
%@AB@%* DdeAppNameServer:                                            NOT COMPLETE%@NL@%
%@AB@%* DdeClientXfer:                                               DONE%@NL@%
%@AB@%* DdeCheckQ:                                                   DONE%@NL@%
%@AB@%*         if (valid selector)%@NL@%
%@AB@%*             add to thread list%@NL@%
%@AB@%*             if (valid DLL type selector)%@NL@%
%@AB@%*                 Set READONLY flag.%@NL@%
%@AB@%* %@NL@%
%@AB@%* ProcessPkt:                                                     NOT IMP.%@NL@%
%@AB@%*         for hData in:%@NL@%
%@AB@%*              After used, calls FreeData()%@NL@%
%@AB@%*         for hData out:%@NL@%
%@AB@%*              before return, adds hData to thread list%@NL@%
%@AB@%*         %@NL@%
%@AB@%* MyPostMsg:                                                      DONE%@NL@%
%@AB@%*         gives if target process != current%@NL@%
%@AB@%*         if target process is not a DLL process/thread, expand hszItem.%@NL@%
%@AB@%*         calls FreeData() on current process if MDPM_FREEHDATA is set.%@NL@%
%@AB@%*         %@NL@%
%@AB@%* %@NL@%
%@AB@%* DdeFreeData:                                                 DONE%@NL@%
%@AB@%*         if in thread list.%@NL@%
%@AB@%*             remove hData from list%@NL@%
%@AB@%*             if not in any thread lists for this process%@NL@%
%@AB@%*                 free data%@NL@%
%@AB@%*             return pass%@NL@%
%@AB@%*         else %@NL@%
%@AB@%*             return fail%@NL@%
%@AB@%* %@NL@%
%@AB@%* FreeData:                                                       DONE%@NL@%
%@AB@%*         if (DLL type selector && HDATA_APPOWNED && creator == current)%@NL@%
%@AB@%*             exit%@NL@%
%@AB@%*         remove hData from thread list if found%@NL@%
%@AB@%*         if not in any thread lists for this process%@NL@%
%@AB@%*             free data%@NL@%
%@AB@%*         %@NL@%
%@AB@%* UnRegister:                                                     DONE%@NL@%
%@AB@%*         for each item in the hDataList:%@NL@%
%@AB@%*             clear HDATA_APPOWNED flag if dll type selector and owned by this%@NL@%
%@AB@%*                 thread.%@NL@%
%@AB@%*             FreeData()%@NL@%
%@AB@%*         destroy list%@NL@%
%@AB@%*         unlink from other thread lists%@NL@%
%@AB@%*         %@NL@%
%@AB@%\*/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HDMGDATA EXPENTRY DdePutData(pSrc, cb, cbOff, hszItem, usFmt, afCmd)%@NL@%
%@AB@%* PBYTE pSrc;   // address of data to place into data handle or NULL%@NL@%
%@AB@%* ULONG cb;     // amount of data to copy if pSrc is not NULL.%@NL@%
%@AB@%* ULONG cbOff;  // offset into data handle region to place pSrc data%@NL@%
%@AB@%* HSZ hszItem;  // item associated with this data%@NL@%
%@AB@%* USHORT usFmt; // format associated with this data%@NL@%
%@AB@%* USHORT afCmd; // HDATA_ flags.%@NL@%
%@AB@%* %@NL@%
%@AB@%* This api allows an application to create a hDmgData apropriate%@NL@%
%@AB@%* for return from its call-back function.%@NL@%
%@AB@%* The passed in data is stored into the hDmgData which is%@NL@%
%@AB@%* returned on success.  Any portions of the data handle not filled are%@NL@%
%@AB@%* undefined.  afCmd contains any of the HDATA_ constants described below:%@NL@%
%@AB@%*%@NL@%
%@AB@%* HDATA_APPOWNED%@NL@%
%@AB@%*   This declares the created data handle to be the responsability of%@NL@%
%@AB@%*   the application to free it.  Application owned data handles may%@NL@%
%@AB@%*   be given to the DLL multiple times.  This allows a server app to be%@NL@%
%@AB@%*   able to support many clients without having to recopy the data for%@NL@%
%@AB@%*   each request.  If this flag is not specified, the data handle becomes%@NL@%
%@AB@%*   invalid once passed to the DLL via any API or the callback function.%@NL@%
%@AB@%*%@NL@%
%@AB@%* NOTES:%@NL@%
%@AB@%*   If an application expects this data handle to hold >64K of data via%@NL@%
%@AB@%*   DdeAddData(), it should specify a cb + cbOff to be as large as%@NL@%
%@AB@%*   the object is expected to get via DdeAddData() calls to avoid%@NL@%
%@AB@%*   unnecessary data copying or reallocation by the DLL.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   if psrc==NULL or cb == 0, no actual data copying takes place.%@NL@%
%@AB@%* %@NL@%
%@AB@%*   Data handles given to an application via the DdeClientXfer() or%@NL@%
%@AB@%*   DdeCheckQueue() functions are the responsability of the client%@NL@%
%@AB@%*   application to free and MUST NOT be returned from the callback%@NL@%
%@AB@%*   function as server data!  The DLL will only accept data handles%@NL@%
%@AB@%*   returned from the callback function that were created by the%@NL@%
%@AB@%*   called application.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/14/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA EXPENTRY DdePutData(pSrc, cb, cbOff, hszItem, usFmt, afCmd)%@NL@%
PBYTE pSrc;%@NL@%
ULONG cb;%@NL@%
ULONG cbOff;%@NL@%
HSZ hszItem;%@NL@%
USHORT usFmt;%@NL@%
USHORT afCmd;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    if (!(pai = GetCurrentAppInfo(FALSE)))%@NL@%
        return(0L);;%@NL@%
%@NL@%
    if (afCmd & ~(HDATA_APPOWNED)) {%@NL@%
        pai->LastError = DMGERR_INVALIDPARAMETER;%@NL@%
        return(0L);%@NL@%
    }%@NL@%
%@NL@%
    return(PutData(pSrc, cb, cbOff, hszItem, usFmt, afCmd | HDATA_APPFREEABLE, pai));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HDMGDATA EXPENTRY DdeAddData(hDmgData, pSrc, cb, cbOff)%@NL@%
%@AB@%* HDMGDATA hDmgData;    // data handle to add data to%@NL@%
%@AB@%* PBYTE pSrc;           // pointer to data to add (if NULL, no data copying)%@NL@%
%@AB@%* ULONG cb;             // size of data to add%@NL@%
%@AB@%* ULONG cbOff;          // offset within hData to place data%@NL@%
%@AB@%*%@NL@%
%@AB@%* This routine allows an application to add data to a hDmgData it had%@NL@%
%@AB@%* previously created using DdePutData().  The handle will be%@NL@%
%@AB@%* grown as necessary to support the data addition.  Data may be added%@NL@%
%@AB@%* to a data handle multiple times and in any order of data locations.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Once a data handle is given to the DLL via return from the callback%@NL@%
%@AB@%* function or via a DLL API, it becomes readonly.  Further attempts to%@NL@%
%@AB@%* add data to the hData by any process will fail.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This call will return 0 if it failed to allocate enough memory or if%@NL@%
%@AB@%* the data handle is readonly.  On success, the returned hDmgData should %@NL@%
%@AB@%* replace the given hDmgData.  On failure, the hDmgData given is left%@NL@%
%@AB@%* in the state it was initially.%@NL@%
%@AB@%*%@NL@%
%@AB@%* NOTE: For huge segments, or segments expected to grow to greater than %@NL@%
%@AB@%*    64K, it is best if DdePutData() be called with a cbOff + cb as %@NL@%
%@AB@%*    large as maximally expected so as not to force reallocation from a %@NL@%
%@AB@%*    normal to a huge segment in 16bit applications.  This also avoids %@NL@%
%@AB@%*    the need of replaceing the hDmgData with the output each time%@NL@%
%@AB@%*    incase a new selector was needed to be allocated and copied to.  %@NL@%
%@AB@%* %@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/17/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA EXPENTRY DdeAddData(hDmgData, pSrc, cb, cbOff)%@NL@%
HDMGDATA hDmgData;%@NL@%
PBYTE pSrc;%@NL@%
ULONG cb;%@NL@%
ULONG cbOff;%@NL@%
{%@NL@%
%@AI@%#define %@AE@%pmyddes ((PMYDDES)hDmgData) %@NL@%
%@AI@%#define %@AE@%selIn (SELECTOROF(hDmgData)) %@NL@%
    %@NL@%
    PAPPINFO pai;%@NL@%
    SEL sel;%@NL@%
    ULONG cbOffAbs;%@NL@%
%@NL@%
    if (!(pai = GetCurrentAppInfo(FALSE)))%@NL@%
        return(0L);;%@NL@%
%@NL@%
    if (!CheckSel(selIn) ||%@NL@%
            pmyddes->offszItemName != sizeof(MYDDES) ||%@NL@%
            pmyddes->magic != MYDDESMAGIC ||%@NL@%
            pmyddes->fs & HDATA_READONLY) {%@NL@%
        pai->LastError = DMGERR_INVALID_HDMGDATA;%@NL@%
        return(0L);%@NL@%
    }%@NL@%
    %@NL@%
    cbOffAbs = pmyddes->offabData + cbOff;%@NL@%
    if (pmyddes->cbData + pmyddes->offabData < cb + cbOffAbs) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * need to grow...%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (cbOffAbs + cb > 0xFFFFL) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * going to be huge...%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if ((pmyddes->offabData + pmyddes->cbData < 0xFFFFL) ||%@NL@%
                    DosReallocHuge(HIUSHORT(cb + cbOffAbs),%@NL@%
                    LOUSHORT(cb + cbOffAbs), selIn)) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Either we can't grow a huge seg or we need to make one.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                if (DosAllocHuge(HIUSHORT(cb + cbOffAbs),%@NL@%
                        LOUSHORT(cb + cbOffAbs), &sel, 0, SEG_GIVEABLE)) {%@NL@%
                    pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
                    return(0);%@NL@%
                }%@NL@%
                CopyHugeBlock(hDmgData, MAKEP(sel, 0), pmyddes->cbData +%@NL@%
                        sizeof(MYDDES) + 1);%@NL@%
                FindPileItem(pai->pHDataPile, CmpULONG, (PBYTE)&hDmgData,%@NL@%
                        FPI_DELETE);%@NL@%
                DosFreeSeg(selIn);%@NL@%
                hDmgData = MAKEP(sel, 0);%@NL@%
                AddPileItem(pai->pHDataPile, (PBYTE)&hDmgData, NULL);%@NL@%
            }%@NL@%
        } else {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * not going to be huge%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (DosReallocSeg((USHORT)(cb + cbOffAbs), selIn)) { %@NL@%
                pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
                return(0L);%@NL@%
            }%@NL@%
        }%@NL@%
        pmyddes->cbData = cbOff + cb;%@NL@%
    }%@NL@%
    if (pSrc)%@NL@%
        CopyHugeBlock(pSrc, HugeOffset((PBYTE)hDmgData, cbOffAbs), cb);%@NL@%
    return(hDmgData);%@NL@%
%@AI@%#undef %@AE@%selIn     %@NL@%
%@AI@%#undef %@AE@%pmyddes     %@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* ULONG EXPENTRY DdeGetData(hDmgData, pDst, cbMax, cbOff)%@NL@%
%@AB@%* HDMGDATA hDmgData;    // data handle to extract data from%@NL@%
%@AB@%* PBYTE pDst;           // destination for extracted data%@NL@%
%@AB@%* ULONG cbMax;          // destination buffer size%@NL@%
%@AB@%* ULONG cbOff;          // offset into data to start extraction%@NL@%
%@AB@%*%@NL@%
%@AB@%* This copies up to cbMax bytes of data contained in the hDmgData data handle%@NL@%
%@AB@%* at offset cbOff into application memory pointed to by pDst.%@NL@%
%@AB@%* If pDst == NULL, no copying is performed.%@NL@%
%@AB@%*%@NL@%
%@AB@%* returns the size of the data contained in the data handle remaining after%@NL@%
%@AB@%* cbOff or 0 if hDmgData is invalid or cbOff is too large.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This API supports HUGE segments in 16 bit applications.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/14/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
ULONG EXPENTRY DdeGetData(hDmgData, pDst, cbMax, cbOff)%@NL@%
HDMGDATA hDmgData;%@NL@%
PBYTE pDst;%@NL@%
ULONG cbMax;%@NL@%
ULONG cbOff;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(FALSE)) == NULL)%@NL@%
        return(0L);%@NL@%
%@NL@%
    if (!CheckSel(SELECTOROF(hDmgData))) {%@NL@%
        pai->LastError = DMGERR_INVALID_HDMGDATA;%@NL@%
        return(0L);%@NL@%
    }%@NL@%
    if (cbOff >= ((PMYDDES)hDmgData)->cbData) {%@NL@%
        pai->LastError = DMGERR_INVALIDPARAMETER;%@NL@%
        return(0L);%@NL@%
    }%@NL@%
    cbMax = min(cbMax, ((PMYDDES)hDmgData)->cbData - cbOff);%@NL@%
    if (pDst == NULL) %@NL@%
        return(((PMYDDES)hDmgData)->cbData - cbOff); %@NL@%
    CopyHugeBlock(HugeOffset(DDES_PABDATA(hDmgData), cbOff), pDst, cbMax);%@NL@%
    return(cbMax);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* PBYTE EXPENTRY DdeAccessData(hDmgData)%@NL@%
%@AB@%* HDMGDATA hDmgData;    // data handle to access%@NL@%
%@AB@%*%@NL@%
%@AB@%* This API returns a pointer to the data referenced by the data handle.%@NL@%
%@AB@%* The pointer returned becomes invalid once the data handle is freed%@NL@%
%@AB@%* or given to the DLL via callback return or API call.%@NL@%
%@AB@%*%@NL@%
%@AB@%* NOTE: applications MUST take care not to access beyond the limits of%@NL@%
%@AB@%* the data handle.  Only hDmgData's created by the application via%@NL@%
%@AB@%* a DdePutData() call may write to this memory prior to passing on%@NL@%
%@AB@%* to any DLL API or returning from the callback function.  Any hDmgData%@NL@%
%@AB@%* received from the DLL should be considered shared-readonly data and%@NL@%
%@AB@%* should be treated as such.  This applies whether the application owns%@NL@%
%@AB@%* the data handle or not.%@NL@%
%@AB@%*%@NL@%
%@AB@%* 0L is returned on error.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     8/24/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PBYTE EXPENTRY DdeAccessData(hDmgData)%@NL@%
HDMGDATA hDmgData;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
    %@NL@%
    if ((pai = GetCurrentAppInfo(FALSE)) == NULL)%@NL@%
        return(0L);%@NL@%
    if (CheckSel(SELECTOROF(hDmgData))) {%@NL@%
        return(DDES_PABDATA(hDmgData));%@NL@%
    }%@NL@%
    pai->LastError = DMGERR_ACCESS_DENIED;%@NL@%
    return(0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* BOOL EXPENTRY DdeFreeData(hDmgData)%@NL@%
%@AB@%* HDMGDATA hDmgData;        // data handle to destroy%@NL@%
%@AB@%*%@NL@%
%@AB@%* This routine should be called by an application wishing to release%@NL@%
%@AB@%* custody of an hDmgData it owns.%@NL@%
%@AB@%* An application owns any hDmgData%@NL@%
%@AB@%* it created with the HDATA_APPOWNED flag or an hDmgData given to%@NL@%
%@AB@%* it via DdeClientXfer(), DdeCheckQueue(), DdeAppNameServer(),%@NL@%
%@AB@%* DdeCreateInitPkt() or DdeProcessPkt().%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns fSuccess.  This function will fail if the hDmgData is not%@NL@%
%@AB@%* owned by the calling app.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/14/88    Sanfords%@NL@%
%@AB@%*   6/12/90 sanfords    Fixed to work with non-DLL generated selectors%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL EXPENTRY DdeFreeData(hDmgData)%@NL@%
HDMGDATA hDmgData;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
    USHORT cbSel;%@NL@%
    TID tid;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(FALSE)) == NULL)%@NL@%
        return(FALSE);%@NL@%
        %@NL@%
    cbSel = CheckSel(SELECTOROF(hDmgData));%@NL@%
    if (!cbSel) {%@NL@%
        pai->LastError = DMGERR_INVALID_HDMGDATA;%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    SemEnter();%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Apps can only free handles the DLL does not own or handles from external%@NL@%
%@AB@%     * non-DLL DDE apps.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!FindPileItem(pai->pHDataPile, CmpULONG, (PBYTE)&hDmgData, FPI_DELETE)) {%@NL@%
        pai->LastError = DMGERR_INVALID_HDMGDATA;%@NL@%
        SemLeave();%@NL@%
        return(FALSE);%@NL@%
    }    %@NL@%
            %@NL@%
    tid = pai->tid;%@NL@%
    do {%@NL@%
        if (FindPileItem(pai->pHDataPile, CmpULONG, (PBYTE)&hDmgData, FPI_COUNT)) {%@NL@%
            SemLeave();%@NL@%
            return(TRUE);%@NL@%
        }%@NL@%
        pai = pai->nextThread;%@NL@%
    } while (pai && pai->tid != tid);%@NL@%
    DosFreeSeg(SELECTOROF(hDmgData));%@NL@%
        %@NL@%
    SemLeave();%@NL@%
    return(TRUE);    %@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* BOOL EXPENTRY DdeCopyBlock(pSrc, pDst, cb)%@NL@%
%@AB@%* PBYTE pSrc;   // source of copy%@NL@%
%@AB@%* PBYTE pDst;   // destination of copy%@NL@%
%@AB@%* ULONG cb;     // size in bytes of copy%@NL@%
%@AB@%*%@NL@%
%@AB@%* This copy utility can handle HUGE segments and can be used by any%@NL@%
%@AB@%* application as a copy utility.  This does not support overlapping huge%@NL@%
%@AB@%* copies.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns fSuccess.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%* History:      1/1/89  created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL EXPENTRY DdeCopyBlock(pSrc, pDst, cb)%@NL@%
PBYTE pSrc;%@NL@%
PBYTE pDst;%@NL@%
ULONG cb;%@NL@%
{%@NL@%
    return(CopyHugeBlock(pSrc, pDst, cb));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HSZ management notes:%@NL@%
%@AB@%*%@NL@%
%@AB@%*   HSZs are used in this DLL to simplify string handling for applications%@NL@%
%@AB@%*   and for inter-process communication.  Since many applications use a%@NL@%
%@AB@%*   fixed set of Application/Topic/Item names, it is convenient to convert%@NL@%
%@AB@%*   them to HSZs and allow quick comparisons for lookups.  This also frees%@NL@%
%@AB@%*   the DLL up from having to constantly provide string buffers for copying%@NL@%
%@AB@%*   strings between itself and its clients.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   HSZs are the same as atoms except they have no restrictions on length or%@NL@%
%@AB@%*   number and are 32 bit values.  They are case preserving and can be%@NL@%
%@AB@%*   compared directly for case sensitive comparisons or via DdeCmpHsz()%@NL@%
%@AB@%*   for case insensitive comparisons.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   When an application creates an HSZ via DdeGetHsz() or increments its%@NL@%
%@AB@%*   count via DdeIncHszCount() it is essentially claiming the HSZ for%@NL@%
%@AB@%*   its own use.  On the other hand, when an application is given an%@NL@%
%@AB@%*   HSZ from the DLL via a callback, it is using another application's HSZ%@NL@%
%@AB@%*   and should not free that HSZ via DdeFreeHsz().%@NL@%
%@AB@%*%@NL@%
%@AB@%*   The DLL insures that during the callback any HSZs given will remain%@NL@%
%@AB@%*   valid for the duration of the callback.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   If an application wishes to keep that HSZ to use for itself as a%@NL@%
%@AB@%*   standard for future comparisons, it should increment its count so that,%@NL@%
%@AB@%*   should the owning application free it, the HSZ will not become invalid.%@NL@%
%@AB@%*   This also prevents an HSZ from changing its value.  (ie, app A frees it%@NL@%
%@AB@%*   and then app B creates a new one that happens to use the same HSZ code,%@NL@%
%@AB@%*   then app C, which had the HSZ stored all along (but forgot to increment%@NL@%
%@AB@%*   its count) now is holding a handle to a different string.)%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Applications may free HSZs they have created or incremented at any time%@NL@%
%@AB@%*   by calling DdeFreeHsz().%@NL@%
%@AB@%*%@NL@%
%@AB@%*   The DLL internally increments HSZ counts while in use so that they will%@NL@%
%@AB@%*   not be destroyed until both the DLL and all applications concerned are%@NL@%
%@AB@%*   through with them.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   IT IS THE APPLICATIONS RESPONSIBILITY TO PROPERLY CREATE AND FREE HSZs!!%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HSZ EXPENTRY DdeGetHsz(psz, country, codepage)%@NL@%
%@AB@%* PSZ psz;          // string to HSZize.%@NL@%
%@AB@%* USHORT country;   // country ID to use in comparisons.%@NL@%
%@AB@%* USHORT codepage;  // codepage to use in comparisons.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This routine returns a string handle to the psz passed in.%@NL@%
%@AB@%* 0 is returned on failure or for NULL strings.%@NL@%
%@AB@%*%@NL@%
%@AB@%* If country is 0, the default system country code is used.%@NL@%
%@AB@%* If codepage is 0, the default system codepage code is used.%@NL@%
%@AB@%*%@NL@%
%@AB@%* String handles are similar to atoms but without the 255%@NL@%
%@AB@%* character limit on strings.  String handles are case preserving.%@NL@%
%@AB@%* see DdeCmpHsz().%@NL@%
%@AB@%*%@NL@%
%@AB@%* String handles are consistant across all processes using the DLL.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/1/89 created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HSZ EXPENTRY DdeGetHsz(psz, country, codepage)%@NL@%
PSZ psz;%@NL@%
USHORT country, codepage;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(FALSE)) == NULL)%@NL@%
        return(0);%@NL@%
%@NL@%
    return(GetHsz(psz, country, codepage, TRUE));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* BOOL EXPENTRY DdeFreeHsz(hsz)%@NL@%
%@AB@%* HSZ hsz;      // string handle to free%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function decrements the usage count for the HSZ given and frees%@NL@%
%@AB@%* it if the count becomes 0.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/1/89 created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL EXPENTRY DdeFreeHsz(hsz)%@NL@%
HSZ hsz;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(FALSE)) == NULL)%@NL@%
        return(0);%@NL@%
    return(FreeHsz(hsz));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* BOOL EXPENTRY DdeIncHszCount(hsz)%@NL@%
%@AB@%* HSZ hsz;  // string handle to increment.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function increments the usage count for the HSZ given.  This is%@NL@%
%@AB@%* useful when an application wishes to keep an HSZ given to it in its%@NL@%
%@AB@%* callback.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/1/89 created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL EXPENTRY DdeIncHszCount(hsz)%@NL@%
HSZ hsz;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(FALSE)) == NULL)%@NL@%
        return(0);%@NL@%
%@NL@%
    return(IncHszCount(hsz));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* USHORT EXPENTRY DdeGetHszString(hsz, psz, cchMax)%@NL@%
%@AB@%* HSZ hsz;      // string handle to extract string from%@NL@%
%@AB@%* PSZ psz;      // buffer for case-sensitive string%@NL@%
%@AB@%* ULONG cchMax; // buffer size.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This API is the inverse of DdeGetHsz().  The actual length of the%@NL@%
%@AB@%* string (without NULL terminator) referenced by hsz is returned.%@NL@%
%@AB@%*%@NL@%
%@AB@%* if psz is NULL, no string is returned in psz.%@NL@%
%@AB@%* 0 is returned if hsz does not exist or is wild.%@NL@%
%@AB@%* If hsz is wild, psz will be set to a 0 length string.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%* History:      Created 5/10/89         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
USHORT EXPENTRY DdeGetHszString(hsz, psz, cchMax)%@NL@%
HSZ hsz;%@NL@%
PSZ psz;%@NL@%
ULONG cchMax;%@NL@%
{%@NL@%
    if (psz) {%@NL@%
        if (hsz) {%@NL@%
            return(QueryHszName(hsz, psz, (USHORT)cchMax));%@NL@%
        } else {%@NL@%
            *psz = '\0';%@NL@%
            return(0);%@NL@%
        }%@NL@%
    } else if (hsz) {%@NL@%
        return(QueryHszLength(hsz));%@NL@%
    } else {%@NL@%
        return(0);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* SHORT EXPENTRY DdeCmpHsz(hsz1, hsz2)%@NL@%
%@AB@%* HSZ hsz1, hsz2;   // string handles to compare.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This routine returns:%@NL@%
%@AB@%*   0  if hsz1 is of equal  rank to   hsz2%@NL@%
%@AB@%*   -2 if hsz1 is invalid.%@NL@%
%@AB@%*   -1 if hsz1 is of lower  rank than hsz2%@NL@%
%@AB@%*   1  if hsz1 is of higher rank than hsz2.%@NL@%
%@AB@%*   2  if hsz2 is invalid.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Note that direct comparison of hszs (ie (hsz1 == hsz2)) is a case sensitive%@NL@%
%@AB@%* comparison.  This function performs a case insensitive comparison.  Thus%@NL@%
%@AB@%* different valued hszs may actually be equal.%@NL@%
%@AB@%* A ranking is provided for binary searching.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
SHORT EXPENTRY DdeCmpHsz(hsz1, hsz2)%@NL@%
HSZ hsz1, hsz2;%@NL@%
{%@NL@%
    return(CmpHsz(hsz1, hsz2));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* ULONG EXPENTRY DdeCheckQueue(hConv, phDmgData, idXfer, afCmd)%@NL@%
%@AB@%* HCONV hConv;          // related convesation handle%@NL@%
%@AB@%* PHDMGDATA phDmgData;  // OUTPUT: for resultant data handle, or NULL%@NL@%
%@AB@%* ULONG idXfer;         // transaction ID or QID_NEWEST or QID_OLDEST%@NL@%
%@AB@%* ULONG afCmd;          // queue operation code.%@NL@%
%@AB@%*%@NL@%
%@AB@%*       This routine checks a client conversation's assynchronous %@NL@%
%@AB@%*       transaction queue for queued transaction status.  This allows a %@NL@%
%@AB@%*       client to extract data or monitor the status of any transaction %@NL@%
%@AB@%*       previously started asynchronously.  (TIMEOUT_ASSYNC) hConv is %@NL@%
%@AB@%*       the client conversation who's queue is being checked.  %@NL@%
%@AB@%*%@NL@%
%@AB@%*       If phDmgData is not NULL and the referenced item has data to %@NL@%
%@AB@%*       return to the client, phDmgData is filled.  Returned hDmgDatas %@NL@%
%@AB@%*       must be freed by the application.  phDmgData will be filled with %@NL@%
%@AB@%*       0L if no return data is applicable or if the transaction is not %@NL@%
%@AB@%*       complete.  %@NL@%
%@AB@%*%@NL@%
%@AB@%*       If the queue is not periodicly flushed by an application %@NL@%
%@AB@%*       issueing asynchronous transactions the queue is automaticly%@NL@%
%@AB@%*       flushed as needed.  Oldest transactions are flushed first.  %@NL@%
%@AB@%*       DdeProcessPkt() and DdeDisconnect() and DdeEndEnumServers%@NL@%
%@AB@%*       remove items from this queue.  %@NL@%
%@AB@%*%@NL@%
%@AB@%*       idXfer is the transaction id returned by an asynchronous call to %@NL@%
%@AB@%*       DdeClientXfer().%@NL@%
%@AB@%* %@NL@%
%@AB@%* afCmd = CQ_FLUSH - remove all items in the queue - return is fSuccess.%@NL@%
%@AB@%* afCmd = CQ_REMOVE - the item referenced is removed from the queue.%@NL@%
%@AB@%* afCmd = CQ_NEXT - references the idXfer AFTER (more recent than) the id %@NL@%
%@AB@%*       given. 0 is returned if the ID given was the newest in the %@NL@%
%@AB@%*       queue otherwise the next ID is returned.%@NL@%
%@AB@%* afCmd = CQ_PREV - references the idXfer BEFORE (less recent than) the id %@NL@%
%@AB@%*       given. 0 is returned if the ID given was the oldest in the %@NL@%
%@AB@%*       queue otherwise the previous ID is returned.%@NL@%
%@AB@%* afCmd = CQ_COUNT    - returns the number of entries in the queue.%@NL@%
%@AB@%*%@NL@%
%@AB@%*       By ORing in one of the following flags, the above flags can be %@NL@%
%@AB@%*       made to reference the apropriate subset of queue entries: %@NL@%
%@AB@%*%@NL@%
%@AB@%* afCmd = CQ_ACTIVEONLY - incomplete active transactions only.%@NL@%
%@AB@%* afCmd = CQ_COMPLETEDONLY - completed transactions only.%@NL@%
%@AB@%* afCmd = CQ_FAILEDONLY - transactions which had protocol violations or%@NL@%
%@AB@%*                         communication failures.%@NL@%
%@AB@%* afCmd = CQ_INACTIVEONLY - The complement of CQ_ACTIVEONLY which is the%@NL@%
%@AB@%*                           union of CQ_COMPLETEDONLY and CQ_FAILEDONLY.%@NL@%
%@AB@%* %@NL@%
%@AB@%* if phdmgdata = NULL, no hdmgdata is returned.%@NL@%
%@AB@%* if idXfer == QID_NEWEST, the top-most (most recent) entry in the %@NL@%
%@AB@%*       queue is referenced.%@NL@%
%@AB@%* if idXfer == QID_OLDEST, the bottom-most (oldest) entry ID is %@NL@%
%@AB@%*       referenced.%@NL@%
%@AB@%*%@NL@%
%@AB@%*       returns the ID of the item processed if it applies, or the count %@NL@%
%@AB@%*       of items or fSuccess.  %@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Standard usage examples:%@NL@%
%@AB@%*%@NL@%
%@AB@%*   To get the state of the oldest transaction:%@NL@%
%@AB@%*   id = DdeCheckQueue(hConv, &hDmgData, QID_OLDEST, 0)%@NL@%
%@AB@%*%@NL@%
%@AB@%*   To get and flush the next completed transaction data, if there is %@NL@%
%@AB@%*       any:%@NL@%
%@AB@%*   id = DdeCheckQueue(hConv, &hDmgData, QID_OLDEST, CQ_REMOVE | %@NL@%
%@AB@%*       CQ_INACTIVEONLY)%@NL@%
%@AB@%*%@NL@%
%@AB@%*   To flush all successfully completed transactions:%@NL@%
%@AB@%*   DdeCheckQueue(hConv, NULL, QID_OLDEST, CQ_FLUSH | CQ_COMPLETEDONLY)%@NL@%
%@AB@%*%@NL@%
%@AB@%*   To see if a specific transaction is complete, and if so, to get the%@NL@%
%@AB@%*   information and remove the transaction from the queue:%@NL@%
%@AB@%*   if (DdeCheckQueue(hConv, &hDmgData, id, CQ_REMOVE | CQ_INACTIVEONLY))%@NL@%
%@AB@%*       ProcessAndFreeData(hDmgData);%@NL@%
%@AB@%*       %@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%* History:      Created 6/6/89         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
ULONG EXPENTRY DdeCheckQueue(hConv, phDmgData, idXfer, afCmd)%@NL@%
HCONV hConv;%@NL@%
PHDMGDATA phDmgData;%@NL@%
ULONG idXfer;%@NL@%
ULONG afCmd;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
    PCLIENTINFO pci;%@NL@%
    PCQDATA pcqd, pcqdT, pcqdEnd;%@NL@%
    USHORT err;%@NL@%
    ULONG retVal = TRUE;%@NL@%
    int i;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == 0)%@NL@%
        return(0);%@NL@%
%@NL@%
    SemCheckOut();%@NL@%
    SemEnter();%@NL@%
    %@NL@%
    err = DMGERR_INVALIDPARAMETER;%@NL@%
    if (!WinIsWindow(DMGHAB, hConv) ||%@NL@%
            !(BOOL)WinSendMsg(hConv, UM_QUERY, (MPARAM)Q_CLIENT, 0L) ||%@NL@%
            idXfer == QID_SYNC) {%@NL@%
        goto failExit;%@NL@%
    }%@NL@%
    %@NL@%
    if (!(pci = (PCLIENTINFO)WinSendMsg(hConv, UM_QUERY, (MPARAM)Q_ALL, 0L))) %@NL@%
        goto failExit;%@NL@%
    %@NL@%
    err = DMGERR_UNFOUND_QUEUE_ID;%@NL@%
    if ((pcqd = (PCQDATA)Findqi(pci->pQ, idXfer)) == NULL)%@NL@%
        goto failExit;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * if referencing an end item, make sure it fits any subset flags.%@NL@%
%@AB@%     * If it doesn't we alter afCmd to force us to the first qualifying%@NL@%
%@AB@%     * entry in the correct direction.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!fInSubset(pcqd, afCmd)) {%@NL@%
        if (idXfer & (QID_OLDEST))%@NL@%
            afCmd |= CQ_NEXT;%@NL@%
        else if (idXfer & (QID_NEWEST))%@NL@%
            afCmd |= CQ_PREV;%@NL@%
        else if (!(afCmd & (CQ_NEXT | CQ_PREV | CQ_COUNT | CQ_FLUSH)))%@NL@%
            goto failExit;%@NL@%
    }%@NL@%
    %@NL@%
    if (afCmd & CQ_NEXT) {%@NL@%
        pcqdEnd = (PCQDATA)pci->pQ->pqiHead->next;%@NL@%
        if ((pcqd = (PCQDATA)pcqd->next) == pcqdEnd)%@NL@%
            goto failExit;%@NL@%
        while (!fInSubset(pcqd, afCmd)) {%@NL@%
            if ((pcqd = (PCQDATA)pcqd->next) == pcqdEnd)%@NL@%
                goto failExit;%@NL@%
        }%@NL@%
    }%@NL@%
            %@NL@%
    if (afCmd & CQ_PREV) {%@NL@%
        pcqdEnd = (PCQDATA)pci->pQ->pqiHead;%@NL@%
        if ((pcqd = (PCQDATA)pcqd->prev) == pcqdEnd)%@NL@%
            goto failExit;%@NL@%
        while (!fInSubset(pcqd, afCmd)) {%@NL@%
            if ((pcqd = (PCQDATA)pcqd->prev) == pcqdEnd)%@NL@%
                goto failExit;%@NL@%
        }%@NL@%
    }%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * pcqd now points to the apropriate entry%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    if (afCmd & CQ_COUNT) %@NL@%
        retVal = 0;%@NL@%
    else%@NL@%
        retVal = MAKEID(pcqd);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Fill phDmgData if specified.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (phDmgData != NULL)%@NL@%
        if ((pcqd->xad.state == CONVST_CONNECTED) &&%@NL@%
                CheckSel(SELECTOROF(pcqd->xad.pddes))) {%@NL@%
            *phDmgData = pcqd->xad.pddes;%@NL@%
            AddPileItem(pai->pHDataPile, (PBYTE)phDmgData, CmpULONG);%@NL@%
            if (((PMYDDES)*phDmgData)->magic == MYDDESMAGIC) {%@NL@%
                ((PMYDDES)*phDmgData)->fs |= HDATA_READONLY;%@NL@%
            }%@NL@%
        } else%@NL@%
            *phDmgData = NULL;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * remove pcqd if apropriate.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (afCmd & (CQ_REMOVE | CQ_FLUSH)) {%@NL@%
        if (!FindPileItem(pai->pHDataPile, CmpULONG, (PBYTE)&pcqd->xad.pddes,%@NL@%
                0))%@NL@%
            FreeData((PMYDDES)pcqd->xad.pddes, pai);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Decrement the use count we incremented when the client started%@NL@%
%@AB@%         * this transaction.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        FreeHsz(pcqd->XferInfo.hszItem);%@NL@%
        Deleteqi(pci->pQ, MAKEID(pcqd));%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * go through entire list and flush or count if specified.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (afCmd & (CQ_FLUSH | CQ_COUNT)) {%@NL@%
        pcqd = (PCQDATA)pci->pQ->pqiHead;%@NL@%
        for (i = pci->pQ->cItems; i; i--) {%@NL@%
            if (fInSubset(pcqd, afCmd)) {%@NL@%
                if (afCmd & CQ_COUNT) %@NL@%
                    retVal++;%@NL@%
                if (afCmd & CQ_FLUSH) {%@NL@%
                    pcqdT = (PCQDATA)pcqd->next;%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                     * Only free the data if not logged - ie the user never got a%@NL@%
%@AB@%                     * copy.%@NL@%
%@AB@%                     */%@AE@%%@NL@%
                    if (!FindPileItem(pci->ci.pai->pHDataPile, CmpULONG,%@NL@%
                            (PBYTE)&pcqd->xad.pddes, 0))%@NL@%
                        FreeData((PMYDDES)pcqd->xad.pddes, pai);%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                     * Decrement the use count we incremented when the client started%@NL@%
%@AB@%                     * this transaction.%@NL@%
%@AB@%                     */%@AE@%%@NL@%
                    FreeHsz(pcqd->XferInfo.hszItem);%@NL@%
                    Deleteqi(pci->pQ, MAKEID(pcqd));%@NL@%
                    pcqd = pcqdT;%@NL@%
                    continue;%@NL@%
                }%@NL@%
            }%@NL@%
            pcqd = (PCQDATA)pcqd->next;%@NL@%
        }%@NL@%
    }%@NL@%
        %@NL@%
    SemLeave();%@NL@%
    SemCheckOut();%@NL@%
    return(retVal);%@NL@%
    %@NL@%
failExit:%@NL@%
    pai->LastError = err;%@NL@%
    SemLeave();%@NL@%
    SemCheckOut();%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
BOOL fInSubset(pcqd, afCmd)%@NL@%
PCQDATA pcqd;%@NL@%
ULONG afCmd;%@NL@%
{%@NL@%
    if (afCmd & CQ_ACTIVEONLY && (pcqd->xad.state <= CONVST_INIT1))%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    if (afCmd & CQ_INACTIVEONLY && (pcqd->xad.state > CONVST_INIT1))%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    if (afCmd & CQ_COMPLETEDONLY && (pcqd->xad.state != CONVST_CONNECTED))%@NL@%
        return(FALSE);%@NL@%
                            %@NL@%
    if (afCmd & CQ_FAILEDONLY && (pcqd->xad.state > CONVST_TERMINATED))%@NL@%
        return(FALSE);%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* BOOL EXPENTRY DdeEnableCallback(hConv, fEnable)%@NL@%
%@AB@%* HCONV hConv;      // server conversation handle to enable/disable or NULL %@NL@%
%@AB@%* BOOL fEnable;     // TRUE enables, FALSE disables callbacks.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This routine is used by an application that does not want to be interrupted%@NL@%
%@AB@%* by DLL calls to its Callback function.  When callbacks are disabled,%@NL@%
%@AB@%* all non critical attempts to call the Callback function instead result in%@NL@%
%@AB@%* the call being placed on a server transaction queue until callbacks are%@NL@%
%@AB@%* reenabled.  An application should reenable callbacks in a timely manner%@NL@%
%@AB@%* to avoid causing synchronous clients to time out.%@NL@%
%@AB@%*%@NL@%
%@AB@%* note that DdeProcessPkt() has the side effect of unblocking and removing%@NL@%
%@AB@%* items from the server transaction queue when processing return packets.%@NL@%
%@AB@%* DdeDisconnect() and DdeEndEnumServers() have the side effect of removing%@NL@%
%@AB@%* any transactions for the disconnected conversation.%@NL@%
%@AB@%*%@NL@%
%@AB@%* If hConv is non-NULL, only the hConv conversation is affected.%@NL@%
%@AB@%* If hConv is NULL, all conversations are affected.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Callbacks can also be disabled on return from the callback function by%@NL@%
%@AB@%* returning the constant CBR_BLOCK.  This has the same effect as%@NL@%
%@AB@%* calling DdeEnableCallback(hConv, FALSE) except that the callback%@NL@%
%@AB@%* returned from is placed back on the callback queue for later re-submission%@NL@%
%@AB@%* to the callback function when the conversations callbacks are reenabled.%@NL@%
%@AB@%* This allows a server that needs a long time to process a request to delay%@NL@%
%@AB@%* returning the result without blocking within the callback function.%@NL@%
%@AB@%* %@NL@%
%@AB@%* No callbacks are made within this function.%@NL@%
%@AB@%* %@NL@%
%@AB@%* Note:  Callback transactions that have XTYPF_NOBLOCK set in their usType%@NL@%
%@AB@%*       parameter cannot be blocked by CBR_BLOCK.%@NL@%
%@AB@%*       These callbacks are issued to the server regardless of the state of%@NL@%
%@AB@%*       callback enableing.%@NL@%
%@AB@%*%@NL@%
%@AB@%* fSuccess is returned.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%* History:      Created 6/6/89         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL EXPENTRY DdeEnableCallback(hConv, fEnable)%@NL@%
HCONV hConv;%@NL@%
BOOL fEnable;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == 0)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    SemCheckOut();%@NL@%
    SemEnter();%@NL@%
    if (hConv == NULL) {%@NL@%
        pai->fEnableCB = fEnable = fEnable ? TRUE : FALSE;%@NL@%
        FlushLst(pai->plstCBExceptions);%@NL@%
    } else if (pai->fEnableCB != fEnable) {%@NL@%
        if (pai->plstCBExceptions == NULL) %@NL@%
            pai->plstCBExceptions = CreateLst(pai->hheapApp, sizeof(HWNDLI));%@NL@%
        AddHwndList((HWND)hConv, pai->plstCBExceptions);%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    if (fEnable)%@NL@%
        WinPostMsg(pai->hwndDmg, UM_CHECKCBQ, (MPARAM)pai, 0L);%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HDMGDATA EXPENTRY DdeAppNameServer(hszApp, afCmd);%@NL@%
%@AB@%* HSZ hszApp;       // referenced app name%@NL@%
%@AB@%* USHORT afCmd;     // action code.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Updates or queries the DDE DLL application name server.  The DDE name%@NL@%
%@AB@%* server acts as a filter for initiate messages on behalf of registered%@NL@%
%@AB@%* applications and serves as a way for an application to determine what%@NL@%
%@AB@%* other applications are available without the need for wild initiates.%@NL@%
%@AB@%* Any change in the name server results in XTYP_REGISTER or XTYP_UNREGISTER%@NL@%
%@AB@%* callbacks to all other applications.  Agents will not be allowed to%@NL@%
%@AB@%* know about any other agent registrations.%@NL@%
%@AB@%*%@NL@%
%@AB@%* afCmd:%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ANS_REGISTER%@NL@%
%@AB@%*       Adds hszApp to the name server.  hszApp cannot be NULL.%@NL@%
%@AB@%*       All other applications will receive a registration notification%@NL@%
%@AB@%*       if their callback filters allow it.%@NL@%
%@AB@%*       fSuccess is returned.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ANS_UNREGISTER%@NL@%
%@AB@%*       Remove hszApp from the name server.  If hszApp==NULL the name server%@NL@%
%@AB@%*       is cleared for the calling application.%@NL@%
%@AB@%*       All other applications will receive a deregistration notification%@NL@%
%@AB@%*       if their callback filters allow it.%@NL@%
%@AB@%*       fSuccess is returned.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ANS_QUERYALLBUTME%@NL@%
%@AB@%*       Returns a zero terminated array of hszApps/hApp pairs registered with%@NL@%
%@AB@%*       the name server by all other applications.%@NL@%
%@AB@%*       (Agent applications do not see other agent registered names.)%@NL@%
%@AB@%*       If hszApp is set, only names matching* hszApp are placed into the list.%@NL@%
%@AB@%*       0 is returned if no applicable names were found.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ANS_QUERYMINE%@NL@%
%@AB@%*       Returns a zero terminated array of hszApps registered with the name%@NL@%
%@AB@%*       server by the calling application.  If hszApp is set, only names%@NL@%
%@AB@%*       matching hszApp are placed into the list.  0 is returned if no%@NL@%
%@AB@%*       applicable names were found.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   The following flags may be ORed in with one of the above flags:%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ANS_FILTERON%@NL@%
%@AB@%*       Turns on dde initiate callback filtering.  Only wild app names or%@NL@%
%@AB@%*       those matching a registered name are given to the application for%@NL@%
%@AB@%*       initiate requests or registration notifications.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ANS_FILTEROFF%@NL@%
%@AB@%*       Turns off dde initiate callback filtering.  All initiate requests%@NL@%
%@AB@%*       and registration notifications are passed onto the application.%@NL@%
%@AB@%*%@NL@%
%@AB@%* A 0 is returned on error.%@NL@%
%@AB@%* %@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA EXPENTRY DdeAppNameServer(hszApp, afCmd)%@NL@%
HSZ hszApp;%@NL@%
USHORT afCmd;%@NL@%
{%@NL@%
    PAPPINFO pai, paiT;%@NL@%
    BOOL fAgent;%@NL@%
    HDMGDATA hData;%@NL@%
    HSZ hsz;%@NL@%
    %@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == 0)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    if (afCmd & ANS_FILTERON)%@NL@%
        pai->afCmd |= DMGCMD_FILTERINITS;%@NL@%
%@NL@%
    if (afCmd & ANS_FILTEROFF) %@NL@%
        pai->afCmd &= ~DMGCMD_FILTERINITS;%@NL@%
%@NL@%
    %@NL@%
    if (afCmd & (ANS_REGISTER | ANS_UNREGISTER)) {%@NL@%
        %@NL@%
        if (pai->afCmd & DMGCMD_CLIENTONLY) {%@NL@%
            pai->LastError = DMGERR_DLL_USAGE;%@NL@%
            return(FALSE);%@NL@%
        }%@NL@%
    %@NL@%
        fAgent = pai->afCmd & DMGCMD_AGENT ? TRUE : FALSE;%@NL@%
        %@NL@%
        if (hszApp == NULL) {%@NL@%
            if (afCmd & ANS_REGISTER) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * registering NULL is not allowed!%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                pai->LastError = DMGERR_INVALIDPARAMETER;%@NL@%
                return(FALSE);%@NL@%
            }%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * unregistering NULL is just like unregistering each%@NL@%
%@AB@%             * registered name.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            while (PopPileSubitem(pai->pAppNamePile, (PBYTE)&hsz)) {%@NL@%
                for (paiT = pAppInfoList; paiT; paiT = paiT->next) {%@NL@%
                    if (pai == paiT || (fAgent && (paiT->afCmd & DMGCMD_AGENT))) %@NL@%
                        continue;%@NL@%
                    WinPostMsg(paiT->hwndFrame, UM_UNREGISTER, (MPARAM)hsz,%@NL@%
                            (MPARAM)pai->hwndFrame);%@NL@%
                }%@NL@%
            }%@NL@%
            return(TRUE);%@NL@%
        }%@NL@%
            %@NL@%
        if (afCmd & ANS_REGISTER) {%@NL@%
            if (pai->pAppNamePile == NULL) %@NL@%
                pai->pAppNamePile = CreatePile(hheapDmg, sizeof(HSZ), 8);%@NL@%
            AddPileItem(pai->pAppNamePile, (PBYTE)&hszApp, NULL);%@NL@%
        } else%@NL@%
            FindPileItem(pai->pAppNamePile, CmpULONG, (PBYTE)&hszApp,%@NL@%
                    FPI_DELETE);%@NL@%
%@NL@%
        for (paiT = pAppInfoList; paiT; paiT = paiT->next) {%@NL@%
            if (pai == paiT ||%@NL@%
                    (fAgent && (paiT->afCmd & DMGCMD_AGENT))) {%@NL@%
                continue;%@NL@%
            }%@NL@%
            WinPostMsg(paiT->hwndFrame,%@NL@%
                    afCmd & ANS_REGISTER ? UM_REGISTER : UM_UNREGISTER,%@NL@%
                    (MPARAM)hszApp, (MPARAM)pai->hwndFrame);%@NL@%
        }%@NL@%
        return(TRUE);%@NL@%
    }%@NL@%
%@NL@%
    if (afCmd & ANS_QUERYMINE) {%@NL@%
        hData = PutData(NULL, 10L * sizeof(HSZ),%@NL@%
                0L, 0L, 0, HDATA_APPOWNED | HDATA_APPFREEABLE, pai);%@NL@%
        if (QueryAppNames(pai, hData, hszApp, 0L)) {%@NL@%
            return(hData);%@NL@%
        } else {%@NL@%
            DdeFreeData(hData);%@NL@%
            return(0L);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (afCmd & ANS_QUERYALLBUTME) {%@NL@%
        ULONG offAdd, offAddNew;%@NL@%
        %@NL@%
        hData = PutData(NULL, 10L * sizeof(HSZ),%@NL@%
                0L, 0L, 0, HDATA_APPOWNED | HDATA_APPFREEABLE, pai);%@NL@%
        *((PHSZ)DDES_PABDATA((PDDESTRUCT)hData)) = 0L;%@NL@%
        SemEnter();%@NL@%
        paiT = pAppInfoList;%@NL@%
        offAdd = 0L;%@NL@%
        while (paiT) {%@NL@%
            if (paiT != pai &&%@NL@%
                    !(fAgent && (paiT->afCmd & DMGCMD_AGENT))) {%@NL@%
                offAddNew = QueryAppNames(paiT, hData, hszApp, offAdd);%@NL@%
                if (offAddNew == 0 && offAddNew < offAdd) {%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                     * memory error most likely.%@NL@%
%@AB@%                     */%@AE@%%@NL@%
                    SemLeave();%@NL@%
                    DdeFreeData(hData);%@NL@%
                    return(0L);%@NL@%
                }%@NL@%
                offAdd = offAddNew;%@NL@%
            }%@NL@%
            paiT = paiT->next;%@NL@%
        }%@NL@%
        SemLeave();%@NL@%
        return(hData);%@NL@%
    }%@NL@%
%@NL@%
    return(0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HDMGDATA EXPENTRY DdeCreateInitPkt(%@NL@%
%@AB@%* HSZ hszApp,         // initiate app string%@NL@%
%@AB@%* HSZ hszTopic,       // initiate topic string%@NL@%
%@AB@%* HDMGDATA hDmgData)  // packet data containing language information.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This routine is called by agent applications from within their callback%@NL@%
%@AB@%* functions which need to store transaction initiate data into a %@NL@%
%@AB@%* network-portable packet.  On return, HDMGDATA contains the packeted %@NL@%
%@AB@%* data.  The calling application must free this data handle when %@NL@%
%@AB@%* through.  Agents are given access to the app string so that they%@NL@%
%@AB@%* can modify it if needed for their net protocol.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA EXPENTRY DdeCreateInitPkt(hszApp, hszTopic, hDmgData)%@NL@%
HSZ hszApp;%@NL@%
HSZ hszTopic;%@NL@%
HDMGDATA hDmgData;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    hszApp;%@NL@%
    hszTopic;%@NL@%
    hDmgData;%@NL@%
%@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == NULL)%@NL@%
        return(0);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Add hDataRet to thread list%@NL@%
%@AB@%     */%@AE@%%@NL@%
    pai->LastError = DMGERR_NOT_IMPLEMENTED;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* BOOL EXPENTRY DdeProcessPkt(%@NL@%
%@AB@%* HDMGDATA hPkt,        // packet from net to process%@NL@%
%@AB@%* ULONG hAgentFrom);    // foreign agent handle associated with this packet.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This routine is called by agent applications which have received a packet%@NL@%
%@AB@%* from another agent.  This call performs what actions are requested by the%@NL@%
%@AB@%* hPkt.  If the particular transaction can be done synchronously, a return%@NL@%
%@AB@%* packet is returned.  If not, an XTYP_RTNPKT callback will eventually be%@NL@%
%@AB@%* sent to the agent and 0 is returned.  0 is also returned on error.%@NL@%
%@AB@%*%@NL@%
%@AB@%* hAgentFrom identifies the agent the packet came from.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This call should NOT be made from within a callback.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA EXPENTRY DdeProcessPkt(hPkt, hAgentFrom)%@NL@%
HDMGDATA hPkt;%@NL@%
ULONG hAgentFrom;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    hPkt;%@NL@%
    hAgentFrom;%@NL@%
    %@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == NULL)%@NL@%
        return(0);%@NL@%
    pai->LastError = DMGERR_NOT_IMPLEMENTED;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* ULONG EXPENTRY DdeQueryVersion()%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns the DLL version number: 0xjjmmuuppL%@NL@%
%@AB@%* jj = major release;%@NL@%
%@AB@%* mm = minor release;%@NL@%
%@AB@%* uu = update number;%@NL@%
%@AB@%* pp = platform ID; 1=OS/2, 2=DOS, 3=WINDOWS, 4=UNIX, 5=MAC, 6=SUN%@NL@%
%@AB@%* %@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
ULONG EXPENTRY DdeQueryVersion()%@NL@%
{%@NL@%
    return(MAKEULONG(MAKESHORT(1, rup),MAKESHORT(rmm, rmj)));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/* PUBDOC START%@NL@%
%@AB@% * ----------------------- Platform specific APIs -----------------------%@NL@%
%@AB@% * PUBDOC END%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HCONV EXPENTRY DdeConverseWithWindow(%@NL@%
%@AB@%* HWND hwnd,            // server window to converse with%@NL@%
%@AB@%* HSZ hszApp,           // app name to converse on%@NL@%
%@AB@%* HSZ hszTopic,         // topic name to converse on%@NL@%
%@AB@%* PCONVCONTEXT pCC)     // language information to converse on%@NL@%
%@AB@%* %@NL@%
%@AB@%* This creates a pre-initiated client conversation with the given hwnd. %@NL@%
%@AB@%* The conversation is assumed to be on the given app, topic and context.%@NL@%
%@AB@%* This is useful for implementing such things as drag and drop DDE %@NL@%
%@AB@%* protocols.  hszApp and hszTopic cannot be NULL.  See%@NL@%
%@AB@%* DdeCreateServerWindow().%@NL@%
%@AB@%*  %@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HCONV EXPENTRY DdeConverseWithWindow(hwnd, hszApp, hszTopic, pCC)%@NL@%
HWND hwnd;     %@NL@%
HSZ hszApp, hszTopic;  %@NL@%
PCONVCONTEXT pCC;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    UNUSED hwnd;%@NL@%
    UNUSED hszApp;%@NL@%
    UNUSED hszTopic;%@NL@%
    UNUSED pCC;%@NL@%
    %@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == NULL)%@NL@%
        return(0);%@NL@%
%@NL@%
    if (QuerylatomLength((LATOM)hszApp) == 0 ||%@NL@%
            QuerylatomLength((LATOM)hszTopic) == 0) {%@NL@%
        pai->LastError = DMGERR_INVALIDPARAMETER;%@NL@%
        return(0);%@NL@%
    }%@NL@%
    %@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* HWND DdeCreateServerWindow(hszApp, hszTopic, pCC)%@NL@%
%@AB@%* HSZ hszApp,       // app name to accept conversations on.%@NL@%
%@AB@%* HSZ hszTopic;     // topic name to accept conversations on.%@NL@%
%@AB@%* PCONVCONTEXT pCC; // language information to accept or NULL for sys default.%@NL@%
%@AB@%*    %@NL@%
%@AB@%* This creates a pre_initiated server DDE window for the caller.  The %@NL@%
%@AB@%* server window does not know what client window it will be talking to.  As %@NL@%
%@AB@%* soon as any DDE message is received by the DDE server window, its %@NL@%
%@AB@%* companion client hwnd is remembered and the conversation is 'locked in'.  %@NL@%
%@AB@%* The hwnd of the server window is returned.  hszApp and hszTopic cannot %@NL@%
%@AB@%* be NULL.  %@NL@%
%@AB@%*    %@NL@%
%@AB@%* Typically, the server app would call CreateServerWindow() and pass the %@NL@%
%@AB@%* hwnd to some prospective client via some other transport mechanism.  The %@NL@%
%@AB@%* client would then call ConverseWithWindow() with the hwnd it received %@NL@%
%@AB@%* from the server and then begin DDE transactions using the HCONV returned.  %@NL@%
%@AB@%*    %@NL@%
%@AB@%* A server may pass this hwnd to many potential clients.  Only the first %@NL@%
%@AB@%* one that responds would get 'locked in'.  The rest would be out of luck %@NL@%
%@AB@%* and their API calls would fail.  The server window ignores messages that%@NL@%
%@AB@%* to not fit the app and topic given.%@NL@%
%@AB@%*  %@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
HWND EXPENTRY DdeCreateServerWindow(hszApp, hszTopic, pCC)%@NL@%
HSZ hszApp, hszTopic;%@NL@%
PCONVCONTEXT pCC;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
    INITINFO ii;%@NL@%
    HWND hwndServer;%@NL@%
    %@NL@%
    hszApp;%@NL@%
    hszTopic;%@NL@%
    pCC;%@NL@%
    %@NL@%
    if ((pai = GetCurrentAppInfo(TRUE)) == NULL)%@NL@%
        return(0);%@NL@%
        %@NL@%
    if (QuerylatomLength((LATOM)hszApp) == 0 ||%@NL@%
            QuerylatomLength((LATOM)hszTopic) == 0) {%@NL@%
        pai->LastError = DMGERR_INVALIDPARAMETER;%@NL@%
        return(0);%@NL@%
    }%@NL@%
    %@NL@%
    if ((hwndServer = CreateServerWindow(pai, hszTopic)) == NULL)%@NL@%
        return(0);%@NL@%
%@NL@%
    ii.hszAppName = hszApp;%@NL@%
    ii.hszTopic = hszTopic;%@NL@%
    ii.hwndSend =%@NL@%
    ii.hwndFrame = NULL;%@NL@%
    ii.pCC = pCC;%@NL@%
    WinSendMsg(hwndServer, UMSR_INITIATE, 0L, 0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DDESPY.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\DDESPY\DDESPY.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name: ddespy%@NL@%
%@AB@%*%@NL@%
%@AB@%* This is a small DDE ddespyr which lets me see whats going on.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created:      sanfords%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@AI@%#include %@AE@%"ddespy.h" %@NL@%
%@NL@%
%@AB@%/*********** declares *********/%@AE@%%@NL@%
%@NL@%
HWND hwndExec = NULL;%@NL@%
%@NL@%
SWP gswp[IW_LAST - IW_FIRST + 1];%@NL@%
PSZ apszTitles[] = {%@NL@%
        "Applications", "Topics", "System Items", "Data"%@NL@%
                   };%@NL@%
%@NL@%
%@NL@%
PSZ apszType[] = {%@NL@%
                        "0-Type"        ,%@NL@%
                        "ACK"           ,%@NL@%
                        "ADVDATA"       ,   %@NL@%
                        "ADVREQ"        ,    %@NL@%
                        "ADVSTART"      ,  %@NL@%
                        "ADVSTOP"       ,   %@NL@%
                        "EXEC"          ,      %@NL@%
                        "INIT"          ,%@NL@%
                        "INITCONF"      ,%@NL@%
                        "MONITOR"       ,%@NL@%
                        "PKT"           ,%@NL@%
                        "POKE"          ,%@NL@%
                        "REGISTER"      ,  %@NL@%
                        "REQUEST"       ,%@NL@%
                        "RTNPKT"        ,%@NL@%
                        "TERM"          ,      %@NL@%
                        "UNREGISTER"    ,%@NL@%
                        "WILDINIT"      ,%@NL@%
                        "XFERCOMP"      ,%@NL@%
                        "19"            ,%@NL@%
                        "20"            ,%@NL@%
                        "21"            ,%@NL@%
                        "22"            ,%@NL@%
                        "23"            ,%@NL@%
                        "24"            ,%@NL@%
                        "25"            ,%@NL@%
                        "26"            ,%@NL@%
                        "27"            ,%@NL@%
                        "28"            ,%@NL@%
                        "29"            ,%@NL@%
                        "30"            ,%@NL@%
                        "31"            ,%@NL@%
               };%@NL@%
%@NL@%
PSZ apszState[] = {         %@AB@%/* corresponds to convinfo.usStatus */%@AE@%%@NL@%
                        "DISCONNECTED"      ,%@NL@%
                        "CONNECTED"         ,%@NL@%
                        "NOADVISE"          ,%@NL@%
                        "ADVISE"            ,%@NL@%
                  };%@NL@%
%@NL@%
PSZ apszStatus[] = {        %@AB@%/* corresponds to convionfi.usConvst */%@AE@%%@NL@%
                        "NOACTIVITY"    ,     %@NL@%
                        "INCOMPLETE"    ,    %@NL@%
                        "TERMINATED"    ,    %@NL@%
                        "CONNECTED"     ,%@NL@%
                        "INITIATING"    ,         %@NL@%
                        "REQSENT"       ,       %@NL@%
                        "DATARCVD"      ,      %@NL@%
                        "POKESENT"      ,      %@NL@%
                        "POKEACKRCVD"   ,   %@NL@%
                        "EXECSENT"      ,      %@NL@%
                        "EXECACKRCVD"   ,   %@NL@%
                        "ADVSENT"       ,       %@NL@%
                        "UNADVSENT"     ,     %@NL@%
                        "ADVACKRCVD"    ,    %@NL@%
                        "UNADVACKRCVD"  ,  %@NL@%
                        "ADVDATASENT"   ,   %@NL@%
                        "ADVDATAACKRCVD",%@NL@%
                   };%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%GetLBCount(hw) (SHORT)WinSendMsg((hw), LM_QUERYITEMCOUNT, 0L, 0L) %@NL@%
%@AI@%#define %@AE@%GetLBSelectedItem(hw) \ %@NL@%
            (SHORT)WinSendMsg((hw), LM_QUERYSELECTION, (MPARAM)LIT_FIRST, 0L)%@NL@%
%@AI@%#define %@AE@%GetLBItemHandle(hw, i) \ %@NL@%
            (ULONG)WinSendMsg((hw), LM_QUERYITEMHANDLE, (MPARAM)(i), 0L)%@NL@%
%@AI@%#define %@AE@%GetLBItemText(hw, i, cch, psz) \ %@NL@%
            (ULONG)WinSendMsg((hw), LM_QUERYITEMTEXT, MPFROM2SHORT((i),(cch)), (MPARAM)(psz))%@NL@%
%@AI@%#define %@AE@%DeleteLBItem(hw, i) WinSendMsg(hw, LM_DELETEITEM, MPFROMSHORT(i), 0L) %@NL@%
%@AI@%#define %@AE@%NotifyOwner(hwnd, msg, mp1, mp2) \ %@NL@%
            (WinSendMsg(WinQueryWindow(hwnd, QW_OWNER, FALSE), msg, mp1, mp2))%@NL@%
%@NL@%
%@NL@%
void cdecl main(int argc, char **argv);%@NL@%
void ResizeChildren(USHORT cxNew, USHORT cyNew);%@NL@%
HDMGDATA EXPENTRY dataxfer(HCONV hConv, HSZ hszTopic, HSZ hszItem,%@NL@%
        USHORT usFmt, USHORT usType, HDMGDATA hDmgData);%@NL@%
MRESULT EXPENTRY ClientWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2);%@NL@%
MRESULT EXPENTRY GetTimeoutDlgProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2);%@NL@%
MRESULT EXPENTRY EnhancedEFWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2);%@NL@%
MRESULT EXPENTRY ExecDlgProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2);%@NL@%
void Refresh(void);%@NL@%
SHORT InsertLBItem(HWND hwndLB, PSZ psz, ULONG ulHandle);%@NL@%
void SetLBEntries(HCONV hConv, HSZ hszItem, USHORT iwlb);%@NL@%
void UpdateQueue(HWND hwndCB, HCONV hConv);%@NL@%
void ConvInfoToString(PCONVINFO pci, PSZ psz, USHORT cbMax);%@NL@%
PSZ mylstrcat(PSZ psz1, PSZ psz2, PSZ pszLast);%@NL@%
int lstrlen(PSZ psz);%@NL@%
%@NL@%
%@AB@%/************* GLOBAL VARIABLES  ************/%@AE@%%@NL@%
%@NL@%
HAB hab;%@NL@%
HMQ hmq;%@NL@%
HHEAP hheap;%@NL@%
HWND hwndFrame;%@NL@%
HWND hwndClient;%@NL@%
USHORT cyTitles;%@NL@%
USHORT cxBorder;%@NL@%
HCONVLIST hConvListMain;%@NL@%
HSZ hszSysTopic;%@NL@%
HSZ hszSysItemTopics;%@NL@%
HSZ hszSysItemSysItems;%@NL@%
ULONG gTimeout = 1000L;%@NL@%
PFNWP lpfnSysEFWndProc;%@NL@%
%@NL@%
void cdecl main(argc, argv)%@NL@%
int argc;%@NL@%
char **argv;%@NL@%
{%@NL@%
    USHORT err;%@NL@%
    QMSG qmsg;%@NL@%
%@NL@%
    argc; argv;%@NL@%
    %@NL@%
    hab = WinInitialize(0);%@NL@%
    hmq = WinCreateMsgQueue(hab, 0);%@NL@%
    hheap = WinCreateHeap(0, 0, 0, 0, 0, HM_MOVEABLE);%@NL@%
%@NL@%
    if (!WinRegisterClass(hab, "DDESpyr Class", ClientWndProc, CS_SIZEREDRAW, 0))%@NL@%
        goto abort;%@NL@%
%@NL@%
    cyTitles = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYTITLEBAR);%@NL@%
    cxBorder = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CXBORDER);%@NL@%
%@NL@%
    hwndFrame = WinCreateStdWindow(HWND_DESKTOP, WS_VISIBLE, NULL,%@NL@%
            (PSZ)"DDESpyr Class",%@NL@%
            (PSZ)"", WS_VISIBLE, (HMODULE)NULL, IDR_MAIN,%@NL@%
            &hwndClient);%@NL@%
%@NL@%
    WinSetWindowText(hwndFrame, "DDE Spy");%@NL@%
    if (err = DdeInitialize((PFNCALLBACK)dataxfer, 0L, 0L)) {%@NL@%
        DdePostError(err);%@NL@%
        goto abort;%@NL@%
    }%@NL@%
%@NL@%
    hszSysTopic = DdeGetHsz((PSZ)SZDDESYS_TOPIC, 0, 0);%@NL@%
    hszSysItemTopics = DdeGetHsz((PSZ)SZDDESYS_ITEM_TOPICS, 0, 0);%@NL@%
    hszSysItemSysItems = DdeGetHsz((PSZ)SZDDESYS_ITEM_SYSITEMS, 0, 0);%@NL@%
%@NL@%
    Refresh();%@NL@%
%@NL@%
    while (WinGetMsg(hab, &qmsg, 0, 0, 0)) {%@NL@%
        WinDispatchMsg(hab, &qmsg);%@NL@%
    }%@NL@%
%@NL@%
    DdeUninitialize();%@NL@%
abort:%@NL@%
    if (hwndFrame)%@NL@%
        WinDestroyWindow(hwndFrame);%@NL@%
    if (hheap) {%@NL@%
        WinDestroyHeap(hheap);%@NL@%
    }%@NL@%
    WinTerminate(hab);%@NL@%
    DosExit(TRUE, 0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1, mp2;%@NL@%
{%@NL@%
    USHORT i;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_CREATE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * initialize globals%@NL@%
%@AB@%         */%@AE@%%@NL@%
        hwndClient = hwnd;%@NL@%
        for (i = IW_APPSLBOX; i <= IW_ITEMSLBOX; i++) {%@NL@%
            gswp[i].hwnd = WinCreateWindow(hwndClient, WC_LISTBOX, "",%@NL@%
                    WS_VISIBLE | LS_NOADJUSTPOS, 0, 0, 0, 0, hwndClient,%@NL@%
                    HWND_TOP, i, NULL, NULL);%@NL@%
        }%@NL@%
        for (i = IW_APPSTITLE; i <= IW_DATATITLE; i++) {%@NL@%
            gswp[i].hwnd = WinCreateWindow(hwndClient, WC_STATIC,%@NL@%
                    apszTitles[i - IW_APPSTITLE],%@NL@%
                    WS_VISIBLE | SS_TEXT | DT_CENTER | DT_BOTTOM,%@NL@%
                    0, 0, 0, 0, hwndClient,%@NL@%
                    HWND_TOP, i, NULL, NULL);%@NL@%
        }%@NL@%
        gswp[IW_DATATEXT].hwnd = WinCreateWindow(hwndClient, WC_STATIC, "",%@NL@%
                WS_VISIBLE | SS_TEXT | DT_WORDBREAK,%@NL@%
                0, 0, 0, 0, hwndClient,%@NL@%
                HWND_TOP, i, NULL, NULL);%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
        case IDM_REFRESH:%@NL@%
            Refresh();%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_SETTIMEOUT:%@NL@%
            gTimeout = (USHORT)WinDlgBox(hwndFrame, NULL,%@NL@%
                    (PFNWP)GetTimeoutDlgProc,%@NL@%
                    (HMODULE)NULL, IDD_GETTIMEOUT, NULL);%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_EXEC:%@NL@%
            WinDlgBox(HWND_DESKTOP, hwnd, ExecDlgProc, NULL, IDD_EXEC, NULL);%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CONTROL:%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
        case IW_APPSLBOX:%@NL@%
            switch (HIUSHORT(mp1)) {%@NL@%
            case LN_SELECT:%@NL@%
                hwnd = gswp[IW_APPSLBOX].hwnd;%@NL@%
                SetLBEntries((HCONV)GetLBItemHandle(hwnd,%@NL@%
                        GetLBSelectedItem(hwnd)),%@NL@%
                        hszSysItemTopics, IW_TOPICSLBOX);%@NL@%
                SetLBEntries((HCONV)GetLBItemHandle(hwnd,%@NL@%
                        GetLBSelectedItem(hwnd)),%@NL@%
                        hszSysItemSysItems, IW_ITEMSLBOX);%@NL@%
                break;%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case IW_TOPICSLBOX:%@NL@%
            break;%@NL@%
%@NL@%
        case IW_ITEMSLBOX:%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            goto DoDefAction;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_SIZE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * resize children%@NL@%
%@AB@%         */%@AE@%%@NL@%
        ResizeChildren(SHORT1FROMMP(mp2), SHORT2FROMMP(mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_ERASEBACKGROUND:%@NL@%
        return(TRUE);%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
DoDefAction:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
    }%@NL@%
    return(0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
void ResizeChildren(cxNew, cyNew)%@NL@%
USHORT cxNew, cyNew;%@NL@%
{%@NL@%
    USHORT i;%@NL@%
%@NL@%
    for (i = IW_FIRST; i <= IW_LAST; i++) {%@NL@%
        gswp[i].fs = SWP_SIZE | SWP_MOVE | SWP_SHOW;%@NL@%
        gswp[i].hwndInsertBehind = HWND_TOP;%@NL@%
    }%@NL@%
%@NL@%
    for (i = IW_APPSTITLE; i <= IW_ITEMSTITLE; i++) {%@NL@%
        gswp[i].x =%@NL@%
        gswp[i - IW_APPSTITLE + IW_APPSLBOX].x = i == IW_APPSTITLE ? -cxBorder :%@NL@%
                gswp[i - 1].x + gswp[i - 1].cx - cxBorder;%@NL@%
%@NL@%
        gswp[i].y = cyNew - cyTitles;%@NL@%
        gswp[i - IW_APPSTITLE + IW_APPSLBOX].y = cyNew / 2;%@NL@%
%@NL@%
        gswp[i].cx =%@NL@%
        gswp[i - IW_APPSTITLE + IW_APPSLBOX].cx = cxNew / 3;%@NL@%
%@NL@%
        gswp[i].cy = cyTitles;%@NL@%
        gswp[i - IW_APPSTITLE + IW_APPSLBOX].cy = (cyNew / 2) - cyTitles;%@NL@%
    }%@NL@%
%@NL@%
    gswp[IW_ITEMSLBOX].cx = cxNew - gswp[IW_ITEMSLBOX].x + cxBorder;%@NL@%
%@NL@%
    gswp[IW_DATATITLE].cy = cyTitles;%@NL@%
    gswp[IW_DATATITLE].y =%@NL@%
    gswp[IW_DATATEXT].cy = cyNew / 2 - cyTitles;%@NL@%
%@NL@%
    gswp[IW_DATATITLE].cx =%@NL@%
    gswp[IW_DATATEXT].cx = cxNew;%@NL@%
%@NL@%
    WinSetMultWindowPos(hab, gswp, IW_DATATEXT - IW_APPSTITLE + 1);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void Refresh()%@NL@%
{%@NL@%
    HCONV hConv;%@NL@%
    register NPSZ npszAppName;%@NL@%
    CONVINFO ci;%@NL@%
    USHORT cb;%@NL@%
%@NL@%
    WinLockWindowUpdate(HWND_DESKTOP, gswp[IW_APPSLBOX].hwnd);%@NL@%
    WinSendMsg(gswp[IW_APPSLBOX].hwnd, LM_DELETEALL, 0L, 0L);%@NL@%
    WinSendMsg(gswp[IW_TOPICSLBOX].hwnd, LM_DELETEALL, 0L, 0L);%@NL@%
    WinSendMsg(gswp[IW_ITEMSLBOX].hwnd, LM_DELETEALL, 0L, 0L);%@NL@%
    %@NL@%
    hConvListMain = DdeBeginEnumServers(0L, hszSysTopic, hConvListMain, NULL, NULL);%@NL@%
    if (hConvListMain) {%@NL@%
        hConv = 0;%@NL@%
        while (hConv = DdeGetNextServer(hConvListMain, hConv)) {%@NL@%
            DdeQueryConvInfo(hConv, &ci, QID_SYNC);%@NL@%
            if (ci.hszAppPartner != 0) {%@NL@%
                cb = DdeGetHszString(ci.hszAppPartner, NULL, 0L) + 1;%@NL@%
                npszAppName = WinAllocMem(hheap, cb);%@NL@%
                DdeGetHszString(ci.hszAppPartner, (PSZ)npszAppName, (ULONG)cb);%@NL@%
                InsertLBItem(gswp[IW_APPSLBOX].hwnd, (PSZ)npszAppName,%@NL@%
                        (ULONG)hConv);%@NL@%
                WinFreeMem(hheap, npszAppName, cb);%@NL@%
            } else {%@NL@%
                InsertLBItem(gswp[IW_APPSLBOX].hwnd, SZINDETERMINATE,%@NL@%
                        (ULONG)hConv);%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
    WinLockWindowUpdate(HWND_DESKTOP, NULL);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
SHORT InsertLBItem(hwndLB, psz, ulHandle)%@NL@%
HWND hwndLB;%@NL@%
PSZ psz;%@NL@%
ULONG ulHandle;%@NL@%
{%@NL@%
    SHORT ili;%@NL@%
%@NL@%
    ili = (SHORT)WinSendMsg(hwndLB, LM_INSERTITEM, (MPARAM)LIT_SORTASCENDING,%@NL@%
            (MPARAM)psz);%@NL@%
    WinSendMsg(hwndLB, LM_SETITEMHANDLE, MPFROMSHORT(ili), (MPARAM)ulHandle);%@NL@%
    return(ili);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void SetLBEntries(hConv, hszItem, iwlb)%@NL@%
HCONV hConv;%@NL@%
HSZ hszItem;%@NL@%
USHORT iwlb;%@NL@%
{%@NL@%
    NPSZ npsz, npszT1, npszT2;%@NL@%
    BOOL fDone = 0;%@NL@%
    ULONG cb;%@NL@%
    HDMGDATA hDmgData;%@NL@%
%@NL@%
    hDmgData = DdeClientXfer(0L, 0L, hConv, hszItem, DDEFMT_TEXT,%@NL@%
        XTYP_REQUEST, gTimeout, NULL);%@NL@%
%@NL@%
    if (hDmgData == 0) {%@NL@%
        DdePostError(DdeGetLastError());%@NL@%
        return;%@NL@%
    }%@NL@%
%@NL@%
    cb = DdeGetData(hDmgData, NULL, 0L, 0L);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * BUG - may later want to handle the case for cb > 0xFFFF%@NL@%
%@AB@%     */%@AE@%%@NL@%
    npsz = WinAllocMem(hheap, (USHORT)cb);%@NL@%
    if (npsz == NULL) {%@NL@%
        DdePostError(DMGERR_MEMORY_ERROR);%@NL@%
        return;%@NL@%
    }%@NL@%
    if (DdeGetData(hDmgData, (PBYTE)npsz, cb, 0L) == 0) {%@NL@%
        DdePostError(DdeGetLastError());%@NL@%
        goto Exit;%@NL@%
    }%@NL@%
    npszT1 = npszT2 = npsz;%@NL@%
    WinLockWindowUpdate(HWND_DESKTOP, gswp[iwlb].hwnd);%@NL@%
    WinSendMsg(gswp[iwlb].hwnd, LM_DELETEALL, 0L, 0L);%@NL@%
    while (!fDone) {%@NL@%
        while (*npszT2 != '\t' && *npszT2 != '\0')%@NL@%
            npszT2++;%@NL@%
        if (*npszT2 == '\t') {%@NL@%
            *npszT2 = '\0';%@NL@%
            npszT2++;%@NL@%
        } else%@NL@%
            fDone = TRUE;%@NL@%
        InsertLBItem(gswp[iwlb].hwnd, (PSZ)npszT1,%@NL@%
                (ULONG)DdeGetHsz(npszT1, 0, 0));%@NL@%
        npszT1 = npszT2;%@NL@%
    }%@NL@%
    WinLockWindowUpdate(HWND_DESKTOP, NULL);%@NL@%
%@NL@%
Exit:%@NL@%
    WinFreeMem(hheap, (NPBYTE)npsz, (USHORT)cb);%@NL@%
    return;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
HDMGDATA EXPENTRY dataxfer(hConv, hszTopic, hszItem, usFmt, usType,%@NL@%
        hDmgData)%@NL@%
HCONV hConv;%@NL@%
HSZ hszTopic;%@NL@%
HSZ hszItem;%@NL@%
USHORT usFmt;%@NL@%
USHORT usType;%@NL@%
HDMGDATA hDmgData;%@NL@%
{%@NL@%
    hConv; hszTopic; hszItem; usFmt; usType; hDmgData;%@NL@%
%@NL@%
    switch (usType) {%@NL@%
    case XTYP_XFERCOMPLETE:%@NL@%
        if (hwndExec) {%@NL@%
            if (DdeCheckQueue(hConv, &hDmgData, (ULONG)hDmgData, 0L)) {%@NL@%
                PSZ psz;%@NL@%
                if (psz = (PSZ)DdeAccessData(hDmgData)) {%@NL@%
                    WinSetDlgItemText(hwndExec, IDEF_DATA, psz);%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                     * Free this data here.%@NL@%
%@AB@%                     */%@AE@%%@NL@%
                    DdeFreeData(hDmgData);%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY GetTimeoutDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    USHORT usValue;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_INITDLG: %@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * set up our entryfield to be enhanced.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinSetDlgItemShort(hwnd, IDC_EF, (USHORT)gTimeout, FALSE);%@NL@%
        lpfnSysEFWndProc = WinSubclassWindow(WinWindowFromID(hwnd, IDC_EF),%@NL@%
                EnhancedEFWndProc);%@NL@%
        break;%@NL@%
%@NL@%
    case ENHAN_ENTER:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * when the user hits the enter key, it will be passed from the%@NL@%
%@AB@%         * entryfield to here and we will use it as a signal to exit.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinQueryDlgItemShort(hwnd, IDC_EF, &usValue, FALSE);%@NL@%
        WinDismissDlg(hwnd, usValue);%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
MRESULT EXPENTRY EnhancedEFWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    switch (msg) {%@NL@%
    case WM_CHAR:%@NL@%
        if (LOUSHORT(mp1) & KC_SCANCODE &&%@NL@%
                LOUSHORT(mp1) & KC_KEYUP &&%@NL@%
                %@AB@%/*---HACK ALERT!---*/%@AE@%%@NL@%
                LOBYTE(LOUSHORT(mp2)) == 0x0d) {%@NL@%
            NotifyOwner(hwnd, ENHAN_ENTER,%@NL@%
                    (MPARAM)WinQueryWindowUShort(hwnd, QWS_ID), 0L);%@NL@%
        }%@NL@%
        break;%@NL@%
    }%@NL@%
    return(lpfnSysEFWndProc(hwnd, msg, mp1, mp2));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY ExecDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    static UCHAR szT[255];%@NL@%
    static HCONV hConv = NULL;%@NL@%
    register USHORT i;%@NL@%
    USHORT cb;%@NL@%
    register USHORT xtyp;%@NL@%
    HDMGDATA hDmgData;%@NL@%
    HSZ hszApp, hszItem, hszTopic;%@NL@%
    BOOL fAssync;%@NL@%
    ULONG xid;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_INITDLG:%@NL@%
        hwndExec = hwnd;%@NL@%
        WinSendDlgItemMsg(hwnd, IDEF_DATA, EM_SETTEXTLIMIT, (MPARAM)MAX_QSTRING, 0L);%@NL@%
        WinSendDlgItemMsg(hwnd, IDCB_QDATA, EM_SETTEXTLIMIT, (MPARAM)MAX_QSTRING, 0L);%@NL@%
        if ((i = GetLBSelectedItem(gswp[IW_APPSLBOX].hwnd)) != LIT_NONE) {%@NL@%
            GetLBItemText(gswp[IW_APPSLBOX].hwnd, i, 255, szT);%@NL@%
            WinSetDlgItemText(hwnd, IDEF_APP, szT);%@NL@%
        }%@NL@%
        if ((i = GetLBSelectedItem(gswp[IW_TOPICSLBOX].hwnd)) != LIT_NONE) {%@NL@%
            GetLBItemText(gswp[IW_TOPICSLBOX].hwnd, i, 255, szT);%@NL@%
            WinSetDlgItemText(hwnd, IDEF_TOPIC, szT);%@NL@%
        }%@NL@%
        if ((i = GetLBSelectedItem(gswp[IW_ITEMSLBOX].hwnd)) != LIT_NONE) {%@NL@%
            GetLBItemText(gswp[IW_ITEMSLBOX].hwnd, i, 255, szT);%@NL@%
            WinSetDlgItemText(hwnd, IDEF_ITEM, szT);%@NL@%
        }%@NL@%
        WinSendDlgItemMsg(hwnd, IDRB_REQUEST, BM_CLICK, 0L, 0L);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CONTROL:%@NL@%
    case WM_COMMAND:%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
        case MBID_CANCEL:%@NL@%
            if (hConv != NULL)%@NL@%
                DdeDisconnect(hConv);%@NL@%
            hConv = NULL;%@NL@%
            WinDismissDlg(hwnd, 0);%@NL@%
            break;%@NL@%
            %@NL@%
        case IDC_QFLUSH:%@NL@%
            DdeCheckQueue(hConv, NULL, QID_NEWEST, CQ_FLUSH);%@NL@%
            WinSetDlgItemText(hwnd, IDCB_QDATA, "");%@NL@%
            UpdateQueue(WinWindowFromID(hwnd, IDCB_QDATA), hConv);%@NL@%
            break;%@NL@%
            %@NL@%
        case IDC_QUPDATE:%@NL@%
            UpdateQueue(WinWindowFromID(hwnd, IDCB_QDATA), hConv);%@NL@%
            WinSendDlgItemMsg(hwnd, IDCB_QDATA, CBM_SHOWLIST, (MPARAM)TRUE, 0L);%@NL@%
            break;%@NL@%
            %@NL@%
        case IDC_DOIT:%@NL@%
            i = (USHORT)WinSendDlgItemMsg(hwnd, IDRB_ADVSTART,%@NL@%
                    BM_QUERYCHECKINDEX, 0L, 0L) + IDRB_ADVSTART;%@NL@%
            WinQueryDlgItemText(hwnd, IDEF_APP, 255, szT);%@NL@%
            hszApp = DdeGetHsz(szT, 0, 0);%@NL@%
            WinQueryDlgItemText(hwnd, IDEF_TOPIC, 255, szT);%@NL@%
            hszTopic = DdeGetHsz(szT, 0, 0);%@NL@%
            WinQueryDlgItemText(hwnd, IDEF_ITEM, 255, szT);%@NL@%
            hszItem = DdeGetHsz(szT, 0, 0);%@NL@%
            if (i != IDRB_REQUEST) {%@NL@%
                WinQueryDlgItemText(hwnd, IDEF_DATA, 255, szT);%@NL@%
                cb = WinQueryDlgItemTextLength(hwnd, IDEF_DATA);%@NL@%
            }%@NL@%
            if (hConv == NULL && !(hConv = DdeConnect(hszApp, hszTopic, NULL, 0L))) {%@NL@%
                DdePostError(DdeGetLastError());%@NL@%
                if (LOUSHORT(mp1) == MBID_OK)%@NL@%
                    WinDismissDlg(hwnd, 0);%@NL@%
                return(0);%@NL@%
            }%@NL@%
            switch (i) {%@NL@%
            case IDRB_REQUEST:%@NL@%
                xtyp = XTYP_REQUEST;%@NL@%
                goto XferOut;%@NL@%
                break;%@NL@%
            case IDRB_ADVSTART:%@NL@%
                xtyp = XTYP_ADVSTART;%@NL@%
                goto XferOut;%@NL@%
                break;%@NL@%
            case IDRB_ADVSTOP:%@NL@%
                xtyp = XTYP_ADVSTOP;%@NL@%
                goto XferOut;%@NL@%
                break;%@NL@%
            case IDRB_POKE:%@NL@%
                xtyp = XTYP_POKE;%@NL@%
                goto XferOut;%@NL@%
                break;%@NL@%
            case IDRB_EXECUTE:%@NL@%
                xtyp = XTYP_EXEC;%@NL@%
XferOut:%@NL@%
                fAssync = (BOOL)WinSendDlgItemMsg(hwnd, IDCBX_ASSYNC,%@NL@%
                        BM_QUERYCHECK, 0L, 0L);%@NL@%
                if (!(hDmgData = DdeClientXfer((PBYTE)szT, (ULONG)cb + 1,%@NL@%
                        hConv, hszItem, DDEFMT_TEXT, xtyp,%@NL@%
                        fAssync ? TIMEOUT_ASYNC : gTimeout, &xid)))%@NL@%
                    DdePostError(DdeGetLastError());%@NL@%
                    %@NL@%
                if (fAssync) {%@NL@%
                    UpdateQueue(WinWindowFromID(hwnd, IDCB_QDATA), hConv);%@NL@%
                } else {%@NL@%
                    if (i == IDRB_REQUEST) {%@NL@%
                        DdeGetData(hDmgData, szT, 255L, 0L);%@NL@%
                        DdeFreeData(hDmgData);%@NL@%
                        WinSetWindowText(gswp[IW_DATATEXT].hwnd, szT);%@NL@%
                        WinSetDlgItemText(hwnd, IDEF_DATA, szT);%@NL@%
                    }%@NL@%
                }%@NL@%
                %@NL@%
            }%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
        hwndExec = NULL;%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
void UpdateQueue(hwndCB, hConv)%@NL@%
HWND hwndCB;%@NL@%
HCONV hConv;%@NL@%
{%@NL@%
    SHORT lit;%@NL@%
    SHORT litSel = LIT_FIRST;%@NL@%
    CONVINFO ci;%@NL@%
    ULONG id, idSel;%@NL@%
    USHORT cItems;%@NL@%
    char szT[MAX_QSTRING];%@NL@%
    %@NL@%
    lit = (SHORT)WinSendMsg(hwndCB, LM_QUERYSELECTION,%@NL@%
            MPFROMSHORT(LIT_FIRST), 0L);%@NL@%
    idSel = (SHORT)WinSendMsg(hwndCB, LM_QUERYITEMHANDLE, MPFROMSHORT(lit), 0L);%@NL@%
    WinSendMsg(hwndCB, LM_DELETEALL, 0L, 0L);%@NL@%
    cItems = (USHORT)DdeCheckQueue(hConv, NULL, QID_NEWEST, CQ_COUNT);%@NL@%
    id = DdeCheckQueue(hConv, NULL, QID_NEWEST, 0L);%@NL@%
    while (cItems--) {%@NL@%
        DdeQueryConvInfo(hConv, &ci, id);%@NL@%
        ConvInfoToString(&ci, szT, MAX_QSTRING);%@NL@%
        lit = (SHORT)WinSendMsg(hwndCB, LM_INSERTITEM, MPFROMSHORT(LIT_END), szT);%@NL@%
        WinSendMsg(hwndCB, LM_SETITEMHANDLE, MPFROMSHORT(lit), (MPARAM)id);%@NL@%
        if (id == idSel) %@NL@%
            litSel = lit;%@NL@%
        id = DdeCheckQueue(hConv, NULL, id, CQ_NEXT);%@NL@%
    }%@NL@%
    WinSendMsg(hwndCB, LM_SELECTITEM, MPFROMSHORT(litSel), (MPARAM)TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
void ConvInfoToString(pci, psz, cbMax)%@NL@%
PCONVINFO pci;%@NL@%
PSZ psz;%@NL@%
USHORT cbMax;%@NL@%
{%@NL@%
    PSZ pszLast;%@NL@%
    char szT[100];%@NL@%
    %@NL@%
    pszLast = psz + cbMax - 1;%@NL@%
    *psz = '\0';%@NL@%
    psz = mylstrcat(psz, apszType[(pci->usType >> 4) && 0x1F], pszLast);%@NL@%
    psz = mylstrcat(psz, ": ", pszLast);%@NL@%
    psz = mylstrcat(psz, apszState[pci->usStatus & ST_CONNECTED ? 1 : 0], pszLast);%@NL@%
    psz = mylstrcat(psz, " ", pszLast);%@NL@%
    psz = mylstrcat(psz, apszState[pci->usStatus & ST_ADVISE ? 3 : 2], pszLast);%@NL@%
    psz = mylstrcat(psz, " ", pszLast);%@NL@%
    psz = mylstrcat(psz, apszStatus[pci->usConvst], pszLast);%@NL@%
    psz = mylstrcat(psz, " ", pszLast);%@NL@%
    if (pci->usFmt == DDEFMT_TEXT) {%@NL@%
        psz = mylstrcat(psz, "TEXT", pszLast);%@NL@%
    } else {   %@NL@%
        DdeGetHszString(pci->hszItem, szT, 100L);%@NL@%
        psz = mylstrcat(psz, szT, pszLast);%@NL@%
    }%@NL@%
    psz = mylstrcat(psz, " ", pszLast);%@NL@%
    DdeGetHszString(pci->hszItem, szT, 100L);%@NL@%
    psz = mylstrcat(psz, szT, pszLast);%@NL@%
    %@NL@%
    if (pci->LastError) {%@NL@%
        psz = mylstrcat(psz, " ", pszLast);%@NL@%
        DdeGetErrorString(pci->LastError, pszLast - psz, psz);%@NL@%
    }%@NL@%
    pszLast = '\0';%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* Concatonates psz1 and psz2 into psz1.%@NL@%
%@AB@%* returns psz pointing to end of concatonated string.%@NL@%
%@AB@%* pszLast marks point at which copying must stop.  This makes this operation%@NL@%
%@AB@%* safe for limited buffer sizes.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  1/1/89  created sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PSZ mylstrcat(psz1, psz2, pszLast)%@NL@%
PSZ psz1, psz2, pszLast;%@NL@%
{%@NL@%
    psz1 += lstrlen(psz1);%@NL@%
    while (*psz2 != '\0' && psz1 < pszLast) {%@NL@%
        *psz1++ = *psz2++;%@NL@%
    }%@NL@%
    *psz1 = '\0';%@NL@%
    return(psz1);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* returns string length not counting null terminator.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  1/1/89  created     sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
int lstrlen(psz)%@NL@%
PSZ psz;%@NL@%
{%@NL@%
    int c = 0;%@NL@%
%@NL@%
    while (*psz != 0) {%@NL@%
        psz++;%@NL@%
        c++;%@NL@%
    }%@NL@%
    return(c);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DEMO.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\DEMO\DEMO.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name:  demo.c - Demo application%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created:%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1987  Microsoft Corporation%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"demo.h" %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@NL@%
%@AB@%/************* GLOBAL VARIABLES         */%@AE@%%@NL@%
%@NL@%
char szDemoClass[] = "Demo";%@NL@%
%@NL@%
HAB  hab;%@NL@%
HMQ  hmqDemo;%@NL@%
HWND hwndDemo;%@NL@%
HWND hwndDemoFrame;%@NL@%
HCONV hconv = NULL;%@NL@%
HSZ hszTitle, hszTopicChase, hszItemPos;%@NL@%
USHORT fmtSWP;%@NL@%
SWP SWPTarget = { 0 };%@NL@%
PFNWP RealFrameProc;%@NL@%
BOOL flee = FALSE;%@NL@%
USHORT cServers = 0;%@NL@%
USHORT cxScreen, cyScreen;%@NL@%
%@NL@%
%@AI@%#define %@AE@%TIMEOUT 100 %@NL@%
%@AI@%#define %@AE@%TIMERSPEED 1000 %@NL@%
%@NL@%
%@AB@%/**************************************/%@AE@%%@NL@%
%@NL@%
VOID CommandMsg(USHORT cmd)%@NL@%
{%@NL@%
    UNUSED cmd;%@NL@%
}%@NL@%
%@NL@%
BOOL DemoInit()%@NL@%
{%@NL@%
    hab = WinInitialize(0);%@NL@%
%@NL@%
    hmqDemo = WinCreateMsgQueue(hab, 0);%@NL@%
%@NL@%
    cxScreen = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CXSCREEN);%@NL@%
    cyScreen = (USHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN);%@NL@%
    srand(2);%@NL@%
    %@NL@%
    if (!WinRegisterClass(hab, szDemoClass, (PFNWP)DemoWndProc,%@NL@%
            CS_SIZEREDRAW, 0))%@NL@%
         return(FALSE);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Initialize the ddeml%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (DdeInitialize((PFNCALLBACK)callback, 0L, 0L))%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now create HSZs for each of our DDE strings.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    fmtSWP = WinAddAtom(WinQuerySystemAtomTable(), "SWP FORMAT");%@NL@%
    hszTitle = DdeGetHsz("Demo", 0, 0);%@NL@%
    hszTopicChase = DdeGetHsz("Chaser", 0, 0);%@NL@%
    hszItemPos = DdeGetHsz("Position", 0, 0);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * let others know we are here - available as a server and turn on%@NL@%
%@AB@%     * filtering so we don't get bothered with any initiates for any%@NL@%
%@AB@%     * other app names.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    DdeAppNameServer(hszTitle, ANS_REGISTER | ANS_FILTERON);%@NL@%
        %@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
int cdecl main(int argc, char** argv)%@NL@%
{%@NL@%
    ULONG fcf;%@NL@%
    QMSG qmsg;%@NL@%
%@NL@%
    UNUSED argc;%@NL@%
    UNUSED argv;%@NL@%
%@NL@%
    if (!DemoInit()) {%@NL@%
        WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
        return(0);%@NL@%
    }%@NL@%
%@NL@%
    fcf = FCF_STANDARD;%@NL@%
%@NL@%
    hwndDemoFrame = WinCreateStdWindow(%@NL@%
            HWND_DESKTOP,%@NL@%
            WS_VISIBLE,%@NL@%
            &fcf,%@NL@%
            szDemoClass,%@NL@%
            "",%@NL@%
            WS_VISIBLE, %@NL@%
            NULL,%@NL@%
            IDR_DEMO,%@NL@%
            &hwndDemo);%@NL@%
%@NL@%
    WinSetFocus(HWND_DESKTOP, hwndDemo);%@NL@%
%@NL@%
    while (WinGetMsg(hab, (PQMSG)&qmsg, NULL, 0, 0)) {%@NL@%
        WinDispatchMsg(hab, (PQMSG)&qmsg);%@NL@%
    }%@NL@%
%@NL@%
    WinDestroyWindow(hwndDemoFrame);%@NL@%
%@NL@%
    WinDestroyMsgQueue(hmqDemo);%@NL@%
    WinTerminate(hab);%@NL@%
%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/********** Demo Window Procedure **************/%@AE@%%@NL@%
%@NL@%
MRESULT FAR PASCAL DemoWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    HPS   hps;%@NL@%
    RECTL rclPaint;%@NL@%
    SWP swp;%@NL@%
    SHORT speed;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_CREATE:%@NL@%
        %@AB@%/* Set up this global first thing in case we need it elsewhere */%@AE@%%@NL@%
        hwndDemo = hwnd;%@NL@%
        hwndDemoFrame = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
        RealFrameProc = WinSubclassWindow(hwndDemoFrame, DemoFrameWndProc);%@NL@%
        WinSetWindowPos(hwndDemoFrame, NULL, 0, 0, 0, 0, SWP_MINIMIZE | SWP_SHOW);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * start the timer so we will keep looking for another app like ours%@NL@%
%@AB@%         * to chase.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinStartTimer(hab, hwndDemo, 1, TIMERSPEED);%@NL@%
        return(MRFROMSHORT(FALSE));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_TIMER:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * We use a timer to keep us moving.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (!hconv) {%@NL@%
            HDMGDATA hData;%@NL@%
            PHSZHAPP phszhapp;%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * no active conversation, try to make one.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinStopTimer(hab, hwndDemo, 1);%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * find out if any others like us are out there%@NL@%
%@AB@%             */%@AE@%%@NL@%
            hData = DdeAppNameServer(hszTitle, ANS_QUERYALLBUTME);%@NL@%
            if (!hData) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * wait till others arrive.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                return(0);%@NL@%
            }%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * extract the first hApp from the hData so we can connect to it%@NL@%
%@AB@%             */%@AE@%%@NL@%
            phszhapp = (PHSZHAPP)DdeAccessData(hData);%@NL@%
            if (phszhapp->hsz == 0) {%@NL@%
                DdeFreeData(hData);%@NL@%
                return(0);%@NL@%
            }%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * perform directed connection to our target%@NL@%
%@AB@%             */%@AE@%%@NL@%
            hconv = DdeConnect(hszTitle, hszTopicChase, NULL, phszhapp->hApp);%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * free the hData now that we are done using it.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            DdeFreeData(hData);%@NL@%
            WinStartTimer(hab, hwndDemo, 1, TIMERSPEED);%@NL@%
            if (!hconv) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * cant make one, try again later.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                return(0);%@NL@%
            }%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Get the target's position into SWPTarget.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (hData = DdeClientXfer(NULL, 0L, hconv, hszItemPos, fmtSWP,%@NL@%
                    XTYP_REQUEST, TIMEOUT, NULL)) {%@NL@%
                DdeCopyBlock(DdeAccessData(hData), (PBYTE)&SWPTarget,%@NL@%
                        sizeof(SWP));%@NL@%
                DdeFreeData(hData);%@NL@%
            }%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * set up an advise loop so our moving target keeps us informed%@NL@%
%@AB@%             * of where he is.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            DdeClientXfer(NULL, 0L, hconv, hszItemPos, fmtSWP,%@NL@%
                    XTYP_ADVSTART, TIMEOUT, NULL);%@NL@%
        }%@NL@%
        %@NL@%
        if (WinIsWindow(hab, SWPTarget.hwnd)) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * target data must be valid, move toward it.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            speed = 1;%@NL@%
            WinQueryWindowPos(hwndDemoFrame, &swp);%@NL@%
            if (swp.x > SWPTarget.x) %@NL@%
                swp.x -= speed;%@NL@%
            if (swp.x < SWPTarget.x)%@NL@%
                swp.x += speed;%@NL@%
            if (swp.y > SWPTarget.y) %@NL@%
                swp.y -= speed;%@NL@%
            if (swp.y < SWPTarget.y)%@NL@%
                swp.y += speed;%@NL@%
            swp.fs = SWP_MOVE | SWP_NOADJUST;%@NL@%
            WinSetMultWindowPos(hab, &swp, 1);%@NL@%
            if ((swp.x == SWPTarget.x) && (swp.y == SWPTarget.y) && (!flee)) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * he's cought stop chasing him and go find another.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                WinAlarm(HWND_DESKTOP, WA_NOTE);%@NL@%
                DdeDisconnect(hconv);%@NL@%
                hconv = NULL;%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * move to a random position%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                WinSetWindowPos(hwndDemoFrame, HWND_TOP, rand() % cxScreen,%@NL@%
                        rand() % cyScreen, 0, 0,%@NL@%
                        SWP_MOVE | SWP_ZORDER | SWP_NOADJUST);%@NL@%
            }%@NL@%
        } else if (hconv) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Target is invalid, disconnect and try a reconnect later.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            DdeDisconnect(hconv);%@NL@%
            hconv = NULL;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        hps = WinBeginPaint(hwnd, (HPS)NULL, &rclPaint);%@NL@%
        DemoPaint(hwnd, hps, &rclPaint);%@NL@%
        WinEndPaint(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        CommandMsg(LOUSHORT(mp1));%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT FAR PASCAL DemoFrameWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    switch (msg) {%@NL@%
    case WM_MOVE:%@NL@%
        DdePostAdvise(hszTopicChase, hszItemPos);%@NL@%
        %@AB@%/* fall through */%@AE@%%@NL@%
    default:%@NL@%
        return(RealFrameProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID DemoPaint(HWND hwnd, HPS hps, RECTL* prcl)%@NL@%
{%@NL@%
    RECTL rcl;%@NL@%
%@NL@%
    UNUSED prcl;%@NL@%
    %@NL@%
    %@AB@%/* get window interior rect */%@AE@%%@NL@%
    WinQueryWindowRect(hwnd, &rcl);%@NL@%
%@NL@%
    %@AB@%/* print "Hello World" centered horizontally and vertically */%@AE@%%@NL@%
    WinDrawText(hps, -1, "Hello World", &rcl, SYSCLR_WINDOWTEXT,%@NL@%
            SYSCLR_WINDOW, DT_CENTER | DT_VCENTER | DT_ERASERECT);%@NL@%
%@NL@%
    %@AB@%/* draw interior border */%@AE@%%@NL@%
    WinDrawBorder(hps, &rcl, 6, 6, SYSCLR_WINDOWTEXT, SYSCLR_WINDOW,%@NL@%
            DB_STANDARD);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
HDMGDATA EXPENTRY callback(%@NL@%
HCONV hConv,%@NL@%
HSZ hszTopic,%@NL@%
HSZ hszItem,%@NL@%
USHORT usFmt,%@NL@%
USHORT usType,%@NL@%
HDMGDATA hDmgData)%@NL@%
{%@NL@%
    SWP swp;%@NL@%
%@NL@%
    UNUSED hConv;%@NL@%
%@NL@%
    if (usType == XTYP_REGISTER && hszItem == hszTitle && !hconv) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * someone else came onboard, if we are looking for a target,%@NL@%
%@AB@%         * restart our clock.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinStartTimer(hab, hwndDemo, 1, TIMERSPEED);%@NL@%
    }%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * we only care about stuff on our topic.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (hszTopic != hszTopicChase)%@NL@%
        return(0);%@NL@%
%@NL@%
    switch (usType) {%@NL@%
        %@NL@%
    case XTYP_ADVSTART:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Always allow advises on our item%@NL@%
%@AB@%         */%@AE@%%@NL@%
        return(hszItem == hszItemPos);%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_ADVDATA:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Always accept advise data on our target's latest position.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (hszItem == hszItemPos) %@NL@%
            DdeGetData(hDmgData, (PBYTE)&SWPTarget, sizeof(SWP), 0L);%@NL@%
        DdeFreeData(hDmgData);%@NL@%
        return(0);%@NL@%
        break;%@NL@%
                %@NL@%
    case XTYP_INIT:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * always allow others to initiate with us on our topic.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        return(hszItem == hszTitle && hszTopic == hszTopicChase);%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_REQUEST:%@NL@%
    case XTYP_ADVREQ:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Respond to data requests as to our whereabouts item and format are%@NL@%
%@AB@%         * ok.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (hszItem != hszItemPos || usFmt != fmtSWP) %@NL@%
            return(0);%@NL@%
        WinQueryWindowPos(hwndDemoFrame, &swp);%@NL@%
        return(DdePutData((PBYTE)&swp, sizeof(SWP), 0L, hszItemPos, fmtSWP, 0));%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(0);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DIALOGS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CLOCK\DIALOGS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    dialogs.c                Dialog procedures for PM Clock Application%@NL@%
%@AB@%%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%INCL_WINBUTTONS %@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#include %@AE@%<os2def.h> %@NL@%
%@AI@%#include %@AE@%<pmwin.h> %@NL@%
%@AI@%#include %@AE@%"dialogs.h" %@NL@%
%@NL@%
%@AB@%/* defined in paint.c */%@AE@%%@NL@%
extern USHORT usMajorTickPref ;%@NL@%
extern USHORT usMinorTickPref ;%@NL@%
extern LONG clrBackground ;%@NL@%
extern LONG clrFace ;%@NL@%
extern LONG clrHourHand ;%@NL@%
extern LONG clrMinuteHand ;%@NL@%
%@NL@%
%@AB@%/* defined in clock.c */%@AE@%%@NL@%
extern HWND hwndFrame ;%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkAboutDlgProc()                 "About..." dialog%@NL@%
%@AB@%%@NL@%
%@AB@%    Returns:        MRESULT, 0 or return value from WinDefDlgProc%@NL@%
%@AB@%*/%@AE@%%@NL@%
MRESULT EXPENTRY ClkAboutDlgProc ( HWND hwnd , USHORT usMsg ,%@NL@%
                                   MPARAM mp1 , MPARAM mp2 )%@NL@%
{%@NL@%
    if ( usMsg == WM_COMMAND ) {%@NL@%
        WinDismissDlg ( hwnd , TRUE ) ;%@NL@%
        return 0L ;%@NL@%
    }%@NL@%
    else return WinDefDlgProc ( hwnd , usMsg , mp1 , mp2 ) ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkTicksDlgProc()                "Ticks..." dialog%@NL@%
%@AB@%%@NL@%
%@AB@%    Returns: MRESULT, 0 or return value from WinDefDlgProc%@NL@%
%@AB@%*/%@AE@%%@NL@%
MRESULT EXPENTRY ClkTicksDlgProc ( HWND hwnd , USHORT usMsg ,%@NL@%
                                   MPARAM mp1 , MPARAM mp2 )%@NL@%
{%@NL@%
    static USHORT usMajorTickSel ;%@NL@%
    static USHORT usMinorTickSel ;%@NL@%
    USHORT usButtonID ;%@NL@%
%@NL@%
    switch ( usMsg ) {%@NL@%
%@NL@%
        case WM_INITDLG :%@NL@%
%@NL@%
            %@AB@%/* show the current major tick preference */%@AE@%%@NL@%
            WinSendMsg ( WinWindowFromID ( hwnd ,%@NL@%
                                           CLKTM_MAJOR | usMajorTickPref ) ,%@NL@%
                         BM_SETCHECK , MPFROM2SHORT ( TRUE , NULL ) , NULL ) ;%@NL@%
%@NL@%
            %@AB@%/* show the current minor tick preference */%@AE@%%@NL@%
            WinSendMsg ( WinWindowFromID ( hwnd ,%@NL@%
                                           CLKTM_MINOR | usMinorTickPref ) ,%@NL@%
                         BM_SETCHECK , MPFROM2SHORT ( TRUE , NULL ) , NULL ) ;%@NL@%
%@NL@%
            %@AB@%/* load the selection values from the preferences */%@AE@%%@NL@%
            usMajorTickSel = usMajorTickPref ;%@NL@%
            usMinorTickSel = usMinorTickPref ;%@NL@%
%@NL@%
            %@AB@%/* let the default dialog procedure handle anything else */%@AE@%%@NL@%
            break ;%@NL@%
%@NL@%
        case WM_COMMAND :%@NL@%
%@NL@%
            switch ( LOUSHORT ( mp1 ) ) {%@NL@%
%@NL@%
                case DID_OK :%@NL@%
%@NL@%
                    %@AB@%/* store away selections as preferences */%@AE@%%@NL@%
                    usMajorTickPref = usMajorTickSel ;%@NL@%
                    usMinorTickPref = usMinorTickSel ;%@NL@%
%@NL@%
                    %@AB@%/* repaint with the new preferences */%@AE@%%@NL@%
                    WinInvalidateRect ( hwndFrame , NULL, TRUE ) ;%@NL@%
%@NL@%
                case DID_CANCEL :%@NL@%
                    WinDismissDlg ( hwnd , TRUE ) ;%@NL@%
            }%@NL@%
%@NL@%
            return NULL ;%@NL@%
%@NL@%
        case WM_CONTROL :%@NL@%
%@NL@%
            if ( SHORT2FROMMP ( mp1 ) == BN_CLICKED ) {%@NL@%
%@NL@%
                usButtonID = SHORT1FROMMP ( mp1 ) ;%@NL@%
%@NL@%
                switch ( usButtonID & 0xff00 ) {%@NL@%
%@NL@%
                    case CLKTM_MAJOR :%@NL@%
                        usMajorTickSel = LOBYTE ( usButtonID ) ;%@NL@%
                        break ;%@NL@%
%@NL@%
                    case CLKTM_MINOR :%@NL@%
                        usMinorTickSel = LOBYTE ( usButtonID ) ;%@NL@%
                        break ;%@NL@%
                }%@NL@%
            }%@NL@%
%@NL@%
            %@AB@%/* fall through to the default control processing */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    return WinDefDlgProc ( hwnd , usMsg , mp1 , mp2 ) ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkColorsDlgProc()                "Clock Color Preferences" Dialog%@NL@%
%@AB@%%@NL@%
%@AB@%    Returns: MRESULT, 0 or return value from WinDefDlgProc%@NL@%
%@AB@%*/%@AE@%%@NL@%
MRESULT EXPENTRY ClkColorsDlgProc ( HWND hwnd , USHORT usMsg ,%@NL@%
                                   MPARAM mp1 , MPARAM mp2 )%@NL@%
{%@NL@%
    USHORT usButtonID ;%@NL@%
    static USHORT usCheckedButtonID ;%@NL@%
    HWND hwndButton ;%@NL@%
    RECTL rclButton , rclButtonInterior ;%@NL@%
    static LONG clrBackgroundNew ;%@NL@%
    static LONG clrFaceNew ;%@NL@%
    static LONG clrHourHandNew ;%@NL@%
    static LONG clrMinuteHandNew ;%@NL@%
    static LONG * pclrNew ;%@NL@%
%@NL@%
    switch ( usMsg ) {%@NL@%
%@NL@%
        case WM_INITDLG :%@NL@%
%@NL@%
            %@AB@%/* load the new values from the current ones */%@AE@%%@NL@%
            clrBackgroundNew = clrBackground ;%@NL@%
            clrFaceNew = clrFace ;%@NL@%
            clrHourHandNew = clrHourHand ;%@NL@%
            clrMinuteHandNew = clrMinuteHand ;%@NL@%
%@NL@%
            %@AB@%/* click the "Background" radio button */%@AE@%%@NL@%
            WinSendMsg ( WinWindowFromID ( hwnd , CLKCLR_BACKGROUND ) ,%@NL@%
                         BM_CLICK , MPFROMSHORT ( TRUE ) , NULL ) ;%@NL@%
%@NL@%
            %@AB@%/* let the default dialog procedure handle anything else */%@AE@%%@NL@%
            break ;%@NL@%
%@NL@%
        case WM_COMMAND :%@NL@%
%@NL@%
            switch ( LOUSHORT ( mp1 ) ) {%@NL@%
                case DID_OK :%@NL@%
%@NL@%
                    %@AB@%/* store the new values */%@AE@%%@NL@%
                    clrBackground = clrBackgroundNew ;%@NL@%
                    clrFace = clrFaceNew ;%@NL@%
                    clrHourHand = clrHourHandNew ;%@NL@%
                    clrMinuteHand = clrMinuteHandNew ;%@NL@%
%@NL@%
                    %@AB@%/* repaint with the new colors */%@AE@%%@NL@%
                    WinInvalidateRect ( hwndFrame , NULL, TRUE ) ;%@NL@%
%@NL@%
                case DID_CANCEL :%@NL@%
%@NL@%
                    WinDismissDlg ( hwnd , TRUE ) ;%@NL@%
            }%@NL@%
            return NULL ;%@NL@%
%@NL@%
        case WM_CONTROL :%@NL@%
%@NL@%
            usButtonID = SHORT1FROMMP ( mp1 ) ;%@NL@%
%@NL@%
            %@AB@%/* selecting a new object */%@AE@%%@NL@%
            if ( usButtonID & CLKCLR_OBJECTS ) {%@NL@%
%@NL@%
                switch ( usButtonID ) {%@NL@%
                    case CLKCLR_BACKGROUND :%@NL@%
                        pclrNew = & clrBackgroundNew ;%@NL@%
                        break ;%@NL@%
                    case CLKCLR_FACE :%@NL@%
                        pclrNew = & clrFaceNew ;%@NL@%
                        break ;%@NL@%
                    case CLKCLR_HOURHAND :%@NL@%
                        pclrNew = & clrHourHandNew ;%@NL@%
                        break ;%@NL@%
                    case CLKCLR_MINUTEHAND :%@NL@%
                        pclrNew = & clrMinuteHandNew ;%@NL@%
                }%@NL@%
%@NL@%
                %@AB@%/* click the button for the new object's current color */%@AE@%%@NL@%
                WinSendMsg (%@NL@%
                    WinWindowFromID ( hwnd ,%@NL@%
                        CLKCLR_BUTTONSHIFT + ( USHORT ) * pclrNew ) ,%@NL@%
                    BM_CLICK , MPFROMSHORT ( TRUE ) , NULL ) ;%@NL@%
%@NL@%
                break ;%@NL@%
            }%@NL@%
%@NL@%
            switch ( SHORT2FROMMP ( mp1 ) ) {%@NL@%
%@NL@%
                case BN_CLICKED :%@NL@%
%@NL@%
                    * pclrNew = ( LONG ) usButtonID - CLKCLR_BUTTONSHIFT ;%@NL@%
%@NL@%
                    %@AB@%/* turn off the check state of the previously checked%@NL@%
%@AB@%                     * button and turn on the check state of the button%@NL@%
%@AB@%                     * just clicked */%@AE@%%@NL@%
%@NL@%
                    WinSendMsg ( WinWindowFromID ( hwnd , usCheckedButtonID ) ,%@NL@%
                                 BM_SETCHECK , MPFROM2SHORT ( FALSE , NULL ) ,%@NL@%
                                 NULL ) ;%@NL@%
                    WinSendMsg ( WinWindowFromID ( hwnd , usButtonID ) ,%@NL@%
                                 BM_SETCHECK , MPFROM2SHORT ( TRUE , NULL ) ,%@NL@%
                                 NULL ) ;%@NL@%
%@NL@%
                    usCheckedButtonID = usButtonID ;%@NL@%
%@NL@%
                    break ;%@NL@%
%@NL@%
                case BN_PAINT :%@NL@%
%@NL@%
                    %@AB@%/* fill only the interior of the button, so we don't%@NL@%
%@AB@%                     * conflict with the focus indicator */%@AE@%%@NL@%
%@NL@%
                    hwndButton = ( ( PUSERBUTTON ) mp2 ) -> hwnd ;%@NL@%
                    WinQueryWindowRect ( hwndButton , & rclButton ) ;%@NL@%
                    rclButton . xLeft ++ ;%@NL@%
                    rclButton . yBottom ++ ;%@NL@%
                    rclButton . xRight -- ;%@NL@%
                    rclButton . yTop -- ;%@NL@%
                    WinFillRect ( ( ( PUSERBUTTON ) mp2 ) -> hps ,%@NL@%
                                  & rclButton ,%@NL@%
                                  ( LONG ) usButtonID - CLKCLR_BUTTONSHIFT ) ;%@NL@%
%@NL@%
                    %@AB@%/* hollow out those buttons which aren't checked */%@AE@%%@NL@%
                    if ( ! WinSendMsg ( WinWindowFromID ( hwnd , usButtonID ) ,%@NL@%
                                      BM_QUERYCHECK , NULL , NULL ) ) {%@NL@%
                        rclButtonInterior . xLeft = rclButton . xLeft + 4 ;%@NL@%
                        rclButtonInterior . yBottom = rclButton . yBottom + 4 ;%@NL@%
                        rclButtonInterior . xRight = rclButton . xRight - 4 ;%@NL@%
                        rclButtonInterior . yTop = rclButton . yTop - 4 ;%@NL@%
                        WinFillRect ( ( ( PUSERBUTTON ) mp2 ) -> hps ,%@NL@%
                                      & rclButtonInterior , SYSCLR_WINDOW ) ;%@NL@%
                    }%@NL@%
%@NL@%
                    break ;%@NL@%
            }%@NL@%
%@NL@%
            %@AB@%/* fall through to the default control processing */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    return WinDefDlgProc ( hwnd , usMsg , mp1 , mp2 ) ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DLGPROC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\INIEDIT\DLGPROC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/******************************* Module Header ******************************\%@NL@%
%@AB@%* Module Name: DlgProc.c%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* System Test Application%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%LINT_ARGS                           // Include needed parts of PM %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT                       //    definitions %@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINBUTTONS %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%INCL_WINSHELLDATA %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%INCL_WINENTRYFIELDS %@NL@%
%@AI@%#define %@AE@%INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%INCL_GPIREGIONS %@NL@%
%@AI@%#define %@AE@%INCL_GPILCIDS %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@AI@%#define %@AE@%INCL_DEV %@NL@%
%@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"IniEdit.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************* Constants *********************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%BUF_SIZE 132 %@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************** Globals **********************************/%@AE@%%@NL@%
%@NL@%
static CHAR   szSearch[BUF_SIZE] = { 0 };           // Current search string%@NL@%
static USHORT usLastIndex = 0;                      // Last Searched Item%@NL@%
%@NL@%
%@AB@%/******************************* Externals *********************************/%@AE@%%@NL@%
%@NL@%
extern USHORT        cAppNames;                     // see iniedit.c%@NL@%
extern HWND          hwndList;%@NL@%
extern PGROUPSTRUCT  pGroups;%@NL@%
extern HAB           habIniEdit;%@NL@%
extern HWND          FocusWindow;%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************** Function Header ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* SearchWndProc%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Handles the Search Dialog Box messages%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
MRESULT _loadds EXPENTRY SearchWndProc(HWND hwndDialog, USHORT msg,%@NL@%
        MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    HWND   hwndText;                            // Current Text Window%@NL@%
%@NL@%
%@NL@%
    switch (msg)%@NL@%
        {%@NL@%
%@NL@%
        case WM_INITDLG:%@NL@%
            hwndText = WinWindowFromID( hwndDialog, IDDI_SEARCH_TEXT );%@NL@%
            WinSetWindowText(hwndText, szSearch);%@NL@%
            WinSendMsg( hwndText, EM_SETSEL,%@NL@%
                    MPFROM2SHORT(0, strlen(szSearch)), (MPARAM)0 );%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            switch( LOUSHORT( mp1 ) )%@NL@%
                {%@NL@%
%@NL@%
                case IDDI_SEARCH_OK:%@NL@%
                    hwndText = WinWindowFromID( hwndDialog, IDDI_SEARCH_TEXT );%@NL@%
                    WinQueryWindowText( hwndText, BUF_SIZE, szSearch );%@NL@%
                    WinDismissDlg( hwndDialog, 0 );%@NL@%
%@NL@%
                    if( (usLastIndex = SHORT1FROMMR(WinSendMsg( hwndList, LM_SEARCHSTRING,%@NL@%
                            MPFROM2SHORT( LSS_SUBSTRING, LIT_FIRST),%@NL@%
                            MPFROMP( szSearch )) ) != LIT_NONE ))%@NL@%
                        {%@NL@%
                        WinSendMsg( hwndList, LM_SELECTITEM,%@NL@%
                                MPFROM2SHORT( (usLastIndex), NULL),%@NL@%
                                MPFROM2SHORT( TRUE, NULL ) );%@NL@%
                        }%@NL@%
                    else  %@AB@%/* not found */%@AE@%%@NL@%
                        {%@NL@%
                        usLastIndex = LIT_FIRST;%@NL@%
                        WinAlarm( HWND_DESKTOP, 0);%@NL@%
                        }%@NL@%
                    break;%@NL@%
%@NL@%
                case IDDI_SEARCH_NEXT:%@NL@%
                    FindNext();%@NL@%
                    break;%@NL@%
%@NL@%
                default:%@NL@%
                    return WinDefDlgProc(hwndDialog, msg, mp1, mp2);%@NL@%
                    break;%@NL@%
                }%@NL@%
%@NL@%
        default:%@NL@%
            return WinDefDlgProc(hwndDialog, msg, mp1, mp2);%@NL@%
            break;%@NL@%
        }%@NL@%
%@NL@%
    return 0L;%@NL@%
%@NL@%
}  %@AB@%/* SearchWndProc */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************** Function Header ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* FindNext%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Finds the next instance of the current search string starting from the%@NL@%
%@AB@%* Last searched position%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID FindNext()%@NL@%
{%@NL@%
   if( (usLastIndex = SHORT1FROMMR(WinSendMsg( hwndList, LM_SEARCHSTRING,%@NL@%
           MPFROM2SHORT( LSS_SUBSTRING, usLastIndex),%@NL@%
           MPFROMP( szSearch )) ) != LIT_NONE ))%@NL@%
       {%@NL@%
       WinSendMsg( hwndList, LM_SELECTITEM,%@NL@%
               MPFROM2SHORT( (usLastIndex), NULL),%@NL@%
               MPFROM2SHORT( TRUE, NULL ) );%@NL@%
       }%@NL@%
   else   %@AB@%/* alarm if not found */%@AE@%%@NL@%
       WinAlarm( HWND_DESKTOP, 0);%@NL@%
%@NL@%
}  %@AB@%/* FindNext */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************** Function Header ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* AddKeyWndProc%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Handles the AddKey Dialog Box messages%@NL@%
%@AB@%* Will facilitate adding new keys for a given App Name%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
MRESULT _loadds EXPENTRY AddKeyWndProc(HWND hwndDialog, USHORT msg,%@NL@%
        MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    HWND   hwndTextApp;                         // Handle for App Text Window%@NL@%
    HWND   hwndTextKey;%@NL@%
    HWND   hwndTextValue;%@NL@%
    CHAR   szApp[BUF_SIZE];                     // String Contents%@NL@%
    CHAR   szKey[BUF_SIZE];%@NL@%
    CHAR   szValue[BUF_SIZE];%@NL@%
%@NL@%
%@NL@%
    switch (msg)%@NL@%
        {%@NL@%
        case WM_INITDLG:%@NL@%
            WinSendDlgItemMsg(hwndDialog, IDDI_ADD_KEY_TEXT_APP, EM_SETTEXTLIMIT,%@NL@%
                    MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
            WinSendDlgItemMsg(hwndDialog, IDDI_ADD_KEY_TEXT_KEY, EM_SETTEXTLIMIT,%@NL@%
                    MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
            WinSendDlgItemMsg(hwndDialog, IDDI_ADD_KEY_TEXT_VAL, EM_SETTEXTLIMIT,%@NL@%
                    MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
            break;%@NL@%
        case WM_COMMAND:%@NL@%
            switch( LOUSHORT( mp1 ) )%@NL@%
                {%@NL@%
%@NL@%
                case IDDI_ADD_KEY_OK:%@NL@%
                    hwndTextApp = WinWindowFromID( hwndDialog, IDDI_ADD_KEY_TEXT_APP );%@NL@%
                    WinQueryWindowText( hwndTextApp, BUF_SIZE, szApp );%@NL@%
%@NL@%
                    hwndTextKey = WinWindowFromID( hwndDialog, IDDI_ADD_KEY_TEXT_KEY );%@NL@%
                    WinQueryWindowText( hwndTextKey, BUF_SIZE, szKey );%@NL@%
%@NL@%
                    hwndTextValue = WinWindowFromID( hwndDialog, IDDI_ADD_KEY_TEXT_VAL );%@NL@%
                    WinQueryWindowText( hwndTextValue, BUF_SIZE, szValue );%@NL@%
%@NL@%
                    WinDismissDlg( hwndDialog, 0 );%@NL@%
%@NL@%
                    %@AB@%/* if the App is NULL forget it */%@AE@%%@NL@%
                    if( *szApp == (CHAR)0 )%@NL@%
                        {%@NL@%
                        break;%@NL@%
                        }%@NL@%
%@NL@%
                    %@AB@%/* if the Key is NULL forget it */%@AE@%%@NL@%
                    if( *szKey == (CHAR)0 )%@NL@%
                        {%@NL@%
                        break;%@NL@%
                        }%@NL@%
%@NL@%
                    %@AB@%/* if the Value is NULL forget it */%@AE@%%@NL@%
                    if( *szValue == (CHAR)0 )%@NL@%
                        {%@NL@%
                        break;%@NL@%
                        }%@NL@%
%@NL@%
                    if( !WinWriteProfileString( habIniEdit, szApp, szKey, szValue ) )%@NL@%
                        ;%@NL@%
                    break;%@NL@%
%@NL@%
                default:%@NL@%
                    return WinDefDlgProc(hwndDialog, msg, mp1, mp2);%@NL@%
                    break;%@NL@%
                }%@NL@%
%@NL@%
        default:%@NL@%
            return WinDefDlgProc(hwndDialog, msg, mp1, mp2);%@NL@%
            break;%@NL@%
        }%@NL@%
%@NL@%
    return 0L;%@NL@%
%@NL@%
}  %@AB@%/* AddKeyWndProc */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************** Function Header ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* ChangeKeyWndProc%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Handles the ChangeKey Dialog Box messages%@NL@%
%@AB@%* Will facilitate changing a key's value given an app, key and new value%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
MRESULT _loadds EXPENTRY ChangeKeyWndProc(HWND hwndDialog, USHORT msg,%@NL@%
        MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    HWND     hwndTextApp;                       // Handle for App Text Window%@NL@%
    HWND     hwndTextKey;%@NL@%
    HWND     hwndTextVal;%@NL@%
    CHAR     szApp[BUF_SIZE];                   // String Contents%@NL@%
    CHAR     szKey[BUF_SIZE];%@NL@%
    CHAR     szVal[BUF_SIZE];%@NL@%
%@NL@%
%@NL@%
    switch (msg)%@NL@%
        {%@NL@%
        case WM_INITDLG:%@NL@%
            if( FocusWindow )%@NL@%
                {%@NL@%
%@NL@%
                FocusWindow = WinWindowFromID( hwndDialog, IDDI_CHANGE_KEY_TEXT_VAL );%@NL@%
                WinSetFocus( HWND_DESKTOP, FocusWindow);%@NL@%
                WinQueryWindowText( FocusWindow, BUF_SIZE, szVal );%@NL@%
%@NL@%
                FocusWindow = (HWND)NULL;%@NL@%
%@NL@%
                return((MRESULT) TRUE );%@NL@%
                } else {%@NL@%
                WinSendDlgItemMsg(hwndDialog, IDDI_CHANGE_KEY_TEXT_APP, EM_SETTEXTLIMIT,%@NL@%
                        MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
                WinSendDlgItemMsg(hwndDialog, IDDI_CHANGE_KEY_TEXT_KEY, EM_SETTEXTLIMIT,%@NL@%
                        MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
                WinSendDlgItemMsg(hwndDialog, IDDI_CHANGE_KEY_TEXT_VAL, EM_SETTEXTLIMIT,%@NL@%
                        MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
                }%@NL@%
            break;%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            switch( LOUSHORT( mp1 ) )%@NL@%
                {%@NL@%
%@NL@%
                case IDDI_CHANGE_KEY_OK:%@NL@%
                    hwndTextApp = WinWindowFromID( hwndDialog, IDDI_CHANGE_KEY_TEXT_APP );%@NL@%
                    WinQueryWindowText( hwndTextApp, BUF_SIZE, szApp );%@NL@%
%@NL@%
                    hwndTextKey = WinWindowFromID( hwndDialog, IDDI_CHANGE_KEY_TEXT_KEY );%@NL@%
                    WinQueryWindowText( hwndTextKey, BUF_SIZE, szKey );%@NL@%
%@NL@%
                    hwndTextVal = WinWindowFromID( hwndDialog, IDDI_CHANGE_KEY_TEXT_VAL );%@NL@%
                    WinQueryWindowText( hwndTextVal, BUF_SIZE, szVal );%@NL@%
%@NL@%
%@NL@%
                    WinDismissDlg( hwndDialog, IDDI_CHANGE_KEY_OK );%@NL@%
%@NL@%
                    %@AB@%/* if the App is NULL forget it */%@AE@%%@NL@%
                    if( *szApp == (CHAR)0 )%@NL@%
                        {%@NL@%
                        break;%@NL@%
                        }%@NL@%
%@NL@%
                    %@AB@%/* if the Key is NULL forget it */%@AE@%%@NL@%
                    if( *szKey == (CHAR)0 )%@NL@%
                        {%@NL@%
                        break;%@NL@%
                        }%@NL@%
%@NL@%
                    %@AB@%/* if the Value is NULL forget it */%@AE@%%@NL@%
                    if( *szVal == (CHAR)0 )%@NL@%
                        {%@NL@%
                        break;%@NL@%
                        }%@NL@%
%@NL@%
%@NL@%
                    if( !WinWriteProfileString( habIniEdit, szApp, szKey, szVal ) )%@NL@%
%@NL@%
                    break;%@NL@%
%@NL@%
                default:%@NL@%
                    return WinDefDlgProc(hwndDialog, msg, mp1, mp2);%@NL@%
                    break;%@NL@%
                }%@NL@%
%@NL@%
        default:%@NL@%
            return WinDefDlgProc(hwndDialog, msg, mp1, mp2);%@NL@%
            break;%@NL@%
        }%@NL@%
%@NL@%
    return 0L;%@NL@%
%@NL@%
}  %@AB@%/* ChangeKeyWndProc */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************** Function Header ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* DelKeyWndProc%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Handles the DelKey Dialog Box messages%@NL@%
%@AB@%* Will facilitate deleting a key value given an app and the key%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
MRESULT _loadds EXPENTRY DelKeyWndProc(HWND hwndDialog, USHORT msg,%@NL@%
        MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    HWND   hwndTextApp;                         // Handle for App Text Window%@NL@%
    HWND   hwndTextKey;%@NL@%
    CHAR   szApp[BUF_SIZE];                     // String Contents%@NL@%
    CHAR   szKey[BUF_SIZE];%@NL@%
%@NL@%
%@NL@%
    switch (msg)%@NL@%
        {%@NL@%
        case WM_INITDLG:%@NL@%
            WinSendDlgItemMsg(hwndDialog, IDDI_DEL_KEY_TEXT_APP, EM_SETTEXTLIMIT,%@NL@%
                    MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
            WinSendDlgItemMsg(hwndDialog, IDDI_DEL_KEY_TEXT_KEY, EM_SETTEXTLIMIT,%@NL@%
                    MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
            break;%@NL@%
        case WM_COMMAND:%@NL@%
            switch( LOUSHORT( mp1 ) )%@NL@%
                {%@NL@%
%@NL@%
                case IDDI_DEL_KEY_OK:%@NL@%
                    hwndTextApp = WinWindowFromID( hwndDialog, IDDI_DEL_KEY_TEXT_APP );%@NL@%
                    WinQueryWindowText( hwndTextApp, BUF_SIZE, szApp );%@NL@%
%@NL@%
                    hwndTextKey = WinWindowFromID( hwndDialog, IDDI_DEL_KEY_TEXT_KEY );%@NL@%
                    WinQueryWindowText( hwndTextKey, BUF_SIZE, szKey );%@NL@%
%@NL@%
%@NL@%
                    WinDismissDlg( hwndDialog, 0 );%@NL@%
%@NL@%
                    %@AB@%/* if the App is NULL forget it */%@AE@%%@NL@%
                    if( *szApp == (CHAR)0 )%@NL@%
                        {%@NL@%
                        break;%@NL@%
                        }%@NL@%
%@NL@%
                    %@AB@%/* if the Key is NULL forget it */%@AE@%%@NL@%
                    if( *szKey == (CHAR)0 )%@NL@%
                        {%@NL@%
                        break;%@NL@%
                        }%@NL@%
%@NL@%
%@NL@%
                    if( !WinWriteProfileString( habIniEdit, szApp, szKey, (PCHAR)NULL ) )%@NL@%
                        ;%@NL@%
                    break;%@NL@%
%@NL@%
                default:%@NL@%
                    return WinDefDlgProc(hwndDialog, msg, mp1, mp2);%@NL@%
                    break;%@NL@%
                }%@NL@%
%@NL@%
        default:%@NL@%
            return WinDefDlgProc(hwndDialog, msg, mp1, mp2);%@NL@%
            break;%@NL@%
        }%@NL@%
%@NL@%
    return 0L;%@NL@%
%@NL@%
}  %@AB@%/* DelKeyProc */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************** Function Header ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* DelAppWndProc%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Handles the DelApp Dialog Box messages%@NL@%
%@AB@%* Will facilitate deleting all keys from a given app name%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
MRESULT _loadds EXPENTRY DelAppWndProc(HWND hwndDialog, USHORT msg,%@NL@%
        MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    HWND   hwndTextApp;                         // App Name Window%@NL@%
    CHAR   szApp[BUF_SIZE];                     // String Contents of Window%@NL@%
%@NL@%
%@NL@%
    switch (msg)%@NL@%
        {%@NL@%
        case WM_INITDLG:%@NL@%
            WinSendDlgItemMsg(hwndDialog, IDDI_DEL_APP_TEXT_APP, EM_SETTEXTLIMIT,%@NL@%
                    MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            switch( LOUSHORT( mp1 ) )%@NL@%
                {%@NL@%
%@NL@%
                case IDDI_DEL_APP_OK:%@NL@%
                    hwndTextApp = WinWindowFromID( hwndDialog, IDDI_DEL_APP_TEXT_APP );%@NL@%
                    WinQueryWindowText( hwndTextApp, BUF_SIZE, szApp );%@NL@%
%@NL@%
                    WinDismissDlg( hwndDialog, 0 );%@NL@%
%@NL@%
                    %@AB@%/* if the App is NULL forget it */%@AE@%%@NL@%
                    if( *szApp == (CHAR)0 )%@NL@%
                        {%@NL@%
                        break;%@NL@%
                        }%@NL@%
%@NL@%
                    if( !WinWriteProfileString( habIniEdit, szApp, (PCHAR)NULL, (PCHAR)NULL ) )%@NL@%
                        ;%@NL@%
%@NL@%
                    break;%@NL@%
%@NL@%
                default:%@NL@%
                    return WinDefDlgProc(hwndDialog, msg, mp1, mp2);%@NL@%
                    break;%@NL@%
                }%@NL@%
%@NL@%
        default:%@NL@%
            return WinDefDlgProc(hwndDialog, msg, mp1, mp2);%@NL@%
            break;%@NL@%
        }%@NL@%
%@NL@%
    return 0L;%@NL@%
%@NL@%
}  %@AB@%/* DelAppWndProc */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DLGSAMP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DLGSAMP\DLGSAMP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    DLGSAMP -- Dialog Box Sample Application%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
 %@NL@%
%@AI@%#define %@AE@%INCL_WINBUTTONS %@NL@%
%@AI@%#define %@AE@%INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%INCL_WINERRORS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINRECTANGLES %@NL@%
%@AI@%#define %@AE@%INCL_WINSWITCHLIST %@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%M_I86L %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
 %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
 %@NL@%
%@AI@%#include %@AE@%"dlgsamp.h" %@NL@%
%@AI@%#include %@AE@%"dlgsamp1.h" %@NL@%
 %@NL@%
%@AB@%/*%@NL@%
%@AB@%    Function Prototypes%@NL@%
%@AB@%*/%@AE@%%@NL@%
 %@NL@%
VOID NEAR cdecl main(VOID);%@NL@%
%@NL@%
%@AB@%/* Local Routines */%@AE@%%@NL@%
VOID cdecl CenterDlgBox(HWND);%@NL@%
VOID cdecl CheckColor(HWND, SHORT, COLOR *);%@NL@%
VOID cdecl EnableModality(HWND, BOOL);%@NL@%
BOOL cdecl IsIntInRange(HWND, SHORT, SHORT, SHORT, SHORT, SHORT);%@NL@%
VOID cdecl LoadDialog(HWND, HWND, SHORT, PFNWP, BOOL);%@NL@%
VOID cdecl MainWndCommand(HWND, USHORT, BOOL *);%@NL@%
VOID cdecl MainWndPaint(HWND);%@NL@%
VOID cdecl SetModality(HWND, BOOL);%@NL@%
VOID cdecl Trace(PSZ, PSZ);%@NL@%
 %@NL@%
%@AB@%/* Window Procedures */%@AE@%%@NL@%
MRESULT EXPENTRY fnwpMainWnd(HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT EXPENTRY fnwpEntryFieldDlg(HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT EXPENTRY fnwpAutoRadioButtonDlg(HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT EXPENTRY fnwpCheckBoxDlg(HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT EXPENTRY fnwpListBoxDlg(HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT EXPENTRY fnwpAboutBoxDlg(HWND, USHORT, MPARAM, MPARAM);%@NL@%
 %@NL@%
%@AB@%/*%@NL@%
%@AB@%    Global variables%@NL@%
%@AB@%*/%@AE@%%@NL@%
COLOR colorClient = CLR_RED | CLR_BLUE;    %@AB@%/* Color of client area    */%@AE@%%@NL@%
 %@NL@%
CHAR  szEntryField1[10] = "";              %@AB@%/* Used to pass back info  */%@AE@%%@NL@%
CHAR  szEntryField2[10] = "";              %@AB@%/* from entry fields       */%@AE@%%@NL@%
                                           %@AB@%/* in EntryFieldDlg        */%@AE@%%@NL@%
 %@NL@%
BOOL  bModality = TRUE;                    %@AB@%/* Does the user want modal*/%@AE@%%@NL@%
                                           %@AB@%/* or modeless dialogs?    */%@AE@%%@NL@%
COLOR colorSave;%@NL@%
CHAR  szSelection[LEN_LISTBOXENTRY] = "";  %@AB@%/* Used to pass back       */%@AE@%%@NL@%
                                           %@AB@%/* list box item selected  */%@AE@%%@NL@%
                                           %@AB@%/* in ListBoxDlg           */%@AE@%%@NL@%
 %@NL@%
HAB   hab;                                 %@AB@%/* Anchor block handle     */%@AE@%%@NL@%
HWND  hwndClient;                          %@AB@%/* Client Window handle    */%@AE@%%@NL@%
HWND  hwndFrame;                           %@AB@%/* Frame Window handle     */%@AE@%%@NL@%
HWND  hwndModelessDlg;                     %@AB@%/* Modeless Dialog handle  */%@AE@%%@NL@%
 %@NL@%
%@AB@%/**************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   FUNCTION: main%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Typical PM main function which initializes PM, creates a message queue,%@NL@%
%@AB@%*   registers a window class, creates a window, gets and dispatches%@NL@%
%@AB@%*   messages to its winproc until its time to quit, and then tidies up%@NL@%
%@AB@%*   before terminating.%@NL@%
%@AB@%*%@NL@%
%@AB@%**************************************************************************/%@AE@%%@NL@%
 %@NL@%
VOID NEAR cdecl main(  )%@NL@%
{%@NL@%
  HMQ     hmq;                        %@AB@%/* Message Queue handle         */%@AE@%%@NL@%
  QMSG    qmsg;                       %@AB@%/* Message                      */%@AE@%%@NL@%
  ULONG   flCreate;%@NL@%
 %@NL@%
  hab   = WinInitialize( 0 );         %@AB@%/* Initialize PM                */%@AE@%%@NL@%
  hmq   = WinCreateMsgQueue( hab, 0 );%@AB@%/* Create application msg queue */%@AE@%%@NL@%
 %@NL@%
  WinRegisterClass(                   %@AB@%/* Register Window Class        */%@AE@%%@NL@%
      hab,                            %@AB@%/* Anchor block handle          */%@AE@%%@NL@%
      "DlgSamp Class",                %@AB@%/* Window Class name            */%@AE@%%@NL@%
      fnwpMainWnd,                    %@AB@%/* Address of Window Procedure  */%@AE@%%@NL@%
      (ULONG) NULL,                   %@AB@%/* No special class style       */%@AE@%%@NL@%
      0                               %@AB@%/* No extra window words        */%@AE@%%@NL@%
      );%@NL@%
 %@NL@%
  flCreate = FCF_STANDARD & ~FCF_ACCELTABLE;%@NL@%
 %@NL@%
  hwndFrame = WinCreateStdWindow(%@NL@%
        HWND_DESKTOP,                   %@AB@%/* Desktop Window is parent     */%@AE@%%@NL@%
        WS_VISIBLE,                     %@AB@%/* Window styles                */%@AE@%%@NL@%
        (PVOID)&flCreate,               %@AB@%/* Window creation parameters   */%@AE@%%@NL@%
        "DlgSamp Class",                %@AB@%/* Window Class name            */%@AE@%%@NL@%
        "",                             %@AB@%/* Window Text                  */%@AE@%%@NL@%
        0L,                             %@AB@%/* Client style                 */%@AE@%%@NL@%
        (HMODULE) NULL,                 %@AB@%/* Module handle                */%@AE@%%@NL@%
        ID_MAINWND,                     %@AB@%/* Window ID                    */%@AE@%%@NL@%
        (HWND FAR *)&hwndClient         %@AB@%/* Client Window handle         */%@AE@%%@NL@%
        );%@NL@%
 %@NL@%
 %@NL@%
  %@AB@%/* Message Loop */%@AE@%%@NL@%
  while( WinGetMsg( hab, (PQMSG)&qmsg, (HWND)NULL, 0, 0 ) )%@NL@%
    WinDispatchMsg( hab, (PQMSG)&qmsg );%@NL@%
 %@NL@%
  %@AB@%/* Cleanup code */%@AE@%%@NL@%
  WinDestroyWindow( hwndFrame );%@NL@%
  WinDestroyMsgQueue( hmq );%@NL@%
  WinTerminate( hab );%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/***********************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   WinProc: fnwpMainWnd%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Controls the state of the menu, and loads various dialogs.  The%@NL@%
%@AB@%*   dialogs will be modal or modeless depending on the setting of the%@NL@%
%@AB@%*   Modality menuitem.%@NL@%
%@AB@%*%@NL@%
%@AB@%***********************************************************************/%@AE@%%@NL@%
 %@NL@%
MRESULT  EXPENTRY fnwpMainWnd( hwnd, message, mp1, mp2 )%@NL@%
HWND    hwnd;%@NL@%
USHORT  message;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
  USHORT   Command;   %@AB@%/* Command passed by WM_COMMAND */%@AE@%%@NL@%
  SHORT    id;        %@AB@%/* ID of item selected from the list box */%@AE@%%@NL@%
 %@NL@%
  switch(message)%@NL@%
  {%@NL@%
    case WM_PAINT:%@NL@%
      MainWndPaint( hwnd );  %@AB@%/* Invoke window painting routine */%@AE@%%@NL@%
      break;%@NL@%
    case WM_HELP:%@NL@%
%@AB@%/*********************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   This will be received when either:-%@NL@%
%@AB@%*%@NL@%
%@AB@%*   1. The user hits the F1 key%@NL@%
%@AB@%*   2. The user clicks on the action bar item F1=Help%@NL@%
%@AB@%*%@NL@%
%@AB@%*********************************************************************/%@AE@%%@NL@%
      WinMessageBox( HWND_DESKTOP,%@NL@%
                     hwndFrame,%@NL@%
                     (PSZ)"Dialog Sample Application: Help",%@NL@%
                     (PSZ)"Try out the pulldown menus, or Alt+selection",%@NL@%
                     ID_MB,%@NL@%
                     MB_OK );%@NL@%
      break;%@NL@%
    case WM_COMMAND:%@NL@%
      Command = SHORT1FROMMP( mp1 );%@NL@%
      MainWndCommand( hwnd, Command, &bModality );%@NL@%
      break;%@NL@%
    case DLGSAMP_EFCOMPLETE:%@NL@%
      WinQueryWindowText( WinWindowFromID( hwndModelessDlg, EF_1 ),%@NL@%
                          sizeof( szEntryField1 ), szEntryField1 );%@NL@%
      WinQueryWindowText( WinWindowFromID( hwndModelessDlg, EF_2 ),%@NL@%
                          sizeof( szEntryField2 ), szEntryField2 );%@NL@%
      WinInvalidateRect( hwnd, NULL, FALSE );%@AB@%/* Request whole window repaint */%@AE@%%@NL@%
      break;%@NL@%
    case DLGSAMP_LBCOMPLETE:%@NL@%
      id = SHORT1FROMMR( WinSendDlgItemMsg( hwndModelessDlg,%@NL@%
                                            LB_1,%@NL@%
                                            LM_QUERYSELECTION,%@NL@%
                                            0L,%@NL@%
                                            0L ) );%@NL@%
      if( id == LIT_NONE )%@NL@%
        strcpy( szSelection, "" );%@NL@%
      else%@NL@%
        WinSendDlgItemMsg( hwndModelessDlg,%@NL@%
                           LB_1,%@NL@%
                           LM_QUERYITEMTEXT,%@NL@%
                           MPFROM2SHORT( id, sizeof( szSelection ) ),%@NL@%
                           MPFROMP( szSelection ) );%@NL@%
      break;%@NL@%
    case DLGSAMP_RBCOMPLETE:%@NL@%
    case DLGSAMP_CBCOMPLETE:%@NL@%
      break;%@NL@%
    case DLGSAMP_DESTROYDLG:%@NL@%
      WinDestroyWindow( hwndModelessDlg );%@NL@%
      EnableModality( hwndFrame, TRUE );%@NL@%
      WinInvalidateRect( hwnd, NULL, FALSE );%@AB@%/* Request whole window repaint */%@AE@%%@NL@%
      break;%@NL@%
    case WM_CLOSE:%@NL@%
      WinPostMsg( hwnd, WM_QUIT, 0L, 0L );  %@AB@%/* Cause termination    */%@AE@%%@NL@%
      break;%@NL@%
    default:%@NL@%
      return WinDefWindowProc( hwnd, message, mp1, mp2 );%@NL@%
  }%@NL@%
  return FALSE;%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/***********************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  DlgProc:  fnwpEntryFieldDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*  A dialog proc which captures and validates the contents of two%@NL@%
%@AB@%*  entry fields.%@NL@%
%@AB@%*%@NL@%
%@AB@%***********************************************************************/%@AE@%%@NL@%
 %@NL@%
MRESULT EXPENTRY fnwpEntryFieldDlg( hwndDlg, message, mp1, mp2 )%@NL@%
HWND    hwndDlg;%@NL@%
USHORT  message;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
  switch (message)%@NL@%
  {%@NL@%
    case WM_INITDLG:%@NL@%
      CenterDlgBox( hwndDlg );%@NL@%
      break;%@NL@%
    case WM_COMMAND:%@NL@%
      switch( SHORT1FROMMP( mp1 ) )%@NL@%
      {%@NL@%
        case DID_OK: %@AB@%/* Enter key or pushbutton pressed/ selected */%@AE@%%@NL@%
 %@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Validate the contents of the two entry fields%@NL@%
%@AB@%*%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
 %@NL@%
          if( !IsIntInRange( hwndDlg, EF_1, 1, 100, ERR_EFINVALID, ID_MB ) )%@NL@%
            return FALSE;%@NL@%
          if( !IsIntInRange( hwndDlg, EF_2, 1, 100, ERR_EFINVALID, ID_MB ) )%@NL@%
            return FALSE;%@NL@%
 %@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   A modal dialog is destroyed before control is returned to the%@NL@%
%@AB@%*   invoking winproc, so it must pass the contents of its Entry Fields etc.%@NL@%
%@AB@%*   back to the invoking window before it returns.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   When a modeless dialog box returns it still continues to exist. It%@NL@%
%@AB@%*   could pass the contents of its Entry Fields etc. back to the%@NL@%
%@AB@%*   invoking window in several ways.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Here a user message is posted to the invoking window to say that the%@NL@%
%@AB@%*   dialog has completed. The invoking window then has an opportunity%@NL@%
%@AB@%*   to extract the contents of the Entry Fields etc.%@NL@%
%@AB@%*%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
 %@NL@%
          if( bModality )%@NL@%
          {%@NL@%
            WinQueryWindowText( WinWindowFromID( hwndDlg, EF_1 ),%@NL@%
                                sizeof( szEntryField1),%@NL@%
                                szEntryField1 );%@NL@%
            WinQueryWindowText( WinWindowFromID( hwndDlg, EF_2 ),%@NL@%
                                sizeof( szEntryField2),%@NL@%
                                szEntryField2 );%@NL@%
          }%@NL@%
          else%@NL@%
            WinPostMsg( hwndClient, DLGSAMP_EFCOMPLETE, 0L, 0L );%@NL@%
 %@NL@%
        case DID_CANCEL:%@AB@%/* Escape key or CANCEL pushbutton pressed/selected */%@AE@%%@NL@%
          if( bModality )%@NL@%
            WinDismissDlg( hwndDlg,TRUE );%@NL@%
          else%@NL@%
            WinPostMsg( hwndClient, DLGSAMP_DESTROYDLG, 0L, 0L );%@NL@%
          return FALSE;%@NL@%
        default:%@NL@%
          break;%@NL@%
      }%@NL@%
      break;%@NL@%
 %@NL@%
    default:  %@AB@%/* Pass all other messages to the default dialog proc */%@AE@%%@NL@%
      return WinDefDlgProc( hwndDlg, message, mp1, mp2 );%@NL@%
  }%@NL@%
  return FALSE;%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/***********************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  DlgProc:  fnwpAutoRadioButtonDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*  A dialog procedure which uses auto radio buttons to change the%@NL@%
%@AB@%*  color of the Client Area window.%@NL@%
%@AB@%*%@NL@%
%@AB@%***********************************************************************/%@AE@%%@NL@%
 %@NL@%
MRESULT EXPENTRY fnwpAutoRadioButtonDlg( hwndDlg, message, mp1, mp2 )%@NL@%
HWND    hwndDlg;%@NL@%
USHORT  message;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
  switch (message)%@NL@%
  {%@NL@%
    case WM_INITDLG:%@NL@%
      colorSave = colorClient;%@NL@%
      CenterDlgBox( hwndDlg );%@NL@%
      if ( colorClient == CLR_RED )%@NL@%
        WinPostMsg( WinWindowFromID( hwndDlg, RB_RED ),%@NL@%
                    BM_SETCHECK,%@NL@%
                    MPFROM2SHORT( TRUE, 0 ),%@NL@%
                    0L );%@NL@%
%@NL@%
      if ( colorClient == CLR_GREEN )%@NL@%
        WinPostMsg( WinWindowFromID( hwndDlg, RB_GREEN ),%@NL@%
                    BM_SETCHECK,%@NL@%
                    MPFROM2SHORT( TRUE, 0 ),%@NL@%
                    0L );%@NL@%
%@NL@%
      if ( colorClient == CLR_BLUE )%@NL@%
        WinPostMsg( WinWindowFromID( hwndDlg, RB_BLUE ),%@NL@%
                    BM_SETCHECK,%@NL@%
                    MPFROM2SHORT( TRUE, 0 ),%@NL@%
                    0L );%@NL@%
%@NL@%
      break;%@NL@%
    case WM_CONTROL:%@NL@%
      if( SHORT2FROMMP( mp1 ) == BN_CLICKED )%@NL@%
        switch( SHORT1FROMMP( mp1 ) )%@NL@%
        {%@NL@%
          case RB_RED:%@NL@%
            colorClient = CLR_RED;%@NL@%
            break;%@NL@%
          case RB_GREEN:%@NL@%
            colorClient = CLR_GREEN;%@NL@%
            break;%@NL@%
          case RB_BLUE:%@NL@%
            colorClient = CLR_BLUE;%@NL@%
            break;%@NL@%
          default:%@NL@%
           return FALSE;%@NL@%
        }%@NL@%
        WinInvalidateRect( hwndClient, NULL, FALSE );%@NL@%
        break;%@NL@%
    case WM_COMMAND:%@NL@%
      switch( SHORT1FROMMP( mp1 ) )%@NL@%
      {%@NL@%
        case DID_OK:     %@AB@%/* Enter key or pushbutton pressed/ selected        */%@AE@%%@NL@%
          if( !bModality )%@NL@%
            WinPostMsg( hwndClient, DLGSAMP_RBCOMPLETE, 0L, 0L );%@NL@%
          break;%@NL@%
        case DID_CANCEL: %@AB@%/* Escape key or CANCEL pushbutton pressed/selected */%@AE@%%@NL@%
          colorClient = colorSave;%@NL@%
          break;%@NL@%
        default:%@NL@%
          return WinDefDlgProc( hwndDlg, message, mp1, mp2 );%@NL@%
      }%@NL@%
      if( bModality )%@NL@%
        WinDismissDlg( hwndDlg, TRUE );%@NL@%
      else%@NL@%
        WinPostMsg( hwndClient, DLGSAMP_DESTROYDLG, 0L, 0L );%@NL@%
      break;%@NL@%
 %@NL@%
    default:  %@AB@%/* Pass all other messages to the default dialog proc */%@AE@%%@NL@%
      return WinDefDlgProc( hwndDlg, message, mp1, mp2 );%@NL@%
  }%@NL@%
  return FALSE;%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/***********************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  DlgProc:  fnwpCheckBoxDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*  A dialog procedure to which use checkboxes to change the color%@NL@%
%@AB@%*  of the Client Area Window.%@NL@%
%@AB@%*%@NL@%
%@AB@%***********************************************************************/%@AE@%%@NL@%
 %@NL@%
MRESULT EXPENTRY fnwpCheckBoxDlg( hwndDlg, message, mp1, mp2 )%@NL@%
HWND    hwndDlg;%@NL@%
USHORT  message;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
  switch (message)%@NL@%
  {%@NL@%
    case WM_INITDLG:%@NL@%
      CenterDlgBox( hwndDlg );%@NL@%
      colorSave = colorClient;%@NL@%
      if( (colorClient & CLR_RED) == CLR_RED )%@NL@%
        WinPostMsg( WinWindowFromID( hwndDlg, CB_RED ),%@NL@%
                    BM_SETCHECK,%@NL@%
                    MPFROM2SHORT( TRUE,0 ),%@NL@%
                    0L );%@NL@%
      if( (colorClient & CLR_GREEN) == CLR_GREEN )%@NL@%
        WinPostMsg( WinWindowFromID( hwndDlg, CB_GREEN ),%@NL@%
                    BM_SETCHECK,%@NL@%
                    MPFROM2SHORT( TRUE,0 ),%@NL@%
                    0L );%@NL@%
      if( (colorClient & CLR_BLUE) == CLR_BLUE )%@NL@%
        WinPostMsg( WinWindowFromID( hwndDlg, CB_BLUE ),%@NL@%
                    BM_SETCHECK,%@NL@%
                    MPFROM2SHORT( TRUE,0 ),%@NL@%
                    0L );%@NL@%
      break;%@NL@%
    case WM_CONTROL:                  %@AB@%/* User has clicked on a checkbox */%@AE@%%@NL@%
      if( SHORT2FROMMP( mp1 ) == BN_CLICKED )%@NL@%
        CheckColor( hwndDlg, SHORT1FROMMP( mp1 ), &colorClient );%@NL@%
      WinInvalidateRect( hwndClient, NULL, FALSE );%@NL@%
      break;%@NL@%
    case WM_COMMAND:%@NL@%
      switch( SHORT1FROMMP( mp1 ) )%@NL@%
      {%@NL@%
        case DID_OK:     %@AB@%/* Enter key or pushbutton pressed/ selected */%@AE@%%@NL@%
          if( !bModality )%@NL@%
            WinPostMsg( hwndClient, DLGSAMP_CBCOMPLETE, 0L, 0L );%@NL@%
          break;%@NL@%
        case DID_CANCEL: %@AB@%/* Escape key or CANCEL pushbutton pressed/selected */%@AE@%%@NL@%
          colorClient = colorSave;%@NL@%
          break;%@NL@%
        default:%@NL@%
          return WinDefDlgProc( hwndDlg, message, mp1, mp2 );%@NL@%
      }%@NL@%
      if( bModality )%@NL@%
        WinDismissDlg( hwndDlg, TRUE );%@NL@%
      else%@NL@%
        WinPostMsg( hwndClient, DLGSAMP_DESTROYDLG, 0L, 0L );%@NL@%
      return FALSE;%@NL@%
 %@NL@%
    default:  %@AB@%/* Pass all other messages to the default dialog proc */%@AE@%%@NL@%
      return WinDefDlgProc( hwndDlg, message, mp1, mp2 );%@NL@%
  }%@NL@%
  return FALSE;%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/***********************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  DlgProc:  fnwpListBoxDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%***********************************************************************/%@AE@%%@NL@%
 %@NL@%
MRESULT EXPENTRY fnwpListBoxDlg( hwndDlg, message, mp1, mp2 )%@NL@%
HWND    hwndDlg;%@NL@%
USHORT  message;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
  CHAR szBuffer[LEN_LISTBOXENTRY];%@NL@%
  SHORT  i;%@NL@%
  SHORT  id;%@NL@%
 %@NL@%
  switch (message)%@NL@%
  {%@NL@%
    case WM_INITDLG:%@NL@%
      CenterDlgBox( hwndDlg );%@NL@%
 %@NL@%
%@AB@%/*************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Initialize the listbox with a set of strings loaded from a%@NL@%
%@AB@%*   resource file.%@NL@%
%@AB@%*%@NL@%
%@AB@%*************************************************************************/%@AE@%%@NL@%
 %@NL@%
      for ( i = 0; i < NUM_LISTBOXENTRIES; i++ )%@NL@%
      {%@NL@%
        WinLoadString( hab,%@NL@%
                       (HMODULE) NULL,%@NL@%
                       LBI_1 + i,%@NL@%
                       LEN_LISTBOXENTRY,%@NL@%
                       (PSZ)szBuffer%@NL@%
                     );%@NL@%
        WinSendDlgItemMsg( hwndDlg,%@NL@%
                           LB_1,%@NL@%
                           LM_INSERTITEM,%@NL@%
                           MPFROM2SHORT( LIT_END, 0 ),%@NL@%
                           MPFROMP( szBuffer )%@NL@%
                         );%@NL@%
      }%@NL@%
      break;%@NL@%
    case WM_COMMAND:%@NL@%
      switch( SHORT1FROMMP( mp1 ) )%@NL@%
      {%@NL@%
        case DID_OK:     %@AB@%/* Enter key or pushbutton pressed/ selected */%@AE@%%@NL@%
          if( bModality )%@NL@%
          {%@NL@%
 %@NL@%
%@AB@%/***********************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Find out which item (if any) was selected and return the selected%@NL@%
%@AB@%*   item text.%@NL@%
%@AB@%*%@NL@%
%@AB@%***********************************************************************/%@AE@%%@NL@%
 %@NL@%
            id = SHORT1FROMMR( WinSendDlgItemMsg( hwndDlg,%@NL@%
                                                  LB_1,%@NL@%
                                                  LM_QUERYSELECTION,%@NL@%
                                                  0L,%@NL@%
                                                  0L ) );%@NL@%
            if( id == LIT_NONE )%@NL@%
              strcpy( szSelection, "" );%@NL@%
            else%@NL@%
              WinSendDlgItemMsg( hwndDlg,%@NL@%
                                 LB_1,%@NL@%
                                 LM_QUERYITEMTEXT,%@NL@%
                                 MPFROM2SHORT( id, LEN_LISTBOXENTRY ),%@NL@%
                                 MPFROMP( szSelection ) );%@NL@%
          }%@NL@%
          else%@NL@%
            WinPostMsg( hwndClient, DLGSAMP_LBCOMPLETE, 0L, 0L );%@NL@%
        case DID_CANCEL: %@AB@%/* Escape key or CANCEL pushbutton pressed/selected */%@AE@%%@NL@%
          if( bModality )%@NL@%
            WinDismissDlg( hwndDlg, TRUE );%@NL@%
          else%@NL@%
            WinPostMsg( hwndClient, DLGSAMP_DESTROYDLG, 0L, 0L );%@NL@%
          return FALSE;%@NL@%
        default:%@NL@%
          break;%@NL@%
      }%@NL@%
      break;%@NL@%
 %@NL@%
    default:  %@AB@%/* Pass all other messages to the default dialog proc */%@AE@%%@NL@%
      return WinDefDlgProc( hwndDlg, message, mp1, mp2 );%@NL@%
  }%@NL@%
  return FALSE;%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/*************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   FUNCTION : CenterDlgBox%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Positions the dialog box in the center of the screen%@NL@%
%@AB@%*%@NL@%
%@AB@%*************************************************************************/%@AE@%%@NL@%
 %@NL@%
VOID cdecl CenterDlgBox( hwnd )%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
  SHORT ix, iy;%@NL@%
  SHORT iwidth, idepth;%@NL@%
  SWP   swp;%@NL@%
 %@NL@%
  iwidth = (SHORT)WinQuerySysValue( HWND_DESKTOP, SV_CXSCREEN );%@NL@%
  idepth = (SHORT)WinQuerySysValue( HWND_DESKTOP, SV_CYSCREEN );%@NL@%
  WinQueryWindowPos( hwnd, (PSWP)&swp );%@NL@%
  ix = ( iwidth  - swp.cx ) / 2;%@NL@%
  iy = ( idepth  - swp.cy ) / 2;%@NL@%
  WinSetWindowPos( hwnd, HWND_TOP, ix, iy, 0, 0, SWP_MOVE );%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  FUNCTION: CheckColor%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Toggle the Checked/UnChecked state of a checkbox and add/remove%@NL@%
%@AB@%*  the corresponding CLR color component of the Client Area Color.%@NL@%
%@AB@%*%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
 %@NL@%
VOID cdecl CheckColor( hwndDlg, iDlgItem, colorClient )%@NL@%
HWND   hwndDlg;%@NL@%
SHORT  iDlgItem;%@NL@%
COLOR *colorClient;%@NL@%
{%@NL@%
  BOOL  bChecked;%@NL@%
  COLOR color;%@NL@%
 %@NL@%
  switch( iDlgItem )%@NL@%
  {%@NL@%
    case CB_RED:%@NL@%
      color = CLR_RED;%@NL@%
      break;%@NL@%
    case CB_GREEN:%@NL@%
      color = CLR_GREEN;%@NL@%
      break;%@NL@%
    case CB_BLUE:%@NL@%
      color = CLR_BLUE;%@NL@%
      break;%@NL@%
    default:%@NL@%
      return;%@NL@%
  }%@NL@%
 %@NL@%
  bChecked = SHORT1FROMMR( WinSendMsg( WinWindowFromID( hwndDlg , iDlgItem ),%@NL@%
                                       BM_QUERYCHECK,%@NL@%
                                       0L,%@NL@%
                                       0L ) );%@NL@%
  WinPostMsg( WinWindowFromID( hwndDlg, iDlgItem ),%@NL@%
              BM_SETCHECK,%@NL@%
              MPFROM2SHORT( !bChecked, 0 ),%@NL@%
              0L );%@NL@%
  if( bChecked )                   %@AB@%/* If color previously checked */%@AE@%%@NL@%
    *colorClient -= color;         %@AB@%/* subtract it ... else        */%@AE@%%@NL@%
  else%@NL@%
    *colorClient += color;         %@AB@%/* ... add it.                 */%@AE@%%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/**************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   FUNCTION: EnableModality%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Enable or disable the Modality menuitems depending on the value%@NL@%
%@AB@%*   of modal. This is done to prevent the user from altering the%@NL@%
%@AB@%*   modality setting while a modeless dialog is active.%@NL@%
%@AB@%*%@NL@%
%@AB@%**************************************************************************/%@AE@%%@NL@%
 %@NL@%
VOID cdecl EnableModality( hwnd, bModal )%@NL@%
HWND hwnd;%@NL@%
BOOL bModal;%@NL@%
{%@NL@%
  if( bModal )%@NL@%
  {%@NL@%
    WinPostMsg( WinWindowFromID( hwnd, FID_MENU ),%@NL@%
                MM_SETITEMATTR,%@NL@%
                MPFROM2SHORT( MI_MODAL, TRUE ),%@NL@%
                MPFROM2SHORT( MIA_DISABLED, ~MIA_DISABLED ) );%@NL@%
    WinPostMsg( WinWindowFromID( hwnd, FID_MENU ),%@NL@%
                MM_SETITEMATTR,%@NL@%
                MPFROM2SHORT( MI_MODELESS, TRUE ),%@NL@%
                MPFROM2SHORT( MIA_DISABLED, ~MIA_DISABLED ) );%@NL@%
  }%@NL@%
  else%@NL@%
  {%@NL@%
    WinPostMsg( WinWindowFromID( hwnd, FID_MENU ),%@NL@%
                MM_SETITEMATTR,%@NL@%
                MPFROM2SHORT( MI_MODAL, TRUE ),%@NL@%
                MPFROM2SHORT( MIA_DISABLED, MIA_DISABLED ) );%@NL@%
    WinPostMsg( WinWindowFromID( hwnd, FID_MENU ),%@NL@%
                MM_SETITEMATTR,%@NL@%
                MPFROM2SHORT( MI_MODELESS, TRUE ),%@NL@%
                MPFROM2SHORT( MIA_DISABLED, MIA_DISABLED ) );%@NL@%
  }%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  FUNCTION: IsIntInRange.%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Checks whether the value of a dialog item is in an integer in%@NL@%
%@AB@%*  a given range.%@NL@%
%@AB@%*%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
 %@NL@%
BOOL cdecl IsIntInRange( hwndDlg,  idEntryField,%@NL@%
                         iLoRange, iHiRange,%@NL@%
                         idErrMsg, idMessageBox )%@NL@%
HWND hwndDlg;%@NL@%
SHORT  idEntryField;%@NL@%
SHORT  iLoRange;%@NL@%
SHORT  iHiRange;%@NL@%
SHORT  idErrMsg;%@NL@%
SHORT  idMessageBox;%@NL@%
{%@NL@%
  SHORT ivalue;%@NL@%
  CHAR  szErrMsg[80];%@NL@%
 %@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Validate an entry field.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   If validation fails leave the dialog visible, issue an error message%@NL@%
%@AB@%*   using a messagebox, and when the user dismisses the messagebox,%@NL@%
%@AB@%*   set the input focus to the entry field containing the error. Leave%@NL@%
%@AB@%*   the contents of the entry field unchanged, and return FALSE.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   If validation is successful return the value in ivalue and return%@NL@%
%@AB@%*   TRUE.%@NL@%
%@AB@%*%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
 %@NL@%
  if( !WinQueryDlgItemShort( hwndDlg, idEntryField, &ivalue, TRUE ) ||%@NL@%
      ( ivalue < iLoRange ) ||%@NL@%
      ( ivalue > iHiRange ) )%@NL@%
  {%@NL@%
    WinLoadString( hab, (HMODULE) NULL, idErrMsg, sizeof( szErrMsg ), szErrMsg );%@NL@%
    WinMessageBox( HWND_DESKTOP,%@NL@%
                   hwndFrame,%@NL@%
                   (PSZ)szErrMsg,%@NL@%
                   NULL,%@NL@%
                   idMessageBox,%@NL@%
                   MB_OK );%@NL@%
    WinSetFocus( HWND_DESKTOP, WinWindowFromID( hwndDlg, idEntryField ) );%@NL@%
    return FALSE;%@NL@%
  }%@NL@%
  else%@NL@%
    return TRUE;%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/***********************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  FUNCTION: LoadDialog%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Use the appropriate functions to put up a modal or modeless%@NL@%
%@AB@%*  dialog box depending on the setting of the bModality parameter.%@NL@%
%@AB@%*%@NL@%
%@AB@%***********************************************************************/%@AE@%%@NL@%
 %@NL@%
VOID cdecl LoadDialog( hwndParent, hwndOwner, idDlg, fnwpDlgProc, bModality )%@NL@%
HWND  hwndParent;%@NL@%
HWND  hwndOwner;%@NL@%
SHORT idDlg;%@NL@%
PFNWP fnwpDlgProc;%@NL@%
BOOL  bModality;%@NL@%
{%@NL@%
  EnableModality( hwndOwner, FALSE ); %@AB@%/* Disable the Modality menu item */%@AE@%%@NL@%
 %@NL@%
  if( bModality )%@NL@%
  {%@NL@%
    WinDlgBox( hwndParent,        %@AB@%/* Parent                    */%@AE@%%@NL@%
               hwndOwner,         %@AB@%/* Owner                     */%@AE@%%@NL@%
               fnwpDlgProc,       %@AB@%/* Address of dialog proc    */%@AE@%%@NL@%
               (HMODULE) NULL,              %@AB@%/* Module handle             */%@AE@%%@NL@%
               idDlg,             %@AB@%/* Id of dialog in resource  */%@AE@%%@NL@%
               NULL );            %@AB@%/* Initialisation data       */%@AE@%%@NL@%
    EnableModality( hwndOwner, TRUE ); %@AB@%/* Enable the Modality menu item */%@AE@%%@NL@%
  }%@NL@%
  else%@NL@%
  {%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *   Check to see if a modeless dialog is already running: if%@NL@%
%@AB@%    *   so destroy it before for loading the requested dialog. Save%@NL@%
%@AB@%    *   the handle of the new dialog in a global variable so that in%@NL@%
%@AB@%    *   can be accessed by the WinProc that issued LoadDialog.%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
 %@NL@%
    if( WinIsWindow( hab, hwndModelessDlg ) )%@NL@%
      WinDestroyWindow( hwndModelessDlg );%@NL@%
    hwndModelessDlg = WinLoadDlg( hwndParent,%@NL@%
                                  hwndOwner,%@NL@%
                                  fnwpDlgProc,%@NL@%
                                  (HMODULE) NULL,%@NL@%
                                  idDlg,%@NL@%
                                  NULL );%@NL@%
  }%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/*************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   FUNCTION: MainWndCommand%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Take the appropriate action when a WM_COMMAND message is received by%@NL@%
%@AB@%*   MainWndProc.  Issues calls which load dialogs in the prevailing state%@NL@%
%@AB@%*   of modality.%@NL@%
%@AB@%*%@NL@%
%@AB@%*************************************************************************/%@AE@%%@NL@%
 %@NL@%
VOID cdecl MainWndCommand( hwnd, Command, bModality )%@NL@%
HWND   hwnd;%@NL@%
USHORT Command;%@NL@%
BOOL   *bModality;%@NL@%
{%@NL@%
  USHORT idDlg;%@NL@%
  PFNWP  pfnDlgProc;%@NL@%
 %@NL@%
  switch( Command )%@NL@%
  {%@NL@%
    case MI_MODAL:%@NL@%
    case MI_MODELESS:%@NL@%
      *bModality = ( Command == MI_MODAL ) ? TRUE%@NL@%
                                           : FALSE;%@NL@%
      SetModality( WinQueryWindow( hwnd, QW_PARENT, FALSE ), *bModality );%@NL@%
      WinInvalidateRect( hwnd, NULL, FALSE );%@NL@%
      return;%@NL@%
    case MI_ENTRYFIELDEXAMPLE:%@NL@%
      idDlg      = DLG_ENTRYFIELDEXAMPLE;%@NL@%
      pfnDlgProc = (PFNWP)fnwpEntryFieldDlg;%@NL@%
      break;%@NL@%
    case MI_AUTORADIOBUTTONEXAMPLE:%@NL@%
      idDlg      = DLG_AUTORADIOBUTTONEXAMPLE;%@NL@%
      pfnDlgProc = (PFNWP)fnwpAutoRadioButtonDlg;%@NL@%
      break;%@NL@%
    case MI_CHECKBOXEXAMPLE:%@NL@%
      idDlg      = DLG_CHECKBOXEXAMPLE;%@NL@%
      pfnDlgProc = (PFNWP)fnwpCheckBoxDlg;%@NL@%
      break;%@NL@%
    case MI_LISTBOXEXAMPLE:%@NL@%
      idDlg      = DLG_LISTBOXEXAMPLE;%@NL@%
      pfnDlgProc = (PFNWP)fnwpListBoxDlg;%@NL@%
      break;%@NL@%
    case MI_ABOUTBOX:%@NL@%
      WinDlgBox(HWND_DESKTOP, hwnd, fnwpAboutBoxDlg, (HMODULE) NULL, DLG_ABOUT, NULL);%@NL@%
      return;%@NL@%
    default:%@NL@%
      return;%@NL@%
  }%@NL@%
  LoadDialog( HWND_DESKTOP,%@NL@%
              hwndFrame,%@NL@%
              idDlg,%@NL@%
              pfnDlgProc,%@NL@%
              *bModality );%@NL@%
  if( *bModality )%@NL@%
    WinInvalidateRect( hwnd, NULL, FALSE );  %@AB@%/* Request whole window repaint */%@AE@%%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   FUNCTION: MainWndPaint%@NL@%
%@AB@%*%@NL@%
%@AB@%*   An unsophisticated window painting routine which simply repaints the%@NL@%
%@AB@%*   entire window when a WM_PAINT message is received. In a real%@NL@%
%@AB@%*   application more sophisticated techniques could be used to determine%@NL@%
%@AB@%*   the minimum region needing repainting, and to paint only that%@NL@%
%@AB@%*   region%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
 %@NL@%
VOID cdecl MainWndPaint( hwnd )%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
  POINTL   pointl;%@NL@%
  HPS      hps;                          %@AB@%/* Presentation space handle */%@AE@%%@NL@%
  RECTL    rcl;                          %@AB@%/* Window rectangle          */%@AE@%%@NL@%
  CHAR     string[50];%@NL@%
 %@NL@%
  hps = WinBeginPaint( hwnd, (HPS)NULL, (PRECTL)&rcl );%@NL@%
  %@AB@%/*%@NL@%
%@AB@%        Color in the background%@NL@%
%@AB@%  */%@AE@%%@NL@%
  switch ((int) colorClient) {%@NL@%
        case 0:                %@AB@%/* (r,g,b) = (0,0,0) */%@AE@%%@NL@%
            WinFillRect( hps, (PRECTL)&rcl, CLR_BLACK );%@NL@%
            break;%@NL@%
        case 7:                %@AB@%/* (r,g,b) = (1,1,1) */%@AE@%%@NL@%
            WinFillRect( hps, (PRECTL)&rcl, CLR_WHITE );%@NL@%
            break;%@NL@%
        default:%@NL@%
            WinFillRect( hps, (PRECTL)&rcl, colorClient );%@NL@%
            break;%@NL@%
  }%@NL@%
  %@AB@%/*%@NL@%
%@AB@%        Set the text character colors%@NL@%
%@AB@%  */%@AE@%%@NL@%
  GpiSetColor( hps, (colorClient == 0L) ? CLR_WHITE%@NL@%
                                        : CLR_BLACK );%@NL@%
  pointl.x = 10L; pointl.y = 70L;%@NL@%
  strcpy( string, "Dialog modality    = " );%@NL@%
  strcat( string, (bModality) ? "Modal"%@NL@%
                              : "Modeless" );%@NL@%
  GpiCharStringAt( hps, &pointl, (LONG)strlen( string ), (PSZ)string );%@NL@%
  pointl.y = 50L;%@NL@%
  strcpy( string, "Entry Field 1      = " );%@NL@%
  strcat( string, szEntryField1 );%@NL@%
  GpiCharStringAt( hps, &pointl, (LONG)strlen( string ), (PSZ)string );%@NL@%
  pointl.y = 30L;%@NL@%
  strcpy( string, "Entry Field 2      = " );%@NL@%
  strcat( string, szEntryField2 );%@NL@%
  GpiCharStringAt( hps, &pointl, (LONG)strlen( string ), (PSZ)string );%@NL@%
  pointl.y = 10L;%@NL@%
  strcpy( string, "List Box Selection = " );%@NL@%
  strcat( string, szSelection );%@NL@%
  GpiCharStringAt( hps, &pointl, (LONG)strlen( string ), (PSZ)string );%@NL@%
  WinEndPaint( hps );%@NL@%
 }%@NL@%
 %@NL@%
%@AB@%/**************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  FUNCTION: SetModality%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Check or uncheck Modal and Modeless menu items as appropriate.%@NL@%
%@AB@%*%@NL@%
%@AB@%**************************************************************************/%@AE@%%@NL@%
 %@NL@%
VOID cdecl SetModality( hwnd, bModal )%@NL@%
HWND hwnd;%@NL@%
BOOL bModal;%@NL@%
{%@NL@%
  WinPostMsg( WinWindowFromID( hwnd, FID_MENU ),%@NL@%
              MM_SETITEMATTR,%@NL@%
              MPFROM2SHORT( MI_MODAL, TRUE ),%@NL@%
              MPFROM2SHORT( MIA_CHECKED, (bModal) ? ( MIA_CHECKED)%@NL@%
                                                  : (~MIA_CHECKED) ) );%@NL@%
 %@NL@%
  WinPostMsg( WinWindowFromID( hwnd, FID_MENU ),%@NL@%
              MM_SETITEMATTR,%@NL@%
              MPFROM2SHORT( MI_MODELESS, TRUE ),%@NL@%
              MPFROM2SHORT( MIA_CHECKED, (bModal) ? (~MIA_CHECKED)%@NL@%
                                                  : ( MIA_CHECKED) ) );%@NL@%
 %@NL@%
}%@NL@%
%@NL@%
MRESULT EXPENTRY fnwpAboutBoxDlg(hDlg, msg, mp1, mp2)%@NL@%
%@AB@%/*%@NL@%
%@AB@%    About... dialog procedure%@NL@%
%@AB@%*/%@AE@%%@NL@%
HWND        hDlg;%@NL@%
USHORT        msg;%@NL@%
MPARAM        mp1;%@NL@%
MPARAM        mp2;%@NL@%
{%@NL@%
    switch(msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case DID_OK: WinDismissDlg(hDlg, TRUE); break;%@NL@%
                default: break;%@NL@%
            }%@NL@%
        default: return WinDefDlgProc(hDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DMGDB.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\DMGDB.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name: DMGDB.C%@NL@%
%@AB@%*%@NL@%
%@AB@%* DDE manager data handling routines%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created: 12/14/88 Sanford Staab%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@AI@%#include %@AE@%"ddemlp.h" %@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* PAPPINFO GetCurrentAppInfo()%@NL@%
%@AB@%*%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%* This routine uses the pid of the current thread to locate the information%@NL@%
%@AB@%* pertaining to that thread.  If not found, 0 is returned.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This call fails if the DLL is in a callback state to prevent recursion.%@NL@%
%@AB@%* if fChkCallback is set.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/1/89  Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PAPPINFO GetCurrentAppInfo(fChkCallback)%@NL@%
BOOL fChkCallback;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    SemEnter();%@NL@%
    if (pAppInfoList == NULL || !CheckSel(SELECTOROF(pAppInfoList))) {%@NL@%
        SemLeave();%@NL@%
        return(0);%@NL@%
    }%@NL@%
    pai = pAppInfoList;%@NL@%
    while (pai) {%@NL@%
        if (pai->pid == FSRSemDmg.pid && pai->tid == FSRSemDmg.tid) {%@NL@%
            if (fChkCallback && pai->cInCallback > MAX_RECURSE) {%@NL@%
                pai->LastError = DMGERR_REENTRANCY;%@NL@%
                break;%@NL@%
            } else {%@NL@%
                SemLeave();%@NL@%
                return(pai);%@NL@%
            }%@NL@%
        }%@NL@%
        pai = pai->next;%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* void UnlinkAppInfo(pai)%@NL@%
%@AB@%* PAPPINFO pai;%@NL@%
%@AB@%*%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   unlinks an pai safely.  Does nothing if not linked.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/1/89  Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void UnlinkAppInfo(pai)%@NL@%
PAPPINFO pai;%@NL@%
{%@NL@%
    PAPPINFO paiT;%@NL@%
%@NL@%
    AssertF(pai != NULL, "UnlinkAppInfo - NULL input");%@NL@%
    SemEnter();%@NL@%
    if (pai == pAppInfoList) {%@NL@%
        pAppInfoList = pai->next;%@NL@%
        SemLeave();%@NL@%
        return;%@NL@%
    }%@NL@%
    paiT = pAppInfoList;%@NL@%
    while (paiT && paiT->next != pai)%@NL@%
        paiT = paiT->next;%@NL@%
    if (paiT)%@NL@%
        paiT->next = pai->next;%@NL@%
    SemLeave();%@NL@%
    return;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Functions ***************************\%@NL@%
%@AB@%* General List management functions.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/15/88    sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PLST CreateLst(hheap, cbItem)%@NL@%
HHEAP hheap;%@NL@%
USHORT cbItem;%@NL@%
{%@NL@%
    PLST pLst;%@NL@%
%@NL@%
    SemEnter();%@NL@%
    if (!(pLst = (PLST)FarAllocMem(hheap, sizeof(LST)))) {%@NL@%
        SemLeave();%@NL@%
        return(NULL);%@NL@%
    }%@NL@%
    pLst->hheap = hheap;%@NL@%
    pLst->cbItem = cbItem;%@NL@%
    pLst->pItemFirst = (PLITEM)NULL;%@NL@%
    SemLeave();%@NL@%
    return(pLst);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
void FlushLst(pLst)%@NL@%
PLST pLst;%@NL@%
{%@NL@%
    if (pLst == NULL)%@NL@%
        return;%@NL@%
    SemEnter();%@NL@%
    while (pLst->pItemFirst) %@NL@%
        RemoveLstItem(pLst, pLst->pItemFirst);%@NL@%
    SemLeave();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
void DestroyLst(pLst)%@NL@%
PLST pLst;%@NL@%
{%@NL@%
    if (pLst == NULL)%@NL@%
        return;%@NL@%
    SemEnter();%@NL@%
    while (pLst->pItemFirst) %@NL@%
        RemoveLstItem(pLst, pLst->pItemFirst);%@NL@%
    FarFreeMem(pLst->hheap, pLst, sizeof(LST));%@NL@%
    SemLeave();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
PLITEM FindLstItem(pLst, npfnCmp, piSearch)%@NL@%
PLST pLst;%@NL@%
NPFNCMP npfnCmp;%@NL@%
PLITEM piSearch;%@NL@%
{%@NL@%
    PLITEM pi;%@NL@%
%@NL@%
    if (pLst == NULL)%@NL@%
        return(NULL);%@NL@%
    SemEnter();%@NL@%
    pi = pLst->pItemFirst;%@NL@%
    while (pi) {%@NL@%
        if ((*npfnCmp)%@NL@%
                ((PBYTE)pi + sizeof(LITEM), (PBYTE)piSearch + sizeof(LITEM))) {%@NL@%
            SemLeave();%@NL@%
            return(pi);%@NL@%
        }%@NL@%
        pi = pi->next;%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Comparison functions for FindLstItem() and FindPileItem()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
BOOL CmpULONG(pb1, pb2)%@NL@%
PBYTE pb1;%@NL@%
PBYTE pb2;%@NL@%
{%@NL@%
    return(*(PULONG)pb1 == *(PULONG)pb2);%@NL@%
}%@NL@%
%@NL@%
BOOL CmppHsz(pb1, pb2)%@NL@%
PBYTE pb1;%@NL@%
PBYTE pb2;%@NL@%
{%@NL@%
    return(CmpHsz(*(PHSZ)pb1, *(PHSZ)pb2) ? FALSE : TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine creates a new list item for pLst and links it in according%@NL@%
%@AB@%* to the ILST_ constant in afCmd.  Returns a pointer to the new item%@NL@%
%@AB@%* or NULL on failure.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Note:  This MUST be in the semaphore for use since the new list item%@NL@%
%@AB@%* is filled with garbage on return yet is linked in.  %@NL@%
%@AB@%* %@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PLITEM NewLstItem(pLst, afCmd)%@NL@%
PLST pLst;%@NL@%
USHORT afCmd;%@NL@%
{%@NL@%
    PLITEM pi, piT;%@NL@%
%@NL@%
    if (pLst == NULL)%@NL@%
        return(NULL);%@NL@%
    SemCheckIn();%@NL@%
    %@NL@%
    pi = (PLITEM)FarAllocMem(pLst->hheap, pLst->cbItem + sizeof(LITEM));%@NL@%
    if (pi == NULL) {%@NL@%
        AssertF(FALSE, "NewLstItem - memory failure");    %@NL@%
        return(NULL);%@NL@%
    }%@NL@%
%@NL@%
    if (afCmd & ILST_NOLINK) %@NL@%
        return(pi);%@NL@%
        %@NL@%
    if (((piT = pLst->pItemFirst) == NULL) || (afCmd & ILST_FIRST)) {%@NL@%
        pi->next = piT;%@NL@%
        pLst->pItemFirst = pi;%@NL@%
    } else {                            %@AB@%/* ILST_LAST assumed */%@AE@%%@NL@%
        while (piT->next != NULL) %@NL@%
            piT = piT->next;%@NL@%
        piT->next = pi;%@NL@%
        pi->next = NULL;%@NL@%
    }%@NL@%
    return(pi);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine unlinks and frees pi from pLst.  If pi cannot be located%@NL@%
%@AB@%* within pLst, it is freed anyway.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL RemoveLstItem(pLst, pi)%@NL@%
PLST pLst;%@NL@%
PLITEM pi;%@NL@%
{%@NL@%
    PLITEM piT;%@NL@%
%@NL@%
    if (pLst == NULL || pi == NULL)%@NL@%
        return(FALSE);%@NL@%
        %@NL@%
    SemCheckIn();%@NL@%
    %@NL@%
    if ((piT = pLst->pItemFirst) != NULL) {%@NL@%
        if (pi == piT) {%@NL@%
            pLst->pItemFirst = pi->next;%@NL@%
        } else {%@NL@%
            while (piT->next != pi && piT->next != NULL)%@NL@%
                piT = piT->next;%@NL@%
            if (piT->next != NULL)%@NL@%
                piT->next = pi->next; %@AB@%/* unlink */%@AE@%%@NL@%
        }%@NL@%
    } else {%@NL@%
        AssertF(pi == NULL, "Improper list item removal");%@NL@%
    }%@NL@%
    FarFreeMem(pLst->hheap, pi, pLst->cbItem + sizeof(LITEM));%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine uses ILST_ constants to insert a list item into the apropriate%@NL@%
%@AB@%* spot of the pLst given.  Only ILST_FIRST or ILST_LAST are allowed.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/11/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL InsertLstItem(pLst, pi, afCmd)%@NL@%
PLST pLst;%@NL@%
PLITEM pi;%@NL@%
USHORT afCmd;%@NL@%
{%@NL@%
    PLITEM piT;%@NL@%
%@NL@%
    if (pLst == NULL)%@NL@%
        return(FALSE);%@NL@%
        %@NL@%
    SemEnter();%@NL@%
    %@NL@%
    if (pLst->pItemFirst == NULL || afCmd & ILST_FIRST) {%@NL@%
        pi->next = pLst->pItemFirst;%@NL@%
        pLst->pItemFirst = pi;%@NL@%
    } else {                    %@AB@%/* ILST_LAST assumed */%@AE@%%@NL@%
        piT = pLst->pItemFirst;%@NL@%
        while (piT->next) %@NL@%
            piT = piT->next;%@NL@%
        piT->next = pi;%@NL@%
        pi->next = NULL;%@NL@%
    }%@NL@%
    %@NL@%
    SemLeave();%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * ------------- Specific list routines -------------%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This function is HIGHLY dependent on the ADVLI structure.%@NL@%
%@AB@% * This will match an exact hsz/fmt pair with a 0 format being wild.%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL CmpAdv(pb1, pb2)%@NL@%
PBYTE pb1;%@NL@%
PBYTE pb2;%@NL@%
{%@NL@%
    USHORT usFmt;%@NL@%
    %@NL@%
    if (*(PHSZ)pb1 == *(PHSZ)pb2) {%@NL@%
        if ((usFmt = *(PUSHORT)(pb2 + 4)) == 0)%@NL@%
            return(TRUE);%@NL@%
        if (usFmt == *(PUSHORT)(pb1 + 4))%@NL@%
            return(TRUE);%@NL@%
    }%@NL@%
    return(FALSE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
BOOL fSearchHwndList(pLst, hwnd)%@NL@%
PLST pLst;%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    HWNDLI hwndi;%@NL@%
%@NL@%
    hwndi.hwnd = hwnd;%@NL@%
    return((BOOL)FindLstItem(pLst, CmpHwnd, (PLITEM)&hwndi));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
void AddHwndList(hwnd, pLst)%@NL@%
HWND hwnd;%@NL@%
PLST pLst;%@NL@%
{%@NL@%
    HWNDLI hwndli;%@NL@%
    PHWNDLI pli;%@NL@%
%@NL@%
    AssertF(pLst != NULL, "AddHwndList - NULL pLst");%@NL@%
    AssertF(pLst->cbItem == sizeof(HWNDLI), "AddHwndList - Bad item size");%@NL@%
    SemEnter();%@NL@%
    hwndli.hwnd = hwnd;%@NL@%
    if ((hwnd == NULL) || FindLstItem(pLst, CmpHwnd, (PLITEM)&hwndli)) {%@NL@%
        SemLeave();%@NL@%
        return;%@NL@%
    }%@NL@%
    pli = (PHWNDLI)NewLstItem(pLst, ILST_FIRST);%@NL@%
    pli->hwnd = hwnd;%@NL@%
    SemLeave();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Insert the given data into the list if one does not already exist%@NL@%
%@AB@% * under the given hwnd.%@NL@%
%@AB@% */%@AE@%%@NL@%
void AddAckHwndList(hwnd, hszApp, hszTopic, pLst)%@NL@%
HWND hwnd;%@NL@%
HSZ hszApp;%@NL@%
HSZ hszTopic;%@NL@%
PLST pLst;%@NL@%
{%@NL@%
    HWNDLI hwndli;%@NL@%
    PACKHWNDLI pli;%@NL@%
%@NL@%
    AssertF(pLst != NULL, "AddAckHwndList - NULL pLst");%@NL@%
    AssertF(pLst->cbItem == sizeof(ACKHWNDLI), "AddAckHwndList - Bad item size");%@NL@%
    SemEnter();%@NL@%
    hwndli.hwnd = hwnd;%@NL@%
    if ((hwnd == NULL) || FindLstItem(pLst, CmpHwnd, (PLITEM)&hwndli)) {%@NL@%
        SemLeave();%@NL@%
        return;%@NL@%
    }%@NL@%
    pli = (PACKHWNDLI)NewLstItem(pLst, ILST_FIRST);%@NL@%
    pli->hwnd = hwnd;%@NL@%
    pli->hszApp = hszApp;%@NL@%
    pli->hszTopic = hszTopic;%@NL@%
    SemLeave();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* hwnd-hsz list functions%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/20/89     Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void AddHwndHszList(hsz, hwnd, pLst)%@NL@%
HSZ hsz;%@NL@%
HWND hwnd;%@NL@%
PLST pLst;%@NL@%
{%@NL@%
    PHWNDHSZLI phhi;%@NL@%
%@NL@%
    AssertF(pLst->cbItem == sizeof(HWNDHSZLI), "AddHwndHszList - Bad item size");%@NL@%
    SemEnter();%@NL@%
    if ((hsz == NULL) || (BOOL)HwndFromHsz(hsz, pLst)) {%@NL@%
        SemLeave();%@NL@%
        return;%@NL@%
    }%@NL@%
    phhi = (PHWNDHSZLI)NewLstItem(pLst, ILST_FIRST);%@NL@%
    phhi->hwnd = hwnd;%@NL@%
    phhi->hsz = hsz;%@NL@%
    IncHszCount(hsz);%@NL@%
    SemLeave();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void DestroyHwndHszList(pLst)%@NL@%
PLST pLst;%@NL@%
{%@NL@%
    AssertF(pLst->cbItem == sizeof(HWNDHSZLI), "DestroyHwndHszList - Bad item size");%@NL@%
    SemEnter();%@NL@%
    while(pLst->pItemFirst) {%@NL@%
        FreeHsz(((PHWNDHSZLI)pLst->pItemFirst)->hsz);%@NL@%
        RemoveLstItem(pLst, pLst->pItemFirst);%@NL@%
    }%@NL@%
    FarFreeMem(pLst->hheap, pLst, sizeof(LST));%@NL@%
    SemLeave();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
HWND HwndFromHsz(hsz, pLst)%@NL@%
HSZ hsz;%@NL@%
PLST pLst;%@NL@%
{%@NL@%
    HWNDHSZLI hhli;%@NL@%
    PHWNDHSZLI phhli;%@NL@%
%@NL@%
    hhli.hsz = hsz;%@NL@%
    if (!(phhli = (PHWNDHSZLI)FindLstItem(pLst, CmppHsz, (PLITEM)&hhli)))%@NL@%
        return(NULL);%@NL@%
    return(phhli->hwnd);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   Advise list helper functions.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/20/89     Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL AddAdvList(pLst, hszItem, fsStatus, usFmt)%@NL@%
PLST pLst;%@NL@%
HSZ hszItem;%@NL@%
USHORT fsStatus;%@NL@%
USHORT usFmt;%@NL@%
{%@NL@%
    PADVLI pali;%@NL@%
%@NL@%
    AssertF(pLst->cbItem == sizeof(ADVLI), "AddAdvList - bad item size");%@NL@%
    if (hszItem == NULL) %@NL@%
        return(TRUE);%@NL@%
    SemEnter();%@NL@%
    if (!(pali = FindAdvList(pLst, hszItem, usFmt))) {%@NL@%
        IncHszCount(hszItem);%@NL@%
        pali = (PADVLI)NewLstItem(pLst, ILST_FIRST);%@NL@%
    }%@NL@%
    AssertF((BOOL)pali, "AddAdvList - NewLstItem() failed")%@NL@%
    if (pali != NULL) {%@NL@%
        pali->hszItem = hszItem;%@NL@%
        pali->usFmt = usFmt;%@NL@%
        pali->fsStatus = fsStatus;%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    return((BOOL)pali);    %@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This will delete the matching Advise loop entry.  If usFmt is 0, all%@NL@%
%@AB@% * entries with the same hszItem are deleted.  Returns fNotEmptyAfterDelete.%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL DeleteAdvList(pLst, hszItem, usFmt)%@NL@%
PLST pLst;%@NL@%
HSZ hszItem;%@NL@%
USHORT usFmt;%@NL@%
{%@NL@%
    PADVLI pali;%@NL@%
%@NL@%
    if (hszItem == NULL) %@NL@%
        return((BOOL)pLst->pItemFirst);%@NL@%
    SemEnter();%@NL@%
    while (pali = (PADVLI)FindAdvList(pLst, hszItem, usFmt)) {%@NL@%
        FreeHsz((pali)->hszItem);%@NL@%
        RemoveLstItem(pLst, (PLITEM)pali);%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    return((BOOL)pLst->pItemFirst);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine searches the advise list for and entry in hszItem.  It returns%@NL@%
%@AB@%* pAdvli only if the item is found.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PADVLI FindAdvList(pLst, hszItem, usFmt)%@NL@%
PLST pLst;%@NL@%
HSZ hszItem;%@NL@%
USHORT usFmt;%@NL@%
{%@NL@%
    ADVLI advli;%@NL@%
%@NL@%
    advli.hszItem = hszItem;%@NL@%
    advli.usFmt = usFmt;%@NL@%
    return((PADVLI)FindLstItem(pLst, CmpAdv, (PLITEM)&advli));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine searches for the next entry for hszItem.  It returns%@NL@%
%@AB@%* pAdvli only if the item is found.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     11/15/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PADVLI FindNextAdv(padvli, hszItem)%@NL@%
PADVLI padvli;%@NL@%
HSZ hszItem;%@NL@%
{%@NL@%
    %@NL@%
    SemEnter();%@NL@%
    while ((padvli = (PADVLI)padvli->next) != NULL) {%@NL@%
        if (padvli->hszItem == hszItem) {%@NL@%
            SemLeave();%@NL@%
            return(padvli);%@NL@%
        }%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    return(NULL);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Pile Functions ********************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%*  A pile is a list where each item is an array of subitems.  This allows%@NL@%
%@AB@%*  a more memory efficient method of handling unordered lists.%@NL@%
%@AB@%*%@NL@%
%@AB@%\*****************************************************************************/%@AE@%%@NL@%
%@NL@%
PPILE CreatePile(hheap, cbItem, cItemsPerBlock)%@NL@%
HHEAP hheap;%@NL@%
USHORT cbItem;%@NL@%
USHORT cItemsPerBlock;%@NL@%
{%@NL@%
    PPILE ppile;%@NL@%
%@NL@%
    if (!(ppile = (PPILE)FarAllocMem(hheap, sizeof(PILE)))) {%@NL@%
        SemLeave();%@NL@%
        return(NULL);%@NL@%
    }%@NL@%
    ppile->pBlockFirst = (PLITEM)NULL;%@NL@%
    ppile->hheap = hheap;%@NL@%
    ppile->cbBlock = cbItem * cItemsPerBlock + sizeof(PILEB);%@NL@%
    ppile->cSubItemsMax = cItemsPerBlock;%@NL@%
    ppile->cbSubItem = cbItem;%@NL@%
    return(ppile);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
PPILE DestroyPile(pPile)%@NL@%
PPILE pPile;%@NL@%
{%@NL@%
    if (pPile == NULL)%@NL@%
        return(NULL);%@NL@%
    SemEnter();%@NL@%
    while (pPile->pBlockFirst) %@NL@%
        RemoveLstItem((PLST)pPile, (PLITEM)pPile->pBlockFirst);%@NL@%
    FarFreeMem(pPile->hheap, pPile, sizeof(PILE));%@NL@%
    SemLeave();%@NL@%
    return(NULL);%@NL@%
}%@NL@%
%@NL@%
void FlushPile(pPile)%@NL@%
PPILE pPile;%@NL@%
{%@NL@%
    if (pPile == NULL)%@NL@%
        return;%@NL@%
    SemEnter();%@NL@%
    while (pPile->pBlockFirst) %@NL@%
        RemoveLstItem((PLST)pPile, (PLITEM)pPile->pBlockFirst);%@NL@%
    SemLeave();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
USHORT QPileItemCount(pPile)%@NL@%
PPILE pPile;%@NL@%
{%@NL@%
    register USHORT c;%@NL@%
    PPILEB pBlock;%@NL@%
%@NL@%
    if (pPile == NULL)%@NL@%
        return(0);%@NL@%
%@NL@%
    SemEnter();%@NL@%
    pBlock = pPile->pBlockFirst;%@NL@%
    c = 0;%@NL@%
    while (pBlock) {%@NL@%
        c += pBlock->cItems;%@NL@%
        pBlock = pBlock->next;%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    return(c);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
BOOL CopyPileItems(pPile, pDst)%@NL@%
PPILE pPile;%@NL@%
PBYTE pDst;%@NL@%
{%@NL@%
    PPILEB pBlock;%@NL@%
    %@NL@%
    AssertF(pDst != NULL, "CopyPileItems - NULL destination");%@NL@%
    if (pPile == NULL)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    SemEnter();%@NL@%
    pBlock = pPile->pBlockFirst;%@NL@%
    while (pBlock) {%@NL@%
        CopyBlock((PBYTE)pBlock + sizeof(PILEB), pDst,%@NL@%
                pBlock->cItems * pPile->cbSubItem);%@NL@%
        pDst += pBlock->cItems * pPile->cbSubItem;%@NL@%
        pBlock = pBlock->next;%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Locate and return the pointer to the pile subitem who's key fields match%@NL@%
%@AB@%* pbSearch using npfnCmp to compare the fields.  If pbSearch == NULL, or%@NL@%
%@AB@%* npfnCmp == NULL, the first subitem is returned.%@NL@%
%@AB@%*%@NL@%
%@AB@%* afCmd may be:%@NL@%
%@AB@%* FPI_DELETE - delete the located item%@NL@%
%@AB@%* FPI_COUNT - count number of items that match%@NL@%
%@AB@%* In this case, the returned pointer is not valid.%@NL@%
%@AB@%*%@NL@%
%@AB@%* pppb points to where to store a pointer to the block which contained%@NL@%
%@AB@%* the located item.%@NL@%
%@AB@%*%@NL@%
%@AB@%* if pppb == NULL, it is ignored.%@NL@%
%@AB@%*%@NL@%
%@AB@%* NULL is returned if pbSearch was not found or if the list was empty.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PBYTE FindPileItem(pPile, npfnCmp, pbSearch, afCmd)%@NL@%
PPILE pPile;%@NL@%
NPFNCMP npfnCmp;%@NL@%
PBYTE pbSearch;%@NL@%
USHORT afCmd;%@NL@%
{%@NL@%
    PBYTE pb;%@NL@%
    PPILEB ppbT;%@NL@%
    register int i;%@NL@%
    register int c;%@NL@%
%@NL@%
    if (pPile == NULL)%@NL@%
        return(NULL);%@NL@%
    c = 0;%@NL@%
    SemEnter();%@NL@%
    ppbT = pPile->pBlockFirst;%@NL@%
    while (ppbT) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * for each block...%@NL@%
%@AB@%         */%@AE@%%@NL@%
        for (pb = (PBYTE)ppbT + sizeof(PILEB), i = 0;%@NL@%
                i < ppbT->cItems; pb += pPile->cbSubItem, i++) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * and each item within that block..%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (pbSearch == NULL || npfnCmp == NULL ||%@NL@%
                    (*npfnCmp)(pb, pbSearch)) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * If it matches or we don't care...%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                if (afCmd & FPI_DELETE) {%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                     * remove entire block if this was the last subitem in it.%@NL@%
%@AB@%                     */%@AE@%%@NL@%
                    if (--ppbT->cItems == 0) {%@NL@%
                        RemoveLstItem((PLST)pPile, (PLITEM)ppbT);%@NL@%
                    } else {%@NL@%
                        %@AB@%/*%@NL@%
%@AB@%                         * copy last subitem in the block over the removed item.%@NL@%
%@AB@%                         */%@AE@%%@NL@%
                        CopyBlock((PBYTE)ppbT + sizeof(PILEB) +%@NL@%
                                pPile->cbSubItem * ppbT->cItems,%@NL@%
                                pb, pPile->cbSubItem);%@NL@%
                    }%@NL@%
                }%@NL@%
                if (afCmd & FPI_COUNT) {%@NL@%
                    c++;%@NL@%
                } else {%@NL@%
                    SemLeave();%@NL@%
                    return(pb);%@NL@%
                }%@NL@%
                if (afCmd & FPI_DELETE) {%@NL@%
                    pb = (PBYTE)ppbT + sizeof(PILEB);%@NL@%
                    i = 0;%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
        ppbT = (PPILEB)ppbT->next;%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    return((PBYTE)(ULONG)c);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Places a copy of the subitem pointed to by pb into the first available%@NL@%
%@AB@%* spot in the pile pPile.  If npfnCmp != NULL, the pile is first searched%@NL@%
%@AB@%* for a pb match.  If found, pb replaces the located data but FALSE is%@NL@%
%@AB@%* returned to show that no real addition took place.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL AddPileItem(pPile, pb, npfnCmp)%@NL@%
PPILE pPile;%@NL@%
PBYTE pb;%@NL@%
BOOL (*npfnCmp)(PBYTE pb, PBYTE pbSearch);%@NL@%
{%@NL@%
    PBYTE pbDst;%@NL@%
    PPILEB ppb;%@NL@%
%@NL@%
    if (pPile == NULL)%@NL@%
        return(FALSE);%@NL@%
    SemEnter();%@NL@%
    if (npfnCmp != NULL &&%@NL@%
            (pbDst = FindPileItem(pPile, npfnCmp, pb, 0)) != NULL) {%@NL@%
        CopyBlock(pb, pbDst, pPile->cbSubItem);%@NL@%
        SemLeave();%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    ppb = pPile->pBlockFirst;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * locate a block with room%@NL@%
%@AB@%     */%@AE@%%@NL@%
    while ((ppb != NULL) && ppb->cItems == pPile->cSubItemsMax) {%@NL@%
        ppb = (PPILEB)ppb->next;%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If all full or no blocks, make a new one, link it on the bottom.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (ppb == NULL) {%@NL@%
        if ((ppb = (PPILEB)NewLstItem((PLST)pPile, ILST_LAST)) == NULL) {%@NL@%
            SemLeave();%@NL@%
            return(FALSE);%@NL@%
        }%@NL@%
        ppb->cItems = 0;%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * add the subitem%@NL@%
%@AB@%     */%@AE@%%@NL@%
    CopyBlock(pb, (PBYTE)ppb + sizeof(PILEB) + pPile->cbSubItem * ppb->cItems++,%@NL@%
        pPile->cbSubItem);%@NL@%
     %@NL@%
    SemLeave();%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Fills pb with a copy of the top item's data and removes it from the pile.%@NL@%
%@AB@%* returns FALSE if the pile was empty.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL PopPileSubitem(pPile, pb)%@NL@%
PPILE pPile;%@NL@%
PBYTE pb;%@NL@%
{%@NL@%
    PPILEB ppb;%@NL@%
    PBYTE pSrc;%@NL@%
%@NL@%
    %@NL@%
    if ((pPile == NULL) || ((ppb = pPile->pBlockFirst) == NULL))%@NL@%
        return(FALSE);%@NL@%
        %@NL@%
    SemEnter();%@NL@%
    pSrc = (PBYTE)pPile->pBlockFirst + sizeof(PILEB);%@NL@%
    CopyBlock(pSrc, pb, pPile->cbSubItem);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * remove entire block if this was the last subitem in it.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pPile->pBlockFirst->cItems == 1) {%@NL@%
        RemoveLstItem((PLST)pPile, (PLITEM)pPile->pBlockFirst);%@NL@%
    } else {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * move last item in block to replace copied subitem and decrement%@NL@%
%@AB@%         * subitem count.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        CopyBlock(pSrc + pPile->cbSubItem * --pPile->pBlockFirst->cItems,%@NL@%
                pSrc, pPile->cbSubItem);%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
    %@NL@%
%@NL@%
%@AB@%/***************************** Semaphore Functions *************************\%@NL@%
%@AB@%* SemEnter() and SemLeave() are macros.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/1/89  Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void SemInit()%@NL@%
{%@NL@%
    PBYTE pSem;%@NL@%
    SHORT c;%@NL@%
%@NL@%
    pSem = (PBYTE)&FSRSemDmg;%@NL@%
    c = 0;%@NL@%
    while (c++ < sizeof(DOSFSRSEM)) {%@NL@%
        *pSem++ = 0;%@NL@%
    }%@NL@%
    FSRSemDmg.cb = sizeof(DOSFSRSEM);%@NL@%
}%@NL@%
%@NL@%
%@AI@%#ifdef %@AE@%DEBUG %@NL@%
void SemCheckIn()%@NL@%
{                                                                %@NL@%
    PIDINFO pi;%@NL@%
    BOOL fin;%@NL@%
%@NL@%
    DosGetPID(&pi);%@NL@%
    fin = (FSRSemDmg.cUsage > 0) &&%@NL@%
            (FSRSemDmg.pid == pi.pid) &&%@NL@%
            ((FSRSemDmg.tid == pi.tid) || (FSRSemDmg.tid == -1));%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * !!! NOTE: during exitlists processing, semaphore TIDs are set to -1%@NL@%
%@AB@%     */%@AE@%%@NL@%
    AssertF(fin, "SemCheckIn - Out of Semaphore");%@NL@%
    if (!fin)%@NL@%
        SemEnter();%@NL@%
}%@NL@%
%@NL@%
void SemCheckOut()%@NL@%
{%@NL@%
    PIDINFO pi;%@NL@%
    BOOL fOut;%@NL@%
%@NL@%
    DosGetPID(&pi);%@NL@%
    fOut = FSRSemDmg.cUsage == 0 || FSRSemDmg.pid != pi.pid ||%@NL@%
                FSRSemDmg.tid != pi.tid;%@NL@%
    AssertF(fOut, "SemCheckOut - In Semaphore");%@NL@%
    if (!fOut)%@NL@%
        while (FSRSemDmg.cUsage)%@NL@%
            SemLeave();%@NL@%
        %@NL@%
}%@NL@%
%@AI@%#endif %@AE@%%@NL@%
%@NL@%
%@NL@%
void SemEnter()%@NL@%
{%@NL@%
    DosFSRamSemRequest(&FSRSemDmg, SEM_INDEFINITE_WAIT);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void SemLeave()%@NL@%
{%@NL@%
    DosFSRamSemClear(&FSRSemDmg);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
void EXPENTRY ExlstAbort(usTermCode)%@NL@%
USHORT usTermCode;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
    usTermCode;%@NL@%
    %@NL@%
    SemEnter();     %@AB@%/* get any other processes out of the semaphore */%@AE@%%@NL@%
    if (pai = GetCurrentAppInfo(FALSE)) {%@NL@%
        pai->cInCallback = 0;  %@AB@%/* so Unregister call will work */%@AE@%%@NL@%
        DdeUninitialize();%@NL@%
    } else {%@NL@%
        SemLeave();%@NL@%
        DosExitList(EXLST_REMOVE, (PFNEXITLIST)ExlstAbort);%@NL@%
    }%@NL@%
    DosExitList(EXLST_EXIT, 0);%@NL@%
}%@NL@%
%@NL@%
BOOL CopyHugeBlock(pSrc, pDst, cb)%@NL@%
PBYTE pSrc;%@NL@%
PBYTE pDst;%@NL@%
ULONG cb;%@NL@%
{%@NL@%
    ULONG cFirst;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     *  |____________|   |___________|   |____________|  |____________|%@NL@%
%@AB@%     *     ^src                                 ^%@NL@%
%@AB@%     *%@NL@%
%@AB@%     *  |____________|   |___________|   |____________|  |____________|%@NL@%
%@AB@%     *             ^dst                                   ^%@NL@%
%@AB@%     */%@AE@%%@NL@%
    cFirst = (ULONG)min((~(USHORT)pSrc), (~(USHORT)pDst)) + 1L;%@NL@%
    if (cb < cFirst) {%@NL@%
        CopyBlock(pSrc, pDst, (USHORT)cb);%@NL@%
        return(TRUE);%@NL@%
    }%@NL@%
%@NL@%
    goto copyit;%@NL@%
        %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now at least one of the pointers is on a segment boundry.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    while (cb) {%@NL@%
        cFirst = min(0x10000 - ((USHORT)pSrc | (USHORT)pDst), cb);%@NL@%
copyit:%@NL@%
        if (HIUSHORT(cFirst)) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * special case where pSrc and pDst both are on segment%@NL@%
%@AB@%             * bounds.  Copy half at a time.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             *  |___________|   |____________|  |____________|%@NL@%
%@AB@%             *  ^src                               ^%@NL@%
%@AB@%             *%@NL@%
%@AB@%             *  |___________|   |____________|  |____________|%@NL@%
%@AB@%             *  ^dst                               ^%@NL@%
%@AB@%             */%@AE@%%@NL@%
            cFirst >>= 1;%@NL@%
            CopyBlock(pSrc, pDst, (USHORT)cFirst);%@NL@%
            pSrc += cFirst;%@NL@%
            pDst += cFirst;%@NL@%
            cb -= cFirst;%@NL@%
        }%@NL@%
        CopyBlock(pSrc, pDst, (USHORT)cFirst);%@NL@%
        pSrc = HugeOffset(pSrc, cFirst);%@NL@%
        pDst = HugeOffset(pDst, cFirst);%@NL@%
        cb -= cFirst;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     *  |____________|   |___________|   |____________|  |____________|%@NL@%
%@AB@%     *           ^src                           ^%@NL@%
%@AB@%     *%@NL@%
%@AB@%     *  |____________|   |___________|   |____________|  |____________|%@NL@%
%@AB@%     *                   ^dst                             ^%@NL@%
%@AB@%     */%@AE@%%@NL@%
    }%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* Kills windows but avoids invalid window rips in debugger.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL DestroyWindow(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    if (WinIsWindow(DMGHAB, hwnd))%@NL@%
        return(WinDestroyWindow(hwnd));%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Returns hConv of the window passed in is one of the ddeml windows.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HCONV IsDdeWindow(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    pai = pAppInfoList;%@NL@%
    %@NL@%
    while (pai && WinIsChild(hwnd, pai->hwndDmg)) %@NL@%
        pai = pai->next;%@NL@%
        %@NL@%
    if (pai)%@NL@%
        return((HCONV)hwnd);%@NL@%
    else%@NL@%
        return(0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine only frees a MYDDES segment if this process is not the owner.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void FreeData(%@NL@%
PMYDDES pmyddes,%@NL@%
PAPPINFO pai)%@NL@%
{%@NL@%
    TID tid;%@NL@%
    if (!CheckSel(SELECTOROF(pmyddes)) ||%@NL@%
            (   pmyddes->offszItemName == sizeof(MYDDES) &&%@NL@%
                pmyddes->magic == MYDDESMAGIC &&%@NL@%
                pmyddes->fs & HDATA_APPOWNED &&%@NL@%
                pmyddes->pai == pai) )%@NL@%
        return;%@NL@%
%@NL@%
    SemEnter();%@NL@%
    FindPileItem(pai->pHDataPile, CmpULONG, (PBYTE)&pmyddes, FPI_DELETE);%@NL@%
    tid = pai->tid;%@NL@%
    do {%@NL@%
        if (FindPileItem(pai->pHDataPile, CmpULONG, (PBYTE)&pmyddes, FPI_COUNT)) {%@NL@%
            SemLeave();%@NL@%
            return;%@NL@%
        }%@NL@%
        pai = pai->nextThread;%@NL@%
    } while (pai && pai->tid != tid);%@NL@%
    SemLeave();%@NL@%
    DosFreeSeg(SELECTOROF(pmyddes));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AI@%#ifdef %@AE@%DEBUG %@NL@%
int APIENTRY DebugOutput(PCH);%@NL@%
void fAssert(f, pszComment, line, szfile)%@NL@%
BOOL f;%@NL@%
PSZ pszComment;%@NL@%
USHORT line;%@NL@%
PSZ szfile;%@NL@%
{%@NL@%
    char szT[90];%@NL@%
    PSZ psz, pszLast;%@NL@%
%@NL@%
    if (!f) {%@NL@%
        szT[0] = '\000';%@NL@%
        psz = szT;%@NL@%
        pszLast = &szT[89];%@NL@%
        psz = lstrcat(psz, "\n\rAssertion failure: ", pszLast);%@NL@%
        psz = lstrcat(psz, szfile, pszLast);%@NL@%
        psz = lstrcat(psz, ":", pszLast);%@NL@%
        psz = dtoa(psz, line, FALSE);%@NL@%
        psz = lstrcat(psz, " ", pszLast);%@NL@%
        psz = lstrcat(psz, pszComment, pszLast);%@NL@%
        psz = lstrcat(psz, "\n\r", pszLast);%@NL@%
        DebugOutput(szT);%@NL@%
        DebugBreak(); %@NL@%
    }%@NL@%
}%@NL@%
%@AI@%#endif %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
HDMGDATA PutData(pSrc, cb, cbOff, hszItem, usFmt, afCmd, pai)%@NL@%
PBYTE pSrc;%@NL@%
ULONG cb;%@NL@%
ULONG cbOff;%@NL@%
HSZ hszItem;%@NL@%
USHORT usFmt;%@NL@%
USHORT afCmd;%@NL@%
PAPPINFO pai;%@NL@%
{%@NL@%
    PMYDDES pmyddes;%@NL@%
    %@NL@%
    if ((pmyddes = (PMYDDES)AllocDDESel(0, usFmt, hszItem, cb + cbOff, pai))%@NL@%
            == NULL) {%@NL@%
        pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
        return(0L);%@NL@%
    }%@NL@%
    pmyddes->fs = afCmd;%@NL@%
    %@NL@%
    if (afCmd & HDATA_APPFREEABLE) {%@NL@%
        if (!AddPileItem(pai->pHDataPile, (PBYTE)&pmyddes, CmpULONG)) {%@NL@%
            DosFreeSeg(SELECTOROF(pmyddes));%@NL@%
            pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
            return(0L);%@NL@%
        } %@NL@%
    }%@NL@%
    if (pSrc)%@NL@%
        CopyHugeBlock(pSrc, HugeOffset(DDES_PABDATA(pmyddes), cbOff), cb);%@NL@%
    return(pmyddes);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This routine adds all HSZ/HAPP pairs it finds for the given pai matching%@NL@%
%@AB@% * hszApp to hDataAdd.%@NL@%
%@AB@% * poffAdd is the offset into the hDataAdd to start inserting HSZ/HAPP%@NL@%
%@AB@% * pairs.  It then truncates the list with a 0 HSZ and returns the offset%@NL@%
%@AB@% * to the terminator (ready to be called again to add more).%@NL@%
%@AB@% *%@NL@%
%@AB@% * returns 0L on error.%@NL@%
%@AB@% */%@AE@%%@NL@%
ULONG%@NL@%
QueryAppNames(%@NL@%
PAPPINFO pai,%@NL@%
HDMGDATA hDataAdd,%@NL@%
HSZ hszApp,%@NL@%
ULONG offAdd)%@NL@%
{%@NL@%
    USHORT chsz;%@NL@%
    PHSZ phsz, phszPile;%@NL@%
    PPILEB pBlock;%@NL@%
%@NL@%
    AssertF(sizeof(HSZ) == sizeof(HAPP), "Type size conflict");%@NL@%
        %@NL@%
    SemEnter();%@NL@%
    if (chsz = (USHORT)FindPileItem(pai->pAppNamePile,%@NL@%
            hszApp ? CmpULONG : NULL, (PBYTE)&hszApp, FPI_COUNT)) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * allocate for additions.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (!DdeAddData(hDataAdd, NULL,%@NL@%
                (chsz + 1L) * (sizeof(HSZ) + sizeof(HDMGDATA)), offAdd)) {%@NL@%
            offAdd = 0L;%@NL@%
            GetCurrentAppInfo(FALSE)->LastError = DMGERR_MEMORY_ERROR;%@NL@%
            goto Exit;%@NL@%
        }%@NL@%
        %@NL@%
        phsz = DDES_PABDATA((PDDESTRUCT)hDataAdd) + offAdd;%@NL@%
        if (hszApp) {%@NL@%
            *phsz++ = hszApp;       %@AB@%/* only one per thread expected */%@AE@%%@NL@%
            *phsz++ = (HSZ)pai->hwndFrame;%@NL@%
        } else {%@NL@%
            pBlock = pai->pAppNamePile->pBlockFirst;%@NL@%
            while (pBlock) {%@NL@%
                phszPile = (PHSZ)(pBlock + 1);%@NL@%
                for (chsz = 0; chsz < pBlock->cItems; chsz++) {%@NL@%
                    *(phsz++) = *(phszPile++);%@NL@%
                    *(phsz++) = (HSZ)pai->hwndFrame;%@NL@%
                }%@NL@%
                pBlock = pBlock->next;%@NL@%
            }%@NL@%
        }%@NL@%
        *phsz = 0L;%@NL@%
        offAdd = phsz - DDES_PABDATA((PDDESTRUCT)hDataAdd);%@NL@%
    }%@NL@%
Exit:    %@NL@%
    SemLeave();%@NL@%
    return(offAdd);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DMGDDE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\DMGDDE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name: DMGDDE.C%@NL@%
%@AB@%*%@NL@%
%@AB@%* This module contains functions used for interfacing with DDE structures%@NL@%
%@AB@%* and such.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created:  12/23/88    sanfords%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@AI@%#include %@AE@%"ddemlp.h" %@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* timeout()%@NL@%
%@AB@%*%@NL@%
%@AB@%* This routine creates a timer for hwndTimeout.  It then runs a modal loop%@NL@%
%@AB@%* which will exit once the WM_TIMER message is received by hwndTimeout.%@NL@%
%@AB@%* hwndTimeout can be any window that doesn't use timers itself with TID_TIMEOUT%@NL@%
%@AB@%* or TID_ABORT since its window proc doesn't need to do%@NL@%
%@AB@%* anything for this to work.  Only the client and server windows use these%@NL@%
%@AB@%* so were cool.%@NL@%
%@AB@%* Only one timeout window is allowed per thread.  This is checked by the%@NL@%
%@AB@%* pai passed in.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns fSuccess, ie TRUE if TID_TIMEOUT was received before TID_ABORT.%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%* Synchronous client transaction modal loops:%@NL@%
%@AB@%*%@NL@%
%@AB@%* During Synchronous transactions, a client application will enter a modal%@NL@%
%@AB@%* loop while waiting for the server to respond to the request.  If an%@NL@%
%@AB@%* application wishes to filter messages to the modal loop, it may do so%@NL@%
%@AB@%* by setting a message filter tied to MSGF_DDE.  Applications should%@NL@%
%@AB@%* be aware however that the DDE modal loop processes private messages%@NL@%
%@AB@%* in the WM_USER range, WM_DDE messages, and WM_TIMER messages with timer IDs%@NL@%
%@AB@%* using the TID_ constants defined in ddeml.h.%@NL@%
%@AB@%* These messages must not be filtered by an application!!!%@NL@%
%@AB@%*%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     sanfords    12/19/88%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL timeout(pai, ulTimeout, hwndTimeout)%@NL@%
PAPPINFO pai;%@NL@%
ULONG ulTimeout;%@NL@%
HWND hwndTimeout;%@NL@%
{%@NL@%
    QMSG qmsg;%@NL@%
%@NL@%
    SemEnter();%@NL@%
    if (pai->hwndTimer) {%@NL@%
        pai->LastError = DMGERR_REENTRANCY;%@NL@%
        AssertF(FALSE, "Recursive timeout call");%@NL@%
        SemLeave();%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    pai->hwndTimer = hwndTimeout;%@NL@%
    SemLeave();%@NL@%
%@NL@%
    WinStartTimer(DMGHAB, hwndTimeout, TID_TIMEOUT, (USHORT)ulTimeout);%@NL@%
%@NL@%
    WinGetMsg(DMGHAB, &qmsg, (HWND)NULL, 0, 0);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * stay in modal loop until a timeout happens.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    while (qmsg.hwnd != hwndTimeout ||%@NL@%
            qmsg.msg != WM_TIMER ||%@NL@%
            (LOUSHORT(qmsg.mp1) != TID_TIMEOUT &&%@NL@%
            LOUSHORT(qmsg.mp1) != TID_ABORT)) {%@NL@%
            %@NL@%
        if (!WinCallMsgFilter(DMGHAB, &qmsg, MSGF_DDE))%@NL@%
            WinDispatchMsg(DMGHAB, &qmsg);%@NL@%
            %@NL@%
        WinGetMsg(DMGHAB, &qmsg, (HWND)NULL, 0, 0);%@NL@%
    }%@NL@%
    %@NL@%
    WinStopTimer(DMGHAB, hwndTimeout, TID_TIMEOUT);%@NL@%
    SemEnter();%@NL@%
    pai->hwndTimer = 0;%@NL@%
    SemLeave();%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * post a callback check incase we blocked callbacks due to being%@NL@%
%@AB@%     * in a timeout.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinPostMsg(pai->hwndDmg, UM_CHECKCBQ, (MPARAM)pai, 0L);%@NL@%
    return(LOUSHORT(qmsg.mp1) == TID_TIMEOUT);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Based on pii, this sends an INITIATE message to either an exact%@NL@%
%@AB@%*  target window (hwndSend), a target frame window (hwndFrame) or to all%@NL@%
%@AB@%*  top level frames (both hwnds are NULL).  It fills in pci info as apropriate.%@NL@%
%@AB@%*  Note that pii->pCC must NOT be NULL and is assumed to be properly set.%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Returns FALSE if SendDDEInit failed.%@NL@%
%@AB@%*  On success pci->ci.xad.state is CONVST_CONNECTED.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   created 12/21/88        sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL ClientInitiate(hwnd, pii, pci)%@NL@%
HWND hwnd;%@NL@%
PINITINFO pii;%@NL@%
PCLIENTINFO pci;%@NL@%
{%@NL@%
    BOOL fRet = TRUE;%@NL@%
%@NL@%
    if (pii->pCC->cb < sizeof(CONVCONTEXT))%@NL@%
        return(FALSE);%@NL@%
        %@NL@%
    SemEnter();%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * we need to set this info BEFORE we do the synchronous initiate%@NL@%
%@AB@%     * so the INITIATEACK msg is done correctly.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    pci->ci.xad.state = CONVST_INIT1;%@NL@%
    pci->ci.xad.LastError = DMGERR_NO_ERROR;%@NL@%
    pci->ci.hszServerApp = pii->hszAppName;%@NL@%
    pci->ci.hszTopic = pii->hszTopic;%@NL@%
    pci->ci.cc.cb = sizeof(CONVCONTEXT);%@NL@%
    CopyBlock((PBYTE)&pii->pCC->fsContext, (PBYTE)&pci->ci.cc.fsContext,%@NL@%
        sizeof(CONVCONTEXT) - sizeof(USHORT));%@NL@%
    pci->ci.hwndFrame = pii->hwndFrame;%@NL@%
    SemLeave();%@NL@%
    %@NL@%
    fRet = SendDDEInit(hwnd,%@NL@%
            WinIsWindow(DMGHAB, pii->hwndSend) ? pii->hwndSend : pii->hwndFrame,%@NL@%
            pci);%@NL@%
    SemEnter();%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If we failed to initiate directly with the server, try the frame.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!fRet && WinIsWindow(DMGHAB, pii->hwndSend) &&%@NL@%
            WinIsWindow(DMGHAB, pii->hwndFrame)) {%@NL@%
        SemLeave();%@NL@%
        fRet = SendDDEInit(hwnd, pii->hwndFrame, pci);%@NL@%
        if (fRet) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * OK, client is locked in so he wont go away on a terminate%@NL@%
%@AB@%             * from a random window. If the new server is not the same%@NL@%
%@AB@%             * window as the origonal, send it a terminate so it can%@NL@%
%@AB@%             * go away nicely.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (pii->hwndSend != pci->ci.hwndPartner) %@NL@%
                WinSendMsg(pii->hwndSend, WM_DDE_TERMINATE, 0L, 0L);%@NL@%
        }%@NL@%
        SemEnter();%@NL@%
        %@NL@%
    }%@NL@%
    if (!fRet) %@NL@%
        pci->ci.xad.state = CONVST_NULL;%@NL@%
    else {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * successful initiate means we want to keep these around awhile.%@NL@%
%@AB@%         * removed at window closing time.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        IncHszCount(pci->ci.hszServerApp);%@NL@%
        IncHszCount(pci->ci.hszTopic);%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    return(fRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Allocates and sends a WM_DDE_INITIATE message to hwndTo.  Any failures%@NL@%
%@AB@%* cause FALSE to be returned.  If hwndTo is NULL, performs equivalent of%@NL@%
%@AB@%* WinDdeInitiate2().%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   created     12/22/88        sanfords%@NL@%
%@AB@%*   2/2/89  sanfords    added SEG_GETABLE during monitoring.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL SendDDEInit(hwndFrom, hwndTo, pci)%@NL@%
HWND hwndFrom;%@NL@%
HWND hwndTo;%@NL@%
PCLIENTINFO pci;%@NL@%
{%@NL@%
    PID pidTo;%@NL@%
    TID tid;%@NL@%
    SEL sel;%@NL@%
    PDDEINIT pddeinit;%@NL@%
    HENUM henum;%@NL@%
    ULONG ul;%@NL@%
    USHORT cchApp, cchTopic;%@NL@%
    PSZ pszApp, pszTopic;%@NL@%
    BOOL fEnumerating;  %@AB@%/* set if extra acks are ok */%@AE@%%@NL@%
%@NL@%
    SemCheckOut();%@NL@%
%@NL@%
    if (hwndTo == NULL) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Call on self for all top level frame windows until we are connected.%@NL@%
%@AB@%         * (if enumerating, do em all anyway.)%@NL@%
%@AB@%         */%@AE@%%@NL@%
        fEnumerating = WinQueryWindow(hwndFrom, QW_PARENT, FALSE) !=%@NL@%
                pci->ci.pai->hwndDmg;%@NL@%
        if (henum = WinBeginEnumWindows(HWND_DESKTOP)) {%@NL@%
            while ((hwndTo = WinGetNextWindow(henum)) &&%@NL@%
                    (fEnumerating || pci->ci.xad.state == CONVST_INIT1)) {%@NL@%
                if (hwndTo != pci->ci.pai->hwndFrame &&%@NL@%
                        (ul = (ULONG)WinSendMsg(hwndTo, WM_QUERYFRAMEINFO, 0L, 0L)) &&%@NL@%
                        (ul & FI_FRAME))%@NL@%
                    SendDDEInit(hwndFrom, hwndTo, pci);%@NL@%
            }%@NL@%
            WinEndEnumWindows(henum);%@NL@%
        }%@NL@%
        return(TRUE);%@NL@%
    }%@NL@%
    %@NL@%
    if (WinQueryWindowProcess(hwndTo, &pidTo, &tid) == NULL)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    SemEnter();%@NL@%
    pszApp = pszFromHsz(pci->ci.hszServerApp, &cchApp);%@NL@%
    pszTopic = pszFromHsz(pci->ci.hszTopic, &cchTopic);%@NL@%
    if (DosAllocSeg(sizeof(DDEINIT) + sizeof(CONVCONTEXT) + cchApp + cchTopic,%@NL@%
                &sel, SEG_GIVEABLE) != 0) {%@NL@%
        SemLeave();%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    pddeinit = MAKEP(sel, 0);%@NL@%
    pddeinit->cb = sizeof(DDEINIT);%@NL@%
    pddeinit->offConvContext = sizeof(DDEINIT);%@NL@%
    pddeinit->pszAppName = (PSZ)pddeinit + sizeof(DDEINIT) + sizeof(CONVCONTEXT);%@NL@%
    pddeinit->pszTopic = pddeinit->pszAppName + cchApp;%@NL@%
    CopyBlock((PBYTE)&pci->ci.cc, (PBYTE)DDEI_PCONVCONTEXT(pddeinit), sizeof(CONVCONTEXT));%@NL@%
    CopyBlock((PBYTE)pszApp, (PBYTE)pddeinit->pszAppName, cchApp);%@NL@%
    CopyBlock((PBYTE)pszTopic, (PBYTE)pddeinit->pszTopic, cchTopic);%@NL@%
    FarFreeMem(hheapDmg, pszApp, cchApp);%@NL@%
    FarFreeMem(hheapDmg, pszTopic, cchTopic);%@NL@%
    SemLeave();%@NL@%
%@NL@%
    if (DosGiveSeg(sel, pidTo, &sel) != 0) {%@NL@%
        DosFreeSeg(sel);%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
%@NL@%
    WinSendMsg(hwndTo, WM_DDE_INITIATE, (MPARAM)hwndFrom, pddeinit);%@NL@%
    if (pidTo != pci->ci.pai->pid)%@NL@%
        DosFreeSeg(sel);%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Alocates and fills in a MYDDES. if pai == 0, the MYDDES is considered%@NL@%
%@AB@%* unowned.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  created     1/4/89  sanfords%@NL@%
%@AB@%* 10/18/89  sanfords Added hack so that if usFmt==DDEFMT_TEXT and hszItem==0L,%@NL@%
%@AB@%*                    the data and item strings are one.%@NL@%
%@AB@%*                    (This allows for excel EXEC compatibility)%@NL@%
%@AB@%*   2/2/89  sanfords Added GETABLE during monitoring.%@NL@%
%@AB@%*  6/13/90  sanfords Altered to not expand hszItem at this point.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PDDESTRUCT AllocDDESel(fsStatus, usFmt, hszItem, cbData, pai)%@NL@%
USHORT fsStatus;%@NL@%
USHORT usFmt;%@NL@%
HSZ hszItem;%@NL@%
ULONG cbData;%@NL@%
PAPPINFO pai;%@NL@%
{%@NL@%
    PMYDDES pmyddes = NULL;%@NL@%
    ULONG cbTotal;%@NL@%
    ULONG cchItem;%@NL@%
    SEL sel;%@NL@%
%@NL@%
    SemEnter();%@NL@%
    cchItem = DdeGetHszString(hszItem, NULL, 0L) + 1L;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * This hack makes execs conform to EXCELs way.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!hszItem && usFmt == DDEFMT_TEXT)%@NL@%
        cchItem = 0L;%@NL@%
%@NL@%
    cbTotal = sizeof(MYDDES) + cchItem + cbData + 1;%@NL@%
    if (cbTotal <= 0xFFFF) {%@NL@%
        if (DosAllocSeg((USHORT)cbTotal, &sel, SEG_GIVEABLE) != 0)%@NL@%
            goto allocDdeExit;%@NL@%
    } else {%@NL@%
        if (DosAllocHuge((USHORT)(cbTotal >> 16), (USHORT)cbTotal, &sel,%@NL@%
                0, SEG_GIVEABLE) != 0)%@NL@%
            goto allocDdeExit;%@NL@%
    }%@NL@%
%@NL@%
    pmyddes = MAKEP(sel, 0);%@NL@%
    pmyddes->cbData = cbData;%@NL@%
    pmyddes->fsStatus = fsStatus;%@NL@%
    pmyddes->usFormat = usFmt;%@NL@%
    pmyddes->offszItemName = sizeof(MYDDES);%@NL@%
    pmyddes->offabData = sizeof(MYDDES) + (USHORT)cchItem;%@NL@%
    pmyddes->ulRes1 = 0L;%@NL@%
    pmyddes->magic = MYDDESMAGIC;%@NL@%
    pmyddes->hszItem = hszItem;%@NL@%
    pmyddes->pai = pai;%@NL@%
    pmyddes->fs = 0;%@NL@%
    *DDES_PABDATA((PDDESTRUCT)pmyddes) = '\0'; %@AB@%/* in case data is never placed */%@AE@%%@NL@%
    *DDES_PSZITEMNAME((PDDESTRUCT)pmyddes) = '\0';  %@AB@%/* we expand this at post time if necessary */%@AE@%%@NL@%
%@NL@%
allocDdeExit:%@NL@%
    SemLeave();%@NL@%
    return((PDDESTRUCT)pmyddes);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine returns the hwnd of a newly created and connected DDE%@NL@%
%@AB@%* client or NULL if failure.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  created     1/6/89  sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HCONV GetDDEClientWindow(hConvList, hwndFrame, hwndSend, hszApp, hszTopic, pCC)%@NL@%
HCONVLIST hConvList;%@NL@%
HWND hwndFrame;%@NL@%
HWND hwndSend;%@NL@%
HSZ hszApp;%@NL@%
HSZ hszTopic;%@NL@%
PCONVCONTEXT pCC;%@NL@%
{%@NL@%
    HCONV hConv;%@NL@%
    INITINFO ii;%@NL@%
    CONVCONTEXT cc;%@NL@%
%@NL@%
    SemCheckOut();%@NL@%
    %@NL@%
    hConv = WinCreateWindow(hConvList, SZCLIENTCLASS, "", 0L,%@NL@%
            0, 0, 0, 0, (HWND)NULL, HWND_TOP, WID_CLIENT, 0L, 0L);%@NL@%
            %@NL@%
    if (hConv == NULL)%@NL@%
        return(NULL);%@NL@%
        %@NL@%
    ii.hszTopic = hszTopic;%@NL@%
    ii.hszAppName = hszApp;%@NL@%
    ii.hwndSend = hwndSend;%@NL@%
    ii.hwndFrame = hwndFrame;%@NL@%
    if (pCC == NULL) {%@NL@%
        pCC = &cc;%@NL@%
        cc.cb = sizeof(CONVCONTEXT);%@NL@%
        cc.fsContext = 0;%@NL@%
        %@AB@%/*##LATER - may want to use process codepage instead */%@AE@%%@NL@%
        cc.usCodepage = syscc.codepage;%@NL@%
        cc.idCountry = syscc.country;%@NL@%
    }%@NL@%
    if (pCC->usCodepage == 0) %@NL@%
        pCC->usCodepage = syscc.codepage;%@NL@%
    if (pCC->idCountry == 0) %@NL@%
        pCC->idCountry = syscc.country;%@NL@%
        %@NL@%
    ii.pCC = pCC;%@NL@%
    WinSendMsg(hConv, UMCL_INITIATE, (MPARAM)&ii, 0L);%@NL@%
    %@NL@%
    if (!((USHORT)WinSendMsg(hConv, UM_QUERY, (MPARAM)Q_STATUS, 0L) &%@NL@%
            ST_CONNECTED)) {%@NL@%
        WinDestroyWindow(hConv);%@NL@%
        return(NULL);%@NL@%
    }%@NL@%
    return(hConv);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine institutes a callback directly if psi->fEnableCB is set%@NL@%
%@AB@%* and calls QReply to complete the transaction,%@NL@%
%@AB@%* otherwise it places the data into the queue for processing.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Since hDmgData may be freed by the app at any time once the callback is%@NL@%
%@AB@%* issued, we cannot depend on it being there for QReply.  Therefore we%@NL@%
%@AB@%* save all the pertinant data in the queue along with it.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns fSuccess.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL MakeCallback(pai, hConv, hszTopic, hszItem, usFmt, usType, hDmgData,%@NL@%
    msg, fsStatus, hConvClient)%@NL@%
PAPPINFO pai;%@NL@%
HCONV hConv;%@NL@%
HSZ hszTopic;%@NL@%
HSZ hszItem;%@NL@%
USHORT usFmt;%@NL@%
USHORT usType;%@NL@%
HDMGDATA hDmgData;%@NL@%
USHORT msg;%@NL@%
USHORT fsStatus;%@NL@%
HCONV hConvClient;%@NL@%
{%@NL@%
    PCBLI pcbli;%@NL@%
%@NL@%
    SemEnter();%@NL@%
    %@NL@%
    if (!(pcbli = (PCBLI)NewLstItem(pai->plstCB, ILST_LAST))) {%@NL@%
        pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
        SemLeave();%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    pcbli->hConv = hConv;%@NL@%
    pcbli->hszTopic = hszTopic;%@NL@%
    pcbli->hszItem = hszItem;%@NL@%
    pcbli->usFmt = usFmt;%@NL@%
    pcbli->usType = usType;%@NL@%
    pcbli->hDmgData = hDmgData;%@NL@%
    pcbli->msg = msg;%@NL@%
    pcbli->fsStatus = fsStatus;%@NL@%
    pcbli->hConvPartner = hConvClient;%@NL@%
    %@NL@%
    if (pai->fEnableCB && !pai->hwndTimer) {%@NL@%
        SemLeave();%@NL@%
        WinPostMsg(pai->hwndDmg, UM_CHECKCBQ, (MPARAM)pai, 0L);%@NL@%
    } else%@NL@%
        SemLeave();%@NL@%
    %@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*************************************************************************\%@NL@%
%@AB@%* Attempts to post a DDE message to hwndTo.  Properly frees up pmyddes%@NL@%
%@AB@%* if afCmd has MDPM_FREEHDATA set.  We do not add pmyddes to the target%@NL@%
%@AB@%* thread list since we assume that will be done at the receiving end%@NL@%
%@AB@%* if necessary.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns fSuccess.%@NL@%
%@AB@%*%@NL@%
%@AB@%* 6/12/90 sanfords  Created%@NL@%
%@AB@%* 6/13/90 sanfords  Made it convert hszItem to a string at this point%@NL@%
%@AB@%*                   only if hwndTo is not a local guy.%@NL@%
%@AB@%\*************************************************************************/%@AE@%%@NL@%
BOOL MyDdePostMsg(%@NL@%
HWND hwndTo,%@NL@%
HWND hwndFrom,%@NL@%
USHORT msg,%@NL@%
PMYDDES pmyddes,%@NL@%
PAPPINFO paiFrom,%@NL@%
USHORT afCmd)%@NL@%
{%@NL@%
    PID pid;%@NL@%
    TID tid;%@NL@%
    SEL selR;%@NL@%
    BOOL fRet;%@NL@%
    PFNWP pfnwpTo;%@NL@%
%@NL@%
    if (!WinQueryWindowProcess(hwndTo, &pid, &tid))%@NL@%
        return FALSE;%@NL@%
%@NL@%
    pfnwpTo = (PFNWP)WinQueryWindowPtr(hwndTo, QWP_PFNWP);%@NL@%
    if (cMonitor || (pfnwpTo != ServerWndProc && pfnwpTo != ClientWndProc)) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * its not local - expand hszItem if necessary - always%@NL@%
%@AB@%         * expand if a monitor is installed.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (CheckSel(SELECTOROF(pmyddes)) >= sizeof(MYDDES) &&%@NL@%
                pmyddes->magic == MYDDESMAGIC &&%@NL@%
                pmyddes->hszItem &&%@NL@%
                !(pmyddes->fs & HDATA_PSZITEMSET)) {%@NL@%
            pmyddes->fs |= HDATA_PSZITEMSET;%@NL@%
            QueryHszName(pmyddes->hszItem, DDES_PSZITEMNAME(pmyddes),%@NL@%
                    pmyddes->offabData - pmyddes->offszItemName);    %@NL@%
        }%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Don't try to share seg with ourselves.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (paiFrom->pid != pid) {%@NL@%
        selR = SELECTOROF(pmyddes);%@NL@%
        if (DosGiveSeg(SELECTOROF(pmyddes), pid, &selR))%@NL@%
            return FALSE;%@NL@%
        if (afCmd & MDPM_FREEHDATA) %@NL@%
            FreeData(pmyddes, paiFrom);%@NL@%
    } else {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * just remove hData from our thread list%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (afCmd & MDPM_FREEHDATA && !(pmyddes->fs & HDATA_APPOWNED))%@NL@%
            FindPileItem(paiFrom->pHDataPile, CmpULONG, (PBYTE)&pmyddes,%@NL@%
                    FPI_DELETE);%@NL@%
    }%@NL@%
    fRet = (BOOL)WinPostMsg(hwndTo, msg, (MPARAM)hwndFrom, (MPARAM)pmyddes);%@NL@%
    if (!fRet) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * make sure this is freed if it is supposed to be - this covers%@NL@%
%@AB@%         * the case where the target is of the same process and only%@NL@%
%@AB@%         * these two threads are registered.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        %@NL@%
        tid = paiFrom->tid;%@NL@%
        do {%@NL@%
            if (FindPileItem(paiFrom->pHDataPile, CmpULONG, (PBYTE)&pmyddes,%@NL@%
                    FPI_COUNT))%@NL@%
                return(FALSE);  %@AB@%/* there is another thread that has this */%@AE@%%@NL@%
            paiFrom = paiFrom->nextThread;%@NL@%
        } while (paiFrom->tid != tid);%@NL@%
        DosFreeSeg(SELECTOROF(pmyddes));%@NL@%
    }%@NL@%
    return(fRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DMGHSZ.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\DMGHSZ.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name: DMGLATOM.C%@NL@%
%@AB@%*%@NL@%
%@AB@%* This module contains functions used for HSZ control.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created:  8/2/88    sanfords%@NL@%
%@AB@%* Added case preservation/insensitive   1/22/90       Sanfords%@NL@%
%@AB@%* 6/12/90 sanfords  Fixed HSZ local string allocation size errors.%@NL@%
%@AB@%*                   Added latom validation checks%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@AI@%#include %@AE@%"ddemlp.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * since the top 12 bits of any latom is always 0 (unless we have > 16%@NL@%
%@AB@% * atom tables!) we can encode any ulong into only 5 bytes.%@NL@%
%@AB@% */%@AE@%%@NL@%
%@AI@%#define %@AE@%ENCODEBYTES         5 %@NL@%
%@AI@%#define %@AE@%MAX_LATOMSTRSIZE    255 - ENCODEBYTES - 2 %@NL@%
char szT[MAX_LATOMSTRSIZE + 1 + ENCODEBYTES];  %@AB@%/* used for HSZ expansion */%@AE@%%@NL@%
%@NL@%
extern BOOL APIENTRY WinSetAtomTableOwner( HATOMTBL, PID );%@NL@%
%@NL@%
%@NL@%
%@AB@%/*********************** LATOM management functions *************************\%@NL@%
%@AB@%* An HSZ is a long atom which holds an encoded reference to two other long%@NL@%
%@AB@%* atoms.  One long atom is for the actual string, the other is for its%@NL@%
%@AB@%* uppercase version.  Two HSZs are ranked by their uppercase latoms.%@NL@%
%@AB@%* This makes HSZs case insensitive, case preserving.  An latom%@NL@%
%@AB@%* is an atom with an atom table index tacked onto the HIUSHORT part of %@NL@%
%@AB@%* of the latom.  Strings too long for the atom manager are split up and%@NL@%
%@AB@%* each piece is prepended with a coded string that represents the%@NL@%
%@AB@%* LATOM of the rest of the string.  LATOM strings thus may be of any length.%@NL@%
%@AB@%* (up to 64K in this version)%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Allocates space in the DDE manager heap for a string queried from the DDE%@NL@%
%@AB@%* manager latomtable.  The case sensitive string is returned.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function should be serialized.  Memory allocation or latom table failure%@NL@%
%@AB@%* results in a 0 return value.%@NL@%
%@AB@%*%@NL@%
%@AB@%* 0 latoms result in a NULL terminated empty string.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Note that *pcch is set to the length of the string INCLUDING the null%@NL@%
%@AB@%* terminator.  This way a wild string has a cch=1.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   created     12/22/88        sanfords%@NL@%
%@AB@%*   11/10/89    sanfords        modified to return '\0' on invalid atom.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PSZ pszFromHsz(hsz, pcch)%@NL@%
HSZ hsz;%@NL@%
USHORT FAR *pcch;%@NL@%
{%@NL@%
    PSZ psz;%@NL@%
    LATOM latom;%@NL@%
    char sz[ENCODEBYTES + 1];%@NL@%
    register USHORT cch;%@NL@%
%@NL@%
    SemCheckIn();%@NL@%
%@NL@%
    if (hsz == 0)%@NL@%
        cch = 1;%@NL@%
    else {%@NL@%
        QuerylatomName((LATOM)hsz, sz, ENCODEBYTES + 1);%@NL@%
        latom = Decode(sz);     %@AB@%/* take origonal case version */%@AE@%%@NL@%
        cch = QuerylatomLength(latom) + 1;%@NL@%
    }%@NL@%
     %@NL@%
    psz = (PSZ)FarAllocMem(hheapDmg, cch);%@NL@%
    if (psz == 0) {%@NL@%
        *pcch = '\000';%@NL@%
        return(0);%@NL@%
    }%@NL@%
%@NL@%
    if (hsz == 0) {%@NL@%
        *pcch = 1;%@NL@%
        *psz = '\0';%@NL@%
    } else {%@NL@%
        *pcch = cch;%@NL@%
        if (QuerylatomName(latom, psz, cch) == 0) {%@NL@%
            AssertF(FALSE, "pszFromHsz - bad latom");%@NL@%
            *psz = '\0';        %@AB@%/* invalid case - never expected */%@AE@%%@NL@%
        }%@NL@%
    }%@NL@%
    return(psz);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* HSZ GetHsz(psz, cc, cp, fAdd)%@NL@%
%@AB@%* PSZ psz;%@NL@%
%@AB@%* USHORT cc;%@NL@%
%@AB@%* USHORT cp;%@NL@%
%@AB@%* BOOL fAdd;%@NL@%
%@AB@%*%@NL@%
%@AB@%* The goal of this routine is to convert a psz to an hsz.  This uses the%@NL@%
%@AB@%* atom manager for its dirty work.  This call has the side effect of%@NL@%
%@AB@%* incrementing the use count for the hsz returned and its associated latoms%@NL@%
%@AB@%* if fAdd is set.%@NL@%
%@AB@%*%@NL@%
%@AB@%* if fAdd is FALSE, NULL is returned if the hsz doesn't exist.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   created     12/23/88    sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HSZ GetHsz(psz, cc, cp, fAdd)%@NL@%
PSZ psz;%@NL@%
USHORT cc;%@NL@%
USHORT cp;%@NL@%
BOOL fAdd;%@NL@%
{%@NL@%
    LATOM latom1, latom2;%@NL@%
    USHORT cb;%@NL@%
    PSZ pszT;%@NL@%
    BOOL fNew = FALSE;%@NL@%
    HSZ hsz;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * NULL or 0 length pszs are considered wild HSZs.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (psz == NULL || *psz == '\0')%@NL@%
        return(0L);%@NL@%
%@NL@%
    SemEnter();%@NL@%
    %@NL@%
    if (!(latom1 = FindAddlatom(psz, fAdd))) {%@NL@%
        AssertF(!fAdd, "GetHsz - Atom Add failed");%@NL@%
        SemLeave();%@NL@%
        return(0L);%@NL@%
    }%@NL@%
        %@NL@%
    cb = lstrlen(psz) + 1;%@NL@%
        %@NL@%
    if (!(pszT = FarAllocMem(hheapDmg, max(cb, ENCODEBYTES * 2 + 1)))) {%@NL@%
        SemLeave();%@NL@%
        return(0L);%@NL@%
    }%@NL@%
    %@NL@%
    CopyBlock((PBYTE)psz, (PBYTE)pszT, cb);%@NL@%
    WinUpper(DMGHAB, cp ? cp : syscc.codepage, cc ? cc : syscc.country, pszT);%@NL@%
    latom2 = FindAddlatom(pszT, fAdd);%@NL@%
%@NL@%
    if (!latom2) {%@NL@%
        AssertF(!fAdd, "GetHsz - Atom Add(2) failed");%@NL@%
        hsz = 0;%@NL@%
    } else {%@NL@%
        *Encode(latom2, Encode(latom1, pszT)) = '\000';%@NL@%
        hsz = (HSZ)FindAddlatom(pszT, fAdd);%@NL@%
    }%@NL@%
    FarFreeMem(hheapDmg, pszT, max(cb, ENCODEBYTES * 2 + 1));%@NL@%
    SemLeave();%@NL@%
    return(hsz);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Note that all three associated latoms are freed.%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL FreeHsz(hsz)%@NL@%
HSZ hsz;%@NL@%
{%@NL@%
    char sz[ENCODEBYTES * 2 + 1];%@NL@%
%@NL@%
    SemEnter();    %@NL@%
    if (hsz && QuerylatomName((LATOM)hsz, sz, ENCODEBYTES * 2 + 1)) {%@NL@%
        Freelatom(Decode((PBYTE)sz));%@NL@%
        Freelatom(Decode((PBYTE)&sz[ENCODEBYTES]));%@NL@%
        Freelatom((LATOM)hsz);%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
    %@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Note that all three associated latoms are incremented.  %@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL IncHszCount(hsz)%@NL@%
HSZ hsz;%@NL@%
{%@NL@%
    char sz[ENCODEBYTES * 2 + 1];%@NL@%
    register BOOL fRet;%@NL@%
%@NL@%
    if (hsz == 0)%@NL@%
        return(TRUE);%@NL@%
        %@NL@%
    SemEnter();%@NL@%
    %@NL@%
    QuerylatomName((LATOM)hsz, sz, ENCODEBYTES * 2 + 1);%@NL@%
    fRet = InclatomCount(Decode((PBYTE)sz)) &&%@NL@%
                InclatomCount(Decode((PBYTE)&sz[ENCODEBYTES])) &&%@NL@%
                InclatomCount((LATOM)hsz);%@NL@%
    SemLeave();%@NL@%
    return(fRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine adds an atom table and returns its handle.  Returns fSuccess.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effects cAtbls, aAtbls, iAtblCurrent;%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL AddAtomTable(fInit)%@NL@%
BOOL fInit;%@NL@%
{%@NL@%
    PHATOMTBL pat;%@NL@%
%@NL@%
    SemEnter();    %@NL@%
%@NL@%
    if (!(pat = (PHATOMTBL)FarAllocMem(hheapDmg,%@NL@%
            sizeof(HATOMTBL) * (cAtbls + 1)))) {%@NL@%
        SemLeave();%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    %@NL@%
    if (!fInit) {%@NL@%
        CopyBlock((PBYTE)aAtbls, (PBYTE)pat, sizeof(HATOMTBL) * cAtbls);%@NL@%
        FarFreeMem(hheapDmg, aAtbls, sizeof(HATOMTBL) * cAtbls);%@NL@%
    }%@NL@%
    %@NL@%
    aAtbls = pat;%@NL@%
%@NL@%
    if (!(aAtbls[cAtbls] = WinCreateAtomTable(0, 0))) %@NL@%
        return(FALSE);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Share our atom tables with all processes...%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!WinSetAtomTableOwner(aAtbls[cAtbls], NULL)) {%@NL@%
        AssertF(FALSE, "AddAtomTable - WinSetAtomTable failed");%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    iAtblCurrent = cAtbls++;%@NL@%
    SemLeave();%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
USHORT QueryHszLength(hsz)%@NL@%
HSZ hsz;%@NL@%
{%@NL@%
    char sz[ENCODEBYTES + 1];%@NL@%
    USHORT us;%@NL@%
%@NL@%
    if (!hsz) %@NL@%
        return(0);%@NL@%
    SemEnter();%@NL@%
    QuerylatomName((LATOM)hsz, sz, ENCODEBYTES + 1);%@NL@%
    us = QuerylatomLength(Decode(sz));%@NL@%
    SemLeave();%@NL@%
    return(us);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
USHORT QueryHszName(hsz, psz, cchMax)%@NL@%
HSZ hsz;%@NL@%
PSZ psz;%@NL@%
USHORT cchMax;%@NL@%
{%@NL@%
    char sz[ENCODEBYTES + 1];%@NL@%
    register USHORT usRet;%@NL@%
    %@NL@%
    if (hsz == 0) {%@NL@%
        if (psz)%@NL@%
            *psz = '\000';%@NL@%
        return(1);%@NL@%
    } else {%@NL@%
        usRet = 0;%@NL@%
        SemEnter();%@NL@%
        if (QuerylatomName((LATOM)hsz, sz, ENCODEBYTES + 1))%@NL@%
            usRet = QuerylatomName(Decode(sz), psz, cchMax);%@NL@%
        SemLeave();%@NL@%
        return(usRet);%@NL@%
    }%@NL@%
}%@NL@%
     %@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * returns 0 if ==, -1 if hsz1 < hsz2, 1 if hsz1 > hsz2, 2 on error%@NL@%
%@AB@% */%@AE@%%@NL@%
SHORT CmpHsz(hsz1, hsz2)%@NL@%
HSZ hsz1, hsz2;%@NL@%
{%@NL@%
    char sz[ENCODEBYTES * 2 + 1];%@NL@%
    LATOM latom;%@NL@%
    SHORT usRet;%@NL@%
    %@NL@%
    if (hsz1 == hsz2)%@NL@%
        return(0);%@NL@%
    if (!hsz1) %@NL@%
        return(-1);%@NL@%
    if (!hsz2)%@NL@%
        return(1);%@NL@%
%@NL@%
    usRet = 2;%@NL@%
    SemEnter();%@NL@%
    if (QuerylatomName((LATOM)hsz1, sz, ENCODEBYTES * 2 + 1)) {%@NL@%
        latom = Decode(&sz[ENCODEBYTES]);   %@AB@%/* use UPPERCASE form for comparison. */%@AE@%%@NL@%
        if (QuerylatomName((LATOM)hsz2, sz, ENCODEBYTES * 2 + 1)) {%@NL@%
            latom = latom - Decode(&sz[ENCODEBYTES]);%@NL@%
            usRet = latom == 0 ? 0 : (latom > 0 ? 1 : -1);%@NL@%
        }%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    return(usRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
    %@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Returns the length of the latom given without NULL terminator.%@NL@%
%@AB@%* Wild LATOMs have a length of 0.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
USHORT QuerylatomLength(latom)%@NL@%
LATOM latom;%@NL@%
{%@NL@%
    USHORT cb;%@NL@%
    USHORT cbT = 0;%@NL@%
    BYTE ab[ENCODEBYTES + 1];%@NL@%
%@NL@%
    AssertF(HIUSHORT(latom) < cAtbls, "Invalid latom");%@NL@%
    if (latom == 0)%@NL@%
        return(0);%@NL@%
    SemCheckIn();%@NL@%
    while (TRUE) {%@NL@%
        if (!(cb = WinQueryAtomLength(aAtbls[HIUSHORT(latom)],%@NL@%
                LOUSHORT(latom)))) {%@NL@%
            AssertF(cbT == 0, "QuerylatomLength - failed on continued latom");%@NL@%
            return(0);%@NL@%
        }%@NL@%
            %@NL@%
        cbT += cb;%@NL@%
        %@NL@%
        if (cb <= MAX_LATOMSTRSIZE) {%@NL@%
            return(cbT);%@NL@%
        }%@NL@%
            %@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * it MUST be a huge latom.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (!(WinQueryAtomName(aAtbls[HIUSHORT(latom)], LOUSHORT(latom),%@NL@%
                (PSZ)ab, ENCODEBYTES + 1))) {%@NL@%
            AssertF(FALSE, "QuerylatomLength - Length but no name");%@NL@%
            return(0);%@NL@%
        }%@NL@%
            %@NL@%
        latom = Decode(ab);%@NL@%
        cbT -= ENCODEBYTES;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
USHORT QuerylatomName(latom, psz, cchMax)%@NL@%
LATOM latom;%@NL@%
PSZ psz;%@NL@%
USHORT cchMax;%@NL@%
{%@NL@%
    USHORT cb;%@NL@%
    extern char szT[];%@NL@%
%@NL@%
    if (HIUSHORT(latom) >= cAtbls) {%@NL@%
        AssertF(FALSE, "Invalid latom");%@NL@%
        psz[0] = '\0';%@NL@%
        return(0);%@NL@%
    }%@NL@%
    %@NL@%
    AssertF(latom != 0, "QuerylatomName - 0 latom");%@NL@%
    SemCheckIn();%@NL@%
    cb = WinQueryAtomLength(aAtbls[HIUSHORT(latom)], LOUSHORT(latom));%@NL@%
    if (cb > MAX_LATOMSTRSIZE) {%@NL@%
        if (!WinQueryAtomName(aAtbls[HIUSHORT(latom)], LOUSHORT(latom), szT,%@NL@%
                MAX_LATOMSTRSIZE + ENCODEBYTES + 1)) {%@NL@%
            AssertF(FALSE, "QuerylatomName - length but no name");%@NL@%
            return(0);%@NL@%
        }%@NL@%
        CopyBlock(szT + ENCODEBYTES, psz, min(MAX_LATOMSTRSIZE, cchMax));%@NL@%
        latom = Decode((PBYTE)szT);%@NL@%
        cb = MAX_LATOMSTRSIZE + QuerylatomName(latom, psz + MAX_LATOMSTRSIZE,%@NL@%
                cchMax > MAX_LATOMSTRSIZE ? cchMax - MAX_LATOMSTRSIZE : 0);%@NL@%
        %@NL@%
    } else {%@NL@%
        WinQueryAtomName(aAtbls[HIUSHORT(latom)], LOUSHORT(latom), psz, cchMax);%@NL@%
    }%@NL@%
    psz[cchMax - 1] = '\0';     %@AB@%/* add NULL terminator */%@AE@%%@NL@%
    return(min(cb, cchMax - 1));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This uses globals szT, aAtbls, cAtbls, and iAtblCurrent to add or%@NL@%
%@AB@%* find the latom for psz depending on fAdd.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
LATOM FindAddlatom(psz, fAdd)%@NL@%
PSZ psz;%@NL@%
BOOL fAdd;%@NL@%
{%@NL@%
    LATOM latom;%@NL@%
%@NL@%
    AssertF(psz != NULL, "FindAddlatom - NULL psz");%@NL@%
    AssertF(*psz != '\0', "FindAddlatom - NULL psz string");%@NL@%
    SemCheckIn();%@NL@%
    if (lstrlen(psz) > MAX_LATOMSTRSIZE) {%@NL@%
        latom = FindAddlatom(psz + MAX_LATOMSTRSIZE, fAdd);%@NL@%
        CopyBlock((PBYTE)psz, Encode((ULONG)latom, szT),%@NL@%
                (ULONG)MAX_LATOMSTRSIZE - ENCODEBYTES + 1);%@NL@%
        szT[MAX_LATOMSTRSIZE + ENCODEBYTES] = '\0';%@NL@%
        latom = FindAddlatomHelper(szT, fAdd);%@NL@%
        return(latom);%@NL@%
    } else {%@NL@%
        return(FindAddlatomHelper(psz, fAdd));%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
LATOM FindAddlatomHelper(psz, fAdd)%@NL@%
PSZ psz;%@NL@%
BOOL fAdd;%@NL@%
{%@NL@%
    int i;%@NL@%
    ATOM atom;%@NL@%
    ATOM (APIENTRY *lpfn)(HATOMTBL, PSZ);%@NL@%
    %@NL@%
    SemCheckIn();%@NL@%
    if (fAdd) {%@NL@%
        AssertF(++cAtoms, "Possible atom count overflow");%@NL@%
        lpfn = WinAddAtom;%@NL@%
    } else %@NL@%
        lpfn = WinFindAtom;%@NL@%
%@NL@%
    if (!(atom = (*lpfn)(aAtbls[i = iAtblCurrent], psz))) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Must be full/not found, try all the existing tables%@NL@%
%@AB@%         */%@AE@%%@NL@%
        for (i = 0; i < cAtbls; i++) {%@NL@%
            if (i != iAtblCurrent) {%@NL@%
                if (atom = (*lpfn)(aAtbls[i], psz)) {%@NL@%
                    if (fAdd)%@NL@%
                        iAtblCurrent = i;%@NL@%
                    break;%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
         %@NL@%
        if (!atom) {%@NL@%
            if (fAdd) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * they're all full, make another table.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                if (!AddAtomTable(FALSE)) {%@NL@%
                    return(0L);%@NL@%
                }%@NL@%
                if (!(atom = (*lpfn)(aAtbls[iAtblCurrent], psz))) {%@NL@%
                    return(0L); %@NL@%
                }%@NL@%
            } else {%@NL@%
                return(0L);%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
    return((LATOM)MAKEP(i, atom));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
    %@NL@%
    %@NL@%
%@NL@%
BOOL InclatomCount(latom)%@NL@%
LATOM latom;%@NL@%
{%@NL@%
    AssertF(HIUSHORT(latom) < cAtbls, "Invalid latom");%@NL@%
    AssertF(latom != 0, "InclatomCount - 0 latom");%@NL@%
    SemCheckIn();%@NL@%
    AssertF(++cAtoms, "Possible atom count overflow");%@NL@%
    return(WinAddAtom(aAtbls[HIUSHORT(latom)], MAKEP(0XFFFF, LOUSHORT(latom))));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
BOOL Freelatom(latom)%@NL@%
LATOM latom;%@NL@%
{%@NL@%
    AssertF(HIUSHORT(latom) < cAtbls, "Invalid latom");%@NL@%
    AssertF(latom != 0, "Freelatom - 0 latom");%@NL@%
    AssertF(WinQueryAtomUsage(aAtbls[HIUSHORT(latom)], LOUSHORT(latom)),%@NL@%
            "Freelatom - Freeing Non-existing atom");%@NL@%
    SemCheckIn();%@NL@%
        %@NL@%
    if (WinDeleteAtom(aAtbls[HIUSHORT(latom)], LOUSHORT(latom))) {%@NL@%
        AssertF(FALSE, "Freelatom - WinDeleteAtom failed");%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    AssertF(--cAtoms >= 0, "Freelatom - negative atom count");%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AI@%#ifdef %@AE@%DEBUG %@NL@%
BASEVAL '0'     %@AB@%/* more readable for debugging */%@AE@%%@NL@%
%@AI@%#else %@AE@%%@NL@%
BASEVAL 1       %@AB@%/* less likely to conflict with a string */%@AE@%%@NL@%
%@AI@%#endif %@AE@%%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Converts an latom into a ENCODEBYTES character string apropriate for%@NL@%
%@AB@%* atomization. (NULL terminator must be added)%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PBYTE Encode(latom, pb)%@NL@%
ULONG latom;%@NL@%
PBYTE pb;%@NL@%
{%@NL@%
    int i;%@NL@%
%@NL@%
    %@NL@%
    AssertF(HIUSHORT(latom) < cAtbls, "Invalid latom");%@NL@%
    for (i = 0; i < ENCODEBYTES; i++) {%@NL@%
        *pb++ = ((BYTE)latom & 0x0F) + BASEVAL;%@NL@%
        latom >>= 4;%@NL@%
    }%@NL@%
    return(pb);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This takes a pointer to a buffer of 8 bytes which is a coded LATOM and%@NL@%
%@AB@%* returns the LATOM.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
LATOM Decode(pb)%@NL@%
PBYTE pb;%@NL@%
{%@NL@%
    ULONG ul = 0;%@NL@%
    int i;%@NL@%
%@NL@%
    for (i = ENCODEBYTES - 1; i >= 0; i--) {%@NL@%
        ul <<= 4;%@NL@%
        ul += (ULONG)(pb[i] - BASEVAL);%@NL@%
    }%@NL@%
    return((LATOM)ul);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This routine extracts the hszItem out of an existing hData handle.%@NL@%
%@AB@% * local conversations can use the hsz directly out of the handle while%@NL@%
%@AB@% * non-dll conversations will have to generate the hsz from the string.%@NL@%
%@AB@% */%@AE@%%@NL@%
HSZ GetHszItem(%@NL@%
PMYDDES pmyddes,%@NL@%
PCONVCONTEXT pCC,%@NL@%
BOOL fAdd)%@NL@%
{%@NL@%
    if (CheckSel(SELECTOROF(pmyddes)) >= sizeof(MYDDES) &&%@NL@%
            pmyddes->magic == MYDDESMAGIC) {%@NL@%
        if (fAdd) %@NL@%
            IncHszCount(pmyddes->hszItem);%@NL@%
        return(pmyddes->hszItem);%@NL@%
    } else {%@NL@%
        return(GetHsz(DDES_PSZITEMNAME(pmyddes), pCC->idCountry,%@NL@%
                pCC->usCodepage, fAdd));%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DMGMON.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\DMGMON.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name: DMGMON.C%@NL@%
%@AB@%*%@NL@%
%@AB@%* This module contains functions used for DDE monitor control.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created:  8/2/88    sanfords%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@AI@%#include %@AE@%"ddemlp.h" %@NL@%
%@AI@%#define %@AE@%MSGF_DDEPOSTMSG     3 %@NL@%
%@NL@%
%@AI@%#define %@AE@%freeMonStr(psz) MyFreeMem(hheapDmg, (NPBYTE)(USHORT)psz, MAX_MONITORSTR + 1) %@NL@%
%@NL@%
%@NL@%
BOOL EXPENTRY DdeSendHookProc(hab, psmh, fInterTask)%@NL@%
HAB hab;%@NL@%
PSMHSTRUCT psmh;%@NL@%
BOOL fInterTask;%@NL@%
{%@NL@%
    PSZ psz;%@NL@%
    PSZ pszSave;%@NL@%
    PSZ pszLast;%@NL@%
%@NL@%
    UNUSED hab;%@NL@%
    UNUSED fInterTask;%@NL@%
    %@NL@%
    if (psmh->msg == WM_DDE_INITIATE || psmh->msg == WM_DDE_INITIATEACK) {%@NL@%
        if (allocMonStr(&pszSave, &pszLast)) {%@NL@%
            psz = timestamp(pszSave, pszLast);%@NL@%
            psz = lstrcat(psz, " ", pszLast);%@NL@%
            psz = ltoa((ULONG)psmh->mp1, psz, pszLast);%@NL@%
            psz = lstrcat(psz, " -> ", pszLast);%@NL@%
            psz = ltoa((ULONG)psmh->hwnd, psz, pszLast);%@NL@%
            psz = lstrcat(psz, "\n\r", pszLast);%@NL@%
            psz = ddeMsgToPsz(psmh->msg, psz, pszLast);%@NL@%
            psz = pddesToPsz(psmh->msg, (PDDESTRUCT)psmh->mp2, psz, pszLast);%@NL@%
            psz = lstrcat(psz, ")\n\r", pszLast);%@NL@%
            MonitorBroadcast(pszSave);%@NL@%
            freeMonStr(pszSave);%@NL@%
        }%@NL@%
    }%@NL@%
    return(FALSE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
BOOL EXPENTRY DdePostHookProc(hab, pqmsg, fs)%@NL@%
HAB hab;%@NL@%
PQMSG pqmsg;%@NL@%
USHORT fs;%@NL@%
{%@NL@%
    PSZ psz;%@NL@%
    PSZ pszSave;%@NL@%
    PSZ pszLast;%@NL@%
%@NL@%
    UNUSED hab;%@NL@%
%@NL@%
    if (fs && pqmsg->msg >= WM_DDE_FIRST && pqmsg->msg <= WM_DDE_LAST) {%@NL@%
        pszLast = psz + MAX_MONITORSTR;  %@NL@%
        if (allocMonStr(&pszSave, &pszLast)) {%@NL@%
            psz = timestamp(pszSave, pszLast);%@NL@%
            psz = lstrcat(psz, " ", pszLast);%@NL@%
            psz = ltoa((ULONG)pqmsg->mp1, psz, pszLast);%@NL@%
            psz = lstrcat(psz, " -> ", pszLast);%@NL@%
            psz = ltoa((ULONG)pqmsg->hwnd, psz, pszLast);%@NL@%
            psz = lstrcat(psz, "\n\r", pszLast);%@NL@%
            psz = ddeMsgToPsz(pqmsg->msg, psz, pszLast);%@NL@%
            psz = pddesToPsz(pqmsg->msg, (PDDESTRUCT)pqmsg->mp2, psz, pszLast);%@NL@%
            psz = lstrcat(psz, ")\n\r", pszLast);%@NL@%
            MonitorBroadcast(pszSave);%@NL@%
            freeMonStr(pszSave);%@NL@%
        }%@NL@%
    }%@NL@%
    return(FALSE);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This guy sends a UM_MONITOR to all the monitor windows (up to MAX_MONITOR)%@NL@%
%@AB@% * The cheap restriction is due to needing to not be in the semaphore%@NL@%
%@AB@% * while the monitor is in control yet needing to keep access to pai in%@NL@%
%@AB@% * the semaphore.%@NL@%
%@AB@% */%@AE@%%@NL@%
void MonitorBroadcast(psz)%@NL@%
PSZ psz;%@NL@%
{%@NL@%
    HWND hwnd[MAX_MONITORS];%@NL@%
    PAPPINFO pai;%@NL@%
    register USHORT i = 0;%@NL@%
%@NL@%
    SemCheckOut();%@NL@%
    SemEnter();%@NL@%
    pai = pAppInfoList;%@NL@%
    while (pai && i < cMonitor && i < MAX_MONITORS) {%@NL@%
        if (pai->hwndMonitor) {%@NL@%
            hwnd[i] = pai->hwndMonitor;%@NL@%
            i++;%@NL@%
        }%@NL@%
        pai = pai->next;%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    %@NL@%
    for (i = 0; i < cMonitor; i++)%@NL@%
        WinSendMsg(hwnd[i], UM_MONITOR, (MPARAM)psz, 0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * We need to allocate the string buffer so that recursive calls will work.%@NL@%
%@AB@% * We also need to do this because the DLL DS is shared between all potential%@NL@%
%@AB@% * monitor processes.%@NL@%
%@AB@% *%@NL@%
%@AB@% * This also initializes the psz for us with a null terminator and checks%@NL@%
%@AB@% * cMonitor for us.  If this fails, no monitor action is done.%@NL@%
%@AB@% *%@NL@%
%@AB@% * ppsz will contain a pointer to the begining of the allocated buffer.%@NL@%
%@AB@% * ppszLast will contain a pointer to the end of the allocated buffer.%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL allocMonStr(ppsz, ppszLast)%@NL@%
PSZ far *ppsz;%@NL@%
PSZ far *ppszLast;%@NL@%
{%@NL@%
    SemEnter();%@NL@%
    if (cMonitor == 0 ||%@NL@%
            ((*ppsz = FarAllocMem(hheapDmg, MAX_MONITORSTR + 1)) == NULL)) {%@NL@%
        SemLeave();%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    *ppszLast = *ppsz + MAX_MONITORSTR;%@NL@%
    **ppsz = '\0';%@NL@%
    SemLeave();%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY MonitorWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
register MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
    HDMGDATA hDmgData;%@NL@%
%@NL@%
    pai = GetCurrentAppInfo(FALSE);%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_CREATE:%@NL@%
        mp1  = (PSZ)"\n\rMonitor Created\n\r\n\r";%@NL@%
        goto MonOut;%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
        mp1 = (PSZ)"\n\r\n\rMonitor Destroyed\n\r";%@NL@%
        %@AB@%/* fall through */%@AE@%%@NL@%
%@NL@%
    case UM_MONITOR:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * mp1 = psz to print%@NL@%
%@AB@%         */%@AE@%%@NL@%
MonOut:%@NL@%
        hDmgData = DdePutData((PSZ)mp1, (ULONG)(lstrlen(mp1) + 1),%@NL@%
                0L, (HSZ)0L, DDEFMT_TEXT, 0);%@NL@%
        pai->cInCallback++;%@NL@%
        DoCallback(pai, 0, 0, 0, DDEFMT_TEXT, XTYP_MONITOR, hDmgData);%@NL@%
        if (pai->cInCallback > 0)   %@AB@%/* test incase exitlist processing messed things up */%@AE@%%@NL@%
            pai->cInCallback--;%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DMGQ.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\DMGQ.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name: DMGQ.C%@NL@%
%@AB@%*%@NL@%
%@AB@%* DDE Manager queue control functions.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created: 9/1/89 Sanford Staab%@NL@%
%@AB@%*%@NL@%
%@AB@%* This is a general queue manager - yes another one!%@NL@%
%@AB@%* Queues are each allocated within their own segment and have a%@NL@%
%@AB@%* QST structure associated with that heap.  Each queue item%@NL@%
%@AB@%* is allocated within the heap segment.  The offset of the items%@NL@%
%@AB@%* address combined with an instance count is used as the item ID.%@NL@%
%@AB@%* This is both unique and allows for instant location of an item.%@NL@%
%@AB@%* New items are added to the head of the queue which is a doubly linked%@NL@%
%@AB@%* list.  The next links point to more recent entries, the prev pointers%@NL@%
%@AB@%* to older entries.  The next of the head is the tail.  The prev of the%@NL@%
%@AB@%* tail is the head.  All pointers are far.%@NL@%
%@AB@%* Queue Data may be of any structure type that begins identical to%@NL@%
%@AB@%* a QUEUEITEM structure.  Functions that require an cbItem perameter%@NL@%
%@AB@%* should be given the size of the specialized queue item structure.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"ddemlp.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* Creates a Queue for items of cbItem.%@NL@%
%@AB@%* Returns NULL on error.%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PQST CreateQ(cbItem)%@NL@%
USHORT cbItem;%@NL@%
{%@NL@%
    QST cq;%@NL@%
    PQST pQ;%@NL@%
    %@NL@%
    cq.cItems = 0;%@NL@%
    cq.instLast = 0;%@NL@%
    cq.cbItem = cbItem;%@NL@%
    cq.pqiHead = NULL;%@NL@%
    if (!(cq.hheap = MyCreateHeap(0, sizeof(QST) + cbItem << 3,%@NL@%
            cbItem << 3, cbItem, cbItem, HEAPFLAGS)))%@NL@%
        return(NULL);%@NL@%
    if (!(pQ = (PQST)FarAllocMem(cq.hheap, sizeof(QST)))) {%@NL@%
        MyDestroyHeap(cq.hheap);%@NL@%
        return(0);%@NL@%
    }%@NL@%
    *pQ = cq;%@NL@%
    return(pQ);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL DestroyQ(pQ)%@NL@%
PQST pQ;%@NL@%
{%@NL@%
    if (pQ)%@NL@%
        MyDestroyHeap(pQ->hheap);%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* returns a long pointer to the queue item data created.  The new item%@NL@%
%@AB@%* is added to the head of the queue.  The queue's cbItem specified at%@NL@%
%@AB@%* creation is used for allocation.%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PQUEUEITEM Addqi(pQ)%@NL@%
PQST pQ;%@NL@%
{%@NL@%
    PQUEUEITEM pqi;%@NL@%
%@NL@%
    if ((pqi = (PQUEUEITEM)FarAllocMem(pQ->hheap, pQ->cbItem)) == NULL) {%@NL@%
        if (pQ->cItems == 0)%@NL@%
            return(0);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * remove the oldest item to make room for the new.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        pqi = pQ->pqiHead->next;%@NL@%
        SemEnter();%@NL@%
        pqi->prev->next = pqi->next;%@NL@%
        pqi->next->prev = pqi->prev;%@NL@%
        SemLeave();%@NL@%
    }%@NL@%
%@NL@%
    SemEnter();%@NL@%
    if (pQ->cItems == 0) {%@NL@%
        pQ->pqiHead = pqi->prev = pqi->next = pqi;%@NL@%
    } else {%@NL@%
        pqi->prev = pQ->pqiHead;%@NL@%
        pqi->next = pQ->pqiHead->next;%@NL@%
        pQ->pqiHead->next->prev = pqi;%@NL@%
        pQ->pqiHead->next = pqi;%@NL@%
        pQ->pqiHead = pqi;%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    pQ->cItems++;%@NL@%
    pqi->inst = ++pQ->instLast;%@NL@%
    return(pqi);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%*  The id given is an external LONG id, not an item instance number.%@NL@%
%@AB@%*  If id is QID_NEWEST, the head item is deleted.%@NL@%
%@AB@%*  If id is QID_OLDEST, the tail item is deleted.%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void Deleteqi(pQ, id)%@NL@%
PQST pQ;%@NL@%
ULONG id;%@NL@%
{%@NL@%
    PQUEUEITEM pqi;%@NL@%
%@NL@%
    SemEnter();%@NL@%
    pqi = Findqi(pQ, id);%@NL@%
    if (pqi == NULL) {%@NL@%
        SemLeave();%@NL@%
        return;%@NL@%
    }%@NL@%
    pqi->prev->next = pqi->next;%@NL@%
    pqi->next->prev = pqi->prev;%@NL@%
    if (pqi == pQ->pqiHead)%@NL@%
        pQ->pqiHead = pqi->prev;%@NL@%
    if (!(--pQ->cItems))%@NL@%
        pQ->pqiHead = NULL;%@NL@%
    FarFreeMem(pQ->hheap, pqi, pQ->cbItem);%@NL@%
    SemLeave();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%*  The id given is an external LONG id, not an item instance number.%@NL@%
%@AB@%*%@NL@%
%@AB@%*  if id == QID_NEWEST, returns the head queue data item.%@NL@%
%@AB@%*  if id == QID_OLDEST, returns the tail queue data item.%@NL@%
%@AB@%*  if the id is not found or the queue is empty, NULL is returned.%@NL@%
%@AB@%*  if found, pqi is returned.%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PQUEUEITEM Findqi(pQ, id)%@NL@%
PQST pQ;%@NL@%
ULONG id;%@NL@%
{%@NL@%
    PQUEUEITEM pqi;%@NL@%
%@NL@%
    SemCheckIn();%@NL@%
    if (pQ == NULL || pQ->pqiHead == NULL)%@NL@%
        return(NULL);%@NL@%
        %@NL@%
    if (id == QID_OLDEST) %@NL@%
        return(pQ->pqiHead->next);%@NL@%
        %@NL@%
    if (id == QID_NEWEST) %@NL@%
        return(pQ->pqiHead);%@NL@%
        %@NL@%
    if (id) {%@NL@%
        pqi = PFROMID(pQ, id);%@NL@%
        if (pqi->inst == HIUSHORT(id)) {%@NL@%
            return(pqi);%@NL@%
        }%@NL@%
        return(NULL);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DMGSTR.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\DMGSTR.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name: DMGSTR.C%@NL@%
%@AB@%*%@NL@%
%@AB@%* DDE manager string handling routines%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created: 1/31/88 Sanford Staab%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@AI@%#include %@AE@%"ddemlp.h" %@NL@%
%@AI@%#include %@AE@%"ctype.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* returns string length not counting null terminator.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  1/1/89  created     sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
int lstrlen(psz)%@NL@%
PSZ psz;%@NL@%
{%@NL@%
    int c = 0;%@NL@%
%@NL@%
    while (*psz != 0) {%@NL@%
        psz++;%@NL@%
        c++;%@NL@%
    }%@NL@%
    return(c);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* Concatonates psz1 and psz2 into psz1.%@NL@%
%@AB@%* returns psz pointing to end of concatonated string.%@NL@%
%@AB@%* pszLast marks point at which copying must stop.  This makes this operation%@NL@%
%@AB@%* safe for limited buffer sizes.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  1/1/89  created sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PSZ lstrcat(psz1, psz2, pszLast)%@NL@%
PSZ psz1, psz2, pszLast;%@NL@%
{%@NL@%
    psz1 += lstrlen(psz1);%@NL@%
    while (*psz2 != '\0' && psz1 < pszLast) {%@NL@%
        *psz1++ = *psz2++;%@NL@%
    }%@NL@%
    *psz1 = '\0';%@NL@%
    return(psz1);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION: ASCII dependent converter of DDE structure data to a string.%@NL@%
%@AB@%* returns psz pointing to end of copy.%@NL@%
%@AB@%* During monitoring we allocate segments as gettable so we can monitor them.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      Created 1/31/89         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PSZ pddesToPsz(msg, pddes, psz, pszLast)%@NL@%
USHORT msg;%@NL@%
PDDESTRUCT pddes;%@NL@%
PSZ psz;%@NL@%
PSZ pszLast;%@NL@%
{%@NL@%
    USHORT cb;%@NL@%
    PBYTE pData;%@NL@%
%@AI@%#define %@AE@%pDdeInit ((PDDEINIT)pddes) %@NL@%
%@NL@%
    *psz = '\0';%@NL@%
    switch (msg) {%@NL@%
    case WM_DDE_REQUEST:%@NL@%
    case WM_DDE_ACK:%@NL@%
    case WM_DDE_DATA:%@NL@%
    case WM_DDE_ADVISE:%@NL@%
    case WM_DDE_UNADVISE:%@NL@%
    case WM_DDE_POKE:%@NL@%
    case WM_DDE_EXECUTE:%@NL@%
        psz = lstrcat(psz, "S:", pszLast);%@NL@%
        psz = Status(pddes->fsStatus, psz, pszLast);%@NL@%
        psz = lstrcat(psz, " F:", pszLast);%@NL@%
        psz = Format(pddes->usFormat, psz, pszLast);%@NL@%
        psz = lstrcat(psz, " I:", pszLast);%@NL@%
        psz = lstrcat(psz, DDES_PSZITEMNAME(pddes), pszLast);%@NL@%
        if (pddes->cbData)%@NL@%
            psz = lstrcat(psz, "\n\r  Data:", pszLast);%@NL@%
        pData = DDES_PABDATA(pddes);%@NL@%
%@NL@%
        for (cb = 0; (ULONG)cb < pddes->cbData && psz < pszLast; cb++, pData++) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * new line every 64 chars%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if ((cb & 0x3F) == 0) {%@NL@%
                *psz = '\0';%@NL@%
                psz = lstrcat(psz, "\n\r    ", pszLast);%@NL@%
            }%@NL@%
            if (*pData > 0x20)%@NL@%
                *psz = *pData;%@NL@%
            else%@NL@%
                *psz = '.';%@NL@%
                %@NL@%
            *psz++ = *psz & 0x7f;%@NL@%
        }%@NL@%
        CopyBlock("\n\r", pszLast - 3, 3L);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DDE_INITIATEACK:%@NL@%
    case WM_DDE_INITIATE:%@NL@%
        if (CheckSel(SELECTOROF(pDdeInit))) {%@NL@%
            psz = lstrcat(psz, "A:", pszLast);%@NL@%
            psz = lstrcat(psz, pDdeInit->pszAppName, pszLast);%@NL@%
            psz = lstrcat(psz, " T:", pszLast);%@NL@%
            psz = lstrcat(psz, pDdeInit->pszTopic, pszLast);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DDE_TERMINATE:%@NL@%
        break;%@NL@%
    }%@NL@%
    *psz = '\0';%@NL@%
    return(psz);%@NL@%
    %@NL@%
%@AI@%#undef %@AE@%pDdeInit %@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
PSZ Status(fs, psz, pszLast)%@NL@%
USHORT fs;%@NL@%
PSZ psz;%@NL@%
PSZ pszLast;%@NL@%
{%@NL@%
    if (fs & DDE_FACK) {%@NL@%
        psz = lstrcat(psz, "ACK ", pszLast);%@NL@%
    }%@NL@%
    if (fs & DDE_FBUSY) {%@NL@%
        psz = lstrcat(psz, "BUSY ", pszLast);%@NL@%
    }%@NL@%
    if (fs & DDE_FNODATA) {%@NL@%
        psz = lstrcat(psz, "NODATA ", pszLast);%@NL@%
    }%@NL@%
    if (fs & DDE_FACKREQ) {%@NL@%
        psz = lstrcat(psz, "ACKREQ ", pszLast);%@NL@%
    }%@NL@%
    if (fs & DDE_FRESPONSE) {%@NL@%
        psz = lstrcat(psz, "RESPONSE ", pszLast);%@NL@%
    }%@NL@%
    if (fs & DDE_NOTPROCESSED) {%@NL@%
        psz = lstrcat(psz, "NOTPROCESSED ", pszLast);%@NL@%
    }%@NL@%
    if (fs & DDE_FAPPSTATUS) {%@NL@%
        psz = lstrcat(psz, "APPSTAT=", pszLast);%@NL@%
        psz = itoa(fs & DDE_FAPPSTATUS, psz, pszLast);%@NL@%
        *psz++ = ' ';%@NL@%
        *psz++ = '\0';%@NL@%
    }%@NL@%
    if (fs & DDE_FRESERVED) {%@NL@%
        psz = lstrcat(psz, "RESERVED=", pszLast);%@NL@%
        psz = itoa(fs & DDE_FRESERVED, psz, pszLast);%@NL@%
    }%@NL@%
    return(psz);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
PSZ Format(fmt, psz, pszLast)%@NL@%
USHORT fmt;%@NL@%
PSZ psz;%@NL@%
PSZ pszLast;%@NL@%
{%@NL@%
    if (fmt > 0xbfff) {%@NL@%
        *psz++ = '"';%@NL@%
        psz += WinQueryAtomName(WinQuerySystemAtomTable(), fmt, psz, pszLast - psz);%@NL@%
        *psz++ = '"';%@NL@%
        *psz = '\0';%@NL@%
    } else if (fmt == DDEFMT_TEXT) {%@NL@%
        psz = lstrcat(psz, "TEXT", pszLast);%@NL@%
    } else {%@NL@%
        psz = itoa(fmt, psz, pszLast);%@NL@%
    }%@NL@%
    return(psz);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION: puts an apropriate string for a DDE message into psz. pszLast%@NL@%
%@AB@%* specifies the last spot to copy.  Returns a psz pointing to the end of%@NL@%
%@AB@%* the copyed data.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      Created 1/31/89         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PSZ ddeMsgToPsz(msg, psz, pszLast)%@NL@%
USHORT msg;%@NL@%
PSZ psz;%@NL@%
PSZ pszLast;%@NL@%
{%@NL@%
    psz = lstrcat(psz, " ", pszLast);%@NL@%
    if (msg < WM_DDE_FIRST || msg > WM_DDE_LAST) {%@NL@%
        psz = itoa(msg, psz, pszLast);%@NL@%
    } else {%@NL@%
        WinLoadString(DMGHAB, hmodDmg, msg, pszLast - psz + 1, psz);%@NL@%
        psz += lstrlen(psz);%@NL@%
    }%@NL@%
    return(lstrcat(psz, "(", pszLast));%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   fills psz with a hex string "0xdddd" and returns psz pointing to the 0%@NL@%
%@AB@%*   terminator at the end.  copying will never go beyond pszLast.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      Created 1/31/89        sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PSZ itoa(us, psz, pszLast)%@NL@%
USHORT us;%@NL@%
PSZ psz;%@NL@%
PSZ pszLast;%@NL@%
{%@NL@%
    if (psz > pszLast - 7)%@NL@%
        return(psz);%@NL@%
    *psz++ = '0';%@NL@%
    *psz++ = 'x';%@NL@%
    return(stoa(psz, us));%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   fills psz with a hex string "0xdddddddd" and returns psz pointing to the 0%@NL@%
%@AB@%*   terminator at the end.  copying will never go beyond pszLast.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      Created 1/31/89        sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PSZ ltoa(ul, psz, pszLast)%@NL@%
ULONG ul;%@NL@%
PSZ psz;%@NL@%
PSZ pszLast;%@NL@%
{%@NL@%
    if (psz > pszLast - 11)%@NL@%
        return(psz);%@NL@%
    *psz++ = '0';%@NL@%
    *psz++ = 'x';%@NL@%
    psz = stoa(psz, HIUSHORT(ul));%@NL@%
    return(stoa(psz, LOUSHORT(ul)));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   fills psz with a hex string "dddd" and returns psz pointing to the 0%@NL@%
%@AB@%*   terminator at the end.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      Created 1/31/89        sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PSZ stoa(psz, us)%@NL@%
PSZ psz;%@NL@%
USHORT us;%@NL@%
{%@NL@%
    static char dtoa[] = "0123456789abcdef";%@NL@%
%@NL@%
    *psz++ = dtoa[(us & 0xf000) >> 12];%@NL@%
    *psz++ = dtoa[(us & 0xf00) >> 8];%@NL@%
    *psz++ = dtoa[(us & 0xf0) >> 4];%@NL@%
    *psz++ = dtoa[us & 0xf];%@NL@%
    *psz = '\0';%@NL@%
    return(psz);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Decimal to ascii%@NL@%
%@AB@% */%@AE@%%@NL@%
PSZ dtoa(psz, us, fRecurse)%@NL@%
PSZ psz;%@NL@%
USHORT us;%@NL@%
BOOL fRecurse;%@NL@%
{%@NL@%
    if (us > 9) {%@NL@%
        psz = dtoa(psz, us / 10, TRUE);%@NL@%
        *psz++ = (UCHAR)(us % 10) + '0';%@NL@%
    } else if (us > 0)%@NL@%
        *psz++ = (UCHAR)us + '0';%@NL@%
    else if (!fRecurse)%@NL@%
        *psz++ = '0';%@NL@%
    *psz = '\000';%@NL@%
    return(psz);%@NL@%
}%@NL@%
   %@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   fills psz with a hex time stamp and returns psz pointing to the 0%@NL@%
%@AB@%*   terminator at the end.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      Created 5/9/89        sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PSZ timestamp(psz, pszLast)%@NL@%
PSZ psz;%@NL@%
PSZ pszLast;%@NL@%
{%@NL@%
    DATETIME dt;%@NL@%
    static USHORT prevTime = 0;%@NL@%
    USHORT Time;%@NL@%
%@NL@%
    DosGetDateTime(&dt);%@NL@%
    Time = MAKESHORT(dt.hundredths, dt.seconds);%@NL@%
    psz = lstrcat(psz, "----------- dTime=", pszLast);%@NL@%
    psz = itoa(Time - prevTime, psz, pszLast);%@NL@%
    psz = lstrcat(psz, " ", pszLast);%@NL@%
    prevTime = Time;%@NL@%
    return(psz + lstrlen(psz));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DMGSTRT.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\DMGSTRT.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%;  DDE manager library initialization routine%@AE@%%@NL@%
%@NL@%
.286p%@NL@%
%@NL@%
?WIN=1      %@AB@%; Use Windows prolog/epilog%@AE@%%@NL@%
?PLM=1      %@AB@%; Use PLM calling convention%@AE@%%@NL@%
DOS5=1%@NL@%
.xlist%@NL@%
include cmacros.inc%@NL@%
.list%@NL@%
%@NL@%
sBegin  DATA%@NL@%
%@NL@%
assumes DS,DATA%@NL@%
%@NL@%
externW hmodDmg%@NL@%
externW usHugeShift%@NL@%
%@NL@%
sEnd    DATA%@NL@%
%@NL@%
sBegin  CODE%@NL@%
assumes cs,CODE%@NL@%
assumes ds,DATA%@NL@%
%@NL@%
externNP        SemInit%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Registers set up by DosLoadModule...%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   SI = heap size%@AE@%%@NL@%
%@AB@%;   DI = module ID%@AE@%%@NL@%
%@AB@%;   DS = library's automatic data segment%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc   LoadProc,<FAR,PUBLIC>%@NL@%
cBegin  LoadProc%@NL@%
%@AB@%;       int     3%@AE@%%@NL@%
        mov     hmodDmg, di%@NL@%
        call    SemInit%@NL@%
cEnd    LoadProc%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; FillBlock(PBYTE pDst, USHORT cb, BYTE b)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc        FillBlock,<PUBLIC, NEAR>,<DI, DS>%@NL@%
ParmD        pDst%@NL@%
ParmW        cb%@NL@%
ParmW        b%@NL@%
cBegin%@NL@%
        les        di,pDst%@NL@%
        mov        cx,cb%@NL@%
        mov        ax,b%@NL@%
        cld%@NL@%
        rep        stosb%@NL@%
cEnd%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; CopyBlock(pbSrc, pbDst, cb)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
LabelNP <PUBLIC, CopyBlock>%@NL@%
        mov     bx,sp%@NL@%
        push    si%@NL@%
        push    di%@NL@%
        mov     dx,ds               %@AB@%; preserve DS%@AE@%%@NL@%
%@NL@%
        mov     cx,ss:[bx+2]%@NL@%
        jcxz    copydone           %@AB@%; all done if crc   == 0%@AE@%%@NL@%
        les     di,ss:[bx+2+2]%@NL@%
        lds     si,ss:[bx+2+2+4]%@NL@%
        cmp     si,di%@NL@%
        jae     copyok%@NL@%
        mov     ax,cx%@NL@%
        dec     ax%@NL@%
        add     si,ax%@NL@%
        add     di,ax%@NL@%
        std%@NL@%
        rep     movsb%@NL@%
        cld%@NL@%
        jmp     short copydone%@NL@%
copyok:%@NL@%
        cld%@NL@%
        rep     movsb%@NL@%
copydone:%@NL@%
%@NL@%
        mov     ds,dx%@NL@%
        pop     di%@NL@%
        pop     si%@NL@%
        ret     10%@NL@%
%@NL@%
%@NL@%
cProc HugeOffset,<NEAR, PUBLIC>%@NL@%
parmD   pSrc%@NL@%
parmD   cb%@NL@%
cBegin%@NL@%
        mov     dx, SEG_cb%@NL@%
        mov     ax, OFF_pSrc%@NL@%
        add     ax, OFF_cb%@NL@%
        adc     dx, 0%@NL@%
        mov     cx, usHugeShift%@NL@%
        shl     dx, cl%@NL@%
        add     dx, SEG_pSrc%@NL@%
cEnd%@NL@%
%@NL@%
%@NL@%
LabelFP <PUBLIC, DdeDebugBreak>%@NL@%
        int     3%@NL@%
        retf    0%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Returns segment size or 0 on error.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
LabelNP <PUBLIC, CheckSel>%@NL@%
%@AB@%;    parmW   Selector    ; selector to validate%@AE@%%@NL@%
cBegin  nogen%@NL@%
        mov     bx,sp               %@AB@%; BX = selector to validate%@AE@%%@NL@%
        mov     bx,ss:[bx].2%@NL@%
        lar     ax,bx               %@AB@%; See if valid selector%@AE@%%@NL@%
        jnz     invalid_selector%@NL@%
%@NL@%
        lsl     ax,bx%@NL@%
        or      ax,ax               %@AB@%; zero sized?%@AE@%%@NL@%
        jnz     valid_selector      %@AB@%; nope, ok.%@AE@%%@NL@%
%@NL@%
invalid_selector:%@NL@%
        xor     ax,ax               %@AB@%; Return zero just to be nice%@AE@%%@NL@%
%@NL@%
valid_selector:%@NL@%
        ret     2%@NL@%
%@NL@%
cEnd    nogen%@NL@%
%@NL@%
sEnd    CODE%@NL@%
end     LoadProc%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DMGWNDP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\DMGWNDP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* Module Name: DMGWNDP.C%@NL@%
%@AB@%*%@NL@%
%@AB@%* This module contains all the window procs for the DDE manager.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created: 12/23/88 sanfords%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"ddemlp.h" %@NL@%
%@NL@%
%@NL@%
ULONG defid = QID_SYNC;%@NL@%
XFERINFO defXferInfo = {%@NL@%
        &defid,%@NL@%
        1L,%@NL@%
        XTYP_INIT,%@NL@%
        DDEFMT_TEXT,%@NL@%
        0L,%@NL@%
        0L,%@NL@%
        0L,%@NL@%
        NULL%@NL@%
};%@NL@%
%@NL@%
void InitAck(HWND hwnd, PCLIENTINFO pci, HWND hwndServer, PDDEINIT pddei);%@NL@%
MRESULT ClientXferReq(PXFERINFO pXferInfo, PCLIENTINFO pci, HWND hwnd);%@NL@%
USHORT SendClientReq(PXADATA pXad, HWND hwndServer, HWND hwnd, PAPPINFO pai);%@NL@%
void DoClientDDEmsg(PCLIENTINFO pci, HWND hwnd, USHORT msg, HWND hwndFrom,%@NL@%
        PDDESTRUCT pddes);%@NL@%
BOOL fExpectedMsg(PXADATA pXad, PDDESTRUCT pddes, USHORT msg, PCLIENTINFO pci);%@NL@%
BOOL AdvanceXaction(HWND hwnd, PCLIENTINFO pci, PXADATA pXad,%@NL@%
        PDDESTRUCT pddes, USHORT msg, PUSHORT pErr);%@NL@%
MRESULT ClientXferRespond(PCLIENTINFO pci, PXADATA pXad, PUSHORT pErr);%@NL@%
void FrameInitConv(HWND hwndClient, PDDEINIT pddei);%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * ----------------CLIENT SECTION------------------%@NL@%
%@AB@% *%@NL@%
%@AB@% * Each client conversation has associated with it a window and a queue.%@NL@%
%@AB@% * A conversation has one synchronous transaction and may have many%@NL@%
%@AB@% * asynchronous transactions.  A transaction is differientiated by its%@NL@%
%@AB@% * state and other pertinant data.  A transaction may be synchronous,%@NL@%
%@AB@% * asynchronous, (initiated by DdeClientXfer()), or it may be external,%@NL@%
%@AB@% * (initiated by an advise loop.)%@NL@%
%@AB@% *%@NL@%
%@AB@% * A transaction is active if it is in the middle of tranfer, otherwise%@NL@%
%@AB@% * it is shutdown.  A shutdown transaction is either successful or%@NL@%
%@AB@% * failed.  When an asynchronous transaction shuts down, the client%@NL@%
%@AB@% * is notified via the callback function. (XTYP_XFERCOMPLETE)%@NL@%
%@AB@% *%@NL@%
%@AB@% * The synchronous transaction, when active, is in a timeout loop which%@NL@%
%@AB@% * can shut-down the transaction at the end of a predefined time period.%@NL@%
%@AB@% * Shutdown synchronous transactions imediately transfer their information%@NL@%
%@AB@% * to the client application by returning to DdeClientXfer().%@NL@%
%@AB@% *%@NL@%
%@AB@% * asynchronous transactions remain in the client queue until removed%@NL@%
%@AB@% * by the client application via DdeCheckQueue().  %@NL@%
%@AB@% *%@NL@%
%@AB@% * external transactions take place when the client is in an advise%@NL@%
%@AB@% * data loop.  These transactions pass through the callback function to%@NL@%
%@AB@% * the client to be accepted.(XTYP_ADVDATA)%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* MRESULT EXPENTRY ClientWndProc(hwnd, msg, mp1, mp2);%@NL@%
%@AB@%*%@NL@%
%@AB@%*   This window controls a single DDE conversation from the CLIENT side.%@NL@%
%@AB@%*   If closed, it will automaticly abort any conversationn in progress.%@NL@%
%@AB@%*   It maintains an internal list of any extra WM_DDEINITIATEACK messages%@NL@%
%@AB@%*   it receives so that it can be queried later about this information.%@NL@%
%@AB@%*   Any extra WM_DDEINITIATEACK messages comming in will be immediately%@NL@%
%@AB@%*   terminated.%@NL@%
%@AB@%*   It also maintains an internal list of all items which currently are%@NL@%
%@AB@%*   in active ADVISE loops.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     12/16/88    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY ClientWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    register PCLIENTINFO pci;%@NL@%
    PAPPINFO pai;%@NL@%
    MRESULT mrData;%@NL@%
    PDDESTRUCT pddes;%@NL@%
%@NL@%
    pci = (PCLIENTINFO)WinQueryWindowULong(hwnd, QWL_USER);%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_CREATE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * allocate and initialize the client window info.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        pai = GetCurrentAppInfo(FALSE);%@NL@%
        SemEnter();%@NL@%
        pci = (PCLIENTINFO)FarAllocMem(pai->hheapApp, sizeof(CLIENTINFO));%@NL@%
        SemLeave();%@NL@%
        if (pci == NULL) {%@NL@%
            pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
            return(1);          %@AB@%/* aboart creation - low memory */%@AE@%%@NL@%
        }%@NL@%
        WinSetWindowULong(hwnd, QWL_USER, (ULONG)pci);%@NL@%
        pci->ci.pai = pai;%@NL@%
        pci->ci.xad.state = CONVST_NULL;%@NL@%
        pci->ci.xad.pXferInfo = &defXferInfo;%@NL@%
        pci->ci.fs = 0;%@NL@%
        pci->ci.hwndPartner = NULL;%@NL@%
        pci->ci.hszServerApp = NULL;%@NL@%
        pci->ci.hszTopic = NULL;%@NL@%
        pci->pQ = NULL;    %@AB@%/* don't create until we need one */%@AE@%%@NL@%
        if (!(pci->ci.pAdviseList = CreateLst(pai->hheapApp, sizeof(ADVLI)))) {%@NL@%
            FarFreeMem(pai->hheapApp, (PBYTE)pci, sizeof(CLIENTINFO));%@NL@%
            pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
            return(1);          %@AB@%/* aboart creation - low memory */%@AE@%%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case UMCL_INITIATE:%@NL@%
        if (pci->ci.xad.state == CONVST_NULL) {%@NL@%
            return(ClientInitiate(hwnd, (PINITINFO)mp1, pci));%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DDE_INITIATEACK:%@NL@%
        InitAck(hwnd, pci, mp1, mp2);%@NL@%
        DosFreeSeg(SELECTOROF(mp2));%@NL@%
        return(1);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
        SemCheckOut();%@NL@%
        if (pci->ci.fs & ST_CONNECTED) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * stop any advises in progress%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (pci->ci.fs & ST_ADVISE) {%@NL@%
                pddes = AllocDDESel(0, 0, 0, 0L, NULL);%@NL@%
                MyDdePostMsg(pci->ci.hwndPartner, hwnd, WM_DDE_UNADVISE,%@NL@%
                        (PMYDDES)pddes, pci->ci.pai, MDPM_FREEHDATA);%@NL@%
            }%@NL@%
            WinSendMsg(hwnd, UMCL_TERMINATE, 0L, 0L);%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * decrement the use counts on hszs we are done with.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            FreeHsz(pci->ci.hszServerApp);%@NL@%
            FreeHsz(pci->ci.hszTopic);%@NL@%
        }%@NL@%
        %@NL@%
        DestroyLst(pci->ci.pAdviseList);%@NL@%
        %@NL@%
        SemEnter();%@NL@%
        DestroyQ(pci->pQ);%@NL@%
        FarFreeMem(pci->ci.pai->hheapApp, (PBYTE)pci, sizeof(CLIENTINFO));%@NL@%
        SemLeave();%@NL@%
        break;%@NL@%
%@NL@%
    case UMCL_TERMINATE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * terminates any conversation in progress%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (pci->ci.fs & ST_CONNECTED) {%@NL@%
            pci->ci.fs = pci->ci.fs & ~ST_CONNECTED;%@NL@%
            pci->ci.xad.state = CONVST_TERMINATED;%@NL@%
            if (WinIsWindow(DMGHAB, pci->ci.hwndPartner))%@NL@%
                WinDdePostMsg(pci->ci.hwndPartner, hwnd, WM_DDE_TERMINATE, 0L, FALSE);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case UMCL_XFER:%@NL@%
        if (!(pci->ci.fs & ST_CONNECTED)) {%@NL@%
            pci->ci.pai->LastError = DMGERR_NO_CONV_ESTABLISHED;%@NL@%
            return(0);%@NL@%
        }%@NL@%
        return(ClientXferReq((PXFERINFO)mp1, pci, hwnd));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DDE_DATA:%@NL@%
    case WM_DDE_ACK:%@NL@%
        DoClientDDEmsg(pci, hwnd, msg, (HWND)mp1, (PDDESTRUCT)mp2);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DDE_TERMINATE:%@NL@%
        SemCheckOut();%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * only respond if this is for us.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((HWND)mp1 != pci->ci.hwndPartner) {%@NL@%
           DosFreeSeg(SELECTOROF(mp2));%@NL@%
           break;%@NL@%
        }%@NL@%
        WinSendMsg(hwnd, UMCL_TERMINATE, 0L, 0L);%@NL@%
        DosFreeSeg(SELECTOROF(mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case UM_QUERY:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * LOUSHORT(mp1) = info index.%@NL@%
%@AB@%         * mp2 = pData.     If pData==0, return data else copy into pData.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
        case Q_STATUS:%@NL@%
             mrData = (MRESULT)pci->ci.fs;%@NL@%
             break;%@NL@%
%@NL@%
        case Q_CLIENT:%@NL@%
             mrData = TRUE;%@NL@%
             break;%@NL@%
%@NL@%
        case Q_APPINFO:%@NL@%
             mrData = pci->ci.pai;%@NL@%
             break;%@NL@%
%@NL@%
        case Q_APPNAME:%@NL@%
             mrData = *(PHSZ)PTOPPILEITEM(pci->ci.pai->pAppNamePile);%@NL@%
             break;%@NL@%
             %@NL@%
        case Q_ALL:%@NL@%
             mrData = (MRESULT)(CLIENTINFO FAR *)pci;%@NL@%
             break;%@NL@%
        }%@NL@%
        if (mp2 == 0)%@NL@%
            return(mrData);%@NL@%
        else%@NL@%
            *(MRESULT FAR *)mp2 = mrData;%@NL@%
        return(1);%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Client response to a WM_DDE_INITIATEACK message when expected.%@NL@%
%@AB@% */%@AE@%%@NL@%
void InitAck(hwnd, pci, hwndServer, pddei)%@NL@%
HWND hwnd;%@NL@%
PCLIENTINFO pci;%@NL@%
HWND hwndServer;%@NL@%
PDDEINIT pddei;%@NL@%
{%@NL@%
    SemCheckOut();%@NL@%
    %@NL@%
    if (pci->ci.fs & ST_CONNECTED) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * extra server - spawn another client window.  (we assume we%@NL@%
%@AB@%         * will only get extras if enumerating.)%@NL@%
%@AB@%         */%@AE@%%@NL@%
        AssertF(WinQueryWindow(hwnd, QW_PARENT, FALSE) != pci->ci.pai->hwndDmg,%@NL@%
            "Improper client spawn")%@NL@%
        if (hwndServer != pci->ci.hwndPartner) {%@NL@%
            WinSendMsg(hwndServer, WM_DDE_TERMINATE, hwnd, 0L);%@NL@%
            GetDDEClientWindow(WinQueryWindow(hwnd, QW_PARENT, FALSE),%@NL@%
                    hwndServer, hwndServer, pci->ci.hszServerApp,%@NL@%
                    pci->ci.hszTopic, &pci->ci.cc);%@NL@%
        }%@NL@%
        return;%@NL@%
    }%@NL@%
%@NL@%
    if (pci->ci.xad.state != CONVST_INIT1) %@NL@%
        return;%@NL@%
        %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * first one back... lock in!%@NL@%
%@AB@%     */%@AE@%%@NL@%
    pci->ci.hwndPartner = hwndServer;%@NL@%
    pci->ci.xad.state = CONVST_CONNECTED;%@NL@%
    pci->ci.fs |= ST_CONNECTED;%@NL@%
    if (WinQueryWindowPtr(hwndServer, QWP_PFNWP) == ServerWndProc) %@NL@%
        pci->ci.fs |= ST_INTRADLL;%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If the connection was made using a wild app name, we want to%@NL@%
%@AB@%     * hack in an apropriate name so QueryConvInfo can give the app%@NL@%
%@AB@%     * something useful to refer to this guy as.%@NL@%
%@AB@%     *%@NL@%
%@AB@%     * - the protocol is little help here.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pci->ci.hszServerApp == 0) {%@NL@%
        if (WinQueryWindowPtr(hwndServer, QWP_PFNWP) == ServerWndProc) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * one of ours! simple.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            pci->ci.hszServerApp = (PAPPINFO)WinSendMsg(pci->ci.hwndPartner,%@NL@%
                    UM_QUERY, (MPARAM)Q_APPNAME, 0L);%@NL@%
        } else {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Try the psz in pddei.  Maybe the server set it properly%@NL@%
%@AB@%             * before returning it.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (!(pci->ci.hszServerApp =%@NL@%
                    GetHsz(PSZAPP(pddei), pci->ci.cc.idCountry,%@NL@%
                            pci->ci.cc.usCodepage, TRUE))) {%@NL@%
                        %@NL@%
                PSZ pszT;%@NL@%
                USHORT cb;%@NL@%
                %@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * WORST CASE:%@NL@%
%@AB@%                 * Until a better way is found, we set the hszServerApp to%@NL@%
%@AB@%                 * the title of the frame window.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                if (pszT = FarAllocMem(pci->ci.pai->hheapApp,%@NL@%
                        cb = WinQueryWindowTextLength(pci->ci.hwndFrame) + 1)) {%@NL@%
                    WinQueryWindowText(pci->ci.hwndFrame, cb, (PSZ)pszT);%@NL@%
                    pci->ci.hszServerApp = GetHsz(pszT, pci->ci.cc.idCountry,%@NL@%
                            pci->ci.cc.usCodepage, TRUE);%@NL@%
                    FarFreeMem(pci->ci.pai->hheapApp, (PBYTE)pszT, cb);%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now what if the topic was wild?%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pci->ci.hszTopic == 0) {%@NL@%
        if (WinQueryWindowPtr(hwndServer, QWP_PFNWP) == ServerWndProc) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * one of ours! simple.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            pci->ci.hszTopic = (PAPPINFO)WinSendMsg(pci->ci.hwndPartner,%@NL@%
                    UM_QUERY, (MPARAM)Q_TOPIC, 0L);%@NL@%
        } else {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Try the psz in pddei.  Maybe the server set it properly%@NL@%
%@AB@%             * before returning it.  If this doesn't work were out of%@NL@%
%@AB@%             * luck, keep it wild.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            pci->ci.hszServerApp = GetHsz(PSZAPP(pddei), pci->ci.cc.idCountry,%@NL@%
                    pci->ci.cc.usCodepage, TRUE);%@NL@%
        }                %@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Processes a client transfer request issued by one of the ClientXfer%@NL@%
%@AB@%* functions.  This may be synchronous or asynchronous.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT ClientXferReq(pXferInfo, pci, hwnd)%@NL@%
PXFERINFO pXferInfo;%@NL@%
PCLIENTINFO pci;%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    PCQDATA pcqd;%@NL@%
    MRESULT retVal;%@NL@%
%@NL@%
    if (pXferInfo->ulTimeout == TIMEOUT_ASYNC) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * add a client queue item to track this transaction and return%@NL@%
%@AB@%         * the ID.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (pci->pQ == NULL)%@NL@%
            pci->pQ = CreateQ(sizeof(CQDATA));%@NL@%
        if (pci->pQ == NULL) {%@NL@%
            pci->ci.pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
            return(0);%@NL@%
        }%@NL@%
        pcqd = (PCQDATA)Addqi(pci->pQ);%@NL@%
        if (pcqd == NULL) {%@NL@%
            pci->ci.pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
            return(0);%@NL@%
        }%@NL@%
        CopyBlock((PBYTE)pXferInfo, (PBYTE)&pcqd->XferInfo, sizeof(XFERINFO));%@NL@%
        pcqd->xad.state = CONVST_CONNECTED;%@NL@%
        pcqd->xad.pddes = 0;%@NL@%
        pcqd->xad.LastError = DMGERR_NO_ERROR;%@NL@%
        pcqd->xad.pXferInfo = &pcqd->XferInfo;%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Get transaction started - if it fails, quit now.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((pcqd->xad.LastError = SendClientReq(&pcqd->xad,%@NL@%
                pci->ci.hwndPartner, hwnd, pci->ci.pai)) == DMGERR_SERVER_DIED) {%@NL@%
            pci->ci.fs = pci->ci.fs & ~ST_CONNECTED;%@NL@%
            Deleteqi(pci->pQ, MAKEID(pcqd));%@NL@%
            pci->ci.pai->LastError = DMGERR_SERVER_DIED;%@NL@%
            return(0);%@NL@%
        }%@NL@%
        return((MRESULT)MAKEID(pcqd));%@NL@%
    }%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * if not quiesent, yet synchronous, tell him were busy.%@NL@%
%@AB@%     * (this case could happen on a recursive call.)%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pci->ci.xad.state != CONVST_CONNECTED) {%@NL@%
        pci->ci.pai->LastError = DMGERR_BUSY;%@NL@%
        return(0);%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Set this so messages comming in during the conversation know whats up%@NL@%
%@AB@%     */%@AE@%%@NL@%
    pci->ci.xad.pXferInfo = pXferInfo;%@NL@%
    %@NL@%
    if ((pci->ci.pai->LastError = SendClientReq(&pci->ci.xad,%@NL@%
            pci->ci.hwndPartner, hwnd, pci->ci.pai)) == DMGERR_SERVER_DIED) {%@NL@%
        pci->ci.fs = pci->ci.fs & ~ST_CONNECTED;%@NL@%
    }%@NL@%
    %@NL@%
    if (pci->ci.pai->LastError != DMGERR_NO_ERROR)%@NL@%
        return(0);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     *  reset the LastError here so we know if we had problems while%@NL@%
%@AB@%     *  in the modal loop.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    pci->ci.pai->LastError = DMGERR_NO_ERROR;%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * timeout - modal loop.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!timeout(pci->ci.pai, pXferInfo->ulTimeout, hwnd)) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * reentrency or client has unregistered%@NL@%
%@AB@%         */%@AE@%%@NL@%
        return(0);%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * check results - lasterror already set by timeout().%@NL@%
%@AB@%     * Synchronous conversation must be reset to quiesent by the time we%@NL@%
%@AB@%     * give up.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pci->ci.xad.state == CONVST_INCOMPLETE) {%@NL@%
        pci->ci.xad.state = CONVST_CONNECTED;%@NL@%
        return(0);%@NL@%
    }%@NL@%
%@NL@%
    retVal = ClientXferRespond(pci, &pci->ci.xad, &pci->ci.pai->LastError);%@NL@%
    if (pci->ci.xad.state == CONVST_INCOMPLETE) %@NL@%
        pci->ci.xad.state = CONVST_CONNECTED;%@NL@%
        %@NL@%
    return(retVal);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
     %@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine sends the apropriate initiation messages for starting a%@NL@%
%@AB@%* client request according to the transaction data given.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
USHORT SendClientReq(pXad, hwndServer, hwnd, pai)     %@NL@%
PXADATA pXad;%@NL@%
HWND hwndServer;%@NL@%
HWND hwnd;%@NL@%
PAPPINFO pai;%@NL@%
{%@NL@%
    USHORT fsStatus = 0;%@NL@%
    USHORT msg;%@NL@%
    BOOL fCopy;%@NL@%
    PDDESTRUCT pddes;%@NL@%
    %@NL@%
    switch (pXad->pXferInfo->usType) {%@NL@%
    case XTYP_REQUEST:%@NL@%
        msg = WM_DDE_REQUEST;%@NL@%
        pXad->state = CONVST_REQSENT;%@NL@%
        fCopy = FALSE;%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_POKE:%@NL@%
        msg = WM_DDE_POKE;%@NL@%
        pXad->state = CONVST_POKESENT;%@NL@%
        fCopy = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_EXEC:%@NL@%
        msg = WM_DDE_EXECUTE;%@NL@%
        pXad->state = CONVST_EXECSENT;%@NL@%
        fCopy = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_ADVSTART:%@NL@%
    case XTYP_ADVSTART | XTYPF_NODATA:%@NL@%
    case XTYP_ADVSTART | XTYPF_ACKREQ:%@NL@%
    case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:%@NL@%
        fsStatus = pXad->pXferInfo->usType & (DDE_FACKREQ | DDE_FNODATA);%@NL@%
        msg = WM_DDE_ADVISE;%@NL@%
        pXad->state = CONVST_ADVSENT;%@NL@%
        fCopy = FALSE;%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_ADVSTOP:%@NL@%
        msg = WM_DDE_UNADVISE;%@NL@%
        pXad->state = CONVST_UNADVSENT;%@NL@%
        fCopy = FALSE;%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(DMGERR_INVALIDPARAMETER);%@NL@%
        break;%@NL@%
    }%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Send transfer%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((pddes = AllocDDESel(fsStatus, pXad->pXferInfo->usFmt,%@NL@%
            pXad->pXferInfo->hszItem, fCopy ? pXad->pXferInfo->cb : 0, NULL))%@NL@%
            == 0) {%@NL@%
        pXad->state = CONVST_CONNECTED;%@NL@%
        return(DMGERR_MEMORY_ERROR);%@NL@%
    }%@NL@%
%@NL@%
    if (fCopy)%@NL@%
        CopyHugeBlock((PBYTE)pXad->pXferInfo->pData, DDES_PABDATA(pddes),%@NL@%
                pXad->pXferInfo->cb);%@NL@%
%@NL@%
    if (WinIsWindow(DMGHAB, hwndServer)) {%@NL@%
        if (!MyDdePostMsg(hwndServer, hwnd, msg, (PMYDDES)pddes, pai, MDPM_FREEHDATA)) {%@NL@%
            pXad->state = CONVST_CONNECTED;%@NL@%
            return(DMGERR_POSTMSG_FAILED);%@NL@%
        }%@NL@%
    } else {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * We lost the server, we are TERMINATED arnold!%@NL@%
%@AB@%         */%@AE@%%@NL@%
        pXad->state = CONVST_TERMINATED;%@NL@%
        FreeData((PMYDDES)pddes, pai);%@NL@%
        return(DMGERR_SERVER_DIED);%@NL@%
    }%@NL@%
    return(DMGERR_NO_ERROR);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This handles client window processing of WM_DDE_ACK and WM_DDE_DATA msgs.%@NL@%
%@AB@%* On exit pddes is freed.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void DoClientDDEmsg(pci, hwnd, msg, hwndFrom, pddes)%@NL@%
PCLIENTINFO pci;%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
HWND hwndFrom;%@NL@%
PDDESTRUCT pddes;%@NL@%
{%@NL@%
    PCQDATA pqd;%@NL@%
    int i;%@NL@%
    HSZ hszItem;%@NL@%
    PADVLI pAdviseItem;%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * make sure its for us.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (hwndFrom != pci->ci.hwndPartner || !(pci->ci.fs & ST_CONNECTED)) {%@NL@%
        FreeData((PMYDDES)pddes, pci->ci.pai);%@NL@%
        return;%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Check if it fits the synchronous transaction data%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (fExpectedMsg(&pci->ci.xad, pddes, msg, pci)) {%@NL@%
        if (AdvanceXaction(hwnd, pci, &pci->ci.xad, pddes, msg,%@NL@%
                &pci->ci.pai->LastError))%@NL@%
            WinPostMsg(hwnd, WM_TIMER, (MPARAM)TID_TIMEOUT, 0L);%@NL@%
        return;%@NL@%
    }%@NL@%
     %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * See if it fits any asynchronous transaction data - if any exist%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pci->pQ != NULL && pci->pQ->pqiHead != NULL) {%@NL@%
        SemEnter();%@NL@%
        pqd = (PCQDATA)pci->pQ->pqiHead;%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * cycle from oldest to newest.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        for (i = pci->pQ->cItems; i; i--) {%@NL@%
            pqd = (PCQDATA)pqd->next;%@NL@%
            if (!fExpectedMsg(&pqd->xad, pddes, msg, pci))%@NL@%
                continue;%@NL@%
            if (AdvanceXaction(hwnd, pci, &pqd->xad, pddes, msg,%@NL@%
                    &pqd->xad.LastError)) {%@NL@%
                ClientXferRespond(pci, &pqd->xad, &pqd->xad.LastError);%@NL@%
                SemLeave();%@NL@%
                MakeCallback(pci->ci.pai, hwnd, (HSZ)0L, (HSZ)0L, 0,%@NL@%
                        XTYP_XFERCOMPLETE, (HDMGDATA)MAKEID(pqd),%@NL@%
                        0, 0, hwndFrom);%@NL@%
                return;%@NL@%
            }%@NL@%
            SemLeave();%@NL@%
            return;%@NL@%
        }%@NL@%
        SemLeave();%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * It doesn't fit anything, check for an advise data message.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (msg == WM_DDE_DATA) {%@NL@%
        hszItem = GetHszItem((PMYDDES)pddes, &pci->ci.cc, TRUE);%@NL@%
        if (pAdviseItem = (PADVLI)FindAdvList(pci->ci.pAdviseList, hszItem,%@NL@%
                pddes->usFormat)) {%@NL@%
            MakeCallback(pci->ci.pai, (HCONV)hwnd, pci->ci.hszTopic,%@NL@%
                hszItem, pddes->usFormat, XTYP_ADVDATA, pddes, msg,%@NL@%
                pddes->fsStatus, pci->ci.hwndPartner);%@NL@%
        } else {%@NL@%
            FreeHsz(hszItem);%@NL@%
        }%@NL@%
        return;%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * throw it away%@NL@%
%@AB@%     */%@AE@%%@NL@%
    FreeData((PMYDDES)pddes, pci->ci.pai);%@NL@%
    return;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine matches a conversation transaction with a DDE message.  If%@NL@%
%@AB@%* the state, usType, format, itemname dde structure data and the message%@NL@%
%@AB@%* received all agree, TRUE is returned.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL fExpectedMsg(pXad, pddes, msg, pci)%@NL@%
PXADATA pXad;%@NL@%
PDDESTRUCT pddes;%@NL@%
USHORT msg;%@NL@%
PCLIENTINFO pci;%@NL@%
{%@NL@%
    HSZ hsz = 0;%@NL@%
    BOOL fRet = FALSE;%@NL@%
    %@NL@%
    if (!(pXad->state > CONVST_INIT1 &&%@NL@%
            pddes->usFormat == pXad->pXferInfo->usFmt &&%@NL@%
            (hsz = GetHszItem((PMYDDES)pddes, &pci->ci.cc, TRUE)) ==%@NL@%
            pXad->pXferInfo->hszItem)) {%@NL@%
        goto Exit;%@NL@%
    }%@NL@%
    switch (pXad->state) {%@NL@%
    case CONVST_REQSENT:%@NL@%
        if (msg == WM_DDE_DATA && !(pddes->fsStatus & DDE_FRESPONSE))%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Not data in response to a request!%@NL@%
%@AB@%             */%@AE@%%@NL@%
            break;%@NL@%
        fRet = (msg == WM_DDE_ACK || msg == WM_DDE_DATA);%@NL@%
        break;%@NL@%
        %@NL@%
    case CONVST_POKESENT:%@NL@%
    case CONVST_EXECSENT:%@NL@%
    case CONVST_ADVSENT:%@NL@%
    case CONVST_UNADVSENT:%@NL@%
        fRet = (msg == WM_DDE_ACK);%@NL@%
        break;%@NL@%
    }%@NL@%
    %@NL@%
Exit:    %@NL@%
    FreeHsz(hsz);%@NL@%
    return(fRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This function assumes that msg is an apropriate message for the transaction%@NL@%
%@AB@%* referenced by pXad.  It acts on msg as apropriate.  pddes is the DDESTRUCT%@NL@%
%@AB@%* associated with msg.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns fSuccess ie: transaction is ready to close up.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL AdvanceXaction(hwnd, pci, pXad, pddes, msg, pErr)%@NL@%
HWND hwnd;%@NL@%
PCLIENTINFO pci;%@NL@%
PXADATA pXad;%@NL@%
PDDESTRUCT pddes;%@NL@%
USHORT msg;%@NL@%
PUSHORT pErr;%@NL@%
{%@NL@%
    switch (msg) {%@NL@%
    case WM_DDE_ACK:%@NL@%
        switch (pXad->state) {%@NL@%
        case CONVST_ADVSENT:%@NL@%
        case CONVST_EXECSENT:%@NL@%
        case CONVST_POKESENT:%@NL@%
        case CONVST_REQSENT:%@NL@%
        case CONVST_UNADVSENT:%@NL@%
            if (pddes->fsStatus & DDE_FACK) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * handle successes%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                switch (pXad->state) {%@NL@%
                case CONVST_POKESENT:%@NL@%
                    pXad->state = CONVST_POKEACKRCVD;%@NL@%
                    break;%@NL@%
%@NL@%
                case CONVST_EXECSENT:%@NL@%
                    pXad->state = CONVST_EXECACKRCVD;%@NL@%
                    break;%@NL@%
%@NL@%
                case CONVST_ADVSENT:%@NL@%
                    pXad->state = CONVST_ADVACKRCVD;%@NL@%
                    break;%@NL@%
%@NL@%
                case CONVST_UNADVSENT:%@NL@%
                    pXad->state = CONVST_UNADVACKRCVD;%@NL@%
                    break;%@NL@%
%@NL@%
                case CONVST_REQSENT:%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                     * requests are not expected to send a +ACK.  only%@NL@%
%@AB@%                     * -ACK or data.  We ignore a +ACK to a request.%@NL@%
%@AB@%                     */%@AE@%%@NL@%
                    FreeData((PMYDDES)pddes, pci->ci.pai);%@NL@%
                    return(FALSE);%@NL@%
                }%@NL@%
            } else {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * handle the expected ACK failures.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                *pErr = DMGERR_NOTPROCESSED;%@NL@%
                if (pddes->fsStatus & DDE_FBUSY)%@NL@%
                    *pErr = DMGERR_BUSY;%@NL@%
                pXad->state = CONVST_INCOMPLETE;%@NL@%
            }%@NL@%
        }%@NL@%
        FreeData((PMYDDES)pddes, pci->ci.pai);%@NL@%
        return(TRUE);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DDE_DATA:%@NL@%
        switch (pXad->state) {%@NL@%
        case CONVST_REQSENT:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * send an ack if requested - we dare not return the given%@NL@%
%@AB@%             * pddes because it may be a data item sent to several%@NL@%
%@AB@%             * clients and we would mess up the fsStatus word for%@NL@%
%@AB@%             * all processes involved.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (pddes->fsStatus & DDE_FACKREQ) {%@NL@%
                MyDdePostMsg(pci->ci.hwndPartner, hwnd, WM_DDE_ACK,%@NL@%
                        (PMYDDES)AllocDDESel(DDE_FACK, pddes->usFormat,%@NL@%
                        pXad->pXferInfo->hszItem, 0L, NULL),%@NL@%
                        pci->ci.pai, MDPM_FREEHDATA);%@NL@%
            }%@NL@%
            pXad->state = CONVST_DATARCVD;%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * We do NOT free the selector here yet because it will be %@NL@%
%@AB@%             * given to the client via pXad->pddes.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            pXad->pddes = pddes;%@NL@%
            return(TRUE);%@NL@%
            break;%@NL@%
        }%@NL@%
    }%@NL@%
    return(FALSE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
    %@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This function assumes that a client transfer request has been completed -%@NL@%
%@AB@%* or should be completed by the time this is called.%@NL@%
%@AB@%*%@NL@%
%@AB@%* pci contains general client info%@NL@%
%@AB@%* pXad contains the transaction info%@NL@%
%@AB@%* pErr points to where to place the LastError code.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns 0 on failure%@NL@%
%@AB@%* Returns TRUE or a Data Selector on success.%@NL@%
%@AB@%* On failure, the conversation is left in a CONVST_INCOMPLETE state.%@NL@%
%@AB@%* On success, the conversation is left in a CONVST_CONNECTED state.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/1/89    Sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT ClientXferRespond(pci, pXad, pErr)%@NL@%
PCLIENTINFO pci;%@NL@%
PXADATA pXad;%@NL@%
PUSHORT pErr;%@NL@%
{%@NL@%
    if (pXad->state == CONVST_INCOMPLETE) %@NL@%
        return(0);%@NL@%
        %@NL@%
    switch (pXad->pXferInfo->usType) {%@NL@%
    case XTYP_REQUEST:%@NL@%
        if (pXad->state != CONVST_DATARCVD) {%@NL@%
            if (*pErr == DMGERR_NO_ERROR)%@NL@%
                *pErr = DMGERR_DATAACKTIMEOUT;%@NL@%
            goto failexit;%@NL@%
        }%@NL@%
        pXad->state = CONVST_CONNECTED;%@NL@%
        return(pXad->pddes);%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_POKE:%@NL@%
        if (pXad->state != CONVST_POKEACKRCVD) {%@NL@%
            if (*pErr == DMGERR_NO_ERROR)%@NL@%
                *pErr = DMGERR_POKEACKTIMEOUT;%@NL@%
            goto failexit;%@NL@%
        }%@NL@%
        pXad->state = CONVST_CONNECTED;%@NL@%
        return(TRUE);%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_EXEC:%@NL@%
        if (pXad->state != CONVST_EXECACKRCVD) {%@NL@%
            if (*pErr == DMGERR_NO_ERROR)%@NL@%
                *pErr = DMGERR_EXECACKTIMEOUT;%@NL@%
            goto failexit;%@NL@%
        }%@NL@%
        pXad->state = CONVST_CONNECTED;%@NL@%
        return(TRUE);%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_ADVSTART:%@NL@%
    case XTYP_ADVSTART | XTYPF_NODATA:%@NL@%
    case XTYP_ADVSTART | XTYPF_ACKREQ:%@NL@%
    case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:%@NL@%
        if (pXad->state != CONVST_ADVACKRCVD) {%@NL@%
            if (*pErr == DMGERR_NO_ERROR)%@NL@%
                *pErr = DMGERR_ADVACKTIMEOUT;%@NL@%
            goto failexit;%@NL@%
        }%@NL@%
        if (!AddAdvList(pci->ci.pAdviseList, pXad->pXferInfo->hszItem,%@NL@%
                pXad->pXferInfo->usType & (DDE_FACKREQ | DDE_FNODATA),%@NL@%
                pXad->pXferInfo->usFmt)) {%@NL@%
            pXad->state = CONVST_INCOMPLETE;%@NL@%
            pci->ci.pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
            return(FALSE);%@NL@%
        } else {%@NL@%
            pXad->state = CONVST_CONNECTED;%@NL@%
            pci->ci.fs |= ST_ADVISE;%@NL@%
            return(TRUE);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_ADVSTOP:%@NL@%
        if (pXad->state != CONVST_UNADVACKRCVD) {%@NL@%
            if (*pErr == DMGERR_NO_ERROR)%@NL@%
                *pErr = DMGERR_UNADVACKTIMEOUT;%@NL@%
            goto failexit;%@NL@%
        }%@NL@%
        if (!DeleteAdvList(pci->ci.pAdviseList, pXad->pXferInfo->hszItem,%@NL@%
                pXad->pXferInfo->usFmt))%@NL@%
            pci->ci.fs &= ~ST_ADVISE;%@NL@%
        pXad->state = CONVST_CONNECTED;%@NL@%
        return(TRUE);%@NL@%
        break;%@NL@%
%@NL@%
    }%@NL@%
    %@NL@%
failexit:%@NL@%
    pXad->state = CONVST_INCOMPLETE;%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * ----------------------------SERVER SECTION--------------------------------%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* MRESULT EXPENTRY ServerWndProc(hwnd, msg, mp1, mp2)%@NL@%
%@AB@%* HWND hwnd;%@NL@%
%@AB@%* USHORT msg;%@NL@%
%@AB@%* MPARAM mp1;%@NL@%
%@AB@%* MPARAM mp2;%@NL@%
%@AB@%*%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   This processes DDE conversations from the server end.%@NL@%
%@AB@%*   It stores internal information and acts much like a state machine.%@NL@%
%@AB@%*   If closed, it will automaticly abort any conversation in progress.%@NL@%
%@AB@%*   It also maintains an internal list of all items which currently are%@NL@%
%@AB@%*   in active ADVISE loops.%@NL@%
%@AB@%* PUBDOC START%@NL@%
%@AB@%*   These server windows have the feature that a conversation can be%@NL@%
%@AB@%*   re-initiated with them by a client.  The Client merely terminates%@NL@%
%@AB@%*   the conversation and then re-initiates by using a SendMsg to this%@NL@%
%@AB@%*   window.  This allows a client to change the topic of the conversation%@NL@%
%@AB@%*   or to pass the conversation on to another client window without%@NL@%
%@AB@%*   loosing the server it initiated with.   This is quite useful for%@NL@%
%@AB@%*   wild initiates.%@NL@%
%@AB@%* PUBDOC END%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%* 10/18/89 sanfords Added hack to make hszItem==0L when offszItem==offabData.%@NL@%
%@AB@%* 1/4/89   sanfords created %@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY ServerWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
%@AI@%#define %@AE@%PDDES ((PDDESTRUCT)mp2)     %@NL@%
    register PSERVERINFO psi;%@NL@%
    MPARAM mrData;%@NL@%
    PADVLI pAdviseItem;%@NL@%
    PSZ pszApp, pszTopic;%@NL@%
    HSZ hsz;%@NL@%
    USHORT cchApp, cchTopic;%@NL@%
    USHORT usType;%@NL@%
    HDMGDATA hDmgData = 0L;%@NL@%
    BOOL fResult;%@NL@%
    %@NL@%
%@NL@%
    psi = (PSERVERINFO)WinQueryWindowULong(hwnd, QWL_USER);%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_DDE_REQUEST:%@NL@%
    case WM_DDE_ACK:%@NL@%
    case WM_DDE_ADVISE:%@NL@%
    case WM_DDE_UNADVISE:%@NL@%
    case WM_DDE_POKE:%@NL@%
    case WM_DDE_EXECUTE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * only respond if this is for us.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((HWND)mp1 != psi->ci.hwndPartner || !(psi->ci.fs & ST_CONNECTED)) {%@NL@%
            FreeData((PMYDDES)mp2, psi->ci.pai);%@NL@%
            return(0);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_CREATE: {%@NL@%
            PAPPINFO pai;%@NL@%
            %@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * allocate and initialize the server window info.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            pai = GetCurrentAppInfo(FALSE);%@NL@%
            SemEnter();%@NL@%
%@NL@%
            if (!(psi = (PSERVERINFO)FarAllocMem(pai->hheapApp, sizeof(SERVERINFO))))%@NL@%
                goto LowMem;%@NL@%
            FillBlock((PBYTE)&psi->ci, sizeof(COMMONINFO), 0);%@NL@%
            if (!(psi->ci.pAdviseList = CreateLst(pai->hheapApp, sizeof(ADVLI)))) {%@NL@%
                FarFreeMem(pai->hheapApp, (PBYTE)psi, sizeof(SERVERINFO));%@NL@%
LowMem:                        %@NL@%
                pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
                SemLeave();%@NL@%
                return(1);          %@AB@%/* abort creation - low memory */%@AE@%%@NL@%
            }%@NL@%
            SemLeave();%@NL@%
            psi->ci.pai = pai;%@NL@%
            psi->ci.xad.state = CONVST_NULL;%@NL@%
            WinSetWindowULong(hwnd, QWL_USER, (ULONG)psi);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case UMSR_INITIATE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * This was sent by the subclassed frame of the server app.%@NL@%
%@AB@%         * The frame has already queried the server for permission%@NL@%
%@AB@%         * to create this window.%@NL@%
%@AB@%         *%@NL@%
%@AB@%         * If mp2 is NULL, this is a hot server window waiting for%@NL@%
%@AB@%         * a WM_DDE_INITIATE.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@AI@%#define %@AE@%pii ((PINITINFO)mp1)          %@NL@%
        IncHszCount(psi->ci.hszServerApp = pii->hszAppName);%@NL@%
        IncHszCount(psi->ci.hszTopic = pii->hszTopic);%@NL@%
        psi->ci.hwndPartner = (HWND)mp2;%@NL@%
        psi->ci.hwndFrame = FindFrame(psi->ci.hwndPartner);%@NL@%
        psi->ci.cc.fsContext = pii->pCC->fsContext;%@NL@%
        psi->ci.cc.idCountry = pii->pCC->idCountry;%@NL@%
        psi->ci.cc.usCodepage = pii->pCC->usCodepage;%@NL@%
        psi->ci.fs |= ST_CONNECTED;%@NL@%
        psi->ci.xad.state = CONVST_CONNECTED;%@NL@%
        %@NL@%
        SemEnter();%@NL@%
        pszApp = pszFromHsz(psi->ci.hszServerApp, &cchApp);%@NL@%
        pszTopic = pszFromHsz(psi->ci.hszTopic, &cchTopic);%@NL@%
        SemLeave();%@NL@%
%@NL@%
        if (mp2)%@NL@%
            WinDdeRespond((HWND)mp2, hwnd, pszApp, pszTopic);%@NL@%
        %@NL@%
        SemEnter();%@NL@%
        FarFreeMem(hheapDmg, (PBYTE)pszApp, cchApp);%@NL@%
        FarFreeMem(hheapDmg, (PBYTE)pszTopic, cchTopic);%@NL@%
        SemLeave();%@NL@%
        %@NL@%
        return(1);%@NL@%
%@AI@%#undef %@AE@%pii         %@NL@%
        break;%@NL@%
%@NL@%
    case WM_DDE_INITIATE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * This will happen when a client tries to re-initiate a conversation%@NL@%
%@AB@%         * with this server.  We allow about 10 seconds after termination%@NL@%
%@AB@%         * for another client to connect specifically with this window.%@NL@%
%@AB@%         * This allows a client to swap windows on its end of the conversation.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        if (psi->ci.xad.state == CONVST_TERMINATED &&%@NL@%
                (psi->ci.hszServerApp == GetHsz(PSZAPP(mp2), psi->ci.cc.idCountry,%@NL@%
                        psi->ci.cc.usCodepage, FALSE))) {%@NL@%
                    %@NL@%
            WinStopTimer(DMGHAB, hwnd, TID_SELFDESTRUCT);%@NL@%
            hsz = psi->ci.hszTopic;%@NL@%
            psi->ci.hszTopic = GetHsz(PSZTOPIC(mp2), psi->ci.cc.idCountry,%@NL@%
                    psi->ci.cc.usCodepage, TRUE);%@NL@%
            FreeHsz(hsz);%@NL@%
            psi->ci.hwndPartner = (HWND)mp1;%@NL@%
            psi->ci.hwndFrame = FindFrame(psi->ci.hwndPartner);%@NL@%
            psi->ci.fs |= ST_CONNECTED;%@NL@%
            psi->ci.xad.state = CONVST_CONNECTED;%@NL@%
            if (WinQueryWindowPtr(psi->ci.hwndPartner, QWP_PFNWP) == ClientWndProc) %@NL@%
                psi->ci.fs |= ST_INTRADLL;%@NL@%
            WinDdeRespond((HWND)mp1, hwnd, PSZAPP(mp2), PSZTOPIC(mp2));%@NL@%
            fResult = TRUE;%@NL@%
        } else%@NL@%
            fResult = FALSE;%@NL@%
            %@NL@%
        FreeData((PMYDDES)mp2, psi->ci.pai);%@NL@%
        return(fResult);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DDE_TERMINATE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * only respond if this is for us.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((HWND)mp1 != psi->ci.hwndPartner) %@NL@%
            break;%@NL@%
        %@AB@%/* fall through */%@AE@%%@NL@%
%@NL@%
    case UMSR_TERMINATE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * terminates any conversation in progress%@NL@%
%@AB@%         * Note that we keep around all the other conversation data so%@NL@%
%@AB@%         * a later re-connection is possible.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (psi->ci.fs & ST_CONNECTED) {%@NL@%
            psi->ci.fs &= ~ST_CONNECTED;%@NL@%
            psi->ci.xad.state = CONVST_TERMINATED;%@NL@%
            if (WinIsWindow(DMGHAB, psi->ci.hwndPartner))%@NL@%
                WinDdePostMsg(psi->ci.hwndPartner, hwnd, WM_DDE_TERMINATE, 0L, FALSE);%@NL@%
        }%@NL@%
        if (psi->ci.fs & ST_ADVISE) {%@NL@%
            FlushLst(psi->ci.pAdviseList);%@NL@%
            psi->ci.fs &= ~ST_ADVISE;%@NL@%
        }%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Mr. Phelps, if this window isn't reconnected within 10 odd%@NL@%
%@AB@%         * seconds, it will self-destruct.  This gives the client time%@NL@%
%@AB@%         * to reconnect with another client window.  This often happens%@NL@%
%@AB@%         * with wild initiates.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinStartTimer(DMGHAB, hwnd, TID_SELFDESTRUCT, 0xa000);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_TIMER:%@NL@%
        if (LOUSHORT(mp1) == TID_SELFDESTRUCT && !(psi->ci.fs & ST_CONNECTED))%@NL@%
            DestroyWindow(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
        SemCheckOut();%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Send ourselves a terminate and free local data.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinSendMsg(hwnd, UMSR_TERMINATE, 0L, 0L);%@NL@%
        MakeCallback(psi->ci.pai, hwnd, psi->ci.hszTopic, (HSZ)NULL, 0, XTYP_TERM,%@NL@%
                0L, 0, 0, psi->ci.hwndPartner);%@NL@%
        SemEnter();%@NL@%
        DestroyLst(psi->ci.pAdviseList);%@NL@%
        FreeHsz(psi->ci.hszServerApp);%@NL@%
        FreeHsz(psi->ci.hszTopic);%@NL@%
        FarFreeMem(psi->ci.pai->hheapApp, (PBYTE)psi, sizeof(SERVERINFO));%@NL@%
        SemLeave();%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DDE_REQUEST:%@NL@%
        usType = XTYP_REQUEST;%@NL@%
        goto Callback;%@NL@%
        %@NL@%
    case WM_DDE_EXECUTE:%@NL@%
        usType = XTYP_EXEC;%@NL@%
        hDmgData = mp2;%@NL@%
        goto Callback;%@NL@%
        %@NL@%
    case WM_DDE_POKE:%@NL@%
        usType = XTYP_POKE;%@NL@%
        hDmgData = mp2;%@NL@%
        goto Callback;%@NL@%
        %@NL@%
    case WM_DDE_ADVISE:%@NL@%
        usType = XTYP_ADVSTART; %@AB@%/* set ST_ADVISE AFTER app oks advise loop */%@AE@%%@NL@%
        goto Callback;%@NL@%
        %@NL@%
    case WM_DDE_UNADVISE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Terminate the advise now, but notify the server in callback so%@NL@%
%@AB@%         * messages don't get out of order.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (!DeleteAdvList(psi->ci.pAdviseList,%@NL@%
                GetHszItem(mp2, &psi->ci.cc, FALSE),%@NL@%
                PDDES->usFormat))%@NL@%
            psi->ci.fs &= ~ST_ADVISE;%@NL@%
        usType = XTYP_ADVSTOP;%@NL@%
        goto Callback;%@NL@%
        %@NL@%
    case WM_DDE_ACK:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * This is an ack in response to the FACKREQ bit being set.%@NL@%
%@AB@%         * See if this refers to one of the advise loops.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((pAdviseItem = FindAdvList(psi->ci.pAdviseList,%@NL@%
                GetHszItem(mp2, &psi->ci.cc, FALSE),%@NL@%
                PDDES->usFormat)) &&%@NL@%
                (pAdviseItem->fsStatus & DDE_FACKREQ)) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Update advise loop status - no longer waiting for an ack.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            pAdviseItem->fsStatus &= ~ADVST_WAITING;%@NL@%
            if (pAdviseItem->fsStatus & ADVST_CHANGED) {%@NL@%
                pAdviseItem->fsStatus |= ADVST_POSTED; %@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * The client is out of date.  Send the data%@NL@%
%@AB@%                 * again (simulate a post advise call).%@NL@%
%@AB@%                 * Don't bother the server with ACK info.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                MakeCallback(psi->ci.pai, (HCONV)hwnd, psi->ci.hszTopic,%@NL@%
                        pAdviseItem->hszItem, %@NL@%
                        pAdviseItem->usFmt, XTYP_ADVREQ, %@NL@%
                        0L, UMSR_POSTADVISE,%@NL@%
                        pAdviseItem->fsStatus & ~DDE_FRESERVED,%@NL@%
                        psi->ci.hwndPartner);%@NL@%
                FreeData((PMYDDES)mp2, psi->ci.pai);%@NL@%
                return(0);%@NL@%
            }%@NL@%
        }%@NL@%
        usType = XTYP_ACK;%@NL@%
        hDmgData = PDDES->fsStatus;%@NL@%
        %@NL@%
Callback:        %@NL@%
        MakeCallback(psi->ci.pai, (HCONV)hwnd, psi->ci.hszTopic,%@NL@%
%@AI@%#if %@AE@%0 %@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * hack for EXCEL which makes its items and data equal for%@NL@%
%@AB@%                 * execute acks which SHOULD use NULL as the item name.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                (PDDES->offszItemName == PDDES->offabData) ?%@NL@%
                    0L :%@NL@%
%@AI@%#endif %@AE@%%@NL@%
                GetHszItem((PMYDDES)mp2, &psi->ci.cc, TRUE),%@NL@%
                PDDES->usFormat, usType,%@NL@%
                hDmgData, msg, PDDES->fsStatus,%@NL@%
                psi->ci.hwndPartner);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * now free the incomming selector IF it wasn't passed on to%@NL@%
%@AB@%         * MakeCallback as hDmgData.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (hDmgData != mp2)%@NL@%
            FreeData((PMYDDES)mp2, psi->ci.pai);%@NL@%
        break;%@NL@%
        %@NL@%
    case UMSR_POSTADVISE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * This message came from DdePostAdvise()%@NL@%
%@AB@%         *%@NL@%
%@AB@%         * Advise loops are tricky because of the desireable FACKREQ feature%@NL@%
%@AB@%         * of DDE.  The advise loop list holds information in its fsStatus%@NL@%
%@AB@%         * field to maintain the state of the advise loop.%@NL@%
%@AB@%         *%@NL@%
%@AB@%         * if the ADVST_POSTED bit is set, it means that the server already%@NL@%
%@AB@%         * has an ADVREQ message in its callback queue.  This prevents%@NL@%
%@AB@%         * unnecessary ADVREQ messages from getting thrown into the callback%@NL@%
%@AB@%         * queue.%@NL@%
%@AB@%         *%@NL@%
%@AB@%         * if the ADVST_WAITING bit is set, the server is still waiting for%@NL@%
%@AB@%         * the client to give it the go-ahead for more data with an%@NL@%
%@AB@%         * ACK message on this item. (FACKREQ is set)  Without a go-ahead,%@NL@%
%@AB@%         * the server will not send any more advise data to the client but%@NL@%
%@AB@%         * will instead set the ADVST_CHANGED bit which will cause another%@NL@%
%@AB@%         * WM_DDE_DATA message to be sent to the client as soon as the%@NL@%
%@AB@%         * go-ahead ACK is received.  This keeps the client up to date%@NL@%
%@AB@%         * but never overloads it.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        if (!(psi->ci.fs & ST_ADVISE) ||%@NL@%
                !(pAdviseItem = FindAdvList(psi->ci.pAdviseList, (HSZ)mp1, 0)))%@NL@%
            break;%@NL@%
%@NL@%
        do {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * for each format for this item that has an advise loop:%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (pAdviseItem->fsStatus & ADVST_POSTED)%@NL@%
                continue;%@NL@%
                %@NL@%
            if ((pAdviseItem->fsStatus & DDE_FACKREQ) &&%@NL@%
                    (pAdviseItem->fsStatus & ADVST_WAITING)) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * if the client has not yet finished with the last data%@NL@%
%@AB@%                 * we gave him, just update the advise loop status%@NL@%
%@AB@%                 * instead of sending data now.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                pAdviseItem->fsStatus |= ADVST_CHANGED;%@NL@%
                continue;%@NL@%
            }%@NL@%
            if (pAdviseItem->fsStatus & DDE_FNODATA) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * In the nodata case, we don't bother the server.  Just%@NL@%
%@AB@%                 * pass the client an apropriate DATA message.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                MyDdePostMsg(psi->ci.hwndPartner, hwnd, WM_DDE_DATA,%@NL@%
                        (PMYDDES)AllocDDESel(pAdviseItem->fsStatus & ~(DDE_FNODATA | DDE_FACKREQ),%@NL@%
                        pAdviseItem->usFmt, (HSZ)mp1, 0L, 0),%@NL@%
                        psi->ci.pai, MDPM_FREEHDATA);%@NL@%
                continue;%@NL@%
            }%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Otherwise, lets get the data from the server.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            pAdviseItem->fsStatus |= ADVST_POSTED;%@NL@%
            MakeCallback(psi->ci.pai, (HCONV)hwnd, psi->ci.hszTopic,%@NL@%
                    (HSZ)mp1, pAdviseItem->usFmt, XTYP_ADVREQ,%@NL@%
                    0, UMSR_POSTADVISE,%@NL@%
                    pAdviseItem->fsStatus & (DDE_FACKREQ | DDE_FNODATA),%@NL@%
                    psi->ci.hwndPartner);%@NL@%
        } while (pAdviseItem = FindNextAdv(pAdviseItem, (HSZ)mp1));%@NL@%
        break;%@NL@%
%@NL@%
    case UM_QUERY:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * LOUSHORT(mp1) = info index.%@NL@%
%@AB@%         * mp2 = pData.     If pData==0, return data else copy into pData.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
        case Q_STATUS:%@NL@%
             mrData = (MRESULT)psi->ci.fs;%@NL@%
             break;%@NL@%
%@NL@%
        case Q_CLIENT:%@NL@%
             mrData = FALSE;%@NL@%
             break;%@NL@%
%@NL@%
        case Q_APPINFO:%@NL@%
             mrData = psi->ci.pai;%@NL@%
             break;%@NL@%
              %@NL@%
        case Q_APPNAME:%@NL@%
             mrData = psi->ci.hszServerApp;%@NL@%
             break;%@NL@%
%@NL@%
        case Q_TOPIC:%@NL@%
             mrData = psi->ci.hszTopic;%@NL@%
             break;%@NL@%
             %@NL@%
        case Q_ALL:%@NL@%
             mrData = (MRESULT)(SERVERINFO FAR *)psi;%@NL@%
             break;%@NL@%
        }%@NL@%
        if (mp2 == 0)%@NL@%
            return(mrData);%@NL@%
        else%@NL@%
            *(MRESULT FAR *)mp2 = mrData;%@NL@%
        return(1);%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
%@AI@%#undef %@AE@%PDDES     %@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This assumes hwnd is a DDE window.  It tries to locate the proper%@NL@%
%@AB@% * top-level frame window that this window is associated with useing%@NL@%
%@AB@% * process and thread IDs.%@NL@%
%@AB@% */%@AE@%%@NL@%
HWND FindFrame(%@NL@%
HWND hwnd)%@NL@%
{%@NL@%
    PID pid, pidFrame;%@NL@%
    TID tid, tidFrame;%@NL@%
    HWND hwndMaybe = NULL;%@NL@%
    HWND hwndBetter = NULL;%@NL@%
    HWND hwndFrame;%@NL@%
    HENUM hEnum;%@NL@%
    ULONG ul;%@NL@%
    %@NL@%
    WinQueryWindowProcess(hwnd, &pid, &tid);%@NL@%
    hEnum = WinBeginEnumWindows(HWND_DESKTOP);%@NL@%
    while (hwndFrame = WinGetNextWindow(hEnum)) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * for all top level windows ...%@NL@%
%@AB@%         */%@AE@%%@NL@%
        ul = (ULONG)WinSendMsg(hwndFrame, WM_QUERYFRAMEINFO, 0L, 0L);%@NL@%
        if (FI_FRAME & ul) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * that are frames ...%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinQueryWindowProcess(hwndFrame, &pidFrame, &tidFrame);%@NL@%
            if (pidFrame == pid) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * in this process - maybe - ...%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                hwndMaybe = hwndFrame;%@NL@%
                if (tidFrame == tid) {%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                     * in this thread - better - ...%@NL@%
%@AB@%                     */%@AE@%%@NL@%
                    hwndBetter = hwndFrame;%@NL@%
                    if (WinQueryWindowPtr(hwndFrame, QWP_PFNWP) ==%@NL@%
                            subframeWndProc) {%@NL@%
                        %@AB@%/*%@NL@%
%@AB@%                         * that are subclassed by us - certainly!%@NL@%
%@AB@%                         */%@AE@%%@NL@%
                        hwndBetter = hwndFrame;%@NL@%
                        break;%@NL@%
                    }%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
    WinEndEnumWindows(hEnum);%@NL@%
    return(hwndBetter ? hwndBetter : hwndMaybe);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This routine handles server message replys.  This may have been called%@NL@%
%@AB@%* immediately in the case of enabled callbacks, or may have been called%@NL@%
%@AB@%* via DdeEnableCallback in which case the server action has been%@NL@%
%@AB@%* delayed.  QReply is responsible for freeing the pddes given as well as%@NL@%
%@AB@%* the pcbi->hDmgData and pcbi->hszItem.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*   Created     9/12/89    Sanfords%@NL@%
%@AB@%*   6/12/90 sanfords    Added checks for HDATA ownership.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void QReply(pcbi, pddes)%@NL@%
PCBLI pcbi;%@NL@%
PDDESTRUCT pddes;   %@AB@%/* hDataRet */%@AE@%%@NL@%
{%@NL@%
    PSERVERINFO psi;%@NL@%
    PADVLI pAdviseItem;%@NL@%
    USHORT fsStatus, msg;%@NL@%
%@NL@%
    if ((pcbi->usType & XCLASS_MASK) == XCLASS_NOTIFICATION)%@NL@%
        return;%@NL@%
%@NL@%
    SemCheckOut();%@NL@%
    psi = WinSendMsg(pcbi->hConv, UM_QUERY, (MPARAM)Q_ALL, 0L);%@NL@%
    %@NL@%
    switch (pcbi->msg) {%@NL@%
    case UMSR_POSTADVISE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * The NODATA case never gets here.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((psi) &&%@NL@%
                (pAdviseItem = FindAdvList(psi->ci.pAdviseList, pcbi->hszItem,%@NL@%
                pcbi->usFmt))) {%@NL@%
            pAdviseItem->fsStatus &= ~ADVST_POSTED;%@NL@%
            if (pddes) {%@NL@%
                pAdviseItem->fsStatus &= ~ADVST_CHANGED;%@NL@%
                MyDdePostMsg(pcbi->hConvPartner, pcbi->hConv, WM_DDE_DATA,%@NL@%
                        (PMYDDES)pddes, psi->ci.pai, MDPM_FREEHDATA);%@NL@%
                if (pAdviseItem->fsStatus & DDE_FACKREQ) %@NL@%
                    pAdviseItem->fsStatus |= ADVST_WAITING;%@NL@%
            }%@NL@%
        }%@NL@%
        break;%@NL@%
            %@NL@%
    case WM_DDE_REQUEST:%@NL@%
        if (pddes) {%@NL@%
            pddes->fsStatus = (pcbi->fsStatus & DDE_FACKREQ) | DDE_FRESPONSE;%@NL@%
            msg = WM_DDE_DATA;%@NL@%
        } else {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * send a -ACK%@NL@%
%@AB@%             */%@AE@%%@NL@%
            pddes = AllocDDESel(((USHORT)pddes & DDE_FAPPSTATUS) |%@NL@%
                    ((USHORT)pddes & DDE_FBUSY ? DDE_FBUSY : DDE_NOTPROCESSED),%@NL@%
                    pcbi->usFmt, pcbi->hszItem, 0L, NULL);%@NL@%
            msg = WM_DDE_ACK;%@NL@%
        }%@NL@%
        MyDdePostMsg(pcbi->hConvPartner, pcbi->hConv, msg, (PMYDDES)pddes,%@NL@%
                psi->ci.pai, MDPM_FREEHDATA);%@NL@%
        break;%@NL@%
        %@NL@%
    case WM_DDE_POKE:%@NL@%
    case WM_DDE_EXECUTE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * pddes is supposed to be the proper DDE_ constants to return.%@NL@%
%@AB@%         * we just stick them in the given pddes (hDmgData) and return%@NL@%
%@AB@%         * it as an ACK.  This frees pcbi->hDmgData in the process.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        ((PDDESTRUCT)pcbi->hDmgData)->fsStatus = %@NL@%
                (USHORT)pddes & ~DDE_FRESERVED;%@NL@%
        MyDdePostMsg(pcbi->hConvPartner, pcbi->hConv, WM_DDE_ACK,%@NL@%
                (PMYDDES)pcbi->hDmgData, psi->ci.pai, MDPM_FREEHDATA);%@NL@%
        break;%@NL@%
        %@NL@%
    case WM_DDE_ADVISE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * pddes is fStartAdvise%@NL@%
%@AB@%         * If DDE_FACK, we add the item to the advise loop%@NL@%
%@AB@%         * list and +ACK else we -ACK.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((BOOL)pddes) {%@NL@%
            psi = (PSERVERINFO)WinQueryWindowULong(pcbi->hConv, QWL_USER);%@NL@%
            if (AddAdvList(psi->ci.pAdviseList, pcbi->hszItem,%@NL@%
                    pcbi->fsStatus & (DDE_FNODATA | DDE_FACKREQ),%@NL@%
                    pcbi->usFmt) == NULL) {%@NL@%
                psi->ci.pai->LastError = DMGERR_MEMORY_ERROR;%@NL@%
                fsStatus = DDE_NOTPROCESSED;%@NL@%
            } else {%@NL@%
                psi->ci.fs |= ST_ADVISE;%@NL@%
                fsStatus = DDE_FACK;%@NL@%
            }%@NL@%
        } else {%@NL@%
            fsStatus = DDE_NOTPROCESSED;%@NL@%
        }%@NL@%
        goto AckBack;%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DDE_UNADVISE:%@NL@%
        fsStatus = DDE_FACK;%@NL@%
        goto AckBack;%@NL@%
        break;%@NL@%
    %@NL@%
    case WM_DDE_DATA:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * must be an advise data item for the CLIENT or maybe some requested%@NL@%
%@AB@%         * data mistakenly sent here due to the client queue being flushed.%@NL@%
%@AB@%         * pddes is fsStatus.%@NL@%
%@AB@%         *%@NL@%
%@AB@%         * send an ack back if requested.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (pcbi->fsStatus & DDE_FACKREQ) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Clean up the status incase the app is messed up.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            fsStatus = (USHORT)pddes & ~DDE_FRESERVED;%@NL@%
            if (fsStatus & (DDE_NOTPROCESSED | DDE_FBUSY))%@NL@%
                fsStatus &= ~DDE_FACK;%@NL@%
AckBack:%@NL@%
            MyDdePostMsg(pcbi->hConvPartner, pcbi->hConv, WM_DDE_ACK,%@NL@%
                (PMYDDES)AllocDDESel(fsStatus, pcbi->usFmt, pcbi->hszItem, 0L, 0),%@NL@%
                psi->ci.pai, MDPM_FREEHDATA);%@NL@%
        }%@NL@%
        break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * ----------------FRAME SECTION------------------%@NL@%
%@AB@% *%@NL@%
%@AB@% * A frame window exists on behalf of every registered thread.  It%@NL@%
%@AB@% * handles conversation initiation and therefore issues callbacks%@NL@%
%@AB@% * to the server app as needed to notify or query the server app.%@NL@%
%@AB@% * The callback queue is always bypassed for these synchronous%@NL@%
%@AB@% * events.%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* MRESULT EXPENTRY subframeWndProc(hwnd, msg, mp1, mp2)%@NL@%
%@AB@%* HWND hwnd;%@NL@%
%@AB@%* USHORT msg;%@NL@%
%@AB@%* MPARAM mp1;%@NL@%
%@AB@%* MPARAM mp2;%@NL@%
%@AB@%*%@NL@%
%@AB@%* This routine takes care of setting up server windows as needed to respond%@NL@%
%@AB@%* to incomming WM_DDE_INTIIATE messages.  It is subclassed from the top%@NL@%
%@AB@%* level frame of the server application.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  created 12/20/88    sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY subframeWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    PAPPINFO pai;%@NL@%
%@NL@%
    pai = GetCurrentAppInfo(FALSE);%@NL@%
    %@NL@%
    switch (msg) {%@NL@%
    case UM_REGISTER:%@NL@%
    case UM_UNREGISTER:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * we pass notification messages through this proc so we can make the%@NL@%
%@AB@%         * xfer call within the correct thread's context.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        MakeCallback(pai, (HCONV)0, (HSZ)0, (HSZ)mp1, 0,%@NL@%
                msg == UM_REGISTER ? XTYP_REGISTER : XTYP_UNREGISTER,%@NL@%
                (HDMGDATA)mp2, msg, 0, 0L);%@NL@%
        return(0);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DDE_INITIATE:%@NL@%
        FrameInitConv((HWND)mp1, (PDDEINIT)mp2);%@NL@%
        FreeData((PMYDDES)mp2, pai);%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return((*lpfnFrameWndProc)(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
void FrameInitConv(hwndClient, pddei)%@NL@%
HWND hwndClient;%@NL@%
PDDEINIT pddei;%@NL@%
{%@NL@%
    PAPPINFO pai, paiClient;%@NL@%
    INITINFO ii;%@NL@%
    HSZPAIR hp[2];%@NL@%
    PHSZPAIR php;%@NL@%
    HSZ hsz = 0;%@NL@%
    HDMGDATA hDataCC;%@NL@%
    PDDESTRUCT pddes;%@NL@%
    HWND hwndServer;%@NL@%
    CONVCONTEXT cc;%@NL@%
    BOOL fWild;%@NL@%
%@NL@%
    if (!CheckSel(SELECTOROF(pddei))) {%@NL@%
        AssertF(FALSE, "Invalid DDEINIT selector");%@NL@%
        return;%@NL@%
    }%@NL@%
    %@NL@%
    SemCheckOut();%@NL@%
    %@NL@%
    pai = GetCurrentAppInfo(FALSE);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If we are filtering and no app names are registered, quit.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((pai->afCmd & DMGCMD_FILTERINITS) &&%@NL@%
            QPileItemCount(pai->pAppNamePile) == 0) %@NL@%
        return;%@NL@%
        %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * filter out inits from ourselves and other agents (if we are an agent)%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (WinQueryWindowPtr(hwndClient, QWP_PFNWP) == ClientWndProc) {%@NL@%
        paiClient = WinSendMsg(hwndClient, UM_QUERY, (MPARAM)Q_APPINFO, 0L);%@NL@%
        if (paiClient == pai)%@NL@%
            return;%@NL@%
            %@NL@%
        if ((pai->afCmd & DMGCMD_AGENT) && (paiClient->afCmd & DMGCMD_AGENT)) %@NL@%
            return;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * make sure ii.pCC is set up right.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pddei->cb >= sizeof(DDEINIT) && pddei->offConvContext) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * new dde init structure!%@NL@%
%@AB@%         */%@AE@%%@NL@%
        ii.pCC = DDEI_PCONVCONTEXT(pddei);%@NL@%
    } else {%@NL@%
        ii.pCC = &cc;%@NL@%
        cc.cb = sizeof(CONVCONTEXT);%@NL@%
        cc.idCountry = syscc.country;%@NL@%
        cc.usCodepage = syscc.codepage;%@NL@%
        cc.fsContext = 0;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    hp[0].hszApp = GetHsz(PSZAPP(pddei), ii.pCC->idCountry,%@NL@%
            ii.pCC->usCodepage, TRUE);%@NL@%
            %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * filter out unwanted app names.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (hp[0].hszApp && (pai->afCmd & DMGCMD_FILTERINITS) &&%@NL@%
            !FindPileItem(pai->pAppNamePile, CmppHsz, (PBYTE)&hp[0].hszApp, 0)) {%@NL@%
        FreeHsz(hp[0].hszApp);%@NL@%
        return;    %@NL@%
    }%@NL@%
%@NL@%
    hp[0].hszTopic = GetHsz(PSZTOPIC(pddei), ii.pCC->idCountry,%@NL@%
            ii.pCC->usCodepage, TRUE);%@NL@%
            %@NL@%
    hp[1].hszApp = hp[1].hszTopic = 0L;%@NL@%
%@NL@%
    fWild = (hp[0].hszApp == 0L || hp[0].hszTopic == 0);%@NL@%
%@NL@%
    hDataCC = PutData((PBYTE)ii.pCC, (ULONG)sizeof(CONVCONTEXT), 0L, (HSZ)NULL,%@NL@%
            0, 0, pai);%@NL@%
%@NL@%
    if (hDataCC == NULL)%@NL@%
        goto CheckOut;%@NL@%
        %@NL@%
    pddes = (PDDESTRUCT)DoCallback(pai, NULL, hp[0].hszTopic,%@NL@%
                    hp[0].hszApp, 0, (fWild ? XTYP_WILDINIT : XTYP_INIT),%@NL@%
                    hDataCC);%@NL@%
%@NL@%
    if (pddes == NULL)%@NL@%
        goto CheckOut;%@NL@%
%@NL@%
    FindPileItem(pai->pHDataPile, CmpULONG, (PBYTE)&hDataCC, FPI_DELETE);%@NL@%
    DosFreeSeg(SELECTOROF(hDataCC));%@NL@%
    %@NL@%
    if (fWild) {%@NL@%
        php = (PHSZPAIR)DDES_PABDATA(pddes);%@NL@%
    } else {%@NL@%
        php = &hp[0];%@NL@%
        pddes = NULL;%@NL@%
    }%@NL@%
        %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * now php points to a 0 terminated list of hszpairs to respond to.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    SemEnter();%@NL@%
    while (QuerylatomLength((LATOM)php->hszApp) &&%@NL@%
            QuerylatomLength((LATOM)php->hszTopic)) {%@NL@%
        SemLeave();%@NL@%
        if ((hwndServer = CreateServerWindow(pai, php->hszTopic)) == 0)%@NL@%
            break;%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * have the server respond%@NL@%
%@AB@%         */%@AE@%%@NL@%
        ii.hszAppName = php->hszApp;%@NL@%
        ii.hszTopic = php->hszTopic;%@NL@%
        WinSendMsg(hwndServer, UMSR_INITIATE, (MPARAM)&ii, hwndClient);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * confirm initialization to server app%@NL@%
%@AB@%         */%@AE@%%@NL@%
        DoCallback(pai, (HCONV)hwndServer, php->hszTopic, php->hszApp,%@NL@%
                0, XTYP_INIT_CONFIRM, 0L);%@NL@%
            %@NL@%
        php++;%@NL@%
        SemEnter();%@NL@%
    }%@NL@%
    SemLeave();%@NL@%
    SemCheckOut();%@NL@%
CheckOut:    %@NL@%
    FreeHsz(hp[0].hszApp);%@NL@%
    FreeHsz(hp[0].hszTopic);%@NL@%
    if (fWild)%@NL@%
        FreeData((PMYDDES)pddes, pai);%@NL@%
}%@NL@%
%@NL@%
HWND CreateServerWindow(%@NL@%
PAPPINFO pai,%@NL@%
HSZ hszTopic)%@NL@%
{%@NL@%
    HWND hwndTSvr, hwndServer;%@NL@%
    %@NL@%
    SemCheckOut();%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * locate or make a Topic server window...%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((hwndTSvr =%@NL@%
            HwndFromHsz(hszTopic, pai->pSvrTopicList)) == 0) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * NO - make one.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((hwndTSvr = WinCreateWindow(pai->hwndDmg, SZDEFCLASS, "", 0L,%@NL@%
                0, 0, 0, 0, (HWND)NULL, HWND_BOTTOM, WID_SVRTOPIC,%@NL@%
                0L, 0L)) == 0L) {%@NL@%
            pai->LastError = DMGERR_PMWIN_ERROR;%@NL@%
            return(NULL);%@NL@%
        }%@NL@%
        AddHwndHszList(hszTopic, hwndTSvr, pai->pSvrTopicList);%@NL@%
    }%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Create the server window%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((hwndServer = WinCreateWindow(hwndTSvr, SZSERVERCLASS, "", 0L,%@NL@%
            0, 0, 0, 0, (HWND)NULL, HWND_BOTTOM, WID_SERVER, 0L, 0L)) == 0L) {%@NL@%
        pai->LastError = DMGERR_PMWIN_ERROR;%@NL@%
        return(NULL);%@NL@%
    }%@NL@%
    return(hwndServer);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * main application window - parent of all others in app.%@NL@%
%@AB@% *%@NL@%
%@AB@% * 6/12/90 sanfords     Fixed semaphore bug%@NL@%
%@AB@% */%@AE@%%@NL@%
MRESULT EXPENTRY DmgWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
%@AI@%#define %@AE@%pai ((PAPPINFO)mp1) %@NL@%
    PCBLI pli, pliNext;%@NL@%
    BOOL fException;%@NL@%
    HDMGDATA hDataRet;%@NL@%
%@NL@%
    hwnd;%@NL@%
    mp2;%@NL@%
        %@NL@%
    switch (msg) {%@NL@%
    case UM_CHECKCBQ:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * We consider everything to be blocked if we are in a client%@NL@%
%@AB@%         * transfer modal loop.   This prevents recursive timeout%@NL@%
%@AB@%         * calls.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (pai->hwndTimer)%@NL@%
            return(0);%@NL@%
            %@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * This is where we actually do callbacks.  We do them via this%@NL@%
%@AB@%         * window proc so that we can asynchronously institute callbacks%@NL@%
%@AB@%         * via a PostMsg().%@NL@%
%@AB@%         */%@AE@%%@NL@%
        SemCheckOut();%@NL@%
        SemEnter();%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * process all enabled conversation callbacks.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        for (pli = (PCBLI)pai->plstCB->pItemFirst; pli; pli = (PCBLI)pliNext) {%@NL@%
            pliNext = (PCBLI)pli->next;%@NL@%
            fException = FindLstItem(pai->plstCBExceptions, CmpULONG, (PLITEM)pli)%@NL@%
                    == NULL ? FALSE : TRUE;%@NL@%
            if (fException == pai->fEnableCB)%@NL@%
                continue; %@AB@%/* blocked */%@AE@%%@NL@%
%@NL@%
            pai->cInCallback++;%@NL@%
            SemLeave();%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * make the actual callback here.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            hDataRet = DoCallback(pai, pli->hConv, pli->hszTopic,%@NL@%
                    pli->hszItem, pli->usFmt, pli->usType, pli->hDmgData);%@NL@%
            SemEnter();%@NL@%
            if (pai->cInCallback > 0)   %@AB@%/* test incase exlst processing messed it up */%@AE@%%@NL@%
                pai->cInCallback--;%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If the callback resulted in a BLOCK, disable this conversation.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (hDataRet == CBR_BLOCK && !(pli->usType & XTYPF_NOBLOCK)) {%@NL@%
                SemLeave();%@NL@%
                DdeEnableCallback(pli->hConv, FALSE);%@NL@%
                SemEnter();%@NL@%
                continue;%@NL@%
            } else {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * otherwise finish processing the callback.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                if (WinIsWindow(DMGHAB, pli->hConvPartner)) {%@NL@%
                    SemLeave();%@NL@%
                    QReply(pli, (PDDESTRUCT)hDataRet);%@NL@%
                    SemEnter();%@NL@%
                }%@NL@%
                RemoveLstItem(pai->plstCB, (PLITEM)pli);%@NL@%
            }%@NL@%
        }%@NL@%
        SemLeave();%@NL@%
        return(0);%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        WinDefWindowProc(hwnd, msg, mp1, mp2);%@NL@%
        break;%@NL@%
    }%@NL@%
%@AI@%#undef %@AE@%pai %@NL@%
}%@NL@%
%@NL@%
%@NL@%
HDMGDATA DoCallback(%@NL@%
PAPPINFO pai,%@NL@%
HCONV hConv,%@NL@%
HSZ hszTopic,%@NL@%
HSZ hszItem,%@NL@%
USHORT usFmt,%@NL@%
USHORT usType,%@NL@%
HDMGDATA hDmgData)%@NL@%
{%@NL@%
    HDMGDATA hDataRet;%@NL@%
    %@NL@%
    AssertF(IncHszCount(hszTopic) && FreeHsz(hszTopic), "Bad hszTopic on callback");%@NL@%
    AssertF(IncHszCount(hszItem) && FreeHsz(hszItem), "Bad hszItem on callback");%@NL@%
%@NL@%
    if (usType & XCLASS_DATAIN) {%@NL@%
        AssertF(CheckSel(SELECTOROF(hDmgData)), "invalid callback data handle");%@NL@%
        ((PMYDDES)hDmgData)->fs |= HDATA_READONLY;%@NL@%
    }%@NL@%
    %@NL@%
%@AI@%#ifdef %@AE@%CRUISER     %@NL@%
    if (pai->afCmd & DMGCMD_32BIT)%@NL@%
        hDataRet = ThkCallback(hConv, hszTopic, hszItem, usFmt, usType, hDmgData,%@NL@%
                pai->pfnCallback);%@NL@%
    else%@NL@%
%@AI@%#endif %@AE@%    %@NL@%
        hDataRet = (*pai->pfnCallback)(hConv, hszTopic, hszItem, usFmt, usType,%@NL@%
                hDmgData);%@NL@%
%@NL@%
    if (usType & XCLASS_DATA && CheckSel(SELECTOROF(hDataRet)) > sizeof(MYDDES) &&%@NL@%
            ((PMYDDES)hDataRet)->magic == MYDDESMAGIC) {%@NL@%
        if (((PMYDDES)hDataRet)->pai != pai) {%@NL@%
            AssertF(FALSE, "hData from callback not created by same thread");%@NL@%
            pai->LastError = DMGERR_DLL_USAGE;%@NL@%
            hDataRet = NULL;%@NL@%
        }%@NL@%
    }%@NL@%
    return(hDataRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EA.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\STOCK\EA.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***        ea.c - layer for EA support%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Author:%@NL@%
%@AB@% *            Benjamin W. Slivka%@NL@%
%@AB@% *            (c) 1990%@NL@%
%@AB@% *            Microsoft Corporation%@NL@%
%@AB@% *%@NL@%
%@AB@% *        History:%@NL@%
%@AB@% *            08-Feb-1990 bens        Initial version (Subset from EA.EXE sources)%@NL@%
%@AB@% *            02-May-1990 bens        Added SetEAValue (copied from ea.exe)%@NL@%
%@AB@% *            01-Jun-1990 bens        Support binary EAs%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOSERRORS %@NL@%
%@AI@%#define %@AE@%INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%INCL_NOPM %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<ctype.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<memory.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"ea.h" %@NL@%
%@AI@%#include %@AE@%"mem.h" %@NL@%
%@NL@%
%@NL@%
%@AI@%#ifdef %@AE@%CHECKASSERTS %@NL@%
%@AI@%#define %@AE@%dbg(a)        a %@NL@%
%@AI@%#else %@AE@%%@NL@%
%@AI@%#define %@AE@%dbg(a) %@NL@%
%@AI@%#endif %@AE@%%@NL@%
%@NL@%
// Buffer sizes for EA API calls%@NL@%
%@AI@%#define %@AE@%CB_GEAL       400                // Enough for one GEA in list %@NL@%
%@AI@%#define %@AE@%CB_FEAL      2000                // Enough for large file list %@NL@%
%@NL@%
%@NL@%
char *            TranslateValue(char *pbValue,USHORT cbValue,USHORT *pcbValue);%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        EAQueryValue - Get text EA value from file%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            pszFile - File path%@NL@%
%@AB@% *            pszName - EA name%@NL@%
%@AB@% *            pcbValue - USHORT to receive value length%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            returns non-zero pointer to value; Caller must free this!%@NL@%
%@AB@% *                If value is ASCII%@NL@%
%@AB@% *                    *pcbValue == 0;%@NL@%
%@AB@% *                If value is BINARY%@NL@%
%@AB@% *                    *pcbValue == length of value;%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            returns NULL%@NL@%
%@AB@% */%@AE@%%@NL@%
char *EAQueryValue(char *pszFile,char *pszName,USHORT *pcbValue)%@NL@%
{%@NL@%
    USHORT        cb;%@NL@%
    EAOP        eaop;%@NL@%
    FEA *        pfea;%@NL@%
    FEA *        pfeaEnd;%@NL@%
    FEALIST *        pFEAList;%@NL@%
    GEA *        pgea;%@NL@%
    GEALIST *        pGEAList;%@NL@%
    char *        psz;%@NL@%
    char *        pszValue;%@NL@%
    USHORT        rc;%@NL@%
%@NL@%
    //%@NL@%
    // Alloc GEAList and FEAList%@NL@%
    //%@NL@%
    pGEAList = MemAlloc(CB_GEAL);%@NL@%
    if (pGEAList == NULL) {%@NL@%
        return NULL;%@NL@%
    }%@NL@%
%@NL@%
    pFEAList = MemAlloc(CB_FEAL);%@NL@%
    if (pFEAList == NULL) {%@NL@%
        MemFree(pGEAList);%@NL@%
        return NULL;%@NL@%
    }%@NL@%
%@NL@%
    // Build GEA List with one GEA%@NL@%
%@NL@%
    pgea = pGEAList->list;                // Point at first GEA%@NL@%
    cb = strlen(pszName);%@NL@%
    pgea->cbName = (UCHAR)cb;                // Set length%@NL@%
    memcpy(pgea->szName,pszName,cb+1);        // Copy name and NUL%@NL@%
    pgea = (GEA *)((char *)pgea + cb + sizeof(GEA));%@NL@%
    pGEAList->cbList = (char *)pgea - (char *)pGEAList; // Set buffer size%@NL@%
%@NL@%
    // Get attribute value%@NL@%
%@NL@%
    pFEAList->cbList = CB_FEAL;         // Set size of FEA list%@NL@%
    eaop.fpGEAList = pGEAList;%@NL@%
    eaop.fpFEAList = pFEAList;%@NL@%
%@NL@%
    rc = DosQPathInfo(pszFile,                // File path%@NL@%
                      FIL_QUERYEASFROMLIST, // info level%@NL@%
                      (PBYTE)&eaop,        // EAOP structure%@NL@%
                      sizeof(eaop),        // Size of EAOP%@NL@%
                      0L);                // Reserved%@NL@%
    pfea = (FEA *)pFEAList->list;        // Point at FEA%@NL@%
%@NL@%
    //        NOTE: DosQPathInfo only fails if there is an inconsistency in%@NL@%
    //              one of its parameters.  It DOES NOT fail if the EA is%@NL@%
    //              not present.  Rather, on a file system that does not%@NL@%
    //              support EAs, it appears to return pFEAList->cbList ==%@NL@%
    //              sizeof(pFEAList->cbList), indicating no FEAs are present.%@NL@%
    //              If the file system *does* support EAs, but the particular%@NL@%
    //              EA is not present, pFEA->cbValue == 0.%@NL@%
%@NL@%
    if ((rc == 0) &&                        // Call succeeded,...%@NL@%
        ((pFEAList->cbList) > sizeof(pFEAList->cbList)) && // FEA is there,...%@NL@%
        (pfea->cbValue > 0)) {                // and file has EA value!%@NL@%
        // Parse EA value%@NL@%
        cb = pfea->cbName;%@NL@%
        psz = (char *)pfea + sizeof(FEA); // Point at name%@NL@%
        pszValue = psz + cb + 1;        // Point at value%@NL@%
        psz = TranslateValue(pszValue,pfea->cbValue,pcbValue);%@NL@%
    }%@NL@%
    else%@NL@%
       psz = NULL;                        // EA not present, or too big%@NL@%
%@NL@%
    MemFree(pFEAList);%@NL@%
    MemFree(pGEAList);%@NL@%
    return psz;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        TranslateValue - produce printable representation of EA value%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            pbValue  - Value buffer%@NL@%
%@AB@% *            cbValue  - Length of value buffer%@NL@%
%@AB@% *            pcbValue - USHORT to receive actual value length%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns non-zero pointer to value; caller MUST free!%@NL@%
%@AB@% *                If value is ASCII%@NL@%
%@AB@% *                    *pcbValue == 0;%@NL@%
%@AB@% *                If value is BINARY%@NL@%
%@AB@% *                    *pcbValue == length of value;%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns NULL%@NL@%
%@AB@% *%@NL@%
%@AB@% *%@NL@%
%@AB@% *  EAT_MVMT - Multi-value, Multi-type%@NL@%
%@AB@% *%@NL@%
%@AB@% *        +------+----------+-------+------+--------+-------+---+---+---+---+%@NL@%
%@AB@% *        | Type | Codepage | Count | Type | Length | Value |...| T | L | V |%@NL@%
%@AB@% *        +------+----------+-------+------+--------+-------+---+---+---+---+%@NL@%
%@AB@% *           us            us             us      us      us       ?%@NL@%
%@AB@% *        \________________________/ \_____________________/     \_________/%@NL@%
%@AB@% *           MVMT header                          Value 1                 Value N%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
char * TranslateValue(char *pbValue,USHORT cbValue,USHORT *pcbValue)%@NL@%
{%@NL@%
    USHORT cb=cbValue;%@NL@%
    USHORT codePage;%@NL@%
    USHORT cValue;%@NL@%
    char * pbDst;%@NL@%
    char * pbSrc;%@NL@%
    char * pszNew;%@NL@%
    USHORT type;%@NL@%
%@NL@%
    // Parse MVMT header, if present%@NL@%
%@NL@%
    pbSrc = pbValue;%@NL@%
%@NL@%
    type = *(USHORT *)pbSrc;                // Get EA value type%@NL@%
    if (type == EAT_MVMT) {%@NL@%
        pbSrc += sizeof(USHORT);        // Skip type%@NL@%
        codePage = *((USHORT*)pbSrc)++; // Get code page%@NL@%
        cValue = *((USHORT*)pbSrc)++;        // Get count of values%@NL@%
        if (cValue != 1)                // Not exactly one value%@NL@%
            return NULL;                //  Fail%@NL@%
        type = *(USHORT *)pbSrc;        // Get EA value type%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    // Parse value%@NL@%
%@NL@%
    if ( (type == EAT_ASCII) || (type == EAT_BINARY) ) {%@NL@%
        pbSrc += sizeof(USHORT);        // Skip type%@NL@%
        cb = *((USHORT *)pbSrc)++;        // Get data length%@NL@%
%@NL@%
        // Allocate buffer for data%@NL@%
%@NL@%
        pszNew = MemAlloc(cb+1);        // Leave room for NUL, in ASCII case%@NL@%
        if (pszNew == NULL)%@NL@%
            return NULL;%@NL@%
        pbDst = pszNew;%@NL@%
%@NL@%
        // Copy data%@NL@%
%@NL@%
        memcpy(pbDst,pbSrc,cb);         // Copy value%@NL@%
        pbDst += cb;                        // Advance destination pointer%@NL@%
%@NL@%
        if (type == EAT_ASCII) {%@NL@%
            *pbDst++ = '\0';                // Terminate ASCIIZ string%@NL@%
            *pcbValue = 0;                // Indicate value is ASCIIZ%@NL@%
        }%@NL@%
        else%@NL@%
            *pcbValue = cb;                // Indicate value is binary%@NL@%
        return pszNew;                        // Return value%@NL@%
    }%@NL@%
    else%@NL@%
        return NULL;                        //  Fail%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        EASetValue - Create/Change/Delete an EA%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            pszFile  - file path%@NL@%
%@AB@% *            pszName  - EA name%@NL@%
%@AB@% *            cbValue  - EA length; 0 => pszValue is ASCIIZ%@NL@%
%@AB@% *            pszValue - EA value; NULL to delete EA%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            returns TRUE%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            returns FALSE%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL EASetValue(char *pszFile,char *pszName,USHORT cbValue,char *pszValue)%@NL@%
{%@NL@%
    USHORT        cbName;%@NL@%
    EAOP        eaop;%@NL@%
    FEA *        pfea;%@NL@%
    FEALIST *        pFEAList;%@NL@%
    char *        psz;%@NL@%
    USHORT        rc;%@NL@%
    USHORT        type;%@NL@%
%@NL@%
    // Determine operation%@NL@%
%@NL@%
    if (pszValue == NULL) {                // Delete this EA%@NL@%
        type = EAT_ASCII;%@NL@%
        cbValue = 0;%@NL@%
    }%@NL@%
    else if (cbValue == 0) {                // Create/Change value%@NL@%
        type = EAT_ASCII;%@NL@%
        cbValue = strlen(pszValue);        // Compute length (do not count NUL!)%@NL@%
    }%@NL@%
    else {                                // Create/Change Binary value%@NL@%
        type = EAT_BINARY;%@NL@%
    }%@NL@%
%@NL@%
    //%@NL@%
    // Alloc FEA List%@NL@%
    //%@NL@%
    pFEAList = MemAlloc(CB_FEAL);%@NL@%
    if (pFEAList == NULL)%@NL@%
        return FALSE;%@NL@%
%@NL@%
    cbName = strlen(pszName);%@NL@%
%@NL@%
    //%@NL@%
    // Build EA structure%@NL@%
    //%@NL@%
    pfea = (FEA *)pFEAList->list;        // Point at first FEA%@NL@%
    pfea->fEA = 0;                        // No flag settings%@NL@%
    pfea->cbName = (UCHAR)cbName;        // Set name length%@NL@%
    pfea->cbValue = cbValue;                // Set value length%@NL@%
%@NL@%
    psz = (char *)pfea + sizeof(FEA);        // Point at location for name%@NL@%
    memcpy(psz,pszName,cbName+1);        // Copy Name *and* NUL%@NL@%
    psz += cbName+1;                        // Point at location for value%@NL@%
    if (cbValue > 0) {                        // Edit/Create EA%@NL@%
        *((USHORT *)psz)++ = EAT_MVMT;        // Set MVMT type (to record code page!)%@NL@%
        *((USHORT *)psz)++ = NULL;        // Set codepage%@NL@%
        *((USHORT *)psz)++ = 1;         // Only one TLV record%@NL@%
        *((USHORT *)psz)++ = type;        // Set EA type%@NL@%
        *((USHORT *)psz)++ = cbValue;        // Set ASCII length%@NL@%
%@NL@%
        pfea->cbValue += 5*sizeof(USHORT); // MVMT header and type and length%@NL@%
        memcpy(psz,pszValue,cbValue);        // Copy Value%@NL@%
    }%@NL@%
    pfea = (FEA *)(psz + cbValue);        // Point at byte after FEA%@NL@%
%@NL@%
    //%@NL@%
    // Set size of FEA List (only one FEA)%@NL@%
    //%@NL@%
%@NL@%
    pFEAList->cbList = (char *)pfea - (char *)pFEAList;%@NL@%
%@NL@%
    eaop.fpGEAList = NULL;%@NL@%
    eaop.fpFEAList = pFEAList;%@NL@%
%@NL@%
    rc = DosSetPathInfo(pszFile,            // File path%@NL@%
                        FIL_QUERYEASIZE,    // Set EA%@NL@%
                        (PBYTE)&eaop,            // EAOP structure%@NL@%
                        sizeof(eaop),            // Size of EAOP%@NL@%
                        0,                    // Options%@NL@%
                        0L);                    // Reserved%@NL@%
    MemFree(pFEAList);%@NL@%
    return (rc == 0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EDPLINE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\EDPLINE\EDPLINE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    edpline.c -- polyline editor, for practice in mouse handling%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINSWITCHLIST %@NL@%
%@AI@%#define %@AE@%INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%       INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%       INCL_WINFRAMEMGR %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"edpline.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%       abs(x)                        (((x) > 0) ? (x) : -(x)) %@NL@%
%@AI@%#define %@AE@%PRIM_POLYLINE                0x0001 %@NL@%
%@AI@%#define %@AE@%PRIM_POLYFILLET         0x0002 %@NL@%
%@AI@%#define %@AE@%PRIM_POLYSPLINE         0x0004 %@NL@%
%@AI@%#define %@AE@%PRIM_POINTARC                0x0008 %@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Function declarations%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AB@%/* Private functions */%@AE@%%@NL@%
%@NL@%
VOID   cdecl main(VOID);%@NL@%
BOOL   InitGlobals(VOID);%@NL@%
BOOL   InitApp(VOID);%@NL@%
VOID   Close(HWND);%@NL@%
VOID   Command(HWND, USHORT);%@NL@%
VOID   Paint(HPS, BOOL);%@NL@%
VOID   MouseMove(HWND, MPARAM);%@NL@%
VOID   ButtonUp(HWND, USHORT);%@NL@%
VOID   ButtonDown(HWND, USHORT, MPARAM);%@NL@%
USHORT IsPtInList(PPOINTL);%@NL@%
USHORT AddPtToList(PPOINTL);%@NL@%
BOOL   IsPtCloseToLine(PPOINTL, PPOINTL, PPOINTL);%@NL@%
VOID   DrawPrimitive(HPS, USHORT);%@NL@%
VOID   DrawPolyLine(HPS);%@NL@%
VOID   DrawPolyFillet(HPS);%@NL@%
VOID   DrawPolySpline(HPS);%@NL@%
VOID   DrawPointArc(HPS);%@NL@%
VOID   DrawControlPoints(HPS, LONG, PPOINTL);%@NL@%
VOID   MyMessageBox(HWND, PSZ);%@NL@%
VOID   SwapLong(PLONG, PLONG);%@NL@%
%@NL@%
%@AB@%/* Exported functions */%@AE@%%@NL@%
%@NL@%
ULONG        EXPENTRY WndProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT EXPENTRY AboutDlgProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Global Variables%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
typedef struct%@NL@%
{%@NL@%
    HAB  hab;%@NL@%
    HMQ  hMsgQ;%@NL@%
    HWND hwndFrame;%@NL@%
    HWND hwnd;%@NL@%
%@NL@%
    ULONG   flPrim;%@NL@%
    BOOL    fDisplayControlPoints;%@NL@%
    LONG    cptl;%@NL@%
    PPOINTL pptl;%@NL@%
%@NL@%
    USHORT  usPtGrabbed;%@NL@%
    BOOL    fDragging;%@NL@%
%@NL@%
    ULONG   ulHitPrecision;%@NL@%
%@NL@%
} GLOBALDATA;%@NL@%
GLOBALDATA global;%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   main%@NL@%
%@AB@%*%@NL@%
%@AB@%*   WinInitialize resizes our ring 2 stack, among other things, so%@NL@%
%@AB@%*   we won't GP fault trying to do graphics.  WinCreateMsgQueue defines%@NL@%
%@AB@%*   us as a REAL PM app. (as well as the WINDOWAPI statement in the .DEF%@NL@%
%@AB@%*   file...)   Call a sub to register our window class and create a window.%@NL@%
%@AB@%*   Loop over messages.  Exit cleanly.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID cdecl%@NL@%
main()%@NL@%
{%@NL@%
    QMSG qMsg;%@NL@%
    int iRet = 0;%@NL@%
%@NL@%
%@NL@%
    global.hab         = WinInitialize(0);%@NL@%
    global.hMsgQ = WinCreateMsgQueue(global.hab, 0);%@NL@%
%@NL@%
    if (InitApp())%@NL@%
        while (WinGetMsg( global.hab, (PQMSG)&qMsg, (HWND)NULL, 0, 0 ))%@NL@%
            WinDispatchMsg( global.hab, (PQMSG)&qMsg );%@NL@%
    else%@NL@%
        iRet = -1;%@NL@%
%@NL@%
    WinDestroyWindow( global.hwndFrame );%@NL@%
    WinDestroyMsgQueue( global.hMsgQ );%@NL@%
    WinTerminate( global.hab );%@NL@%
    DosExit(EXIT_PROCESS, iRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   InitGlobals%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Initialize global variables.%@NL@%
%@AB@%*%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
InitGlobals()%@NL@%
{%@NL@%
    global.flPrim = PRIM_POLYLINE;%@NL@%
    global.fDisplayControlPoints = TRUE;%@NL@%
%@NL@%
    global.cptl = 0L;%@NL@%
    global.pptl = NULL;%@NL@%
    if (DosAllocSeg(CPTLMAX * sizeof(POINTL),%@NL@%
                   ((PUSHORT)&global.pptl)+1, 0))%@NL@%
        return FALSE;%@NL@%
%@NL@%
    global.usPtGrabbed = -1;%@NL@%
    global.fDragging = FALSE;%@NL@%
    global.ulHitPrecision = 0L;%@NL@%
%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   InitApp%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Register application window class and creates standard window.%@NL@%
%@AB@%*%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INIT_MENU_ITEM(val, var)     \ %@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, (val), (var))%@NL@%
%@NL@%
BOOL%@NL@%
InitApp()%@NL@%
{%@NL@%
    char szTitle[24];%@NL@%
    ULONG ctldata;%@NL@%
    PID pid;%@NL@%
    TID tid;%@NL@%
    HSWITCH hsw;%@NL@%
    static SWCNTRL swctl = { 0, 0, 0, 0, 0, SWL_VISIBLE,%@NL@%
                             SWL_JUMPABLE, "Edit Polyline", 0 };%@NL@%
%@NL@%
    if (!InitGlobals())%@NL@%
        return FALSE;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*  Register Application Window Class  */%@AE@%%@NL@%
%@NL@%
    WinLoadString( global.hab, (HMODULE) NULL, IDS_TITLE, sizeof(szTitle), (PCH)szTitle );%@NL@%
    if ( !WinRegisterClass( global.hab, (PCH)szTitle, (PFNWP)WndProc,%@NL@%
            CS_SIZEREDRAW, 0 ))%@NL@%
        return FALSE;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Create a window instance of class "PolyLine Editor" */%@AE@%%@NL@%
%@NL@%
    ctldata = FCF_STANDARD &%@NL@%
     ~(ULONG)(FCF_ICON | FCF_ACCELTABLE | FCF_TASKLIST);%@NL@%
%@NL@%
    if (global.hwndFrame = WinCreateStdWindow(%@NL@%
        HWND_DESKTOP,                   %@AB@%/* specify desktop as parent window            */%@AE@%%@NL@%
        WS_VISIBLE,                   %@AB@%/* window styles                            */%@AE@%%@NL@%
        &ctldata,                   %@AB@%/* frame creation flags                    */%@AE@%%@NL@%
        (PCH)szTitle,                   %@AB@%/* window class name                     */%@AE@%%@NL@%
        (PCH)szTitle,                   %@AB@%/* name appearing in window caption            */%@AE@%%@NL@%
        0L,                           %@AB@%/*                                            */%@AE@%%@NL@%
        (HMODULE)NULL,                   %@AB@%/* use current executable module id            */%@AE@%%@NL@%
        IDR_EDPLINE,                   %@AB@%/* menu id                                    */%@AE@%%@NL@%
        (HWND FAR *)&global.hwnd   %@AB@%/* window handle                            */%@AE@%%@NL@%
        ))%@NL@%
    {%@NL@%
        INIT_MENU_ITEM(IDM_CTLPOINTS, global.fDisplayControlPoints);%@NL@%
%@NL@%
        if (global.flPrim & PRIM_POLYLINE)%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, IDM_POLYLINE);%@NL@%
        if (global.flPrim & PRIM_POLYFILLET)%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, IDM_POLYFILLET);%@NL@%
        if (global.flPrim & PRIM_POLYSPLINE)%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, IDM_POLYSPLINE);%@NL@%
        if (global.flPrim & PRIM_POINTARC)%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, IDM_POINTARC);%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* Add ourselves to the switch list. */%@AE@%%@NL@%
%@NL@%
        WinQueryWindowProcess(global.hwndFrame, &pid, &tid);%@NL@%
        swctl.hwnd        = global.hwndFrame;%@NL@%
        swctl.idProcess = pid;%@NL@%
        hsw = WinAddSwitchEntry(&swctl);%@NL@%
%@NL@%
        return TRUE;%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   WndProc%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the window class.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG EXPENTRY%@NL@%
WndProc( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
    HPS   hps;%@NL@%
%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_CLOSE:%@NL@%
        Close(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        Command(hwnd, LOUSHORT(mp1));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        hps = WinBeginPaint(global.hwnd, NULL, NULL);%@NL@%
        if (global.ulHitPrecision == 0L)%@NL@%
        {%@NL@%
            HDC hdc;%@NL@%
            LONG cx;%@NL@%
%@NL@%
            if (hdc = WinQueryWindowDC(global.hwnd)) {%@NL@%
                DevQueryCaps(hdc, CAPS_MARKER_WIDTH,  1L,  &cx);%@NL@%
                global.ulHitPrecision = (cx >> 17) + 1L;%@NL@%
            } else {%@NL@%
                global.ulHitPrecision = 6L;%@NL@%
            }%@NL@%
        }%@NL@%
        Paint(hps, TRUE);%@NL@%
        WinEndPaint(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1DOWN:%@NL@%
    case WM_BUTTON2DOWN:%@NL@%
        ButtonDown(hwnd, usMsg, mp1);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1UP:%@NL@%
    case WM_BUTTON2UP:%@NL@%
        ButtonUp(hwnd, usMsg);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_MOUSEMOVE:%@NL@%
        MouseMove(hwnd, mp1);%@NL@%
        return( (ULONG)WinDefWindowProc(hwnd, usMsg, mp1, mp2));%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return( (ULONG)WinDefWindowProc(hwnd, usMsg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MouseMove%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MouseMove(hwnd, mp1)%@NL@%
HWND hwnd;%@NL@%
MPARAM mp1;%@NL@%
{%@NL@%
    POINTL ptl;%@NL@%
    HPS hps;%@NL@%
%@NL@%
    if (hwnd == global.hwnd)%@NL@%
        if (global.fDragging)%@NL@%
        {%@NL@%
            ptl.x = (LONG) LOUSHORT(mp1);%@NL@%
            ptl.y = (LONG) HIUSHORT(mp1);%@NL@%
%@NL@%
            if (global.usPtGrabbed != -1)%@NL@%
            {%@NL@%
                hps = WinGetPS(hwnd);%@NL@%
                Paint(hps, FALSE);%@NL@%
%@NL@%
                *(global.pptl+global.usPtGrabbed) = ptl;%@NL@%
%@NL@%
                Paint(hps, FALSE);%@NL@%
                WinReleasePS(hps);%@NL@%
            }%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ButtonUp%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
ButtonUp(hwnd, usMsg)%@NL@%
HWND hwnd;%@NL@%
USHORT usMsg;%@NL@%
{%@NL@%
    int i;%@NL@%
    HPS hps;%@NL@%
%@NL@%
%@NL@%
    if (hwnd == global.hwnd)%@NL@%
        if (global.fDragging)%@NL@%
        {%@NL@%
            global.fDragging = FALSE;%@NL@%
            if (global.usPtGrabbed != -1)%@NL@%
            {%@NL@%
                if (usMsg == WM_BUTTON2UP)%@NL@%
                {%@NL@%
                    hps = WinGetPS(hwnd);%@NL@%
                    Paint(hps, FALSE);%@NL@%
%@NL@%
                    if ((i = global.usPtGrabbed) < (int) global.cptl-1)%@NL@%
                        while (i < (int) global.cptl-1)%@NL@%
                        {%@NL@%
                            global.pptl[i] = global.pptl[i+1];%@NL@%
                            ++i;%@NL@%
                        }%@NL@%
%@NL@%
                    --global.cptl;%@NL@%
                    global.usPtGrabbed = -1;%@NL@%
%@NL@%
                    Paint(hps, FALSE);%@NL@%
                    WinReleasePS(hps);%@NL@%
                }%@NL@%
                else        %@AB@%/* WM_BUTTON1UP */%@AE@%%@NL@%
                    global.usPtGrabbed = -1;%@NL@%
            }%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ButtonDown%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
ButtonDown(hwnd, usMsg, mp1)%@NL@%
HWND hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
{%@NL@%
    POINTL ptl;%@NL@%
    HPS hps;%@NL@%
    USHORT usNewPtGrabbed;%@NL@%
%@NL@%
%@NL@%
    if (hwnd == global.hwnd)%@NL@%
        if (!global.fDragging)%@NL@%
        {%@NL@%
            global.fDragging = TRUE;%@NL@%
%@NL@%
            ptl.x = (LONG) LOUSHORT(mp1);%@NL@%
            ptl.y = (LONG) HIUSHORT(mp1);%@NL@%
%@NL@%
            if ((usNewPtGrabbed = IsPtInList(&ptl)) != -1)%@NL@%
                global.usPtGrabbed = usNewPtGrabbed;%@NL@%
%@NL@%
            if (usMsg == WM_BUTTON1DOWN)%@NL@%
            {%@NL@%
                hps = WinGetPS(hwnd);%@NL@%
                Paint(hps, FALSE);%@NL@%
%@NL@%
                if (usNewPtGrabbed == -1)%@NL@%
                    global.usPtGrabbed = AddPtToList(&ptl);%@NL@%
                else%@NL@%
                    global.usPtGrabbed = usNewPtGrabbed;%@NL@%
%@NL@%
                Paint(hps, FALSE);%@NL@%
                WinReleasePS(hps);%@NL@%
%@NL@%
                if (global.usPtGrabbed == -1)%@NL@%
                    MyMessageBox(global.hwnd, "Cannot add any more points.");%@NL@%
            }%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   IsPtInList%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
USHORT%@NL@%
IsPtInList(pptl)%@NL@%
PPOINTL pptl;%@NL@%
{%@NL@%
    int i;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* try to find pptl in the points we already have */%@AE@%%@NL@%
    for (i = 0; i < (int) global.cptl; ++i)%@NL@%
        if (((abs(pptl->x - global.pptl[i].x))%@NL@%
                <= (LONG) global.ulHitPrecision)%@NL@%
         && ((abs(pptl->y - global.pptl[i].y))%@NL@%
                <= (LONG) global.ulHitPrecision))%@NL@%
                return i;%@NL@%
%@NL@%
    %@AB@%/* couldn't find it */%@AE@%%@NL@%
    return -1;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   AddPtToList%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
USHORT%@NL@%
AddPtToList(pptl)%@NL@%
PPOINTL pptl;%@NL@%
{%@NL@%
    int i, j;%@NL@%
%@NL@%
    if (global.cptl < CPTLMAX)%@NL@%
    {%@NL@%
        %@AB@%/* check for new points lying on a line segment */%@AE@%%@NL@%
        for (i = 0; i < (int) (global.cptl - 1L); ++i)%@NL@%
            if (IsPtCloseToLine(&global.pptl[i], &global.pptl[i+1], pptl))%@NL@%
            {%@NL@%
                for (j = (int) global.cptl; j > i+1; --j)%@NL@%
                    global.pptl[j] = global.pptl[j - 1];%@NL@%
                global.pptl[i+1] = *pptl;%@NL@%
                ++global.cptl;%@NL@%
                return i+1;%@NL@%
            }%@NL@%
%@NL@%
        %@AB@%/* append the point */%@AE@%%@NL@%
%@NL@%
        i = (int) global.cptl;%@NL@%
        global.pptl[i] = *pptl;%@NL@%
        ++global.cptl;%@NL@%
        return i;%@NL@%
    }%@NL@%
%@NL@%
    return -1;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   IsPtCloseToLine%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
IsPtCloseToLine(pptl1, pptl2, pptlTest)%@NL@%
PPOINTL pptl1;%@NL@%
PPOINTL pptl2;%@NL@%
PPOINTL pptlTest;%@NL@%
{%@NL@%
    POINTL ptlLL, ptlUR;%@NL@%
    LONG dx, dy, yIntercept, result;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* find the bounding box of the line segment */%@AE@%%@NL@%
%@NL@%
    ptlLL = *pptl1;        %@AB@%/* assume line goes lower left to upper right */%@AE@%%@NL@%
    ptlUR = *pptl2;%@NL@%
    if (pptl1->x > pptl2->x)%@NL@%
        SwapLong(&ptlLL.x, &ptlUR.x);%@NL@%
    if (pptl1->y > pptl2->y)%@NL@%
        SwapLong(&ptlLL.y, &ptlUR.y);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* adjust the bounding box if it's too narrow */%@AE@%%@NL@%
%@NL@%
    dx = pptl2->x - pptl1->x;%@NL@%
    if (abs(dx) <= (LONG) (global.ulHitPrecision >> 1))%@NL@%
    {%@NL@%
        ptlLL.x -= (LONG) (global.ulHitPrecision >> 1);%@NL@%
        ptlUR.x += (LONG) (global.ulHitPrecision >> 1);%@NL@%
    }%@NL@%
    dy = pptl2->y - pptl1->y;%@NL@%
    if (abs(dy) <= (LONG) (global.ulHitPrecision >> 1))%@NL@%
    {%@NL@%
        ptlLL.y -= (LONG) (global.ulHitPrecision >> 1);%@NL@%
        ptlUR.y += (LONG) (global.ulHitPrecision >> 1);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* see if the test point is in the bounding box of the line segment */%@AE@%%@NL@%
%@NL@%
    if ((pptlTest->x >= ptlLL.x) &&%@NL@%
        (pptlTest->x <= ptlUR.x) &&%@NL@%
        (pptlTest->y >= ptlLL.y) &&%@NL@%
        (pptlTest->y <= ptlUR.y))%@NL@%
    {%@NL@%
        %@AB@%/* test for special cases */%@AE@%%@NL@%
%@NL@%
        if (dx == 0)%@NL@%
        {%@NL@%
            if (abs(pptlTest->x - pptl1->x) <= (LONG) global.ulHitPrecision)%@NL@%
                return TRUE;%@NL@%
            else%@NL@%
                return FALSE;%@NL@%
        }%@NL@%
%@NL@%
        if (dy == 0)%@NL@%
        {%@NL@%
            if (abs(pptlTest->y - pptl1->y) <= (LONG) global.ulHitPrecision)%@NL@%
                return TRUE;%@NL@%
            else%@NL@%
                return FALSE;%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* test for general case */%@AE@%%@NL@%
%@NL@%
        yIntercept = pptl1->y - (pptl1->x * dy) / dx;%@NL@%
%@NL@%
        result = pptlTest->y - (pptlTest->x * dy / dx) - yIntercept;%@NL@%
        if (abs(result) <= (LONG) global.ulHitPrecision)%@NL@%
            return TRUE;%@NL@%
    }%@NL@%
%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   SwapLong%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
SwapLong(pl1, pl2)%@NL@%
PLONG pl1, pl2;%@NL@%
{%@NL@%
    LONG lTmp;%@NL@%
%@NL@%
    lTmp = *pl1;%@NL@%
    *pl1 = *pl2;%@NL@%
    *pl2 = lTmp;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Close%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
Close(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    WinPostMsg(hwnd, WM_QUIT, 0L, 0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Command%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Dispatches menu commands to the proper handlers.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%UPDATE_MENU_BOOL(var, val)                                \ %@NL@%
        {                                                        \%@NL@%
            TOGGLE_BOOL((var));                                 \%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, (val), (var));        \%@NL@%
        }%@NL@%
%@NL@%
%@AI@%#define %@AE@%UPDATE_MENU_LIST(var, val)                                \ %@NL@%
        {                                                        \%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, (var));         \%@NL@%
            (var) = (val);                                        \%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, (var));                \%@NL@%
        }%@NL@%
%@NL@%
VOID%@NL@%
Command(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    BOOL fRedraw = FALSE;%@NL@%
    int rc;%@NL@%
%@NL@%
    switch (id)%@NL@%
    {%@NL@%
    case IDM_ABOUT:%@NL@%
        rc = WinDlgBox(HWND_DESKTOP, hwnd, AboutDlgProc, (HMODULE) NULL, IDD_ABOUT, NULL);%@NL@%
        fRedraw = FALSE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_NOPRIM:%@NL@%
        global.flPrim = 0L;%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, IDM_POLYLINE, 0);%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, IDM_POLYFILLET, 0);%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, IDM_POLYSPLINE, 0);%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYLINE:%@NL@%
        global.flPrim ^= PRIM_POLYLINE;%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, id, (global.flPrim & PRIM_POLYLINE));%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYFILLET:%@NL@%
        global.flPrim ^= PRIM_POLYFILLET;%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, id, (global.flPrim & PRIM_POLYFILLET));%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYSPLINE:%@NL@%
        global.flPrim ^= PRIM_POLYSPLINE;%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, id, (global.flPrim & PRIM_POLYSPLINE));%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POINTARC:%@NL@%
        global.flPrim ^= PRIM_POINTARC;%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, id, (global.flPrim & PRIM_POINTARC));%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_CTLPOINTS:%@NL@%
        UPDATE_MENU_BOOL(global.fDisplayControlPoints, IDM_CTLPOINTS);%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_CLEARALL:%@NL@%
        global.cptl = 0L;%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    if (fRedraw)%@NL@%
    {%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
        Paint(hps, TRUE);%@NL@%
        WinReleasePS(hps);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Paint%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
Paint(hps, fClearScreen)%@NL@%
HPS  hps;%@NL@%
BOOL fClearScreen;%@NL@%
{%@NL@%
    LINEBUNDLE lb;%@NL@%
    RECTL rcl;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    if (fClearScreen)%@NL@%
    {%@NL@%
        %@AB@%/* clear the screen */%@AE@%%@NL@%
        WinQueryWindowRect(global.hwnd, &rcl);%@NL@%
        GpiBitBlt(hps, NULL, 2L, (PPOINTL) &rcl, ROP_ONE, 0L);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    if (global.cptl > 0L)%@NL@%
    {%@NL@%
        if (global.fDisplayControlPoints)%@NL@%
        {%@NL@%
            if (fClearScreen)%@NL@%
                %@AB@%/* draw all the control points */%@AE@%%@NL@%
                DrawControlPoints(hps, global.cptl, global.pptl);%@NL@%
            else if (global.usPtGrabbed != -1)%@NL@%
                %@AB@%/* draw just the control point that moved */%@AE@%%@NL@%
                DrawControlPoints(hps, 1L, global.pptl+global.usPtGrabbed);%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* set mix mode to xor */%@AE@%%@NL@%
        lb.usMixMode = FM_XOR;%@NL@%
        GpiSetAttrs(hps, PRIM_LINE, LBB_MIX_MODE, 0L, &lb);%@NL@%
%@NL@%
        %@AB@%/* draw the current primitives */%@AE@%%@NL@%
%@NL@%
        if (global.flPrim & PRIM_POLYLINE)%@NL@%
        {%@NL@%
            lb.lColor = CLR_BROWN;%@NL@%
            GpiSetAttrs(hps, PRIM_LINE, LBB_COLOR, 0L, &lb);%@NL@%
            DrawPrimitive(hps, IDM_POLYLINE);%@NL@%
        }%@NL@%
%@NL@%
        if (global.flPrim & PRIM_POLYFILLET)%@NL@%
        {%@NL@%
            lb.lColor = CLR_DARKCYAN;%@NL@%
            GpiSetAttrs(hps, PRIM_LINE, LBB_COLOR, 0L, &lb);%@NL@%
            DrawPrimitive(hps, IDM_POLYFILLET);%@NL@%
        }%@NL@%
%@NL@%
        if (global.flPrim & PRIM_POLYSPLINE)%@NL@%
        {%@NL@%
            lb.lColor = CLR_DARKPINK;%@NL@%
            GpiSetAttrs(hps, PRIM_LINE, LBB_COLOR, 0L, &lb);%@NL@%
            DrawPrimitive(hps, IDM_POLYSPLINE);%@NL@%
        }%@NL@%
%@NL@%
        if (global.flPrim & PRIM_POINTARC)%@NL@%
        {%@NL@%
            lb.lColor = CLR_BACKGROUND;%@NL@%
            GpiSetAttrs(hps, PRIM_LINE, LBB_COLOR, 0L, &lb);%@NL@%
            DrawPrimitive(hps, IDM_POINTARC);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawPrimitive%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawPrimitive(hps, usPrim)%@NL@%
HPS hps;%@NL@%
USHORT usPrim;%@NL@%
{%@NL@%
    switch ( usPrim )%@NL@%
    {%@NL@%
    case IDM_POLYLINE:%@NL@%
        DrawPolyLine(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYFILLET:%@NL@%
        DrawPolyFillet(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYSPLINE:%@NL@%
        DrawPolySpline(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POINTARC:%@NL@%
        DrawPointArc(hps);%@NL@%
        break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawPolyLine%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawPolyLine(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    GpiSetCurrentPosition( hps, global.pptl );%@NL@%
    GpiPolyLine( hps, global.cptl-1L, global.pptl+1 );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawPolyFillet%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawPolyFillet(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    if (global.cptl > 2)%@NL@%
    {%@NL@%
        GpiSetCurrentPosition( hps, global.pptl );%@NL@%
        GpiPolyFillet( hps, global.cptl-1L, global.pptl+1 );%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawPolySpline%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawPolySpline(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    USHORT cptSlack;        %@AB@%/* # points in pptl not usable by PolySpline */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* GpiPolySpline expects the number of points to be a%@NL@%
%@AB@%       multiple of 3.  If we have a non-multiple of three,%@NL@%
%@AB@%       (excluding the first point, which we've used to set%@NL@%
%@AB@%       the current position), only pass the largest multiple%@NL@%
%@AB@%       of three, saving the rest for the next go-round. */%@AE@%%@NL@%
%@NL@%
    cptSlack = (int)((global.cptl-1L) % 3) + 1;%@NL@%
    GpiSetCurrentPosition( hps, global.pptl );%@NL@%
    GpiPolySpline( hps, global.cptl-cptSlack,%@NL@%
                   global.pptl+1 );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawPointArc%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawPointArc(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    if (global.cptl >= 3L)%@NL@%
    {%@NL@%
        GpiSetCurrentPosition( hps, global.pptl );%@NL@%
        GpiPointArc( hps, global.pptl+1 );%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawControlPoints%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawControlPoints(hps, cptl, pptl)%@NL@%
HPS hps;%@NL@%
LONG cptl;%@NL@%
PPOINTL pptl;%@NL@%
{%@NL@%
    MARKERBUNDLE mb;%@NL@%
%@NL@%
    mb.lColor = CLR_TRUE;%@NL@%
    mb.usMixMode = FM_XOR;%@NL@%
    GpiSetAttrs(hps, PRIM_MARKER, MBB_COLOR | MBB_MIX_MODE, 0L, &mb);%@NL@%
%@NL@%
    GpiPolyMarker(hps, cptl, pptl);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MyMessageBox%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Displays a message box with the given string.  To simplify matters,%@NL@%
%@AB@%*   the box will always have the same title ("PolyLine Editor"), will always%@NL@%
%@AB@%*   have a single button ("Ok"), will always have an exclamation point%@NL@%
%@AB@%*   icon, and will always be application modal.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MyMessageBox(hWnd, sz)%@NL@%
HWND hWnd;%@NL@%
PSZ sz;%@NL@%
{%@NL@%
    static char *szTitle = "PolyLine Editor";%@NL@%
%@NL@%
    WinMessageBox(HWND_DESKTOP, hWnd, sz, szTitle, (HMODULE) NULL,%@NL@%
                  MB_OK|MB_ICONEXCLAMATION|MB_APPLMODAL);%@NL@%
}%@NL@%
%@NL@%
MRESULT EXPENTRY AboutDlgProc(hDlg, msg, mp1, mp2)%@NL@%
%@AB@%/*%@NL@%
%@AB@%    About... dialog procedure%@NL@%
%@AB@%*/%@AE@%%@NL@%
HWND        hDlg;%@NL@%
USHORT        msg;%@NL@%
MPARAM        mp1;%@NL@%
MPARAM        mp2;%@NL@%
{%@NL@%
    switch(msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case DID_OK: WinDismissDlg(hDlg, TRUE); break;%@NL@%
                default: break;%@NL@%
            }%@NL@%
        default: return WinDefDlgProc(hDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EDPLINE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CLIPVIEW\EDPLINE\EDPLINE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    edpline.c -- polyline editor, for practice in mouse handling%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINSWITCHLIST %@NL@%
%@AI@%#define %@AE@%INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@AI@%#define %@AE@%       INCL_GPITRANSFORMS %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%       INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%       INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%       INCL_WINCLIPBOARD %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"edpline.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%       abs(x)                        (((x) > 0) ? (x) : -(x)) %@NL@%
%@AI@%#define %@AE@%PRIM_POLYLINE                0x0001 %@NL@%
%@AI@%#define %@AE@%PRIM_POLYFILLET         0x0002 %@NL@%
%@AI@%#define %@AE@%PRIM_POLYSPLINE         0x0004 %@NL@%
%@AI@%#define %@AE@%PRIM_POINTARC                0x0008 %@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Function declarations%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AB@%/* Private functions */%@AE@%%@NL@%
%@NL@%
VOID   cdecl main(VOID);%@NL@%
BOOL   InitGlobals(VOID);%@NL@%
BOOL   InitApp(VOID);%@NL@%
VOID   Close(HWND);%@NL@%
VOID   Command(HWND, USHORT);%@NL@%
VOID   Paint(HPS, BOOL);%@NL@%
VOID   MouseMove(HWND, MPARAM);%@NL@%
VOID   ButtonUp(HWND, USHORT);%@NL@%
VOID   ButtonDown(HWND, USHORT, MPARAM);%@NL@%
USHORT IsPtInList(PPOINTL);%@NL@%
USHORT AddPtToList(PPOINTL);%@NL@%
BOOL   IsPtCloseToLine(PPOINTL, PPOINTL, PPOINTL);%@NL@%
VOID   DrawPrimitive(HPS, USHORT);%@NL@%
VOID   DrawPolyLine(HPS);%@NL@%
VOID   DrawPolyFillet(HPS);%@NL@%
VOID   DrawPolySpline(HPS);%@NL@%
VOID   DrawPointArc(HPS);%@NL@%
VOID   DrawControlPoints(HPS, LONG, PPOINTL);%@NL@%
VOID   MyMessageBox(HWND, PSZ);%@NL@%
VOID   SwapLong(PLONG, PLONG);%@NL@%
%@NL@%
%@AB@%/* Exported functions */%@AE@%%@NL@%
%@NL@%
ULONG        CALLBACK WndProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT CALLBACK AboutDlgProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Global Variables%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
typedef struct%@NL@%
{%@NL@%
    HAB  hab;%@NL@%
    HMQ  hMsgQ;%@NL@%
    HWND hwndFrame;%@NL@%
    HWND hwnd;%@NL@%
%@NL@%
    ULONG   flPrim;%@NL@%
    BOOL    fDisplayControlPoints;%@NL@%
    LONG    cptl;%@NL@%
    PPOINTL pptl;%@NL@%
%@NL@%
    USHORT  usPtGrabbed;%@NL@%
    BOOL    fDragging;%@NL@%
%@NL@%
    ULONG   ulHitPrecision;%@NL@%
%@NL@%
    HPS     hpsMetafile;%@NL@%
    HDC     hdcMetafile;%@NL@%
    ULONG   hItem;%@NL@%
    SIZEL   sizlPage;%@NL@%
    DEVOPENSTRUC dop;%@NL@%
%@NL@%
} GLOBALDATA;%@NL@%
GLOBALDATA global;%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   main%@NL@%
%@AB@%*%@NL@%
%@AB@%*   WinInitialize resizes our ring 2 stack, among other things, so%@NL@%
%@AB@%*   we won't GP fault trying to do graphics.  WinCreateMsgQueue defines%@NL@%
%@AB@%*   us as a REAL PM app. (as well as the WINDOWAPI statement in the .DEF%@NL@%
%@AB@%*   file...)   Call a sub to register our window class and create a window.%@NL@%
%@AB@%*   Loop over messages.  Exit cleanly.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID cdecl%@NL@%
main()%@NL@%
{%@NL@%
    QMSG qMsg;%@NL@%
    int iRet = 0;%@NL@%
%@NL@%
%@NL@%
    global.hab         = WinInitialize(0);%@NL@%
    global.hMsgQ = WinCreateMsgQueue(global.hab, 0);%@NL@%
%@NL@%
    if (InitApp())%@NL@%
        while (WinGetMsg( global.hab, (PQMSG)&qMsg, (HWND)NULL, 0, 0 ))%@NL@%
            WinDispatchMsg( global.hab, (PQMSG)&qMsg );%@NL@%
    else%@NL@%
        iRet = -1;%@NL@%
%@NL@%
    WinDestroyWindow( global.hwndFrame );%@NL@%
    WinDestroyMsgQueue( global.hMsgQ );%@NL@%
    WinTerminate( global.hab );%@NL@%
    DosExit(EXIT_PROCESS, iRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   InitGlobals%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Initialize global variables.%@NL@%
%@AB@%*%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
InitGlobals()%@NL@%
{%@NL@%
    global.flPrim = PRIM_POLYLINE;%@NL@%
    global.fDisplayControlPoints = TRUE;%@NL@%
%@NL@%
    global.cptl = 0L;%@NL@%
    global.pptl = NULL;%@NL@%
    if (DosAllocSeg(CPTLMAX * sizeof(POINTL),%@NL@%
                   ((PUSHORT)&global.pptl)+1, 0))%@NL@%
        return FALSE;%@NL@%
%@NL@%
    global.usPtGrabbed = -1;%@NL@%
    global.fDragging = FALSE;%@NL@%
    global.ulHitPrecision = 0L;%@NL@%
%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   InitApp%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Register application window class and creates standard window.%@NL@%
%@AB@%*%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INIT_MENU_ITEM(val, var)     \ %@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, (val), (var))%@NL@%
%@NL@%
BOOL%@NL@%
InitApp()%@NL@%
{%@NL@%
    char szTitle[24];%@NL@%
    ULONG ctldata;%@NL@%
    PID pid;%@NL@%
    TID tid;%@NL@%
    HSWITCH hsw;%@NL@%
    static SWCNTRL swctl = { 0, 0, 0, 0, 0, SWL_VISIBLE,%@NL@%
                             SWL_JUMPABLE, "Edit Polyline", 0 };%@NL@%
%@NL@%
    if (!InitGlobals())%@NL@%
        return FALSE;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*  Register Application Window Class  */%@AE@%%@NL@%
%@NL@%
    WinLoadString( global.hab, (HMODULE) NULL, IDS_TITLE, sizeof(szTitle), (PCH)szTitle );%@NL@%
    if ( !WinRegisterClass( global.hab, (PCH)szTitle, (PFNWP)WndProc,%@NL@%
            CS_SIZEREDRAW, 0 ))%@NL@%
        return FALSE;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Create a window instance of class "PolyLine Editor" */%@AE@%%@NL@%
%@NL@%
    ctldata = FCF_STANDARD &%@NL@%
     ~(ULONG)(FCF_ICON | FCF_TASKLIST);%@NL@%
%@NL@%
    if (global.hwndFrame = WinCreateStdWindow(%@NL@%
        HWND_DESKTOP,                   %@AB@%/* specify desktop as parent window            */%@AE@%%@NL@%
        WS_VISIBLE,                   %@AB@%/* window styles                            */%@AE@%%@NL@%
        &ctldata,                   %@AB@%/* frame creation flags                    */%@AE@%%@NL@%
        (PCH)szTitle,                   %@AB@%/* window class name                     */%@AE@%%@NL@%
        (PCH)szTitle,                   %@AB@%/* name appearing in window caption            */%@AE@%%@NL@%
        0L,                           %@AB@%/*                                            */%@AE@%%@NL@%
        (HMODULE)NULL,                   %@AB@%/* use current executable module id            */%@AE@%%@NL@%
        IDR_EDPLINE,                   %@AB@%/* menu id                                    */%@AE@%%@NL@%
        (HWND FAR *)&global.hwnd   %@AB@%/* window handle                            */%@AE@%%@NL@%
        ))%@NL@%
    {%@NL@%
        INIT_MENU_ITEM(IDM_CTLPOINTS, global.fDisplayControlPoints);%@NL@%
%@NL@%
        if (global.flPrim & PRIM_POLYLINE)%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, IDM_POLYLINE);%@NL@%
        if (global.flPrim & PRIM_POLYFILLET)%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, IDM_POLYFILLET);%@NL@%
        if (global.flPrim & PRIM_POLYSPLINE)%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, IDM_POLYSPLINE);%@NL@%
        if (global.flPrim & PRIM_POINTARC)%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, IDM_POINTARC);%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* Add ourselves to the switch list. */%@AE@%%@NL@%
%@NL@%
        WinQueryWindowProcess(global.hwndFrame, &pid, &tid);%@NL@%
        swctl.hwnd        = global.hwndFrame;%@NL@%
        swctl.idProcess = pid;%@NL@%
        hsw = WinAddSwitchEntry(&swctl);%@NL@%
%@NL@%
        return TRUE;%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   WndProc%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the window class.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
WndProc( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
    HPS   hps;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_CLOSE:%@NL@%
        Close(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        Command(hwnd, LOUSHORT(mp1));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        hps = WinBeginPaint(global.hwnd, NULL, NULL);%@NL@%
%@NL@%
        if (global.ulHitPrecision == 0L)%@NL@%
        {%@NL@%
            HDC hdc;%@NL@%
            LONG cx;%@NL@%
%@NL@%
            if (hdc = WinQueryWindowDC(global.hwnd)) {%@NL@%
                DevQueryCaps(hdc, CAPS_MARKER_WIDTH,  1L,  &cx);%@NL@%
                global.ulHitPrecision = (cx >> 17) + 1L;%@NL@%
            } else {%@NL@%
                global.ulHitPrecision = 6L;%@NL@%
            }%@NL@%
        }%@NL@%
        Paint(hps, TRUE);%@NL@%
        WinEndPaint(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1DOWN:%@NL@%
    case WM_BUTTON2DOWN:%@NL@%
        ButtonDown(hwnd, usMsg, mp1);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1UP:%@NL@%
    case WM_BUTTON2UP:%@NL@%
        ButtonUp(hwnd, usMsg);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_MOUSEMOVE:%@NL@%
        MouseMove(hwnd, mp1);%@NL@%
        return( (ULONG)WinDefWindowProc(hwnd, usMsg, mp1, mp2));%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return( (ULONG)WinDefWindowProc(hwnd, usMsg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MouseMove%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MouseMove(hwnd, mp1)%@NL@%
HWND hwnd;%@NL@%
MPARAM mp1;%@NL@%
{%@NL@%
    POINTL ptl;%@NL@%
    HPS hps;%@NL@%
%@NL@%
    if (hwnd == global.hwnd)%@NL@%
        if (global.fDragging)%@NL@%
        {%@NL@%
            ptl.x = (LONG) LOUSHORT(mp1);%@NL@%
            ptl.y = (LONG) HIUSHORT(mp1);%@NL@%
%@NL@%
            if (global.usPtGrabbed != -1)%@NL@%
            {%@NL@%
                hps = WinGetPS(hwnd);%@NL@%
                Paint(hps, FALSE);%@NL@%
%@NL@%
                *(global.pptl+global.usPtGrabbed) = ptl;%@NL@%
%@NL@%
                Paint(hps, FALSE);%@NL@%
                WinReleasePS(hps);%@NL@%
            }%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ButtonUp%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
ButtonUp(hwnd, usMsg)%@NL@%
HWND hwnd;%@NL@%
USHORT usMsg;%@NL@%
{%@NL@%
    int i;%@NL@%
    HPS hps;%@NL@%
%@NL@%
%@NL@%
    if (hwnd == global.hwnd)%@NL@%
        if (global.fDragging)%@NL@%
        {%@NL@%
            global.fDragging = FALSE;%@NL@%
            if (global.usPtGrabbed != -1)%@NL@%
            {%@NL@%
                if (usMsg == WM_BUTTON2UP)%@NL@%
                {%@NL@%
                    hps = WinGetPS(hwnd);%@NL@%
                    Paint(hps, FALSE);%@NL@%
%@NL@%
                    if ((i = global.usPtGrabbed) < (int) global.cptl-1)%@NL@%
                        while (i < (int) global.cptl-1)%@NL@%
                        {%@NL@%
                            global.pptl[i] = global.pptl[i+1];%@NL@%
                            ++i;%@NL@%
                        }%@NL@%
%@NL@%
                    --global.cptl;%@NL@%
                    global.usPtGrabbed = -1;%@NL@%
%@NL@%
                    Paint(hps, FALSE);%@NL@%
                    WinReleasePS(hps);%@NL@%
                }%@NL@%
                else        %@AB@%/* WM_BUTTON1UP */%@AE@%%@NL@%
                    global.usPtGrabbed = -1;%@NL@%
            }%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ButtonDown%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
ButtonDown(hwnd, usMsg, mp1)%@NL@%
HWND hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
{%@NL@%
    POINTL ptl;%@NL@%
    HPS hps;%@NL@%
    USHORT usNewPtGrabbed;%@NL@%
%@NL@%
%@NL@%
    if (hwnd == global.hwnd)%@NL@%
        if (!global.fDragging)%@NL@%
        {%@NL@%
            global.fDragging = TRUE;%@NL@%
%@NL@%
            ptl.x = (LONG) LOUSHORT(mp1);%@NL@%
            ptl.y = (LONG) HIUSHORT(mp1);%@NL@%
%@NL@%
            if ((usNewPtGrabbed = IsPtInList(&ptl)) != -1)%@NL@%
                global.usPtGrabbed = usNewPtGrabbed;%@NL@%
%@NL@%
            if (usMsg == WM_BUTTON1DOWN)%@NL@%
            {%@NL@%
                hps = WinGetPS(hwnd);%@NL@%
                Paint(hps, FALSE);%@NL@%
%@NL@%
                if (usNewPtGrabbed == -1)%@NL@%
                    global.usPtGrabbed = AddPtToList(&ptl);%@NL@%
                else%@NL@%
                    global.usPtGrabbed = usNewPtGrabbed;%@NL@%
%@NL@%
                Paint(hps, FALSE);%@NL@%
                WinReleasePS(hps);%@NL@%
%@NL@%
                if (global.usPtGrabbed == -1)%@NL@%
                    MyMessageBox(global.hwnd, "Cannot add any more points.");%@NL@%
            }%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   IsPtInList%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
USHORT%@NL@%
IsPtInList(pptl)%@NL@%
PPOINTL pptl;%@NL@%
{%@NL@%
    int i;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* try to find pptl in the points we already have */%@AE@%%@NL@%
    for (i = 0; i < (int) global.cptl; ++i)%@NL@%
        if (((abs(pptl->x - global.pptl[i].x))%@NL@%
                <= (LONG) global.ulHitPrecision)%@NL@%
         && ((abs(pptl->y - global.pptl[i].y))%@NL@%
                <= (LONG) global.ulHitPrecision))%@NL@%
                return i;%@NL@%
%@NL@%
    %@AB@%/* couldn't find it */%@AE@%%@NL@%
    return -1;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   AddPtToList%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
USHORT%@NL@%
AddPtToList(pptl)%@NL@%
PPOINTL pptl;%@NL@%
{%@NL@%
    int i, j;%@NL@%
%@NL@%
    if (global.cptl < CPTLMAX)%@NL@%
    {%@NL@%
        %@AB@%/* check for new points lying on a line segment */%@AE@%%@NL@%
        for (i = 0; i < (int) (global.cptl - 1L); ++i)%@NL@%
            if (IsPtCloseToLine(&global.pptl[i], &global.pptl[i+1], pptl))%@NL@%
            {%@NL@%
                for (j = (int) global.cptl; j > i+1; --j)%@NL@%
                    global.pptl[j] = global.pptl[j - 1];%@NL@%
                global.pptl[i+1] = *pptl;%@NL@%
                ++global.cptl;%@NL@%
                return i+1;%@NL@%
            }%@NL@%
%@NL@%
        %@AB@%/* append the point */%@AE@%%@NL@%
%@NL@%
        i = (int) global.cptl;%@NL@%
        global.pptl[i] = *pptl;%@NL@%
        ++global.cptl;%@NL@%
        return i;%@NL@%
    }%@NL@%
%@NL@%
    return -1;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   IsPtCloseToLine%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
IsPtCloseToLine(pptl1, pptl2, pptlTest)%@NL@%
PPOINTL pptl1;%@NL@%
PPOINTL pptl2;%@NL@%
PPOINTL pptlTest;%@NL@%
{%@NL@%
    POINTL ptlLL, ptlUR;%@NL@%
    LONG dx, dy, yIntercept, result;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* find the bounding box of the line segment */%@AE@%%@NL@%
%@NL@%
    ptlLL = *pptl1;        %@AB@%/* assume line goes lower left to upper right */%@AE@%%@NL@%
    ptlUR = *pptl2;%@NL@%
    if (pptl1->x > pptl2->x)%@NL@%
        SwapLong(&ptlLL.x, &ptlUR.x);%@NL@%
    if (pptl1->y > pptl2->y)%@NL@%
        SwapLong(&ptlLL.y, &ptlUR.y);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* adjust the bounding box if it's too narrow */%@AE@%%@NL@%
%@NL@%
    dx = pptl2->x - pptl1->x;%@NL@%
    if (abs(dx) <= (LONG) (global.ulHitPrecision >> 1))%@NL@%
    {%@NL@%
        ptlLL.x -= (LONG) (global.ulHitPrecision >> 1);%@NL@%
        ptlUR.x += (LONG) (global.ulHitPrecision >> 1);%@NL@%
    }%@NL@%
    dy = pptl2->y - pptl1->y;%@NL@%
    if (abs(dy) <= (LONG) (global.ulHitPrecision >> 1))%@NL@%
    {%@NL@%
        ptlLL.y -= (LONG) (global.ulHitPrecision >> 1);%@NL@%
        ptlUR.y += (LONG) (global.ulHitPrecision >> 1);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* see if the test point is in the bounding box of the line segment */%@AE@%%@NL@%
%@NL@%
    if ((pptlTest->x >= ptlLL.x) &&%@NL@%
        (pptlTest->x <= ptlUR.x) &&%@NL@%
        (pptlTest->y >= ptlLL.y) &&%@NL@%
        (pptlTest->y <= ptlUR.y))%@NL@%
    {%@NL@%
        %@AB@%/* test for special cases */%@AE@%%@NL@%
%@NL@%
        if (dx == 0)%@NL@%
        {%@NL@%
            if (abs(pptlTest->x - pptl1->x) <= (LONG) global.ulHitPrecision)%@NL@%
                return TRUE;%@NL@%
            else%@NL@%
                return FALSE;%@NL@%
        }%@NL@%
%@NL@%
        if (dy == 0)%@NL@%
        {%@NL@%
            if (abs(pptlTest->y - pptl1->y) <= (LONG) global.ulHitPrecision)%@NL@%
                return TRUE;%@NL@%
            else%@NL@%
                return FALSE;%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* test for general case */%@AE@%%@NL@%
%@NL@%
        yIntercept = pptl1->y - (pptl1->x * dy) / dx;%@NL@%
%@NL@%
        result = pptlTest->y - (pptlTest->x * dy / dx) - yIntercept;%@NL@%
        if (abs(result) <= (LONG) global.ulHitPrecision)%@NL@%
            return TRUE;%@NL@%
    }%@NL@%
%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   SwapLong%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
SwapLong(pl1, pl2)%@NL@%
PLONG pl1, pl2;%@NL@%
{%@NL@%
    LONG lTmp;%@NL@%
%@NL@%
    lTmp = *pl1;%@NL@%
    *pl1 = *pl2;%@NL@%
    *pl2 = lTmp;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Close%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
Close(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    WinPostMsg(hwnd, WM_QUIT, 0L, 0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Command%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Dispatches menu commands to the proper handlers.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%UPDATE_MENU_BOOL(var, val)                                \ %@NL@%
        {                                                        \%@NL@%
            TOGGLE_BOOL((var));                                 \%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, (val), (var));        \%@NL@%
        }%@NL@%
%@NL@%
%@AI@%#define %@AE@%UPDATE_MENU_LIST(var, val)                                \ %@NL@%
        {                                                        \%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, (var));         \%@NL@%
            (var) = (val);                                        \%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, (var));                \%@NL@%
        }%@NL@%
%@NL@%
VOID%@NL@%
Command(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    BOOL fRedraw = FALSE;%@NL@%
    int rc;%@NL@%
%@NL@%
    switch (id)%@NL@%
    {%@NL@%
    case IDM_ABOUT:%@NL@%
        rc = WinDlgBox(HWND_DESKTOP, hwnd, AboutDlgProc, (HMODULE) NULL, IDD_ABOUT, NULL);%@NL@%
        fRedraw = FALSE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_NOPRIM:%@NL@%
        global.flPrim = 0L;%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, IDM_POLYLINE, 0);%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, IDM_POLYFILLET, 0);%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, IDM_POLYSPLINE, 0);%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYLINE:%@NL@%
        global.flPrim ^= PRIM_POLYLINE;%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, id, (global.flPrim & PRIM_POLYLINE));%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYFILLET:%@NL@%
        global.flPrim ^= PRIM_POLYFILLET;%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, id, (global.flPrim & PRIM_POLYFILLET));%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYSPLINE:%@NL@%
        global.flPrim ^= PRIM_POLYSPLINE;%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, id, (global.flPrim & PRIM_POLYSPLINE));%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POINTARC:%@NL@%
        global.flPrim ^= PRIM_POINTARC;%@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, id, (global.flPrim & PRIM_POINTARC));%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_CTLPOINTS:%@NL@%
        UPDATE_MENU_BOOL(global.fDisplayControlPoints, IDM_CTLPOINTS);%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_CLEARALL:%@NL@%
        global.cptl = 0L;%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_COPY:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            To put this image on the clipboard, create a Metafile DC.%@NL@%
%@AB@%%@NL@%
%@AB@%            Associate a presentation space with the DC, then play the%@NL@%
%@AB@%            drawing orders into the metafile.%@NL@%
%@AB@%        */%@AE@%%@NL@%
        global.dop.pszLogAddress = NULL;%@NL@%
        global.dop.pszDriverName = "DISPLAY";%@NL@%
        global.dop.pdriv = NULL;%@NL@%
        global.dop.pszDataType = NULL;%@NL@%
%@NL@%
        global.hdcMetafile = DevOpenDC(global.hab, OD_METAFILE,%@NL@%
                            "*", 4L, (PDEVOPENDATA) &global.dop, NULL);%@NL@%
        global.hpsMetafile = GpiCreatePS(global.hab, global.hdcMetafile,%@NL@%
                                    &global.sizlPage, PU_PELS | GPIA_ASSOC);%@NL@%
%@NL@%
        Paint(global.hpsMetafile, TRUE);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Clean up.  A handle to the metafile is obtained when%@NL@%
%@AB@%            calling DevCloseDC().%@NL@%
%@AB@%        */%@AE@%%@NL@%
        GpiAssociate(global.hpsMetafile, NULL);%@NL@%
        GpiDestroyPS(global.hpsMetafile);%@NL@%
        global.hItem = (ULONG) DevCloseDC(global.hdcMetafile);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Be sure to empty the clipboard of other data.  This will%@NL@%
%@AB@%            also empty previous data stored in other formats.%@NL@%
%@AB@%            Then, set the clipboard data with type METAFILE, passing%@NL@%
%@AB@%            the handle to our metafile.%@NL@%
%@AB@%        */%@AE@%%@NL@%
        if (WinOpenClipbrd(global.hab)) {%@NL@%
            WinEmptyClipbrd(global.hab);%@NL@%
            WinSetClipbrdData(global.hab,global.hItem, CF_METAFILE, CFI_HANDLE);%@NL@%
            WinCloseClipbrd(global.hab);%@NL@%
        }%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    if (fRedraw)%@NL@%
    {%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
        Paint(hps, TRUE);%@NL@%
        WinReleasePS(hps);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Paint%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
Paint(hps, fClearScreen)%@NL@%
HPS  hps;%@NL@%
BOOL fClearScreen;%@NL@%
{%@NL@%
    LINEBUNDLE lb;%@NL@%
    RECTL rcl;%@NL@%
    if (fClearScreen)%@NL@%
    {%@NL@%
        %@AB@%/* clear the screen */%@AE@%%@NL@%
        WinQueryWindowRect(global.hwnd, &rcl);%@NL@%
        GpiBitBlt(hps, NULL, 2L, (PPOINTL) &rcl, ROP_ONE, 0L);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    if (global.cptl > 0L)%@NL@%
    {%@NL@%
        if (global.fDisplayControlPoints)%@NL@%
        {%@NL@%
            if (fClearScreen)%@NL@%
                %@AB@%/* draw all the control points */%@AE@%%@NL@%
                DrawControlPoints(hps, global.cptl, global.pptl);%@NL@%
            else if (global.usPtGrabbed != -1)%@NL@%
                %@AB@%/* draw just the control point that moved */%@AE@%%@NL@%
                DrawControlPoints(hps, 1L, global.pptl+global.usPtGrabbed);%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* set mix mode to xor */%@AE@%%@NL@%
        lb.usMixMode = FM_XOR;%@NL@%
        GpiSetAttrs(hps, PRIM_LINE, LBB_MIX_MODE, 0L, &lb);%@NL@%
%@NL@%
        %@AB@%/* draw the current primitives */%@AE@%%@NL@%
%@NL@%
        if (global.flPrim & PRIM_POLYLINE)%@NL@%
        {%@NL@%
            lb.lColor = CLR_BROWN;%@NL@%
            GpiSetAttrs(hps, PRIM_LINE, LBB_COLOR, 0L, &lb);%@NL@%
            DrawPrimitive(hps, IDM_POLYLINE);%@NL@%
        }%@NL@%
%@NL@%
        if (global.flPrim & PRIM_POLYFILLET)%@NL@%
        {%@NL@%
            lb.lColor = CLR_DARKCYAN;%@NL@%
            GpiSetAttrs(hps, PRIM_LINE, LBB_COLOR, 0L, &lb);%@NL@%
            DrawPrimitive(hps, IDM_POLYFILLET);%@NL@%
        }%@NL@%
%@NL@%
        if (global.flPrim & PRIM_POLYSPLINE)%@NL@%
        {%@NL@%
            lb.lColor = CLR_DARKPINK;%@NL@%
            GpiSetAttrs(hps, PRIM_LINE, LBB_COLOR, 0L, &lb);%@NL@%
            DrawPrimitive(hps, IDM_POLYSPLINE);%@NL@%
        }%@NL@%
%@NL@%
        if (global.flPrim & PRIM_POINTARC)%@NL@%
        {%@NL@%
            lb.lColor = CLR_BACKGROUND;%@NL@%
            GpiSetAttrs(hps, PRIM_LINE, LBB_COLOR, 0L, &lb);%@NL@%
            DrawPrimitive(hps, IDM_POINTARC);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawPrimitive%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawPrimitive(hps, usPrim)%@NL@%
HPS hps;%@NL@%
USHORT usPrim;%@NL@%
{%@NL@%
    switch ( usPrim )%@NL@%
    {%@NL@%
    case IDM_POLYLINE:%@NL@%
        DrawPolyLine(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYFILLET:%@NL@%
        DrawPolyFillet(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYSPLINE:%@NL@%
        DrawPolySpline(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POINTARC:%@NL@%
        DrawPointArc(hps);%@NL@%
        break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawPolyLine%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawPolyLine(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    GpiSetCurrentPosition( hps, global.pptl );%@NL@%
    GpiPolyLine( hps, global.cptl-1L, global.pptl+1 );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawPolyFillet%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawPolyFillet(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    if (global.cptl > 2)%@NL@%
    {%@NL@%
        GpiSetCurrentPosition( hps, global.pptl );%@NL@%
        GpiPolyFillet( hps, global.cptl-1L, global.pptl+1 );%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawPolySpline%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawPolySpline(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    USHORT cptSlack;        %@AB@%/* # points in pptl not usable by PolySpline */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* GpiPolySpline expects the number of points to be a%@NL@%
%@AB@%       multiple of 3.  If we have a non-multiple of three,%@NL@%
%@AB@%       (excluding the first point, which we've used to set%@NL@%
%@AB@%       the current position), only pass the largest multiple%@NL@%
%@AB@%       of three, saving the rest for the next go-round. */%@AE@%%@NL@%
%@NL@%
    cptSlack = (int)((global.cptl-1L) % 3) + 1;%@NL@%
    GpiSetCurrentPosition( hps, global.pptl );%@NL@%
    GpiPolySpline( hps, global.cptl-cptSlack,%@NL@%
                   global.pptl+1 );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawPointArc%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawPointArc(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    if (global.cptl >= 3L)%@NL@%
    {%@NL@%
        GpiSetCurrentPosition( hps, global.pptl );%@NL@%
        GpiPointArc( hps, global.pptl+1 );%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawControlPoints%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawControlPoints(hps, cptl, pptl)%@NL@%
HPS hps;%@NL@%
LONG cptl;%@NL@%
PPOINTL pptl;%@NL@%
{%@NL@%
    MARKERBUNDLE mb;%@NL@%
%@NL@%
    mb.lColor = CLR_TRUE;%@NL@%
    mb.usMixMode = FM_XOR;%@NL@%
    GpiSetAttrs(hps, PRIM_MARKER, MBB_COLOR | MBB_MIX_MODE, 0L, &mb);%@NL@%
%@NL@%
    GpiPolyMarker(hps, cptl, pptl);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MyMessageBox%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Displays a message box with the given string.  To simplify matters,%@NL@%
%@AB@%*   the box will always have the same title ("PolyLine Editor"), will always%@NL@%
%@AB@%*   have a single button ("Ok"), will always have an exclamation point%@NL@%
%@AB@%*   icon, and will always be application modal.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MyMessageBox(hWnd, sz)%@NL@%
HWND hWnd;%@NL@%
PSZ sz;%@NL@%
{%@NL@%
    static char *szTitle = "PolyLine Editor";%@NL@%
%@NL@%
    WinMessageBox(HWND_DESKTOP, hWnd, sz, szTitle, 0,%@NL@%
                  MB_OK|MB_ICONEXCLAMATION|MB_APPLMODAL);%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK AboutDlgProc(HWND hDlg, USHORT msg, MPARAM mp1, MPARAM mp2) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    About... dialog procedure%@NL@%
%@AB@%*/%@AE@%%@NL@%
    switch(msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case DID_OK: WinDismissDlg(hDlg, TRUE); break;%@NL@%
                default: break;%@NL@%
            }%@NL@%
        default: return WinDefDlgProc(hDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EXPAND.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\EXPAND\EXPAND.C%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_PM %@NL@%
%@AI@%#include %@AE@%<OS2.H> %@NL@%
%@AI@%#include %@AE@%"Expand.H" %@NL@%
%@NL@%
MRESULT EXPENTRY WndProc      (HWND, USHORT, MPARAM, MPARAM );%@NL@%
MRESULT EXPENTRY AboutDlgProc (HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT EXPENTRY DialogProc  (HWND, USHORT, MPARAM, MPARAM);%@NL@%
%@NL@%
int cdecl main(void);%@NL@%
%@NL@%
char szAppName[] = "Expand";%@NL@%
%@NL@%
HAB        hAB;%@NL@%
HMQ        hmqMsgQueue;%@NL@%
HWND        hWndMain,%@NL@%
        hWndFrame;%@NL@%
%@NL@%
int cdecl main()%@NL@%
{%@NL@%
    QMSG    qmsg;%@NL@%
    ULONG   ctlData;%@NL@%
%@NL@%
    hAB = WinInitialize (0);%@NL@%
    hmqMsgQueue = WinCreateMsgQueue (hAB, 0);%@NL@%
%@NL@%
    if (!WinRegisterClass (hAB,%@NL@%
                           szAppName,%@NL@%
                           WndProc,%@NL@%
                           CS_SYNCPAINT | CS_SIZEREDRAW,%@NL@%
                           0)) {%@NL@%
        return(0);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    ctlData = FCF_STANDARD;%@NL@%
    hWndFrame = WinCreateStdWindow ( HWND_DESKTOP,%@NL@%
                                    WS_VISIBLE,%@NL@%
                                    &ctlData,%@NL@%
                                    szAppName,%@NL@%
                                    NULL,%@NL@%
                                    0L,%@NL@%
                                    0,%@NL@%
                                    ID_RESOURCE,%@NL@%
                                    &hWndMain);%@NL@%
    WinSetWindowText (hWndFrame, szAppName);%@NL@%
    WinShowWindow (hWndFrame, TRUE);%@NL@%
%@NL@%
    while ( WinGetMsg (hAB, &qmsg, NULL, 0, 0)) {%@NL@%
        WinDispatchMsg (hAB, &qmsg);%@NL@%
    }%@NL@%
%@NL@%
    WinDestroyWindow   (hWndFrame);%@NL@%
    WinDestroyMsgQueue (hmqMsgQueue);%@NL@%
    WinTerminate       (hAB);%@NL@%
}%@NL@%
%@NL@%
MRESULT EXPENTRY WndProc (hWnd, msg, mp1, mp2)%@NL@%
    HWND    hWnd;%@NL@%
    USHORT  msg;%@NL@%
    MPARAM  mp1, mp2;%@NL@%
{%@NL@%
    HPS    hPS;%@NL@%
    RECTL   rclPaint, rclWindow;%@NL@%
    POINTL  ptlPatternRef;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            switch (COMMANDMSG(&msg)->cmd) {%@NL@%
                case IDM_ABOUT:%@NL@%
                    WinDlgBox(HWND_DESKTOP, hWnd, AboutDlgProc,%@NL@%
                        (HMODULE) NULL, ID_RESOURCE, NULL);%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_ITEM+1:%@NL@%
                    WinDlgBox(HWND_DESKTOP, hWnd, DialogProc,%@NL@%
                        (HMODULE) NULL, ID_DIALOG, NULL);%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_ITEM+2:%@NL@%
                case IDM_ITEM+3:%@NL@%
                case IDM_ITEM+4:%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_EXIT:%@NL@%
                    WinPostMsg (hWnd, WM_CLOSE, 0L, 0L);%@NL@%
                    break;%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case WM_HELP:%@NL@%
            WinMessageBox (HWND_DESKTOP, hWnd,%@NL@%
                "Help Not Implemented Yet.",%@NL@%
                " - Help - ",%@NL@%
                0,%@NL@%
                MB_OK | MB_MOVEABLE | MB_APPLMODAL);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_CLOSE:%@NL@%
            WinPostMsg (hWnd, WM_QUIT, 0L, 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_PAINT:%@NL@%
            hPS = WinBeginPaint (hWnd, NULL, &rclPaint);%@NL@%
%@NL@%
            WinQueryWindowRect(hWnd, &rclWindow);%@NL@%
            ptlPatternRef.x = rclWindow.xLeft;%@NL@%
            ptlPatternRef.y = rclWindow.yTop;%@NL@%
            GpiSetPatternRefPoint(hPS, &ptlPatternRef);%@NL@%
            WinFillRect(hPS, &rclPaint, SYSCLR_APPWORKSPACE);%@NL@%
%@NL@%
            WinEndPaint (hPS);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return (WinDefWindowProc (hWnd, msg, mp1, mp2));%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY AboutDlgProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    switch (msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch (COMMANDMSG(&msg)->cmd) {%@NL@%
                case IDB_OK:%@NL@%
                    WinDismissDlg (hwnd, TRUE);%@NL@%
                    return 0;%@NL@%
            }%@NL@%
            break;%@NL@%
     }%@NL@%
     return WinDefDlgProc (hwnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
MRESULT EXPENTRY DialogProc (HWND hDlg, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    SWP  swpDlg, swpParent, swpOwner;%@NL@%
    static HWND option, button1, button2, button3, button4;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
        case WM_INITDLG:%@NL@%
            WinSendDlgItemMsg (hDlg, 256, EM_SETTEXTLIMIT, MPFROMSHORT(8), 0L);%@NL@%
            WinQueryWindowPos (hDlg, &swpDlg);%@NL@%
            WinQueryWindowPos (WinQueryWindow(hDlg, QW_PARENT, FALSE), &swpParent);%@NL@%
            WinQueryWindowPos (WinQueryWindow(hDlg, QW_OWNER, FALSE), &swpOwner);%@NL@%
            swpDlg.x = swpOwner.x + ((swpOwner.cx / 2) - ((swpDlg.cx+120) / 2));%@NL@%
            swpDlg.y = swpOwner.y + ((swpOwner.cy / 2) - (swpDlg.cy / 2));%@NL@%
            WinSetMultWindowPos (hAB, &swpDlg, 1);%@NL@%
            option  = WinWindowFromID (hDlg, IDB_OPTION);%@NL@%
            button1 = WinWindowFromID (hDlg, IDB_RADIO1);%@NL@%
            WinShowWindow (button1, FALSE);%@NL@%
            button2 = WinWindowFromID (hDlg, IDB_RADIO2);%@NL@%
            WinShowWindow (button2, FALSE);%@NL@%
            button3 = WinWindowFromID (hDlg, IDB_RADIO3);%@NL@%
            WinShowWindow (button3, FALSE);%@NL@%
            button4 = WinWindowFromID (hDlg, IDB_RADIO4);%@NL@%
            WinShowWindow (button4, FALSE);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            switch (COMMANDMSG(&msg)->cmd) {%@NL@%
                case IDB_OPTION:%@NL@%
                    WinQueryWindowPos (hDlg, &swpDlg);%@NL@%
                    swpDlg.fs = SWP_SIZE;%@NL@%
                    swpDlg.cx += 120;%@NL@%
                    WinSetMultWindowPos (hAB, &swpDlg, 1);%@NL@%
                    WinEnableWindow (option, FALSE);%@NL@%
                    WinShowWindow (button1, TRUE);%@NL@%
                    WinShowWindow (button2, TRUE);%@NL@%
                    WinShowWindow (button3, TRUE);%@NL@%
                    WinShowWindow (button4, TRUE);%@NL@%
                    WinSetFocus (HWND_DESKTOP, button1);%@NL@%
                    return FALSE;%@NL@%
%@NL@%
                case IDB_OK:%@NL@%
                case IDB_CANCEL:%@NL@%
                    WinDismissDlg (hDlg, TRUE);%@NL@%
                    return 0;%@NL@%
            }%@NL@%
            break;%@NL@%
     }%@NL@%
     return WinDefDlgProc (hDlg, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FATPEL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\FATPEL\FATPEL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   fatpel.c -- The Diamond Metric, Theory vs. Practice%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
 %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%       INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINSWITCHLIST %@NL@%
%@AI@%#define %@AE@%INCL_WINTRACKRECT %@NL@%
%@AI@%#define %@AE@%INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%INCL_WINBUTTONS %@NL@%
%@AI@%#define %@AE@%INCL_GPILOGCOLORTABLE %@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%       INCL_GPITRANSFORMS %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%INCL_BITMAPFILEFORMAT %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_GPIREGIONS %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"opendlg.h" %@NL@%
%@AI@%#include %@AE@%"fatpel.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Function declarations%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AB@%/* Private functions */%@AE@%%@NL@%
%@NL@%
VOID  cdecl main(VOID);%@NL@%
BOOL  FAR InitGlobals(VOID);%@NL@%
BOOL  FAR InitApp(VOID);%@NL@%
VOID  Close(HWND);%@NL@%
VOID  Command(HWND, USHORT);%@NL@%
VOID  Paint(HPS, USHORT);%@NL@%
VOID  EraseBackground(HPS);%@NL@%
VOID  DrawGrid(HPS);%@NL@%
VOID  DisplayRenderedPels(HPS, USHORT);%@NL@%
VOID  DisplayControlPoints(HPS, LONG, PPOINTL, USHORT);%@NL@%
VOID  DisplayMathematicalObject(HPS, USHORT);%@NL@%
VOID  DrawFatPels(HPS);%@NL@%
VOID  DrawOneFatPel(HPS, PPOINTL, COLOR);%@NL@%
VOID  GetFatPelFromPt(PPOINTL, PPOINTL);%@NL@%
VOID  SetFatPel(PPOINTL, COLOR);%@NL@%
VOID  RoundControlPoints(HPS, LONG, PPOINTL, PPOINTL, LONG, LONG);%@NL@%
VOID  ComputeTransform(PRECTL, PRECTL);%@NL@%
VOID  DrawPrimitive(HPS, LONG, PPOINTL);%@NL@%
VOID  UpdateSurfaceDims(VOID);%@NL@%
VOID  MySetWindowLong        (HWND, USHORT, LONG);%@NL@%
VOID  MySetWindowLongHex(HWND, USHORT, LONG);%@NL@%
LONG  MyGetWindowLong        (HWND, USHORT);%@NL@%
VOID  MouseMove(HWND, MPARAM);%@NL@%
VOID  ButtonUp(HWND, USHORT);%@NL@%
VOID  ButtonDown(HWND, USHORT, MPARAM);%@NL@%
VOID  DragPelSize(HWND, POINTS);%@NL@%
VOID  WriteFile(HWND, HPS);%@NL@%
BOOL  WriteBMP(HFILE, HPS, PBITMAPINFOHEADER);%@NL@%
VOID  MyMessageBox(HWND, PSZ);%@NL@%
VOID  SaveWindowToFile(HWND);%@NL@%
SHORT IsPtInList(PPOINTL);%@NL@%
SHORT AddPtToList(PPOINTL);%@NL@%
BOOL  IsPtCloseToLine(PPOINTL, PPOINTL, PPOINTL);%@NL@%
VOID  SwapLong(PLONG, PLONG);%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Exported functions */%@AE@%%@NL@%
%@NL@%
ULONG CALLBACK WndProc         (HWND, USHORT, MPARAM, MPARAM);%@NL@%
ULONG CALLBACK AboutDlg  (HWND, USHORT, MPARAM, MPARAM);%@NL@%
ULONG CALLBACK ColorsDlg (HWND, USHORT, MPARAM, MPARAM);%@NL@%
ULONG CALLBACK PelSizeDlg(HWND, USHORT, MPARAM, MPARAM);%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Global Variables%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AB@%/* compute absolute value for arbitrary (in my case, LONG) number */%@AE@%%@NL@%
%@AB@%/* this is to avoid compiler warnings about data conversion */%@AE@%%@NL@%
%@AI@%#define %@AE@%L_ABS(x)        (((x) > 0) ? (x) : (-(x))) %@NL@%
%@NL@%
typedef struct%@NL@%
{%@NL@%
    HAB      hab;%@NL@%
    HMQ      hMsgQ;%@NL@%
    HWND     hwndFrame;%@NL@%
    HWND     hwnd;%@NL@%
%@NL@%
    BOOL     fFirstTime;   %@AB@%/* TRUE --> first time initialization of rcl */%@AE@%%@NL@%
    RECTL    rcl;           %@AB@%/* dimensions of client rectangle */%@AE@%%@NL@%
%@NL@%
    HPS      hpsFat;%@NL@%
    HDC      hdcFat;%@NL@%
    HBITMAP  hbmFat;%@NL@%
    HPS      hpsFatShadow;%@NL@%
    HDC      hdcFatShadow;%@NL@%
    HBITMAP  hbmFatShadow;%@NL@%
%@NL@%
    RECTL    rclFatBM;           %@AB@%/* dimensions of fatbits bitmap */%@AE@%%@NL@%
    RECTL    rclFat;           %@AB@%/* dimensions of active fat bits grid */%@AE@%%@NL@%
    LONG     cxFatPel;            %@AB@%/* width of fat pel */%@AE@%%@NL@%
    LONG     cyFatPel;            %@AB@%/* height of fat pel */%@AE@%%@NL@%
    LONG     cxHalfFatPel;%@NL@%
    LONG     cyHalfFatPel;%@NL@%
    USHORT   usPelShape;%@NL@%
%@NL@%
    MATRIXLF matlf;        %@AB@%/* goes from window coords to fatpel coords */%@AE@%%@NL@%
%@NL@%
    BOOL     fRGB;           %@AB@%/* TRUE --> color mode is RGB */%@AE@%%@NL@%
    COLOR    clrMathObj;%@NL@%
    COLOR    clrRenderedObj;%@NL@%
    COLOR    clrField;%@NL@%
    COLOR    clrCrossHair;%@NL@%
    COLOR    clrInterstice;%@NL@%
    COLOR    clrControlPoints;%@NL@%
%@NL@%
    COLOR    clrBlackIndex;%@NL@%
    COLOR    clrEditPel;%@NL@%
%@NL@%
    USHORT   usControlPointSymbol;%@NL@%
%@NL@%
    BOOL     fDisplayRenderedObj;%@NL@%
    BOOL     fDisplayMathObj;%@NL@%
    BOOL     fDisplayControlPoints;%@NL@%
    BOOL     fDisplayCrossHairs;%@NL@%
    BOOL     fDisplayPelBorder;%@NL@%
    BOOL     fRoundControlPoints;%@NL@%
    BOOL     fAutoRedraw;%@NL@%
    USHORT   usCurPrim;%@NL@%
    USHORT   usMix;%@NL@%
%@NL@%
    LONG     cptl;%@NL@%
    PPOINTL  pptl;%@NL@%
    PPOINTL  pptlTmp;%@NL@%
%@NL@%
    BOOL     fDraggingPelSize;%@NL@%
    HPOINTER hptrDragSize;%@NL@%
%@NL@%
    BOOL     fDraggingPelColor;%@NL@%
    HPOINTER hptrDragColor;%@NL@%
%@NL@%
    SHORT    sPtGrabbed;%@NL@%
    BOOL     fDraggingControlPoint;%@NL@%
    LONG     lHitPrecision;%@NL@%
%@NL@%
    BOOL     fEditPelColors;%@NL@%
%@NL@%
} GLOBALDATA;%@NL@%
GLOBALDATA global;%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   main%@NL@%
%@AB@%*%@NL@%
%@AB@%*   WinInitialize resizes our ring 2 stack, among other things, so%@NL@%
%@AB@%*   we won't GP fault trying to do graphics.  WinCreateMsgQueue defines%@NL@%
%@AB@%*   us as a REAL PM app. (WINDOWAPI in .DEF file does also).%@NL@%
%@AB@%*   Call a sub to register our window class and create a window.%@NL@%
%@AB@%*   Loop over messages.  Exit cleanly.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID cdecl%@NL@%
main()%@NL@%
{%@NL@%
    QMSG qMsg;%@NL@%
    int iRet = 0;%@NL@%
%@NL@%
%@NL@%
    global.hab         = WinInitialize(0);%@NL@%
    global.hMsgQ = WinCreateMsgQueue(global.hab, 0);%@NL@%
%@NL@%
    if (InitApp())%@NL@%
        while (WinGetMsg( global.hab, (PQMSG)&qMsg, (HWND)NULL, 0, 0 ))%@NL@%
            WinDispatchMsg( global.hab, (PQMSG)&qMsg );%@NL@%
    else%@NL@%
        iRet = -1;%@NL@%
%@NL@%
    WinDestroyWindow( global.hwndFrame );%@NL@%
    WinDestroyMsgQueue( global.hMsgQ );%@NL@%
    WinTerminate( global.hab );%@NL@%
    DosExit(EXIT_PROCESS, iRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   InitGlobals%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Initialize global variables.%@NL@%
%@AB@%*%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL FAR%@NL@%
InitGlobals()%@NL@%
{%@NL@%
    global.fFirstTime                 = TRUE;%@NL@%
%@NL@%
    global.rcl.xLeft                 = 0L;%@NL@%
    global.rcl.yBottom                 = 0L;%@NL@%
    global.rcl.xRight                 = 0L;%@NL@%
    global.rcl.yTop                 = 0L;%@NL@%
%@NL@%
    global.hpsFat                 = NULL;%@NL@%
    global.hdcFat                 = NULL;%@NL@%
    global.hbmFat                 = NULL;%@NL@%
    global.hpsFatShadow          = NULL;%@NL@%
    global.hdcFatShadow          = NULL;%@NL@%
    global.hbmFatShadow          = NULL;%@NL@%
    global.rclFatBM.xLeft         = 0L;%@NL@%
    global.rclFatBM.yBottom         = 0L;%@NL@%
    global.rclFatBM.xRight         = 0L;%@NL@%
    global.rclFatBM.yTop         = 0L;%@NL@%
%@NL@%
    global.cxFatPel                 = 32L;%@NL@%
    global.cyFatPel                 = 32L;%@NL@%
    global.cxHalfFatPel          = global.cxFatPel / 2L;%@NL@%
    global.cyHalfFatPel          = global.cyFatPel / 2L;%@NL@%
    global.usPelShape                 = IDD_CIRCLE;%@NL@%
%@NL@%
    global.fRGB                  = FALSE;%@NL@%
    global.clrMathObj                 = CLR_BLUE;%@NL@%
    global.clrRenderedObj         = CLR_NEUTRAL;%@NL@%
    global.clrField                 = CLR_CYAN;%@NL@%
    global.clrCrossHair          = CLR_DARKCYAN;%@NL@%
    global.clrInterstice         = CLR_BACKGROUND;%@NL@%
    global.clrControlPoints         = CLR_YELLOW;%@NL@%
%@NL@%
    global.clrBlackIndex         = CLR_ERROR;%@NL@%
    global.clrEditPel                 = CLR_ERROR;%@NL@%
%@NL@%
    global.usControlPointSymbol  = MARKSYM_SOLIDDIAMOND;%@NL@%
%@NL@%
    global.fDisplayRenderedObj         = TRUE;%@NL@%
    global.fDisplayMathObj         = TRUE;%@NL@%
    global.fDisplayControlPoints = TRUE;%@NL@%
    global.fDisplayCrossHairs         = TRUE;%@NL@%
    global.fDisplayPelBorder         = TRUE;%@NL@%
    global.fRoundControlPoints         = FALSE;%@NL@%
    global.fAutoRedraw                 = TRUE;%@NL@%
    global.usCurPrim                 = IDM_POLYLINE;%@NL@%
    global.usMix                 = FM_OVERPAINT;%@NL@%
%@NL@%
    global.fDraggingPelSize         = FALSE;%@NL@%
    global.fDraggingPelColor         = FALSE;%@NL@%
    global.fDraggingControlPoint = FALSE;%@NL@%
    global.sPtGrabbed                 = NO_POINT;%@NL@%
    global.lHitPrecision         = 0L;%@NL@%
%@NL@%
    global.fEditPelColors         = FALSE;%@NL@%
%@NL@%
%@NL@%
    global.cptl = 0L;%@NL@%
    global.pptl = NULL;%@NL@%
    if (DosAllocSeg(CPTLMAX * sizeof(POINTL),%@NL@%
                   ((PUSHORT)&global.pptl)+1, 0))%@NL@%
        return FALSE;%@NL@%
    global.pptlTmp = NULL;%@NL@%
    if (DosAllocSeg(CPTLMAX * sizeof(POINTL),%@NL@%
                   ((PUSHORT)&global.pptlTmp)+1, 0))%@NL@%
        return FALSE;%@NL@%
%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   InitApp%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Register application window class and creates standard window.%@NL@%
%@AB@%*%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
         %@NL@%
%@AI@%#define %@AE@%INIT_MENU_ITEM(val, var)     \ %@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, (val), (var))%@NL@%
%@NL@%
BOOL FAR%@NL@%
InitApp()%@NL@%
{%@NL@%
    char szTitle[24];%@NL@%
    ULONG ctldata;%@NL@%
    PID pid;%@NL@%
    TID tid;%@NL@%
    HSWITCH hsw;%@NL@%
    static SWCNTRL swctl = { 0, 0, 0, 0, 0, SWL_VISIBLE,%@NL@%
                             SWL_JUMPABLE, "FatPels", 0 };%@NL@%
%@NL@%
    if (!InitGlobals())%@NL@%
        return FALSE;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*  Register Application Window Class  */%@AE@%%@NL@%
%@NL@%
    WinLoadString( global.hab, (HMODULE) NULL, IDS_TITLE, sizeof(szTitle), (PCH)szTitle );%@NL@%
    if ( !WinRegisterClass( global.hab, (PCH)szTitle, (PFNWP)WndProc,%@NL@%
            CS_SIZEREDRAW, 0 ))%@NL@%
        return FALSE;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Load the pointer to use when dragging pel size. */%@AE@%%@NL@%
    if (!(global.hptrDragSize = WinLoadPointer( HWND_DESKTOP, (HMODULE) NULL, IDR_DRAGSIZEPTR )))%@NL@%
        return FALSE;%@NL@%
%@NL@%
    %@AB@%/* Load the pointer to use when dragging pel color. */%@AE@%%@NL@%
    if (!(global.hptrDragColor = WinLoadPointer( HWND_DESKTOP, (HMODULE) NULL, IDR_DRAGCOLORPTR )))%@NL@%
        return FALSE;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Create a window instance of class "FatPel" */%@AE@%%@NL@%
%@NL@%
    ctldata = FCF_STANDARD &%@NL@%
     ~(ULONG)(FCF_ICON | FCF_ACCELTABLE | FCF_TASKLIST);%@NL@%
%@NL@%
    if (global.hwndFrame = WinCreateStdWindow(%@NL@%
        HWND_DESKTOP,                   %@AB@%/* specify desktop as parent window            */%@AE@%%@NL@%
        WS_VISIBLE,                   %@AB@%/* window styles                            */%@AE@%%@NL@%
        &ctldata,                   %@AB@%/* frame creation flags                    */%@AE@%%@NL@%
        (PCH)szTitle,                   %@AB@%/* window class name                     */%@AE@%%@NL@%
        (PCH)szTitle,                   %@AB@%/* name appearing in window caption            */%@AE@%%@NL@%
        0L,                           %@AB@%/*                                            */%@AE@%%@NL@%
        (HMODULE)NULL,                   %@AB@%/* use current executable module id            */%@AE@%%@NL@%
        IDR_FATPEL,                   %@AB@%/* menu id                                    */%@AE@%%@NL@%
        (HWND FAR *)&global.hwnd   %@AB@%/* window handle                            */%@AE@%%@NL@%
        ))%@NL@%
    {%@NL@%
        INIT_MENU_ITEM(IDM_RENDEREDOBJ,         global.fDisplayRenderedObj);%@NL@%
        INIT_MENU_ITEM(IDM_MATHOBJ,         global.fDisplayMathObj);%@NL@%
        INIT_MENU_ITEM(IDM_CTLPOINTS,         global.fDisplayControlPoints);%@NL@%
        INIT_MENU_ITEM(IDM_CROSSHAIRS,         global.fDisplayCrossHairs);%@NL@%
        INIT_MENU_ITEM(IDM_PELBORDER,         global.fDisplayPelBorder);%@NL@%
        INIT_MENU_ITEM(IDM_ROUNDPOINTS,         global.fRoundControlPoints);%@NL@%
        INIT_MENU_ITEM(IDM_AUTOREDRAW,         global.fAutoRedraw);%@NL@%
        INIT_MENU_ITEM(IDM_EDITPELCOLORS, global.fEditPelColors);%@NL@%
%@NL@%
        CHECK_MENU_ITEM(global.hwndFrame, global.usCurPrim);%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* Add ourselves to the switch list. */%@AE@%%@NL@%
%@NL@%
        WinQueryWindowProcess(global.hwndFrame, &pid, &tid);%@NL@%
        swctl.hwnd        = global.hwndFrame;%@NL@%
        swctl.idProcess = pid;%@NL@%
        hsw = WinAddSwitchEntry(&swctl);%@NL@%
%@NL@%
        return TRUE;%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   WndProc%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the window class.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
WndProc( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND        hwnd;%@NL@%
USHORT        usMsg;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_CLOSE:%@NL@%
        Close(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        Command(hwnd, LOUSHORT(mp1));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        {%@NL@%
            HPS   hps;%@NL@%
%@NL@%
            if (global.fFirstTime)%@NL@%
            {%@NL@%
                SIZEF sizfx;%@NL@%
%@NL@%
                hps = WinGetPS(hwnd);%@NL@%
                GpiQueryMarkerBox(hps, &sizfx);%@NL@%
                global.lHitPrecision = sizfx.cx / 0x20000L + 1L;%@NL@%
                WinReleasePS(hps);%@NL@%
%@NL@%
                UpdateSurfaceDims();%@NL@%
                global.fFirstTime = FALSE;%@NL@%
            }%@NL@%
%@NL@%
            %@AB@%/* The small bitmap may have been resized since we last%@NL@%
%@AB@%             * painted, in which case it will have been initialized to%@NL@%
%@AB@%             * the field color.  Therefore, we will render the mathematical%@NL@%
%@AB@%             * object to make sure the right fatpels are there.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            global.usMix = FM_OVERPAINT;%@NL@%
            hps = WinBeginPaint(global.hwnd, NULL, NULL);%@NL@%
            Paint(hps, CLEAR_BACKGROUND|RENDER_MATH_OBJ);%@NL@%
            WinEndPaint(hps);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1DOWN:%@NL@%
    case WM_BUTTON2DOWN:%@NL@%
        ButtonDown(hwnd, usMsg, mp1);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1UP:%@NL@%
    case WM_BUTTON2UP:%@NL@%
        ButtonUp(hwnd, usMsg);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_MOUSEMOVE:%@NL@%
        MouseMove(hwnd, mp1);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_SIZE:%@NL@%
        UpdateSurfaceDims();%@NL@%
        return( (ULONG)WinDefWindowProc(hwnd, usMsg, mp1, mp2));%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return( (ULONG)WinDefWindowProc(hwnd, usMsg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MouseMove%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MouseMove(hwnd, mp1)%@NL@%
HWND hwnd;%@NL@%
MPARAM mp1;%@NL@%
{%@NL@%
    POINTL ptl;%@NL@%
    HPS hps;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* make sure we still have our pointer */%@AE@%%@NL@%
    %@AB@%/* notice the hierarchy of pointer modes */%@AE@%%@NL@%
%@NL@%
    if (global.fDraggingPelSize)%@NL@%
    {%@NL@%
        if (global.hptrDragSize)%@NL@%
            WinSetPointer(HWND_DESKTOP,global.hptrDragSize);%@NL@%
    }%@NL@%
    else if (global.fEditPelColors)%@NL@%
    {%@NL@%
        if (global.hptrDragColor)%@NL@%
            WinSetPointer(HWND_DESKTOP,global.hptrDragColor);%@NL@%
    }%@NL@%
    else%@NL@%
        WinSetPointer(HWND_DESKTOP,%@NL@%
                  WinQuerySysPointer(HWND_DESKTOP,SPTR_ARROW,FALSE));%@NL@%
%@NL@%
%@NL@%
    if (global.fDraggingPelColor)%@NL@%
    {%@NL@%
        POINTL ptl, ptlFat;%@NL@%
        HPS hps;%@NL@%
%@NL@%
%@NL@%
        ptl.x = (LONG) LOUSHORT(mp1);%@NL@%
        ptl.y = (LONG) HIUSHORT(mp1);%@NL@%
%@NL@%
        %@AB@%/* letting the point go negative causes overflow errors */%@AE@%%@NL@%
        if (ptl.x < 0)%@NL@%
            ptl.x = 0;%@NL@%
        if (ptl.y < 0)%@NL@%
            ptl.y = 0;%@NL@%
%@NL@%
        GetFatPelFromPt(&ptl, &ptlFat);%@NL@%
        SetFatPel(&ptlFat, global.clrEditPel);%@NL@%
%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
        Paint(hps, OVERRIDE_RENDERED_OBJ);%@NL@%
        Paint(hps, IGNORED);        %@AB@%/* this call just copies fatpels to the screen */%@AE@%%@NL@%
        WinReleasePS(hps);%@NL@%
    }%@NL@%
    else if (global.fDraggingControlPoint)%@NL@%
    {%@NL@%
        ptl.x = (LONG) LOUSHORT(mp1);%@NL@%
        ptl.y = (LONG) HIUSHORT(mp1);%@NL@%
%@NL@%
        %@AB@%/* letting the point go negative causes overflow errors */%@AE@%%@NL@%
        if (ptl.x < 0)%@NL@%
            ptl.x = 0;%@NL@%
        if (ptl.y < 0)%@NL@%
            ptl.y = 0;%@NL@%
%@NL@%
        if (global.sPtGrabbed != NO_POINT)%@NL@%
        {%@NL@%
            hps = WinGetPS(hwnd);%@NL@%
            Paint(hps, OVERRIDE_RENDERED_OBJ);%@NL@%
%@NL@%
            global.pptl[global.sPtGrabbed] = ptl;%@NL@%
%@NL@%
            Paint(hps, CLEAR_FAT_BITMAP|RENDER_MATH_OBJ);%@NL@%
            WinReleasePS(hps);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ButtonUp%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
ButtonUp(hwnd, usMsg)%@NL@%
HWND hwnd;%@NL@%
USHORT usMsg;%@NL@%
{%@NL@%
    SHORT i;%@NL@%
    HPS hps;%@NL@%
%@NL@%
%@NL@%
    if (global.fDraggingPelColor)%@NL@%
    {%@NL@%
        global.fDraggingPelColor = FALSE;%@NL@%
        WinSetCapture(HWND_DESKTOP, NULL);%@NL@%
    }%@NL@%
    else if (global.fDraggingControlPoint)%@NL@%
    {%@NL@%
        global.fDraggingControlPoint = FALSE;%@NL@%
        WinSetCapture(HWND_DESKTOP, NULL);%@NL@%
        if (global.sPtGrabbed != NO_POINT)%@NL@%
        {%@NL@%
            if (usMsg == WM_BUTTON2UP)        %@AB@%/* remove point? */%@AE@%%@NL@%
            {%@NL@%
                hps = WinGetPS(hwnd);%@NL@%
                Paint(hps, OVERRIDE_RENDERED_OBJ);%@NL@%
%@NL@%
                %@AB@%/* squeeze out selected point */%@AE@%%@NL@%
                if ((i = global.sPtGrabbed) < (SHORT)(global.cptl-1))%@NL@%
                    while (i < (SHORT)(global.cptl-1))%@NL@%
                    {%@NL@%
                        global.pptl[i] = global.pptl[i+1];%@NL@%
                        ++i;%@NL@%
                    }%@NL@%
%@NL@%
                --global.cptl;%@NL@%
                global.sPtGrabbed = NO_POINT;%@NL@%
%@NL@%
                Paint(hps, CLEAR_FAT_BITMAP|RENDER_MATH_OBJ);%@NL@%
                WinReleasePS(hps);%@NL@%
            }%@NL@%
            else    %@AB@%/* WM_BUTTON1UP */%@AE@%%@NL@%
                global.sPtGrabbed = NO_POINT;%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ButtonDown%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
ButtonDown(hwnd, usMsg, mp1)%@NL@%
HWND hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
{%@NL@%
    if (global.fDraggingPelSize)%@NL@%
    {%@NL@%
        POINTS pt;%@NL@%
        HPS hps;%@NL@%
%@NL@%
        pt.x = LOUSHORT(mp1);%@NL@%
        pt.y = HIUSHORT(mp1);%@NL@%
        DragPelSize(hwnd, pt);%@NL@%
        global.fDraggingPelSize = FALSE;%@NL@%
%@NL@%
        WinSetPointer(HWND_DESKTOP,%@NL@%
                      WinQuerySysPointer(HWND_DESKTOP,SPTR_ARROW,FALSE));%@NL@%
%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
        global.usMix = FM_OVERPAINT;%@NL@%
        Paint(hps, CLEAR_BACKGROUND|CLEAR_FAT_BITMAP|RENDER_MATH_OBJ);%@NL@%
        WinReleasePS(hps);%@NL@%
    }%@NL@%
    else if (global.fEditPelColors)%@NL@%
    {%@NL@%
        POINTL ptl, ptlFat;%@NL@%
        HPS hps;%@NL@%
%@NL@%
        global.fDraggingPelColor = TRUE;%@NL@%
        WinSetCapture(HWND_DESKTOP, hwnd);%@NL@%
%@NL@%
        ptl.x = (LONG) LOUSHORT(mp1);%@NL@%
        ptl.y = (LONG) HIUSHORT(mp1);%@NL@%
%@NL@%
        if (global.usMix != FM_XOR)%@NL@%
        {%@NL@%
            hps = WinGetPS(hwnd);%@NL@%
            global.usMix = FM_XOR;%@NL@%
            Paint(hps, CLEAR_BACKGROUND);%@NL@%
            WinReleasePS(hps);%@NL@%
        }%@NL@%
%@NL@%
        if (usMsg == WM_BUTTON1DOWN)%@NL@%
            global.clrEditPel = global.clrRenderedObj;%@NL@%
        else%@NL@%
            global.clrEditPel = global.clrField;%@NL@%
%@NL@%
        GetFatPelFromPt(&ptl, &ptlFat);%@NL@%
        SetFatPel(&ptlFat, global.clrEditPel);%@NL@%
%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
        Paint(hps, OVERRIDE_RENDERED_OBJ);%@NL@%
        Paint(hps, IGNORED);        %@AB@%/* this call just copies fatpels to the screen */%@AE@%%@NL@%
        WinReleasePS(hps);%@NL@%
    }%@NL@%
    else if (!global.fDraggingControlPoint)%@NL@%
    {%@NL@%
        POINTL ptl;%@NL@%
        SHORT sNewPtGrabbed;%@NL@%
        HPS hps;%@NL@%
%@NL@%
        global.fDraggingControlPoint = TRUE;%@NL@%
        WinSetCapture(HWND_DESKTOP, hwnd);%@NL@%
%@NL@%
        ptl.x = (LONG) LOUSHORT(mp1);%@NL@%
        ptl.y = (LONG) HIUSHORT(mp1);%@NL@%
%@NL@%
        sNewPtGrabbed = IsPtInList(&ptl);%@NL@%
%@NL@%
        if (global.usMix != FM_XOR)%@NL@%
        {%@NL@%
            hps = WinGetPS(hwnd);%@NL@%
            global.usMix = FM_XOR;%@NL@%
            Paint(hps, CLEAR_BACKGROUND);%@NL@%
            WinReleasePS(hps);%@NL@%
        }%@NL@%
%@NL@%
        if (usMsg == WM_BUTTON1DOWN)        %@AB@%/* add/move point? */%@AE@%%@NL@%
        {%@NL@%
            hps = WinGetPS(hwnd);%@NL@%
%@NL@%
            if (sNewPtGrabbed != NO_POINT)%@NL@%
                global.sPtGrabbed = sNewPtGrabbed;%@NL@%
            Paint(hps, OVERRIDE_RENDERED_OBJ);%@NL@%
%@NL@%
            if (sNewPtGrabbed == NO_POINT)%@NL@%
                global.sPtGrabbed = AddPtToList(&ptl);%@NL@%
            else%@NL@%
                global.sPtGrabbed = sNewPtGrabbed;%@NL@%
%@NL@%
            Paint(hps, CLEAR_FAT_BITMAP|RENDER_MATH_OBJ);%@NL@%
            WinReleasePS(hps);%@NL@%
%@NL@%
            if (global.sPtGrabbed == NO_POINT)%@NL@%
                MyMessageBox(global.hwnd, "Cannot add any more points.");%@NL@%
        }%@NL@%
        else if (sNewPtGrabbed != NO_POINT)%@NL@%
            global.sPtGrabbed = sNewPtGrabbed;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   GetFatPelFromPt%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
GetFatPelFromPt(pptl, pptlFat)%@NL@%
PPOINTL pptl;%@NL@%
PPOINTL pptlFat;%@NL@%
{%@NL@%
    pptlFat->x = pptl->x / global.cxFatPel;%@NL@%
    pptlFat->y = pptl->y / global.cyFatPel;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   SetFatPel%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
SetFatPel(pptl, clr)%@NL@%
PPOINTL pptl;%@NL@%
COLOR clr;%@NL@%
{%@NL@%
    LINEBUNDLE lb;%@NL@%
%@NL@%
    if (global.hpsFat)%@NL@%
    {%@NL@%
        lb.lColor = clr;%@NL@%
        GpiSetAttrs(global.hpsFat, PRIM_LINE, LBB_COLOR, 0L, &lb);%@NL@%
        GpiSetPel(global.hpsFat, pptl);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   IsPtInList%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
SHORT%@NL@%
IsPtInList(pptl)%@NL@%
PPOINTL pptl;%@NL@%
{%@NL@%
    SHORT i;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* try to find pptl in the points we already have */%@AE@%%@NL@%
    for (i = 0; i < (SHORT)global.cptl; ++i)%@NL@%
        if (((L_ABS(pptl->x - global.pptl[i].x)) <= global.lHitPrecision) &&%@NL@%
            ((L_ABS(pptl->y - global.pptl[i].y)) <= global.lHitPrecision))%@NL@%
                return i;%@NL@%
%@NL@%
    %@AB@%/* couldn't find it */%@AE@%%@NL@%
    return NO_POINT;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   AddPtToList%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
SHORT%@NL@%
AddPtToList(pptl)%@NL@%
PPOINTL pptl;%@NL@%
{%@NL@%
    SHORT i, j;%@NL@%
%@NL@%
    if (global.cptl < CPTLMAX)%@NL@%
    {%@NL@%
        %@AB@%/* check for new points lying on a line segment */%@AE@%%@NL@%
        for (i = 0; i < (SHORT)(global.cptl-1L); ++i)%@NL@%
            if (IsPtCloseToLine(&global.pptl[i], &global.pptl[i+1], pptl))%@NL@%
            {%@NL@%
                %@AB@%/* insert point between endpoints of nearest line segment */%@AE@%%@NL@%
                for (j = (SHORT)global.cptl; j > i+1; --j)%@NL@%
                    global.pptl[j] = global.pptl[j - 1];%@NL@%
                global.pptl[i+1] = *pptl;%@NL@%
                ++global.cptl;%@NL@%
                return i+1;%@NL@%
            }%@NL@%
%@NL@%
        %@AB@%/* append the point */%@AE@%%@NL@%
%@NL@%
        i = (SHORT) global.cptl;%@NL@%
        global.pptl[i] = *pptl;%@NL@%
        ++global.cptl;%@NL@%
        return i;%@NL@%
    }%@NL@%
%@NL@%
    return NO_POINT;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   IsPtCloseToLine%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
IsPtCloseToLine(pptl1, pptl2, pptlTest)%@NL@%
PPOINTL pptl1;%@NL@%
PPOINTL pptl2;%@NL@%
PPOINTL pptlTest;%@NL@%
{%@NL@%
    POINTL ptlLL, ptlUR;%@NL@%
    LONG dx, dy, yIntercept, error;%@NL@%
    LONG lBoxAdjustment;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* find the bounding box of the line segment */%@AE@%%@NL@%
%@NL@%
    ptlLL = *pptl1;        %@AB@%/* assume line goes lower left to upper right */%@AE@%%@NL@%
    ptlUR = *pptl2;%@NL@%
    if (pptl1->x > pptl2->x)%@NL@%
        SwapLong(&ptlLL.x, &ptlUR.x);%@NL@%
    if (pptl1->y > pptl2->y)%@NL@%
        SwapLong(&ptlLL.y, &ptlUR.y);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* adjust the bounding box if it's too narrow */%@AE@%%@NL@%
%@NL@%
    lBoxAdjustment = global.lHitPrecision/2L;%@NL@%
%@NL@%
    dx = pptl2->x - pptl1->x;%@NL@%
    if (L_ABS(dx) <= global.lHitPrecision)%@NL@%
    {%@NL@%
        ptlLL.x -= lBoxAdjustment;%@NL@%
        ptlUR.x += lBoxAdjustment;%@NL@%
    }%@NL@%
    dy = pptl2->y - pptl1->y;%@NL@%
    if (L_ABS(dy) <= global.lHitPrecision)%@NL@%
    {%@NL@%
        ptlLL.y -= lBoxAdjustment;%@NL@%
        ptlUR.y += lBoxAdjustment;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* see if the test point is in the bounding box of the line segment */%@AE@%%@NL@%
%@NL@%
    if ((pptlTest->x >= ptlLL.x) &&%@NL@%
        (pptlTest->x <= ptlUR.x) &&%@NL@%
        (pptlTest->y >= ptlLL.y) &&%@NL@%
        (pptlTest->y <= ptlUR.y))%@NL@%
    {%@NL@%
        %@AB@%/* test for special cases */%@AE@%%@NL@%
%@NL@%
        if (dx == 0)        %@AB@%/* vertical line */%@AE@%%@NL@%
        {%@NL@%
            return (L_ABS(pptlTest->x - pptl1->x) <= global.lHitPrecision);%@NL@%
        }%@NL@%
%@NL@%
        if (dy == 0)        %@AB@%/* horizontal line */%@AE@%%@NL@%
        {%@NL@%
            return (L_ABS(pptlTest->y - pptl1->y) <= global.lHitPrecision);%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* test for general case */%@AE@%%@NL@%
%@NL@%
        yIntercept = pptl1->y - (pptl1->x * dy) / dx;%@NL@%
%@NL@%
        error = pptlTest->y - (pptlTest->x * dy / dx) - yIntercept;%@NL@%
        if (L_ABS(error) <= global.lHitPrecision)%@NL@%
            return TRUE;%@NL@%
    }%@NL@%
%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   SwapLong%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
SwapLong(pl1, pl2)%@NL@%
PLONG pl1, pl2;%@NL@%
{%@NL@%
    LONG lTmp;%@NL@%
%@NL@%
    lTmp = *pl1;%@NL@%
    *pl1 = *pl2;%@NL@%
    *pl2 = lTmp;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DragPelSize%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Set the dimensions of a fat pel by dragging a rectangle%@NL@%
%@AB@%*   on the screen.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DragPelSize(hwnd, pt)%@NL@%
HWND hwnd;%@NL@%
POINTS pt;%@NL@%
{%@NL@%
    TRACKINFO ti;%@NL@%
%@NL@%
    WinSendMsg(global.hwndFrame, WM_QUERYTRACKINFO, (MPARAM)TF_MOVE, (MPARAM)&ti);%@NL@%
%@NL@%
    ti.cxBorder   = 1;%@NL@%
    ti.cyBorder   = 1;%@NL@%
    ti.rclTrack.xLeft        = (LONG)pt.x;%@NL@%
    ti.rclTrack.yBottom = (LONG)pt.y;%@NL@%
    ti.rclTrack.xRight        = (LONG)pt.x;%@NL@%
    ti.rclTrack.yTop        = (LONG)pt.y;%@NL@%
    ti.fs = TF_RIGHT | TF_TOP;%@NL@%
    ti.ptlMinTrackSize.x = 1L;%@NL@%
    ti.ptlMinTrackSize.y = 1L;%@NL@%
%@NL@%
    if (WinTrackRect(hwnd, NULL, &ti))%@NL@%
    {%@NL@%
        global.cxFatPel = (ti.rclTrack.xRight - ti.rclTrack.xLeft)  ;%@NL@%
        global.cyFatPel = (ti.rclTrack.yTop   - ti.rclTrack.yBottom);%@NL@%
%@NL@%
        if (global.cxFatPel < 1L)%@NL@%
            global.cxFatPel = 1L;%@NL@%
%@NL@%
        if (global.cyFatPel < 1L)%@NL@%
            global.cyFatPel = 1L;%@NL@%
%@NL@%
        global.cxHalfFatPel = global.cxFatPel / 2L;%@NL@%
        global.cyHalfFatPel = global.cyFatPel / 2L;%@NL@%
%@NL@%
        UpdateSurfaceDims();%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Close%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
Close(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    if (global.hptrDragSize)%@NL@%
        WinDestroyPointer(global.hptrDragSize);%@NL@%
    WinPostMsg(hwnd, WM_QUIT, 0L, 0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Command%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Dispatches menu commands to the proper handlers.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
                   %@NL@%
%@AI@%#define %@AE@%UPDATE_MENU_BOOL(var, val)                                \ %@NL@%
        {                                                        \%@NL@%
            TOGGLE_BOOL((var));                                 \%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, (val), (var));        \%@NL@%
        }%@NL@%
%@NL@%
%@AI@%#define %@AE@%UPDATE_MENU_LIST(var, val)                                \ %@NL@%
        {                                                        \%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, (var));         \%@NL@%
            (var) = (val);                                        \%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, (var));                \%@NL@%
        }%@NL@%
%@NL@%
VOID%@NL@%
Command(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    BOOL fRedraw = FALSE;%@NL@%
    USHORT fsCmd = IGNORED;%@NL@%
%@NL@%
%@NL@%
    switch (id)%@NL@%
    {%@NL@%
    case IDM_SAVE:%@NL@%
        SaveWindowToFile(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_ABOUT:%@NL@%
        WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)AboutDlg, (HMODULE) NULL,%@NL@%
                       IDR_ABOUTDLG, NULL );%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_REDRAW:%@NL@%
        fsCmd = CLEAR_BACKGROUND|CLEAR_FAT_BITMAP|RENDER_MATH_OBJ;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_SETPELSIZE:%@NL@%
        {%@NL@%
            LONG cxFatPel, cyFatPel;%@NL@%
%@NL@%
            cxFatPel = global.cxFatPel;%@NL@%
            cyFatPel = global.cyFatPel;%@NL@%
%@NL@%
            if (WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)PelSizeDlg, (HMODULE) NULL,%@NL@%
                           IDR_PELSIZEDLG, NULL ))%@NL@%
            {%@NL@%
                if ((cxFatPel == global.cxFatPel) &&%@NL@%
                    (cyFatPel == global.cyFatPel))%@NL@%
                    fsCmd = CLEAR_BACKGROUND;%@NL@%
                else%@NL@%
                    fsCmd = CLEAR_BACKGROUND|CLEAR_FAT_BITMAP|RENDER_MATH_OBJ;%@NL@%
                fRedraw = TRUE;%@NL@%
            }%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_DRAGPELSIZE:%@NL@%
        global.fDraggingPelSize = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_RENDEREDOBJ:%@NL@%
        UPDATE_MENU_BOOL(global.fDisplayRenderedObj, IDM_RENDEREDOBJ);%@NL@%
        fsCmd = CLEAR_BACKGROUND|CLEAR_FAT_BITMAP|RENDER_MATH_OBJ;%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_MATHOBJ:%@NL@%
        UPDATE_MENU_BOOL(global.fDisplayMathObj, IDM_MATHOBJ);%@NL@%
        fsCmd = CLEAR_BACKGROUND;%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_CTLPOINTS:%@NL@%
        UPDATE_MENU_BOOL(global.fDisplayControlPoints, IDM_CTLPOINTS);%@NL@%
        fsCmd = CLEAR_BACKGROUND;%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_CROSSHAIRS:%@NL@%
        UPDATE_MENU_BOOL(global.fDisplayCrossHairs, IDM_CROSSHAIRS);%@NL@%
        fsCmd = CLEAR_BACKGROUND;%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_PELBORDER:%@NL@%
        UPDATE_MENU_BOOL(global.fDisplayPelBorder, IDM_PELBORDER);%@NL@%
        fsCmd = CLEAR_BACKGROUND;%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_ROUNDPOINTS:%@NL@%
        UPDATE_MENU_BOOL(global.fRoundControlPoints, IDM_ROUNDPOINTS);%@NL@%
        fsCmd = CLEAR_BACKGROUND;%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_AUTOREDRAW:%@NL@%
        UPDATE_MENU_BOOL(global.fAutoRedraw, IDM_AUTOREDRAW);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_NOPRIM:%@NL@%
    case IDM_POLYLINE:%@NL@%
    case IDM_POLYFILLET:%@NL@%
    case IDM_POLYSPLINE:%@NL@%
    case IDM_POINTARC:%@NL@%
        UPDATE_MENU_LIST(global.usCurPrim, id);%@NL@%
        fsCmd = CLEAR_BACKGROUND|CLEAR_FAT_BITMAP|RENDER_MATH_OBJ;%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_SETCOLORS:%@NL@%
        if (WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)ColorsDlg, (HMODULE) NULL,%@NL@%
                       IDR_COLORSDLG, NULL ))%@NL@%
        {%@NL@%
            fsCmd = CLEAR_BACKGROUND|RENDER_MATH_OBJ;%@NL@%
            fRedraw = TRUE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_EDITPELCOLORS:%@NL@%
        UPDATE_MENU_BOOL(global.fEditPelColors, IDM_EDITPELCOLORS);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_CLEARALL:%@NL@%
        global.cptl = 0L;%@NL@%
        fsCmd = CLEAR_BACKGROUND|CLEAR_FAT_BITMAP|RENDER_MATH_OBJ;%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    if ((global.fAutoRedraw && fRedraw) || (id == IDM_REDRAW))%@NL@%
    {%@NL@%
        HPS hps;%@NL@%
%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
        global.usMix = FM_OVERPAINT;%@NL@%
        Paint(hps, fsCmd);%@NL@%
        WinReleasePS(hps);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Paint%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
Paint(hps, fsCmd)%@NL@%
HPS  hps;%@NL@%
USHORT fsCmd;%@NL@%
{%@NL@%
    HRGN hrgn, hrgnClipOld, hrgnT;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Clear the unused part of the client rectangle to a hatch pattern. */%@AE@%%@NL@%
    if (fsCmd & CLEAR_BACKGROUND)%@NL@%
        EraseBackground(hps);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Set up the color mode as the user has requested */%@AE@%%@NL@%
%@NL@%
    if (global.fRGB)%@NL@%
    {%@NL@%
        GpiCreateLogColorTable(hps, LCOL_RESET, LCOLF_RGB, 0L, 0L, NULL);%@NL@%
        if (global.hpsFat)%@NL@%
        {%@NL@%
            GpiCreateLogColorTable(global.hpsFat, LCOL_RESET, LCOLF_RGB, 0L, 0L, NULL);%@NL@%
            GpiCreateLogColorTable(global.hpsFatShadow, LCOL_RESET, LCOLF_RGB, 0L, 0L, NULL);%@NL@%
        }%@NL@%
    }%@NL@%
    else%@NL@%
        if (global.hpsFat)%@NL@%
        {%@NL@%
            GpiCreateLogColorTable(global.hpsFat, LCOL_RESET, LCOLF_INDRGB, 0L, 0L, NULL);%@NL@%
            GpiCreateLogColorTable(global.hpsFatShadow, LCOL_RESET, LCOLF_INDRGB, 0L, 0L, NULL);%@NL@%
            global.clrBlackIndex = GpiQueryColorIndex(hps, 0L, 0x000000L);%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
    if (global.usPelShape == IDD_CIRCLE)%@NL@%
    {%@NL@%
        ARCPARAMS arcp;%@NL@%
%@NL@%
        arcp.lP = global.cxFatPel / 2L;%@NL@%
        arcp.lQ = global.cyFatPel / 2L;%@NL@%
        arcp.lR = 0L;%@NL@%
        arcp.lS = 0L;%@NL@%
%@NL@%
        GpiSetArcParams(hps, &arcp);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* set clipping rectangle to the fatbit surface */%@AE@%%@NL@%
%@NL@%
    if ((hrgn = GpiCreateRegion(hps, 1L, &global.rcl)) != HRGN_ERROR)%@NL@%
        GpiSetClipRegion(hps, hrgn, &hrgnClipOld);%@NL@%
%@NL@%
%@NL@%
    if (fsCmd & CLEAR_BACKGROUND)%@NL@%
    {%@NL@%
        DrawGrid(hps);%@NL@%
%@NL@%
        if (global.hpsFatShadow)%@NL@%
        {%@NL@%
            AREABUNDLE ab;%@NL@%
%@NL@%
            %@AB@%/* clear shadow fatpel surface to background color */%@AE@%%@NL@%
            ab.lColor = global.clrField;%@NL@%
            GpiSetAttrs(global.hpsFatShadow, PRIM_AREA, ABB_COLOR, 0L, &ab);%@NL@%
            GpiBitBlt(global.hpsFatShadow, NULL, 2L, (PPOINTL)&global.rclFat, ROP_PATCOPY,(ULONG) 0);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (global.fDisplayRenderedObj && !(fsCmd & OVERRIDE_RENDERED_OBJ))%@NL@%
        DisplayRenderedPels(hps, fsCmd);%@NL@%
%@NL@%
    if (global.fDisplayControlPoints)%@NL@%
    {%@NL@%
        %@AB@%/* when rubberbanding with the rendered obj, newly drawn fatpels%@NL@%
%@AB@%         * can wipe out stationary control point markers, so we have to%@NL@%
%@AB@%         * redraw them all each time%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        if (global.fDisplayRenderedObj || (fsCmd & CLEAR_BACKGROUND))%@NL@%
            DisplayControlPoints(hps, global.cptl, global.pptl, global.usMix);%@NL@%
        else if (global.sPtGrabbed != NO_POINT)%@NL@%
            %@AB@%/* draw just the control point that moved */%@AE@%%@NL@%
            DisplayControlPoints(hps, 1L, global.pptl+global.sPtGrabbed, global.usMix);%@NL@%
    }%@NL@%
%@NL@%
    if (global.fDisplayMathObj)%@NL@%
        DisplayMathematicalObject(hps, global.usMix);%@NL@%
%@NL@%
    %@AB@%/* delete the clip region we set up */%@AE@%%@NL@%
%@NL@%
    if (hrgnClipOld != HRGN_ERROR)%@NL@%
        GpiSetClipRegion(hps, hrgnClipOld, &hrgnT);%@NL@%
    if (hrgn != HRGN_ERROR)%@NL@%
        GpiDestroyRegion(hps, hrgn);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DisplayMathematicalObject%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DisplayMathematicalObject(hps, usMix)%@NL@%
HPS hps;%@NL@%
USHORT usMix;%@NL@%
{%@NL@%
    PPOINTL pptl;%@NL@%
    LINEBUNDLE lb;%@NL@%
%@NL@%
    if (global.cptl > 0)%@NL@%
    {%@NL@%
        if (global.fRoundControlPoints)%@NL@%
        {%@NL@%
            RoundControlPoints(hps, global.cptl, global.pptl, global.pptlTmp,%@NL@%
                               global.cxFatPel, global.cyFatPel);%@NL@%
            pptl = global.pptlTmp;%@NL@%
        }%@NL@%
        else%@NL@%
            pptl = global.pptl;%@NL@%
%@NL@%
        %@AB@%/* draw line */%@AE@%%@NL@%
        lb.lColor    = global.clrMathObj;%@NL@%
        lb.usMixMode = usMix;%@NL@%
        GpiSetAttrs(hps, PRIM_LINE, LBB_COLOR|LBB_MIX_MODE, 0L, &lb);%@NL@%
        DrawPrimitive(hps, global.cptl, pptl);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DisplayControlPoints%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DisplayControlPoints(hps, cptl, pptl, usMix)%@NL@%
HPS hps;%@NL@%
LONG cptl;%@NL@%
PPOINTL pptl;%@NL@%
USHORT usMix;%@NL@%
{%@NL@%
    PPOINTL pptlT;%@NL@%
    MARKERBUNDLE mb;%@NL@%
%@NL@%
    if (cptl > 0)%@NL@%
    {%@NL@%
        if (global.fRoundControlPoints)%@NL@%
        {%@NL@%
            RoundControlPoints(hps, cptl, pptl, global.pptlTmp,%@NL@%
                               global.cxFatPel, global.cyFatPel);%@NL@%
            pptlT = global.pptlTmp;%@NL@%
        }%@NL@%
        else%@NL@%
            pptlT = pptl;%@NL@%
%@NL@%
%@NL@%
        mb.lColor    = global.clrControlPoints;%@NL@%
        mb.usMixMode = usMix;%@NL@%
        mb.usSymbol  = global.usControlPointSymbol;%@NL@%
        GpiSetAttrs(hps, PRIM_MARKER, MBB_COLOR|MBB_MIX_MODE|MBB_SYMBOL, 0L, &mb);%@NL@%
%@NL@%
        GpiPolyMarker(hps, cptl, pptlT);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   EraseBackground%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Erase the unused part of the window to a hatch pattern.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
EraseBackground(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    RECTL rclClient, rclT;%@NL@%
    AREABUNDLE ab;%@NL@%
%@NL@%
%@NL@%
    WinQueryWindowRect(global.hwnd, &rclClient);%@NL@%
%@NL@%
    ab.lColor          = CLR_BLACK;%@NL@%
    ab.lBackColor = CLR_WHITE;%@NL@%
    ab.usSymbol   = PATSYM_DIAG1;%@NL@%
    GpiSetAttrs(hps, PRIM_AREA, ABB_COLOR|ABB_BACK_COLOR|ABB_SYMBOL,%@NL@%
                0L, (PBUNDLE)&ab);%@NL@%
%@NL@%
    if (global.rcl.yTop < rclClient.yTop)%@NL@%
    {%@NL@%
        rclT.xLeft   = rclClient.xLeft;%@NL@%
        rclT.yBottom = global.rcl.yBottom;%@NL@%
        rclT.xRight  = rclClient.xRight;%@NL@%
        rclT.yTop    = rclClient.yTop;%@NL@%
        GpiBitBlt(hps, NULL, 2L, (PPOINTL)&rclT, ROP_PATCOPY, (ULONG) 0);%@NL@%
    }%@NL@%
%@NL@%
    if (global.rcl.xRight < rclClient.xRight)%@NL@%
    {%@NL@%
        rclT.xLeft   = global.rcl.xRight;%@NL@%
        rclT.yBottom = rclClient.yBottom;%@NL@%
        rclT.xRight  = rclClient.xRight;%@NL@%
        rclT.yTop    = global.rcl.yTop;%@NL@%
        GpiBitBlt(hps, NULL, 2L, (PPOINTL)&rclT, ROP_PATCOPY, (ULONG) 0);%@NL@%
    }%@NL@%
%@NL@%
    ab.usSymbol   = PATSYM_SOLID;%@NL@%
    GpiSetAttrs(hps, PRIM_AREA, ABB_SYMBOL, 0L, (PBUNDLE)&ab);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawGrid%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawGrid(hps)%@NL@%
HPS  hps;%@NL@%
{%@NL@%
    AREABUNDLE ab;%@NL@%
    POINTL ptl;%@NL@%
    POINTL aptl[3];%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* clear fatpel surface to background color */%@AE@%%@NL@%
    ab.lColor = global.clrInterstice;%@NL@%
    GpiSetAttrs(hps, PRIM_AREA, ABB_COLOR, 0L, &ab);%@NL@%
    GpiBitBlt(hps, NULL, 2L, (PPOINTL)&global.rcl, ROP_PATCOPY, (ULONG) 0);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* draw one pel in lower left corner */%@AE@%%@NL@%
%@NL@%
    ptl.x = global.cxFatPel / 2L;%@NL@%
    ptl.y = global.cyFatPel / 2L;%@NL@%
    DrawOneFatPel(hps, &ptl, global.clrField);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* blt up first column then across -- we don't have to worry%@NL@%
%@AB@%     * about the edges because a clip region has been setup to do that.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    aptl[0].x = 0L;%@NL@%
    aptl[0].y = global.cyFatPel;%@NL@%
    aptl[1].x = global.cxFatPel;%@NL@%
    aptl[2].x = 0L;%@NL@%
    aptl[2].y = 0L;%@NL@%
%@NL@%
    while (aptl[0].y <= global.rcl.yTop)%@NL@%
    {%@NL@%
        aptl[1].y  = aptl[0].y + aptl[0].y;%@NL@%
        GpiBitBlt(hps, hps, 3L, aptl, ROP_SRCCOPY, (LONG)NULL);%@NL@%
        aptl[0].y += aptl[1].y - aptl[0].y;%@NL@%
    }%@NL@%
%@NL@%
    aptl[0].x = global.cxFatPel;%@NL@%
    aptl[0].y = 0L;%@NL@%
    aptl[1].y = global.rcl.yTop;%@NL@%
    aptl[2].x = 0L;%@NL@%
    aptl[2].y = 0L;%@NL@%
%@NL@%
    while (aptl[0].x <= global.rcl.xRight)%@NL@%
    {%@NL@%
        aptl[1].x  = aptl[0].x + aptl[0].x;%@NL@%
        GpiBitBlt(hps, hps, 3L, aptl, ROP_SRCCOPY, (LONG)NULL);%@NL@%
        aptl[0].x += aptl[1].x - aptl[0].x;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DisplayRenderedPels%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DisplayRenderedPels(hps, fsCmd)%@NL@%
HPS hps;%@NL@%
USHORT fsCmd;%@NL@%
{%@NL@%
    LINEBUNDLE lb;%@NL@%
    AREABUNDLE ab;%@NL@%
    POINTL aptl[3];%@NL@%
%@NL@%
    %@AB@%/*        Call GPI to draw the current primitive into the small bitmap,%@NL@%
%@AB@%     *        then fatbit it to the display.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    if (global.hbmFat)%@NL@%
    {%@NL@%
        if (fsCmd & CLEAR_FAT_BITMAP)%@NL@%
        {%@NL@%
            %@AB@%/* clear fatpel surface to background color */%@AE@%%@NL@%
            ab.lColor = global.clrField;%@NL@%
            GpiSetAttrs(global.hpsFat, PRIM_AREA, ABB_COLOR, 0L, &ab);%@NL@%
            GpiBitBlt(global.hpsFat, NULL, 2L, (PPOINTL)&global.rclFat, ROP_PATCOPY, (ULONG) 0);%@NL@%
        }%@NL@%
%@NL@%
        if (fsCmd & RENDER_MATH_OBJ)%@NL@%
        {%@NL@%
            if (global.cptl > 0)%@NL@%
            {%@NL@%
                %@AB@%/* draw line */%@AE@%%@NL@%
                lb.lColor = global.clrRenderedObj;%@NL@%
                GpiSetAttrs(global.hpsFat, PRIM_LINE, LBB_COLOR, 0L, &lb);%@NL@%
                GpiSetModelTransformMatrix(global.hpsFat, 9L,%@NL@%
                                          &global.matlf, TRANSFORM_REPLACE);%@NL@%
                DrawPrimitive(global.hpsFat, global.cptl, global.pptl);%@NL@%
                GpiSetModelTransformMatrix(global.hpsFat, 0L, NULL, TRANSFORM_REPLACE);%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* xor the new rendered bitmap into the shadow bitmap */%@AE@%%@NL@%
        *((PRECTL)&aptl[0]) = global.rclFat;%@NL@%
        aptl[2].x = 0L;%@NL@%
        aptl[2].y = 0L;%@NL@%
        GpiBitBlt(global.hpsFatShadow, global.hpsFat, 3L, aptl, ROP_SRCINVERT, (ULONG) 0);%@NL@%
%@NL@%
        %@AB@%/* fatbit object to the display */%@AE@%%@NL@%
        DrawFatPels(hps);%@NL@%
%@NL@%
        %@AB@%/* get the new shadow bitmap */%@AE@%%@NL@%
        GpiBitBlt(global.hpsFatShadow, global.hpsFat, 3L, aptl, ROP_SRCCOPY, (ULONG) 0);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawFatPels%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawFatPels(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    POINTL ptl, ptlCenter;%@NL@%
    LONG i, j;%@NL@%
    COLOR clr;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* if the pel size is 1,1, then just blt the small bitmap to the%@NL@%
%@AB@%     * display.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    if ((global.cxFatPel == 1L) && (global.cyFatPel == 1L))%@NL@%
    {%@NL@%
        POINTL aptl[3];%@NL@%
%@NL@%
        *((PRECTL)&aptl[0]) = global.rcl;%@NL@%
        aptl[2].x = 0L;%@NL@%
        aptl[2].y = 0L;%@NL@%
        GpiBitBlt(hps, global.hpsFat, 3L, aptl, ROP_SRCCOPY, 0L);%@NL@%
%@NL@%
        return;%@NL@%
    }%@NL@%
%@NL@%
    for (i = 0; i < global.rclFat.xRight; ++i)%@NL@%
        for (j = 0; j < global.rclFat.yTop; ++j)%@NL@%
        {%@NL@%
            ptl.x = i;%@NL@%
            ptl.y = j;%@NL@%
%@NL@%
            clr = GpiQueryPel(global.hpsFatShadow, &ptl);%@NL@%
            if ((global.fRGB && (clr != 0x000000L)) ||%@NL@%
               (!global.fRGB && (clr != global.clrBlackIndex)))%@NL@%
            {%@NL@%
                clr = GpiQueryPel(global.hpsFat, &ptl);%@NL@%
                ptlCenter.x = (i * global.cxFatPel) + global.cxHalfFatPel;%@NL@%
                ptlCenter.y = (j * global.cyFatPel) + global.cyHalfFatPel;%@NL@%
                DrawOneFatPel(hps, &ptlCenter, clr);%@NL@%
            }%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawOneFatPel%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawOneFatPel(hps, pptl, clr)%@NL@%
HPS hps;%@NL@%
PPOINTL pptl;%@NL@%
COLOR clr;%@NL@%
{%@NL@%
    POINTL ptl;%@NL@%
    LINEBUNDLE lb;%@NL@%
    AREABUNDLE ab;%@NL@%
%@NL@%
%@NL@%
    if (global.fDisplayPelBorder || global.fDisplayCrossHairs)%@NL@%
    {%@NL@%
        lb.lColor = global.clrCrossHair;%@NL@%
        GpiSetAttrs(hps, PRIM_LINE, LBB_COLOR, 0L, &lb);%@NL@%
    }%@NL@%
%@NL@%
    ab.lColor = clr;%@NL@%
    GpiSetAttrs(hps, PRIM_AREA, ABB_COLOR, 0L, &ab);%@NL@%
%@NL@%
%@NL@%
    switch (global.usPelShape)%@NL@%
    {%@NL@%
    case IDD_SQUARE:%@NL@%
        {%@NL@%
            POINTL ptlT;%@NL@%
            ULONG flCmd;%@NL@%
%@NL@%
            if (global.fDisplayPelBorder)%@NL@%
                flCmd = DRO_OUTLINEFILL;%@NL@%
            else%@NL@%
                flCmd = DRO_FILL;%@NL@%
%@NL@%
            ptlT.x = pptl->x - global.cxHalfFatPel;%@NL@%
            ptlT.y = pptl->y - global.cyHalfFatPel;%@NL@%
            GpiSetCurrentPosition(hps, &ptlT);%@NL@%
            ptlT.x = pptl->x + global.cxHalfFatPel;%@NL@%
            ptlT.y = pptl->y + global.cyHalfFatPel;%@NL@%
            GpiBox(hps, flCmd, &ptlT, 0L, 0L);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case IDD_DIAMOND:%@NL@%
        {%@NL@%
            POINTL aptlT[4];%@NL@%
            ULONG flCmd;%@NL@%
%@NL@%
            if (global.fDisplayPelBorder)%@NL@%
                flCmd = BA_BOUNDARY;%@NL@%
            else%@NL@%
                flCmd = 0L;%@NL@%
%@NL@%
            aptlT[0].x = pptl->x;%@NL@%
            aptlT[0].y = pptl->y - global.cyHalfFatPel;%@NL@%
            aptlT[1].x = pptl->x - global.cxHalfFatPel;%@NL@%
            aptlT[1].y = pptl->y;%@NL@%
            aptlT[2].x = pptl->x;%@NL@%
            aptlT[2].y = pptl->y + global.cyHalfFatPel;%@NL@%
            aptlT[3].x = pptl->x + global.cxHalfFatPel;%@NL@%
            aptlT[3].y = pptl->y;%@NL@%
%@NL@%
            GpiSetCurrentPosition(hps, &aptlT[3]);%@NL@%
            GpiBeginArea(hps, flCmd);%@NL@%
            GpiPolyLine(hps, 4L, aptlT);%@NL@%
            GpiEndArea(hps);%@NL@%
        }%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    case IDD_CIRCLE:%@NL@%
        {%@NL@%
            ULONG flCmd;%@NL@%
%@NL@%
            if (global.fDisplayPelBorder)%@NL@%
                flCmd = DRO_OUTLINEFILL;%@NL@%
            else%@NL@%
                flCmd = DRO_FILL;%@NL@%
%@NL@%
            GpiSetCurrentPosition(hps, pptl);%@NL@%
            GpiFullArc(hps, flCmd, 0x10000L);%@NL@%
        }%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    if (global.fDisplayCrossHairs)%@NL@%
    {%@NL@%
        %@AB@%/* draw cross in center of pel */%@AE@%%@NL@%
%@NL@%
        ptl.x = pptl->x - global.cxHalfFatPel;%@NL@%
        ptl.y = pptl->y;%@NL@%
        GpiSetCurrentPosition(hps, &ptl);%@NL@%
        ptl.x = pptl->x + global.cxHalfFatPel;%@NL@%
        GpiPolyLine(hps, 1L, &ptl);%@NL@%
%@NL@%
        ptl.x = pptl->x;%@NL@%
        ptl.y = pptl->y - global.cyHalfFatPel;%@NL@%
        GpiSetCurrentPosition(hps, &ptl);%@NL@%
        ptl.y = pptl->y + global.cyHalfFatPel;%@NL@%
        GpiPolyLine(hps, 1L, &ptl);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   RoundControlPoints%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
RoundControlPoints(hps, cptl, pptl1, pptl2, cx, cy)%@NL@%
HPS hps;%@NL@%
LONG cptl;%@NL@%
PPOINTL pptl1;%@NL@%
PPOINTL pptl2;%@NL@%
LONG cx;%@NL@%
LONG cy;%@NL@%
{%@NL@%
    LONG cx2, cy2;%@NL@%
    LONG i;%@NL@%
    MATRIXLF matlf;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* copy the input buffer to the output/scratch buffer */%@AE@%%@NL@%
    for (i = 0; i < cptl; ++i)%@NL@%
        pptl2[i] = pptl1[i];%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* set the transform, transform the points to device space (i.e. to%@NL@%
%@AB@%     * hpsFat dimensions), then restore the original transform%@NL@%
%@AB@%     */%@AE@%%@NL@%
    GpiQueryModelTransformMatrix(hps, 9L, &matlf);%@NL@%
    GpiSetModelTransformMatrix(hps, 9L, &global.matlf, TRANSFORM_REPLACE);%@NL@%
    GpiConvert(hps, CVTC_WORLD, CVTC_DEVICE, cptl, pptl2);%@NL@%
    GpiSetModelTransformMatrix(hps, 9L, &matlf, TRANSFORM_REPLACE);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* position each point in the center of its fatpel */%@AE@%%@NL@%
%@NL@%
    cx2 = cx / 2L;%@NL@%
    cy2 = cy / 2L;%@NL@%
%@NL@%
    for (i = 0; i < cptl; ++i, ++pptl2)%@NL@%
    {%@NL@%
        pptl2->x = pptl2->x * cx + cx2;%@NL@%
        pptl2->y = pptl2->y * cy + cy2;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ComputeTransform%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
ComputeTransform(prcl1, prcl2)%@NL@%
PRECTL prcl1;%@NL@%
PRECTL prcl2;%@NL@%
{%@NL@%
    LONG xExt1, yExt1;%@NL@%
    LONG xExt2, yExt2;%@NL@%
    FIXED xScale, yScale;%@NL@%
%@NL@%
%@NL@%
    xExt1 = prcl1->xRight - prcl1->xLeft;%@NL@%
    yExt1 = prcl1->yTop   - prcl1->yBottom;%@NL@%
    xExt2 = prcl2->xRight - prcl2->xLeft;%@NL@%
    yExt2 = prcl2->yTop   - prcl2->yBottom;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* If the rectangles are of exactly the same dimensions, then%@NL@%
%@AB@%     * set the unity transform.  If not, compute the x and y scale%@NL@%
%@AB@%     * factors.  Note that in world coordinates rectangles are%@NL@%
%@AB@%     * inclusive-inclusive, whereas in device coordinates they are%@NL@%
%@AB@%     * inclusive-exclusive.  The extents of the destination are%@NL@%
%@AB@%     * therefore one pel too large as computed, so we subtract one%@NL@%
%@AB@%     * in the scale factor computation.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    if (xExt1 == xExt2)%@NL@%
        xScale = 0x10000L;%@NL@%
    else%@NL@%
        xScale = ((xExt2-1L) * 0x10000L) / xExt1;%@NL@%
%@NL@%
    if (yExt1 == yExt2)%@NL@%
        yScale = 0x10000L;%@NL@%
    else%@NL@%
        yScale = ((yExt2-1L) * 0x10000L) / yExt1;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* store the transform matrix for easy access */%@AE@%%@NL@%
%@NL@%
    global.matlf.fxM11 = xScale;%@NL@%
    global.matlf.fxM12 = 0L;%@NL@%
    global.matlf. lM13 = 0L;%@NL@%
    global.matlf.fxM21 = 0L;%@NL@%
    global.matlf.fxM22 = yScale;%@NL@%
    global.matlf. lM23 = 0L;%@NL@%
    global.matlf. lM31 = 0L;%@NL@%
    global.matlf. lM32 = 0L;%@NL@%
    global.matlf. lM33 = 1L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DrawPrimitive%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
DrawPrimitive(hps, cptl, pptl)%@NL@%
HPS hps;%@NL@%
LONG cptl;%@NL@%
PPOINTL pptl;%@NL@%
{%@NL@%
    switch (global.usCurPrim)%@NL@%
    {%@NL@%
    case IDM_NOPRIM:%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYLINE:%@NL@%
        GpiSetCurrentPosition(hps, pptl);%@NL@%
        GpiPolyLine(hps, cptl-1L, pptl + 1);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYFILLET:%@NL@%
        if (cptl >= 3L)%@NL@%
        {%@NL@%
            GpiSetCurrentPosition(hps, pptl);%@NL@%
            GpiPolyFillet(hps, cptl-1L, pptl + 1);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POLYSPLINE:%@NL@%
        if (cptl >= 4L)%@NL@%
        {%@NL@%
            LONG cptSlack;    %@AB@%/* # points in pptl not usable by PolySpline */%@AE@%%@NL@%
%@NL@%
            cptSlack = ((cptl-1L) % 3) + 1;%@NL@%
            GpiSetCurrentPosition( hps, pptl );%@NL@%
            GpiPolySpline( hps, cptl-cptSlack, pptl+1 );%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_POINTARC:%@NL@%
        if (cptl >= 3L)%@NL@%
        {%@NL@%
            GpiSetCurrentPosition( hps, pptl );%@NL@%
            GpiPointArc( hps, pptl+1 );%@NL@%
        }%@NL@%
        break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   UpdateSurfaceDims%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
UpdateSurfaceDims()%@NL@%
{%@NL@%
    SIZEL size;%@NL@%
    BITMAPINFOHEADER bminfo;%@NL@%
    AREABUNDLE ab;%@NL@%
%@NL@%
%@NL@%
    WinQueryWindowRect(global.hwnd, &global.rcl);%@NL@%
%@NL@%
    %@AB@%/* compute size of small surface */%@AE@%%@NL@%
    global.rclFat.xLeft   = 0L;%@NL@%
    global.rclFat.yBottom = 0L;%@NL@%
    global.rclFat.xRight  = global.rcl.xRight / global.cxFatPel;%@NL@%
    global.rclFat.yTop          = global.rcl.yTop   / global.cyFatPel;%@NL@%
%@NL@%
    %@AB@%/* compute size of fatpel version of small surface */%@AE@%%@NL@%
    global.rcl.xLeft   = 0L;%@NL@%
    global.rcl.yBottom = 0L;%@NL@%
    global.rcl.xRight  = global.rclFat.xRight * global.cxFatPel;%@NL@%
    global.rcl.yTop    = global.rclFat.yTop   * global.cyFatPel;%@NL@%
%@NL@%
    ComputeTransform(&global.rcl, &global.rclFat);%@NL@%
%@NL@%
    if ((global.rclFat.xRight <= global.rclFatBM.xRight) &&%@NL@%
        (global.rclFat.yTop   <= global.rclFatBM.yTop))%@NL@%
        return;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* The new fatbits surface doesn't fit in the bitmap, so we%@NL@%
%@AB@%     * have to make a new one.        If we don't have a DC or PS, make%@NL@%
%@AB@%     * those before making the bitmap.        If we do have a bitmap,%@NL@%
%@AB@%     * delete it before making the new one.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    global.rclFatBM = global.rclFat;%@NL@%
%@NL@%
    if (global.hbmFat)%@NL@%
    {%@NL@%
        GpiSetBitmap(global.hpsFat, NULL);%@NL@%
        GpiDeleteBitmap(global.hbmFat);%@NL@%
        GpiSetBitmap(global.hpsFatShadow, NULL);%@NL@%
        GpiDeleteBitmap(global.hbmFatShadow);%@NL@%
    }%@NL@%
%@NL@%
    if (!global.hdcFat)%@NL@%
    {%@NL@%
        global.hdcFat = DevOpenDC(global.hab, OD_MEMORY, "*", 0L, NULL, NULL);%@NL@%
        if (!global.hdcFat)%@NL@%
            goto usd_error;%@NL@%
%@NL@%
        global.hdcFatShadow = DevOpenDC(global.hab, OD_MEMORY, "*", 0L, NULL, NULL);%@NL@%
        if (!global.hdcFatShadow)%@NL@%
            goto usd_error;%@NL@%
    }%@NL@%
%@NL@%
    if (!global.hpsFat)%@NL@%
    {%@NL@%
        size.cx = 0L;%@NL@%
        size.cy = 0L;%@NL@%
        global.hpsFat = GpiCreatePS(global.hab, global.hdcFat, &size,%@NL@%
                                 PU_PELS|GPIT_MICRO|GPIA_ASSOC);%@NL@%
        if (!global.hpsFat)%@NL@%
            goto usd_error;%@NL@%
%@NL@%
        global.hpsFatShadow = GpiCreatePS(global.hab, global.hdcFatShadow, &size,%@NL@%
                                 PU_PELS|GPIT_MICRO|GPIA_ASSOC);%@NL@%
        if (!global.hpsFatShadow)%@NL@%
            goto usd_error;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* create bitmap with maximum color resolution (24-bit color) */%@AE@%%@NL@%
    bminfo.cbFix = sizeof(BITMAPINFOHEADER);%@NL@%
    bminfo.cx = (USHORT) (global.rclFatBM.xRight - global.rclFatBM.xLeft);%@NL@%
    bminfo.cy = (USHORT) (global.rclFatBM.yTop         - global.rclFatBM.yBottom);%@NL@%
    bminfo.cPlanes   = 1L;%@NL@%
    bminfo.cBitCount = 24L;%@NL@%
    global.hbmFat = GpiCreateBitmap(global.hpsFat, &bminfo, 0L, 0L, 0L);%@NL@%
    if (!global.hbmFat)%@NL@%
        goto usd_error;%@NL@%
    GpiSetBitmap(global.hpsFat, global.hbmFat);%@NL@%
%@NL@%
    %@AB@%/* create a shadow bitmap of the one we just created */%@AE@%%@NL@%
    bminfo.cbFix = sizeof(BITMAPINFOHEADER);%@NL@%
    bminfo.cx = (USHORT) (global.rclFatBM.xRight - global.rclFatBM.xLeft);%@NL@%
    bminfo.cy = (USHORT) (global.rclFatBM.yTop         - global.rclFatBM.yBottom);%@NL@%
    bminfo.cPlanes   = 1L;%@NL@%
    bminfo.cBitCount = 24L;%@NL@%
    global.hbmFatShadow = GpiCreateBitmap(global.hpsFatShadow, &bminfo, 0L, 0L, 0L);%@NL@%
    if (!global.hbmFat)%@NL@%
        goto usd_error;%@NL@%
    GpiSetBitmap(global.hpsFatShadow, global.hbmFatShadow);%@NL@%
%@NL@%
    %@AB@%/* clear bitmap surface to field color */%@AE@%%@NL@%
    ab.lColor = global.clrField;%@NL@%
    GpiSetAttrs(global.hpsFat, PRIM_AREA, ABB_COLOR, 0L, &ab);%@NL@%
    GpiBitBlt(global.hpsFat, NULL, 2L, (PPOINTL)&global.rclFat, ROP_PATCOPY, (ULONG) 0);%@NL@%
%@NL@%
    return;%@NL@%
%@NL@%
%@NL@%
%@AB@%/* error exit point */%@AE@%%@NL@%
%@NL@%
usd_error:%@NL@%
    if (global.hpsFat)%@NL@%
        GpiDestroyPS(global.hpsFat);%@NL@%
    if (global.hpsFatShadow)%@NL@%
        GpiDestroyPS(global.hpsFatShadow);%@NL@%
    if (global.hdcFat)%@NL@%
        DevCloseDC(global.hdcFat);%@NL@%
    if (global.hdcFatShadow)%@NL@%
        DevCloseDC(global.hdcFatShadow);%@NL@%
%@NL@%
    global.hpsFat        = NULL;%@NL@%
    global.hdcFat        = NULL;%@NL@%
    global.hpsFatShadow = NULL;%@NL@%
    global.hdcFatShadow = NULL;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   AboutDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the About box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
AboutDlg(hwnd, usMsg, mp1, mp2)%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_COMMAND:%@NL@%
        if (SHORT1FROMMP(mp1) == DID_OK)%@NL@%
            WinDismissDlg(hwnd, TRUE);%@NL@%
        else%@NL@%
            return FALSE;%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   PelSizeDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the Pel Size dialog box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
PelSizeDlg(hwnd, usMsg, mp1, mp2)%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
        MySetWindowLong(hwnd, IDD_PELWIDTH,  global.cxFatPel);%@NL@%
        MySetWindowLong(hwnd, IDD_PELHEIGHT, global.cyFatPel);%@NL@%
        WinSendDlgItemMsg(hwnd, global.usPelShape,%@NL@%
                          BM_SETCHECK, (MPARAM)TRUE, 0L);%@NL@%
        return FALSE;%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
            global.cxFatPel = MyGetWindowLong(hwnd, IDD_PELWIDTH);%@NL@%
            global.cyFatPel = MyGetWindowLong(hwnd, IDD_PELHEIGHT);%@NL@%
%@NL@%
            if (global.cxFatPel < 1L)%@NL@%
                global.cxFatPel = 1L;%@NL@%
%@NL@%
            if (global.cyFatPel < 1L)%@NL@%
                global.cyFatPel = 1L;%@NL@%
%@NL@%
            global.cxHalfFatPel = global.cxFatPel / 2L;%@NL@%
            global.cyHalfFatPel = global.cyFatPel / 2L;%@NL@%
%@NL@%
            global.usPelShape = SHORT1FROMMR( WinSendDlgItemMsg(hwnd, IDD_SQUARE,%@NL@%
                                   BM_QUERYCHECKINDEX, 0L, 0L) + IDD_SQUARE);%@NL@%
%@NL@%
%@NL@%
            UpdateSurfaceDims();%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ColorsDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the Set Colors dialog box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
ColorsDlg(hwnd, usMsg, mp1, mp2)%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
    BOOL fRGB;%@NL@%
    COLOR clrMathObj;%@NL@%
    COLOR clrRenderedObj;%@NL@%
    COLOR clrField;%@NL@%
    COLOR clrCrossHair;%@NL@%
    COLOR clrInterstice;%@NL@%
    COLOR clrControlPoints;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
        if (global.fRGB)%@NL@%
        {%@NL@%
            MySetWindowLongHex(hwnd, IDD_MATHOBJ,     global.clrMathObj);%@NL@%
            MySetWindowLongHex(hwnd, IDD_RENDEREDOBJ, global.clrRenderedObj);%@NL@%
            MySetWindowLongHex(hwnd, IDD_FIELD,             global.clrField);%@NL@%
            MySetWindowLongHex(hwnd, IDD_CROSSHAIRS,  global.clrCrossHair);%@NL@%
            MySetWindowLongHex(hwnd, IDD_INTERSTICE,  global.clrInterstice);%@NL@%
            MySetWindowLongHex(hwnd, IDD_CTLPOINTS,   global.clrControlPoints);%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
            MySetWindowLong   (hwnd, IDD_MATHOBJ,     global.clrMathObj);%@NL@%
            MySetWindowLong   (hwnd, IDD_RENDEREDOBJ, global.clrRenderedObj);%@NL@%
            MySetWindowLong   (hwnd, IDD_FIELD,             global.clrField);%@NL@%
            MySetWindowLong   (hwnd, IDD_CROSSHAIRS,  global.clrCrossHair);%@NL@%
            MySetWindowLong   (hwnd, IDD_INTERSTICE,  global.clrInterstice);%@NL@%
            MySetWindowLong   (hwnd, IDD_CTLPOINTS,   global.clrControlPoints);%@NL@%
        }%@NL@%
        WinSendDlgItemMsg(hwnd, IDD_RGB, BM_SETCHECK, MPFROM2SHORT(global.fRGB,0), 0L);%@NL@%
        return FALSE;%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CONTROL:%@NL@%
        if ((SHORT1FROMMP(mp1) == IDD_RGB) && (SHORT2FROMMP(mp1)== BN_CLICKED))%@NL@%
        {%@NL@%
            fRGB = !SHORT1FROMMR(WinSendDlgItemMsg(hwnd, IDD_RGB, BM_QUERYCHECK, 0L, 0L));%@NL@%
            WinSendDlgItemMsg(hwnd, IDD_RGB, BM_SETCHECK, MPFROM2SHORT(fRGB,0), 0L);%@NL@%
%@NL@%
            clrMathObj             = MyGetWindowLong(hwnd, IDD_MATHOBJ);%@NL@%
            clrRenderedObj   = MyGetWindowLong(hwnd, IDD_RENDEREDOBJ);%@NL@%
            clrField             = MyGetWindowLong(hwnd, IDD_FIELD);%@NL@%
            clrCrossHair     = MyGetWindowLong(hwnd, IDD_CROSSHAIRS);%@NL@%
            clrInterstice    = MyGetWindowLong(hwnd, IDD_INTERSTICE);%@NL@%
            clrControlPoints = MyGetWindowLong(hwnd, IDD_CTLPOINTS);%@NL@%
%@NL@%
            if (fRGB)%@NL@%
            {%@NL@%
                HPS hps;%@NL@%
%@NL@%
                %@AB@%/* for each color, get rgb value from index */%@AE@%%@NL@%
%@NL@%
                hps = WinGetPS(hwnd);%@NL@%
%@NL@%
                clrMathObj         = GpiQueryRGBColor(hps, 0L, clrMathObj);%@NL@%
                clrRenderedObj         = GpiQueryRGBColor(hps, 0L, clrRenderedObj);%@NL@%
                clrField         = GpiQueryRGBColor(hps, 0L, clrField);%@NL@%
                clrCrossHair         = GpiQueryRGBColor(hps, 0L, clrCrossHair);%@NL@%
                clrInterstice         = GpiQueryRGBColor(hps, 0L, clrInterstice);%@NL@%
                clrControlPoints = GpiQueryRGBColor(hps, 0L, clrControlPoints);%@NL@%
%@NL@%
                WinReleasePS(hps);%@NL@%
%@NL@%
                MySetWindowLongHex(hwnd, IDD_MATHOBJ,         clrMathObj);%@NL@%
                MySetWindowLongHex(hwnd, IDD_RENDEREDOBJ, clrRenderedObj);%@NL@%
                MySetWindowLongHex(hwnd, IDD_FIELD,         clrField);%@NL@%
                MySetWindowLongHex(hwnd, IDD_CROSSHAIRS,  clrCrossHair);%@NL@%
                MySetWindowLongHex(hwnd, IDD_INTERSTICE,  clrInterstice);%@NL@%
                MySetWindowLongHex(hwnd, IDD_CTLPOINTS,         clrControlPoints);%@NL@%
            }%@NL@%
            else%@NL@%
            {%@NL@%
                HPS hps;%@NL@%
%@NL@%
                %@AB@%/* for each color, get nearest index value from rgb */%@AE@%%@NL@%
%@NL@%
                hps = WinGetPS(hwnd);%@NL@%
%@NL@%
                clrMathObj         = GpiQueryColorIndex(hps, 0L, clrMathObj);%@NL@%
                clrRenderedObj         = GpiQueryColorIndex(hps, 0L, clrRenderedObj);%@NL@%
                clrField         = GpiQueryColorIndex(hps, 0L, clrField);%@NL@%
                clrCrossHair         = GpiQueryColorIndex(hps, 0L, clrCrossHair);%@NL@%
                clrInterstice         = GpiQueryColorIndex(hps, 0L, clrInterstice);%@NL@%
                clrControlPoints = GpiQueryColorIndex(hps, 0L, clrControlPoints);%@NL@%
%@NL@%
                WinReleasePS(hps);%@NL@%
%@NL@%
                MySetWindowLong   (hwnd, IDD_MATHOBJ,         clrMathObj);%@NL@%
                MySetWindowLong   (hwnd, IDD_RENDEREDOBJ, clrRenderedObj);%@NL@%
                MySetWindowLong   (hwnd, IDD_FIELD,         clrField);%@NL@%
                MySetWindowLong   (hwnd, IDD_CROSSHAIRS,  clrCrossHair);%@NL@%
                MySetWindowLong   (hwnd, IDD_INTERSTICE,  clrInterstice);%@NL@%
                MySetWindowLong   (hwnd, IDD_CTLPOINTS,         clrControlPoints);%@NL@%
            }%@NL@%
        }%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
            global.clrMathObj            = MyGetWindowLong(hwnd, IDD_MATHOBJ);%@NL@%
            global.clrRenderedObj   = MyGetWindowLong(hwnd, IDD_RENDEREDOBJ);%@NL@%
            global.clrField            = MyGetWindowLong(hwnd, IDD_FIELD);%@NL@%
            global.clrCrossHair     = MyGetWindowLong(hwnd, IDD_CROSSHAIRS);%@NL@%
            global.clrInterstice    = MyGetWindowLong(hwnd, IDD_INTERSTICE);%@NL@%
            global.clrControlPoints = MyGetWindowLong(hwnd, IDD_CTLPOINTS);%@NL@%
%@NL@%
            global.fRGB = SHORT1FROMMR(WinSendDlgItemMsg(hwnd, IDD_RGB, BM_QUERYCHECK, 0L, 0L));%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
            %@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MySetWindowLong%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Sets the given control id to the value specified.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MySetWindowLong(hWnd, id, num)%@NL@%
HWND hWnd;%@NL@%
USHORT id;%@NL@%
LONG num;%@NL@%
{%@NL@%
    char szStr[CCHSTR];%@NL@%
%@NL@%
    sprintf((NPCH)szStr, "%ld", num);%@NL@%
    WinSetWindowText(WinWindowFromID(hWnd, id), (PCH)szStr);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MySetWindowLongHex%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Sets the given control id to the value specified, in hexadecimal%@NL@%
%@AB@%*   notation.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MySetWindowLongHex(hWnd, id, num)%@NL@%
HWND hWnd;%@NL@%
USHORT id;%@NL@%
LONG num;%@NL@%
{%@NL@%
    char szStr[CCHSTR];%@NL@%
%@NL@%
    sprintf((NPCH)szStr, "0x%06lX", num);%@NL@%
    WinSetWindowText(WinWindowFromID(hWnd, id), (PCH)szStr);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MyGetWindowLong%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Returns the value from the given control id.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
LONG%@NL@%
MyGetWindowLong(hWnd, id)%@NL@%
HWND hWnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    char szStr[CCHSTR];%@NL@%
    LONG num;%@NL@%
%@NL@%
    WinQueryWindowText(WinWindowFromID(hWnd, id), CCHSTR, (PCH)szStr);%@NL@%
%@NL@%
    if (strchr(szStr, 'x'))%@NL@%
        sscanf((NPCH)szStr, "0x%lx", &num);%@NL@%
    else if (strchr(szStr, 'X'))%@NL@%
        sscanf((NPCH)szStr, "0X%lx", &num);%@NL@%
    else%@NL@%
        sscanf((NPCH)szStr, "%ld", &num);%@NL@%
%@NL@%
    return num;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   SaveWindowToFile%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Copy the bits from the client rectangle (actually, just the fatpel%@NL@%
%@AB@%*   area) into a bitmap, then save that bitmap.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
SaveWindowToFile(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    BITMAPINFOHEADER bminfo;%@NL@%
    HBITMAP hbm;%@NL@%
    HPS hps;%@NL@%
    POINTL aptl[3];%@NL@%
%@NL@%
    %@AB@%/* create bitmap in display's favorite format */%@AE@%%@NL@%
    bminfo.cbFix = sizeof(BITMAPINFOHEADER);%@NL@%
    bminfo.cx = (USHORT) (global.rcl.xRight - global.rcl.xLeft);%@NL@%
    bminfo.cy = (USHORT) (global.rcl.yTop   - global.rcl.yBottom);%@NL@%
    bminfo.cPlanes   = 0L;%@NL@%
    bminfo.cBitCount = 0L;%@NL@%
    if (hbm = GpiCreateBitmap(global.hpsFat, &bminfo, 0L, 0L, 0L))%@NL@%
    {%@NL@%
        %@AB@%/* select it into the small bitmap's PS */%@AE@%%@NL@%
        GpiSetBitmap(global.hpsFat, hbm);%@NL@%
%@NL@%
        %@AB@%/* GpiBitBlt from the window to the bitmap */%@AE@%%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
%@NL@%
        *((PRECTL)&aptl[0]) = global.rcl;%@NL@%
        aptl[2].x = 0L;%@NL@%
        aptl[2].y = 0L;%@NL@%
        GpiBitBlt(global.hpsFat, hps, 3L, aptl, ROP_SRCCOPY, 0L);%@NL@%
%@NL@%
        WinReleasePS(hps);%@NL@%
%@NL@%
        %@AB@%/* save the bitmap */%@AE@%%@NL@%
        WriteFile(hwnd, global.hpsFat);%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* deselect the bitmap and delete it */%@AE@%%@NL@%
    GpiSetBitmap(global.hpsFat, global.hbmFat);%@NL@%
    if (hbm)%@NL@%
        GpiDeleteBitmap(hbm);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   WriteFile%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Calls the OpenDlg's DlgFile function to ask the user what file name to%@NL@%
%@AB@%*   save under.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
WriteFile(hwnd, hps)%@NL@%
HWND hwnd;%@NL@%
HPS hps;%@NL@%
{%@NL@%
    HFILE hfile;%@NL@%
    DLF dlf;%@NL@%
    BITMAPINFOHEADER bmih;%@NL@%
%@NL@%
    dlf.rgbAction        = DLG_SAVEDLG;%@NL@%
    dlf.rgbFlags        = 0;%@NL@%
    dlf.phFile                = &hfile;%@NL@%
    dlf.pszExt                = "";%@NL@%
    dlf.pszAppName        = "FatPel";%@NL@%
    dlf.pszInstructions = NULL;%@NL@%
    dlf.szFileName[0]        = '\0';%@NL@%
    dlf.szOpenFile[0]        = '\0';%@NL@%
    dlf.pszTitle        = "Save Bitmap";%@NL@%
%@NL@%
%@NL@%
    switch (DlgFile(hwnd,&dlf))%@NL@%
    {%@NL@%
    case TDF_ERRMEM:%@NL@%
    case TDF_INVALID:%@NL@%
        MyMessageBox(hwnd, "Error opening file.");%@NL@%
        break;%@NL@%
%@NL@%
    case TDF_NOSAVE:%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        bmih.cbFix     = sizeof(BITMAPINFOHEADER);%@NL@%
        bmih.cx        = (USHORT) global.rcl.xRight;%@NL@%
        bmih.cy        = (USHORT) global.rcl.yTop;%@NL@%
        bmih.cPlanes   = 0L;%@NL@%
        bmih.cBitCount = 0L;%@NL@%
%@NL@%
        if (!WriteBMP(hfile, hps, &bmih))%@NL@%
            MyMessageBox(hwnd, "Error writing file.");%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   WriteBMP%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Write the bitmap out to a BMP format file.        Write the file%@NL@%
%@AB@%*   header first, then the bitmap bits.  Space for the header%@NL@%
%@AB@%*   and the bits is allocated.        Huge bitmaps are supported.%@NL@%
%@AB@%*   Free up memory and close the file before leaving.  The file%@NL@%
%@AB@%*   will have been opened by the time this function is called,%@NL@%
%@AB@%*   and the file handle will be in the *pdlf structure.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
WriteBMP(hfile, hps, pbmih)%@NL@%
HFILE hfile;%@NL@%
HPS hps;                 %@AB@%/* hps from which to get bitmap bits.           */%@AE@%%@NL@%
PBITMAPINFOHEADER pbmih; %@AB@%/* Bitmap information.                    */%@AE@%%@NL@%
{%@NL@%
    ULONG cScans;%@NL@%
    ULONG ulSize;         %@AB@%/* Number of bytes occupied by bitmap bits.             */%@AE@%%@NL@%
    USHORT cSegs;         %@AB@%/* Number of 64K segments in ulSize.                     */%@AE@%%@NL@%
    USHORT cbExtra;         %@AB@%/* Bytes in last segment of ulSize.                     */%@AE@%%@NL@%
    SEL selBits;         %@AB@%/* Base selector to bitmap bits.                     */%@AE@%%@NL@%
    USHORT hugeshift;         %@AB@%/* Segment index shift value.                             */%@AE@%%@NL@%
    USHORT cbBMHdr;         %@AB@%/* Size of bitmap header.                             */%@AE@%%@NL@%
    PBITMAPFILEHEADER pbfh; %@AB@%/* Pointer to private copy of bitmap info data.        */%@AE@%%@NL@%
    USHORT cbWrite1;         %@AB@%/* Number of bytes to write first call to DosWrite  */%@AE@%%@NL@%
    USHORT cbWrite2;         %@AB@%/* Number of bytes to write second call to DosWrite */%@AE@%%@NL@%
    USHORT cbWritten;         %@AB@%/* Number of bytes written by DosWrite.             */%@AE@%%@NL@%
    BOOL fRet = FALSE;         %@AB@%/* Function return code.                             */%@AE@%%@NL@%
    int i;                 %@AB@%/* Generic loop index.                              */%@AE@%%@NL@%
    struct%@NL@%
    {%@NL@%
        LONG cPlanes;%@NL@%
        LONG cBitCount;%@NL@%
    } bmFmt;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * If the bitmap was created with either 0 planes or 0 bits per%@NL@%
%@AB@%    * pixel, then query the format to write with.  By asking for just%@NL@%
%@AB@%    * one format (two LONGs, or one instance of structure of bmFmt),%@NL@%
%@AB@%    * we'll get the device's favored format.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    if ((pbmih->cPlanes == 0) || (pbmih->cBitCount == 0))%@NL@%
    {%@NL@%
        if (!GpiQueryDeviceBitmapFormats(hps, 2L, (PLONG)&bmFmt))%@NL@%
            goto lfwrite_error_close_file;%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
        bmFmt.cPlanes        = pbmih->cPlanes;%@NL@%
        bmFmt.cBitCount = pbmih->cBitCount;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Determine size of bitmap header.        The header consists of a%@NL@%
%@AB@%    * a fixed-size part and a variable-length color table.  The%@NL@%
%@AB@%    * latter has  2^cBitCount  entries, each of which is sizeof(RGB)%@NL@%
%@AB@%    * bytes long.  The exception is when cBitCount is 24, in which%@NL@%
%@AB@%    * case the color table is omitted because the pixels are direct%@NL@%
%@AB@%    * rgb values.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    i = (int) bmFmt.cBitCount;%@NL@%
    if (i == 24)%@NL@%
        cbBMHdr = 0;%@NL@%
    else%@NL@%
        for (cbBMHdr = sizeof(RGB); i > 0; --i)%@NL@%
            cbBMHdr *= 2;%@NL@%
    cbBMHdr += sizeof(BITMAPFILEHEADER);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Copy structure from input to work buffer.  The call to%@NL@%
%@AB@%    * GpiQueryBitmapBits will have write-access to this, so we won't%@NL@%
%@AB@%    * let it have the user's data.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    pbfh = 0;%@NL@%
    if (DosAllocSeg(cbBMHdr, ((PUSHORT)&pbfh)+1, 0))%@NL@%
        goto lfwrite_error_close_file;%@NL@%
    pbfh->bmp = *pbmih;%@NL@%
    if ((pbmih->cPlanes == 0) || (pbmih->cBitCount))%@NL@%
    {%@NL@%
        pbfh->bmp.cPlanes   = (USHORT) bmFmt.cPlanes;%@NL@%
        pbfh->bmp.cBitCount = (USHORT) bmFmt.cBitCount;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Allocate space for the bitmap bits -- all of them at once.%@NL@%
%@AB@%    * The extra ULONG casts are there to force all the arithmetic%@NL@%
%@AB@%    * to be done in 32 bits.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    ulSize = (%@NL@%
               (%@NL@%
                 (%@NL@%
                   (ULONG)pbfh->bmp.cBitCount%@NL@%
                   * (ULONG)pbfh->bmp.cx%@NL@%
                   + 31L%@NL@%
                 ) / 32L%@NL@%
               ) * (ULONG)pbfh->bmp.cPlanes * 4L%@NL@%
             ) * (ULONG)pbfh->bmp.cy;%@NL@%
%@NL@%
    cSegs   = (USHORT)(ulSize/0x10000L);%@NL@%
    cbExtra = (USHORT)(ulSize%0x10000L);%@NL@%
    if (DosAllocHuge(cSegs, cbExtra, (PSEL)&selBits, 0, 0))%@NL@%
        goto lfwrite_error_free_header;%@NL@%
    if (DosGetHugeShift(&hugeshift))%@NL@%
        goto lfwrite_error_free_bits;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Tell GPI to give us the bits. The function returns the number%@NL@%
%@AB@%    * of scan lines of the bitmap that were copied.  We want all of%@NL@%
%@AB@%    * them at once.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    cScans = GpiQueryBitmapBits( hps%@NL@%
                               , 0L%@NL@%
                               , (ULONG)pbfh->bmp.cy%@NL@%
                               , (PBYTE)MAKEP(selBits, 0)%@NL@%
                               , (PBITMAPINFO)&pbfh->bmp);%@NL@%
    if (cScans != pbfh->bmp.cy)  %@AB@%/* compare with original number of scans */%@AE@%%@NL@%
        goto lfwrite_error_free_bits;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Fill in the extra header fields and write the header out to%@NL@%
%@AB@%    * the file.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    pbfh->usType    = 0x4D42;                  %@AB@%/* 'MB' */%@AE@%%@NL@%
    pbfh->cbSize    = ulSize + cbBMHdr;%@NL@%
    pbfh->xHotspot  = pbfh->bmp.cx / 2;%@NL@%
    pbfh->yHotspot  = pbfh->bmp.cy / 2;%@NL@%
    pbfh->offBits   = cbBMHdr;%@NL@%
%@NL@%
    if (DosWrite( hfile%@NL@%
                , (PVOID)pbfh%@NL@%
                , cbBMHdr%@NL@%
                , &cbWritten))%@NL@%
        goto lfwrite_error_free_bits;%@NL@%
    if (cbWritten != cbBMHdr)%@NL@%
        goto lfwrite_error_free_bits;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Write the bits out to the file. The DosWrite function allows a%@NL@%
%@AB@%    * maximum of 64K-1 bytes written at a time.  We get around this%@NL@%
%@AB@%    * by writing two 32K chunks for each 64K segment, and writing the%@NL@%
%@AB@%    * last segment in one piece.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    for (i = 0; i <= (SHORT) cSegs; ++i)%@NL@%
    {%@NL@%
        if (i < (SHORT) cSegs)%@NL@%
        {%@NL@%
            %@AB@%/* This segment is 64K bytes long, so split it up. */%@AE@%%@NL@%
            cbWrite1 = 0x8000;%@NL@%
            cbWrite2 = 0x8000;%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
            %@AB@%/* This segment is less than 64K bytes long, so write it all. */%@AE@%%@NL@%
            cbWrite1 = cbExtra;%@NL@%
            cbWrite2 = 0;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* There's a possibility that cbExtra will be 0, so check%@NL@%
%@AB@%         * to avoid an unnecessary system call.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (cbWrite1 > 0)%@NL@%
        {%@NL@%
            if (DosWrite( hfile%@NL@%
                        , (PVOID)MAKEP(selBits+(i<<hugeshift), 0)%@NL@%
                        , cbWrite1%@NL@%
                        , &cbWritten))%@NL@%
                goto lfwrite_error_free_bits;%@NL@%
            if (cbWrite1 != cbWritten)%@NL@%
                goto lfwrite_error_free_bits;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* This will always be skipped on the last partial segment. */%@AE@%%@NL@%
        if (cbWrite2 > 0)%@NL@%
        {%@NL@%
            if (DosWrite( hfile%@NL@%
                        , (PVOID)MAKEP(selBits+(i<<hugeshift), cbWrite1)%@NL@%
                        , cbWrite2%@NL@%
                        , &cbWritten))%@NL@%
                goto lfwrite_error_free_bits;%@NL@%
            if (cbWrite2 != cbWritten)%@NL@%
                goto lfwrite_error_free_bits;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    fRet = TRUE;     %@AB@%/* The bits are on the disk. */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Close the file, free the buffer space and leave.        This is a%@NL@%
%@AB@%    * common exit point from the function.  Since the same cleanup%@NL@%
%@AB@%    * operations need to be performed for such a large number of%@NL@%
%@AB@%    * possible error conditions, this is concise way to do the right%@NL@%
%@AB@%    * thing.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
lfwrite_error_free_bits:%@NL@%
    DosFreeSeg(selBits);%@NL@%
lfwrite_error_free_header:%@NL@%
    DosFreeSeg(*((PUSHORT)&pbfh+1));%@NL@%
lfwrite_error_close_file:%@NL@%
    DosClose(hfile);%@NL@%
    return fRet;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MyMessageBox%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Displays a message box with the given string.  To simplify matters,%@NL@%
%@AB@%*   the box will always have the same title ("FatPel"), will always%@NL@%
%@AB@%*   have a single button ("Ok"), will always have an exclamation point%@NL@%
%@AB@%*   icon, and will always be application modal.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MyMessageBox(hWnd, sz)%@NL@%
HWND hWnd;%@NL@%
PSZ sz;%@NL@%
{%@NL@%
    static char *szTitle = "FatPel Application";%@NL@%
%@NL@%
    WinMessageBox(HWND_DESKTOP, hWnd, sz, szTitle, 0,%@NL@%
                  MB_OK|MB_ICONEXCLAMATION|MB_APPLMODAL);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FDIR.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\FDIR\FDIR.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@% This sample code demonstrates conversion from longnames to 8.3 and how%@NL@%
%@AB@% to determine the longname from the EA of a FAT file.%@NL@%
%@AB@% Should be compiled with the Large model.%@NL@%
%@AB@%%@NL@%
%@AB@% Written by Jeff Johnson 6/20/89%@NL@%
%@AB@%%@NL@%
%@AB@% This code was written to demonstrate two new features of OS/2 V1.2:%@NL@%
%@AB@% 1) How to convert long filenames to the appropriate 8.3 names.%@NL@%
%@AB@% 2) How to find a file's longname on a FAT system by checking its EA.%@NL@%
%@AB@%%@NL@%
%@AB@% Procedures in this file:%@NL@%
%@AB@%   main()             Does the main directory program calling support modules%@NL@%
%@AB@%   Convert_to_8dot3() Converts a longname to 8.3 name%@NL@%
%@AB@%   ParsePathName()    Breaks a full path into its 3 components%@NL@%
%@AB@%   QueryLongname()    Gets the .LONGNAME EA for a given file%@NL@%
%@AB@%   QueryIFS()         Determines the IFS type of a drive%@NL@%
%@AB@%%@NL@%
%@AB@%**************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%INCL_BASE %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<malloc.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%FAT  0 %@NL@%
%@AI@%#define %@AE@%HPFS 1 %@NL@%
%@AI@%#define %@AE@%GetInfoLevel1 0x0001 %@NL@%
%@AI@%#define %@AE@%GetInfoLevel3 0x0003 %@NL@%
%@NL@%
VOID Convert_to_8dot3(CHAR *,CHAR *);%@NL@%
VOID ParsePathName(CHAR *,CHAR *,CHAR *,CHAR *);%@NL@%
VOID QueryLongname(CHAR *,CHAR *);%@NL@%
VOID QueryIFS(CHAR *,PUSHORT,PUSHORT);%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: main()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  argc, argv.  If the user places a file spec on the command%@NL@%
%@AB@% *              line it is used to select/filter the directory listing.%@NL@%
%@AB@% *              Otherwise, the default directory is listed.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Always exits with 0.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: main() coordinates the directory process by calling the%@NL@%
%@AB@% *          appropriate setup routines, then handling the DosFindNext%@NL@%
%@AB@% *          loop for each file.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Very little error checking is done as the code is written%@NL@%
%@AB@% *                  to demonstrate longname conversion/EA reading, not as%@NL@%
%@AB@% *                  a finished app.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: ParsePathName(), QueryIFS(), Convert_to_8dot3(), QueryLongname()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
main (int argc, char *argv[])%@NL@%
{%@NL@%
    USHORT uRetval,hdir=0xffff,SearchCount=1;%@NL@%
    PFILEFINDBUF pfbuf;%@NL@%
    char szDrive[3],szPath[260],szFilename[CCHMAXPATH],szFullPath[CCHMAXPATH];%@NL@%
    USHORT ifsloc,ifsname;%@NL@%
    char *szFilePtr,szLongName[260];%@NL@%
%@NL@%
    if(argc<2)%@NL@%
        ParsePathName("",szDrive,szPath,szFilename);%@NL@%
    else%@NL@%
        ParsePathName(argv[1],szDrive,szPath,szFilename);%@NL@%
%@NL@%
    if(strlen(szFilename) == 0)%@NL@%
        strcpy(szFilename,"*");%@NL@%
%@NL@%
    strcpy(szFullPath,szDrive);%@NL@%
    strcat(szFullPath,szPath);%@NL@%
    szFilePtr = szFullPath + strlen(szFullPath);%@NL@%
    strcat(szFullPath,szFilename);%@NL@%
%@NL@%
    QueryIFS(szDrive,&ifsloc,&ifsname);%@NL@%
%@NL@%
    if(ifsname != FAT && ifsname != HPFS)%@NL@%
    {%@NL@%
        printf("Unrecognized file system.\n");%@NL@%
        return 0;%@NL@%
    }%@NL@%
%@NL@%
    if(ifsname == FAT)%@NL@%
        printf("FAT -> HPFS directory listing\n");%@NL@%
    else%@NL@%
        printf("HPFS -> FAT directory listing\n");%@NL@%
%@NL@%
%@NL@%
    pfbuf = (PFILEFINDBUF) malloc(sizeof(FILEFINDBUF));%@NL@%
    uRetval=DosFindFirst(szFullPath,(PHDIR) &hdir,FILE_DIRECTORY,%@NL@%
                         pfbuf,sizeof(FILEFINDBUF),&SearchCount,0L);%@NL@%
%@NL@%
    if(uRetval)%@NL@%
    {%@NL@%
        printf("No files found.\n");%@NL@%
        return 0;%@NL@%
    }%@NL@%
%@NL@%
    do%@NL@%
    {%@NL@%
        if(ifsname == FAT)%@NL@%
        {%@NL@%
            strcpy(szFilePtr,pfbuf->achName);  %@AB@%/* Drop in name after path */%@AE@%%@NL@%
%@NL@%
            QueryLongname(szFullPath,szLongName);%@NL@%
%@NL@%
            if(strlen(szLongName) == 0)%@NL@%
                printf("%s\n",pfbuf->achName);%@NL@%
            else%@NL@%
                printf("%s\n",szLongName);%@NL@%
        }%@NL@%
        else   %@AB@%/* It's HPFS */%@AE@%%@NL@%
        {%@NL@%
            Convert_to_8dot3(pfbuf->achName,szFilename);%@NL@%
            printf("%s\n",szFilename);%@NL@%
        }%@NL@%
    } while(!(uRetval=DosFindNext(hdir,pfbuf,%@NL@%
                                  sizeof(FILEFINDBUF),&SearchCount)));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: Convert_to_8dot3()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  szLong points to the input long file name.%@NL@%
%@AB@% *              szFat points to a return buffer for the FAT compatible name.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID. The converted string is placed in szFat buffer.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Converts a HPFS longname to the standard 8.3 name.  This is%@NL@%
%@AB@% *          done as follows:  The extension is the first 3 characters after%@NL@%
%@AB@% *          the last dot, no extension if there are no dots.  The file stem%@NL@%
%@AB@% *          is at most 8 character and is taken from the beginning of the%@NL@%
%@AB@% *          longname string, replacing all dots with underscores.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Should be bulletproof.  Exception code included to allow%@NL@%
%@AB@% *                  the special file name '..' through.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID Convert_to_8dot3(CHAR *szLong,CHAR *szFat)%@NL@%
{%@NL@%
    USHORT usStemMaxLen; %@AB@%/* Holds the max size the 8 char base can be */%@AE@%%@NL@%
    USHORT cnt;%@NL@%
    CHAR   szStem[9],szExt[4];  %@AB@%/* Holds the Stem and Extension */%@AE@%%@NL@%
    CHAR   *szLastDot;          %@AB@%/* Pointer to the last dot */%@AE@%%@NL@%
%@NL@%
    if(!strcmp(szLong,"..")) %@AB@%/* Allow the predecessor file to pass thru */%@AE@%%@NL@%
    {%@NL@%
        strcpy(szFat,"..");%@NL@%
        return;%@NL@%
    }%@NL@%
%@NL@%
    szLastDot = strrchr(szLong,'.'); %@AB@%/* Find the last period */%@AE@%%@NL@%
%@NL@%
    if(szLastDot)  %@AB@%/* There is at least one period */%@AE@%%@NL@%
    {%@NL@%
        strncpy(szExt,szLastDot+1,3);       %@AB@%/* 1st 3 chars after . are ext */%@AE@%%@NL@%
        szExt[3]=0;%@NL@%
        usStemMaxLen = szLastDot - szLong;  %@AB@%/* Max stem is everything b4 . */%@AE@%%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
        *szExt = 0;                         %@AB@%/* No extension */%@AE@%%@NL@%
        usStemMaxLen = strlen(szLong);      %@AB@%/* Stem can be whole string */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    if(usStemMaxLen>8)                      %@AB@%/* Limit stem to 8 chars */%@AE@%%@NL@%
        usStemMaxLen = 8;%@NL@%
%@NL@%
    for(cnt=0;cnt<usStemMaxLen;cnt++)       %@AB@%/* Copy in chars to form stem */%@AE@%%@NL@%
    {%@NL@%
        switch(szLong[cnt])%@NL@%
        {%@NL@%
            case '.':                       %@AB@%/* Convert .'s to _'s */%@AE@%%@NL@%
                szStem[cnt] = '_';%@NL@%
                break;%@NL@%
            default:                        %@AB@%/* Copy all other chars */%@AE@%%@NL@%
                szStem[cnt] = szLong[cnt];%@NL@%
                break;%@NL@%
        }%@NL@%
    }%@NL@%
    szStem[cnt] = 0;%@NL@%
%@NL@%
    %@AB@%/* Put it all together */%@AE@%%@NL@%
    strcpy(szFat,szStem);%@NL@%
    strcat(szFat,".");%@NL@%
    strcat(szFat,szExt);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: ParsePathName()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  szFullPath points to the input full path name.%@NL@%
%@AB@% *              szDrive points to the return buffer for the drive letter.%@NL@%
%@AB@% *              szPath points to the return buffer for the path.%@NL@%
%@AB@% *              szFilename points to the return buffer for the Filename.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID. The converted string is placed in last 3 passed params.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Break a full path string and break it into its three components.%@NL@%
%@AB@% *          If the passed string doesn't have a drive, the current letter is%@NL@%
%@AB@% *          fetched an placed in the return buffer.  The same is true for%@NL@%
%@AB@% *          the path buffer.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Error checking should be done on the DOS calls.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID ParsePathName(CHAR *szFullPath,CHAR *szDrive,CHAR *szPath,CHAR *szFilename)%@NL@%
{%@NL@%
    CHAR *szBack;          %@AB@%/* Used to find last backslach */%@AE@%%@NL@%
    USHORT usPathLen;      %@AB@%/* Holds the length of the path part of string */%@AE@%%@NL@%
%@NL@%
    *szPath = *szFilename = 0;%@NL@%
%@NL@%
    %@AB@%/* Do the Drive letter */%@AE@%%@NL@%
    if(*(szFullPath+1)==':')           %@AB@%/* If there is a drive letter */%@AE@%%@NL@%
    {%@NL@%
        szDrive[0] = *szFullPath;%@NL@%
%@NL@%
        szFullPath += 2;%@NL@%
    }%@NL@%
    else                               %@AB@%/* We take the default */%@AE@%%@NL@%
    {%@NL@%
        USHORT dno;  %@AB@%/* Drive number */%@AE@%%@NL@%
        ULONG  dmap; %@AB@%/* Map of available drives */%@AE@%%@NL@%
%@NL@%
        DosQCurDisk((PUSHORT) &dno,(PULONG) &dmap);%@NL@%
        *szDrive = (CHAR)( dno + 'A'-1);%@NL@%
    }%@NL@%
    szDrive[1] = ':';          %@AB@%/* Add the colon */%@AE@%%@NL@%
    szDrive[2] = (CHAR) 0;%@NL@%
%@NL@%
    %@AB@%/* Now do the path */%@AE@%%@NL@%
    szBack = strrchr(szFullPath,'\\');%@NL@%
    if(szBack)                         %@AB@%/* There is at least 1 backslash */%@AE@%%@NL@%
    {%@NL@%
       usPathLen = szBack - szFullPath + 1;%@NL@%
       strncpy(szPath,szFullPath,usPathLen);   %@AB@%/* Copy path */%@AE@%%@NL@%
       szPath[usPathLen] = (CHAR) 0;%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
       *szPath = (CHAR) 0;%@NL@%
       szBack  = szFullPath-1;  %@AB@%/* Points 1 char before the file name */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* Finally do the file name */%@AE@%%@NL@%
    strcpy(szFilename,szBack+1);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: QueryLongname()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  szfile points to the file to be queried.%@NL@%
%@AB@% *              szLong points to the return buffer for the long filename.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID. The converted string is placed in last 3 passed params.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Looks for an EA named .LONGNAME attached to szfile.  If found,%@NL@%
%@AB@% *          it places the EA value in the return buffer.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Routine assumes that the EA format is LP ASCII which%@NL@%
%@AB@% *                  is what the specs required, but probably the exception%@NL@%
%@AB@% *                  handling should be a bit tighter.  Return buf should be%@NL@%
%@AB@% *                  at least CCHMAXPATH long to accomodate max length names.%@NL@%
%@AB@% *                  Note also that no check is made to prevent overwriting%@NL@%
%@AB@% *                  the end of the return buffer.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID QueryLongname(CHAR *szfile,CHAR *szLong)%@NL@%
{%@NL@%
    CHAR    *szEAName;  %@AB@%/* Points to the .LONGNAME string */%@AE@%%@NL@%
    SHORT   cbEAName;   %@AB@%/* Length of the .LONGNAME string */%@AE@%%@NL@%
%@NL@%
    SHORT   cbFEAList;  %@AB@%/* The length of the FEA buf to be used */%@AE@%%@NL@%
    SHORT   cbGEAList;  %@AB@%/* "                 GEA                */%@AE@%%@NL@%
%@NL@%
    CHAR   cvFdump[300],cvGdump[50];     %@AB@%/* FEA and GEA buffers */%@AE@%%@NL@%
    FEALIST *pFEAList;                   %@AB@%/* Pointers to the buffers */%@AE@%%@NL@%
    GEALIST *pGEAList;%@NL@%
    EAOP    eaop;%@NL@%
                                         %@AB@%/* Pass struct for Dos call */%@AE@%%@NL@%
    USHORT  usRetval;%@NL@%
    SHORT   cbRet;%@NL@%
    CHAR    *szT;%@NL@%
%@NL@%
    *szLong = (CHAR) 0;                %@AB@%/* Default if we can't get the EA */%@AE@%%@NL@%
%@NL@%
    szEAName = ".LONGNAME";        %@AB@%/* The particular EA we are interested in */%@AE@%%@NL@%
    cbEAName = strlen(szEAName);%@NL@%
%@NL@%
    cbGEAList = sizeof(GEALIST) + cbEAName;  %@AB@%/* Set buf lengths */%@AE@%%@NL@%
    cbFEAList = sizeof(FEALIST) + cbEAName+1 + 256 + 2;%@NL@%
%@NL@%
    pFEAList = (FEALIST *) cvFdump;   %@AB@%/* Set pointers to 2 buffers */%@AE@%%@NL@%
    pGEAList = (GEALIST *) cvGdump;%@NL@%
%@NL@%
    eaop.fpGEAList = (PGEALIST) pGEAList; %@AB@%/* Build the EAOP struct */%@AE@%%@NL@%
    eaop.fpFEAList = (PFEALIST) pFEAList;%@NL@%
%@NL@%
    pGEAList->cbList = cbGEAList;       %@AB@%/* Fill in GEA buf length */%@AE@%%@NL@%
    pGEAList->list[0].cbName = (CHAR) cbEAName; %@AB@%/* Set .longname length */%@AE@%%@NL@%
    strcpy((char *) pGEAList->list[0].szName, (char *) szEAName);%@NL@%
%@NL@%
    pFEAList -> cbList = cbFEAList; %@AB@%/* Set length of receiving buffer */%@AE@%%@NL@%
%@NL@%
    usRetval = DosQPathInfo(szfile,      %@AB@%/* Get the .LONGNAME EA */%@AE@%%@NL@%
                            GetInfoLevel3,%@NL@%
                            (PVOID) &eaop,%@NL@%
                            sizeof(EAOP),%@NL@%
                            0L);%@NL@%
%@NL@%
    if(usRetval != 0) %@AB@%/* There was an error */%@AE@%%@NL@%
       return;%@NL@%
%@NL@%
    if(pFEAList->list[0].cbValue <=0)  %@AB@%/* It couldn't return EA value */%@AE@%%@NL@%
       return;%@NL@%
%@NL@%
    szT = (CHAR *) pFEAList + sizeof(FEALIST) + cbEAName + 1;%@NL@%
    if (*((USHORT *) szT) == 0xfffd) %@AB@%/* length preceeded ASCII */%@AE@%%@NL@%
    {%@NL@%
        szT += 2;%@NL@%
        cbRet = *((USHORT *) szT);%@NL@%
%@NL@%
        szT += 2;%@NL@%
        strncpy(szLong,szT,cbRet);%@NL@%
        szLong[cbRet]=0;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: QueryIFS()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  szDrive points to drive letter to be queried.%@NL@%
%@AB@% *              pusLocale will contain the location of the drive:%@NL@%
%@AB@% *                        3=local, 4=remote.%@NL@%
%@AB@% *              pusFSDName will contain the IFS type: 0=FAT, 1=HPFS, 2=Other.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID.  All returns are in the last 2 params.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Mainly used to determine whether the file system is FAT or HPFS.%@NL@%
%@AB@% *          also returns info on whether the drive is local or remote.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Error checking on the DOS call should be implemented.%@NL@%
%@AB@% *                  The buffer filled by DosQFSAttach is structured as follows:%@NL@%
%@AB@% *                         USHORT iType;%@NL@%
%@AB@% *                         USHORT cbName;%@NL@%
%@AB@% *                         UCHAR  szName[];%@NL@%
%@AB@% *                         USHORT cbFSDName;%@NL@%
%@AB@% *                         UCHAR  szFSDName[];%@NL@%
%@AB@% *                         ...%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID QueryIFS(CHAR *szDrive,PUSHORT pusLocale,PUSHORT pusFSDName)%@NL@%
{%@NL@%
    CHAR vChunk[100];             %@AB@%/* Buffer for data from DosQFSAttach */%@AE@%%@NL@%
    USHORT usChunkLen=100;%@NL@%
    USHORT usTemp;                %@AB@%/* Holds offset for FSDName */%@AE@%%@NL@%
%@NL@%
    DosQFSAttach(szDrive,0,GetInfoLevel1, vChunk,&usChunkLen,0L);%@NL@%
%@NL@%
    *pusLocale = *((PUSHORT) vChunk);  %@AB@%/* Set local from 1st USHORT *);*/%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Skip over iType, cbName, szName, and cbFSDName fields to szFSDName */%@AE@%%@NL@%
    usTemp = *((PUSHORT) &vChunk[sizeof(USHORT)]) + sizeof(USHORT)*3 + 1;%@NL@%
%@NL@%
    if(!strcmp("FAT",&vChunk[usTemp]))%@NL@%
    {%@NL@%
        *pusFSDName = 0;%@NL@%
        return;%@NL@%
    }%@NL@%
    if(!strcmp("HPFS",&vChunk[usTemp]))%@NL@%
    {%@NL@%
        *pusFSDName = 1;%@NL@%
        return;%@NL@%
    }%@NL@%
%@NL@%
    *pusFSDName = 2;%@NL@%
    return;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FILE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\STOCK\FILE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***        file.C - standard file dialogs%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOSERRORS %@NL@%
%@AI@%#define %@AE@%INCL_WINCOMMON %@NL@%
%@AI@%#define %@AE@%INCL_WINBUTTONS %@NL@%
%@AI@%#define %@AE@%INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stddef.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"fileid.h" %@NL@%
%@AI@%#include %@AE@%"file.h" %@NL@%
%@AI@%#include %@AE@%"mem.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%dbg(x)        x %@NL@%
%@NL@%
typedef struct {    %@AB@%/* fctl */%@AE@%%@NL@%
    char    *pszTitle;                        // Dialog box title%@NL@%
    char    *pszPattern;                // wild-card file pattern%@NL@%
    char    achPath[CCHMAXPATH];        // full path of file%@NL@%
} FILECTL;%@NL@%
typedef FILECTL *PFILECTL;%@NL@%
%@NL@%
MRESULT EXPENTRY FileDlgProc(HWND hwnd,USHORT msg,MPARAM mp1,MPARAM mp2);%@NL@%
%@NL@%
USHORT                beginSearch(char *psz, USHORT *pattr);%@NL@%
BOOL                changeDir(HWND hwndDlg, PFILECTL pfctl);%@NL@%
BOOL                changeDrive(HWND hwndDlg, PFILECTL pfctl);%@NL@%
BOOL                changeFile(HWND hwndDlg, PFILECTL pfctl);%@NL@%
void                endSearch(void);%@NL@%
USHORT                nextSearch(char *psz, USHORT *pattr);%@NL@%
USHORT                niceWinDlgBox(HWND hwndParent, HWND hwndOwner, PFNWP pfnDlgProc,%@NL@%
                            HMODULE hmod, USHORT idDlg, PVOID pCreateParams);%@NL@%
BOOL                setCurDir(HWND hwndDlg);%@NL@%
BOOL                setDir(HWND hwndDlg);%@NL@%
BOOL                setDrive(HWND hwndDlg);%@NL@%
BOOL                setFile(HWND hwndDlg);%@NL@%
char *                trimBlanks(char * psz);%@NL@%
%@NL@%
%@NL@%
static BOOL        fDidOK;                        // true if OK was just pressed%@NL@%
%@NL@%
static HDIR        hdir;                        // directory search handle%@NL@%
%@NL@%
static USHORT        itDrive;                // last item selected in Drive LB%@NL@%
static USHORT        itDir;                        // last item selected in Dir LB%@NL@%
static USHORT        itFile;                        // last item selected in File LB%@NL@%
%@NL@%
%@NL@%
char *FileOpen(HWND hwndOwner,char *pszTitle,char *pszPattern)%@NL@%
{%@NL@%
    BOOL    fOK;%@NL@%
    FILECTL fctl;%@NL@%
%@NL@%
    fctl.pszTitle = pszTitle;%@NL@%
    fctl.pszPattern = pszPattern;%@NL@%
%@NL@%
    fOK = niceWinDlgBox(HWND_DESKTOP, hwndOwner, FileDlgProc,%@NL@%
                            NULL, IDD_FILE, &fctl);%@NL@%
%@NL@%
    if (fOK)%@NL@%
        return MemStrDup(fctl.achPath);%@NL@%
    else%@NL@%
        return NULL;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
USHORT        niceWinDlgBox(HWND hwndParent, HWND hwndOwner, PFNWP pfnDlgProc,%@NL@%
                            HMODULE hmod, USHORT idDlg, PVOID pCreateParams)%@NL@%
{%@NL@%
    HAB            hab;%@NL@%
    HWND    hwndDlg;%@NL@%
    USHORT  us;%@NL@%
    SWP            swp;%@NL@%
    SWP            swpDesk;%@NL@%
%@NL@%
    hwndDlg = WinLoadDlg(hwndParent, hwndOwner, pfnDlgProc,%@NL@%
                            hmod, idDlg, pCreateParams);%@NL@%
%@NL@%
    WinQueryWindowPos(hwndDlg,&swp);  // get window position%@NL@%
    WinQueryWindowPos(HWND_DESKTOP,&swpDesk); // get desktop%@NL@%
%@NL@%
    // center dialog box on screen%@NL@%
%@NL@%
    swp.x = (swpDesk.cx - swp.cx) >> 1;%@NL@%
    swp.y = (swpDesk.cy - swp.cy) >> 1;%@NL@%
%@NL@%
    hab = WinQueryAnchorBlock(hwndDlg);%@NL@%
    WinSetMultWindowPos(hab,&swp,1);%@NL@%
%@NL@%
    us = WinProcessDlg(hwndDlg);%@NL@%
    WinDestroyWindow(hwndDlg);%@NL@%
%@NL@%
    return us;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***        FileDlgProc - "File" Dialog Procedure%@NL@%
%@AB@%*%@NL@%
%@AB@%*/%@AE@%%@NL@%
MRESULT EXPENTRY FileDlgProc(HWND hwnd,USHORT msg,MPARAM mp1,MPARAM mp2)%@NL@%
{%@NL@%
    static char            ach[CCHMAXPATH];%@NL@%
           USHORT   attr;%@NL@%
    static HWND            hwndFocus;%@NL@%
    static HWND            hwndLBDir;%@NL@%
    static HWND            hwndLBDrive;%@NL@%
    static HWND            hwndLBFile;%@NL@%
    static HWND            hwndText;%@NL@%
    static USHORT   idLB;%@NL@%
    static USHORT   idLBPrevious;%@NL@%
           USHORT   it;%@NL@%
    static PFILECTL pfctl;%@NL@%
           USHORT   rc;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_INITDLG:%@NL@%
        pfctl = (PFILECTL)(VOID *)SHORT1FROMMP(mp2);        // set file control block%@NL@%
%@NL@%
        hwndLBDir   = WinWindowFromID(hwnd, IDL_DIR);%@NL@%
        hwndLBDrive = WinWindowFromID(hwnd, IDL_DRIVE);%@NL@%
        hwndLBFile  = WinWindowFromID(hwnd, IDL_FILE);%@NL@%
        hwndText = WinWindowFromID(hwnd, IDC_TEXT);%@NL@%
        idLBPrevious = 0;                // no previous focus%@NL@%
%@NL@%
        WinSetWindowText(hwnd, pfctl->pszTitle);  // set dialog title%@NL@%
        WinSetWindowText(hwndText, pfctl->pszPattern);        // init file pattern%@NL@%
%@NL@%
        setDrive(hwnd);                        // init drive list box%@NL@%
        setDir(hwnd);                        // update dir list%@NL@%
        setFile(hwnd);                        // update file list%@NL@%
        setCurDir(hwnd);                // init current drive/dir string%@NL@%
%@NL@%
        WinDefDlgProc(hwnd, msg, mp1, mp2); // do default stuff%@NL@%
%@NL@%
        hwndFocus = hwndText;%@NL@%
        WinSetFocus(HWND_DESKTOP,hwndFocus);%@NL@%
        return (MRESULT) TRUE;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
%@NL@%
        case DID_OK:                        // store updated list%@NL@%
            dbg( printf("WM_COMMAND: DID_OK\n") );%@NL@%
            WinQueryWindowText(hwndText, CCHMAXPATH, ach);%@NL@%
            trimBlanks(ach);        // Trim leading/trailing blanks%@NL@%
            WinSetWindowText(hwndText, ach);%@NL@%
            dbg( printf("   opening %s\n",ach) );%@NL@%
            rc = DosQFileMode(ach,&attr,0L); // Does file exist?%@NL@%
            dbg( printf("   DosQFileMode rc=%d\n",rc) );%@NL@%
%@NL@%
            // If directory is specified, pretend file not found%@NL@%
%@NL@%
            if (attr & FILE_DIRECTORY)%@NL@%
                rc = ERROR_FILE_NOT_FOUND;%@NL@%
%@NL@%
            fDidOK = TRUE;%@NL@%
            switch (rc) {%@NL@%
%@NL@%
            case NO_ERROR: {%@NL@%
                USHORT        cch=CCHMAXPATH;%@NL@%
%@NL@%
                rc = DosQPathInfo(%@NL@%
                    ach,                // Path specifiec%@NL@%
                    FIL_QUERYFULLNAME,        // Get fully-qualified name%@NL@%
                    pfctl->achPath,        // Return buffer%@NL@%
                    CCHMAXPATH,                // Return buffer size%@NL@%
                    0L                        // Reserved%@NL@%
                    );%@NL@%
                if (rc == 0)%@NL@%
                    WinDismissDlg(hwnd,TRUE); // return SUCCESS%@NL@%
                }%@NL@%
                return FALSE;%@NL@%
%@NL@%
            case ERROR_FILE_NOT_FOUND:%@NL@%
            case ERROR_PATH_NOT_FOUND:%@NL@%
                // check for and process user wild-card pattern%@NL@%
                if (strcmp(ach,pfctl->pszPattern) != 0)%@NL@%
                    setFile(hwnd);%@NL@%
                break;                        // continue dialog%@NL@%
%@NL@%
            case ERROR_ACCESS_DENIED:%@NL@%
            case ERROR_DRIVE_LOCKED:%@NL@%
            case ERROR_NOT_DOS_DISK:%@NL@%
                WinMessageBox(HWND_DESKTOP, hwnd, "Access Denied",%@NL@%
                              "Error", NULL, MB_ICONEXCLAMATION);%@NL@%
                break;%@NL@%
%@NL@%
            default:%@NL@%
                break;%@NL@%
            }%@NL@%
            WinSetFocus(HWND_DESKTOP,hwndFocus);%@NL@%
            break;%@NL@%
%@NL@%
        case DID_CANCEL:%@NL@%
            WinDismissDlg(hwnd, NULL);%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CONTROL:%@NL@%
        idLBPrevious = idLB;                // remember previous focus%@NL@%
        idLB = SHORT1FROMMP(mp1);%@NL@%
        dbg (printf("WM_CONTROL: id = %04x hwndLB=%08x\n",idLB,mp2) );%@NL@%
        switch (SHORT2FROMMP(mp1)) {%@NL@%
            case LN_ENTER:%@NL@%
                switch (idLB) {%@NL@%
%@NL@%
                case IDL_DRIVE:%@NL@%
                    dbg( printf("LN_ENTER: IDL_DRIVE\n") );%@NL@%
                    changeDrive(hwnd,pfctl);%@NL@%
                    return FALSE;%@NL@%
%@NL@%
                case IDL_DIR:%@NL@%
                    dbg( printf("LN_ENTER: IDL_DIR\n") );%@NL@%
                    changeDir(hwnd,pfctl);%@NL@%
                    return FALSE;%@NL@%
%@NL@%
                case IDL_FILE:%@NL@%
                    dbg( printf("LN_ENTER: IDL_FILE\n") );%@NL@%
                    changeFile(hwnd,pfctl);%@NL@%
                    WinSendMsg(hwnd,WM_COMMAND,MPFROMSHORT(DID_OK),NULL);%@NL@%
                    return FALSE;%@NL@%
%@NL@%
                default:%@NL@%
                    dbg( printf("LN_ENTER: unknown list box = %04x\n",idLB) );%@NL@%
                    return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
                    break;%@NL@%
                }%@NL@%
                break;%@NL@%
%@NL@%
            case LN_SELECT:%@NL@%
                switch (idLB) {%@NL@%
%@NL@%
                case IDL_DRIVE:%@NL@%
                    dbg( printf("LN_SELECT: IDL_DRIVE\n") );%@NL@%
                    it = SHORT1FROMMR(WinSendMsg(hwndFocus, LM_QUERYSELECTION, 0L, 0L));%@NL@%
                    if (it != LIT_NONE) {%@NL@%
                        if (fDidOK)%@NL@%
                            fDidOK = FALSE;%@NL@%
                        else {%@NL@%
                            itDrive = it;%@NL@%
                            WinSendMsg(hwndFocus, LM_QUERYITEMTEXT,%@NL@%
                                MPFROM2SHORT(it,CCHMAXPATH), MPFROMP(ach));%@NL@%
                            strcat(ach,pfctl->pszPattern);%@NL@%
                            WinSetWindowText(hwndText, ach);%@NL@%
                        }%@NL@%
                    }%@NL@%
                    idLB = 0;                // allow LN_SETFOCUS to work%@NL@%
                    return FALSE;%@NL@%
%@NL@%
                case IDL_DIR:%@NL@%
                    dbg( printf("LN_SELECT: IDL_DIR\n") );%@NL@%
                    it = SHORT1FROMMR(WinSendMsg(hwndFocus, LM_QUERYSELECTION, 0L, 0L));%@NL@%
                    if (it != LIT_NONE) {%@NL@%
                        if (fDidOK)%@NL@%
                            fDidOK = FALSE;%@NL@%
                        else {%@NL@%
                            itDir = it;%@NL@%
                            WinSendMsg(hwndFocus, LM_QUERYITEMTEXT,%@NL@%
                                MPFROM2SHORT(it,CCHMAXPATH), MPFROMP(ach));%@NL@%
                            strcat(ach,"\\");%@NL@%
                            strcat(ach,pfctl->pszPattern);%@NL@%
                            WinSetWindowText(hwndText, ach);%@NL@%
                        }%@NL@%
                    }%@NL@%
                    idLB = 0;                // allow LN_SETFOCUS to work%@NL@%
                    return FALSE;%@NL@%
%@NL@%
                case IDL_FILE:%@NL@%
                    dbg( printf("LN_SELECT: IDL_FILE\n") );%@NL@%
                    it = SHORT1FROMMR(WinSendMsg(hwndFocus, LM_QUERYSELECTION, 0L, 0L));%@NL@%
                    if (it != LIT_NONE) {%@NL@%
                        if (fDidOK)%@NL@%
                            fDidOK = FALSE;%@NL@%
                        else {%@NL@%
                            itFile = it;%@NL@%
                            changeFile(hwnd,pfctl);%@NL@%
                        }%@NL@%
                    }%@NL@%
                    idLB = 0;                // allow LN_SETFOCUS to work%@NL@%
                    return FALSE;%@NL@%
%@NL@%
                default:%@NL@%
                    dbg( printf("LN_SELECT: unknown list box = %04x\n",idLB) );%@NL@%
                    return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
                    break;%@NL@%
                }%@NL@%
                break;%@NL@%
%@NL@%
            case LN_SETFOCUS:%@NL@%
                /%@AB@%/* The following test prevents reselecting the last%@NL@%
%@AB@%                //  selected list box item when the user is scrolling%@NL@%
%@AB@%                //  the list box.%@NL@%
%@AB@%%@NL@%
%@AB@%                if (idLB == idLBPrevious)%@NL@%
%@AB@%                    break;                // no actual focus change%@NL@%
%@AB@%%@NL@%
%@AB@%                switch (idLB) {%@NL@%
%@AB@%%@NL@%
%@AB@%                case IDL_DRIVE:%@NL@%
%@AB@%                    dbg( printf("LN_SETFOCUS: IDL_DRIVE\n") );%@NL@%
%@AB@%                    hwndFocus = hwndLBDrive;%@NL@%
%@AB@%                    WinSendMsg(hwndFocus, LM_SELECTITEM,%@NL@%
%@AB@%                            MPFROMSHORT(itDrive), MPFROMSHORT(TRUE));%@NL@%
%@AB@%                    return FALSE;%@NL@%
%@AB@%%@NL@%
%@AB@%                case IDL_DIR:%@NL@%
%@AB@%                    dbg( printf("LN_SETFOCUS: IDL_DIR\n") );%@NL@%
%@AB@%                    hwndFocus = hwndLBDir;%@NL@%
%@AB@%                    WinSendMsg(hwndFocus, LM_SELECTITEM,%@NL@%
%@AB@%                            MPFROMSHORT(itDir), MPFROMSHORT(TRUE));%@NL@%
%@AB@%                    return FALSE;%@NL@%
%@AB@%%@NL@%
%@AB@%                case IDL_FILE:%@NL@%
%@AB@%                    dbg( printf("LN_SETFOCUS: IDL_FILE\n") );%@NL@%
%@AB@%                    hwndFocus = hwndLBFile;%@NL@%
%@AB@%                    WinSendMsg(hwndFocus, LM_SELECTITEM,%@NL@%
%@AB@%                            MPFROMSHORT(itFile), MPFROMSHORT(TRUE));%@NL@%
%@AB@%                    return FALSE;%@NL@%
%@AB@%%@NL@%
%@AB@%                default:%@NL@%
%@AB@%                    dbg( printf("LN_SETFOCUS: unknown list box = %04x\n",idLB) );%@NL@%
%@AB@%                    return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
%@AB@%                    break;%@NL@%
%@AB@%                }%@NL@%
%@AB@%                break;%@NL@%
%@AB@%%@NL@%
%@AB@%            case LN_KILLFOCUS:%@NL@%
%@AB@%                switch (idLB) {%@NL@%
%@AB@%%@NL@%
%@AB@%                case IDL_DRIVE:%@NL@%
%@AB@%                    dbg( printf("LN_KILLFOCUS: IDL_DRIVE\n") );%@NL@%
%@AB@%                    hwndFocus = hwndLBDrive;%@NL@%
%@AB@%                    WinSendMsg(hwndFocus, LM_SELECTITEM,%@NL@%
%@AB@%                            MPFROMSHORT(LIT_NONE), MPFROMSHORT(FALSE));%@NL@%
%@AB@%                    return FALSE;%@NL@%
%@AB@%%@NL@%
%@AB@%                case IDL_DIR:%@NL@%
%@AB@%                    dbg( printf("LN_KILLFOCUS: IDL_DIR\n") );%@NL@%
%@AB@%                    hwndFocus = hwndLBDir;%@NL@%
%@AB@%                    WinSendMsg(hwndFocus, LM_SELECTITEM,%@NL@%
%@AB@%                            MPFROMSHORT(LIT_NONE), MPFROMSHORT(FALSE));%@NL@%
%@AB@%                    return FALSE;%@NL@%
%@AB@%%@NL@%
%@AB@%                case IDL_FILE:%@NL@%
%@AB@%                    dbg( printf("LN_KILLFOCUS: IDL_FILE\n") );%@NL@%
%@AB@%                    hwndFocus = hwndLBFile;%@NL@%
%@AB@%                    WinSendMsg(hwndFocus, LM_SELECTITEM,%@NL@%
%@AB@%                            MPFROMSHORT(LIT_NONE), MPFROMSHORT(FALSE));%@NL@%
%@AB@%                    return FALSE;%@NL@%
%@AB@%%@NL@%
%@AB@%                default:%@NL@%
%@AB@%                    dbg( printf("LN_KILLFOCUS: unknown list box = %04x\n",idLB) );%@NL@%
%@AB@%                    return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
%@AB@%                    break;%@NL@%
%@AB@%                }%@NL@%
%@AB@%                break;%@NL@%
%@AB@%%@NL@%
%@AB@%            default:%@NL@%
%@AB@%                dbg( printf("notify code= %04x\n",SHORT2FROMMP(mp1)) );%@NL@%
%@AB@%                return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
%@AB@%        }%@NL@%
%@AB@%        return FALSE;%@NL@%
%@AB@%%@NL@%
%@AB@%    default:%@NL@%
%@AB@%        return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
%@AB@%    }%@NL@%
%@AB@%    return FALSE;%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%BOOL        changeDrive(HWND hwndDlg, PFILECTL pfctl)%@NL@%
%@AB@%{%@NL@%
%@AB@%    USHORT  it;%@NL@%
%@AB@%    USHORT  drv;%@NL@%
%@AB@%    HWND    hwndLBDrive;%@NL@%
%@AB@%    HWND    hwndText;%@NL@%
%@AB@%%@NL@%
%@AB@%    hwndLBDrive = WinWindowFromID(hwndDlg, IDL_DRIVE);%@NL@%
%@AB@%    hwndText = WinWindowFromID(hwndDlg, IDC_TEXT);%@NL@%
%@AB@%%@NL@%
%@AB@%    it = SHORT1FROMMR(WinSendMsg(hwndLBDrive, LM_QUERYSELECTION, 0L, 0L));%@NL@%
%@AB@%    if (it != LIT_NONE) {%@NL@%
%@AB@%        itDrive = it;%@NL@%
%@AB@%        drv = SHORT1FROMMR(WinSendMsg(hwndLBDrive, // get drive number%@NL@%
%@AB@%                        LM_QUERYITEMHANDLE, MPFROMSHORT(it), 0L));%@NL@%
%@AB@%        DosSelectDisk(drv);                // change drive%@NL@%
%@AB@%        WinSetWindowText(hwndText, pfctl->pszPattern);        // reset pattern%@NL@%
%@AB@%        setDir(hwndDlg);                // update dir list%@NL@%
%@AB@%        setFile(hwndDlg);                // update file list%@NL@%
%@AB@%        setCurDir(hwndDlg);                // update current drive/dir text%@NL@%
%@AB@%        return TRUE;%@NL@%
%@AB@%    }%@NL@%
%@AB@%    return FALSE;%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%BOOL        changeDir(HWND hwndDlg, PFILECTL pfctl)%@NL@%
%@AB@%{%@NL@%
%@AB@%    char    ach[CCHMAXPATH];%@NL@%
%@AB@%    HWND    hwndLBDir;%@NL@%
%@AB@%    HWND    hwndText;%@NL@%
%@AB@%    USHORT  it;%@NL@%
%@AB@%%@NL@%
%@AB@%    hwndLBDir = WinWindowFromID(hwndDlg, IDL_DIR);%@NL@%
%@AB@%    hwndText = WinWindowFromID(hwndDlg, IDC_TEXT);%@NL@%
%@AB@%%@NL@%
%@AB@%    it = SHORT1FROMMR(WinSendMsg(hwndLBDir, LM_QUERYSELECTION, 0L, 0L));%@NL@%
%@AB@%    if (it != LIT_NONE) {%@NL@%
%@AB@%        itDir = it;%@NL@%
%@AB@%        WinSendMsg(hwndLBDir, LM_QUERYITEMTEXT, // get dir%@NL@%
%@AB@%                        MPFROM2SHORT(it,CCHMAXPATH), MPFROMP(ach));%@NL@%
%@AB@%        DosChDir(ach, 0L);%@NL@%
%@AB@%        WinSetWindowText(hwndText, pfctl->pszPattern);        // reset pattern%@NL@%
%@AB@%        setDir(hwndDlg);                // update dir list%@NL@%
%@AB@%        setFile(hwndDlg);                // update file list%@NL@%
%@AB@%        setCurDir(hwndDlg);                // update current drive/dir text%@NL@%
%@AB@%        return TRUE;%@NL@%
%@AB@%    }%@NL@%
%@AB@%    return FALSE;%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%BOOL        changeFile(HWND hwndDlg, PFILECTL pfctl)%@NL@%
%@AB@%{%@NL@%
%@AB@%    char    ach[CCHMAXPATH];%@NL@%
%@AB@%    HWND    hwndLBFile;%@NL@%
%@AB@%    HWND    hwndText;%@NL@%
%@AB@%    USHORT  it;%@NL@%
%@AB@%%@NL@%
%@AB@%    hwndText = WinWindowFromID(hwndDlg, IDC_TEXT);%@NL@%
%@AB@%    hwndLBFile = WinWindowFromID(hwndDlg, IDL_FILE);%@NL@%
%@AB@%%@NL@%
%@AB@%    it = SHORT1FROMMR(WinSendMsg(hwndLBFile, LM_QUERYSELECTION, 0L, 0L));%@NL@%
%@AB@%    if (it != LIT_NONE) {%@NL@%
%@AB@%        itFile = it;%@NL@%
%@AB@%        WinSendMsg(hwndLBFile, LM_QUERYITEMTEXT, // get dir%@NL@%
%@AB@%                        MPFROM2SHORT(it,CCHMAXPATH), MPFROMP(ach));%@NL@%
%@AB@%        WinSetWindowText(hwndText, ach);  // set file name%@NL@%
%@AB@%        return TRUE;%@NL@%
%@AB@%    }%@NL@%
%@AB@%    return FALSE;%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%BOOL        setDrive(HWND hwndDlg)%@NL@%
%@AB@%{%@NL@%
%@AB@%    char    ach[3];%@NL@%
%@AB@%    ULONG   bmlDrives;%@NL@%
%@AB@%    USHORT  drvCurrent;%@NL@%
%@AB@%    HWND    hwndLBDrive;%@NL@%
%@AB@%    USHORT  i;%@NL@%
%@AB@%    USHORT  us;%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%    hwndLBDrive = WinWindowFromID(hwndDlg, IDL_DRIVE);%@NL@%
%@AB@%%@NL@%
%@AB@%    if (DosQCurDisk(&drvCurrent,&bmlDrives) != 0) {%@NL@%
%@AB@%        dbg( printf("DosQCurDisk failed!\n") );%@NL@%
%@AB@%        return FALSE;%@NL@%
%@AB@%    }%@NL@%
%@AB@%    drvCurrent--;                        // 0-based drive number%@NL@%
%@AB@%%@NL@%
%@AB@%    ach[1] = ':';                        // init drive string%@NL@%
%@AB@%    ach[2] = '\0';%@NL@%
%@AB@%%@NL@%
%@AB@%    WinEnableWindowUpdate(hwndLBDrive,FALSE); // turn off list box updates%@NL@%
%@AB@%    WinSendMsg(hwndLBDrive, LM_DELETEALL, NULL, NULL); // delete old entries%@NL@%
%@AB@%%@NL@%
%@AB@%    for (i=0; bmlDrives != NULL; i++) { // get all 1 bits!%@NL@%
%@AB@%        if (bmlDrives & 1) {                // drive exists%@NL@%
%@AB@%            ach[0] = (char)(i + 'a');%@NL@%
%@AB@%            us = SHORT1FROMMR(WinSendMsg(hwndLBDrive, LM_INSERTITEM,%@NL@%
%@AB@%                    MPFROMSHORT(LIT_SORTASCENDING), MPFROMP(ach)));%@NL@%
%@AB@%            WinSendMsg(hwndLBDrive, LM_SETITEMHANDLE,         // set drive number%@NL@%
%@AB@%                MPFROMSHORT(us), MPFROMSHORT(i+1));%@NL@%
%@AB@%            if (i == drvCurrent) {%@NL@%
%@AB@%                itDrive = us;                // save index for selection%@NL@%
%@AB@%            }%@NL@%
%@AB@%        }%@NL@%
%@AB@%        bmlDrives >>= 1;                // get next drive bit in bit 0%@NL@%
%@AB@%    }%@NL@%
%@AB@%%@NL@%
%@AB@%    WinEnableWindowUpdate(hwndLBDrive,TRUE); // repaint list box%@NL@%
%@AB@%    return TRUE;%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%BOOL        setCurDir(HWND hwndDlg)%@NL@%
%@AB@%{%@NL@%
%@AB@%    char    ach[CCHMAXPATH];%@NL@%
%@AB@%    ULONG   bmlDrives;%@NL@%
%@AB@%    USHORT  cch;%@NL@%
%@AB@%    USHORT  drvCurrent;%@NL@%
%@AB@%    HWND    hwndCurDir;%@NL@%
%@AB@%    USHORT  rc;%@NL@%
%@AB@%%@NL@%
%@AB@%    rc = DosQCurDisk(&drvCurrent,&bmlDrives);        // get current drive%@NL@%
%@AB@%%@NL@%
%@AB@%    ach[0] = (char)((char)drvCurrent + 'a' - (char)1) ; // make drive letter%@NL@%
%@AB@%    ach[1] = ':';                        // rest of drive string%@NL@%
%@AB@%    ach[2] = '\\';%@NL@%
%@AB@%%@NL@%
%@AB@%    cch = CCHMAXPATH-3;                            // room for drive string%@NL@%
%@AB@%%@NL@%
%@AB@%    rc = DosQCurDir(drvCurrent, &ach[3], &cch);%@NL@%
%@AB@%%@NL@%
%@AB@%    hwndCurDir = WinWindowFromID(hwndDlg, IDC_CURDIR);%@NL@%
%@AB@%    WinSetWindowText(hwndCurDir,ach);        // set current drive/dir text%@NL@%
%@AB@%    return TRUE;%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%BOOL        setDir(HWND hwndDlg)%@NL@%
%@AB@%{%@NL@%
%@AB@%    char            ach[20];%@NL@%
%@AB@%    static USHORT   attr;%@NL@%
%@AB@%    USHORT            cch;%@NL@%
%@AB@%    HWND            hwndLBDir;%@NL@%
%@AB@%%@NL@%
%@AB@%    hwndLBDir  = WinWindowFromID(hwndDlg, IDL_DIR);%@NL@%
%@AB@%%@NL@%
%@AB@%    WinEnableWindowUpdate(hwndLBDir,FALSE); // turn off list box updates%@NL@%
%@AB@%    WinSendMsg(hwndLBDir, LM_DELETEALL, NULL, NULL); // delete old entries%@NL@%
%@AB@%%@NL@%
%@AB@%    // get all directories%@NL@%
%@AB@%%@NL@%
%@AB@%    strcpy(ach,"*.*");%@NL@%
%@AB@%    attr = 0x37;%@NL@%
%@AB@%    for (cch = beginSearch(ach,&attr);%@NL@%
%@AB@%         cch != 0;%@NL@%
%@AB@%         cch = nextSearch(ach,&attr)) {%@NL@%
%@AB@%        if (attr & 0x0010) {                // only get directories%@NL@%
%@AB@%        //  if ((cch > 1) || (ach[0] != '.')) { // do all but "."%@NL@%
%@AB@%                WinSendMsg(hwndLBDir, LM_INSERTITEM,%@NL@%
%@AB@%                    MPFROMSHORT(LIT_SORTASCENDING), MPFROMP(ach));%@NL@%
%@AB@%        //  }%@NL@%
%@AB@%        }%@NL@%
%@AB@%    }%@NL@%
%@AB@%    endSearch();%@NL@%
%@AB@%%@NL@%
%@AB@%    WinEnableWindowUpdate(hwndLBDir,TRUE); // repaint list box%@NL@%
%@AB@%    itDir = 1;%@NL@%
%@AB@%    return TRUE;%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%BOOL        setFile(HWND hwndDlg)%@NL@%
%@AB@%{%@NL@%
%@AB@%    char            ach[20];%@NL@%
%@AB@%    static USHORT   attr;%@NL@%
%@AB@%    USHORT            cch;%@NL@%
%@AB@%    HWND            hwndLBFile;%@NL@%
%@AB@%    HWND            hwndText;%@NL@%
%@AB@%%@NL@%
%@AB@%    hwndLBFile = WinWindowFromID(hwndDlg, IDL_FILE);%@NL@%
%@AB@%    hwndText   = WinWindowFromID(hwndDlg, IDC_TEXT);%@NL@%
%@AB@%%@NL@%
%@AB@%    WinEnableWindowUpdate(hwndLBFile,FALSE); // turn off list box updates%@NL@%
%@AB@%    WinSendMsg(hwndLBFile, LM_DELETEALL, NULL, NULL); // delete old entries%@NL@%
%@AB@%%@NL@%
%@AB@%    // get only files that match user's pattern%@NL@%
%@AB@%%@NL@%
%@AB@%    WinQueryWindowText(hwndText,CCHMAXPATH,ach);%@NL@%
%@AB@%    dbg( printf("file pattern = %s\n",ach) );%@NL@%
%@AB@%    attr = 0x27;                        // do all but directories%@NL@%
%@AB@%    for (cch = beginSearch(ach,&attr);%@NL@%
%@AB@%         cch != 0;%@NL@%
%@AB@%         cch = nextSearch(ach,&attr) ) {%@NL@%
%@AB@%        WinSendMsg(hwndLBFile, LM_INSERTITEM,%@NL@%
%@AB@%                MPFROMSHORT(LIT_SORTASCENDING), MPFROMP(ach));%@NL@%
%@AB@%%@NL@%
%@AB@%    }%@NL@%
%@AB@%    endSearch();%@NL@%
%@AB@%    WinEnableWindowUpdate(hwndLBFile,TRUE); // repaint list box%@NL@%
%@AB@%    itFile = 1;                            // default selection%@NL@%
%@AB@%%@NL@%
%@AB@%    return TRUE;%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%USHORT        beginSearch(char *psz, USHORT *pattr)%@NL@%
%@AB@%{%@NL@%
%@AB@%    FILEFINDBUF            findbuf;%@NL@%
%@AB@%    USHORT            cf;%@NL@%
%@AB@%    USHORT            rc;%@NL@%
%@AB@%%@NL@%
%@AB@%    cf = 1;                            // only return 1 file%@NL@%
%@AB@%    hdir = 0xFFFF;                    // create a search handle%@NL@%
%@AB@%%@NL@%
%@AB@%    rc = DosFindFirst(psz,            // file specification%@NL@%
%@AB@%                      &hdir,            // pointer to variable for handle%@NL@%
%@AB@%                      *pattr,            // search attribute (everything)%@NL@%
%@AB@%                      &findbuf,            // pointer to result buffer%@NL@%
%@AB@%                      sizeof(FILEFINDBUF), // length of result buffer%@NL@%
%@AB@%                      &cf,            // files to find/files found%@NL@%
%@AB@%                      0L);            // Must be zero%@NL@%
%@AB@%%@NL@%
%@AB@%    if (cf != 0) {%@NL@%
%@AB@%        psz[findbuf.cchName] = '\0';        // terminate name%@NL@%
%@AB@%        strncpy(psz,findbuf.achName,findbuf.cchName); // copy name to caller%@NL@%
%@AB@%        *pattr = findbuf.attrFile;%@NL@%
%@AB@%        return findbuf.cchName;%@NL@%
%@AB@%    }%@NL@%
%@AB@%    return 0;%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%USHORT        nextSearch(char *psz, USHORT *pattr)%@NL@%
%@AB@%{%@NL@%
%@AB@%    FILEFINDBUF            findbuf;%@NL@%
%@AB@%    USHORT            cf;%@NL@%
%@AB@%    USHORT            rc;%@NL@%
%@AB@%%@NL@%
%@AB@%    cf = 1;            // only return 1 file%@NL@%
%@AB@%%@NL@%
%@AB@%    rc = DosFindNext(hdir,            // pointer to variable for handle%@NL@%
%@AB@%                     &findbuf,            // pointer to result buffer%@NL@%
%@AB@%                     sizeof(FILEFINDBUF), // length of result buffer%@NL@%
%@AB@%                     &cf);            // files to find/files found%@NL@%
%@AB@%%@NL@%
%@AB@%    if (cf != 0) {%@NL@%
%@AB@%        psz[findbuf.cchName] = '\0'; // terminate name%@NL@%
%@AB@%        strncpy(psz,findbuf.achName,findbuf.cchName); // copy name to caller%@NL@%
%@AB@%        *pattr = findbuf.attrFile;%@NL@%
%@AB@%        return findbuf.cchName;%@NL@%
%@AB@%    }%@NL@%
%@AB@%    return 0;%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%void        endSearch(void)%@NL@%
%@AB@%{%@NL@%
%@AB@%    DosFindClose(hdir);%@NL@%
%@AB@%}%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%/***        trimBlanks - trim off leading and trailing blanks%@NL@%
%@AB@%*%@NL@%
%@AB@%*        ENTRY        psz - string to be trimmed%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
char * trimBlanks(char *psz)%@NL@%
{%@NL@%
    char *pch;%@NL@%
    char *pchDst;%@NL@%
    char *pchRight;%@NL@%
%@NL@%
    //        Find right-most non-blank character%@NL@%
%@NL@%
    for (pch = psz+strlen(psz)-1;        // start at last character%@NL@%
         (pch >= psz) && (*pch == ' '); // scan backward to non-blank%@NL@%
        pch--)%@NL@%
            ;%@NL@%
%@NL@%
    *(pch+1) = '\0';                        // trim trailing blanks%@NL@%
%@NL@%
    pchRight = pch;%@NL@%
%@NL@%
    // Find left-most non-blank character%@NL@%
%@NL@%
    for (pch = psz;                        // start at first character%@NL@%
         (pch <= pchRight) && (*pch == ' '); // scan forward to non-blank%@NL@%
         pch++)%@NL@%
            ;%@NL@%
%@NL@%
    // Shift string left to trim leading blanks%@NL@%
%@NL@%
    if (pch > psz) {                        // leading blanks to trim%@NL@%
        pchRight++;                        // grab traling null%@NL@%
        pchDst = psz;                        // do not destroy psz%@NL@%
        while (pchDst <= pchRight)%@NL@%
            *pchDst++ = *pch++;                // shift string left%@NL@%
    }%@NL@%
    return psz;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FILE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\OPENDLG\FILE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    FILE.C -- Open/Save As Dialog Box library routines%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@% INCL_DOS %@NL@%
%@AI@%#define %@AE@% INCL_DOSQUEUES %@NL@%
%@AI@%#include %@AE@%"tool.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function is the Open dialog box window procedure.  It handles input,%@NL@%
%@AB@%* allows the user to change directories, checks for legal filenames, opens%@NL@%
%@AB@%* specified files, appends default extensions and returns the file's name.%@NL@%
%@AB@%*%@NL@%
%@AB@%* The return values are%@NL@%
%@AB@%*   TDF_INVALID - Library error (internal error),%@NL@%
%@AB@%*   TDF_NOOPEN  - User hits cancel%@NL@%
%@AB@%*   TDF_NEWOPEN - Created new file (file left open)%@NL@%
%@AB@%*   TDF_OLDOPEN - Opened existing file (file left open)%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY DlgOpenWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
    {%@NL@%
    PDLF pdlf;%@NL@%
    PSZ  lpchFile;%@NL@%
    CHAR sz[MAX_FNAME_LEN];%@NL@%
%@NL@%
    switch (msg)%@NL@%
        {%@NL@%
    case WM_INITDLG:%@NL@%
        %@AB@%/* initialize dialog box */%@AE@%%@NL@%
        DlgInitOpen(hwnd, LONGFROMMP(mp2));%@NL@%
%@NL@%
        %@AB@%/* fill static field with path name and fill list box with%@NL@%
%@AB@%           filenames that lMatch spec */%@AE@%%@NL@%
        if (!DlgDirList(hwnd, ((PDLF)(mp2))->pszExt+1, ID_DIRLIST,%@NL@%
                        ID_FILELIST, ID_PATH, ((PDLF)(mp2))->rgbFlags))%@NL@%
            %@AB@%/* NOTE: shouldn't we post a message if something screws up? */%@AE@%%@NL@%
            WinDismissDlg(hwnd, TDF_INVALID);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        pdlf = (PDLF) WinQueryWindowULong(hwnd, 0);%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
            {%@NL@%
        case MBID_OK:%@NL@%
            %@AB@%/* Open button pressed */%@AE@%%@NL@%
            %@AB@%/* get name from edit box */%@AE@%%@NL@%
            WinQueryWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                CBROOTNAMEMAX, (PSZ)pdlf->szFileName);%@NL@%
            Upper((PSZ)pdlf->szFileName);%@NL@%
            if (lstrlen((PSZ)pdlf->szFileName))%@NL@%
                DlgOpenName(hwnd, pdlf);%@NL@%
            break;%@NL@%
%@NL@%
        case MBID_CANCEL:%@NL@%
            %@AB@%/* Cancel button pressed, dismiss dialog box */%@AE@%%@NL@%
            WinDismissDlg(hwnd, TDF_NOOPEN);%@NL@%
            break;%@NL@%
%@NL@%
        case MBID_HELP:%@NL@%
            %@AB@%/* Help button pressed */%@AE@%%@NL@%
            WinMessageBox( HWND_DESKTOP%@NL@%
                         , hwnd%@NL@%
                         , pdlf->pszInstructions%@NL@%
                         , pdlf->pszTitle%@NL@%
                         , NULL%@NL@%
                         , MB_OK | MB_APPLMODAL );%@NL@%
            break;%@NL@%
            }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CONTROL:%@NL@%
        pdlf = (PDLF) WinQueryWindowULong(hwnd, 0);%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
            {%@NL@%
        case ID_DIRLIST:%@NL@%
            %@AB@%/* user clicked in directory list box */%@AE@%%@NL@%
            switch (SHORT2FROMMP(mp1))%@NL@%
                {%@NL@%
            case LN_SELECT:%@NL@%
                %@AB@%/* single click case */%@AE@%%@NL@%
                %@AB@%/* get current edit string */%@AE@%%@NL@%
                WinQueryWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                                   CBROOTNAMEMAX, (PSZ)sz);%@NL@%
                Upper((PSZ)sz);%@NL@%
%@NL@%
                %@AB@%/* get selected string */%@AE@%%@NL@%
                if (DlgDirSelect(hwnd, (PSZ)pdlf->szFileName, ID_DIRLIST))%@NL@%
                    {%@NL@%
                    %@AB@%/* if edit field contains wild card, then append file%@NL@%
%@AB@%                       part to selected directory, otherwise append%@NL@%
%@AB@%                       last wildcard search spec */%@AE@%%@NL@%
                    lpchFile = FileInPath((PSZ)sz);%@NL@%
                    lstrcat( (PSZ)pdlf->szFileName%@NL@%
                           , DlgSearchSpec( lpchFile)%@NL@%
                             ? lpchFile%@NL@%
                             : (PSZ)pdlf->szLastWild );%@NL@%
                    %@AB@%/* set edit box to resulting name */%@AE@%%@NL@%
                    WinSetWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                                     (PSZ)pdlf->szFileName);%@NL@%
                    }%@NL@%
                break;%@NL@%
%@NL@%
            case LN_ENTER:%@NL@%
                %@AB@%/* get text from edit box */%@AE@%%@NL@%
                WinQueryWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                                   CBROOTNAMEMAX, (PSZ)pdlf->szFileName);%@NL@%
                Upper((PSZ)pdlf->szFileName);%@NL@%
                if( DlgSearchSpec( (PSZ)pdlf->szFileName))%@NL@%
                    {%@NL@%
                    DlgDirList( hwnd%@NL@%
                              , (PSZ)pdlf->szFileName%@NL@%
                              , ID_DIRLIST%@NL@%
                              , ID_FILELIST%@NL@%
                              , ID_PATH%@NL@%
                              , pdlf->rgbFlags );%@NL@%
                    lstrcpy( (PSZ)pdlf->szLastWild%@NL@%
                           , FileInPath( (PSZ)pdlf->szFileName));%@NL@%
                    WinSetWindowText( WinWindowFromID( hwnd, ID_EDIT)%@NL@%
                                    , (PSZ)pdlf->szFileName );%@NL@%
                    }%@NL@%
                break;%@NL@%
                }%@NL@%
            break;%@NL@%
%@NL@%
        case ID_FILELIST:%@NL@%
            %@AB@%/* user clicked in file list box */%@AE@%%@NL@%
            switch (SHORT2FROMMP(mp1))%@NL@%
                {%@NL@%
            case LN_SELECT:%@NL@%
                %@AB@%/* single click case */%@AE@%%@NL@%
%@NL@%
                %@AB@%/* get current edit string */%@AE@%%@NL@%
                %@AB@%/* if it contains a wildcard, save it before obliteration */%@AE@%%@NL@%
                WinQueryWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                                   CBROOTNAMEMAX, (PSZ)sz);%@NL@%
                Upper((PSZ)sz);%@NL@%
                if( DlgSearchSpec( (PSZ)sz))%@NL@%
                    lstrcpy( (PSZ)pdlf->szLastWild, FileInPath( (PSZ)sz));%@NL@%
%@NL@%
                %@AB@%/* get selected file name */%@AE@%%@NL@%
                DlgDirSelect(hwnd, (PSZ)pdlf->szFileName, ID_FILELIST);%@NL@%
                %@AB@%/* set edit box to resulting name */%@AE@%%@NL@%
                WinSetWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                                 (PSZ)pdlf->szFileName);%@NL@%
                break;%@NL@%
%@NL@%
            case LN_ENTER:%@NL@%
                %@AB@%/* double click case, single click already processed */%@AE@%%@NL@%
                DlgOpenName(hwnd, pdlf);%@NL@%
                break;%@NL@%
                }%@NL@%
            break;%@NL@%
            }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        }%@NL@%
%@NL@%
    return (MRFROMLONG(0L));  %@AB@%/* message processed */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function stores the pdlf in the dialog window structure, sets%@NL@%
%@AB@%* the title and instruction texts and limits the text size.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID PASCAL DlgInitOpen (hwnd, lpParm)%@NL@%
HWND hwnd;%@NL@%
ULONG lpParm;%@NL@%
    {%@NL@%
    PDLF pdlf;%@NL@%
%@NL@%
    %@AB@%/* Set pdlf local to window */%@AE@%%@NL@%
    pdlf = (PDLF) lpParm;%@NL@%
    WinSetWindowULong(hwnd, 0, lpParm);%@NL@%
%@NL@%
    %@AB@%/* set edit box text size limit */%@AE@%%@NL@%
    WinSendDlgItemMsg(hwnd, ID_EDIT, EM_SETTEXTLIMIT, (MPARAM)CBROOTNAMEMAX, 0L);%@NL@%
%@NL@%
    %@AB@%/* set edit window to search spec */%@AE@%%@NL@%
    if (pdlf->pszExt != (PSZ)NULL)%@NL@%
        WinSetWindowText(WinWindowFromID(hwnd, ID_EDIT), pdlf->pszExt+1);%@NL@%
%@NL@%
    %@AB@%/* set title window */%@AE@%%@NL@%
    if (pdlf->pszTitle != (PSZ)NULL)%@NL@%
        WinSetWindowText(WinWindowFromID(hwnd, FID_TITLEBAR), pdlf->pszTitle);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function processes the currently selected name in the open dialog%@NL@%
%@AB@%* box.  If the name represents a directory, the current directory is%@NL@%
%@AB@%* changed to that one and the corresponding files are displayed.  If the%@NL@%
%@AB@%* name is a file, then it is opened.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID PASCAL DlgOpenName(hwnd, pdlf)%@NL@%
HWND hwnd;%@NL@%
PDLF pdlf;%@NL@%
    {%@NL@%
    PSZ  lpch;%@NL@%
    USHORT wVal;%@NL@%
    CHAR sz[MAX_FNAME_LEN];%@NL@%
%@NL@%
    %@AB@%/* try using current name as a directory */%@AE@%%@NL@%
    lstrcpy((PSZ)sz, (PSZ)pdlf->szFileName);%@NL@%
    if (!DlgSearchSpec((PSZ)sz))%@NL@%
        DlgAddSearchExt(pdlf, (PSZ)sz);%@NL@%
    if (DlgDirList(hwnd, (PSZ)sz, ID_DIRLIST, ID_FILELIST, ID_PATH,%@NL@%
                   pdlf->rgbFlags))%@NL@%
        {%@NL@%
        %@AB@%/* name was a directory, extract and set file name */%@AE@%%@NL@%
        lpch = FileInPath((PSZ)sz);%@NL@%
        lstrcpy((PSZ)pdlf->szFileName, lpch);%@NL@%
        WinSetWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                         (PSZ)pdlf->szFileName);%@NL@%
        }%@NL@%
    else%@NL@%
        %@AB@%/* try to open name as a file */%@AE@%%@NL@%
        if ((wVal = DlgOpenFile(pdlf, hwnd)) != TDF_NOOPEN)%@NL@%
            WinDismissDlg(hwnd, wVal);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function is the SaveAs dialog box window procedure.  It handles input,%@NL@%
%@AB@%* tests for legal filenames and uses message boxes to report any problems.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Return values are:%@NL@%
%@AB@%*     TDF_INVALID - Library error (internal error),%@NL@%
%@AB@%*     TDF_NOOPEN  - User hits cancel%@NL@%
%@AB@%*   Specific for DLG_NOOPEN%@NL@%
%@AB@%*     TDF_NEWSAVE - user wants to save to a new file (file not created)%@NL@%
%@AB@%*     TDF_OLDSAVE - user wants to save over existing file (file not opened)%@NL@%
%@AB@%*   else%@NL@%
%@AB@%*     TDF_NEWSAVE - user wants to save to a new file (file left open)%@NL@%
%@AB@%*     TDF_OLDSAVE - user wants to save over existing file (file left open)%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY DlgSaveAsWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND   hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
    {%@NL@%
    PDLF    pdlf;%@NL@%
    PSZ     lpchFile;%@NL@%
    CHAR    sz[MAX_FNAME_LEN];%@NL@%
%@NL@%
    switch (msg)%@NL@%
        {%@NL@%
    case WM_INITDLG:%@NL@%
        %@AB@%/* Store pdlf, set instructions, limit text size */%@AE@%%@NL@%
        DlgInitSaveAs(hwnd, LONGFROMMP(mp2));%@NL@%
%@NL@%
        %@AB@%/* fill static field with path name and fill list box with%@NL@%
%@AB@%           filenames that lMatch spec */%@AE@%%@NL@%
        if (!DlgDirList(hwnd, ((PDLF)(mp2))->pszExt+1, ID_DIRLIST,%@NL@%
                        ID_FILELIST, ID_PATH, ((PDLF)(mp2))->rgbFlags))%@NL@%
            %@AB@%/* NOTE: shouldn't we post a message if something screws up? */%@AE@%%@NL@%
            WinDismissDlg(hwnd, TDF_INVALID);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        pdlf = (PDLF) WinQueryWindowULong(hwnd, 0);%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
           {%@NL@%
        case MBID_OK:%@NL@%
            %@AB@%/* get text from edit box */%@AE@%%@NL@%
            WinQueryWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                               CBROOTNAMEMAX, (PSZ)pdlf->szFileName);%@NL@%
            Upper((PSZ)pdlf->szFileName);%@NL@%
            if( DlgSearchSpec( (PSZ)pdlf->szFileName))%@NL@%
                {%@NL@%
                DlgDirList( hwnd%@NL@%
                          , (PSZ)pdlf->szFileName%@NL@%
                          , ID_DIRLIST%@NL@%
                          , ID_FILELIST%@NL@%
                          , ID_PATH%@NL@%
                          , pdlf->rgbFlags );%@NL@%
                lstrcpy( (PSZ)pdlf->szLastWild%@NL@%
                       , FileInPath( (PSZ)pdlf->szFileName));%@NL@%
                lstrcpy( (PSZ)pdlf->szFileName, (PSZ)pdlf->szLastFile);%@NL@%
                WinSetWindowText( WinWindowFromID( hwnd, ID_EDIT)%@NL@%
                                , (PSZ)pdlf->szFileName );%@NL@%
                }%@NL@%
            else if( lstrlen( (PSZ)pdlf->szFileName))%@NL@%
                DlgSaveAsName( hwnd, pdlf);%@NL@%
            break;%@NL@%
%@NL@%
        case MBID_CANCEL:%@NL@%
            WinDismissDlg(hwnd, TDF_NOSAVE);%@NL@%
            break;%@NL@%
%@NL@%
        case MBID_HELP:%@NL@%
            %@AB@%/* Help button pressed */%@AE@%%@NL@%
            WinMessageBox( HWND_DESKTOP%@NL@%
                         , hwnd%@NL@%
                         , pdlf->pszInstructions%@NL@%
                         , pdlf->pszTitle%@NL@%
                         , NULL%@NL@%
                         , MB_OK | MB_APPLMODAL );%@NL@%
            break;%@NL@%
            }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CONTROL:%@NL@%
        pdlf = (PDLF) WinQueryWindowULong(hwnd, 0);%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
            {%@NL@%
        case ID_DIRLIST:%@NL@%
            %@AB@%/* user clicked in directory list box */%@AE@%%@NL@%
            switch (SHORT2FROMMP(mp1))%@NL@%
                {%@NL@%
            case LN_SELECT:%@NL@%
                %@AB@%/* single click case */%@AE@%%@NL@%
                %@AB@%/* get current edit string */%@AE@%%@NL@%
                WinQueryWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                                   CBROOTNAMEMAX, (PSZ)sz);%@NL@%
                Upper((PSZ)sz);%@NL@%
%@NL@%
                %@AB@%/* get selected string */%@AE@%%@NL@%
                if (DlgDirSelect(hwnd, (PSZ)pdlf->szFileName, ID_DIRLIST))%@NL@%
                    {%@NL@%
                    %@AB@%/* if edit field contains wild card, then append file%@NL@%
%@AB@%                       part to selected directory, otherwise append%@NL@%
%@AB@%                       last wildcard search spec */%@AE@%%@NL@%
                    lpchFile = FileInPath((PSZ)sz);%@NL@%
                    if( DlgSearchSpec( lpchFile))%@NL@%
                        {%@NL@%
                        lstrcat( (PSZ)pdlf->szFileName, lpchFile );%@NL@%
                        lstrcpy( (PSZ)pdlf->szLastWild, lpchFile);%@NL@%
                        }%@NL@%
                    else%@NL@%
                        {%@NL@%
                        lstrcat( (PSZ)pdlf->szFileName, (PSZ)pdlf->szLastWild );%@NL@%
                        lstrcpy( (PSZ)pdlf->szLastFile, lpchFile);%@NL@%
                        }%@NL@%
                    %@AB@%/* set edit box to resulting name */%@AE@%%@NL@%
                    WinSetWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                                     (PSZ)pdlf->szFileName);%@NL@%
                    }%@NL@%
                break;%@NL@%
%@NL@%
            case LN_ENTER:%@NL@%
                %@AB@%/* get text from edit box */%@AE@%%@NL@%
                WinQueryWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                                   CBROOTNAMEMAX, (PSZ)pdlf->szFileName);%@NL@%
                Upper((PSZ)pdlf->szFileName);%@NL@%
                if( DlgSearchSpec( (PSZ)pdlf->szFileName))%@NL@%
                    {%@NL@%
                    DlgDirList( hwnd%@NL@%
                              , (PSZ)pdlf->szFileName%@NL@%
                              , ID_DIRLIST%@NL@%
                              , ID_FILELIST%@NL@%
                              , ID_PATH%@NL@%
                              , pdlf->rgbFlags );%@NL@%
                    lstrcpy( (PSZ)pdlf->szLastWild%@NL@%
                           , FileInPath( (PSZ)pdlf->szFileName));%@NL@%
                    lstrcpy( (PSZ)pdlf->szFileName, (PSZ)pdlf->szLastFile);%@NL@%
                    WinSetWindowText( WinWindowFromID( hwnd, ID_EDIT)%@NL@%
                                    , (PSZ)pdlf->szFileName );%@NL@%
                    }%@NL@%
                break;%@NL@%
                }%@NL@%
            break;%@NL@%
%@NL@%
        case ID_FILELIST:%@NL@%
            %@AB@%/* user clicked in file list box */%@AE@%%@NL@%
            switch (SHORT2FROMMP(mp1))%@NL@%
                {%@NL@%
            case LN_SELECT:%@NL@%
                %@AB@%/* single click case */%@AE@%%@NL@%
%@NL@%
                %@AB@%/* get current edit string */%@AE@%%@NL@%
                %@AB@%/* if it contains a wildcard, save it before obliteration */%@AE@%%@NL@%
                WinQueryWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                                   CBROOTNAMEMAX, (PSZ)sz);%@NL@%
                Upper((PSZ)sz);%@NL@%
                if( DlgSearchSpec( (PSZ)sz))%@NL@%
                    lstrcpy( (PSZ)pdlf->szLastWild, FileInPath( (PSZ)sz));%@NL@%
%@NL@%
                %@AB@%/* get selected file name */%@AE@%%@NL@%
                DlgDirSelect(hwnd, (PSZ)pdlf->szFileName, ID_FILELIST);%@NL@%
                %@AB@%/* set edit box to resulting name */%@AE@%%@NL@%
                WinSetWindowText(WinWindowFromID(hwnd, ID_EDIT),%@NL@%
                                 (PSZ)pdlf->szFileName);%@NL@%
                break;%@NL@%
%@NL@%
            case LN_ENTER:%@NL@%
                %@AB@%/* double click case, single click already processed */%@AE@%%@NL@%
                DlgSaveAsName(hwnd, pdlf);%@NL@%
                break;%@NL@%
                }%@NL@%
            break;%@NL@%
            }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        }%@NL@%
%@NL@%
    return (MRFROMLONG(0L));    %@AB@%/* message processed */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/* This function attempts to open a file for writing.  It queries if over-    */%@AE@%%@NL@%
%@AB@%/* write is OK if the file already exists.                                      */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID PASCAL DlgSaveAsName( hwnd, pdlf)%@NL@%
HWND  hwnd;%@NL@%
PDLF  pdlf;%@NL@%
    {%@NL@%
    USHORT  usTdf;%@NL@%
%@NL@%
    %@AB@%/* add extension if there is not one already */%@AE@%%@NL@%
    AddExt((PSZ)pdlf->szFileName, pdlf->pszExt);%@NL@%
    %@AB@%/* test file name legality */%@AE@%%@NL@%
    if (!DlgParseFile((PSZ)pdlf->szFileName,%@NL@%
                      (PSZ)pdlf->szOpenFile, FALSE, FALSE))%@NL@%
        {%@NL@%
        %@AB@%/* illegal filename */%@AE@%%@NL@%
        DlgAlertBox(hwnd, IDS_IFN, pdlf,%@NL@%
                    MB_OK | MB_ICONEXCLAMATION);%@NL@%
        return;%@NL@%
        }%@NL@%
    usTdf = TDF_NEWSAVE;%@NL@%
    %@AB@%/* test if file already exists */%@AE@%%@NL@%
    if (DlgParseFile((PSZ)pdlf->szFileName,%@NL@%
                     (PSZ)pdlf->szOpenFile, TRUE, FALSE))%@NL@%
        {%@NL@%
        %@AB@%/* overwrite? */%@AE@%%@NL@%
        if (DlgAlertBox(hwnd, IDS_REF, pdlf,%@NL@%
                        MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION)%@NL@%
            == MBID_NO)%@NL@%
            return;%@NL@%
        usTdf = TDF_OLDSAVE;%@NL@%
        }%@NL@%
    if (!(pdlf->rgbAction & DLG_NOOPEN) &&%@NL@%
        !(OpenFile( (PSZ)pdlf->szFileName%@NL@%
                  , pdlf->phFile%@NL@%
                  , (PSZ)pdlf->szOpenFile%@NL@%
                  , OF_WRITE)))%@NL@%
        {%@NL@%
        DlgAlertBox(hwnd, IDS_EOF, pdlf,%@NL@%
                    MB_OK | MB_ICONEXCLAMATION);%@NL@%
        return;%@NL@%
        }%@NL@%
    WinDismissDlg(hwnd, usTdf);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function initializes the SaveAs dialog box.  It puts the current%@NL@%
%@AB@%* directory string in the ID_PATH field and initializes the edit box%@NL@%
%@AB@%* with the proposed filename.  It is the simple relative file name if current%@NL@%
%@AB@%* dir == pdlf->szOpenFile.  Otherwise, it is the fully qualified name.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID PASCAL DlgInitSaveAs (hwnd, lpParm)%@NL@%
HWND hwnd;%@NL@%
ULONG lpParm;%@NL@%
    {%@NL@%
    PDLF pdlf;%@NL@%
    CHAR sz[MAX_FNAME_LEN];%@NL@%
    PSZ  lpszFile, lpszFN, lpszCD;%@NL@%
%@NL@%
    %@AB@%/* set pdlf local to window */%@AE@%%@NL@%
    pdlf = (PDLF) lpParm;%@NL@%
    WinSetWindowULong(hwnd, 0, lpParm);%@NL@%
%@NL@%
    %@AB@%/* set edit box text size limit */%@AE@%%@NL@%
    WinSendDlgItemMsg(hwnd, ID_EDIT, EM_SETTEXTLIMIT, (MPARAM)CBROOTNAMEMAX, 0L);%@NL@%
%@NL@%
    %@AB@%/* set title window */%@AE@%%@NL@%
    if (pdlf->pszTitle != (PSZ)NULL)%@NL@%
        WinSetWindowText(WinWindowFromID(hwnd, FID_TITLEBAR), pdlf->pszTitle);%@NL@%
%@NL@%
    %@AB@%/* set szLastWild to search spec */%@AE@%%@NL@%
    if (pdlf->pszExt != (PSZ)NULL)%@NL@%
        lstrcpy( (PSZ)pdlf->szLastWild, (PSZ)pdlf->pszExt+1 );%@NL@%
%@NL@%
    %@AB@%/* get current directory */%@AE@%%@NL@%
    DosSearchPath(0, (PSZ)szDot, (PSZ)szStarStar, (PSZ)sz, MAX_FNAME_LEN);%@NL@%
    lpszFile = FileInPath((PSZ)sz);%@NL@%
    if (lpszFile > (PSZ)sz + 3)%@NL@%
        lpszFile--;%@NL@%
    *lpszFile = '\0';%@NL@%
%@NL@%
    %@AB@%/* compare path part name to previously opened file name and%@NL@%
%@AB@%       make the file name relative if they are the same */%@AE@%%@NL@%
    lpszFN = (PSZ)pdlf->szOpenFile;%@NL@%
    lpszCD = (PSZ)sz;%@NL@%
    lpszFile = FileInPath((PSZ)pdlf->szOpenFile);%@NL@%
    while (lpszFN < lpszFile && *lpszFN == *lpszCD)%@NL@%
        {%@NL@%
        lpszFN = NextChar(lpszFN);%@NL@%
        lpszCD = NextChar(lpszCD);%@NL@%
        }%@NL@%
    if (*lpszCD)%@NL@%
        lpszFN = (PSZ)pdlf->szOpenFile;%@NL@%
    else if (*lpszFN == '\\')%@NL@%
        lpszFN = NextChar(lpszFN);%@NL@%
    Upper( lpszFN);%@NL@%
    WinSetWindowText(WinWindowFromID(hwnd, ID_EDIT), lpszFN);%@NL@%
    lstrcpy( (PSZ)pdlf->szLastFile, lpszFN);%@NL@%
%@NL@%
    %@AB@%/* set current path field */%@AE@%%@NL@%
    WinSetWindowText(WinWindowFromID(hwnd, ID_PATH),%@NL@%
                     DlgFitPathToBox(hwnd, ID_PATH, (PSZ)sz));%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function returns the filename part of the given path string.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
PSZ  EXPENTRY FileInPath(lpsz)%@NL@%
PSZ  lpsz;%@NL@%
    {%@NL@%
    PSZ  lpch;%@NL@%
%@NL@%
    %@AB@%/* strip path/drive specification from name if there is one */%@AE@%%@NL@%
    lpch = lpsz + lstrlen(lpsz);%@NL@%
    while (lpch > lpsz)%@NL@%
        {%@NL@%
        lpch = PrevChar(lpsz, lpch);%@NL@%
        if (*lpch == '\\' || *lpch == ':')%@NL@%
            {%@NL@%
            lpch = NextChar(lpch);%@NL@%
            break;%@NL@%
            }%@NL@%
        }%@NL@%
    return(lpch);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function adds the extension to a file name if it is missing.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID EXPENTRY AddExt(lpsz, lpszExt)%@NL@%
PSZ  lpsz;%@NL@%
PSZ  lpszExt;%@NL@%
    {%@NL@%
    PSZ  lpch;%@NL@%
%@NL@%
    lpch = lpsz + lstrlen(lpsz);%@NL@%
    while (*lpch != '.' && *lpch != '\\' && *lpch != ':' && lpch > lpsz)%@NL@%
        lpch = PrevChar(lpsz, lpch);%@NL@%
%@NL@%
    if (*lpch != '.')%@NL@%
        lstrcat(lpsz, (PSZ)(lpszExt+2));%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function adds the "appropriate" extension to a filename, partial%@NL@%
%@AB@%* filename, search spec or partial search spec.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID PASCAL DlgAddSearchExt(pdlf, lpszEdit)%@NL@%
PDLF pdlf;%@NL@%
PSZ  lpszEdit;%@NL@%
    {%@NL@%
    PSZ  lpchLast;%@NL@%
%@NL@%
    lpchLast = PrevChar(lpszEdit, lpszEdit + lstrlen(lpszEdit));%@NL@%
    if (*lpchLast == '\\' || *lpchLast == ':')%@NL@%
        lstrcat(lpszEdit, pdlf->pszExt + 1);%@NL@%
    else%@NL@%
        lstrcat(lpszEdit, pdlf->pszExt);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function returns TRUE if lpsz contains a wildcard character '*' or '?';%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL PASCAL DlgSearchSpec(lpsz)%@NL@%
PSZ  lpsz;%@NL@%
   {%@NL@%
    for (; *lpsz; lpsz = NextChar(lpsz))%@NL@%
        if (*lpsz == '*' || *lpsz == '?')%@NL@%
            return TRUE;%@NL@%
    return FALSE;%@NL@%
   }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function displays an error or warning msg.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
int PASCAL DlgAlertBox(hwnd, ids, pdlf, wStyle)%@NL@%
HWND hwnd;%@NL@%
int ids;%@NL@%
PDLF pdlf;%@NL@%
USHORT wStyle;%@NL@%
    {%@NL@%
    %@AB@%/* note:  5th param is idHelp */%@AE@%%@NL@%
    return (AlertBox(hwnd, ids, (PSZ)pdlf->szFileName, pdlf->pszAppName,%@NL@%
                         NULL, wStyle | MB_APPLMODAL));%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FILE1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\OPENDLG\FILE1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    FILE1.C -- Dialog Directory Listbox and Open File functions%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@% INCL_DOS %@NL@%
%@AI@%#include %@AE@%"tool.h" %@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function builds a directory list in a list box.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
int FAR PASCAL DlgDirList(hwnd, lpszPath, idDirList, idFileList,%@NL@%
                          idStaticPath, attr)%@NL@%
HWND hwnd;%@NL@%
PSZ  lpszPath;%@NL@%
int idDirList;%@NL@%
int idFileList;%@NL@%
int idStaticPath;%@NL@%
USHORT attr;%@NL@%
    {%@NL@%
    CHAR szPath[MAX_FNAME_LEN];%@NL@%
    CHAR chTmp;%@NL@%
    PSZ  lpszFile, lpszNull;%@NL@%
    HPOINTER hPointer;%@NL@%
%@NL@%
    %@AB@%/* ensure path is legal and expand to full search path */%@AE@%%@NL@%
    if (!DlgParseFile(lpszPath, (PSZ)szPath, FALSE, TRUE))%@NL@%
        return FALSE;%@NL@%
%@NL@%
    %@AB@%/* set pointer to hours glass */%@AE@%%@NL@%
    hPointer = WinQueryPointer(HWND_DESKTOP); %@NL@%
    WinSetPointer(HWND_DESKTOP, WinQuerySysPointer(HWND_DESKTOP, SPTR_WAIT, FALSE));%@NL@%
%@NL@%
    %@AB@%/* set current drive */%@AE@%%@NL@%
    DosSelectDisk(*szPath - 'A' + 1);%@NL@%
%@NL@%
    %@AB@%/* temporarily put zero after directory spec and set current directory */%@AE@%%@NL@%
    lpszFile = FileInPath((PSZ)szPath);%@NL@%
    lpszNull = lpszFile;%@NL@%
    if (lpszNull > (PSZ)szPath + 3)%@NL@%
        lpszNull--;%@NL@%
    chTmp = *lpszNull;%@NL@%
    *lpszNull = '\0';%@NL@%
    DosChDir((PSZ)szPath, 0l);%@NL@%
    if (idStaticPath)%@NL@%
        WinSetWindowText(WinWindowFromID(hwnd, idStaticPath),%@NL@%
                         DlgFitPathToBox(hwnd, idStaticPath, (PSZ)szPath));%@NL@%
    *lpszNull = chTmp;%@NL@%
%@NL@%
    %@AB@%/* fill list box with file names */%@AE@%%@NL@%
    if (idDirList && idFileList)%@NL@%
        {%@NL@%
        %@AB@%/* fill them up with new entries */%@AE@%%@NL@%
        DlgFillListBoxes(hwnd, idDirList, idFileList, attr, lpszFile);%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/* reset pointer to previous figure */%@AE@%%@NL@%
    WinSetPointer(HWND_DESKTOP, hPointer);%@NL@%
%@NL@%
    return TRUE;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function gets the file name selected by the user.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
int FAR PASCAL DlgDirSelect(hwnd, lpszIn, idListBox)%@NL@%
HWND hwnd;%@NL@%
PSZ  lpszIn;%@NL@%
int idListBox;%@NL@%
    {%@NL@%
    CHAR sz[MAX_FNAME_LEN];%@NL@%
    int item;%@NL@%
    PSZ  lpsz, lpszFile;%@NL@%
    BOOL fDir;%@NL@%
%@NL@%
    %@AB@%/* get currently selected list entry */%@AE@%%@NL@%
    item = (int) SHORT1FROMMR(WinSendDlgItemMsg(hwnd, idListBox, LM_QUERYSELECTION, 0L, 0L));%@NL@%
    if (item == LIT_NONE)%@NL@%
        return FALSE;%@NL@%
    WinSendDlgItemMsg(hwnd, idListBox, LM_QUERYITEMTEXT,%@NL@%
                      MPFROM2SHORT(item, MAX_FNAME_LEN), (MPARAM)(PSZ)sz);%@NL@%
    lpszFile = sz;%@NL@%
%@NL@%
    %@AB@%/* extract name */%@AE@%%@NL@%
    if (fDir = (*sz == '['))%@NL@%
        {%@NL@%
        lpszFile = NextChar(lpszFile);%@NL@%
        if (*lpszFile == '-')%@NL@%
            {%@NL@%
            %@AB@%/* drive selection */%@AE@%%@NL@%
            lpszFile = NextChar(lpszFile);%@NL@%
            *(lpszFile+1) = ':';%@NL@%
            *(lpszFile+2) = '\0';%@NL@%
            }%@NL@%
        else%@NL@%
            {%@NL@%
            %@AB@%/* directory selection */%@AE@%%@NL@%
            lpsz = lpszFile;%@NL@%
            while (*lpsz != ']')%@NL@%
                lpsz = NextChar(lpsz);%@NL@%
            *lpsz = '\\';%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
    lstrcpy(lpszIn, lpszFile);%@NL@%
    return (fDir);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function tries to open pdlf=>szFileName.  If the file does not%@NL@%
%@AB@%* exist, the function asks to create it.%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Returns:%@NL@%
%@AB@%*    TDF_NOOPEN  - Illegal Filename or user didn't want to create%@NL@%
%@AB@%*    TDF_OLDOPEN - Existing file%@NL@%
%@AB@%*    TDF_NEWOPEN - File was created%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
USHORT PASCAL DlgOpenFile(pdlf, hwnd)%@NL@%
PDLF pdlf;%@NL@%
HWND hwnd;%@NL@%
    {%@NL@%
    %@AB@%/* check for legal dos name */%@AE@%%@NL@%
    if (!DlgParseFile((PSZ)pdlf->szFileName, (PSZ)pdlf->szOpenFile,%@NL@%
                      FALSE, FALSE))%@NL@%
        {%@NL@%
        DlgAlertBox(hwnd, IDS_IFN, pdlf, MB_OK | MB_ICONEXCLAMATION);%@NL@%
        return (TDF_NOOPEN);%@NL@%
        }%@NL@%
    %@AB@%/* see if file already exists */%@AE@%%@NL@%
    if (DlgParseFile((PSZ)pdlf->szFileName, (PSZ)pdlf->szOpenFile,%@NL@%
                      TRUE, FALSE))%@NL@%
        {%@NL@%
        if (OpenFile((PSZ)pdlf->szFileName, pdlf->phFile,%@NL@%
                        (PSZ)pdlf->szOpenFile, OF_READ))%@NL@%
            return (TDF_OLDOPEN);%@NL@%
        else%@NL@%
            {%@NL@%
            DlgAlertBox(hwnd, IDS_EOF, pdlf, MB_OK | MB_ICONEXCLAMATION);%@NL@%
            return (TDF_NOOPEN);%@NL@%
            }%@NL@%
        }%@NL@%
    %@AB@%/* file doesn't exist: create new one? */%@AE@%%@NL@%
    else if (DlgAlertBox(hwnd, IDS_FNF, pdlf, MB_YESNO | MB_ICONQUESTION) == MBID_YES)%@NL@%
        {%@NL@%
        if (OpenFile((PSZ)pdlf->szFileName, pdlf->phFile,%@NL@%
                        (PSZ)pdlf->szOpenFile, OF_CREATE))%@NL@%
            return (TDF_NEWOPEN);%@NL@%
        else%@NL@%
            DlgAlertBox(hwnd, IDS_ECF, pdlf, MB_OK | MB_ICONEXCLAMATION);%@NL@%
        }%@NL@%
    return(TDF_NOOPEN);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function returns the OS/2 file handle if operation is successful,%@NL@%
%@AB@%* 0 otherwise.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effects:  Depend on wMode:%@NL@%
%@AB@%*     OF_READ:      open file for reading only%@NL@%
%@AB@%*     OF_WRITE:     open file for writing only%@NL@%
%@AB@%*     OF_READWRITE: open file for reading and writing%@NL@%
%@AB@%*     OF_CREATE:    create the file if it does not exist%@NL@%
%@AB@%*     OF_REOPEN:    open file using info in the reopen buffer%@NL@%
%@AB@%*     OF_EXIST:     test file existence%@NL@%
%@AB@%*     OF_PARSE:     fill reopen buffer, with no other action%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
BOOL EXPENTRY OpenFile(lpszFile, lpHandle, lpszOpenFile, wMode)%@NL@%
PSZ  lpszFile;%@NL@%
PHFILE lpHandle;%@NL@%
PSZ  lpszOpenFile;%@NL@%
USHORT wMode;%@NL@%
    {%@NL@%
    HFILE hFile = NULL;%@NL@%
    USHORT wAction = NULL;%@NL@%
    USHORT wAttrs = NULL;%@NL@%
    USHORT wOpenFlag, wOpenMode;%@NL@%
    CHAR sz[MAX_FNAME_LEN];%@NL@%
%@NL@%
    %@AB@%/* if reopen specified, use earlier pathname */%@AE@%%@NL@%
    if (wMode & OF_REOPEN)%@NL@%
        {%@NL@%
        lstrcpy((PSZ)sz, lpszOpenFile);%@NL@%
        lpszFile = (PSZ)sz;%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/* parse file */%@AE@%%@NL@%
    if (!DlgParseFile(lpszFile, lpszOpenFile, wMode&OF_EXIST, FALSE))%@NL@%
        {%@NL@%
        *lpszOpenFile = '\0';%@NL@%
        return FALSE;%@NL@%
        }%@NL@%
    %@AB@%/* return if implementing boolean test OF_PARSE or OF_EXIST */%@AE@%%@NL@%
    if (wMode & (OF_PARSE | OF_EXIST))%@NL@%
        {%@NL@%
        return TRUE;%@NL@%
        }%@NL@%
%@NL@%
    if (wMode & OF_READ)%@NL@%
        {%@NL@%
        wOpenFlag = 0x01;               %@AB@%/* fail if it doesn't exist */%@AE@%%@NL@%
        wOpenMode = 0x20;               %@AB@%/* read only */%@AE@%%@NL@%
        }%@NL@%
    else if (wMode & OF_WRITE)%@NL@%
        {%@NL@%
        wOpenFlag = 0x11;               %@AB@%/* create if necessary */%@AE@%%@NL@%
        wOpenMode = 0x11;               %@AB@%/* write only */%@AE@%%@NL@%
        }%@NL@%
    else if (wMode & OF_READWRITE)%@NL@%
        {%@NL@%
        wOpenFlag = 0x11;               %@AB@%/* create if necessary */%@AE@%%@NL@%
        wOpenMode = 0x12;               %@AB@%/* read-write */%@AE@%%@NL@%
        }%@NL@%
    else if (wMode & OF_CREATE)%@NL@%
        {%@NL@%
        %@AB@%/* create and close file */%@AE@%%@NL@%
        wOpenFlag = 0x10;               %@AB@%/* fail if exists */%@AE@%%@NL@%
        wOpenMode = 0x10;               %@AB@%/* read only */%@AE@%%@NL@%
        }%@NL@%
    else%@NL@%
        {%@NL@%
        return FALSE;%@NL@%
        }%@NL@%
%@NL@%
    if (DosOpen(lpszFile, (PHFILE)&hFile, &wAction,%@NL@%
                (ULONG) 0, 0, wOpenFlag, wOpenMode, (ULONG) 0))%@NL@%
        return FALSE;%@NL@%
%@NL@%
    if (wMode & OF_CREATE)%@NL@%
        {%@NL@%
        if (DosClose(hFile))%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
    else%@NL@%
        *lpHandle = hFile;%@NL@%
%@NL@%
    return TRUE;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function puts a path string into a static box.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
PSZ  PASCAL DlgFitPathToBox(hwnd, idStatic, lpch)%@NL@%
HWND hwnd;%@NL@%
int idStatic;%@NL@%
PSZ  lpch;%@NL@%
    {%@NL@%
    WRECT rc;%@NL@%
    int cxField;%@NL@%
    char chDrive;%@NL@%
    HPS hps;%@NL@%
%@NL@%
    %@AB@%/* get length of static field */%@AE@%%@NL@%
    WinQueryWindowRect(WinWindowFromID(hwnd, idStatic), (PRECTL)&rc);%@NL@%
    cxField = rc.xRight - rc.xLeft;%@NL@%
%@NL@%
    hps = WinGetPS(hwnd);%@NL@%
    if (cxField < (int) LOUSHORT(GetTextExtent(hps, lpch,%@NL@%
                                           lstrlen(lpch))))%@NL@%
        {%@NL@%
        chDrive = *lpch;%@NL@%
        %@AB@%/* chop characters off front of string until text is short enough */%@AE@%%@NL@%
        do%@NL@%
            do%@NL@%
                lpch = NextChar(lpch);%@NL@%
            while (*(lpch+6) != '\\' &&%@NL@%
                   *(lpch+6) != '\0');%@NL@%
        while (cxField < (int) LOUSHORT(GetTextExtent(hps, lpch,%@NL@%
                                                 lstrlen(lpch))));%@NL@%
        %@AB@%/* insert header */%@AE@%%@NL@%
        *lpch++ = chDrive;%@NL@%
        *lpch++ = ':';%@NL@%
        *lpch++ = '\\';%@NL@%
        *lpch++ = '.';%@NL@%
        *lpch++ = '.';%@NL@%
        *lpch++ = '.';%@NL@%
        lpch -= 6;%@NL@%
        }%@NL@%
    WinReleasePS(hps);%@NL@%
    return (lpch);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function fills a list box with appropriate file names from the%@NL@%
%@AB@%* current directory.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
int PASCAL DlgFillListBoxes(hwnd, idDirList, idFileList, attr, lpszFileSpec)%@NL@%
HWND   hwnd;%@NL@%
int    idDirList;%@NL@%
int    idFileList;%@NL@%
USHORT attr;%@NL@%
PSZ    lpszFileSpec;%@NL@%
    {%@NL@%
    USHORT usFiles, usDrive;%@NL@%
    int i;%@NL@%
    PSZ  lpsz;%@NL@%
    HDIR hDir;%@NL@%
    ULONG lrgfDrives;%@NL@%
    FILEFINDBUF ffb;%@NL@%
    CHAR sz[20];%@NL@%
    int cDrives;%@NL@%
    int result = -1;%@NL@%
    HWND hwndFiles, hwndDirs;%@NL@%
%@NL@%
    %@AB@%/* get listbox window handles */%@AE@%%@NL@%
    hwndFiles = WinWindowFromID(hwnd, idFileList);%@NL@%
    hwndDirs = WinWindowFromID(hwnd, idDirList);%@NL@%
%@NL@%
    %@AB@%/* disable updates to listboxes */%@AE@%%@NL@%
    WinEnableWindowUpdate(hwndFiles, FALSE);%@NL@%
    WinEnableWindowUpdate(hwndDirs, FALSE);%@NL@%
%@NL@%
    %@AB@%/* empty list boxes of any old entries */%@AE@%%@NL@%
    WinSendMsg(hwndFiles, LM_DELETEALL, 0L, 0L);%@NL@%
    WinSendMsg(hwndDirs, LM_DELETEALL, 0L, 0L);%@NL@%
%@NL@%
    %@AB@%/* put files that lMatch search spec in file listbox */%@AE@%%@NL@%
    usFiles = 1;%@NL@%
    hDir = 0xFFFF;%@NL@%
    if (!DosFindFirst(lpszFileSpec, (PHDIR)&hDir,%@NL@%
        attr&~(BITATTRDIR|BITATTRDRIVE), (PFILEFINDBUF)&ffb, sizeof(FILEFINDBUF),%@NL@%
        &usFiles, 0L))%@NL@%
        {%@NL@%
        do%@NL@%
            {%@NL@%
            %@AB@%/* add string to list box */%@AE@%%@NL@%
            result = (int) SHORT1FROMMR(WinSendMsg(hwndFiles, LM_INSERTITEM,%@NL@%
                                      MPFROM2SHORT(LIT_SORTASCENDING, 0),%@NL@%
                                      (MPARAM)(PSZ)&(ffb.achName[0])));%@NL@%
            usFiles = 1;%@NL@%
            }%@NL@%
        while (result >= 0 && !DosFindNext(hDir,%@NL@%
                                           (PFILEFINDBUF)&ffb,%@NL@%
                                           sizeof(FILEFINDBUF),%@NL@%
                                           &usFiles));%@NL@%
        DosFindClose(hDir);%@NL@%
        }%@NL@%
%@NL@%
    if (result != LIT_MEMERROR && (attr   & BITATTRDIR))%@NL@%
        {%@NL@%
        %@AB@%/* get directories */%@AE@%%@NL@%
        usFiles = 1;%@NL@%
        hDir = 0xFFFF;%@NL@%
        if (!DosFindFirst((PSZ)szStarStar, (PHDIR)&hDir, BITATTRDIR,%@NL@%
            (PFILEFINDBUF)&ffb, sizeof(FILEFINDBUF), &usFiles, 0l))%@NL@%
            {%@NL@%
            do%@NL@%
                {%@NL@%
                %@AB@%/* extract file name */%@AE@%%@NL@%
                if (ffb.attrFile & BITATTRDIR)%@NL@%
                    {%@NL@%
                    %@AB@%/* put brackets around directory */%@AE@%%@NL@%
                    lpsz = (PSZ)&(ffb.achName[0]);%@NL@%
                    if (*lpsz == '.' && *(lpsz+1) == '\0')%@NL@%
                        %@AB@%/* forget about current directory name '.' */%@AE@%%@NL@%
                        continue;%@NL@%
                    sz[0] = '[';%@NL@%
                    lstrcpy((PSZ)&sz[1], lpsz);%@NL@%
                    sz[ffb.cchName    + 1] = ']';%@NL@%
                    sz[ffb.cchName    + 2] = '\0';%@NL@%
                    lpsz = (PSZ)sz;%@NL@%
                    %@AB@%/* add string to list box */%@AE@%%@NL@%
                    result = (int) SHORT1FROMMR(WinSendMsg(hwndDirs, LM_INSERTITEM,%@NL@%
                                              MPFROM2SHORT(LIT_SORTASCENDING, 0),%@NL@%
                                              (MPARAM)lpsz));%@NL@%
                    }%@NL@%
                usFiles = 1;%@NL@%
                }%@NL@%
            while (result >= -1 && !DosFindNext(hDir,%@NL@%
                                               (PFILEFINDBUF)&ffb,%@NL@%
                                               sizeof(FILEFINDBUF),%@NL@%
                                               &usFiles));%@NL@%
            DosFindClose(hDir);%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
    if (result != LIT_MEMERROR && (attr   & BITATTRDRIVE))%@NL@%
        %@AB@%/* get drives */%@AE@%%@NL@%
        {%@NL@%
        sz[0] = '[';%@NL@%
        sz[1] = sz[3] = '-';%@NL@%
        sz[4] = ']';%@NL@%
        sz[5] = '\0';%@NL@%
%@NL@%
        DosQCurDisk(&usDrive, (unsigned long far *)&lrgfDrives);%@NL@%
        cDrives = 0;%@NL@%
        for (i=0; 'A' + i <= 'Z'; i++)%@NL@%
            {%@NL@%
            if (lrgfDrives & 1L)%@NL@%
                {%@NL@%
                sz[2] = (char)('A' + i);%@NL@%
                %@AB@%/* add drive to list */%@AE@%%@NL@%
                result = (int) SHORT1FROMMR(WinSendMsg(hwndDirs, LM_INSERTITEM,%@NL@%
                                          MPFROM2SHORT(LIT_END, 0),%@NL@%
                                          (MPARAM)(PSZ)sz));%@NL@%
                cDrives++;%@NL@%
                }%@NL@%
            lrgfDrives >>= 1;%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/* enable and show updated listboxes */%@AE@%%@NL@%
    WinShowWindow(hwndFiles, TRUE);%@NL@%
    WinShowWindow(hwndDirs, TRUE);%@NL@%
%@NL@%
    return result;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function parses a string into an fully expanded file name or search%@NL@%
%@AB@%* path.  If fExist is true then the file must exist or the search path must%@NL@%
%@AB@%* correspond to at least one existing file.  In all cases, the corresponding%@NL@%
%@AB@%* directory must exist.  The string must be a file name, ie. no wildcards,%@NL@%
%@AB@%* unless fWildOkay is true.  Returns TRUE if string is parsed correctly.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL PASCAL DlgParseFile(lpszIn, lpszExp, fExist, fWildOkay)%@NL@%
PSZ  lpszIn, lpszExp;%@NL@%
BOOL fExist, fWildOkay;%@NL@%
    {%@NL@%
    CHAR szPath[MAX_FNAME_LEN];%@NL@%
    PSZ  lpszFile, lpsz;%@NL@%
%@NL@%
    %@AB@%/* go past any path spec to first char in file name */%@AE@%%@NL@%
    lpszFile = FileInPath(lpszIn);%@NL@%
%@NL@%
    %@AB@%/* check validity of file name */%@AE@%%@NL@%
    if (!fExist && !DlgValidName(lpszFile, fWildOkay))%@NL@%
        {%@NL@%
        *lpszExp = '\0';%@NL@%
        return FALSE;%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/* copy path part to path string */%@AE@%%@NL@%
    lpsz = (PSZ)szPath;%@NL@%
    if (lpszIn == lpszFile)%@NL@%
        *lpsz++ = '.';%@NL@%
    else%@NL@%
        {%@NL@%
        while (lpszIn < lpszFile && lpsz < ((PSZ)szPath + MAX_FNAME_LEN - 1))%@NL@%
            *lpsz++ = *lpszIn++;%@NL@%
        }%@NL@%
    *lpsz = '\0';%@NL@%
%@NL@%
    %@AB@%/* let DOS do the dirty work */%@AE@%%@NL@%
    if (fExist)%@NL@%
        {%@NL@%
        %@AB@%/* test existence of file while parsing path */%@AE@%%@NL@%
        if (DosSearchPath(0, (PSZ)szPath, lpszFile, lpszExp, MAX_FNAME_LEN))%@NL@%
            {%@NL@%
            *lpszExp = '\0';%@NL@%
            return FALSE;%@NL@%
            }%@NL@%
        }%@NL@%
    else%@NL@%
        {%@NL@%
        %@AB@%/* use dummy wild card while parsing path */%@AE@%%@NL@%
        if (DosSearchPath(0, (PSZ)szPath, (PSZ)szStarStar, lpszExp, MAX_FNAME_LEN))%@NL@%
            {%@NL@%
            *lpszExp = '\0';%@NL@%
            return FALSE;%@NL@%
            }%@NL@%
        %@AB@%/* replace wild card part with true file name converted to CAPS */%@AE@%%@NL@%
        lpsz = lpszExp;%@NL@%
        while (*lpsz != '?' && *lpsz != '*' && *lpsz != '\0')%@NL@%
            lpsz++;%@NL@%
        while (*lpszFile != '\0')%@NL@%
            {%@NL@%
            *lpsz++ = *lpszFile++;%@NL@%
            }%@NL@%
        *lpsz = '\0';%@NL@%
        Upper(lpszExp);%@NL@%
        }%@NL@%
    return TRUE;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function determines if a string forms a legal file name or search%@NL@%
%@AB@%* path.  Wildcard characters are acceptable if fWildOkay is true.  Returns%@NL@%
%@AB@%* TRUE if string is legal.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL PASCAL DlgValidName(lpszName, fWildOkay)%@NL@%
PSZ  lpszName;%@NL@%
BOOL fWildOkay;%@NL@%
    {%@NL@%
    int cLen;%@NL@%
    PSZ  lpsz;%@NL@%
%@NL@%
    %@AB@%/* check file name */%@AE@%%@NL@%
    if (*lpszName == '\0')%@NL@%
        return FALSE;%@NL@%
    cLen = 0;%@NL@%
    lpsz = lpszName;%@NL@%
    while (*lpsz != '\0' && *lpsz != '.')%@NL@%
        {%@NL@%
        if (++cLen > 8 || *lpsz < 0x20)%@NL@%
            return FALSE;%@NL@%
        switch (*lpsz++)%@NL@%
            {%@NL@%
            case '*':%@NL@%
            case '?':%@NL@%
                if (fWildOkay)%@NL@%
                    break;%@NL@%
            case '\"':%@NL@%
            case '\\':%@NL@%
            case '/':%@NL@%
            case '[':%@NL@%
            case ']':%@NL@%
            case ':':%@NL@%
            case '|':%@NL@%
            case '<':%@NL@%
            case '>':%@NL@%
            case '+':%@NL@%
            case '=':%@NL@%
            case ';':%@NL@%
            case ',':%@NL@%
                return FALSE;%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/* check extension */%@AE@%%@NL@%
    if (*lpsz++ == '\0')%@NL@%
        return TRUE;%@NL@%
    cLen = 0;%@NL@%
    while (*lpsz != '\0')%@NL@%
        {%@NL@%
        if (++cLen > 3 || *lpsz < 0x20)%@NL@%
            return FALSE;%@NL@%
        switch (*lpsz++)%@NL@%
            {%@NL@%
            case '*':%@NL@%
            case '?':%@NL@%
                if (fWildOkay)%@NL@%
                    break;%@NL@%
            case '.':%@NL@%
            case '\"':%@NL@%
            case '\\':%@NL@%
            case '/':%@NL@%
            case '[':%@NL@%
            case ']':%@NL@%
            case ':':%@NL@%
            case '|':%@NL@%
            case '<':%@NL@%
            case '>':%@NL@%
            case '+':%@NL@%
            case '=':%@NL@%
            case ';':%@NL@%
            case ',':%@NL@%
                return FALSE;%@NL@%
            }%@NL@%
        }%@NL@%
    return TRUE;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%GPI.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\OPENDLG\GPI.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* GPI.C -- GPI Helper routines%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%"tool.h" %@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* GetTextExtent helper function%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG EXPENTRY GetTextExtent(HPS hps, PCH lpstr, int cch) {%@NL@%
    POINTL rgptl[TXTBOX_COUNT];%@NL@%
%@NL@%
    if (cch) {%@NL@%
        GpiQueryTextBox(hps, (LONG)cch, lpstr, 5L, rgptl);%@NL@%
        return(MAKEULONG((SHORT)(rgptl[TXTBOX_CONCAT].x - rgptl[TXTBOX_BOTTOMLEFT].x),%@NL@%
                     (SHORT)(rgptl[TXTBOX_TOPLEFT].y - rgptl[TXTBOX_BOTTOMLEFT].y)));%@NL@%
    } else%@NL@%
        return(0L);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%HANOI.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\HANOI\HANOI.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@% This program implements a tower of hanoi program.  This%@NL@%
%@AB@% sample app was written to demonstrate the use of a multi-%@NL@%
%@AB@% threaded program.  The main thread handles the PM interface,%@NL@%
%@AB@% the second thread is started to do the recursive execution%@NL@%
%@AB@% of the hanoi algorithm.%@NL@%
%@AB@%%@NL@%
%@AB@% This program was written by Jeff Johnson, 7/89.%@NL@%
%@AB@%%@NL@%
%@AB@% Procedures in this file:%@NL@%
%@AB@%   main()             Sets up the PM environment and heap and%@NL@%
%@AB@%                      calls the main window procedure ClientWndProc%@NL@%
%@AB@%   ClientWndProc()    Handles the main window messages%@NL@%
%@AB@%   CalcThread()       Sets up and terminates the secondary thread%@NL@%
%@AB@%   DrawDisk()         Draws or erases a disk on one of the poles%@NL@%
%@AB@%   MoveDisk()         Moves a disk from one pole to another%@NL@%
%@AB@%   Hanoi()            Recursive alogrithm for tower of hanoi prog%@NL@%
%@AB@%   EnableMenuItem()   Activates/deactivates a menu choice%@NL@%
%@AB@%   EntryFldDlgProc()  Handles the set number of disks dialog box%@NL@%
%@AB@%   SetupTowers()      Sets up the global tower data%@NL@%
%@AB@%%@NL@%
%@AB@%**************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"hanoi.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/********************* GLOBALS *******************************/%@AE@%%@NL@%
%@NL@%
CHAR szClientClass[] = "Hanoi";%@NL@%
%@NL@%
%@AB@%/* Note that this use of global data precludes multiple windows%@NL@%
%@AB@%   of hanoi running at the same time.  Thus, from an object-%@NL@%
%@AB@%   oriented perspective, this is less than desireable and the%@NL@%
%@AB@%   data should be passed into the window, rather than used%@NL@%
%@AB@%   explicitly. */%@AE@%%@NL@%
%@NL@%
BYTE abTowers[3][MAXDISKCNT];     %@AB@%/* Used to hold disk numbers on each post */%@AE@%%@NL@%
BYTE abTowersNdx[3];              %@AB@%/* Current number of disks on each post   */%@AE@%%@NL@%
BYTE cTowerSize = DEFAULTSIZE;   %@AB@%/* Holds the total number of disks        */%@AE@%%@NL@%
USHORT ausPolePos[3]= { POSTOFFSET, %@AB@%/* Holds offset drawing information     */%@AE@%%@NL@%
                       POSTOFFSET + POSTSPACE,%@NL@%
                       POSTOFFSET + 2*POSTSPACE };%@NL@%
ULONG  ulIterations;%@NL@%
%@NL@%
%@AB@%/*************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: main()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  argc, argv.  If the user places a number (1 thru MAXDISKCNT)%@NL@%
%@AB@% *              on the command line, that number will become the default%@NL@%
%@AB@% *              number of disks on the stack. Otherwise there will be%@NL@%
%@AB@% *              DEFUALTSIZE disks initially.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Always returns 0%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Parses the command line, sets up the PM environment, prepares%@NL@%
%@AB@% *          the Tower arrays, calls the main window proc, handles the%@NL@%
%@AB@% *          window's messages then cleans up and exits.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: ClientWndProc() (thru PM)%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
int main(int argc, char *argv[])%@NL@%
{%@NL@%
   HAB          hab;%@NL@%
   HMQ          hmq;%@NL@%
   HWND         hwndFrame, hwndClient;%@NL@%
   QMSG         qmsg;%@NL@%
%@NL@%
   ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU | FCF_MINBUTTON |%@NL@%
                        FCF_SHELLPOSITION | FCF_MENU    | FCF_TASKLIST  |%@NL@%
                        FCF_ICON          | FCF_BORDER  | FCF_ACCELTABLE;%@NL@%
%@NL@%
   SHORT sHold;%@NL@%
%@NL@%
   if(argc > 1)  %@AB@%/* If command line arg, use as the initial number of disks */%@AE@%%@NL@%
   {%@NL@%
      sHold = atoi(argv[1]);%@NL@%
      if(sHold>0 && sHold<=MAXDISKCNT)%@NL@%
         cTowerSize = (BYTE) sHold;%@NL@%
   }%@NL@%
   SetupTowers();%@NL@%
%@NL@%
   %@AB@%/* These PM calls should be error checked */%@AE@%%@NL@%
   hab = WinInitialize(0);%@NL@%
   hmq = WinCreateMsgQueue(hab, 0);%@NL@%
%@NL@%
   if(!WinRegisterClass(hab, szClientClass,ClientWndProc,0L,0))%@NL@%
   {%@NL@%
      WinAlarm(HWND_DESKTOP, WA_ERROR);        %@AB@%/* Register failed */%@AE@%%@NL@%
      DosExit(EXIT_PROCESS,1);%@NL@%
   }%@NL@%
%@NL@%
   hwndFrame = WinCreateStdWindow(HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                  &flFrameFlags, szClientClass, NULL,%@NL@%
                                  0L, (HMODULE) NULL, ID_MAINMENU, &hwndClient);%@NL@%
   if(!hwndFrame)%@NL@%
   {%@NL@%
      WinAlarm(HWND_DESKTOP, WA_ERROR); %@AB@%/* Window create failed */%@AE@%%@NL@%
      DosExit(EXIT_PROCESS,1);%@NL@%
   }%@NL@%
%@NL@%
   while(WinGetMsg(hab,&qmsg,NULL,0,0))        %@AB@%/* Message loop */%@AE@%%@NL@%
      WinDispatchMsg(hab,&qmsg);%@NL@%
%@NL@%
   WinDestroyWindow(hwndFrame);                %@AB@%/* Clean up     */%@AE@%%@NL@%
   WinDestroyMsgQueue(hmq);%@NL@%
   WinTerminate(hab);%@NL@%
   return 0;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: ClientWndProc()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd, msg, mp1, mp2.  Standard PM Window Proc params.%@NL@%
%@AB@% *              No user data is expected in the WM_CREATE.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Handles all the messages associated with the main window%@NL@%
%@AB@% *          and calls the appropriate handling procedures.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: Called only by main().  Note that when WM_PAINT executes,%@NL@%
%@AB@% *                 the secondary thread may change data during the update%@NL@%
%@AB@% *                 which may cause a problem.  However, this is NOT a write%@NL@%
%@AB@% *                 conflict, as only 1 thread does the writing.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  DrawDisk(), CalcThread() (thru Thread), EntryFldDlgProc() (thru PM)%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
   HPS    hps;                         %@AB@%/* Handle for painting           */%@AE@%%@NL@%
   RECTL  rcl;                         %@AB@%/* Rectangle struct for painting */%@AE@%%@NL@%
   POINTL ptl;                         %@AB@%/* Point struct for painting     */%@AE@%%@NL@%
   BYTE   cPole,bCnt,bHeight,cnt;      %@AB@%/* Utility variables             */%@AE@%%@NL@%
   CHAR   szMsg[MSGBUFSIZE];           %@AB@%/* sprintf buffer                */%@AE@%%@NL@%
   static CALCPARAM cp;                %@AB@%/* Struct used to notify thread  */%@AE@%%@NL@%
   static TID    tidCalc;              %@AB@%/* Secondary thread ID           */%@AE@%%@NL@%
   static VOID   *pThreadStack;        %@AB@%/* Pointer to secondary stack    */%@AE@%%@NL@%
%@NL@%
   switch(msg)%@NL@%
   {%@NL@%
      case WM_PAINT:%@NL@%
         hps = WinBeginPaint(hwnd,NULL,NULL);   %@AB@%/* Get paint handle     */%@AE@%%@NL@%
         WinQueryWindowRect(hwnd,&rcl);%@NL@%
%@NL@%
         DrawRect(rcl.xLeft,rcl.yBottom,        %@AB@%/* White out the screen */%@AE@%%@NL@%
                  rcl.xRight,rcl.yTop,CLR_WHITE);%@NL@%
%@NL@%
         %@AB@%/* Draw the base */%@AE@%%@NL@%
         DrawRect(BASEXOFFSET,           BASEYOFFSET,%@NL@%
                  BASEXOFFSET+BASELEN-1, BASEYOFFSET+BASETHICK-1,%@NL@%
                  CLR_DARKGREEN);%@NL@%
%@NL@%
         %@AB@%/* Draw the 3 posts */%@AE@%%@NL@%
         bHeight = (BYTE) (cTowerSize*DISKSPACE + POSTEXTRAHT);%@NL@%
         for(cnt=0;cnt<3;cnt++)%@NL@%
         {%@NL@%
            DrawRect(ausPolePos[cnt]-POSTHALF,          BASEYOFFSET,%@NL@%
                     ausPolePos[cnt]-POSTHALF+POSTWIDTH,bHeight,%@NL@%
                     CLR_DARKGREEN);%@NL@%
         }%@NL@%
%@NL@%
         %@AB@%/* Place the appropriate disks on each pole */%@AE@%%@NL@%
         for(cPole=0;cPole<3;cPole++)%@NL@%
         {%@NL@%
            for(bCnt=0;bCnt<abTowersNdx[cPole];bCnt++)%@NL@%
            {%@NL@%
               DrawDisk(hps,cPole,bCnt,fDRAW);%@NL@%
            }%@NL@%
         }%@NL@%
%@NL@%
         WinEndPaint(hps);%@NL@%
         return 0L;%@NL@%
%@NL@%
      case WM_COMMAND:%@NL@%
         switch(COMMANDMSG(&msg)->cmd)%@NL@%
         {%@NL@%
            case IDM_START:%@NL@%
               %@AB@%/* Try to get stack space */%@AE@%%@NL@%
               if((pThreadStack = malloc(STACKSIZE)) == NULL)%@NL@%
               {%@NL@%
                  WinAlarm(HWND_DESKTOP, WA_ERROR);  %@AB@%/* Couldn't get memory */%@AE@%%@NL@%
                  return 0L;%@NL@%
               }%@NL@%
               cp.hwnd = hwnd;           %@AB@%/* Set the static struct  */%@AE@%%@NL@%
               cp.fContinueCalc = TRUE;%@NL@%
               ulIterations = 0;         %@AB@%/* Zero iteration counter */%@AE@%%@NL@%
%@NL@%
               %@AB@%/* Try to start the thread */%@AE@%%@NL@%
               if((tidCalc = _beginthread(CalcThread,pThreadStack,%@NL@%
                                          STACKSIZE, &cp))     == -1)%@NL@%
               {%@NL@%
                  free(pThreadStack);    %@AB@%/* Thread wouldn't start  */%@AE@%%@NL@%
                  WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
                  return 0L;%@NL@%
               }%@NL@%
               %@AB@%/* Disallow menu items that could change data while the second%@NL@%
%@AB@%                  thread is running */%@AE@%%@NL@%
               EnableMenuItem(hwnd,IDM_START,FALSE); %@AB@%/* Disable Start & set */%@AE@%%@NL@%
               EnableMenuItem(hwnd,IDM_SET,FALSE);%@NL@%
               EnableMenuItem(hwnd,IDM_STOP,TRUE);   %@AB@%/* Enable Stop item    */%@AE@%%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDM_STOP:%@NL@%
               cp.fContinueCalc = FALSE;  %@AB@%/* Notify thread to quit          */%@AE@%%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDM_SET:%@NL@%
               if(WinDlgBox(HWND_DESKTOP, hwnd, %@AB@%/* Pop up the query/set box */%@AE@%%@NL@%
                         EntryFldDlgProc,(HMODULE) NULL,ID_SETCOUNT,NULL))%@NL@%
               {%@NL@%
                  SetupTowers();                          %@AB@%/* Reset towers   */%@AE@%%@NL@%
                  WinInvalidateRect(hwnd,NULL,FALSE);     %@AB@%/* Force a redraw */%@AE@%%@NL@%
               }%@NL@%
               return 0L;%@NL@%
%@NL@%
             default:%@NL@%
                return WinDefWindowProc(hwnd, msg, mp1, mp2);%@NL@%
         }%@NL@%
%@NL@%
      case UM_CALC_DONE:%@NL@%
         EnableMenuItem(hwnd,IDM_START,TRUE);  %@AB@%/* Reenable Start & set      */%@AE@%%@NL@%
         EnableMenuItem(hwnd,IDM_SET,TRUE);%@NL@%
         EnableMenuItem(hwnd,IDM_STOP,FALSE);  %@AB@%/* Disable stop              */%@AE@%%@NL@%
         free(pThreadStack);                   %@AB@%/* Free thread's stack space */%@AE@%%@NL@%
%@NL@%
         sprintf(szMsg,"%lu disks were moved.",ulIterations);  %@AB@%/* Print msg */%@AE@%%@NL@%
         WinMessageBox(HWND_DESKTOP, hwnd, szMsg, "Done!", 0, MB_OK);%@NL@%
%@NL@%
         SetupTowers();                        %@AB@%/* Reset towers              */%@AE@%%@NL@%
         WinInvalidateRect(hwnd,NULL,FALSE);   %@AB@%/* Force a screen redraw     */%@AE@%%@NL@%
         return 0L;%@NL@%
%@NL@%
       default:%@NL@%
          return WinDefWindowProc(hwnd, msg, mp1, mp2);%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: CalcThread()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pcp is a struct which contains the hwnd handle and the%@NL@%
%@AB@% *              continue flag which is initially set to TRUE.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Calls the recursive Hanoi with initial setting of 0,2,1 meaning%@NL@%
%@AB@% *          from pole 0, to pole 2, using pole 1 as a temporary.  Hanoi%@NL@%
%@AB@% *          returns when finished, or the user says stop.  This proc then%@NL@%
%@AB@% *          sets a critical section so the posted message won't be handled%@NL@%
%@AB@% *          until the thread is terminated.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: No DosExitCritSec() is called since _endthread() supposedly%@NL@%
%@AB@% *                 clears the critical section when the thread is%@NL@%
%@AB@% *                 terminated.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  Hanoi()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID _cdecl FAR CalcThread(PCALCPARAM pcp)%@NL@%
{%@NL@%
   HAB hab;%@NL@%
%@NL@%
   hab = WinInitialize(0);    %@AB@%/* Called to increase Ring 2 stack size */%@AE@%%@NL@%
   Hanoi(pcp,cTowerSize,0,2,1);      %@AB@%/* Execute the recursive routine */%@AE@%%@NL@%
   WinTerminate(hab);%@NL@%
%@NL@%
   DosEnterCritSec(); %@AB@%/* Set Crit so the UM_CALC_DONE isn't processed */%@AE@%%@NL@%
                      %@AB@%/* until this thread has completely terminated  */%@AE@%%@NL@%
   WinPostMsg(pcp->hwnd,UM_CALC_DONE,NULL,NULL);         %@AB@%/* Post done */%@AE@%%@NL@%
%@NL@%
   _endthread();                                  %@AB@%/* Terminate thread */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: DrawDisk()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hps is a handle to the main PS space.%@NL@%
%@AB@% *              cPole is the pole (0-2) to draw the disk on.%@NL@%
%@AB@% *              bLevel is the number of spaces from the bottom to draw disk.%@NL@%
%@AB@% *              fDraw if =0, erase disk, if =1 draw disk.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine takes a PS handle, the hanoi spindle and disk level%@NL@%
%@AB@% *          and draws an appropriately sized disk.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: Does not grab exclusive access to the screen before%@NL@%
%@AB@% *                 drawing which may cause a problem.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID DrawDisk(HPS hps,BYTE cPole, BYTE bLevel,BYTE fDraw)%@NL@%
{%@NL@%
   USHORT usXstart,usYstart,usWidth;%@NL@%
   POINTL ptl;%@NL@%
%@NL@%
   usYstart = BOTDISKYPOS + DISKSPACE*bLevel;  %@AB@%/* Calculate Bottom of disk   */%@AE@%%@NL@%
%@NL@%
   usWidth  = (MAXDISKWIDTH-MINDISKWIDTH)*abTowers[cPole][bLevel]/cTowerSize%@NL@%
              + MINDISKWIDTH;                  %@AB@%/* Calculate the disk's width */%@AE@%%@NL@%
%@NL@%
   usXstart = ausPolePos[cPole] - usWidth/2;   %@AB@%/* Center disk on pole        */%@AE@%%@NL@%
%@NL@%
   if(fDraw == fDRAW)  %@AB@%/* If we are to draw the disk */%@AE@%%@NL@%
   {%@NL@%
      DrawRect(usXstart,usYstart,usXstart+usWidth,%@NL@%
               usYstart+DISKTHICK-1,CLR_RED);%@NL@%
   }%@NL@%
   else         %@AB@%/* We are to erase the disk, then redraw the pole */%@AE@%%@NL@%
   {%@NL@%
      DrawRect(usXstart,usYstart,usXstart+usWidth,%@NL@%
               usYstart+DISKTHICK-1,CLR_WHITE);%@NL@%
      DrawRect(ausPolePos[cPole]-POSTHALF,usYstart,%@NL@%
               ausPolePos[cPole]-POSTHALF+POSTWIDTH,usYstart+DISKTHICK-1,%@NL@%
               CLR_DARKGREEN);%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: MoveDisk()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hps is a handle to the main PS space.%@NL@%
%@AB@% *              bFrom is the spindle to take the top disk from.%@NL@%
%@AB@% *              bTo is the spindle to place the disk on.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine moves the top disk from the bFrom spindle to the top%@NL@%
%@AB@% *          of the bTo spindle.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: Does error checking for trying to move a disk from a%@NL@%
%@AB@% *                 spindle that does not have any disks on it.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  MoveDisk()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID MoveDisk(HPS hps,BYTE bFrom,BYTE bTo)%@NL@%
{%@NL@%
   CHAR bTOSndx;  %@AB@%/* Top of stack index  */%@AE@%%@NL@%
   BYTE bDiskNum; %@AB@%/* Disk number to move */%@AE@%%@NL@%
%@NL@%
   bTOSndx = (CHAR) (abTowersNdx[bFrom]-1);%@NL@%
   if(bTOSndx < 0)%@NL@%
      return;%@NL@%
%@NL@%
   DrawDisk(hps,bFrom,bTOSndx,fERASE);   %@AB@%/* Remove disk off from stack     */%@AE@%%@NL@%
%@NL@%
   bDiskNum = abTowers[bFrom][bTOSndx];  %@AB@%/* Get move disk number           */%@AE@%%@NL@%
   abTowersNdx[bFrom]--;                 %@AB@%/* Decrease count on from spindle */%@AE@%%@NL@%
%@NL@%
   bTOSndx = abTowersNdx[bTo]++;         %@AB@%/* Offset to place the disk at    */%@AE@%%@NL@%
   abTowers[bTo][bTOSndx] = bDiskNum;    %@AB@%/* Place on stack in memory       */%@AE@%%@NL@%
%@NL@%
   DrawDisk(hps,bTo,bTOSndx,fDRAW);      %@AB@%/* Draw disk on the to stack      */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: Hanoi()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pcp is a struct which contains the hwnd handle and the%@NL@%
%@AB@% *                  continue flag which is initially set to TRUE.%@NL@%
%@AB@% *              bHeight is the number of disks in the from stack to move.%@NL@%
%@AB@% *              bFrom is the from spindle number, 0-2.%@NL@%
%@AB@% *              bTo is the to spindle number.%@NL@%
%@AB@% *              bTemp is the temporary spindle number.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine implements a recursive hanoi program that works as%@NL@%
%@AB@% *          follows:  By recursion, move all the disks, except for the%@NL@%
%@AB@% *          bottom disk to the temporary stack.  Then move the bottom%@NL@%
%@AB@% *          disk to the target spindle.  Now recursively move the stack%@NL@%
%@AB@% *          on the temporary spindle to the target spindle.  The limiting%@NL@%
%@AB@% *          case is when Hanoi() is called with a bHeight of 0 in which%@NL@%
%@AB@% *          case the depth recursion is terminated.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: This routine checks the ->fContinueCalc flag, which is set%@NL@%
%@AB@% *                 by the main thread when the user selects stop, to see if%@NL@%
%@AB@% *                 the user wishes to abort the algorithm.  If so, it backs%@NL@%
%@AB@% *                 out and exits.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  MoveDisk()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID Hanoi(PCALCPARAM pcp, BYTE bHeight, BYTE bFrom, BYTE bTo, BYTE bTemp)%@NL@%
{%@NL@%
   HPS hps;%@NL@%
%@NL@%
   if(bHeight<=0 || !pcp->fContinueCalc)  %@AB@%/* Exit up if no more disks or */%@AE@%%@NL@%
      return;                             %@AB@%/* the user said Stop          */%@AE@%%@NL@%
%@NL@%
   Hanoi(pcp,(BYTE)(bHeight-1),bFrom,bTemp,bTo);  %@AB@%/* Move all but bottom disk    */%@AE@%%@NL@%
%@NL@%
   if(!pcp->fContinueCalc)                %@AB@%/* If user said to stop        */%@AE@%%@NL@%
      return;%@NL@%
%@NL@%
   %@AB@%/* Display bFrom -> bTo */%@AE@%%@NL@%
   hps = WinGetPS(pcp->hwnd);%@NL@%
   MoveDisk(hps,bFrom,bTo);               %@AB@%/* Move the bottom disk        */%@AE@%%@NL@%
   WinReleasePS(hps);%@NL@%
   ulIterations++;%@NL@%
%@NL@%
   Hanoi(pcp,(BYTE)(bHeight-1),bTemp,bTo,bFrom);  %@AB@%/* Move disks over             */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: EnableMenuItem()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd is a handle of the current window.%@NL@%
%@AB@% *              sMenuItem is the ID of the item to Enable/Disable.%@NL@%
%@AB@% *              fEnable will enable item if TRUE, otherwise disables it.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine handles enabling/disabling of menu items.  This%@NL@%
%@AB@% *          is done by getting Parent and Menu hwnd handles then sending%@NL@%
%@AB@% *          the appropriate message.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID EnableMenuItem(HWND hwnd, SHORT sMenuItem, BOOL fEnable)%@NL@%
{%@NL@%
   HWND hwndParent = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
   HWND hwndMenu   = WinWindowFromID(hwndParent, FID_MENU);%@NL@%
%@NL@%
   WinSendMsg(hwndMenu, MM_SETITEMATTR,%@NL@%
              MPFROM2SHORT(sMenuItem, TRUE),%@NL@%
              MPFROM2SHORT(MIA_DISABLED, fEnable ? 0 : MIA_DISABLED));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: EntryFldDlgProc()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd, msg, mp1, mp2.  Standard PM Dialog Proc params.%@NL@%
%@AB@% *              No user data is expected in the WM_CREATE.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Terminates with a TRUE iff a new valid Tower Size has been entered.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Handles all the messages associated with the set entry field%@NL@%
%@AB@% *          and calls the appropriate handling procedures.  The purpose%@NL@%
%@AB@% *          of this dialog box is to get a new number of disks for the%@NL@%
%@AB@% *          hanoi routine.%@NL@%
%@AB@% *%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: If the value entered is valid, global cTowerSize is%@NL@%
%@AB@% *                 changed to the new value, and TRUE is returned.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY EntryFldDlgProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
   SHORT sNewSize;            %@AB@%/* Holds new number of disks        */%@AE@%%@NL@%
%@NL@%
   switch(msg)%@NL@%
   {%@NL@%
      case WM_INITDLG:%@NL@%
         WinSendDlgItemMsg(hwnd, ID_ENTRYFLD,EM_SETTEXTLIMIT,  %@AB@%/* Limit len */%@AE@%%@NL@%
                                 MPFROM2SHORT(2,0),NULL);%@NL@%
         WinSetDlgItemShort(hwnd, ID_ENTRYFLD,(SHORT) cTowerSize,TRUE);%@NL@%
         return 0L;                           %@AB@%/* Allow normal focus setting */%@AE@%%@NL@%
%@NL@%
      case WM_COMMAND:%@NL@%
         switch(COMMANDMSG(&msg)->cmd)%@NL@%
         {%@NL@%
            case DID_OK:%@NL@%
               WinQueryDlgItemShort(hwnd, ID_ENTRYFLD,%@NL@%
                                    &sNewSize, TRUE); %@AB@%/* Get the short      */%@AE@%%@NL@%
               if(sNewSize>0 && sNewSize<=MAXDISKCNT) %@AB@%/* Set new Tower size */%@AE@%%@NL@%
               {%@NL@%
                  cTowerSize = (BYTE) sNewSize;%@NL@%
                  WinDismissDlg(hwnd,TRUE);%@NL@%
               }%@NL@%
               else                                   %@AB@%/* Invalid value      */%@AE@%%@NL@%
                  WinDismissDlg(hwnd,FALSE);%@NL@%
               return 0L;%@NL@%
%@NL@%
            case DID_CANCEL:%@NL@%
               WinDismissDlg(hwnd,FALSE);%@NL@%
               return 0L;%@NL@%
%@NL@%
            default:%@NL@%
               return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
         }%@NL@%
%@NL@%
      default:%@NL@%
         return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: SetupTowers()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  None%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine initializes the global arrays that represent the%@NL@%
%@AB@% *          hanoi stacks.  This involves placing all the disks on the%@NL@%
%@AB@% *          first peg, emptying the other 2 pegs and setting the associated%@NL@%
%@AB@% *          counts.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: Calling uses the global variable cTowerSize to determine%@NL@%
%@AB@% *                 how many disks there are.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID SetupTowers()%@NL@%
{%@NL@%
   USHORT cnt;%@NL@%
%@NL@%
   for(cnt=0;cnt<cTowerSize;cnt++)       %@AB@%/* Setup the intial post with disks */%@AE@%%@NL@%
      abTowers[0][cnt] = (BYTE)(cTowerSize-cnt-1);%@NL@%
%@NL@%
   abTowersNdx[0] = cTowerSize;          %@AB@%/* Set disk count for initial post  */%@AE@%%@NL@%
   abTowersNdx[1] = abTowersNdx[2] = 0;  %@AB@%/* Zero other post counts           */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%HELLO.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\OPENDLG\HELLO\HELLO.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * HELLO.C -- A simple program which calls the OpenDlg library%@NL@%
%@AB@% * Created by Microsoft Corporation, 1989%@NL@%
%@AB@% */%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_PM %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<opendlg.h> %@NL@%
%@AI@%#include %@AE@%"hello.h" %@NL@%
%@AB@%/*%@NL@%
%@AB@% * Globals%@NL@%
%@AB@% */%@AE@%%@NL@%
HAB     hAB;%@NL@%
HMQ     hMqHello;%@NL@%
HWND    hWndHello;%@NL@%
HWND    hWndHelloFrame;%@NL@%
CHAR    szClassName[]        = "Hello World";%@NL@%
CHAR        szMessage[]        = " - File Dialog Sample";%@NL@%
CHAR        szExtension[]        = "\\*.*";%@NL@%
CHAR        szHelp[]        = "Help would go here.";%@NL@%
DLF        vdlf;%@NL@%
HFILE        vhFile;%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Main routine...initializes window and message queue%@NL@%
%@AB@% */%@AE@%%@NL@%
int cdecl main( ) {%@NL@%
    QMSG qmsg;%@NL@%
    ULONG ctldata;%@NL@%
%@NL@%
    hAB = WinInitialize(0);%@NL@%
%@NL@%
    hMqHello = WinCreateMsgQueue(hAB, 0);%@NL@%
%@NL@%
    if (!WinRegisterClass( hAB, (PCH)szClassName, (PFNWP)HelloWndProc,%@NL@%
                CS_SIZEREDRAW, 0))%@NL@%
        return( 0 );%@NL@%
%@NL@%
    %@AB@%/* Create the window */%@AE@%%@NL@%
    ctldata = FCF_STANDARD & ~(FCF_ACCELTABLE);%@NL@%
    hWndHelloFrame = WinCreateStdWindow( HWND_DESKTOP, WS_VISIBLE, &ctldata,%@NL@%
                                         szClassName, szMessage,%@NL@%
                                         WS_VISIBLE, (HMODULE) NULL, ID_RESOURCE,%@NL@%
                                         (HWND FAR *)&hWndHello );%@NL@%
%@NL@%
    WinShowWindow( hWndHelloFrame, TRUE );%@NL@%
%@NL@%
    %@AB@%/* Poll messages from event queue */%@AE@%%@NL@%
    while( WinGetMsg( hAB, (PQMSG)&qmsg, (HWND)NULL, 0, 0 ) )%@NL@%
        WinDispatchMsg( hAB, (PQMSG)&qmsg );%@NL@%
%@NL@%
    %@AB@%/* Clean up */%@AE@%%@NL@%
    WinDestroyWindow( hWndHelloFrame );%@NL@%
    WinDestroyMsgQueue( hMqHello );%@NL@%
    WinTerminate( hAB );%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK HelloWndProc(hWnd, msg, mp1, mp2)%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This routine processes WM_COMMAND, WM_PAINT.  It passes%@NL@%
%@AB@% * everything else to the Default Window Procedure.%@NL@%
%@AB@% */%@AE@%%@NL@%
HWND hWnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    HPS                hPS;%@NL@%
    POINTL        pt;%@NL@%
    CHARBUNDLE        cb;%@NL@%
    RECTL        rcl;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            switch (COMMANDMSG(&msg)->cmd) {%@NL@%
%@NL@%
                case IDM_OPEN: %@AB@%/* Demonstrate Open... dialog call */%@AE@%%@NL@%
                    SetupDLF( &vdlf%@NL@%
                            , DLG_OPENDLG%@NL@%
                            , &vhFile%@NL@%
                            , szExtension%@NL@%
                            , NULL%@NL@%
                            , "Open Title"%@NL@%
                            , szHelp );%@NL@%
                     DlgFile(hWndHelloFrame, &vdlf);%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_SAVE: %@AB@%/* Demonstrate Save As... dialog call */%@AE@%%@NL@%
                    SetupDLF( &vdlf%@NL@%
                            , DLG_SAVEDLG%@NL@%
                            , &vhFile%@NL@%
                            , szExtension%@NL@%
                            , NULL%@NL@%
                            , "Save Title"%@NL@%
                            , szHelp);%@NL@%
                    lstrcpy( (PSZ)vdlf.szOpenFile, (PSZ)"foo.bar");%@NL@%
                    DlgFile(hWndHelloFrame, &vdlf);%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_ABOUT:%@NL@%
                    WinDlgBox(HWND_DESKTOP, hWnd, AboutDlgProc,%@NL@%
                              (HMODULE) NULL, IDD_ABOUT, NULL);%@NL@%
                    return 0;%@NL@%
%@NL@%
                default: break;%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case WM_PAINT:%@NL@%
            %@AB@%/* Open the presentation space */%@AE@%%@NL@%
            hPS = WinBeginPaint(hWnd, NULL, &rcl);%@NL@%
%@NL@%
            %@AB@%/* Fill the background with Dark Blue */%@AE@%%@NL@%
            WinFillRect(hPS, &rcl, CLR_DARKBLUE);%@NL@%
%@NL@%
            %@AB@%/* Write "Hello World" in Red */%@AE@%%@NL@%
            pt.x = pt.y = 0L;%@NL@%
            cb.lColor = CLR_RED;%@NL@%
            GpiSetAttrs(hPS, PRIM_CHAR, CBB_COLOR, 0L, &cb);%@NL@%
            GpiCharStringAt(hPS, &pt, (LONG)sizeof(szClassName)-1, szClassName);%@NL@%
%@NL@%
            %@AB@%/* Finish painting */%@AE@%%@NL@%
            WinEndPaint(hPS);%@NL@%
            break;%@NL@%
%@NL@%
        default: return WinDefWindowProc(hWnd, msg, mp1, mp2); break;%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
MRESULT CALLBACK AboutDlgProc(hDlg, msg, mp1, mp2)%@NL@%
%@AB@%/*%@NL@%
%@AB@%    About... dialog procedure%@NL@%
%@AB@%*/%@AE@%%@NL@%
HWND hDlg;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    switch(msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch(COMMANDMSG(&msg)->cmd) {%@NL@%
                case DID_OK: WinDismissDlg(hDlg, TRUE); break;%@NL@%
                default: break;%@NL@%
            }%@NL@%
        default: return WinDefDlgProc(hDlg, msg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%INIEDIT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\INIEDIT\INIEDIT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/******************************* Module Header ******************************\%@NL@%
%@AB@%* Module Name: IniEdit.c%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* PM OS2.ini Editor%@NL@%
%@AB@%*%@NL@%
%@AB@%* Allows adding, deleting and modifying of os2.ini entries through PM%@NL@%
%@AB@%* interface%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%LINT_ARGS                           // Include needed parts of PM %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT                       //    definitions %@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINBUTTONS %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%INCL_WINSHELLDATA %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%INCL_WINENTRYFIELDS %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINSWITCHLIST %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%INCL_GPIREGIONS %@NL@%
%@AI@%#define %@AE@%INCL_GPILCIDS %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@AI@%#define %@AE@%INCL_DEV %@NL@%
%@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"IniEdit.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************* Constants **********************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%STACK_SIZE            0x2000        // Stack size for second thread %@NL@%
%@AI@%#define %@AE@%UPPER_SEGMENT_LIMIT   0xFD00        // Amount of Segment used %@NL@%
%@NL@%
%@AB@%/******************************** Globals **********************************/%@AE@%%@NL@%
%@NL@%
char szIniEdit[] = "IniEdit";               // App String Name%@NL@%
%@NL@%
HAB       habIniEdit;                       // Handle Anchor Block%@NL@%
HMQ       hmqIniEdit;                       // Handle Message Queue%@NL@%
HWND      hwndIniEdit;                      // Main Client Window%@NL@%
HWND      hwndIniEditFrame;                 // Frame Window%@NL@%
HDC       hdcScreen;                        // DC for Client Window%@NL@%
HPS       hpsScreen;                        // PS for Client Window%@NL@%
%@NL@%
%@NL@%
USHORT    cAppNames = 0;                    // Count of App names in os2.ini%@NL@%
USHORT    usShift = 0;                      // DosHugeAlloc segment offsets%@NL@%
HWND      FocusWindow = (HWND)NULL;         // Focus of Dialog Box%@NL@%
USHORT    cxBorder;                         // System border width%@NL@%
USHORT    cyBorder;                         // System border height%@NL@%
%@NL@%
USHORT    usFormat = APP_FORM;              // Current Display format%@NL@%
USHORT    usPrintFormat = APP_FORM;         // Format for Printing%@NL@%
USHORT    usLineHeight = 12;                // Current font Height%@NL@%
HWND      hwndList = (HWND)NULL;            // Handle of Main ListBox%@NL@%
HWND      hwndMenu = (HWND)NULL;            // Handle of Main Menu%@NL@%
%@NL@%
PGROUPSTRUCT  pGroups;                      // Pointer to String Groups%@NL@%
PPAIRSTRUCT   pPairsBase;                   // Pointer to Key-Value Pairs%@NL@%
PPAIRSTRUCT   pPairsAlloc;                  // Pointer to next Avail Memory%@NL@%
PBYTE         pPrintStack;                  // Pointer to Print Thread Stack%@NL@%
%@NL@%
%@AI@%#define %@AE@%HOLD_LEN 4096 %@NL@%
CHAR          achNames[HOLD_LEN];           // Array of Character from Query%@NL@%
CHAR          szBuf[2 * MAX_STRING_LEN];        // Character buffer for Pairs%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Function Decls ******************************/%@AE@%%@NL@%
%@NL@%
VOID    ProcessMenuItem( HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2 );%@NL@%
VOID    cdecl main( VOID );%@NL@%
VOID    IniEditPaint( VOID );%@NL@%
VOID    ReadIni( VOID );%@NL@%
VOID    OldProfilePrint( VOID );%@NL@%
VOID    UpdateListBox( BOOL fRead, USHORT usForm );%@NL@%
%@NL@%
MRESULT _loadds EXPENTRY IniEditWndProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Function Header *****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* main%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Do initialization then do a message loop%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID cdecl main()%@NL@%
{%@NL@%
%@NL@%
    QMSG         qmsg;                      // Current Queue Message%@NL@%
    ULONG        fcf;                       // Frame Control Flags%@NL@%
    SIZEL        sizel;                     // Size of PS%@NL@%
    RECTL        rclWindow;                 // Size Rect for ListBox Window%@NL@%
    SEL          sel;                       // Selector of allocated segments%@NL@%
    SWCNTRL      swcntrl;                   // Switch Control Block%@NL@%
    FONTMETRICS  fmetrics;                  // FontMetrics of current font%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*** Set up and Initialization ***/%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Initialize the anchor block handle */%@AE@%%@NL@%
    habIniEdit = WinInitialize(0);%@NL@%
%@NL@%
    %@AB@%/* Create the message queue */%@AE@%%@NL@%
    hmqIniEdit = WinCreateMsgQueue(habIniEdit, 0);%@NL@%
%@NL@%
    %@AB@%/* Register the window class for the IniEdit window */%@AE@%%@NL@%
    WinRegisterClass(habIniEdit, (PCH)szIniEdit, IniEditWndProc,%@NL@%
            CS_SIZEREDRAW, 0);%@NL@%
%@NL@%
    %@AB@%/* Create the window for IniEdit */%@AE@%%@NL@%
    fcf = FCF_TITLEBAR | FCF_MINMAX | FCF_SYSMENU | FCF_SIZEBORDER | FCF_MENU%@NL@%
        | FCF_SHELLPOSITION | FCF_ACCELTABLE | FCF_ICON;%@NL@%
%@NL@%
    hwndIniEditFrame = WinCreateStdWindow( HWND_DESKTOP, WS_VISIBLE,%@NL@%
        (PVOID)&fcf, (PSZ)szIniEdit, (PSZ)szIniEdit, WS_VISIBLE,%@NL@%
        (HMODULE)NULL, IDI_INIEDIT, (PHWND)&hwndIniEdit);%@NL@%
%@NL@%
    %@AB@%/* Create a DC for the IniEdit window */%@AE@%%@NL@%
    hdcScreen = WinOpenWindowDC(hwndIniEdit);%@NL@%
%@NL@%
    %@AB@%/* also create a screen PS */%@AE@%%@NL@%
%@NL@%
    sizel.cx= 0L;   // To use the default screen page size.%@NL@%
    sizel.cy= 0L;%@NL@%
%@NL@%
    if( (hpsScreen = GpiCreatePS( habIniEdit, hdcScreen, &sizel,%@NL@%
            (PU_PELS | GPIF_DEFAULT | GPIT_MICRO | GPIA_ASSOC ))) == (HPS)NULL )%@NL@%
        {%@NL@%
                ;%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Initially set the keyboard focus to us */%@AE@%%@NL@%
    WinSetFocus(HWND_DESKTOP, hwndIniEdit);%@NL@%
%@NL@%
    %@AB@%/* get the font size */%@AE@%%@NL@%
    GpiQueryFontMetrics( hpsScreen, (LONG)sizeof( FONTMETRICS ), &fmetrics );%@NL@%
    usLineHeight = (USHORT)(fmetrics.lMaxDescender + fmetrics.lMaxBaselineExt);%@NL@%
%@NL@%
    %@AB@%/* get the system widths of a border */%@AE@%%@NL@%
    cxBorder = (USHORT) WinQuerySysValue(HWND_DESKTOP, SV_CXBORDER);%@NL@%
    cyBorder = (USHORT) WinQuerySysValue(HWND_DESKTOP, SV_CYBORDER);%@NL@%
%@NL@%
    %@AB@%/* this menu handle is often used */%@AE@%%@NL@%
    hwndMenu = WinWindowFromID( hwndIniEditFrame, FID_MENU );%@NL@%
%@NL@%
    %@AB@%/* add program to switch list */%@AE@%%@NL@%
    swcntrl.hwnd             = hwndIniEditFrame;%@NL@%
    swcntrl.hwndIcon         = NULL;%@NL@%
    swcntrl.hprog            = NULL;%@NL@%
    swcntrl.idProcess        = 0;%@NL@%
    swcntrl.idSession        = 0;%@NL@%
    swcntrl.uchVisibility    = 0;%@NL@%
    swcntrl.fbJump           = 0;%@NL@%
    strcpy( swcntrl.szSwtitle, szIniEdit);%@NL@%
    swcntrl.fReserved        = 0;%@NL@%
%@NL@%
    WinAddSwitchEntry( &swcntrl );%@NL@%
%@NL@%
    %@AB@%/* Create main list box in main window */%@AE@%%@NL@%
    WinQueryWindowRect( hwndIniEdit, &rclWindow);%@NL@%
    rclWindow.yTop -= usLineHeight;%@NL@%
    rclWindow.yTop += cyBorder;%@NL@%
    rclWindow.xRight += 2*cxBorder;%@NL@%
    hwndList = WinCreateWindow( hwndIniEdit,            // parent%@NL@%
                                WC_LISTBOX,             // class%@NL@%
                                (PSZ)"Scroll",          // name%@NL@%
                                LS_NOADJUSTPOS,         // style%@NL@%
                                -cxBorder, -cyBorder,   // position%@NL@%
                                (USHORT)rclWindow.xRight,%@NL@%
                                (USHORT)rclWindow.yTop,%@NL@%
                                hwndIniEditFrame,       // Owner%@NL@%
                                HWND_TOP,               // InsertBehind%@NL@%
                                IDI_LIST,               // ID%@NL@%
                                (PVOID)NULL,            // pCtlData,%@NL@%
                                (PVOID)NULL);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*** Memory Allocation ***/%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Alloc the needed space for the groups */%@AE@%%@NL@%
    if( DosAllocSeg( 32000, &sel, 0) )%@NL@%
        ErrMessage( "main: DosAlloc for pGroup failed" );%@NL@%
    pGroups = MAKEP( sel, 0);%@NL@%
%@NL@%
    if( DosAllocHuge( 4, 0, &sel, 0, 0) )%@NL@%
        ErrMessage( "main: DosAlloc for pPairs failed" );%@NL@%
    pPairsAlloc = pPairsBase = MAKEP( sel, 0);%@NL@%
%@NL@%
    %@AB@%/* create a stack for second thread */%@AE@%%@NL@%
    if( DosAllocSeg( STACK_SIZE, &sel, 0) )%@NL@%
        ErrMessage( "main: DosAlloc for Stack failed" );%@NL@%
    pPrintStack = MAKEP( sel, 0);%@NL@%
%@NL@%
    DosGetHugeShift( &usShift );%@NL@%
%@NL@%
    %@AB@%/* read in os2.ini and fill in list box */%@AE@%%@NL@%
    UpdateListBox( TRUE, APP_FORM );%@NL@%
%@NL@%
    WinShowWindow( hwndList, TRUE );%@NL@%
%@NL@%
    %@AB@%/* Process messages for the window */%@AE@%%@NL@%
    while ( WinGetMsg(habIniEdit, (PQMSG)&qmsg, (HWND)NULL, 0, 0 ) )%@NL@%
        {%@NL@%
%@NL@%
        %@AB@%/* Dispatch the message */%@AE@%%@NL@%
        WinDispatchMsg(habIniEdit, (PQMSG)&qmsg);%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*** CleanUp ***/%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Destroy the IniEdit window and message queue */%@AE@%%@NL@%
    GpiDestroyPS( hpsScreen );%@NL@%
    WinDestroyWindow(hwndIniEditFrame);%@NL@%
    WinDestroyMsgQueue(hmqIniEdit);%@NL@%
%@NL@%
    %@AB@%/* Exit PM */%@AE@%%@NL@%
    WinTerminate( habIniEdit );%@NL@%
    DosExit( EXIT_PROCESS, 0 );%@NL@%
%@NL@%
}  %@AB@%/* main */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************** Function Header ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* ReadIni%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Reads in OS2.ini%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID ReadIni()%@NL@%
{%@NL@%
    USHORT    cchNames;                     // Count of Character from Query%@NL@%
    USHORT    Index[MAX_APP_NAMES];         // Index of Names into achNames%@NL@%
    USHORT    cPairs;                       // Count of pairs in current AppName%@NL@%
    ULONG     ul;%@NL@%
    USHORT    i,j;                          // Loop Counters%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Reset Count of App Names */%@AE@%%@NL@%
    cAppNames = 0;%@NL@%
%@NL@%
    %@AB@%/* Reset memory available pointer to Base */%@AE@%%@NL@%
    pPairsAlloc = pPairsBase;%@NL@%
%@NL@%
    %@AB@%/* Determine number of characters in app Names Strings */%@AE@%%@NL@%
    WinQueryProfileSize( habIniEdit, NULL, NULL, &cchNames );%@NL@%
%@NL@%
    %@AB@%/* Read in the App Name strings */%@AE@%%@NL@%
    WinQueryProfileString( habIniEdit, NULL, NULL, " ", achNames, cchNames );%@NL@%
%@NL@%
    %@AB@%/*** Find the starting index of each App ***/%@AE@%%@NL@%
%@NL@%
    %@AB@%/* step through each string in set of app characters%@NL@%
%@AB@%     * adding length of current string to find begining of next string%@NL@%
%@AB@%     * also store each App Name into szAppName element of Group%@NL@%
%@AB@%     */%@AE@%%@NL@%
    for( i=0; i<cchNames; i += (strlen(pGroups[cAppNames-1].szAppName)+1) )%@NL@%
        {%@NL@%
        if( achNames[i] != (char)0 )%@NL@%
            {%@NL@%
            strcpy( pGroups[cAppNames++].szAppName, &achNames[i]);%@NL@%
            }  %@AB@%/* if */%@AE@%%@NL@%
        else%@NL@%
            if( achNames[i+1] == (char)0 )%@NL@%
                break;%@NL@%
        }  %@AB@%/* for */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*** Read elements of each App Name ***/%@AE@%%@NL@%
    for( i=0; i<cAppNames; i++ )%@NL@%
        {%@NL@%
        %@AB@%/* Get number of Character Associated with App Name */%@AE@%%@NL@%
        WinQueryProfileSize( habIniEdit, pGroups[i].szAppName, NULL, &cchNames );%@NL@%
%@NL@%
        %@AB@%/* Enumerate all KeyNames for this app name */%@AE@%%@NL@%
        WinQueryProfileString( habIniEdit, pGroups[i].szAppName, NULL, " ", achNames, HOLD_LEN );%@NL@%
%@NL@%
        %@AB@%/* Count the number of key Names */%@AE@%%@NL@%
        cPairs = 0;%@NL@%
        for( j=0; j<cchNames; j++)%@NL@%
            if( achNames[j] != (CHAR)0 )%@NL@%
                {%@NL@%
                Index[cPairs++] = j;%@NL@%
                j += strlen( &achNames[j] );%@NL@%
                }%@NL@%
%@NL@%
        pGroups[i].cKeys = cPairs;%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Make sure we can fit the entire structure into our current%@NL@%
%@AB@%         * segment, if not, lets jump to the next segment%@NL@%
%@AB@%         */%@AE@%%@NL@%
        ul =  sizeof(PAIRSTRUCT) * cPairs;%@NL@%
        if ((ul + (ULONG)OFFSETOF(pPairsAlloc)) >= 0x10000L)%@NL@%
            pPairsAlloc = MAKEP( (HIUSHORT(pPairsAlloc)+(1<<usShift)), 0);%@NL@%
%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* Allocate the number of pair structures for the current group */%@AE@%%@NL@%
        pGroups[i].pPairs = pPairsAlloc;%@NL@%
%@NL@%
        // pPairsAlloc += sizeof(PAIRSTRUCT)*cPairs;%@NL@%
        // Remember that incrementing a pointer automatically mult by size of item%@NL@%
        pPairsAlloc += cPairs;%@NL@%
%@NL@%
        %@AB@%/* Step to next segment if near end of current segment */%@AE@%%@NL@%
        if( LOUSHORT(pPairsAlloc) > UPPER_SEGMENT_LIMIT)%@NL@%
            {%@NL@%
            pPairsAlloc = MAKEP( (HIUSHORT(pPairsAlloc)+(1<<usShift)), 0);%@NL@%
            }%@NL@%
%@NL@%
        %@AB@%/* Store the KeyName into the pair structure */%@AE@%%@NL@%
        for( j=0; j<cPairs; j++ )%@NL@%
            {%@NL@%
            strcpy( pGroups[i].pPairs[j].szKey, &achNames[Index[j]] );%@NL@%
%@NL@%
            %@AB@%/* store the key value */%@AE@%%@NL@%
            WinQueryProfileString( habIniEdit, pGroups[i].szAppName,%@NL@%
                     pGroups[i].pPairs[j].szKey, " ",%@NL@%
                     pGroups[i].pPairs[j].szValue, MAX_STRING_LEN );%@NL@%
%@NL@%
            }%@NL@%
        }  %@AB@%/* each App Name */%@AE@%%@NL@%
%@NL@%
}  %@AB@%/* ReadIni */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************** Function Header ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* ProcessMenuItem%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Act on the corresponding Menu Item Choosen%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID ProcessMenuItem( HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2 )%@NL@%
{%@NL@%
    TID  Tid;                               // ID of new thread; Not used%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Switch on the Menu Item choosen */%@AE@%%@NL@%
    switch( LOUSHORT( mp1 ) )%@NL@%
        {%@NL@%
        case IDMI_SHOW_ALL:%@NL@%
        case IDMI_SHOW_APPNAMES:%@NL@%
            usFormat = (LOUSHORT(mp1) == IDMI_SHOW_ALL);%@NL@%
            UpdateListBox( FALSE, usFormat ? ALL_FORM : APP_FORM );%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_SEARCH:%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndIniEditFrame, (PFNWP)SearchWndProc,%@NL@%
                            (HMODULE)NULL, IDD_SEARCH, (PVOID)NULL);%@NL@%
            break;%@NL@%
%@NL@%
        case IDMI_EDIT_DELETE_KEY:%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndIniEditFrame, (PFNWP)DelKeyWndProc,%@NL@%
                            (HMODULE)NULL, IDD_DEL_KEY, (PVOID)NULL);%@NL@%
            UpdateListBox( TRUE, usFormat ? ALL_FORM : APP_FORM );%@NL@%
            break;%@NL@%
%@NL@%
        case IDMI_EDIT_DELETE_APP:%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndIniEditFrame, (PFNWP)DelAppWndProc,%@NL@%
                            (HMODULE)NULL, IDD_DEL_APP, (PVOID)NULL);%@NL@%
            UpdateListBox( TRUE, usFormat ? ALL_FORM : APP_FORM );%@NL@%
            break;%@NL@%
%@NL@%
        case IDMI_EDIT_ADD_KEY:%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndIniEditFrame, (PFNWP)AddKeyWndProc,%@NL@%
                            (HMODULE)NULL, IDD_ADD_KEY, (PVOID)NULL);%@NL@%
            UpdateListBox( TRUE, usFormat ? ALL_FORM : APP_FORM );%@NL@%
            break;%@NL@%
%@NL@%
        case IDMI_EDIT_CHANGE:%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndIniEditFrame, (PFNWP)ChangeKeyWndProc,%@NL@%
                            (HMODULE)NULL, IDD_CHANGE_KEY, (PVOID)NULL);%@NL@%
            UpdateListBox( TRUE, usFormat ? ALL_FORM : APP_FORM );%@NL@%
            break;%@NL@%
%@NL@%
        case IDMI_PRINT_ALL:%@NL@%
        case IDMI_PRINT_APP:%@NL@%
            usPrintFormat = LOUSHORT(mp1) == IDMI_PRINT_ALL ? ALL_FORM : APP_FORM;%@NL@%
            if( DosCreateThread( PrintThread, &Tid, ((PBYTE)(pPrintStack)+STACK_SIZE) ) )%@NL@%
                ErrMessage("StartThread2: DosCreateThread Failed");%@NL@%
            break;%@NL@%
%@NL@%
        case IDMI_REFRESH:%@NL@%
            UpdateListBox( TRUE, usFormat );%@NL@%
            break;%@NL@%
%@NL@%
        case IDMI_ABOUT:%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndIniEditFrame, (PFNWP)DelAppWndProc,%@NL@%
                            (HMODULE)NULL, IDD_ABOUT, (PVOID)NULL);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            WinDefWindowProc(hwnd, msg, mp1, mp2);%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
        }  %@AB@%/* switch */%@AE@%%@NL@%
%@NL@%
}  %@AB@%/* ProcessMenuItem */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************** Function Header ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* UpdateListBox%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Update Main List Box to correct state%@NL@%
%@AB@%*    May Also:%@NL@%
%@AB@%*    - Check correct menu item%@NL@%
%@AB@%*    - Repaint title of List Box%@NL@%
%@AB@%*    - ReRead os2.ini file%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID UpdateListBox( BOOL fReadIni, USHORT usNewFormat )%@NL@%
{%@NL@%
    USHORT    i,j;                          // Loop Counters%@NL@%
    USHORT    Index;                        // Index into ListBox%@NL@%
    static    USHORT    usLastFormat = -1;  // Last displayed format%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Check the correct item if format changed */%@AE@%%@NL@%
    if( usLastFormat != usNewFormat )%@NL@%
        {%@NL@%
        WinSendMsg( hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(IDMI_SHOW_ALL, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, usFormat ? MIA_CHECKED:FALSE));%@NL@%
%@NL@%
        WinSendMsg( hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(IDMI_SHOW_APPNAMES, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, (!usFormat) ? MIA_CHECKED:FALSE));%@NL@%
        usLastFormat = usNewFormat;%@NL@%
%@NL@%
        WinSendMsg( hwndIniEdit, WM_PAINT, (MPARAM)NULL, (MPARAM)NULL );%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Turn off list box updates */%@AE@%%@NL@%
    WinEnableWindowUpdate( hwndList, FALSE );%@NL@%
%@NL@%
    %@AB@%/* Remove all items from list box */%@AE@%%@NL@%
    WinSendMsg( hwndList, LM_DELETEALL, (MPARAM)0, (MPARAM)0 );%@NL@%
%@NL@%
    %@AB@%/* ReRead os2.ini if needed */%@AE@%%@NL@%
    if( fReadIni )%@NL@%
        ReadIni();%@NL@%
%@NL@%
    %@AB@%/* Add elements to listbox */%@AE@%%@NL@%
    if( usNewFormat == ALL_FORM )%@NL@%
        {%@NL@%
%@NL@%
        %@AB@%/* Insert all app Names */%@AE@%%@NL@%
        for( i=0; i<cAppNames; i++ )%@NL@%
            {%@NL@%
            Index = SHORT1FROMMR(WinSendMsg( hwndList, LM_INSERTITEM,%@NL@%
                    MPFROM2SHORT(LIT_END, NULL),%@NL@%
                    MPFROMP(pGroups[i].szAppName) ));%@NL@%
%@NL@%
            WinSendMsg( hwndList, LM_SETITEMHANDLE,%@NL@%
                    MPFROMSHORT(Index),%@NL@%
                    MPFROMSHORT(i) );%@NL@%
%@NL@%
            %@AB@%/* Insert Key Value Pairs for App Name */%@AE@%%@NL@%
            for( j=0; j<pGroups[i].cKeys; j++ )%@NL@%
                {%@NL@%
                sprintf( szBuf, "     %s: %s", pGroups[i].pPairs[j].szKey,%@NL@%
                        pGroups[i].pPairs[j].szValue );%@NL@%
                Index = SHORT1FROMMR(WinSendMsg( hwndList, LM_INSERTITEM,%@NL@%
                        MPFROM2SHORT(LIT_END, NULL),%@NL@%
                        MPFROMP(szBuf) ));%@NL@%
%@NL@%
                WinSendMsg( hwndList, LM_SETITEMHANDLE,%@NL@%
                        MPFROMSHORT(Index),%@NL@%
                        MPFROM2SHORT(i,j) );%@NL@%
%@NL@%
                }%@NL@%
            }%@NL@%
        }  %@AB@%/* if */%@AE@%%@NL@%
    else%@NL@%
        {%@NL@%
        %@AB@%/* Insert all app Names */%@AE@%%@NL@%
        for( i=0; i<cAppNames; i++ )%@NL@%
            {%@NL@%
            WinSendMsg( hwndList, LM_INSERTITEM,%@NL@%
                    MPFROM2SHORT(LIT_SORTASCENDING, NULL),%@NL@%
                    MPFROMP(pGroups[i].szAppName) );%@NL@%
            }%@NL@%
        }  %@AB@%/* else */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Do All repainting of ListBox */%@AE@%%@NL@%
    WinEnableWindowUpdate( hwndList, TRUE );%@NL@%
%@NL@%
}  %@AB@%/* UpdateListBox */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************** Function Header ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* IniEditPaint%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Window Paint Routine%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID IniEditPaint()%@NL@%
{%@NL@%
    RECTL     rclWindow;                    // Current size of Main Window%@NL@%
    RECTL     rclBlit;                      // Size of Area to Blank for Title%@NL@%
    CHAR      szShowMode[MAX_STRING_LEN];   // String Description of mode%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Get the size of the whole window */%@AE@%%@NL@%
    WinQueryWindowRect( hwndIniEdit, &rclWindow );%@NL@%
%@NL@%
    %@AB@%/* Paint the window Title Area */%@AE@%%@NL@%
    rclBlit = rclWindow;%@NL@%
    rclBlit.yBottom = rclBlit.yTop - usLineHeight;%@NL@%
%@NL@%
    GpiBitBlt( hpsScreen, (HPS)NULL, 2L, (PPOINTL)&rclBlit, ROP_ONE, (LONG)NULL);%@NL@%
%@NL@%
    %@AB@%/* Write the Title */%@AE@%%@NL@%
    strcpy( szShowMode, usFormat == APP_FORM ? SZAPP : SZALL );%@NL@%
    WinDrawText( hpsScreen, strlen(szShowMode), szShowMode, &rclWindow,%@NL@%
            CLR_BLUE, CLR_WHITE, DT_CENTER|DT_TOP);%@NL@%
%@NL@%
}  %@AB@%/* IniEditPaint */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************** Function Header ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* IniEditWndProc%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Window Proc for IniEdit%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
MRESULT _loadds EXPENTRY IniEditWndProc(HWND hwnd, USHORT msg,%@NL@%
        MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
%@NL@%
    CHAR      szBuf[MAX_STRING_LEN];        // Input character Buffer%@NL@%
    CHAR      szBuf2[MAX_STRING_LEN];       // Second Input Character Buffer%@NL@%
    USHORT    Index;                        // Index of Current ListBox Item%@NL@%
    USHORT    TopIndex;                     // Current Top Item in ListBox%@NL@%
    ULONG     Handle;                       // ListBox Item Handle Info%@NL@%
    HWND      hwndDialog;                   // Window handle of Dailog Box%@NL@%
    HWND      hwndText;                     // Handle of current text window%@NL@%
    HPS       hpsPaint;                     // PS to Paint%@NL@%
    RECTL     rclPaint;                     // Rect in hpsPaint to Paint%@NL@%
    BOOL      fScroll = FALSE;              // Scroll List Box Flag%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Switch on message being processed */%@AE@%%@NL@%
    switch( msg )%@NL@%
        {%@NL@%
        case WM_PAINT:%@NL@%
            %@AB@%/* Paint the IniEdit window portion not covered by List Box */%@AE@%%@NL@%
            hpsPaint = WinBeginPaint(hwnd, (HPS)NULL, &rclPaint);%@NL@%
            IniEditPaint();%@NL@%
            WinEndPaint(hpsPaint);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            %@AB@%/* If menu item call Processing Routine */%@AE@%%@NL@%
            if( LOUSHORT( mp2 ) == CMDSRC_MENU )%@NL@%
                ProcessMenuItem( hwnd, msg, mp1, mp2 );%@NL@%
%@NL@%
            %@AB@%/* If accelorator call appropriate routine */%@AE@%%@NL@%
            if( LOUSHORT( mp2 ) == CMDSRC_ACCELERATOR )%@NL@%
                {%@NL@%
                switch( LOUSHORT( mp1 ) )%@NL@%
                    {%@NL@%
                    case IDDI_SEARCH_NEXT:%@NL@%
                        FindNext();%@NL@%
                        break;%@NL@%
                    }%@NL@%
                }%@NL@%
            break;%@NL@%
%@NL@%
        case WM_SIZE:%@NL@%
            %@AB@%/* Put the list box in the correct location of the window */%@AE@%%@NL@%
            if( hwndList != (HWND)NULL )%@NL@%
                %@AB@%/* The position is set to fill the client, except for the */%@AE@%%@NL@%
                %@AB@%/* area at the top for some text.  In addition, the       */%@AE@%%@NL@%
                %@AB@%/* rectangle is outset by a border width on all dimensions*/%@AE@%%@NL@%
                %@AB@%/* except for the top so that the list box border is      */%@AE@%%@NL@%
                %@AB@%/* "tucked" under the clients border and doesn't cause    */%@AE@%%@NL@%
                %@AB@%/* there to be a double thick border around it.           */%@AE@%%@NL@%
                WinSetWindowPos( hwndList, HWND_TOP, -cxBorder, -cyBorder,%@NL@%
                        SHORT1FROMMP(mp2)+(2*cxBorder),%@NL@%
                        SHORT2FROMMP(mp2)-usLineHeight + cyBorder,%@NL@%
                        SWP_SIZE | SWP_MOVE );%@NL@%
            break;%@NL@%
%@NL@%
        case WM_CONTROL:%@NL@%
            %@AB@%/* Switch on Control activated */%@AE@%%@NL@%
            switch( SHORT1FROMMP(mp1) )%@NL@%
                {%@NL@%
%@NL@%
                %@AB@%/*** Process List Box Activity ***/%@AE@%%@NL@%
                case IDI_LIST:%@NL@%
                    %@AB@%/* was it a double click? */%@AE@%%@NL@%
                    if( SHORT2FROMMP(mp1) == LN_ENTER )%@NL@%
                        {%@NL@%
                        %@AB@%/* get the item clicked on */%@AE@%%@NL@%
                        Index = SHORT1FROMMR(WinSendMsg( hwndList, LM_QUERYSELECTION,%@NL@%
                                (MPARAM)0, (MPARAM)0 ));%@NL@%
%@NL@%
                        %@AB@%/* grab its text */%@AE@%%@NL@%
                        WinSendMsg( hwndList, LM_QUERYITEMTEXT,%@NL@%
                                MPFROM2SHORT(Index, MAX_STRING_LEN), MPFROMP(szBuf) );%@NL@%
%@NL@%
                        %@AB@%/* if in APP form toggle to ALL form */%@AE@%%@NL@%
                        if( usFormat == APP_FORM )%@NL@%
                            {%@NL@%
                            usFormat = ALL_FORM;%@NL@%
                            fScroll = TRUE;%@NL@%
                            }%@NL@%
                        else%@NL@%
                            {%@NL@%
                            %@AB@%/* if an App name was choosen then go to APP form */%@AE@%%@NL@%
                            if( szBuf[0] != ' ')%@NL@%
                                {%@NL@%
                                usFormat = APP_FORM;%@NL@%
                                fScroll = TRUE;%@NL@%
                                }%@NL@%
                            else%@NL@%
                                %@AB@%/* A Key Value Pair was double clicked%@NL@%
%@AB@%                                 * allow editing of key Value%@NL@%
%@AB@%                                 */%@AE@%%@NL@%
                                {%@NL@%
%@NL@%
                                FocusWindow = (HWND)1;%@NL@%
%@NL@%
                                hwndDialog = WinLoadDlg( HWND_DESKTOP,%@NL@%
                                    hwndIniEditFrame, ChangeKeyWndProc,%@NL@%
                                    (HMODULE)NULL, IDD_CHANGE_KEY, NULL);%@NL@%
%@NL@%
                                Handle = (ULONG)WinSendMsg( hwndList, LM_QUERYITEMHANDLE,%@NL@%
                                    MPFROMSHORT(Index), (MPARAM)NULL );%@NL@%
%@NL@%
                                hwndText = WinWindowFromID( hwndDialog, IDDI_CHANGE_KEY_TEXT_APP );%@NL@%
                                WinSendMsg(hwndText, EM_SETTEXTLIMIT,%@NL@%
                                        MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
                                WinSetWindowText( hwndText, pGroups[LOUSHORT(Handle)].szAppName);%@NL@%
%@NL@%
                                %@AB@%/* note bug in PMWin GPs if full segment */%@AE@%%@NL@%
                                hwndText = WinWindowFromID( hwndDialog, IDDI_CHANGE_KEY_TEXT_KEY );%@NL@%
                                WinSendMsg(hwndText, EM_SETTEXTLIMIT,%@NL@%
                                        MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
                                strcpy( szBuf2, pGroups[LOUSHORT(Handle)].pPairs[HIUSHORT(Handle)].szKey );%@NL@%
                                WinSetWindowText( hwndText, szBuf2 );%@NL@%
%@NL@%
                                hwndText = WinWindowFromID( hwndDialog, IDDI_CHANGE_KEY_TEXT_VAL );%@NL@%
                                WinSendMsg(hwndText, EM_SETTEXTLIMIT,%@NL@%
                                        MPFROMSHORT(MAX_STRING_LEN), 0L);%@NL@%
                                strcpy( szBuf2, pGroups[LOUSHORT(Handle)].pPairs[HIUSHORT(Handle)].szValue );%@NL@%
                                WinSetWindowText( hwndText, szBuf2 );%@NL@%
%@NL@%
                                WinPostMsg( hwndText, EM_SETSEL,%@NL@%
                                        MPFROM2SHORT(0, strlen(szBuf2)), (MPARAM)0 );%@NL@%
%@NL@%
                                if( WinProcessDlg( hwndDialog ) == IDDI_CHANGE_KEY_OK )%@NL@%
                                    {%@NL@%
                                    TopIndex = SHORT1FROMMR(WinSendMsg( hwndList, LM_QUERYTOPINDEX,%@NL@%
                                         (MPARAM)NULL, (MPARAM)NULL ));%@NL@%
%@NL@%
                                    UpdateListBox( TRUE, usFormat );%@NL@%
%@NL@%
                                    %@AB@%/* scroll to top */%@AE@%%@NL@%
                                    WinSendMsg( hwndList, LM_SETTOPINDEX,%@NL@%
                                         MPFROMSHORT(TopIndex), (MPARAM)NULL );%@NL@%
%@NL@%
                                    %@AB@%/* make the item selected */%@AE@%%@NL@%
                                    WinSendMsg( hwndList, LM_SELECTITEM,%@NL@%
                                            MPFROMSHORT(Index), MPFROMSHORT(TRUE) );%@NL@%
%@NL@%
                                    %@AB@%/* make selected */%@AE@%%@NL@%
                                    }%@NL@%
%@NL@%
                                WinDestroyWindow( hwndDialog );%@NL@%
                                }%@NL@%
                            }%@NL@%
%@NL@%
                        %@AB@%/* Make the double clicked item selected in new form */%@AE@%%@NL@%
                        if( fScroll )%@NL@%
                            {%@NL@%
                            %@AB@%/* put in correct form */%@AE@%%@NL@%
                            UpdateListBox( FALSE, usFormat );%@NL@%
%@NL@%
                            %@AB@%/* get the index of the item clicked on */%@AE@%%@NL@%
                            Index = SHORT1FROMMR(WinSendMsg( hwndList, LM_SEARCHSTRING,%@NL@%
                                    MPFROM2SHORT(LSS_SUBSTRING, LIT_FIRST),%@NL@%
                                    MPFROMP(szBuf) ));%@NL@%
%@NL@%
                            %@AB@%/* scroll that item to the top */%@AE@%%@NL@%
                            WinSendMsg( hwndList, LM_SETTOPINDEX,%@NL@%
                                    MPFROMSHORT(Index), (MPARAM)NULL );%@NL@%
%@NL@%
                            %@AB@%/* make the item selected */%@AE@%%@NL@%
                            WinSendMsg( hwndList, LM_SELECTITEM,%@NL@%
                                    MPFROMSHORT(Index), MPFROMSHORT(TRUE) );%@NL@%
                            }%@NL@%
                        }  %@AB@%/* if ENTER */%@AE@%%@NL@%
                }%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return WinDefWindowProc(hwnd, msg, mp1, mp2);%@NL@%
            break;%@NL@%
        }%@NL@%
%@NL@%
    return 0L;%@NL@%
%@NL@%
}  %@AB@%/* IniEditWndProc */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%INIT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\OPENDLG\INIT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* INIT.C -- Library initialization funcitons%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"tool.h" %@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function initializes the file dialog library (by loading strings).%@NL@%
%@AB@%*%@NL@%
%@AB@%* Note: Initialization will fail if CCHSTRINGSMAX is smaller than the%@NL@%
%@AB@%*       space taken up by all strings in the .rc file.  Fix by increasing%@NL@%
%@AB@%*       CCHSTRINGSMAX in wintool.h and maybe also the initial heap size%@NL@%
%@AB@%*       in wintool.def.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns:%@NL@%
%@AB@%*   TRUE if initialization successful%@NL@%
%@AB@%*   FALSE otherwise%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL PASCAL InitLibrary()%@NL@%
{%@NL@%
    int i;%@NL@%
    int cch;%@NL@%
    PSTR pch;%@NL@%
    PSTR pmem;%@NL@%
    int cchRemaining;%@NL@%
%@NL@%
    %@AB@%/* allocate memory for strings */%@AE@%%@NL@%
    if (!(pch = (pmem = WinAllocMem(vhheap, cchRemaining = CCHSTRINGSMAX))))%@NL@%
        return FALSE;%@NL@%
%@NL@%
    %@AB@%/* load strings from resource file */%@AE@%%@NL@%
    for (i = 0; i < CSTRINGS; i++) {%@NL@%
        cch = 1 + WinLoadString(HABX, vhModule, i, cchRemaining, (PSZ)pch);%@NL@%
        if (cch < 2)%@NL@%
            %@AB@%/* loadstring failed */%@AE@%%@NL@%
            return FALSE;%@NL@%
        vrgsz[i] = pch;%@NL@%
        pch += cch;%@NL@%
%@NL@%
        if ((cchRemaining -= cch) <= 0)%@NL@%
            %@AB@%/* ran out of space */%@AE@%%@NL@%
            return FALSE;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* reallocate string space to size actually needed */%@AE@%%@NL@%
    WinReallocMem(vhheap, pmem, CCHSTRINGSMAX, CCHSTRINGSMAX - cchRemaining);%@NL@%
%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%JIGSAW.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\JIGSAW\JIGSAW.C%@AE@%%@NL@%
%@NL@%
%@AB@%/********************************** Jigsaw  ***********************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Created 1988, Microsoft Corporation.                                       */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Purpose:  To illustrate the use of Gpi retained segments.                      */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Summary:  This program provides a jigsaw puzzle, based on a decomposition  */%@AE@%%@NL@%
%@AB@%/*   of an arbitrary bitmap loaded from a file.  The user can jumble the      */%@AE@%%@NL@%
%@AB@%/*   pieces, then drag them individually by means of the mouse.  The image    */%@AE@%%@NL@%
%@AB@%/*   can be zoomed in and out and scrolled up/down and left/right.              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/*   Each piece of the puzzle is a retained segment.  When a piece is              */%@AE@%%@NL@%
%@AB@%/*   selected for dragging, it is made dynamic.  A menu option allows the     */%@AE@%%@NL@%
%@AB@%/*   selected piece to be dragged as an outline or as a normal-looking piece. */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/*   Individual pieces are made to "move" by changing their model transforms. */%@AE@%%@NL@%
%@AB@%/*   Scrolling and zooming of the whole picture is done by changing the       */%@AE@%%@NL@%
%@AB@%/*   default viewing transform.                                               */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Optimizations:  While it is possible to implement this puzzle using a very */%@AE@%%@NL@%
%@AB@%/*   naive approach, this is liable to lead to a rather slowly-operating      */%@AE@%%@NL@%
%@AB@%/*   program.  The following optimizations dramatically improve program       */%@AE@%%@NL@%
%@AB@%/*   performance:                                                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/*   1> BitBlt only as much of the bitmap through a clip path as necessary.   */%@AE@%%@NL@%
%@AB@%/*   Each piece of the puzzle is drawn by defining a clip path, blitting      */%@AE@%%@NL@%
%@AB@%/*   through the path, and drawing an outline on the same path.  The naive    */%@AE@%%@NL@%
%@AB@%/*   approach is to blit the whole bitmap through the clip path.  A more      */%@AE@%%@NL@%
%@AB@%/*   clever approach is to compute the piece's bounding box and only use      */%@AE@%%@NL@%
%@AB@%/*   the source and destination rectangles which correspond to this box.      */%@AE@%%@NL@%
%@AB@%/*   This leads to an order-of-magnitude speedup in the time to draw one      */%@AE@%%@NL@%
%@AB@%/*   piece.                                                                      */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/*   2> Make the source and target rectangles for BitBlt the same size              */%@AE@%%@NL@%
%@AB@%/*   in device coordinates.  A BitBlt in a retained segment must be done      */%@AE@%%@NL@%
%@AB@%/*   with GpiWCBitBlt and the target rectangle must be specified in world     */%@AE@%%@NL@%
%@AB@%/*   coordinates, so you must use GpiConvert (taking into account that in     */%@AE@%%@NL@%
%@AB@%/*   world space rectangles are inclusive-inclusive while in device space     */%@AE@%%@NL@%
%@AB@%/*   rectangles are inclusive-exclusive) to compute what target world space   */%@AE@%%@NL@%
%@AB@%/*   rectangle will be converted to the desired device space rectangle.       */%@AE@%%@NL@%
%@AB@%/*   Making the sizes of the source and converted target rectangles differ    */%@AE@%%@NL@%
%@AB@%/*   by even one pel will cause strectching or compression to occur, with     */%@AE@%%@NL@%
%@AB@%/*   a dramatic loss in speed.        Unfortunately, due to rounding effects, it is */%@AE@%%@NL@%
%@AB@%/*   not always possible to guarantee that adding an offset to the              */%@AE@%%@NL@%
%@AB@%/*   transformation applied to a segment will leave the size of the              */%@AE@%%@NL@%
%@AB@%/*   rectangle defined by the orders in the segment unchanged.                      */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/*   3> Use auxiliary information to reduce the number of segments which      */%@AE@%%@NL@%
%@AB@%/*   must be checked for correlation.  The naive approach to hit-testing is   */%@AE@%%@NL@%
%@AB@%/*   to test the whole chain, even though generally only a small fraction of  */%@AE@%%@NL@%
%@AB@%/*   the segments in the chain could possibly get a hit.  A more clever       */%@AE@%%@NL@%
%@AB@%/*   approach is to take the bounding box for each segment and only include   */%@AE@%%@NL@%
%@AB@%/*   the segment in the correlation check if the box contains the correlation */%@AE@%%@NL@%
%@AB@%/*   point.  eg.                                                              */%@AE@%%@NL@%
%@AB@%/*    a> Edit the chain by adjusting the ATTR_CHAINED attribute of each       */%@AE@%%@NL@%
%@AB@%/*    segment to reflect candidacy for being hit.  Afterwards, fix up by      */%@AE@%%@NL@%
%@AB@%/*    adding back removed segments to the chain.                              */%@AE@%%@NL@%
%@AB@%/*    b> Even faster is to keep an auxiliary data structure which records     */%@AE@%%@NL@%
%@AB@%/*    the priority of the segments (placed in the SEGLIST chain).  Run              */%@AE@%%@NL@%
%@AB@%/*    through the priority list from high-priority to low-priority and do a   */%@AE@%%@NL@%
%@AB@%/*    correlation test on each segment which passes the bounding-box test.    */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/*   4> When repainting through a clip region, only draw those segments which */%@AE@%%@NL@%
%@AB@%/*   overlap the clip region.  The naive approach is to set up the clip       */%@AE@%%@NL@%
%@AB@%/*   region and do a GpiDrawChain on the whole chain.  The drawback to this   */%@AE@%%@NL@%
%@AB@%/*   is that much time will be spent running through the orders in segments   */%@AE@%%@NL@%
%@AB@%/*   which are not visible through the clip region.  Very often, most of the  */%@AE@%%@NL@%
%@AB@%/*   segments in the picture can be eliminated from needing to be drawn by    */%@AE@%%@NL@%
%@AB@%/*   recognizing that there is no overlap between the bounding boxes of the   */%@AE@%%@NL@%
%@AB@%/*   segment and the clip region.                                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/*   5> Do WinScrollWindow horizontally in multiples of 8 pels when possible. */%@AE@%%@NL@%
%@AB@%/*   For example, horizontal scrolls by 7 or 9 pels are much slower than a    */%@AE@%%@NL@%
%@AB@%/*   a horizontal scroll by 8 pels.                                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_BITMAPFILEFORMAT %@NL@%
 %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_DOSSEMAPHORES %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DEV %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINRECTANGLES %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINSCROLLBARS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINSWITCHLIST %@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%INCL_GPICONTROL %@NL@%
%@AI@%#define %@AE@%INCL_GPITRANSFORMS %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@AI@%#define %@AE@%INCL_GPIMETAFILES %@NL@%
%@AI@%#define %@AE@%INCL_GPIPATHS %@NL@%
%@AI@%#define %@AE@%INCL_GPIREGIONS %@NL@%
%@AI@%#define %@AE@%INCL_GPISEGMENTS %@NL@%
%@AI@%#define %@AE@%INCL_GPISEGEDITING %@NL@%
%@AI@%#define %@AE@%INCL_GPICORRELATION %@NL@%
%@AI@%#define %@AE@%INCL_GPILCIDS %@NL@%
 %@NL@%
%@AI@%#define %@AE@%INCL_ERRORS %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<opendlg.h> %@NL@%
%@AI@%#include %@AE@%"noncomm.h" %@NL@%
%@AI@%#include %@AE@%"jigsaw.h" %@NL@%
 %@NL@%
 %@NL@%
 %@NL@%
%@AB@%/*----------------------- inter-thread messages ------------------------------*/%@AE@%%@NL@%
 %@NL@%
UM_DIE              WM_USER+1        %@AB@%/* instruct async thread to terminate  */%@AE@%%@NL@%
UM_DRAW       WM_USER+2        %@AB@%/* draw the current picture              */%@AE@%%@NL@%
UM_VSCROLL    WM_USER+3        %@AB@%/* perform scroll by recalculating the */%@AE@%%@NL@%
                                       %@AB@%/* default viewing transform           */%@AE@%%@NL@%
UM_HSCROLL    WM_USER+4        %@AB@%/* perform scroll by recalculating the */%@AE@%%@NL@%
                                       %@AB@%/* default viewing transform           */%@AE@%%@NL@%
UM_SIZING     WM_USER+5        %@AB@%/* perform sizing by recalculating the */%@AE@%%@NL@%
                                       %@AB@%/* default viewing transform           */%@AE@%%@NL@%
UM_ZOOM_IN    WM_USER+6        %@AB@%/* zoom the picture by recalculating   */%@AE@%%@NL@%
                                       %@AB@%/* the default viewing transform       */%@AE@%%@NL@%
UM_ZOOM_OUT   WM_USER+7        %@AB@%/* zoom the picture by recalculating   */%@AE@%%@NL@%
                                       %@AB@%/* the default viewing transform       */%@AE@%%@NL@%
%@AI@%#define %@AE@%UM_REDRAW     WM_USER+8 %@NL@%
%@AI@%#define %@AE@%UM_JUMBLE     WM_USER+9 %@NL@%
%@AI@%#define %@AE@%UM_LOAD       WM_USER+10 %@NL@%
UM_DUMMY      WM_USER+11       %@AB@%/* all commands not forcing redraw     */%@AE@%%@NL@%
                                       %@AB@%/* must come after this one            */%@AE@%%@NL@%
 %@NL@%
UM_LEFTDOWN   WM_USER+12       %@AB@%/* mouse button down in the client area*/%@AE@%%@NL@%
                                       %@AB@%/* perform a correlation on the current*/%@AE@%%@NL@%
                                       %@AB@%/* picture, setting any picked segment */%@AE@%%@NL@%
                                       %@AB@%/* to dynamic                              */%@AE@%%@NL@%
UM_MOUSEMOVE  WM_USER+13       %@AB@%/* mousemove command, remove, repositon*/%@AE@%%@NL@%
                                       %@AB@%/* and redraw any dynamic sements      */%@AE@%%@NL@%
UM_LEFTUP     WM_USER+14       %@AB@%/* mouse button up in the client area  */%@AE@%%@NL@%
                                       %@AB@%/* set any dynamic segment to normal   */%@AE@%%@NL@%
UM_FASTDRAG   WM_USER+15       %@AB@%/* toggle fast-drag (outline) mode     */%@AE@%%@NL@%
UM_DRAWDONE   WM_USER+16       %@AB@%/* Async DrawChain has completed       */%@AE@%%@NL@%
%@AI@%#define %@AE@%UM_FLUSH      WM_USER+17 %@NL@%
 %@NL@%
 %@NL@%
%@AB@%/*------------------------ element label values  -----------------------------*/%@AE@%%@NL@%
 %@NL@%
%@AI@%#define %@AE@%FILLPATH       222L %@NL@%
%@AI@%#define %@AE@%BITBLT_TOP     232L %@NL@%
%@AI@%#define %@AE@%BITBLT_BOTTOM  233L %@NL@%
 %@NL@%
 %@NL@%
%@AB@%/*------------------------- correlation parameters ---------------------------*/%@AE@%%@NL@%
 %@NL@%
HITS        1L                       %@AB@%/* maximum number of hits to return    */%@AE@%%@NL@%
DEPTH        2L                       %@AB@%/* max depth of seg calls to return    */%@AE@%%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/*-------------------------- general definitions -----------------------------*/%@AE@%%@NL@%
 %@NL@%
 %@NL@%
HAB        habMain=NULL;                       %@AB@%/* main thread anchor block handle     */%@AE@%%@NL@%
HMQ        hmqMain=NULL;                       %@AB@%/* main thread queue handle              */%@AE@%%@NL@%
HWND    hwndFrame=NULL;                %@AB@%/* frame control handle                */%@AE@%%@NL@%
HWND        hwndClient=NULL;               %@AB@%/* client area handle                      */%@AE@%%@NL@%
HDC        hdcClient=NULL;                %@AB@%/* window dc handle                      */%@AE@%%@NL@%
HPS        hpsClient=NULL;                %@AB@%/* client area Gpi ps handle              */%@AE@%%@NL@%
SIZEL        sizlMaxClient;                       %@AB@%/* max client area size                      */%@AE@%%@NL@%
HPS     hpsPaint=NULL;                 %@AB@%/* ps for use in Main Thread           */%@AE@%%@NL@%
HRGN        hrgnInvalid = NULL;               %@AB@%/* handle to the invalid region              */%@AE@%%@NL@%
 %@NL@%
HAB        habAsync=NULL;                       %@AB@%/* async thread anchor block handle    */%@AE@%%@NL@%
HMQ        hmqAsync=NULL;                       %@AB@%/* async thread queue handle              */%@AE@%%@NL@%
TID     tidAsync;                      %@AB@%/* async thread id                     */%@AE@%%@NL@%
SEL        selStack;                       %@AB@%/* async thread stack selector              */%@AE@%%@NL@%
STACKSIZE  4096                %@AB@%/* async thread stack size              */%@AE@%%@NL@%
SHORT        sPrty = -1;                       %@AB@%/* async thread priority               */%@AE@%%@NL@%
 %@NL@%
HWND        hwndHorzScroll=NULL;               %@AB@%/* horizontal scroll bar window              */%@AE@%%@NL@%
HWND        hwndVertScroll=NULL;               %@AB@%/* vertical scroll bar window              */%@AE@%%@NL@%
POINTS        ptsScrollPos, ptsOldScrollPos;%@NL@%
POINTS        ptsScrollMax, ptsHalfScrollMax;%@NL@%
POINTS        ptsScrollLine = { 8, 8};%@NL@%
POINTS        ptsScrollPage = { 64, 64};%@NL@%
 %@NL@%
%@AI@%#define %@AE@%UNITY               65536L %@NL@%
MATRIXLF matlfIdentity = { UNITY, 0, 0, 0, UNITY, 0, 0, 0, 1 };%@NL@%
LONG        lScale = 0;                       %@AB@%/* current zoom level                      */%@AE@%%@NL@%
%@AI@%#define %@AE@%ZOOM_MAX       8 %@NL@%
%@AI@%#define %@AE@%ZOOM_IN_ARG    1 %@NL@%
%@AI@%#define %@AE@%ZOOM_OUT_ARG   -1 %@NL@%
 %@NL@%
%@AI@%#define %@AE@%CALLSEG_BASE   1000 %@NL@%
POINTL        ptlOffset;%@NL@%
POINTL        ptlBotLeft  = { 0, 0};%@NL@%
POINTL        ptlTopRight = { 300, 300};%@NL@%
LONG        lLastSegId;                       %@AB@%/* last segment id assigned to a piece */%@AE@%%@NL@%
LONG        lPickedSeg;                       %@AB@%/* seg id of piece selected for drag   */%@AE@%%@NL@%
RECTL        rclBounds;                       %@AB@%/* pict bounding box in model coords.  */%@AE@%%@NL@%
POINTL        ptlOldMouse = {0L, 0L};        %@AB@%/* current mouse posn                      */%@AE@%%@NL@%
BOOL        fButtonDown = FALSE;               %@AB@%/* only drag if mouse down              */%@AE@%%@NL@%
BOOL        fFastDrag = FALSE;               %@AB@%/* show only outline of dragging piece */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/*-------------------------- segment list ------------------------------------*/%@AE@%%@NL@%
%@NL@%
typedef struct _SEGLIST {               %@AB@%/* sl                                      */%@AE@%%@NL@%
    LONG                  lSegId;%@NL@%
    struct _SEGLIST FAR * pslPrev;%@NL@%
    struct _SEGLIST FAR * pslNext;%@NL@%
    POINTL                  ptlLocation; %@AB@%/* piece location, world coordinates   */%@AE@%%@NL@%
    RECTL                  rclCurrent;  %@AB@%/* segment bounding box, model coords  */%@AE@%%@NL@%
    RECTL                  rclBitBlt;   %@AB@%/* segment bounding box, world coords  */%@AE@%%@NL@%
} SEGLIST ;%@NL@%
typedef SEGLIST FAR *PSEGLIST;               %@AB@%/* psl                                      */%@AE@%%@NL@%
typedef PSEGLIST FAR *PPSEGLIST;       %@AB@%/* ppsl                                      */%@AE@%%@NL@%
PSEGLIST pslHead = NULL;               %@AB@%/* head of the list                      */%@AE@%%@NL@%
PSEGLIST pslTail = NULL;               %@AB@%/* tail of the list                      */%@AE@%%@NL@%
PSEGLIST pslPicked = NULL;               %@AB@%/* picked segment's list member        */%@AE@%%@NL@%
%@AI@%#define %@AE@%  ADD_HEAD_SEG         1 %@NL@%
%@AI@%#define %@AE@%  ADD_TAIL_SEG         2 %@NL@%
%@AI@%#define %@AE@%       DEL_SEG         3 %@NL@%
 %@NL@%
%@AB@%/*-------------------------- bitmap-related data -----------------------------*/%@AE@%%@NL@%
%@NL@%
typedef struct _LOADINFO {               %@AB@%/* li                                      */%@AE@%%@NL@%
    HFILE   hf;%@NL@%
    CHAR    szFileName[MAX_FNAME_LEN];%@NL@%
} LOADINFO ;%@NL@%
typedef LOADINFO FAR *PLOADINFO;       %@AB@%/* pli                                      */%@AE@%%@NL@%
%@NL@%
HPS                   hpsBitmapFile=NULL, hpsBitmapTemp=NULL, hpsBitmapDrag=NULL;%@NL@%
HDC                   hdcBitmapFile=NULL, hdcBitmapTemp=NULL, hdcBitmapDrag=NULL;%@NL@%
HBITMAP            hbmBitmapFile=NULL, hbmBitmapTemp=NULL, hbmBitmapDrag=NULL;%@NL@%
BITMAPINFOHEADER   bmpBitmapFile   = {12L, 0, 0, 0, 0};%@NL@%
BITMAPINFOHEADER   bmpBitmapTemp   = {12L, 0, 0, 0, 0};%@NL@%
BITMAPINFOHEADER   bmpBitmapDrag   = {12L, 0, 0, 0, 0};%@NL@%
BITMAPINFO           bmiBitmap           = {12L, 0, 0, 0, 0, {{0, 0, 0}}};%@NL@%
static DEVOPENSTRUC dop = { NULL%@NL@%
                          , "DISPLAY"%@NL@%
                          , NULL%@NL@%
                          , NULL%@NL@%
                          , NULL%@NL@%
                          , NULL%@NL@%
                          , NULL%@NL@%
                          , NULL%@NL@%
                          , NULL };%@NL@%
%@NL@%
%@NL@%
%@AB@%/*-------------------------- old-style bitmap header -------------------------*/%@AE@%%@NL@%
%@NL@%
typedef struct {%@NL@%
    USHORT    wType;%@NL@%
    ULONG     dwSize;%@NL@%
    int       xHotspot;%@NL@%
    int       yHotspot;%@NL@%
    ULONG     dwBitsOffset;%@NL@%
    USHORT    bmWidth;%@NL@%
    USHORT    bmHeight;%@NL@%
    USHORT    bmPlanes;%@NL@%
    USHORT    bmBitcount;%@NL@%
} RCBITMAP;%@NL@%
typedef RCBITMAP FAR *PRCBITMAP;%@NL@%
%@NL@%
%@NL@%
%@AB@%/*--------------------------- Miscellaneous ----------------------------------*/%@AE@%%@NL@%
 %@NL@%
ULONG        ulTerminateSem = 0;               %@AB@%/* main thread blocks while async dies */%@AE@%%@NL@%
HSEM        hsemTerminate  = &ulTerminateSem;%@NL@%
%@NL@%
ULONG        ulSzFmt   = 0;                       %@AB@%/* serializes access to sprintf()      */%@AE@%%@NL@%
HSEM        hsemSzFmt = &ulSzFmt;%@NL@%
CHAR        szFmt[50];                       %@AB@%/* buffer used by sprintf()              */%@AE@%%@NL@%
%@NL@%
SWCNTRL swctl = { 0, 0, 0, 0, 0, SWL_VISIBLE, SWL_JUMPABLE, 0, 0 };%@NL@%
HSWITCH hsw;                               %@AB@%/* handle to a switch list entry       */%@AE@%%@NL@%
char        szTitle[80];                       %@AB@%/* Title bar text                      */%@AE@%%@NL@%
%@NL@%
BOOL        fErrMem = FALSE;               %@AB@%/* set if alloc async stack fails      */%@AE@%%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/*------------------------- Function Prototypes ------------------------------*/%@AE@%%@NL@%
%@NL@%
VOID         CalcBounds( VOID);%@NL@%
VOID         CalcTransform( HWND);%@NL@%
MRESULT CALLBACK ClientWndProc( HWND, USHORT, MPARAM, MPARAM);%@NL@%
BOOL         CreateBitmapHdcHps( HDC, HPS);%@NL@%
BOOL         CreateThread( VOID);%@NL@%
BOOL         CreatePicture( VOID);%@NL@%
VOID         DestroyThread( VOID);%@NL@%
BOOL         DoDraw( HRGN);%@NL@%
VOID         DoHorzScroll( VOID);%@NL@%
VOID         DoVertScroll( VOID);%@NL@%
BOOL         DumpPicture( VOID);%@NL@%
VOID         Finalize( VOID);%@NL@%
BOOL         Initialize( VOID);%@NL@%
VOID         Jumble( VOID);%@NL@%
VOID         LeftDown( MPARAM);%@NL@%
VOID         LeftUp( VOID);%@NL@%
VOID         Load( PLOADINFO);%@NL@%
VOID cdecl main( VOID);%@NL@%
VOID         MessageInt( HWND, INT, PCH);%@NL@%
VOID         MouseMove( MPARAM);%@NL@%
VOID         MyMessageBox( HWND, PSZ);%@NL@%
VOID FAR NewThread( VOID);%@NL@%
BOOL         PrepareBitmap( VOID);%@NL@%
BOOL         ReadBitmap( HFILE);%@NL@%
VOID         Redraw( VOID);%@NL@%
VOID         ReportError( HAB);%@NL@%
BOOL         SegListCheck( INT);%@NL@%
PSEGLIST SegListGet( LONG);%@NL@%
BOOL         SegListUpdate( USHORT, PSEGLIST);%@NL@%
BOOL         SendCommand( USHORT, ULONG);%@NL@%
VOID         SetDVTransform( FIXED, FIXED, FIXED, FIXED, LONG, LONG, LONG);%@NL@%
VOID         SetRect( PSEGLIST);%@NL@%
VOID         ToggleFastDrag( VOID);%@NL@%
VOID         Translate( PSEGLIST, PPOINTL);%@NL@%
MRESULT  WndProcCommand( HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT  WndProcCreate( HWND);%@NL@%
MRESULT  WndProcPaint( VOID);%@NL@%
MRESULT  WndProcSize( MPARAM, MPARAM);%@NL@%
VOID         Zoom( SHORT);%@NL@%
VOID         ZoomMenuItems( VOID);%@NL@%
%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/*  MyMessageBox                                                              */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/*  Displays a message box with the given string.  To simplify matters,       */%@AE@%%@NL@%
%@AB@%/*  the box will always have the same title ("Jigsaw"), will always              */%@AE@%%@NL@%
%@AB@%/*  have a single button ("Ok"), will always have an exclamation point              */%@AE@%%@NL@%
%@AB@%/*  icon, and will always be application modal.                               */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
MyMessageBox( hWnd, psz)%@NL@%
%@NL@%
HWND  hWnd;%@NL@%
PSZ   psz;%@NL@%
{%@NL@%
    WinMessageBox( HWND_DESKTOP%@NL@%
                 , hWnd%@NL@%
                 , psz%@NL@%
                 , szTitle%@NL@%
                 , 0%@NL@%
                 , MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL );%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Main thread will initialize the process for PM services and process              */%@AE@%%@NL@%
%@AB@%/* the application message queue until a WM_QUIT message is received. It will */%@AE@%%@NL@%
%@AB@%/* then destroy all PM resources and terminate. Any error during              */%@AE@%%@NL@%
%@AB@%/* initialization will be reported and the process terminated.                */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID cdecl%@NL@%
main()%@NL@%
{%@NL@%
  QMSG        qmsg;%@NL@%
 %@NL@%
  if( Initialize())%@NL@%
      while( WinGetMsg( habMain, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg( habMain, &qmsg);%@NL@%
  else%@NL@%
      ReportError( habMain);%@NL@%
  Finalize();%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* The Initialize function will initialize the PM interface,                      */%@AE@%%@NL@%
%@AB@%/* create an application message queue, a standard frame window and a new     */%@AE@%%@NL@%
%@AB@%/* thread to control drawing operations.  It will also initialize static      */%@AE@%%@NL@%
%@AB@%/* strings.                                                                   */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
Initialize()%@NL@%
{%@NL@%
  ULONG   flCreate;%@NL@%
  PID          pid;%@NL@%
  TID          tid;%@NL@%
 %@NL@%
  WinShowPointer( HWND_DESKTOP, TRUE);%@NL@%
  habMain = WinInitialize( 0);%@NL@%
  if( !habMain)%@NL@%
      return( FALSE);%@NL@%
 %@NL@%
  hmqMain = WinCreateMsgQueue( habMain,0);%@NL@%
  if( !hmqMain)%@NL@%
      return( FALSE);%@NL@%
 %@NL@%
  WinLoadString( habMain, (HMODULE) NULL, TITLEBAR, sizeof(szTitle), szTitle);%@NL@%
  if( !WinRegisterClass( habMain%@NL@%
                       , (PCH)szTitle%@NL@%
                       , (PFNWP)ClientWndProc%@NL@%
                       , CS_SIZEREDRAW%@NL@%
                       , 0 ))%@NL@%
      return( FALSE);%@NL@%
 %@NL@%
  flCreate =   (FCF_STANDARD | FCF_VERTSCROLL | FCF_HORZSCROLL)%@NL@%
             & ~(ULONG)FCF_TASKLIST;%@NL@%
  hwndFrame = WinCreateStdWindow( HWND_DESKTOP%@NL@%
                                , WS_VISIBLE%@NL@%
                                , &flCreate%@NL@%
                                , szTitle%@NL@%
                                , szTitle%@NL@%
                                , WS_VISIBLE%@NL@%
                                , (HMODULE) NULL%@NL@%
                                , APPMENU%@NL@%
                                , &hwndClient);%@NL@%
  if( !hwndFrame)%@NL@%
      return( FALSE);%@NL@%
%@NL@%
  WinQueryWindowProcess( hwndFrame, &pid, &tid);%@NL@%
  swctl.hwnd          = hwndFrame;%@NL@%
  swctl.idProcess = pid;%@NL@%
  lstrcpy( swctl.szSwtitle, szTitle);%@NL@%
  hsw = WinAddSwitchEntry( &swctl);%@NL@%
%@NL@%
  if( !CreateThread())                      %@AB@%/* create async thread                     */%@AE@%%@NL@%
      return ( FALSE);%@NL@%
  if( !CreateBitmapHdcHps( &hdcBitmapFile, &hpsBitmapFile))%@NL@%
      return( FALSE);%@NL@%
  if( !CreateBitmapHdcHps( &hdcBitmapTemp, &hpsBitmapTemp))%@NL@%
      return( FALSE);%@NL@%
  if( !CreateBitmapHdcHps( &hdcBitmapDrag, &hpsBitmapDrag))%@NL@%
      return( FALSE);%@NL@%
 %@NL@%
  return( TRUE);%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Finalize will destroy the asynchronous drawing thread, all Presentation    */%@AE@%%@NL@%
%@AB@%/* Manager resources, and terminate the process.                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Finalize()%@NL@%
{%@NL@%
  DestroyThread();%@NL@%
%@NL@%
  while( pslHead != NULL )%@NL@%
      SegListUpdate( DEL_SEG, pslHead);%@NL@%
  if( hrgnInvalid)%@NL@%
      GpiDestroyRegion( hpsClient, hrgnInvalid);%@NL@%
  if( hpsClient)%@NL@%
      GpiAssociate( hpsClient, NULL);%@NL@%
  if( hpsPaint)%@NL@%
      GpiAssociate( hpsPaint, NULL);%@NL@%
  if( hpsBitmapFile)%@NL@%
      GpiAssociate( hpsBitmapFile, NULL);%@NL@%
  if( hpsBitmapTemp)%@NL@%
      GpiAssociate( hpsBitmapTemp, NULL);%@NL@%
  if( hpsBitmapDrag)%@NL@%
      GpiAssociate( hpsBitmapDrag, NULL);%@NL@%
  if( hwndFrame)%@NL@%
      WinDestroyWindow( hwndFrame);%@NL@%
  if( hmqMain)%@NL@%
      WinDestroyMsgQueue( hmqMain);%@NL@%
  if( habMain)%@NL@%
      WinTerminate( habMain);%@NL@%
%@NL@%
  DosExit( EXIT_PROCESS, 0);%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* ReportError        will display the latest error information for the required    */%@AE@%%@NL@%
%@AB@%/* thread. No resources to be loaded if out of memory error.                  */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
ReportError( hab)%@NL@%
%@NL@%
HAB hab;%@NL@%
{%@NL@%
  PERRINFO  perriBlk;%@NL@%
  PSZ            pszErrMsg;%@NL@%
  USHORT *  TempPtr;%@NL@%
 %@NL@%
  if( !hwndFrame)%@NL@%
      return;%@NL@%
  if( !fErrMem)%@NL@%
  {%@NL@%
      perriBlk = WinGetErrorInfo(hab);%@NL@%
      if( !perriBlk)%@NL@%
          return;%@NL@%
      SELECTOROF( pszErrMsg) = SELECTOROF(perriBlk);%@NL@%
      SELECTOROF( TempPtr)   = SELECTOROF(perriBlk);%@NL@%
      OFFSETOF( TempPtr)     = perriBlk->offaoffszMsg;%@NL@%
      OFFSETOF( pszErrMsg)   = *TempPtr;%@NL@%
      WinMessageBox( HWND_DESKTOP%@NL@%
                   , hwndFrame%@NL@%
                   , pszErrMsg%@NL@%
                   , szTitle%@NL@%
                   , 0%@NL@%
                   , MB_CUACRITICAL | MB_ENTER);%@NL@%
      WinFreeErrorInfo( perriBlk);%@NL@%
  } else%@NL@%
      WinMessageBox( HWND_DESKTOP%@NL@%
                   , hwndFrame%@NL@%
                   , "ERROR - Out Of Memory"%@NL@%
                   , szTitle%@NL@%
                   , 0%@NL@%
                   , MB_CUACRITICAL | MB_ENTER);%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* CreateThread  creates the asynchronous drawing thread. It will allocate    */%@AE@%%@NL@%
%@AB@%/* stack space and create the thread.                                         */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
CreateThread()%@NL@%
{%@NL@%
  PBYTE pbAsyncStack;                      %@AB@%/* long pointer to stack for new thread */%@AE@%%@NL@%
 %@NL@%
 %@NL@%
  if( DosAllocSeg( STACKSIZE, (PSEL)&selStack, 0 ))%@NL@%
  {%@NL@%
      fErrMem = TRUE;%@NL@%
      return( FALSE);%@NL@%
  }%@NL@%
  OFFSETOF(pbAsyncStack) = STACKSIZE-2;%@NL@%
  SELECTOROF(pbAsyncStack) = selStack;%@NL@%
  if( DosCreateThread( (PFNTHREAD)NewThread, &tidAsync, pbAsyncStack ))%@NL@%
      return( FALSE);%@NL@%
  return( TRUE);%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* DestroyThread  will send a message  to the asynchronous drawing thread     */%@AE@%%@NL@%
%@AB@%/* commanding it to terminate itself. If the send is successful it will wait  */%@AE@%%@NL@%
%@AB@%/* until the async thread has terminated. It will then release any stack space*/%@AE@%%@NL@%
%@AB@%/* used by that thread.                                                       */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
DestroyThread()%@NL@%
{%@NL@%
  if( tidAsync)%@NL@%
  {%@NL@%
      DosSemSet( hsemTerminate);%@NL@%
      if( SendCommand( (USHORT)UM_DIE, (ULONG)NULL))%@NL@%
          DosSemWait( hsemTerminate, SEM_INDEFINITE_WAIT);%@NL@%
  }%@NL@%
  if( selStack)%@NL@%
      DosFreeSeg( selStack);%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* SendCommand        will attempt to post the required command and parameters to   */%@AE@%%@NL@%
%@AB@%/* the asynchronous drawing thread's message queue. The command will only     */%@AE@%%@NL@%
%@AB@%/* be posted if the queue exists.                                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
SendCommand( usCommand, ulInfo)%@NL@%
%@NL@%
USHORT        usCommand;%@NL@%
ULONG        ulInfo;%@NL@%
{%@NL@%
  if( !hmqAsync)%@NL@%
      return( FALSE);%@NL@%
%@NL@%
  switch( usCommand)%@NL@%
  {%@NL@%
    case UM_DIE:%@NL@%
    case UM_LEFTDOWN:%@NL@%
    case UM_LEFTUP:%@NL@%
    case UM_MOUSEMOVE:%@NL@%
    case UM_DRAW:%@NL@%
    case UM_HSCROLL:%@NL@%
    case UM_VSCROLL:%@NL@%
    case UM_ZOOM_IN:%@NL@%
    case UM_ZOOM_OUT:%@NL@%
    case UM_REDRAW:%@NL@%
    case UM_SIZING:%@NL@%
    case UM_FASTDRAG:%@NL@%
    case UM_JUMBLE:%@NL@%
    case UM_LOAD:%@NL@%
 %@NL@%
        return( WinPostQueueMsg( hmqAsync%@NL@%
                               , usCommand%@NL@%
                               , MPFROMLONG( ulInfo)%@NL@%
                               , MPFROMLONG( NULL  ) ) );%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return( TRUE);%@NL@%
  }%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* ClientWndProd is the window procedure associated with the client window.   */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
MRESULT CALLBACK%@NL@%
ClientWndProc( hwnd, msg, mp1, mp2)%@NL@%
%@NL@%
HWND        hwnd;%@NL@%
USHORT  msg;%@NL@%
MPARAM        mp1;%@NL@%
MPARAM        mp2;%@NL@%
{%@NL@%
  CHAR  szTemp[128];%@NL@%
 %@NL@%
  switch( msg)%@NL@%
  {%@NL@%
    case WM_CREATE:%@NL@%
      return( WndProcCreate( hwnd));%@NL@%
      break;%@NL@%
 %@NL@%
    case WM_CLOSE:%@NL@%
      WinLoadString( habMain, (HMODULE) NULL, TERMINATE, sizeof(szTemp), (PSZ)szTemp );%@NL@%
      if( WinMessageBox( HWND_DESKTOP%@NL@%
                       , hwndFrame%@NL@%
                       , szTemp%@NL@%
                       , szTitle%@NL@%
                       , 0%@NL@%
                       , MB_CUAWARNING | MB_YESNO | MB_DEFBUTTON2)%@NL@%
               == MBID_YES)%@NL@%
          WinPostMsg( hwnd, WM_QUIT, NULL, NULL);%@NL@%
      break;%@NL@%
 %@NL@%
    case WM_PAINT:%@NL@%
      return( WndProcPaint());%@NL@%
      break;%@NL@%
 %@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/*                                                                              */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    case WM_ERASEBACKGROUND:%@NL@%
      WinFillRect( (HPS)mp1, (PRECTL)mp2, CLR_BACKGROUND);%@NL@%
      return( FALSE);%@NL@%
      break;%@NL@%
 %@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/*                                                                              */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    case WM_MINMAXFRAME:%@NL@%
      if( (((PSWP)mp1)->fs & SWP_RESTORE)  ||%@NL@%
          (((PSWP)mp1)->fs & SWP_MAXIMIZE) )%@NL@%
        SendCommand( (USHORT)UM_SIZING, 0L);%@NL@%
      break;%@NL@%
 %@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/* Process menu item commands, and commands generated from the keyboard   */%@AE@%%@NL@%
    %@AB@%/* via the accelerator table. Most are handled by the async thread        */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    case WM_COMMAND:%@NL@%
      return( WndProcCommand( hwnd, msg, mp1, mp2));%@NL@%
      break;%@NL@%
 %@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/* Scrolling is handled by the async drawing thread. Simply pass on the   */%@AE@%%@NL@%
    %@AB@%/* command and parameters                                                 */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    case WM_HSCROLL:%@NL@%
      SendCommand( (USHORT)UM_HSCROLL, LONGFROMMP(mp2));%@NL@%
      break;%@NL@%
 %@NL@%
    case WM_VSCROLL:%@NL@%
      SendCommand( (USHORT)UM_VSCROLL, LONGFROMMP(mp2));%@NL@%
      break;%@NL@%
 %@NL@%
    %@AB@%/************************************************************************/%@AE@%%@NL@%
    %@AB@%/* The client area is being resized.                                    */%@AE@%%@NL@%
    %@AB@%/************************************************************************/%@AE@%%@NL@%
    case WM_SIZE:%@NL@%
      return( WndProcSize( mp1, mp2));%@NL@%
      break;%@NL@%
 %@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/* Mouse commands are handled by the async thread. Simply send on the     */%@AE@%%@NL@%
    %@AB@%/* command and parameters.                                                */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    case WM_BUTTON1DBLCLK:%@NL@%
    case WM_BUTTON1DOWN:%@NL@%
      if( hwnd != WinQueryFocus( HWND_DESKTOP, FALSE))%@NL@%
          WinSetFocus( HWND_DESKTOP, hwnd);%@NL@%
      if( !fButtonDown)%@NL@%
      {%@NL@%
          fButtonDown = TRUE;%@NL@%
          SendCommand( (USHORT)UM_LEFTDOWN, LONGFROMMP(mp1));%@NL@%
      }%@NL@%
      return((MRESULT) TRUE);%@NL@%
      break;%@NL@%
 %@NL@%
    case WM_BUTTON1UP:%@NL@%
      if( !fButtonDown)%@NL@%
          return((MRESULT) TRUE);%@NL@%
      if( SendCommand( (USHORT)UM_LEFTUP, LONGFROMMP(mp1)))%@NL@%
          fButtonDown = FALSE;%@NL@%
      else%@NL@%
          WinAlarm( HWND_DESKTOP, WA_WARNING);%@NL@%
      return((MRESULT) TRUE);%@NL@%
      break;%@NL@%
 %@NL@%
    case WM_MOUSEMOVE:%@NL@%
      if( fButtonDown && (pslPicked != NULL))%@NL@%
          SendCommand( (USHORT)UM_MOUSEMOVE, LONGFROMMP(mp1));%@NL@%
      return( WinDefWindowProc( hwnd, msg, mp1, mp2));%@NL@%
      break;%@NL@%
%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/* Default for the rest                                                      */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    default:%@NL@%
      return( WinDefWindowProc( hwnd, msg, mp1, mp2));%@NL@%
  }%@NL@%
 %@NL@%
  return( FALSE);%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/* Get the maximum client area size.  Create a window DC for the client       */%@AE@%%@NL@%
%@AB@%/* area and a normal GPI Presentation Space and associate the two.  The GPI   */%@AE@%%@NL@%
%@AB@%/* PS will be the maximum client area size and be in pels.                      */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
MRESULT%@NL@%
WndProcCreate( hwnd)%@NL@%
%@NL@%
HWND  hwnd;%@NL@%
{%@NL@%
  SIZEL sizlPickApp;                      %@AB@%/* pick aperture size                      */%@AE@%%@NL@%
 %@NL@%
  sizlMaxClient.cx = WinQuerySysValue( HWND_DESKTOP, SV_CXFULLSCREEN);%@NL@%
  sizlMaxClient.cy = WinQuerySysValue( HWND_DESKTOP, SV_CYFULLSCREEN);%@NL@%
 %@NL@%
  hdcClient = WinOpenWindowDC( hwnd);%@NL@%
  hpsClient = GpiCreatePS( habMain%@NL@%
                         , hdcClient%@NL@%
                         , &sizlMaxClient%@NL@%
                         , GPIA_ASSOC | PU_PELS );%@NL@%
  if( !hpsClient)%@NL@%
      return((MRESULT) TRUE);%@NL@%
  GpiSetAttrMode( hpsClient, AM_PRESERVE);%@NL@%
%@NL@%
  hwndHorzScroll = WinWindowFromID( WinQueryWindow( hwnd, QW_PARENT, FALSE)%@NL@%
                                  , FID_HORZSCROLL);%@NL@%
%@NL@%
  hwndVertScroll = WinWindowFromID( WinQueryWindow( hwnd, QW_PARENT, FALSE)%@NL@%
                                  , FID_VERTSCROLL);%@NL@%
%@NL@%
  hpsPaint = GpiCreatePS( habMain, NULL, &sizlMaxClient, PU_PELS);%@NL@%
 %@NL@%
  hrgnInvalid = GpiCreateRegion( hpsClient, 0L, NULL);%@NL@%
 %@NL@%
  sizlPickApp.cx = sizlPickApp.cy = 1;%@NL@%
  GpiSetPickApertureSize( hpsClient, PICKAP_REC, &sizlPickApp);%@NL@%
  return( FALSE);%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/*******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                               */%@AE@%%@NL@%
%@AB@%/* WM_PAINT message                                                               */%@AE@%%@NL@%
%@AB@%/*                                                                               */%@AE@%%@NL@%
%@AB@%/*******************************************************************************/%@AE@%%@NL@%
MRESULT%@NL@%
WndProcPaint()%@NL@%
%@NL@%
{%@NL@%
  HRGN         hrgnUpdt;%@NL@%
  SHORT  sRgnType;%@NL@%
 %@NL@%
  hrgnUpdt = GpiCreateRegion( hpsPaint, 0L, NULL);%@NL@%
  sRgnType = WinQueryUpdateRegion( hwndClient, hrgnUpdt);%@NL@%
  WinValidateRegion( hwndClient, hrgnUpdt, FALSE);%@NL@%
  SendCommand( UM_DRAW, (ULONG)hrgnUpdt);%@NL@%
  return( FALSE);%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/* Process menu item commands, and commands generated from the keyboard via   */%@AE@%%@NL@%
%@AB@%/* the accelerator table.  Most are handled by the async thread               */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
MRESULT%@NL@%
WndProcCommand( hwnd, msg, mp1, mp2)%@NL@%
%@NL@%
HWND        hwnd;%@NL@%
USHORT  msg;%@NL@%
MPARAM        mp1, mp2;%@NL@%
{%@NL@%
  CHAR            szTemp[128];%@NL@%
  DLF            dlf;%@NL@%
  SEL            sel;%@NL@%
  PLOADINFO pli;%@NL@%
  PSZ            pszError, psz1, psz2;%@NL@%
 %@NL@%
  switch( SHORT1FROMMP(mp1))%@NL@%
  {%@NL@%
    case MENU_JUMBLE:%@NL@%
        SendCommand( UM_JUMBLE, 0L);%@NL@%
        break;%@NL@%
%@NL@%
    case MENU_LOAD:%@NL@%
        DosAllocSeg( sizeof( LOADINFO), &sel, 0);%@NL@%
        pli = MAKEP( sel, 0);%@NL@%
%@NL@%
        dlf.rgbAction            = DLG_OPENDLG;%@NL@%
        dlf.rgbFlags            = ATTRDIRLIST;%@NL@%
        dlf.phFile            = &(pli->hf);%@NL@%
        dlf.pszExt            = (PSZ)"\\*.bmp";%@NL@%
        dlf.pszAppName            = szTitle;%@NL@%
        dlf.pszTitle            = "Load Bitmap";%@NL@%
        dlf.pszInstructions = NULL;%@NL@%
        dlf.szFileName[0]   = '\0';%@NL@%
        dlf.szOpenFile[0]   = '\0';%@NL@%
        pszError            = "Error reading file.";%@NL@%
%@NL@%
        switch( DlgFile( hwnd, &dlf))%@NL@%
        {%@NL@%
          case TDF_ERRMEM:%@NL@%
          case TDF_INVALID:%@NL@%
              MyMessageBox( hwnd, pszError);%@NL@%
              break;%@NL@%
%@NL@%
          case TDF_NOOPEN:%@NL@%
              break;%@NL@%
%@NL@%
          default:%@NL@%
              for( psz1 = dlf.szFileName, psz2 = pli->szFileName%@NL@%
                 ; *psz2++ = *psz1++%@NL@%
                 ; )%@NL@%
                  ;%@NL@%
              SendCommand( UM_LOAD, (LONG)pli);%@NL@%
              break;%@NL@%
        }%@NL@%
        break;%@NL@%
    %@AB@%/**********************************************************************/%@AE@%%@NL@%
    %@AB@%/* EXIT command, menu item or F3 key pressed. Give the operator a          */%@AE@%%@NL@%
    %@AB@%/* second chance, if confirmed post a WM_QUIT msg to the application  */%@AE@%%@NL@%
    %@AB@%/* msg queue. This will force the MAIN thread to terminate.           */%@AE@%%@NL@%
    %@AB@%/**********************************************************************/%@AE@%%@NL@%
    case MENU_EXIT:%@NL@%
      WinLoadString( habMain, (HMODULE) NULL, TERMINATE, sizeof(szTemp), szTemp);%@NL@%
      if( WinMessageBox( HWND_DESKTOP%@NL@%
                       , hwndFrame%@NL@%
                       , szTemp%@NL@%
                       , szTitle%@NL@%
                       , 0%@NL@%
                       , MB_CUAWARNING | MB_YESNO | MB_DEFBUTTON2)%@NL@%
            == MBID_YES)%@NL@%
        WinPostMsg( hwnd, WM_QUIT, NULL, NULL);%@NL@%
      break;%@NL@%
 %@NL@%
    %@AB@%/**********************************************************************/%@AE@%%@NL@%
    %@AB@%/* Pass on the rest to the async thread.                                  */%@AE@%%@NL@%
    %@AB@%/**********************************************************************/%@AE@%%@NL@%
    case MENU_ZOOMIN:%@NL@%
      SendCommand( UM_ZOOM_IN, 0L);%@NL@%
      break;%@NL@%
 %@NL@%
    case MENU_ZOOMOUT:%@NL@%
      SendCommand( UM_ZOOM_OUT, 0L);%@NL@%
      break;%@NL@%
%@NL@%
    case MENU_FASTDRAG:%@NL@%
      SendCommand( UM_FASTDRAG, 0L);%@NL@%
      break;%@NL@%
 %@NL@%
    %@AB@%/**********************************************************************/%@AE@%%@NL@%
    %@AB@%/* Unrecognised => default                                                  */%@AE@%%@NL@%
    %@AB@%/**********************************************************************/%@AE@%%@NL@%
    default:%@NL@%
      return( WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
  }%@NL@%
  return( FALSE);%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/* Load a bitmap                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Load( pli)%@NL@%
%@NL@%
PLOADINFO  pli;%@NL@%
{%@NL@%
    PSZ     pszError;%@NL@%
    RECTL   rclClient;%@NL@%
%@NL@%
    pszError = (PSZ)"Error reading file.";%@NL@%
%@NL@%
    DumpPicture();%@NL@%
    if( !ReadBitmap( pli->hf) )%@NL@%
    {%@NL@%
      MyMessageBox( hwndClient, pszError);%@NL@%
      return;%@NL@%
    }%@NL@%
    if( !PrepareBitmap() )%@NL@%
    {%@NL@%
      MyMessageBox( hwndClient, pszError);%@NL@%
      return;%@NL@%
    }%@NL@%
%@NL@%
    lstrcpy( swctl.szSwtitle, szTitle);%@NL@%
    lstrcat( swctl.szSwtitle, ": ");%@NL@%
    lstrcat( swctl.szSwtitle, pli->szFileName);%@NL@%
    WinChangeSwitchEntry( hsw, &swctl);%@NL@%
    WinSetWindowText( hwndFrame, swctl.szSwtitle);%@NL@%
%@NL@%
    CreatePicture();%@NL@%
    lScale = 0;%@NL@%
%@NL@%
    WinQueryWindowRect( hwndClient, &rclClient);%@NL@%
    ptsScrollMax.x = (SHORT)(rclClient.xRight - rclClient.xLeft);%@NL@%
    ptsHalfScrollMax.x = ptsScrollMax.x >> 1;%@NL@%
    ptsScrollPos.x = ptsHalfScrollMax.x;%@NL@%
    ptsOldScrollPos.x = ptsHalfScrollMax.x;%@NL@%
    WinSendMsg( hwndHorzScroll%@NL@%
              , SBM_SETSCROLLBAR%@NL@%
              , MPFROMSHORT( ptsScrollPos.x)%@NL@%
              , MPFROM2SHORT( 1, ptsScrollMax.x) );%@NL@%
    ptsScrollMax.y = (SHORT)(rclClient.yTop - rclClient.yBottom);%@NL@%
    ptsHalfScrollMax.y = ptsScrollMax.y >> 1;%@NL@%
    ptsScrollPos.y = ptsHalfScrollMax.y;%@NL@%
    ptsOldScrollPos.y = ptsHalfScrollMax.y;%@NL@%
    WinSendMsg( hwndVertScroll%@NL@%
              , SBM_SETSCROLLBAR%@NL@%
              , MPFROMSHORT( ptsScrollPos.y)%@NL@%
              , MPFROM2SHORT( 1, ptsScrollMax.y) );%@NL@%
%@NL@%
    CalcBounds();%@NL@%
    CalcTransform( hwndClient);%@NL@%
    DosFreeSeg( SELECTOROF( pli));%@NL@%
}%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/* Throw the pieces around the screen.                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Jumble()%@NL@%
{%@NL@%
  LONG            lWidth, lHeight;%@NL@%
  DATETIME  date;%@NL@%
  POINTL    ptl;%@NL@%
  RECTL     rclClient;%@NL@%
  PSEGLIST  psl;%@NL@%
%@NL@%
  if( WinQueryWindowRect( hwndClient, &rclClient) )%@NL@%
  {%@NL@%
    lWidth  = rclClient.xRight - rclClient.xLeft;%@NL@%
    lHeight = rclClient.yTop   - rclClient.yBottom;%@NL@%
    if( (lWidth > 0) && (lHeight > 0) )%@NL@%
    {%@NL@%
      DosGetDateTime( &date);%@NL@%
      srand( (USHORT)date.hundredths);%@NL@%
      for( psl = pslHead; psl != NULL; psl = psl->pslNext)%@NL@%
      {%@NL@%
        ptl.x = rclClient.xLeft   + (rand() % lWidth);%@NL@%
        ptl.y = rclClient.yBottom + (rand() % lHeight);%@NL@%
        Translate( psl, &ptl);%@NL@%
        SetRect( psl);%@NL@%
      }%@NL@%
    }%@NL@%
  }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/* The client area is being resized.  The current scroll bar thumb position   */%@AE@%%@NL@%
%@AB@%/* and scroll bar range must be recalculated prior to recalculating the       */%@AE@%%@NL@%
%@AB@%/* default viewing transform for the picture.  Wait for subsequent WM_PAINT   */%@AE@%%@NL@%
%@AB@%/* to do any drawing.                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
MRESULT%@NL@%
WndProcSize( mp1, mp2)%@NL@%
%@NL@%
MPARAM        mp1, mp2;%@NL@%
{%@NL@%
  HWND        hwndFrameTemp;%@NL@%
%@NL@%
  if( hwndFrame)%@NL@%
    hwndFrameTemp = hwndFrame;%@NL@%
  else%@NL@%
    hwndFrameTemp = WinQueryWindow( hwndClient, QW_PARENT, FALSE);%@NL@%
%@NL@%
  ptsScrollMax.y = SHORT2FROMMP( mp2);%@NL@%
  ptsHalfScrollMax.y = ptsScrollMax.y >> 1;%@NL@%
  if( mp1)%@NL@%
  {%@NL@%
      ptsScrollPos.y = (SHORT)(((LONG)ptsScrollPos.y * (LONG)SHORT2FROMMP(mp2))/(LONG)SHORT2FROMMP(mp1));%@NL@%
      ptsOldScrollPos.y = (SHORT)(((LONG)ptsOldScrollPos.y * (LONG)SHORT2FROMMP(mp2))/(LONG)SHORT2FROMMP(mp1));%@NL@%
  } else%@NL@%
  {%@NL@%
      ptsScrollPos.y = ptsHalfScrollMax.y;     %@AB@%/* first sizing after window creation  */%@AE@%%@NL@%
      ptsOldScrollPos.y = ptsHalfScrollMax.y;%@NL@%
  }%@NL@%
  WinSendMsg( hwndVertScroll%@NL@%
            , SBM_SETSCROLLBAR%@NL@%
            , MPFROMSHORT( ptsScrollPos.y)%@NL@%
            , MPFROM2SHORT( 1, ptsScrollMax.y) );%@NL@%
%@NL@%
%@NL@%
  ptsScrollMax.x = SHORT1FROMMP( mp2);%@NL@%
  ptsHalfScrollMax.x = ptsScrollMax.x >> 1;%@NL@%
  if( mp1)%@NL@%
  {%@NL@%
      ptsScrollPos.x = (SHORT)(((LONG)ptsScrollPos.x * (LONG)SHORT1FROMMP(mp2))/(LONG)SHORT1FROMMP(mp1));%@NL@%
      ptsOldScrollPos.x = (SHORT)(((LONG)ptsOldScrollPos.x * (LONG)SHORT1FROMMP(mp2))/(LONG)SHORT1FROMMP(mp1));%@NL@%
  } else%@NL@%
  {%@NL@%
      ptsScrollPos.x = ptsHalfScrollMax.x;     %@AB@%/* first sizing after window creation  */%@AE@%%@NL@%
      ptsOldScrollPos.x = ptsHalfScrollMax.x;%@NL@%
  }%@NL@%
  WinSendMsg( hwndHorzScroll%@NL@%
            , SBM_SETSCROLLBAR%@NL@%
            , MPFROMSHORT( ptsScrollPos.x)%@NL@%
            , MPFROM2SHORT( 1, ptsScrollMax.x) );%@NL@%
%@NL@%
%@NL@%
  SendCommand( UM_SIZING, 0L);%@NL@%
  return( FALSE);%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* NewThread is the asynchronous drawing thread. It is responsible for all    */%@AE@%%@NL@%
%@AB@%/* drawing.  It will initialize its PM interface and create an application    */%@AE@%%@NL@%
%@AB@%/* message queue.  It will then monitor its message queue and process any     */%@AE@%%@NL@%
%@AB@%/* commands received.                                                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID FAR%@NL@%
NewThread()%@NL@%
{%@NL@%
  QMSG          qmsgAsync, qmsgPeek;%@NL@%
  BOOL          fDone;%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* Initialize the PM interface.  If it fails, terminate both threads.       */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  habAsync = WinInitialize( 0);%@NL@%
  if( !habAsync)%@NL@%
  {%@NL@%
      WinPostMsg( hwndClient, WM_QUIT, NULL, NULL);%@NL@%
      DosExit( EXIT_THREAD, 0);%@NL@%
  }%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* Create a message queue.  If it fails, terminate both threads.              */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  hmqAsync = WinCreateMsgQueue( habAsync, 80);%@NL@%
  if( !hmqAsync)%@NL@%
  {%@NL@%
      WinPostMsg( hwndClient, WM_QUIT, NULL, NULL);%@NL@%
      WinTerminate( habAsync);%@NL@%
      DosExit( EXIT_THREAD, 0);%@NL@%
  }%@NL@%
 %@NL@%
  DosSetPrty( PRTYS_THREAD, PRTYC_NOCHANGE, sPrty, (TID)NULL);%@NL@%
 %@NL@%
 %@NL@%
  while( TRUE)%@NL@%
  {%@NL@%
    WinGetMsg( habAsync, &qmsgAsync, NULL, 0, 0);%@NL@%
 %@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/* process the commands                                                   */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    switch( qmsgAsync.msg)%@NL@%
    {%@NL@%
 %@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_LOAD:%@NL@%
        Load( (PLOADINFO)qmsgAsync.mp1);%@NL@%
        Redraw();%@NL@%
        break;%@NL@%
%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_JUMBLE:%@NL@%
        Jumble();%@NL@%
        Redraw();%@NL@%
        break;%@NL@%
%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_REDRAW:%@NL@%
        Redraw();%@NL@%
        break;%@NL@%
%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* DRAW will use the passed region containing the invalidated area of   */%@AE@%%@NL@%
      %@AB@%/* the screen, repaint it and then destroy the region.                      */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_DRAW:%@NL@%
        DoDraw( (HRGN)qmsgAsync.mp1);%@NL@%
        if( qmsgAsync.mp1)%@NL@%
            GpiDestroyRegion( hpsClient, (HRGN)qmsgAsync.mp1);%@NL@%
        break;%@NL@%
 %@NL@%
 %@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* Get new scroll posn from command ( i.e. +/-1 +/-page) or new              */%@AE@%%@NL@%
      %@AB@%/* absolute position from parameter, update scroll posn, change the     */%@AE@%%@NL@%
      %@AB@%/* transform and update the thumb posn.  Finally update the window.     */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_HSCROLL:%@NL@%
        switch( SHORT2FROMMP( qmsgAsync.mp1) )%@NL@%
        {%@NL@%
            case SB_LINEUP:%@NL@%
                ptsScrollPos.x -= ptsScrollLine.x;%@NL@%
                break;%@NL@%
            case SB_LINEDOWN:%@NL@%
                ptsScrollPos.x += ptsScrollLine.x;%@NL@%
                break;%@NL@%
            case SB_SLIDERTRACK:%@NL@%
            case SB_SLIDERPOSITION:%@NL@%
                for( fDone = FALSE; !fDone ;)%@NL@%
                {%@NL@%
                  if( WinPeekMsg( habAsync%@NL@%
                                , &qmsgPeek%@NL@%
                                , NULL%@NL@%
                                , UM_HSCROLL%@NL@%
                                , UM_HSCROLL%@NL@%
                                , PM_NOREMOVE))%@NL@%
                      if(   (SHORT2FROMMP( qmsgPeek.mp1) == SB_SLIDERTRACK)%@NL@%
                          ||(SHORT2FROMMP( qmsgPeek.mp1) == SB_SLIDERPOSITION) )%@NL@%
                          WinPeekMsg( habAsync%@NL@%
                                    , &qmsgAsync%@NL@%
                                    , NULL%@NL@%
                                    , UM_HSCROLL%@NL@%
                                    , UM_HSCROLL%@NL@%
                                    , PM_REMOVE);%@NL@%
                      else%@NL@%
                          fDone = TRUE;%@NL@%
                  else%@NL@%
                      fDone = TRUE;%@NL@%
                }%@NL@%
                ptsScrollPos.x = SHORT1FROMMP( qmsgAsync.mp1);%@NL@%
                break;%@NL@%
            case SB_PAGEUP:%@NL@%
                ptsScrollPos.x -= ptsScrollPage.x;%@NL@%
                break;%@NL@%
            case SB_PAGEDOWN:%@NL@%
                ptsScrollPos.x += ptsScrollPage.x;%@NL@%
                break;%@NL@%
            case SB_ENDSCROLL:%@NL@%
                break;%@NL@%
            default:%@NL@%
                break;%@NL@%
        }%@NL@%
        DoHorzScroll();%@NL@%
        break;%@NL@%
 %@NL@%
      case UM_VSCROLL:%@NL@%
        switch( SHORT2FROMMP( qmsgAsync.mp1) )%@NL@%
        {%@NL@%
            case SB_LINEUP:%@NL@%
                ptsScrollPos.y -= ptsScrollLine.y;%@NL@%
                break;%@NL@%
            case SB_LINEDOWN:%@NL@%
                ptsScrollPos.y += ptsScrollLine.y;%@NL@%
                break;%@NL@%
            case SB_SLIDERTRACK:%@NL@%
            case SB_SLIDERPOSITION:%@NL@%
                for( fDone = FALSE; !fDone ;)%@NL@%
                {%@NL@%
                  if( WinPeekMsg( habAsync%@NL@%
                                , &qmsgPeek%@NL@%
                                , NULL%@NL@%
                                , UM_VSCROLL%@NL@%
                                , UM_VSCROLL%@NL@%
                                , PM_NOREMOVE))%@NL@%
                      if(   (SHORT2FROMMP( qmsgPeek.mp1) == SB_SLIDERTRACK)%@NL@%
                          ||(SHORT2FROMMP( qmsgPeek.mp1) == SB_SLIDERPOSITION) )%@NL@%
                          WinPeekMsg( habAsync%@NL@%
                                    , &qmsgAsync%@NL@%
                                    , NULL%@NL@%
                                    , UM_VSCROLL%@NL@%
                                    , UM_VSCROLL%@NL@%
                                    , PM_REMOVE);%@NL@%
                      else%@NL@%
                          fDone = TRUE;%@NL@%
                  else%@NL@%
                      fDone = TRUE;%@NL@%
                }%@NL@%
                ptsScrollPos.y = SHORT1FROMMP( qmsgAsync.mp1);%@NL@%
                break;%@NL@%
            case SB_PAGEUP:%@NL@%
                ptsScrollPos.y -= ptsScrollPage.y;%@NL@%
                break;%@NL@%
            case SB_PAGEDOWN:%@NL@%
                ptsScrollPos.y += ptsScrollPage.y;%@NL@%
                break;%@NL@%
            case SB_ENDSCROLL:%@NL@%
                break;%@NL@%
            default:%@NL@%
                break;%@NL@%
        }%@NL@%
        DoVertScroll();%@NL@%
        break;%@NL@%
 %@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* recalc the picture transform                                         */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_SIZING:%@NL@%
        CalcBounds();%@NL@%
        CalcTransform( hwndClient);%@NL@%
        break;%@NL@%
 %@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* adjust zoom factor                                                   */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_ZOOM_IN:%@NL@%
        Zoom( ZOOM_IN_ARG);%@NL@%
        break;%@NL@%
 %@NL@%
      case UM_ZOOM_OUT:%@NL@%
        Zoom( ZOOM_OUT_ARG);%@NL@%
        break;%@NL@%
%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* toggle fast-drag                                                      */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_FASTDRAG:%@NL@%
        ToggleFastDrag();%@NL@%
        break;%@NL@%
 %@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* Button down will cause a correlate on the picture to test for a hit. */%@AE@%%@NL@%
      %@AB@%/* Any selected segment will be highlighted and redrawn as dynamic.     */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_LEFTDOWN:%@NL@%
        LeftDown( qmsgAsync.mp1);%@NL@%
        break;%@NL@%
 %@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* if a segment is being dragged it will be redrawn in a new posn       */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_MOUSEMOVE:%@NL@%
        for( fDone = FALSE; !fDone ;)%@NL@%
        {%@NL@%
          if( WinPeekMsg( habAsync%@NL@%
                        , &qmsgPeek%@NL@%
                        , NULL%@NL@%
                        , UM_MOUSEMOVE%@NL@%
                        , UM_LEFTUP%@NL@%
                        , PM_NOREMOVE))%@NL@%
              if( qmsgPeek.msg == UM_MOUSEMOVE)%@NL@%
                  WinPeekMsg( habAsync%@NL@%
                            , &qmsgAsync%@NL@%
                            , NULL%@NL@%
                            , UM_MOUSEMOVE%@NL@%
                            , UM_MOUSEMOVE%@NL@%
                            , PM_REMOVE);%@NL@%
              else%@NL@%
                  fDone = TRUE;%@NL@%
          else%@NL@%
              fDone = TRUE;%@NL@%
        }%@NL@%
        MouseMove( qmsgAsync.mp1);%@NL@%
        break;%@NL@%
 %@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* if a segment is being dragged it will be redrawn as normal              */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_LEFTUP:%@NL@%
        LeftUp();%@NL@%
        break;%@NL@%
 %@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* destroy resources and terminate                                     */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_DIE:%@NL@%
        WinDestroyMsgQueue( hmqAsync);%@NL@%
        WinTerminate( habAsync);%@NL@%
        DosEnterCritSec();%@NL@%
        DosSemClear( hsemTerminate);%@NL@%
        DosExit( EXIT_THREAD, 0);%@NL@%
        break;%@NL@%
 %@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* finish flush of commands from queue                                      */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      case UM_FLUSH:%@NL@%
        break;%@NL@%
 %@NL@%
      default:%@NL@%
        break;%@NL@%
    }%@NL@%
  }%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/* button down will cause one segment to be indicated and made dynamic              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
LeftDown( mp)%@NL@%
%@NL@%
MPARAM         mp;%@NL@%
{%@NL@%
  HRGN            hrgnUpdt;%@NL@%
  LONG            alSegTag[HITS][DEPTH][2];%@NL@%
  POINTL    ptl, aptl[4];%@NL@%
  RECTL     rcl;%@NL@%
  MATRIXLF  matlf;%@NL@%
  LONG            lOffset;%@NL@%
  BYTE            bBuff[128];%@NL@%
  CHAR            pszMsg[40];%@NL@%
  PSZ            psz1, psz2;%@NL@%
%@NL@%
  ptl.x = (LONG)(SHORT)SHORT1FROMMP( mp);%@NL@%
  ptl.y = (LONG)(SHORT)SHORT2FROMMP( mp);%@NL@%
%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  for( pslPicked = pslTail; pslPicked != NULL; pslPicked = pslPicked->pslPrev)%@NL@%
  {%@NL@%
    rcl = pslPicked->rclCurrent;%@NL@%
    GpiConvert( hpsClient, CVTC_MODEL, CVTC_DEVICE, 2L, (PPOINTL)&rcl);%@NL@%
    rcl.xRight++;%@NL@%
    rcl.yTop++;%@NL@%
    if( WinPtInRect( habAsync, &rcl, &ptl))%@NL@%
    {%@NL@%
        LONG lRet;%@NL@%
%@NL@%
        GpiSetEditMode( hpsClient, SEGEM_INSERT);%@NL@%
        GpiOpenSegment( hpsClient, pslPicked->lSegId);%@NL@%
        GpiSetElementPointerAtLabel( hpsClient, FILLPATH);%@NL@%
        GpiFillPath( hpsClient, 1L, 0L);%@NL@%
        GpiCloseSegment( hpsClient);%@NL@%
        lRet = GpiCorrelateSegment( hpsClient%@NL@%
                                  , pslPicked->lSegId%@NL@%
                                  , PICKSEL_VISIBLE%@NL@%
                                  , &ptl%@NL@%
                                  , HITS%@NL@%
                                  , DEPTH%@NL@%
                                  , (PLONG)alSegTag );%@NL@%
        GpiOpenSegment( hpsClient, pslPicked->lSegId);%@NL@%
        GpiSetElementPointerAtLabel( hpsClient, FILLPATH);%@NL@%
        GpiOffsetElementPointer( hpsClient, 1L);%@NL@%
        GpiDeleteElement( hpsClient);%@NL@%
        GpiCloseSegment( hpsClient);%@NL@%
%@NL@%
        if( lRet > 0)%@NL@%
            break;%@NL@%
    }%@NL@%
  }%@NL@%
  if( pslPicked)%@NL@%
    lPickedSeg         = pslPicked->lSegId;%@NL@%
  else%@NL@%
  {%@NL@%
    fButtonDown = FALSE;%@NL@%
    return;%@NL@%
  }%@NL@%
  if( (lPickedSeg < 1) || (lPickedSeg > lLastSegId) )%@NL@%
  {%@NL@%
    DosSemRequest( hsemSzFmt, SEM_INDEFINITE_WAIT);%@NL@%
    sprintf( szFmt, "Segment id out of range: %x", lPickedSeg);%@NL@%
    for( psz1 = szFmt, psz2 = pszMsg; *psz2++ = *psz1++; )%@NL@%
        ;%@NL@%
    DosSemClear( hsemSzFmt);%@NL@%
    MyMessageBox( hwndClient, pszMsg);%@NL@%
    fButtonDown = FALSE;%@NL@%
    return;%@NL@%
  }%@NL@%
%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  hrgnUpdt = GpiCreateRegion( hpsClient, 1L, &rcl);%@NL@%
  GpiSetSegmentAttrs( hpsClient, lPickedSeg, ATTR_VISIBLE, ATTR_OFF);%@NL@%
%@NL@%
  GpiQuerySegmentTransformMatrix( hpsClient%@NL@%
                                , lPickedSeg%@NL@%
                                , 9L%@NL@%
                                , &matlf );%@NL@%
  GpiBeginPath( hpsClient, 1L);%@NL@%
  GpiCallSegmentMatrix( hpsClient%@NL@%
                      , lPickedSeg + CALLSEG_BASE%@NL@%
                      , 9L%@NL@%
                      , &matlf%@NL@%
                      , TRANSFORM_REPLACE );%@NL@%
  GpiEndPath( hpsClient);%@NL@%
  GpiSetClipPath( hpsClient, 1L, SCP_AND);%@NL@%
  DoDraw( hrgnUpdt);%@NL@%
  GpiSetClipPath( hpsClient, 0L, SCP_RESET);%@NL@%
  GpiDestroyRegion( hpsClient, hrgnUpdt);%@NL@%
%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  ptlOffset = ptlBotLeft;%@NL@%
  GpiConvert( hpsClient, CVTC_WORLD, CVTC_DEVICE, 1L, &ptlOffset);%@NL@%
%@NL@%
  aptl[0].x = pslPicked->rclBitBlt.xLeft;%@NL@%
  aptl[0].y = pslPicked->rclBitBlt.yBottom;%@NL@%
  aptl[1].x = pslPicked->rclBitBlt.xRight;%@NL@%
  aptl[1].y = pslPicked->rclBitBlt.yTop;%@NL@%
  aptl[2] = aptl[0];%@NL@%
  aptl[3] = aptl[1];%@NL@%
  GpiConvert( hpsClient, CVTC_WORLD, CVTC_DEVICE, 2L, &aptl[2]);%@NL@%
  aptl[2].x -= ptlOffset.x;%@NL@%
  aptl[2].y -= ptlOffset.y;%@NL@%
  aptl[3].x -= ptlOffset.x - 1;%@NL@%
  aptl[3].y -= ptlOffset.y - 1;%@NL@%
  GpiSetEditMode( hpsClient, SEGEM_INSERT);%@NL@%
%@NL@%
  for( lOffset = 0L; GpiGetData( hpsClient%@NL@%
                               , lPickedSeg%@NL@%
                               , &lOffset%@NL@%
                               , DFORM_NOCONV%@NL@%
                               , (LONG)sizeof( bBuff)%@NL@%
                               , bBuff) > 0; )%@NL@%
      ;%@NL@%
%@NL@%
  GpiOpenSegment( hpsClient, lPickedSeg);%@NL@%
  GpiDeleteElementsBetweenLabels( hpsClient, BITBLT_TOP, BITBLT_BOTTOM);%@NL@%
  if( !fFastDrag)%@NL@%
      GpiWCBitBlt( hpsClient%@NL@%
                 , hbmBitmapDrag%@NL@%
                 , 4L%@NL@%
                 , aptl%@NL@%
                 , ROP_SRCCOPY%@NL@%
                 , BBO_IGNORE );%@NL@%
  GpiCloseSegment( hpsClient);%@NL@%
%@NL@%
  for( lOffset = 0L; GpiGetData( hpsClient%@NL@%
                               , lPickedSeg%@NL@%
                               , &lOffset%@NL@%
                               , DFORM_NOCONV%@NL@%
                               , (LONG)sizeof( bBuff)%@NL@%
                               , bBuff) > 0; )%@NL@%
      ;%@NL@%
%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  GpiSetSegmentAttrs( hpsClient, lPickedSeg, ATTR_VISIBLE, ATTR_ON);%@NL@%
  GpiSetSegmentAttrs( hpsClient, lPickedSeg, ATTR_DYNAMIC, ATTR_ON);%@NL@%
  GpiSetDrawControl( hpsClient, DCTL_DYNAMIC, DCTL_ON);%@NL@%
  GpiDrawSegment( hpsClient, lPickedSeg);%@NL@%
%@NL@%
  WinSetCapture( HWND_DESKTOP, hwndClient);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* move the segment                                                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
MouseMove( mp)%@NL@%
%@NL@%
MPARAM         mp;%@NL@%
{%@NL@%
  RECTL   rcl;%@NL@%
  POINTL  ptl, ptlModel;%@NL@%
 %@NL@%
  ptl.x = (LONG)(SHORT)SHORT1FROMMP( mp);%@NL@%
  ptl.y = (LONG)(SHORT)SHORT2FROMMP( mp);%@NL@%
%@NL@%
  ptlModel = ptl;%@NL@%
  GpiConvert( hpsClient, CVTC_DEVICE, CVTC_MODEL, 1L, &ptlModel);%@NL@%
  ptlModel.x = 5 * (ptlModel.x / 5);%@NL@%
  ptlModel.y = 5 * (ptlModel.y / 5);%@NL@%
  if( (ptlModel.x == ptlOldMouse.x) && (ptlModel.y == ptlOldMouse.y))%@NL@%
    return;%@NL@%
  ptlOldMouse.x = ptlModel.x;%@NL@%
  ptlOldMouse.y = ptlModel.y;%@NL@%
%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* clip mouse coords to client window                                       */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  WinQueryWindowRect(hwndClient, &rcl);%@NL@%
  if (rcl.xLeft > ptl.x)%@NL@%
    ptl.x = rcl.xLeft;%@NL@%
  if (rcl.xRight <= ptl.x)%@NL@%
    ptl.x = rcl.xRight;%@NL@%
  if (rcl.yBottom > ptl.y)%@NL@%
    ptl.y = rcl.yBottom;%@NL@%
  if (rcl.yTop <= ptl.y)%@NL@%
    ptl.y = rcl.yTop;%@NL@%
%@NL@%
  GpiRemoveDynamics( hpsClient, lPickedSeg, lPickedSeg);%@NL@%
  Translate( pslPicked, &ptl);%@NL@%
  GpiDrawDynamics( hpsClient);%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/* The dragged segment is being unselected.  Return it to its normal state.   */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
LeftUp()%@NL@%
{%@NL@%
  SEGLIST    sl;%@NL@%
  POINTL     aptl[4];%@NL@%
%@NL@%
  if( !lPickedSeg)%@NL@%
    return;%@NL@%
  GpiRemoveDynamics( hpsClient, lPickedSeg, lPickedSeg);%@NL@%
  GpiSetSegmentAttrs( hpsClient, lPickedSeg, ATTR_DYNAMIC, ATTR_OFF);%@NL@%
%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  ptlOffset = ptlBotLeft;%@NL@%
  GpiConvert( hpsClient, CVTC_WORLD, CVTC_DEVICE, 1L, &ptlOffset);%@NL@%
%@NL@%
  aptl[0].x = pslPicked->rclBitBlt.xLeft;%@NL@%
  aptl[0].y = pslPicked->rclBitBlt.yBottom;%@NL@%
  aptl[1].x = pslPicked->rclBitBlt.xRight;%@NL@%
  aptl[1].y = pslPicked->rclBitBlt.yTop;%@NL@%
  aptl[2] = aptl[0];%@NL@%
  aptl[3] = aptl[1];%@NL@%
  GpiConvert( hpsClient, CVTC_WORLD, CVTC_DEVICE, 2L, &aptl[2]);%@NL@%
  aptl[2].x -= ptlOffset.x;%@NL@%
  aptl[2].y -= ptlOffset.y;%@NL@%
  aptl[3].x -= ptlOffset.x - 1;%@NL@%
  aptl[3].y -= ptlOffset.y - 1;%@NL@%
  GpiSetEditMode( hpsClient, SEGEM_INSERT);%@NL@%
  GpiOpenSegment( hpsClient, lPickedSeg);%@NL@%
  GpiDeleteElementsBetweenLabels( hpsClient, BITBLT_TOP, BITBLT_BOTTOM);%@NL@%
  GpiWCBitBlt( hpsClient%@NL@%
             , hbmBitmapTemp%@NL@%
             , 4L%@NL@%
             , aptl%@NL@%
             , ROP_SRCCOPY%@NL@%
             , BBO_IGNORE );%@NL@%
  GpiCloseSegment( hpsClient);%@NL@%
%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  GpiDrawSegment( hpsClient, lPickedSeg);%@NL@%
  GpiSetSegmentPriority( hpsClient, lPickedSeg, 0L, LOWER_PRI); %@AB@%/* highest    */%@AE@%%@NL@%
  SetRect( pslPicked);%@NL@%
%@NL@%
  sl = *pslPicked;%@NL@%
  SegListUpdate( DEL_SEG, pslPicked);%@NL@%
  SegListUpdate( ADD_TAIL_SEG, &sl);            %@AB@%/* at tail => highest priority    */%@AE@%%@NL@%
  pslPicked = NULL;%@NL@%
%@NL@%
  WinSetCapture( HWND_DESKTOP, (HWND)NULL);%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* DoHorzScroll will horizontally scroll the current contents of              */%@AE@%%@NL@%
%@AB@%/* the client area and redraw the invalidated area                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
DoHorzScroll()%@NL@%
{%@NL@%
  RECTL     rcl;%@NL@%
  HRGN            hrgn;%@NL@%
  MATRIXLF  matlf;%@NL@%
 %@NL@%
  if( ptsScrollPos.x > ptsScrollMax.x)%@NL@%
      ptsScrollPos.x = ptsScrollMax.x;%@NL@%
  if( ptsScrollPos.x < 0)%@NL@%
      ptsScrollPos.x = 0;%@NL@%
 %@NL@%
  if( ptsOldScrollPos.x != ptsScrollPos.x)%@NL@%
      WinSendMsg( hwndHorzScroll%@NL@%
                , SBM_SETPOS%@NL@%
                , MPFROM2SHORT( ptsScrollPos.x, 0)%@NL@%
                , MPFROMLONG( NULL));%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* Scroll the window the reqd amount, using bitblt'ing (ScrollWindow)       */%@AE@%%@NL@%
  %@AB@%/* if any of the screen still in view, and paint into uncovered region;     */%@AE@%%@NL@%
  %@AB@%/* else repaint the whole client area.                                      */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  hrgn = GpiCreateRegion( hpsClient, 0L, NULL);%@NL@%
  if( abs( ptsScrollPos.x - ptsOldScrollPos.x) <= ptsScrollMax.x)%@NL@%
  {%@NL@%
      WinScrollWindow( hwndClient%@NL@%
                     , ptsOldScrollPos.x - ptsScrollPos.x%@NL@%
                     , 0%@NL@%
                     , NULL%@NL@%
                     , NULL%@NL@%
                     , hrgn%@NL@%
                     , &rcl%@NL@%
                     , 0);%@NL@%
  } else%@NL@%
  {%@NL@%
      WinQueryWindowRect( hwndClient, &rcl);%@NL@%
      GpiSetRegion( hpsClient, hrgn, 1L, &rcl);%@NL@%
  }%@NL@%
  GpiQueryDefaultViewMatrix( hpsClient, 9L, &matlf );%@NL@%
  matlf.lM31 -= ptsScrollPos.x - ptsOldScrollPos.x;%@NL@%
  GpiSetDefaultViewMatrix( hpsClient, 9L, &matlf, TRANSFORM_REPLACE);%@NL@%
%@NL@%
  DoDraw( hrgn);%@NL@%
  ptsOldScrollPos.x = ptsScrollPos.x;%@NL@%
  GpiDestroyRegion( hpsClient, hrgn);%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* DoVertScroll will vertically scroll the current contents of                      */%@AE@%%@NL@%
%@AB@%/* the client area and redraw the invalidated area                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
DoVertScroll()%@NL@%
{%@NL@%
  RECTL     rcl;%@NL@%
  HRGN            hrgn;%@NL@%
  MATRIXLF  matlf;%@NL@%
 %@NL@%
  if( ptsScrollPos.y > ptsScrollMax.y)%@NL@%
      ptsScrollPos.y = ptsScrollMax.y;%@NL@%
  if( ptsScrollPos.y < 0)%@NL@%
      ptsScrollPos.y = 0;%@NL@%
 %@NL@%
  if( ptsOldScrollPos.y != ptsScrollPos.y)%@NL@%
      WinSendMsg( hwndVertScroll%@NL@%
                , SBM_SETPOS%@NL@%
                , MPFROM2SHORT( ptsScrollPos.y, 0)%@NL@%
                , MPFROMLONG( NULL));%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* Scroll the window the reqd amount, using bitblt'ing (ScrollWindow)       */%@AE@%%@NL@%
  %@AB@%/* if any of the screen still in view, and paint into uncovered region;     */%@AE@%%@NL@%
  %@AB@%/* else repaint the whole client area.                                      */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  hrgn = GpiCreateRegion( hpsClient, 0L, NULL);%@NL@%
  if( abs( ptsScrollPos.y - ptsOldScrollPos.y) <= ptsScrollMax.y)%@NL@%
  {%@NL@%
      WinScrollWindow( hwndClient%@NL@%
                     , 0%@NL@%
                     , ptsScrollPos.y - ptsOldScrollPos.y%@NL@%
                     , NULL%@NL@%
                     , NULL%@NL@%
                     , hrgn%@NL@%
                     , &rcl%@NL@%
                     , 0);%@NL@%
  } else%@NL@%
  {%@NL@%
      WinQueryWindowRect( hwndClient, &rcl);%@NL@%
      GpiSetRegion( hpsClient, hrgn, 1L, &rcl);%@NL@%
  }%@NL@%
  GpiQueryDefaultViewMatrix( hpsClient, 9L, &matlf );%@NL@%
  matlf.lM32 += ptsScrollPos.y - ptsOldScrollPos.y;%@NL@%
  GpiSetDefaultViewMatrix( hpsClient, 9L, &matlf, TRANSFORM_REPLACE);%@NL@%
%@NL@%
  DoDraw( hrgn);%@NL@%
  ptsOldScrollPos.y = ptsScrollPos.y;%@NL@%
  GpiDestroyRegion( hpsClient, hrgn);%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Redraw the entire client window.                                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Redraw()%@NL@%
{%@NL@%
  RECTL   rclInvalid;%@NL@%
  HRGN          hrgnUpdt;%@NL@%
 %@NL@%
  WinQueryWindowRect( hwndClient, &rclInvalid);%@NL@%
  hrgnUpdt = GpiCreateRegion( hpsClient, 1L, &rclInvalid);%@NL@%
  DoDraw( hrgnUpdt);%@NL@%
  GpiDestroyRegion( hpsClient, hrgnUpdt);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* toggle the fast-drag flag and update the menu check-box                      */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
ToggleFastDrag()%@NL@%
{%@NL@%
  MENUITEM mi;%@NL@%
  HWND           hwndMenu, hwndOptions;%@NL@%
%@NL@%
  hwndMenu = WinWindowFromID( hwndFrame, FID_MENU);%@NL@%
  WinSendMsg( hwndMenu%@NL@%
            , MM_QUERYITEM%@NL@%
            , MPFROM2SHORT( SM_OPTIONS, FALSE)%@NL@%
            , MPFROMP( (PMENUITEM)&mi));%@NL@%
  hwndOptions = mi.hwndSubMenu;%@NL@%
%@NL@%
  if( fFastDrag)%@NL@%
  {%@NL@%
    fFastDrag = FALSE;%@NL@%
    WinSendMsg( hwndOptions%@NL@%
              , MM_SETITEMATTR%@NL@%
              , MPFROM2SHORT( MENU_FASTDRAG, TRUE)%@NL@%
              , MPFROM2SHORT( MIA_CHECKED, ~MIA_CHECKED) );%@NL@%
  }%@NL@%
  else%@NL@%
  {%@NL@%
    fFastDrag = TRUE;%@NL@%
    WinSendMsg( hwndOptions%@NL@%
              , MM_SETITEMATTR%@NL@%
              , MPFROM2SHORT( MENU_FASTDRAG, TRUE)%@NL@%
              , MPFROM2SHORT( MIA_CHECKED, MIA_CHECKED) );%@NL@%
  }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* adjust zoom factor and recalc the picture transform, then do a redraw of   */%@AE@%%@NL@%
%@AB@%/* whole screen                                                               */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Zoom( sInOrOut)%@NL@%
%@NL@%
SHORT sInOrOut;%@NL@%
{%@NL@%
  LONG         lScaleOld;%@NL@%
%@NL@%
  lScaleOld = lScale;%@NL@%
  lScale += sInOrOut;%@NL@%
  if( lScale > ZOOM_MAX)%@NL@%
    lScale = ZOOM_MAX;%@NL@%
  else%@NL@%
    if( lScale < -ZOOM_MAX)%@NL@%
      lScale = -ZOOM_MAX;%@NL@%
  if( lScale != lScaleOld)%@NL@%
  {%@NL@%
      ZoomMenuItems();%@NL@%
      CalcBounds();%@NL@%
      CalcTransform( hwndClient);%@NL@%
      Redraw();%@NL@%
  }%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* enable/disable zoom menu items depending on scaling                        */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
ZoomMenuItems()%@NL@%
{%@NL@%
  MENUITEM  mi;%@NL@%
  HWND            hwndMenu, hwndOptions;%@NL@%
 %@NL@%
  hwndMenu = WinWindowFromID( hwndFrame, FID_MENU);%@NL@%
  WinSendMsg( hwndMenu%@NL@%
            , MM_QUERYITEM%@NL@%
            , MPFROM2SHORT( SM_OPTIONS, FALSE)%@NL@%
            , MPFROMP( (PMENUITEM)&mi));%@NL@%
  hwndOptions = mi.hwndSubMenu;%@NL@%
 %@NL@%
  if( lScale >= ZOOM_MAX)%@NL@%
  {%@NL@%
      WinSendMsg( hwndOptions%@NL@%
                , MM_SETITEMATTR%@NL@%
                , MPFROM2SHORT( MENU_ZOOMIN, TRUE)%@NL@%
                , MPFROM2SHORT( MIA_DISABLED, MIA_DISABLED));%@NL@%
      WinSendMsg( hwndOptions%@NL@%
                , MM_SETITEMATTR%@NL@%
                , MPFROM2SHORT( MENU_ZOOMOUT, TRUE)%@NL@%
                , MPFROM2SHORT( MIA_DISABLED, ~MIA_DISABLED));%@NL@%
  } else%@NL@%
  {%@NL@%
      if( lScale <= - ZOOM_MAX)%@NL@%
      {%@NL@%
          WinSendMsg( hwndOptions%@NL@%
                    , MM_SETITEMATTR%@NL@%
                    , MPFROM2SHORT( MENU_ZOOMOUT, TRUE)%@NL@%
                    , MPFROM2SHORT( MIA_DISABLED, MIA_DISABLED));%@NL@%
          WinSendMsg( hwndOptions%@NL@%
                    , MM_SETITEMATTR%@NL@%
                    , MPFROM2SHORT( MENU_ZOOMIN, TRUE)%@NL@%
                    , MPFROM2SHORT( MIA_DISABLED, ~MIA_DISABLED));%@NL@%
      } else%@NL@%
      {%@NL@%
          WinSendMsg( hwndOptions%@NL@%
                    , MM_SETITEMATTR%@NL@%
                    , MPFROM2SHORT( MENU_ZOOMOUT, TRUE)%@NL@%
                    , MPFROM2SHORT( MIA_DISABLED, ~MIA_DISABLED));%@NL@%
          WinSendMsg( hwndOptions%@NL@%
                    , MM_SETITEMATTR%@NL@%
                    , MPFROM2SHORT( MENU_ZOOMIN, TRUE)%@NL@%
                    , MPFROM2SHORT( MIA_DISABLED, ~MIA_DISABLED));%@NL@%
      }%@NL@%
  }%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Determine the bounding rect of a segment.                                      */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
SetRect( psl)%@NL@%
%@NL@%
PSEGLIST  psl;%@NL@%
{%@NL@%
  GpiResetBoundaryData( hpsClient);%@NL@%
  GpiSetDrawControl( hpsClient, DCTL_DISPLAY, DCTL_OFF);%@NL@%
  GpiSetDrawControl( hpsClient, DCTL_BOUNDARY, DCTL_ON);%@NL@%
  GpiDrawSegment( hpsClient, psl->lSegId);%@NL@%
  GpiSetDrawControl( hpsClient, DCTL_DISPLAY, DCTL_ON);%@NL@%
  GpiSetDrawControl( hpsClient, DCTL_BOUNDARY, DCTL_OFF);%@NL@%
  GpiQueryBoundaryData( hpsClient, &(psl->rclCurrent));%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Translate a segment                                                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
Translate( psl, pptlNew)%@NL@%
%@NL@%
PSEGLIST  psl;%@NL@%
PPOINTL   pptlNew;%@NL@%
{%@NL@%
  POINTL    ptl;%@NL@%
  MATRIXLF  matlf;%@NL@%
%@NL@%
  ptl = *pptlNew;%@NL@%
  GpiConvert( hpsClient, CVTC_DEVICE, CVTC_MODEL, 1L, &ptl);%@NL@%
  ptl.x = (ptl.x / 5) * 5;%@NL@%
  ptl.y = (ptl.y / 5) * 5;%@NL@%
  ptl.x -= 25;%@NL@%
  ptl.y -= 25;%@NL@%
%@NL@%
  GpiQuerySegmentTransformMatrix( hpsClient%@NL@%
                                , psl->lSegId%@NL@%
                                , 9L%@NL@%
                                , &matlf);%@NL@%
  matlf.lM31 = ptl.x - (psl->ptlLocation).x;%@NL@%
  matlf.lM32 = ptl.y - (psl->ptlLocation).y;%@NL@%
  GpiSetSegmentTransformMatrix( hpsClient%@NL@%
                              , psl->lSegId%@NL@%
                              , 9L%@NL@%
                              , &matlf%@NL@%
                              , TRANSFORM_REPLACE);%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* set the default viewing transform                                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
SetDVTransform( fx11, fx12, fx21, fx22, l31, l32, lType)%@NL@%
%@NL@%
FIXED        fx11, fx12, fx21, fx22;%@NL@%
LONG        l31, l32, lType;%@NL@%
{%@NL@%
  MATRIXLF  matlf;%@NL@%
%@NL@%
  matlf.fxM11 = fx11;%@NL@%
  matlf.fxM12 = fx12;%@NL@%
  matlf.lM13  = 0L;%@NL@%
  matlf.fxM21 = fx21;%@NL@%
  matlf.fxM22 = fx22;%@NL@%
  matlf.lM23  = 0L;%@NL@%
  matlf.lM31  = l31;%@NL@%
  matlf.lM32  = l32;%@NL@%
  matlf.lM33  = 1L;%@NL@%
  GpiSetDefaultViewMatrix( hpsClient, 9L, &matlf, lType);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* get bounding rect of whole picture in model coordinates                      */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
CalcBounds()%@NL@%
{%@NL@%
  PSEGLIST  psl;%@NL@%
  RECTL     rcl;%@NL@%
%@NL@%
  if( !pslHead)%@NL@%
    return;%@NL@%
  rclBounds = pslHead->rclCurrent;%@NL@%
  for( psl = pslHead->pslNext; psl != NULL; psl = psl->pslNext)%@NL@%
  {%@NL@%
    rcl = psl->rclCurrent;%@NL@%
    if( rcl.xLeft < rclBounds.xLeft)%@NL@%
      rclBounds.xLeft = rcl.xLeft;%@NL@%
    if( rcl.xRight > rclBounds.xRight)%@NL@%
      rclBounds.xRight = rcl.xRight;%@NL@%
    if( rcl.yTop > rclBounds.yTop)%@NL@%
      rclBounds.yTop = rcl.yTop;%@NL@%
    if( rcl.yBottom < rclBounds.yBottom)%@NL@%
      rclBounds.yBottom = rcl.yBottom;%@NL@%
  }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Calculate and set the default viewing transform based on zoom and scroll   */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
VOID%@NL@%
CalcTransform( hwnd)%@NL@%
%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
  RECTL     rclClient;%@NL@%
  POINTL    ptlCenter, ptlTrans, ptlScale, aptl[4];%@NL@%
  HRGN            hrgn;%@NL@%
  PSEGLIST  psl;%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* from bounding rect of picture get center of picture                      */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  ptlCenter.x = (rclBounds.xLeft   + rclBounds.xRight) / 2;%@NL@%
  ptlCenter.y = (rclBounds.yBottom + rclBounds.yTop  ) / 2;%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* translate center of picture to origin                                      */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  SetDVTransform( (FIXED)UNITY%@NL@%
                , (FIXED)0%@NL@%
                , (FIXED)0%@NL@%
                , (FIXED)UNITY%@NL@%
                , -ptlCenter.x%@NL@%
                , -ptlCenter.y%@NL@%
                , TRANSFORM_REPLACE);%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* scale down to 60% of max client area                                      */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  ptlScale.x = (6 * UNITY * sizlMaxClient.cx) /%@NL@%
               (10 * (ptlTopRight.x - ptlBotLeft.x));%@NL@%
  ptlScale.y = (6 * UNITY * sizlMaxClient.cy) /%@NL@%
               (10 * (ptlTopRight.y - ptlBotLeft.y));%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* add in zoom scale                                                              */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  ptlScale.x += ptlScale.x * lScale / (ZOOM_MAX + 1);%@NL@%
  ptlScale.y += ptlScale.y * lScale / (ZOOM_MAX + 1);%@NL@%
%@NL@%
  SetDVTransform( (FIXED)ptlScale.x%@NL@%
                , (FIXED)0%@NL@%
                , (FIXED)0%@NL@%
                , (FIXED)ptlScale.y%@NL@%
                , 0L%@NL@%
                , 0L%@NL@%
                , TRANSFORM_ADD);%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* translate center of picture to center of client window                      */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  WinQueryWindowRect( hwnd, &rclClient);%@NL@%
  ptlTrans.x = (rclClient.xRight - rclClient.xLeft)   / 2;%@NL@%
  ptlTrans.y = (rclClient.yTop         - rclClient.yBottom) / 2;%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* add in horizontal and vertical scrolling factors                              */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  ptlTrans.x += ptsScrollPos.x - ptsHalfScrollMax.x;%@NL@%
  ptlTrans.y += ptsScrollPos.y - ptsHalfScrollMax.y;%@NL@%
  SetDVTransform( (FIXED)UNITY%@NL@%
                , (FIXED)0%@NL@%
                , (FIXED)0%@NL@%
                , (FIXED)UNITY%@NL@%
                , ptlTrans.x%@NL@%
                , ptlTrans.y%@NL@%
                , TRANSFORM_ADD);%@NL@%
%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* create a shadow bitmap of the original, sized to the current output size */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  aptl[0] = ptlBotLeft;%@NL@%
  aptl[1] = ptlTopRight;%@NL@%
  GpiConvert( hpsClient, CVTC_WORLD, CVTC_DEVICE, 2L, aptl);%@NL@%
  ptlOffset = aptl[0];%@NL@%
%@NL@%
  aptl[0].x -= ptlOffset.x;%@NL@%
  aptl[0].y -= ptlOffset.y;%@NL@%
  aptl[1].x -= ptlOffset.x - 1;%@NL@%
  aptl[1].y -= ptlOffset.y - 1;%@NL@%
  aptl[2].x = 0L;%@NL@%
  aptl[2].y = 0L;%@NL@%
  aptl[3].x = bmpBitmapFile.cx;%@NL@%
  aptl[3].y = bmpBitmapFile.cy;%@NL@%
  GpiSetBitmap( hpsBitmapTemp, hbmBitmapTemp);%@NL@%
  GpiBitBlt( hpsBitmapTemp%@NL@%
           , hpsBitmapFile%@NL@%
           , 4L%@NL@%
           , aptl%@NL@%
           , ROP_SRCCOPY%@NL@%
           , BBO_IGNORE);%@NL@%
  GpiSetBitmap( hpsBitmapTemp, NULL);%@NL@%
%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* create a copy of the shadow bitmap, adjusted to appear normal when       */%@AE@%%@NL@%
  %@AB@%/* bitblt'd in XOR mode onto a CLR_BACKGROUND background (dynamic segment)  */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  GpiSetBitmap( hpsBitmapDrag, hbmBitmapDrag);%@NL@%
  GpiSetColor( hpsBitmapDrag, CLR_BACKGROUND);%@NL@%
  hrgn = GpiCreateRegion( hpsBitmapDrag, 1L, (PRECTL)aptl);%@NL@%
  GpiPaintRegion( hpsBitmapDrag, hrgn);%@NL@%
  GpiDestroyRegion( hpsBitmapDrag, hrgn);%@NL@%
  GpiBitBlt( hpsBitmapDrag%@NL@%
           , hpsBitmapFile%@NL@%
           , 4L%@NL@%
           , aptl%@NL@%
           , ROP_SRCINVERT%@NL@%
           , BBO_IGNORE);%@NL@%
  GpiSetBitmap( hpsBitmapDrag, NULL);%@NL@%
%@NL@%
  for( psl = pslHead; psl != NULL; psl = psl->pslNext)%@NL@%
  {%@NL@%
    aptl[0].x = psl->rclBitBlt.xLeft;%@NL@%
    aptl[0].y = psl->rclBitBlt.yBottom;%@NL@%
    aptl[1].x = psl->rclBitBlt.xRight;%@NL@%
    aptl[1].y = psl->rclBitBlt.yTop;%@NL@%
    aptl[2] = aptl[0];%@NL@%
    aptl[3] = aptl[1];%@NL@%
    GpiConvert( hpsClient, CVTC_WORLD, CVTC_DEVICE, 2L, &aptl[2]);%@NL@%
    aptl[2].x -= ptlOffset.x;%@NL@%
    aptl[2].y -= ptlOffset.y;%@NL@%
    aptl[3].x -= ptlOffset.x - 1;%@NL@%
    aptl[3].y -= ptlOffset.y - 1;%@NL@%
    GpiSetEditMode( hpsClient, SEGEM_INSERT);%@NL@%
    GpiOpenSegment( hpsClient, psl->lSegId);%@NL@%
    GpiDeleteElementsBetweenLabels( hpsClient, BITBLT_TOP, BITBLT_BOTTOM);%@NL@%
    GpiWCBitBlt( hpsClient%@NL@%
               , hbmBitmapTemp%@NL@%
               , 4L%@NL@%
               , aptl%@NL@%
               , ROP_SRCCOPY%@NL@%
               , BBO_IGNORE );%@NL@%
    GpiCloseSegment( hpsClient);%@NL@%
  }%@NL@%
}%@NL@%
 %@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Draw the picture, using the passed region for clipping.                      */%@AE@%%@NL@%
%@AB@%/* Test each segment to see if its bounding box intersects the bounding box   */%@AE@%%@NL@%
%@AB@%/* of the clipping region.  Draw only if there is an intersection.              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
DoDraw( hrgn)%@NL@%
%@NL@%
HRGN        hrgn;%@NL@%
{%@NL@%
  HRGN            hrgnOld;%@NL@%
  RECTL     rcl, rclRegion, rclDst;%@NL@%
  PSEGLIST  psl;%@NL@%
%@NL@%
  GpiSetColor( hpsClient, CLR_BACKGROUND);%@NL@%
  GpiPaintRegion( hpsClient, hrgn);%@NL@%
%@NL@%
  GpiQueryRegionBox( hpsClient, hrgn, &rclRegion);%@NL@%
  GpiSetClipRegion( hpsClient, hrgn, &hrgnOld);%@NL@%
  for( psl = pslHead; psl != NULL; psl = psl->pslNext)%@NL@%
  {%@NL@%
    rcl = psl->rclCurrent;%@NL@%
    GpiConvert( hpsClient, CVTC_MODEL, CVTC_DEVICE, 2L, (PPOINTL)&rcl);%@NL@%
    rcl.xRight++;%@NL@%
    rcl.yTop++;%@NL@%
    if( WinIntersectRect( habAsync, &rclDst, &rcl, &rclRegion))%@NL@%
        GpiDrawSegment( hpsClient, psl->lSegId);%@NL@%
  }%@NL@%
  GpiSetClipRegion( hpsClient, NULL, &hrgnOld);%@NL@%
%@NL@%
  return( TRUE);%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Return a pointer to a segment list member, based on segment id.              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
PSEGLIST%@NL@%
SegListGet( lSeg)%@NL@%
%@NL@%
LONG           lSeg;%@NL@%
{%@NL@%
  PSEGLIST  psl;%@NL@%
%@NL@%
  for( psl = pslHead; psl != NULL; psl = psl->pslNext)%@NL@%
    if( psl->lSegId == lSeg)%@NL@%
      return( psl);%@NL@%
  return( NULL);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Check the segment list for obvious errors.                                      */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
SegListCheck( iLoc)%@NL@%
%@NL@%
INT   iLoc;%@NL@%
{%@NL@%
  PSEGLIST   psl;%@NL@%
  CHAR             pszMsg[50];%@NL@%
  PSZ             psz1, psz2;%@NL@%
%@NL@%
  pszMsg[0] = '\0';%@NL@%
  for( psl = pslHead; psl != NULL; psl = psl->pslNext)%@NL@%
    if( (psl->lSegId < 1) || (psl->lSegId > lLastSegId) )%@NL@%
    {%@NL@%
      DosSemRequest( hsemSzFmt, SEM_INDEFINITE_WAIT);%@NL@%
      sprintf( szFmt, "Bad head segment list, location %d", iLoc);%@NL@%
      for( psz1 = szFmt, psz2 = pszMsg; *psz2++ = *psz1++; )%@NL@%
          ;%@NL@%
      DosSemClear( hsemSzFmt);%@NL@%
      MyMessageBox( hwndClient, pszMsg);%@NL@%
      return( FALSE);%@NL@%
    }%@NL@%
  for( psl = pslTail; psl != NULL; psl = psl->pslPrev)%@NL@%
    if( (psl->lSegId < 1) || (psl->lSegId > lLastSegId) )%@NL@%
    {%@NL@%
      DosSemRequest( hsemSzFmt, SEM_INDEFINITE_WAIT);%@NL@%
      sprintf( szFmt, "Bad head segment list, location %d", iLoc);%@NL@%
      for( psz1 = szFmt, psz2 = pszMsg; *psz2++ = *psz1++; )%@NL@%
          ;%@NL@%
      DosSemClear( hsemSzFmt);%@NL@%
      MyMessageBox( hwndClient, pszMsg);%@NL@%
      return( FALSE);%@NL@%
    }%@NL@%
  return( TRUE);%@NL@%
}%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Add (at head or tail) or delete a specified segment list member.              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
SegListUpdate( usOperation, pslUpdate)%@NL@%
%@NL@%
USHORT         usOperation;%@NL@%
PSEGLIST pslUpdate;%@NL@%
{%@NL@%
  PSEGLIST psl;%@NL@%
  SEL           sel;%@NL@%
%@NL@%
  switch( usOperation)%@NL@%
  {%@NL@%
    case ADD_HEAD_SEG:%@NL@%
      DosAllocSeg( sizeof( SEGLIST), &sel, 0);%@NL@%
      if( pslHead == NULL)%@NL@%
      {%@NL@%
        pslHead = MAKEP( sel, 0);%@NL@%
        if( pslHead == NULL)%@NL@%
          return( FALSE);%@NL@%
        *pslHead = *pslUpdate;%@NL@%
        pslHead->pslPrev = NULL;%@NL@%
        pslHead->pslNext = NULL;%@NL@%
        pslTail = pslHead;%@NL@%
      } else%@NL@%
      {%@NL@%
        psl = MAKEP( sel, 0);%@NL@%
        if( psl == NULL)%@NL@%
          return( FALSE);%@NL@%
        *psl = *pslUpdate;%@NL@%
        pslHead->pslPrev = psl;%@NL@%
        psl->pslNext = pslHead;%@NL@%
        psl->pslPrev = NULL;%@NL@%
        pslHead = psl;%@NL@%
      }%@NL@%
      return( TRUE);%@NL@%
      break;%@NL@%
%@NL@%
    case ADD_TAIL_SEG:%@NL@%
      DosAllocSeg( sizeof( SEGLIST), &sel, 0);%@NL@%
      if( pslTail == NULL)%@NL@%
      {%@NL@%
        pslHead = MAKEP( sel, 0);%@NL@%
        if( pslHead == NULL)%@NL@%
          return( FALSE);%@NL@%
        *pslHead = *pslUpdate;%@NL@%
        pslHead->pslPrev = NULL;%@NL@%
        pslHead->pslNext = NULL;%@NL@%
        pslTail = pslHead;%@NL@%
      } else%@NL@%
      {%@NL@%
        psl = MAKEP( sel, 0);%@NL@%
        if( psl == NULL)%@NL@%
          return( FALSE);%@NL@%
        *psl = *pslUpdate;%@NL@%
        pslTail->pslNext = psl;%@NL@%
        psl->pslPrev = pslTail;%@NL@%
        psl->pslNext = NULL;%@NL@%
        pslTail = psl;%@NL@%
      }%@NL@%
      return( TRUE);%@NL@%
      break;%@NL@%
%@NL@%
    case DEL_SEG:%@NL@%
      for( psl = pslHead; psl != NULL; psl = psl->pslNext)%@NL@%
      {%@NL@%
        if( psl->lSegId == pslUpdate->lSegId)%@NL@%
        {%@NL@%
          if( psl == pslHead)%@NL@%
          {%@NL@%
            pslHead = psl->pslNext;%@NL@%
            if( pslHead == NULL)%@NL@%
              pslTail = NULL;%@NL@%
            else%@NL@%
              pslHead->pslPrev = NULL;%@NL@%
          }else if( psl == pslTail)%@NL@%
          {%@NL@%
            pslTail = psl->pslPrev;%@NL@%
            pslTail->pslNext = NULL;%@NL@%
          } else%@NL@%
          {%@NL@%
            (psl->pslPrev)->pslNext = psl->pslNext;%@NL@%
            (psl->pslNext)->pslPrev = psl->pslPrev;%@NL@%
          }%@NL@%
          DosFreeSeg( SELECTOROF(psl));%@NL@%
          return( TRUE);%@NL@%
          break;%@NL@%
        }%@NL@%
      }%@NL@%
      return( FALSE);%@NL@%
      break;%@NL@%
%@NL@%
    default:%@NL@%
      return( FALSE);%@NL@%
  }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* DumpPicture will free the list and segment store for the picture              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
DumpPicture()%@NL@%
{%@NL@%
  while( pslHead != NULL )%@NL@%
    SegListUpdate( DEL_SEG, pslHead);%@NL@%
  GpiDeleteSegments( hpsClient, 1L, CALLSEG_BASE + lLastSegId);%@NL@%
  GpiSetBitmap( hpsBitmapFile, NULL);%@NL@%
  if( hbmBitmapFile)%@NL@%
      GpiDeleteBitmap( hbmBitmapFile);%@NL@%
  GpiSetBitmap( hpsBitmapTemp, NULL);%@NL@%
  if( hbmBitmapTemp)%@NL@%
      GpiDeleteBitmap( hbmBitmapTemp);%@NL@%
  GpiSetBitmap( hpsBitmapDrag, NULL);%@NL@%
  if( hbmBitmapDrag)%@NL@%
      GpiDeleteBitmap( hbmBitmapDrag);%@NL@%
%@NL@%
  return( TRUE);%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Draw the picture into segment store.                                       */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
CreatePicture()%@NL@%
{%@NL@%
 %@NL@%
  POINTL    ptl, aptlSides[12], aptlControl[12];%@NL@%
  SEGLIST   sl;%@NL@%
  LONG            lCallSegId, l;%@NL@%
%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* reset the default viewing transform to identity                              */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  SetDVTransform( (FIXED)UNITY%@NL@%
                , (FIXED)0%@NL@%
                , (FIXED)0%@NL@%
                , (FIXED)UNITY%@NL@%
                , 0L%@NL@%
                , 0L%@NL@%
                , TRANSFORM_REPLACE);%@NL@%
%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* set to store mode                                                              */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  GpiSetDrawingMode( hpsClient, DM_RETAIN);%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* chaining and detectability off, fastchaining off                              */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  GpiSetInitialSegmentAttrs( hpsClient, ATTR_CHAINED, ATTR_OFF);%@NL@%
  GpiSetInitialSegmentAttrs( hpsClient, ATTR_DETECTABLE, ATTR_OFF);%@NL@%
  GpiSetInitialSegmentAttrs( hpsClient, ATTR_FASTCHAIN, ATTR_OFF);%@NL@%
 %@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  %@AB@%/* draw the pieces                                                              */%@AE@%%@NL@%
  %@AB@%/****************************************************************************/%@AE@%%@NL@%
  lLastSegId = 0;%@NL@%
  lCallSegId = CALLSEG_BASE;%@NL@%
  for( ptl.x = ptlBotLeft.x; ptl.x < ptlTopRight.x; ptl.x += 50)%@NL@%
  {%@NL@%
    for( ptl.y = ptlBotLeft.y; ptl.y < ptlTopRight.y; ptl.y += 50)%@NL@%
    {%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* compute the piece outline control points                              */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      aptlControl[0].x = 10L;%@NL@%
      aptlControl[0].y = 10L;%@NL@%
      aptlControl[1].x = 40L;%@NL@%
      aptlControl[1].y = -10L;%@NL@%
      aptlControl[2].x = 50L;%@NL@%
      aptlControl[2].y = 0L;%@NL@%
%@NL@%
      aptlControl[3].x = 40L;%@NL@%
      aptlControl[3].y = 10L;%@NL@%
      aptlControl[4].x = 60L;%@NL@%
      aptlControl[4].y = 40L;%@NL@%
      aptlControl[5].x = 50L;%@NL@%
      aptlControl[5].y = 50L;%@NL@%
%@NL@%
      aptlControl[6].x = 40L;%@NL@%
      aptlControl[6].y = 40L;%@NL@%
      aptlControl[7].x = 10L;%@NL@%
      aptlControl[7].y = 60L;%@NL@%
      aptlControl[8].x = 0L;%@NL@%
      aptlControl[8].y = 50L;%@NL@%
%@NL@%
      aptlControl[9].x        = 10L;%@NL@%
      aptlControl[9].y        = 40L;%@NL@%
      aptlControl[10].x = -10L;%@NL@%
      aptlControl[10].y = 10L;%@NL@%
      aptlControl[11].x = 0L;%@NL@%
      aptlControl[11].y = 0L;%@NL@%
%@NL@%
      if( ptl.y == ptlBotLeft.y)%@NL@%
      {%@NL@%
        aptlControl[0].y = 0L;%@NL@%
        aptlControl[1].y = 0L;%@NL@%
      }%@NL@%
%@NL@%
      if( (ptl.x + 50) == ptlTopRight.x)%@NL@%
      {%@NL@%
        aptlControl[3].x = 50L;%@NL@%
        aptlControl[4].x = 50L;%@NL@%
      }%@NL@%
%@NL@%
      if( (ptl.y + 50) == ptlTopRight.y)%@NL@%
      {%@NL@%
        aptlControl[6].y = 50L;%@NL@%
        aptlControl[7].y = 50L;%@NL@%
      }%@NL@%
%@NL@%
      if( ptl.x == ptlBotLeft.x)%@NL@%
      {%@NL@%
        aptlControl[ 9].x = 0L;%@NL@%
        aptlControl[10].x = 0L;%@NL@%
      }%@NL@%
%@NL@%
      for( l=0; l<12; l++)%@NL@%
      {%@NL@%
        aptlSides[l].x = ptl.x + aptlControl[l].x;%@NL@%
        aptlSides[l].y = ptl.y + aptlControl[l].y;%@NL@%
      }%@NL@%
%@NL@%
      GpiOpenSegment( hpsClient, ++lCallSegId);%@NL@%
      GpiMove( hpsClient, &ptl);%@NL@%
      GpiPolyLine( hpsClient, 12L, aptlSides);%@NL@%
      GpiCloseSegment( hpsClient);%@NL@%
%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* draw the root segment                                                      */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      GpiOpenSegment( hpsClient, ++lLastSegId);%@NL@%
      GpiSetTag( hpsClient, lLastSegId);%@NL@%
%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* store the piece location                                              */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      sl.ptlLocation = ptl;%@NL@%
%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* compute the dimensions of the matching rects for BitBlt              */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      sl.rclBitBlt.xLeft   = ptl.x - 10;%@NL@%
      sl.rclBitBlt.yBottom = ptl.y - 10;%@NL@%
      sl.rclBitBlt.xRight  = ptl.x + 60;%@NL@%
      sl.rclBitBlt.yTop    = ptl.y + 60;%@NL@%
      if( ptl.x == ptlBotLeft.x)%@NL@%
        sl.rclBitBlt.xLeft += 10;%@NL@%
      if( ptl.y == ptlBotLeft.y)%@NL@%
        sl.rclBitBlt.yBottom += 10;%@NL@%
      if( (ptl.x + 50) == ptlTopRight.x)%@NL@%
        sl.rclBitBlt.xRight -= 10;%@NL@%
      if( (ptl.y + 50) == ptlTopRight.y)%@NL@%
        sl.rclBitBlt.yTop -= 10;%@NL@%
%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      %@AB@%/* draw one piece                                                       */%@AE@%%@NL@%
      %@AB@%/************************************************************************/%@AE@%%@NL@%
      GpiBeginPath( hpsClient, 1L);%@NL@%
      GpiMove( hpsClient, &ptl);%@NL@%
      GpiPolyLine( hpsClient, 12L, aptlSides);%@NL@%
      GpiEndPath( hpsClient);%@NL@%
      GpiSetColor( hpsClient, CLR_BLACK);%@NL@%
      GpiLabel( hpsClient, FILLPATH);%@NL@%
%@NL@%
      GpiSetClipPath( hpsClient, 0L, SCP_RESET);%@NL@%
      GpiBeginPath( hpsClient, 1L);%@NL@%
      GpiMove( hpsClient, &ptl);%@NL@%
      GpiPolyLine( hpsClient, 12L, aptlSides);%@NL@%
      GpiEndPath( hpsClient);%@NL@%
      GpiSetClipPath( hpsClient, 1L, SCP_AND);%@NL@%
      GpiLabel( hpsClient, BITBLT_TOP);%@NL@%
      GpiLabel( hpsClient, BITBLT_BOTTOM);%@NL@%
%@NL@%
      GpiSetClipPath( hpsClient, 0L, SCP_RESET);%@NL@%
      GpiSetColor( hpsClient, CLR_RED);%@NL@%
      GpiMove( hpsClient, &ptl);%@NL@%
      GpiPolyLine( hpsClient, 12L, aptlSides);%@NL@%
%@NL@%
      GpiCloseSegment( hpsClient);%@NL@%
      GpiSetSegmentAttrs( hpsClient, lLastSegId, ATTR_CHAINED, ATTR_ON);%@NL@%
      GpiSetSegmentAttrs( hpsClient, lLastSegId, ATTR_DETECTABLE, ATTR_ON);%@NL@%
%@NL@%
      sl.lSegId = lLastSegId;%@NL@%
      sl.pslNext = NULL;%@NL@%
      sl.pslPrev = NULL;%@NL@%
      SetRect( &sl);%@NL@%
      SegListUpdate( ADD_TAIL_SEG, &sl);%@NL@%
    }%@NL@%
  }%@NL@%
  return( TRUE);%@NL@%
}%@NL@%
 %@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Create the Temp and Drag bitmaps.                                              */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
PrepareBitmap()%@NL@%
{%@NL@%
  bmpBitmapTemp    = bmpBitmapFile;%@NL@%
  bmpBitmapTemp.cx = LOUSHORT( (sizlMaxClient.cx * 6L) / 5L);%@NL@%
  bmpBitmapTemp.cy = LOUSHORT( (sizlMaxClient.cy * 6L) / 5L);%@NL@%
  hbmBitmapTemp    = GpiCreateBitmap( hpsBitmapTemp%@NL@%
                                    , &bmpBitmapTemp%@NL@%
                                    , 0L%@NL@%
                                    , NULL%@NL@%
                                    , NULL);%@NL@%
  if( !hbmBitmapTemp)%@NL@%
    return( FALSE);%@NL@%
%@NL@%
  bmpBitmapDrag    = bmpBitmapFile;%@NL@%
  bmpBitmapDrag.cx = LOUSHORT( (sizlMaxClient.cx * 6L) / 5L);%@NL@%
  bmpBitmapDrag.cy = LOUSHORT( (sizlMaxClient.cy * 6L) / 5L);%@NL@%
  hbmBitmapDrag    = GpiCreateBitmap( hpsBitmapDrag%@NL@%
                                    , &bmpBitmapDrag%@NL@%
                                    , 0L%@NL@%
                                    , NULL%@NL@%
                                    , NULL);%@NL@%
  if( !hbmBitmapDrag)%@NL@%
    return( FALSE);%@NL@%
  return( TRUE);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/* Create a memory DC and an associated PS.                                      */%@AE@%%@NL@%
%@AB@%/*                                                                            */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
CreateBitmapHdcHps( phdc, phps)%@NL@%
%@NL@%
PHDC  phdc;%@NL@%
PHPS  phps;%@NL@%
{%@NL@%
  SIZEL    sizl;%@NL@%
  HDC           hdc;%@NL@%
  HPS           hps;%@NL@%
%@NL@%
  hdc = DevOpenDC( habMain, OD_MEMORY, "*", 3L, (PDEVOPENDATA)&dop, NULL);%@NL@%
  if( !hdc)%@NL@%
    return( FALSE);%@NL@%
%@NL@%
  sizl.cx = sizl.cy = 0L;%@NL@%
  hps = GpiCreatePS( habMain%@NL@%
                   , hdc%@NL@%
                   , &sizl%@NL@%
                   , PU_PELS | GPIA_ASSOC );%@NL@%
  if( !hps)%@NL@%
    return( FALSE);%@NL@%
%@NL@%
  *phdc = hdc;%@NL@%
  *phps = hps;%@NL@%
  return( TRUE);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/* Get the bitmap from disk.                                                      */%@AE@%%@NL@%
%@AB@%/* Note that there are 2 formats for bitmap files, one of which is archaic.   */%@AE@%%@NL@%
%@AB@%/* Both formats are supported here.  All new bitmaps should follow the format */%@AE@%%@NL@%
%@AB@%/* in BITMAPFILEHEADER.                                                       */%@AE@%%@NL@%
%@AB@%/*                                                                              */%@AE@%%@NL@%
%@AB@%/******************************************************************************/%@AE@%%@NL@%
BOOL%@NL@%
ReadBitmap( hfile)%@NL@%
%@NL@%
HFILE  hfile;%@NL@%
{%@NL@%
    ULONG cScans;%@NL@%
    ULONG ulSize;         %@AB@%/* Number of bytes occupied by bitmap bits.              */%@AE@%%@NL@%
    USHORT cSegs;         %@AB@%/* Number of 64K segments in ulSize.                      */%@AE@%%@NL@%
    USHORT cbExtra;         %@AB@%/* Bytes in last segment of ulSize.                      */%@AE@%%@NL@%
    SEL sel;                 %@AB@%/* Base selector to file data.                       */%@AE@%%@NL@%
    USHORT hugeshift;         %@AB@%/* Segment index shift value.                              */%@AE@%%@NL@%
    USHORT cbRead1;         %@AB@%/* Number of bytes to read first call to DosRead     */%@AE@%%@NL@%
    USHORT cbRead2;         %@AB@%/* Number of bytes to read second call to DosRead    */%@AE@%%@NL@%
    USHORT cbRead;         %@AB@%/* Number of bytes read by DosRead.                      */%@AE@%%@NL@%
    BOOL fRet = FALSE;         %@AB@%/* Function return code.                              */%@AE@%%@NL@%
    USHORT  i;                 %@AB@%/* Generic loop index.                               */%@AE@%%@NL@%
    FILESTATUS fsts;%@NL@%
    PBITMAPFILEHEADER pbfh;%@NL@%
    PRCBITMAP  rb;%@NL@%
    PBYTE pImage;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/* Find out how big the file is so we can read the whole thing in.              */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
%@NL@%
    if( DosQFileInfo( hfile, 1, &fsts, sizeof(FILESTATUS)) != 0)%@NL@%
        goto ReadBitmap_close_file;%@NL@%
%@NL@%
    ulSize  = fsts.cbFile;%@NL@%
    cSegs   = (USHORT)(ulSize/0x10000L);%@NL@%
    cbExtra = (USHORT)(ulSize%0x10000L);%@NL@%
    if (DosAllocHuge(cSegs, cbExtra, (PSEL)&sel, 0, 0))%@NL@%
        goto ReadBitmap_close_file;%@NL@%
    if (DosGetHugeShift( &hugeshift))%@NL@%
        goto ReadBitmap_free_bits;%@NL@%
%@NL@%
    pImage = (PBYTE)MAKEP(sel, 0);%@NL@%
    rb           = (PRCBITMAP)pImage;%@NL@%
    pbfh   = (PBITMAPFILEHEADER)pImage;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/* Read the bits in from the file. The DosRead function allows a              */%@AE@%%@NL@%
    %@AB@%/* maximum of 64K-1 bytes read at a time.  We get around this              */%@AE@%%@NL@%
    %@AB@%/* by reading two 32K chunks for each 64K segment, and reading the              */%@AE@%%@NL@%
    %@AB@%/* last segment in one piece.                                              */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
%@NL@%
    for (i = 0; i <= cSegs; ++i)%@NL@%
    {%@NL@%
        if (i < cSegs)%@NL@%
        {%@NL@%
            %@AB@%/* This segment is 64K bytes long, so split it up. */%@AE@%%@NL@%
            cbRead1 = 0x8000;%@NL@%
            cbRead2 = 0x8000;%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
            %@AB@%/* This segment is less than 64K bytes long, so read it all. */%@AE@%%@NL@%
            cbRead1 = cbExtra;%@NL@%
            cbRead2 = 0;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* There's a possibility that cbExtra will be 0, so check%@NL@%
%@AB@%         * to avoid an unnecessary system call.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (cbRead1 > 0)%@NL@%
        {%@NL@%
            if (DosRead( hfile%@NL@%
                       , (PVOID)MAKEP(sel+(i<<hugeshift), 0)%@NL@%
                       , cbRead1%@NL@%
                       , &cbRead))%@NL@%
                goto ReadBitmap_free_bits;%@NL@%
            if (cbRead1 != cbRead)%@NL@%
                goto ReadBitmap_free_bits;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* This will always be skipped on the last partial segment. */%@AE@%%@NL@%
        if (cbRead2 > 0)%@NL@%
        {%@NL@%
            if (DosRead( hfile%@NL@%
                       , (PVOID)MAKEP(sel+(i<<hugeshift), cbRead1)%@NL@%
                       , cbRead2%@NL@%
                       , &cbRead))%@NL@%
                goto ReadBitmap_free_bits;%@NL@%
            if (cbRead2 != cbRead)%@NL@%
                goto ReadBitmap_free_bits;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/* Tell GPI to put the bits into the thread's PS. The function returns    */%@AE@%%@NL@%
    %@AB@%/* the number of scan lines of the bitmap that were copied.  We want      */%@AE@%%@NL@%
    %@AB@%/* all of them at once.                                                      */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
%@NL@%
    if (pbfh->bmp.cbFix != sizeof(BITMAPINFOHEADER))%@NL@%
    {%@NL@%
        bmpBitmapFile.cx        = rb->bmWidth;%@NL@%
        bmpBitmapFile.cy        = rb->bmHeight;%@NL@%
        bmpBitmapFile.cPlanes        = rb->bmPlanes;%@NL@%
        bmpBitmapFile.cBitCount = rb->bmBitcount;%@NL@%
        hbmBitmapFile = GpiCreateBitmap( hpsBitmapFile%@NL@%
                                       , &bmpBitmapFile%@NL@%
                                       , 0L%@NL@%
                                       , NULL%@NL@%
                                       , NULL);%@NL@%
        if( !hbmBitmapFile)%@NL@%
            goto ReadBitmap_free_bits;%@NL@%
        GpiSetBitmap( hpsBitmapFile, hbmBitmapFile);%@NL@%
%@NL@%
        pImage += rb->dwBitsOffset;%@NL@%
        rb->dwBitsOffset = sizeof(BITMAPINFOHEADER);%@NL@%
        cScans = GpiSetBitmapBits( hpsBitmapFile%@NL@%
                                 , 0L%@NL@%
                                 , (LONG)rb->bmHeight%@NL@%
                                 , pImage%@NL@%
                                 , (PBITMAPINFO)&(rb->dwBitsOffset));%@NL@%
        if (cScans != (ULONG)rb->bmHeight)  %@AB@%/* original number of scans ? */%@AE@%%@NL@%
            goto ReadBitmap_free_bits;%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
        bmpBitmapFile.cx        = pbfh->bmp.cx;%@NL@%
        bmpBitmapFile.cy        = pbfh->bmp.cy;%@NL@%
        bmpBitmapFile.cPlanes        = pbfh->bmp.cPlanes;%@NL@%
        bmpBitmapFile.cBitCount = pbfh->bmp.cBitCount;%@NL@%
        hbmBitmapFile = GpiCreateBitmap( hpsBitmapFile%@NL@%
                                       , &bmpBitmapFile%@NL@%
                                       , 0L%@NL@%
                                       , NULL%@NL@%
                                       , NULL);%@NL@%
        if( !hbmBitmapFile)%@NL@%
            goto ReadBitmap_free_bits;%@NL@%
        GpiSetBitmap( hpsBitmapFile, hbmBitmapFile);%@NL@%
%@NL@%
        cScans = GpiSetBitmapBits( hpsBitmapFile%@NL@%
                                 , 0L%@NL@%
                                 , (LONG)pbfh->bmp.cy%@NL@%
                                 , pImage + pbfh->offBits%@NL@%
                                 , (PBITMAPINFO)&(pbfh->bmp));%@NL@%
        if (cScans != (ULONG)pbfh->bmp.cy)  %@AB@%/* original number of scans ? */%@AE@%%@NL@%
            goto ReadBitmap_free_bits;%@NL@%
    }%@NL@%
%@NL@%
    fRet = TRUE;     %@AB@%/* okey-dokey */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
    %@AB@%/* Close the file, free the buffer space and leave.  This is a              */%@AE@%%@NL@%
    %@AB@%/* common exit point from the function.  Since the same cleanup              */%@AE@%%@NL@%
    %@AB@%/* operations need to be performed for such a large number of              */%@AE@%%@NL@%
    %@AB@%/* possible error conditions, this is concise way to do the right              */%@AE@%%@NL@%
    %@AB@%/* thing.                                                                      */%@AE@%%@NL@%
    %@AB@%/**************************************************************************/%@AE@%%@NL@%
%@NL@%
ReadBitmap_free_bits:%@NL@%
    DosFreeSeg( sel);%@NL@%
ReadBitmap_close_file:%@NL@%
    DosClose( hfile);%@NL@%
    return fRet;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LFCMD.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\LINEFRAC\LFCMD.C%@AE@%%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   lfcmd.c -- Subroutines for menu command processing for LineFractal.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#define %@AE@%INCL_BITMAPFILEFORMAT %@NL@%
%@AI@%#define %@AE@%INCL_DOSSEMAPHORES %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"opendlg.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GLOBALS %@NL@%
%@AI@%#define %@AE@%INCL_THREADS %@NL@%
%@AI@%#include %@AE@%"linefrac.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_LFCMD %@NL@%
%@AI@%#define %@AE@%INCL_LFDLG %@NL@%
%@AI@%#define %@AE@%INCL_LFMAIN %@NL@%
%@AI@%#define %@AE@%INCL_LFTHREAD %@NL@%
%@AI@%#define %@AE@%INCL_LFPS %@NL@%
%@AI@%#define %@AE@%INCL_LFDRAW %@NL@%
%@AI@%#define %@AE@%INCL_LFUTIL %@NL@%
%@AI@%#define %@AE@%INCL_LFFILE %@NL@%
%@AI@%#include %@AE@%"lffuncs.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Macros%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Helper macros for repetitious code.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%UPDATE_MENU_BOOL(var, val)                                \ %@NL@%
        {                                                        \%@NL@%
            TOGGLE_BOOL((var));                                 \%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, (val), (var));        \%@NL@%
        }%@NL@%
%@NL@%
%@AI@%#define %@AE@%UPDATE_MENU_LIST(var, val)                                \ %@NL@%
        {                                                        \%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, (var));         \%@NL@%
            (var) = (val);                                        \%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, (var));                \%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Global Variables%@NL@%
%@AB@%*%@NL@%
%@AB@%*   global        Global data block.%@NL@%
%@AB@%*   aulRops        Array of BitBlt rops available for pasting.%@NL@%
%@AB@%*   aXform        Array of built-in transforms and default positioning%@NL@%
%@AB@%*                  and sizing information.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
extern GLOBALDATA global;%@NL@%
extern XFORMDATA  aXform[];%@NL@%
%@NL@%
ULONG aulRops[] =%@NL@%
{%@NL@%
      ROP_SRCCOPY,%@NL@%
      ROP_SRCAND,%@NL@%
      ROP_SRCPAINT,%@NL@%
      ROP_SRCINVERT,%@NL@%
    (~ROP_SRCCOPY)   & 0xFF,%@NL@%
    (~ROP_SRCAND)    & 0xFF,%@NL@%
    (~ROP_SRCPAINT)  & 0xFF,%@NL@%
    (~ROP_SRCINVERT) & 0xFF%@NL@%
};%@NL@%
%@NL@%
char *pszAttrs = "Previous attributes not read yet.";%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfCommand%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Dispatches menu commands to the proper handlers.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfCommand(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    switch (id)%@NL@%
    {%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *        File menu%@NL@%
%@AB@%    *%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_LOAD:%@NL@%
    case IDM_SAVE:%@NL@%
    case IDM_ABOUT:%@NL@%
        LfFileMenu(hwnd, id);%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *        Edit menu%@NL@%
%@AB@%    *%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_SELECT:%@NL@%
    case IDM_SELECTALL:%@NL@%
    case IDM_CUT:%@NL@%
    case IDM_COPY:%@NL@%
    case IDM_PASTE:%@NL@%
    case IDM_USECLIPBRD:%@NL@%
    case IDM_PASTES:%@NL@%
    case IDM_PASTEDSA:%@NL@%
    case IDM_PASTEDSO:%@NL@%
    case IDM_PASTEDSX:%@NL@%
    case IDM_PASTESN:%@NL@%
    case IDM_PASTEDSAN:%@NL@%
    case IDM_PASTEDSON:%@NL@%
    case IDM_PASTEDSXN:%@NL@%
        LfEditMenu(hwnd, id);%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *        Thread menu%@NL@%
%@AB@%    *%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_DCPOSTSCRIPT:%@NL@%
    case IDM_DCPROPRINTER:%@NL@%
    case IDM_DCDIRECT:%@NL@%
    case IDM_DCMEMORY:%@NL@%
    case IDM_EDITTHREADPARAMS:%@NL@%
    case IDM_THR0TOTOP:%@NL@%
    case IDM_THR1TOTOP:%@NL@%
    case IDM_THR2TOTOP:%@NL@%
    case IDM_THR3TOTOP:%@NL@%
    case IDM_THR4TOTOP:%@NL@%
    case IDM_THR5TOTOP:%@NL@%
    case IDM_THR6TOTOP:%@NL@%
    case IDM_THR7TOTOP:%@NL@%
    case IDM_THR8TOTOP:%@NL@%
    case IDM_THR9TOTOP:%@NL@%
    case IDM_KILLTOPTHREAD:%@NL@%
    case IDM_KILLALLTHREADS:%@NL@%
    case IDM_AUTOSWITCH:%@NL@%
    case IDM_SWITCHDELAY:%@NL@%
    case IDM_UPDATEMENUS:%@NL@%
    case IDM_THREADINHERITANCE:%@NL@%
        LfThreadMenu(hwnd, id);%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *        Control menu%@NL@%
%@AB@%    *%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_CLEARBITMAP:%@NL@%
    case IDM_COPYBITMAPTOSCREEN:%@NL@%
    case IDM_SQUAREBITMAP:%@NL@%
    case IDM_RESIZEBITMAPTOWINDOW:%@NL@%
    case IDM_MOUSECHANGESRECURSION:%@NL@%
    case IDM_ANIMATEPTR:%@NL@%
    case IDM_PTRPREFERENCES:%@NL@%
    case IDM_TIMERDELAY:%@NL@%
        if (LfControlMenu(hwnd, id))%@NL@%
            goto lfcmd_redraw;%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *        Fractal menu%@NL@%
%@AB@%    *%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_SHARKTOOTH:%@NL@%
    case IDM_SAWTOOTH:%@NL@%
    case IDM_KOCH:%@NL@%
    case IDM_SPACEFILLER:%@NL@%
    case IDM_STOVE:%@NL@%
    case IDM_SQUAREWAVE:%@NL@%
    case IDM_HOURGLASS:%@NL@%
    case IDM_FRACREDRAW:%@NL@%
        if (LfFractalMenu(hwnd, id))%@NL@%
            goto lfcmd_redraw;%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *        Primitive menu%@NL@%
%@AB@%    *%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_POLYLINE:%@NL@%
    case IDM_POLYFILLET:%@NL@%
    case IDM_POLYSPLINE:%@NL@%
    case IDM_POLYMARKER:%@NL@%
    case IDM_PEANO:%@NL@%
    case IDM_PRIMREDRAW:%@NL@%
        if (LfPrimitiveMenu(hwnd, id))%@NL@%
            goto lfcmd_redraw;%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *        Attributes menu%@NL@%
%@AB@%    *%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_LINEATTRS:%@NL@%
    case IDM_MARKERATTRS:%@NL@%
    case IDM_AREAATTRS:%@NL@%
    case IDM_IMAGEATTRS:%@NL@%
    case IDM_MISCATTRS:%@NL@%
    case IDM_DIMENSIONS:%@NL@%
    case IDM_DRAGDIMS:%@NL@%
    case IDM_ATTRREDRAW:%@NL@%
        if (LfAttributesMenu(hwnd, id))%@NL@%
            goto lfcmd_redraw;%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *        Environment menu%@NL@%
%@AB@%    *%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_AUTORESIZE:%@NL@%
    case IDM_AUTOSELECTDIMS:%@NL@%
    case IDM_CLEARONREDRAW:%@NL@%
    case IDM_AUTOSTARTREDRAW:%@NL@%
    case IDM_COLLECTBOUNDS:%@NL@%
        LfEnvironmentMenu(hwnd, id);%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *        Control menu, continued.  These two commands dovetail%@NL@%
%@AB@%    *        conveniently,  so they are placed out of sequence here.%@NL@%
%@AB@%    *%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
lfcmd_redraw:%@NL@%
    case IDM_REDRAW:%@NL@%
        DosSemClear(&(global.pThrTop)->lSemRedraw);%@NL@%
%@NL@%
        %@AB@%/* Fall through to restart the drawing. */%@AE@%%@NL@%
%@NL@%
    case IDM_ABORT:%@NL@%
        global.pThrTop->fInterrupted = TRUE;%@NL@%
        break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfFileMenu%@NL@%
%@AB@%*%@NL@%
%@AB@%*   These commands allow the loading and saving of bitmaps from threads%@NL@%
%@AB@%*   with memory DC's.  The about box shows the version number, title,%@NL@%
%@AB@%*   and author.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfFileMenu(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    switch (id)%@NL@%
    {%@NL@%
    case IDM_LOAD:%@NL@%
        if (global.pThrTop->dcType == IDM_DCMEMORY)%@NL@%
            LfReadFile(hwnd, global.pThrTop);%@NL@%
        else%@NL@%
            MyMessageBox(hwnd, "Cannot load bitmap into a\nnon-memory DC.");%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_SAVE:%@NL@%
        if (global.pThrTop->dcType == IDM_DCMEMORY)%@NL@%
            LfWriteFile(hwnd, global.pThrTop);%@NL@%
        else%@NL@%
            MyMessageBox(hwnd, "Cannot save bitmap from a\nnon-memory DC.");%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_ABOUT:%@NL@%
        WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)AboutDlg, (HMODULE) NULL,%@NL@%
                       (USHORT) IDR_ABOUTDLG, NULL );%@NL@%
        break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfEditMenu%@NL@%
%@AB@%*%@NL@%
%@AB@%*   These commands allow for cutting, copying, and pasting of rectangles%@NL@%
%@AB@%*   of bits.  The user can drag a rectangle or select the entire surface.%@NL@%
%@AB@%*   The GpiBitBlt rop to use when pasting can be any of those listed.%@NL@%
%@AB@%*   The user can specify that the system clipboard be used for storing%@NL@%
%@AB@%*   the cut or copied bits, or that a private bitmap be used.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfEditMenu(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    switch (id)%@NL@%
    {%@NL@%
    case IDM_SELECT:%@NL@%
        global.fSelecting = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_SELECTALL:%@NL@%
        LfSelectAll(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_CUT:%@NL@%
        if (global.fShowSelectRc)%@NL@%
            LfCut(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_COPY:%@NL@%
        if (global.fShowSelectRc)%@NL@%
            LfCopy(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_PASTE:%@NL@%
        if (global.fHaveSelectRc)%@NL@%
        {%@NL@%
            HPS hps;%@NL@%
%@NL@%
            global.fPasting = TRUE;%@NL@%
            if (global.fShowSelectRc && global.fTempSelect)%@NL@%
            {%@NL@%
                hps = WinGetPS(hwnd);%@NL@%
                LfShowSelectRc(hps, &global.rclSelect);%@NL@%
                WinReleasePS(hps);%@NL@%
                global.fShowSelectRc = FALSE;%@NL@%
                global.fTempSelect = FALSE;%@NL@%
            }%@NL@%
            if (!global.fShowSelectRc)%@NL@%
            {%@NL@%
                global.fShowSelectRc = TRUE;%@NL@%
                hps = WinGetPS(hwnd);%@NL@%
                LfShowSelectRc(hps, &global.rclCutCopy);%@NL@%
                WinReleasePS(hps);%@NL@%
            }%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_USECLIPBRD:%@NL@%
        UPDATE_MENU_BOOL(global.fUseClipbrd, IDM_USECLIPBRD);%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_PASTES:%@NL@%
    case IDM_PASTEDSA:%@NL@%
    case IDM_PASTEDSO:%@NL@%
    case IDM_PASTEDSX:%@NL@%
    case IDM_PASTESN:%@NL@%
    case IDM_PASTEDSAN:%@NL@%
    case IDM_PASTEDSON:%@NL@%
    case IDM_PASTEDSXN:%@NL@%
        UNCHECK_MENU_ITEM(global.hwndFrame, global.usRopIndex+IDM_PASTES);%@NL@%
        global.usRopIndex = id - IDM_PASTES;%@NL@%
        CHECK_MENU_ITEM(global.hwndFrame, global.usRopIndex+IDM_PASTES);%@NL@%
        global.ulPasteROP = aulRops[global.usRopIndex];%@NL@%
        break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfThreadMenu%@NL@%
%@AB@%*%@NL@%
%@AB@%*   These commands allow the creation, viewing, editing, and deletion%@NL@%
%@AB@%*   of up to 10 independently drawing threads.        The middle group%@NL@%
%@AB@%*   allow for simple animation by cycling through the threads at%@NL@%
%@AB@%*   a user-selectable rate.  The updating of menus can be disabled to%@NL@%
%@AB@%*   allow a faster thread-switch rate.        The last group determine how%@NL@%
%@AB@%*   new threads will look and act.  If inheritance is enabled, a new%@NL@%
%@AB@%*   thread will be drawn with the attributes of the top thread, otherwise%@NL@%
%@AB@%*   it will use the program's default values.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfThreadMenu(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    static char *szError1 = "Could not start thread.";%@NL@%
%@NL@%
    switch (id)%@NL@%
    {%@NL@%
    case IDM_DCPOSTSCRIPT:%@NL@%
    case IDM_DCPROPRINTER:%@NL@%
        break;        %@AB@%/* not implemented yet */%@AE@%%@NL@%
%@NL@%
    case IDM_DCDIRECT:%@NL@%
        {%@NL@%
            PTHR pthr;%@NL@%
%@NL@%
            if (global.cThr < MAX_THREADS)%@NL@%
                if (pthr = LfStartThread(IDM_DCDIRECT))%@NL@%
                {%@NL@%
                    (global.aThr)[global.cThr] = pthr;%@NL@%
                    ++global.cThr;%@NL@%
                    pthr->dcType = id;%@NL@%
%@NL@%
                    LfBringThreadToTop(pthr);%@NL@%
                    break;%@NL@%
                }%@NL@%
            MyMessageBox(hwnd, szError1);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_DCMEMORY:%@NL@%
%@NL@%
        if (global.cThr < MAX_THREADS)%@NL@%
        {%@NL@%
            if (global.fFirstThread)%@NL@%
            {%@NL@%
                global.bm.cx            = (USHORT) (global.rcl.xRight - global.rcl.xLeft);%@NL@%
                global.bm.cy            = (USHORT) (global.rcl.yTop   - global.rcl.yBottom);%@NL@%
                global.bm.cPlanes   = 0;%@NL@%
                global.bm.cBitCount = 0;%@NL@%
                global.fFirstThread = FALSE;%@NL@%
            }%@NL@%
            else if (global.fThreadInheritance)%@NL@%
            {%@NL@%
                global.bm.cx            = (USHORT) global.pThrTop->rcl.xRight;%@NL@%
                global.bm.cy            = (USHORT) global.pThrTop->rcl.yTop;%@NL@%
                global.bm.cPlanes   = global.pThrTop->cPlanes;%@NL@%
                global.bm.cBitCount = global.pThrTop->cBitCount;%@NL@%
            }%@NL@%
            else%@NL@%
            {%@NL@%
                global.bm.cx            = (USHORT) (global.rcl.xRight - global.rcl.xLeft);%@NL@%
                global.bm.cy            = (USHORT) (global.rcl.yTop   - global.rcl.yBottom);%@NL@%
                global.bm.cPlanes   = 0;%@NL@%
                global.bm.cBitCount = 0;%@NL@%
                if (!WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)BitmapParamsDlg, (HMODULE) NULL,%@NL@%
                              (USHORT) IDR_BITMAPPARAMSDLG, NULL ))%@NL@%
                    break;        %@AB@%/* if user hit "cancel", don't start thread */%@AE@%%@NL@%
            }%@NL@%
%@NL@%
            {%@NL@%
                PTHR pthr;%@NL@%
%@NL@%
                if (pthr = LfStartThread(IDM_DCMEMORY))%@NL@%
                {%@NL@%
                    (global.aThr)[global.cThr] = pthr;%@NL@%
                    ++global.cThr;%@NL@%
                    pthr->dcType = id;%@NL@%
%@NL@%
                    LfBringThreadToTop(pthr);%@NL@%
                    break;%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
        MyMessageBox(hwnd, szError1);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_EDITTHREADPARAMS:%@NL@%
        if (global.pThrTop->dcType == IDM_DCMEMORY)%@NL@%
        {%@NL@%
            USHORT cxT, cyT, cpT, cbT;%@NL@%
%@NL@%
            cxT = global.bm.cx              = (USHORT) global.pThrTop->rcl.xRight;%@NL@%
            cyT = global.bm.cy              = (USHORT) global.pThrTop->rcl.yTop;%@NL@%
            cpT = global.bm.cPlanes   = global.pThrTop->cPlanes;%@NL@%
            cbT = global.bm.cBitCount = global.pThrTop->cBitCount;%@NL@%
%@NL@%
            if (WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)BitmapParamsDlg, (HMODULE) NULL,%@NL@%
                          (USHORT) IDR_BITMAPPARAMSDLG, NULL ))%@NL@%
                if ((cxT != global.bm.cx)      ||%@NL@%
                    (cyT != global.bm.cy)      ||%@NL@%
                    (cpT != global.bm.cPlanes) ||%@NL@%
                    (cbT != global.bm.cBitCount))%@NL@%
                    LfResizePS(global.pThrTop);%@NL@%
        }%@NL@%
        else%@NL@%
            MyMessageBox(hwnd, "No editable DC parameters.");%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_THR0TOTOP:%@NL@%
    case IDM_THR1TOTOP:%@NL@%
    case IDM_THR2TOTOP:%@NL@%
    case IDM_THR3TOTOP:%@NL@%
    case IDM_THR4TOTOP:%@NL@%
    case IDM_THR5TOTOP:%@NL@%
    case IDM_THR6TOTOP:%@NL@%
    case IDM_THR7TOTOP:%@NL@%
    case IDM_THR8TOTOP:%@NL@%
    case IDM_THR9TOTOP:%@NL@%
        {%@NL@%
            USHORT i;%@NL@%
%@NL@%
            if ((i = id-IDM_THR0TOTOP) < global.cThr)%@NL@%
                LfBringThreadToTop(global.aThr[i]);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_KILLTOPTHREAD:%@NL@%
        {%@NL@%
            PTHR pthr;%@NL@%
%@NL@%
            pthr = global.pThrTop;%@NL@%
            if (global.cThr > 1)%@NL@%
            {%@NL@%
                USHORT i;%@NL@%
%@NL@%
                if ((i = global.iThrTop+1) == global.cThr)%@NL@%
                    i -= 2;%@NL@%
                LfBringThreadToTop(global.aThr[i]);%@NL@%
            }%@NL@%
            else%@NL@%
                LfBringThreadToTop(NULL);%@NL@%
%@NL@%
            LfKillThread(pthr);%@NL@%
            LfBringThreadToTop(global.pThrTop);     %@AB@%/* update global.iThrTop and menu */%@AE@%%@NL@%
%@NL@%
            %@AB@%/* If no threads left, then start over. */%@AE@%%@NL@%
            if (global.cThr == 0)%@NL@%
            {%@NL@%
                global.fFirstThread = TRUE;%@NL@%
                WinSendMsg(hwnd, WM_COMMAND, (MPARAM)IDM_DCMEMORY, 0);%@NL@%
            }%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_KILLALLTHREADS:%@NL@%
        {%@NL@%
            SHORT i;%@NL@%
%@NL@%
            %@AB@%/* Delete them all and start over. */%@AE@%%@NL@%
            LfBringThreadToTop(NULL);%@NL@%
            for (i = global.cThr-1; i >= 0; --i)%@NL@%
                LfKillThread(global.aThr[i]);%@NL@%
            global.fFirstThread = TRUE;%@NL@%
            WinSendMsg(hwnd, WM_COMMAND, (MPARAM)IDM_DCMEMORY, 0);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_AUTOSWITCH:%@NL@%
        UPDATE_MENU_BOOL(global.fAutoSwitch, IDM_AUTOSWITCH);%@NL@%
        if (global.fAutoSwitch)%@NL@%
            WinStartTimer(global.hab, global.hwnd, IDT_AUTOSWITCH, global.usSwitchDelay);%@NL@%
        else%@NL@%
            WinStopTimer(global.hab, global.hwnd, IDT_AUTOSWITCH);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_SWITCHDELAY:%@NL@%
        WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)SwitchDelayDlg, (HMODULE) NULL,%@NL@%
                      (USHORT) IDR_SWITCHDELAYDLG, NULL );%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_UPDATEMENUS:%@NL@%
        UPDATE_MENU_BOOL(global.fUpdateMenusOnThreadSwitch, IDM_UPDATEMENUS);%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_THREADINHERITANCE:%@NL@%
        UPDATE_MENU_BOOL(global.fThreadInheritance, IDM_THREADINHERITANCE);%@NL@%
        break;%@NL@%
%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfControlMenu%@NL@%
%@AB@%*%@NL@%
%@AB@%*   These commands cause global effects.  The top set cause immediate%@NL@%
%@AB@%*   results.  The bottom set determine how the program reacts to%@NL@%
%@AB@%*   certain events (mouse movement and button messages, timer messages).%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfControlMenu(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    BOOL fRedraw = FALSE;%@NL@%
%@NL@%
    switch (id)%@NL@%
    {%@NL@%
    case IDM_CLEARBITMAP:%@NL@%
        LfClearRect(global.pThrTop, NULL);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_COPYBITMAPTOSCREEN:%@NL@%
        if (global.pThrTop->hps)%@NL@%
            WinInvalidateRect(global.hwnd, &(global.pThrTop)->rcl, FALSE);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_SQUAREBITMAP:%@NL@%
        LfSquareBitmap(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_RESIZEBITMAPTOWINDOW:%@NL@%
        LfResizeBitmapToWindow();%@NL@%
        fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_MOUSECHANGESRECURSION:%@NL@%
        UPDATE_MENU_BOOL(global.fMouseChangesRecursion, IDM_MOUSECHANGESRECURSION);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_ANIMATEPTR:%@NL@%
        UPDATE_MENU_BOOL(global.fAnimatePtr, IDM_ANIMATEPTR);%@NL@%
        if (global.fAnimatePtr)%@NL@%
            global.usPtrIncr = 1;%@NL@%
        else%@NL@%
        {%@NL@%
            global.usPtrIncr = 0;%@NL@%
            global.usCurPtr  = global.usUserPtr;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_PTRPREFERENCES:%@NL@%
        WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)PtrPreferencesDlg, (HMODULE) NULL,%@NL@%
                      (USHORT) IDR_PTRPREFERENCESDLG, NULL );%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_TIMERDELAY:%@NL@%
        WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)TimerDelayDlg, (HMODULE) NULL,%@NL@%
                      (USHORT) IDR_TIMERDELAYDLG, NULL );%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return fRedraw;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfFractalMenu%@NL@%
%@AB@%*%@NL@%
%@AB@%*   These commands select the fractal similarity transform, i.e. the%@NL@%
%@AB@%*   basic fractal shape, for a thread.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfFractalMenu(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    BOOL fRedraw = FALSE;%@NL@%
%@NL@%
    switch (id)%@NL@%
    {%@NL@%
    case IDM_SHARKTOOTH:%@NL@%
    case IDM_SAWTOOTH:%@NL@%
    case IDM_KOCH:%@NL@%
    case IDM_SPACEFILLER:%@NL@%
    case IDM_STOVE:%@NL@%
    case IDM_SQUAREWAVE:%@NL@%
    case IDM_HOURGLASS:%@NL@%
        LfSelectXform(hwnd, global.pThrTop, id);%@NL@%
        if (global.pThrTop->fFracRedraw)%@NL@%
            fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_FRACREDRAW:%@NL@%
        UPDATE_MENU_BOOL(global.pThrTop->fFracRedraw, IDM_FRACREDRAW);%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return fRedraw;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfPrimitiveMenu%@NL@%
%@AB@%*%@NL@%
%@AB@%*   These commands select the drawing primitive used to output the%@NL@%
%@AB@%*   fractal for a thread.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfPrimitiveMenu(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    BOOL fRedraw = FALSE;%@NL@%
%@NL@%
    switch (id)%@NL@%
    {%@NL@%
    case IDM_POLYLINE:%@NL@%
    case IDM_POLYFILLET:%@NL@%
    case IDM_POLYSPLINE:%@NL@%
    case IDM_POLYMARKER:%@NL@%
    case IDM_PEANO:%@NL@%
        LfSelectPrim(hwnd, global.pThrTop, id);%@NL@%
        if (global.pThrTop->fPrimRedraw)%@NL@%
            fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_PRIMREDRAW:%@NL@%
        UPDATE_MENU_BOOL(global.pThrTop->fPrimRedraw, IDM_PRIMREDRAW);%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return fRedraw;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfAttributesMenu%@NL@%
%@AB@%*%@NL@%
%@AB@%*   These commands allow the user to alter all the drawing attributes%@NL@%
%@AB@%*   of a fractal (color, mix mode, marker symbol, etc.), as well as%@NL@%
%@AB@%*   some fractal-related attributes such as width, height, offset,%@NL@%
%@AB@%*   number of sides to polygonal frame, and rotation.  Each thread%@NL@%
%@AB@%*   has an independent set of all these attributes.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfAttributesMenu(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    BOOL fRedraw = FALSE;%@NL@%
%@NL@%
    switch (id)%@NL@%
    {%@NL@%
    case IDM_LINEATTRS:%@NL@%
        if (global.fUpdateAttrs && (global.flLineAttrs & LFA_LINEALL))%@NL@%
            MyMessageBox(hwnd, pszAttrs);%@NL@%
        if (WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)LineAttrsDlg, (HMODULE) NULL,%@NL@%
                      (USHORT) IDR_LINEATTRSDLG, NULL ))%@NL@%
            fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_MARKERATTRS:%@NL@%
        if (global.fUpdateAttrs && (global.flMarkerAttrs & LFA_MARKALL))%@NL@%
            MyMessageBox(hwnd, pszAttrs);%@NL@%
        if (WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)MarkerAttrsDlg, (HMODULE) NULL,%@NL@%
                      (USHORT) IDR_MARKERATTRSDLG, NULL ))%@NL@%
            fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_AREAATTRS:%@NL@%
        if (global.fUpdateAttrs && (global.flAreaAttrs & LFA_AREAALL))%@NL@%
            MyMessageBox(hwnd, pszAttrs);%@NL@%
        if (WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)AreaAttrsDlg, (HMODULE) NULL,%@NL@%
                      (USHORT) IDR_AREAATTRSDLG, NULL ))%@NL@%
            fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_IMAGEATTRS:%@NL@%
        if (global.fUpdateAttrs && (global.flImageAttrs & LFA_IMAGEALL))%@NL@%
            MyMessageBox(hwnd, pszAttrs);%@NL@%
        if (WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)ImageAttrsDlg, (HMODULE) NULL,%@NL@%
                      (USHORT) IDR_IMAGEATTRSDLG, NULL ))%@NL@%
            fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_MISCATTRS:%@NL@%
        if (global.fUpdateAttrs && (global.flMiscAttrs & (LFA_RECURSION |%@NL@%
                LFA_CPTMAX | LFA_POLYGONSIDES | LFA_ROTATION)))%@NL@%
            MyMessageBox(hwnd, pszAttrs);%@NL@%
        if (WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)MiscAttrsDlg, (HMODULE) NULL,%@NL@%
                      (USHORT) IDR_MISCATTRSDLG, NULL ))%@NL@%
            fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_DIMENSIONS:%@NL@%
        if (global.fUpdateAttrs && (global.flMiscAttrs & (LFA_XOFF |%@NL@%
                LFA_YOFF | LFA_XSCALE | LFA_YSCALE)))%@NL@%
            MyMessageBox(hwnd, pszAttrs);%@NL@%
        if (WinDlgBox( HWND_DESKTOP, hwnd, (PFNWP)DimensionsDlg, (HMODULE) NULL,%@NL@%
                      (USHORT) IDR_DIMENSIONSDLG, NULL ))%@NL@%
            fRedraw = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_DRAGDIMS:%@NL@%
        global.fTracking = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/********************************************************************/%@AE@%%@NL@%
%@NL@%
    case IDM_ATTRREDRAW:%@NL@%
        UPDATE_MENU_BOOL(global.pThrTop->fAttrRedraw, IDM_ATTRREDRAW);%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    if (fRedraw)%@NL@%
        if (global.pThrTop->fAttrRedraw)%@NL@%
            return TRUE;%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfEnvironmentMenu%@NL@%
%@AB@%*%@NL@%
%@AB@%*   These commands alter the way a thread reacts to system and program%@NL@%
%@AB@%*   events by toggling certain flags.  Each thread has its own%@NL@%
%@AB@%*   environment flags.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfEnvironmentMenu(hwnd, id)%@NL@%
HWND hwnd;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    switch (id)%@NL@%
    {%@NL@%
    case IDM_AUTORESIZE:%@NL@%
        UPDATE_MENU_BOOL(global.pThrTop->fAutoSizePS, IDM_AUTORESIZE);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_AUTOSELECTDIMS:%@NL@%
        UPDATE_MENU_BOOL(global.pThrTop->fAutoSelectDims, IDM_AUTOSELECTDIMS);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_CLEARONREDRAW:%@NL@%
        UPDATE_MENU_BOOL(global.pThrTop->fClearOnRedraw, IDM_CLEARONREDRAW);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_AUTOSTARTREDRAW:%@NL@%
        UPDATE_MENU_BOOL(global.pThrTop->fAutoStartRedraw, IDM_AUTOSTARTREDRAW);%@NL@%
        if (global.pThrTop->fAutoStartRedraw)%@NL@%
            LfStartRedrawTimer();%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_COLLECTBOUNDS:%@NL@%
        UPDATE_MENU_BOOL(global.pThrTop->fCollectBounds, IDM_COLLECTBOUNDS);%@NL@%
        break;%@NL@%
%@NL@%
    }%@NL@%
%@NL@%
    hwnd;        %@AB@%/* this prevents an "unused variable" warning message */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfSelectDimension%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Set the dimensions of the next fractal by dragging a rectangle%@NL@%
%@AB@%*   on the screen.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfSelectDimension(hwnd, pt)%@NL@%
HWND hwnd;%@NL@%
POINTS pt;%@NL@%
{%@NL@%
    TRACKINFO ti;%@NL@%
    LONG lXExt, lYExt;%@NL@%
%@NL@%
%@NL@%
    WinSendMsg(global.hwndFrame, WM_QUERYTRACKINFO, (MPARAM)TF_MOVE, (MPARAM)&ti);%@NL@%
%@NL@%
    ti.cxBorder   = 1;%@NL@%
    ti.cyBorder   = 1;%@NL@%
    ti.rclTrack.xLeft        = (LONG)pt.x;%@NL@%
    ti.rclTrack.yBottom = (LONG)pt.y;%@NL@%
    ti.rclTrack.xRight        = (LONG)pt.x;%@NL@%
    ti.rclTrack.yTop        = (LONG)pt.y;%@NL@%
    ti.fs = TF_RIGHT | TF_TOP;%@NL@%
    ti.ptlMinTrackSize.x = 1L;%@NL@%
    ti.ptlMinTrackSize.y = 1L;%@NL@%
%@NL@%
    if (WinTrackRect(hwnd, NULL, &ti))%@NL@%
    {%@NL@%
        lXExt = (global.pThrTop->rcl).xRight - (global.pThrTop->rcl).xLeft;%@NL@%
        lYExt = (global.pThrTop->rcl).yTop   - (global.pThrTop->rcl).yBottom;%@NL@%
%@NL@%
        global.dblXScale = (double)(ti.rclTrack.xRight - ti.rclTrack.xLeft)   / (double)lXExt;%@NL@%
        global.dblYScale = (double)(ti.rclTrack.yTop   - ti.rclTrack.yBottom) / (double)lYExt;%@NL@%
        global.dblXOff         = (double) ti.rclTrack.xLeft        / (double)lXExt;%@NL@%
        global.dblYOff         = (double) ti.rclTrack.yBottom / (double)lYExt;%@NL@%
%@NL@%
        global.flMiscAttrs |= LFA_XSCALE | LFA_YSCALE | LFA_XOFF | LFA_YOFF;%@NL@%
%@NL@%
        global.pThrTop->fUpdateAttrs = TRUE;%@NL@%
        global.fUpdateAttrs             = TRUE;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfSquareBitmap%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Resize the window horizontally to so that the client area is a%@NL@%
%@AB@%*   square.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfSquareBitmap(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    SWP swp;%@NL@%
    HWND hwndDesk;%@NL@%
    RECTL rcl;%@NL@%
%@NL@%
    if (hwnd == global.hwnd)%@NL@%
        if (hwndDesk = WinQueryDesktopWindow(global.hab, NULL))%@NL@%
            if (WinQueryWindowPos(global.hwndFrame, (PSWP)&swp))%@NL@%
            {%@NL@%
                rcl.xLeft   = 0L;%@NL@%
                rcl.yBottom = 0L;%@NL@%
                rcl.xRight  = swp.cx;%@NL@%
                rcl.yTop    = swp.cy;%@NL@%
                if (WinCalcFrameRect(global.hwndFrame, &rcl, TRUE))%@NL@%
                {%@NL@%
                    rcl.xRight        = (SHORT)((LONG)rcl.yTop   *%@NL@%
                                  global.pThrTop->AspectRatio.lHorz /%@NL@%
                                  global.pThrTop->AspectRatio.lVert);%@NL@%
%@NL@%
                    if (WinCalcFrameRect(global.hwndFrame, &rcl, FALSE))%@NL@%
                        WinSetWindowPos(global.hwndFrame, 0, swp.x, swp.y,%@NL@%
                            (SHORT)rcl.xRight, (SHORT)rcl.yTop,%@NL@%
                            SWP_SIZE);%@NL@%
                }%@NL@%
            }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfResizeBitmapToWindow%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Resize the bitmap to match the windows dimensions exactly.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfResizeBitmapToWindow()%@NL@%
{%@NL@%
    global.bm.cx = (USHORT) (global.rcl.xRight - global.rcl.xLeft);%@NL@%
    global.bm.cy = (USHORT) (global.rcl.yTop   - global.rcl.yBottom);%@NL@%
    global.bm.cPlanes        = global.pThrTop->cPlanes;%@NL@%
    global.bm.cBitCount = global.pThrTop->cBitCount;%@NL@%
%@NL@%
    LfResizePS(global.pThrTop);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfSelect%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Select a rectangle to cut or copy to the clipboard.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfSelect(hwnd, pt)%@NL@%
HWND hwnd;%@NL@%
POINTS pt;%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    TRACKINFO ti;%@NL@%
    PRECTL prcl;%@NL@%
%@NL@%
%@NL@%
    if (global.fShowSelectRc)%@NL@%
    {%@NL@%
        global.fShowSelectRc = FALSE;%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
        if (global.fTempSelect)%@NL@%
        {%@NL@%
            prcl = &global.rclSelect;%@NL@%
            global.fTempSelect = FALSE;%@NL@%
        }%@NL@%
        else%@NL@%
            prcl = &global.rclCutCopy;%@NL@%
        LfShowSelectRc(hps, prcl);%@NL@%
        WinReleasePS(hps);%@NL@%
    }%@NL@%
%@NL@%
    WinSendMsg(global.hwndFrame, WM_QUERYTRACKINFO, (MPARAM)TF_MOVE, (MPARAM)&ti);%@NL@%
%@NL@%
    ti.cxBorder = 1;%@NL@%
    ti.cyBorder = 1;%@NL@%
    ti.rclTrack.xLeft        = (LONG)pt.x;%@NL@%
    ti.rclTrack.yBottom = (LONG)pt.y;%@NL@%
    ti.rclTrack.xRight        = (LONG)pt.x;%@NL@%
    ti.rclTrack.yTop        = (LONG)pt.y;%@NL@%
    ti.fs = TF_RIGHT | TF_TOP;%@NL@%
    ti.ptlMinTrackSize.x = 1L;%@NL@%
    ti.ptlMinTrackSize.y = 1L;%@NL@%
%@NL@%
    if (WinTrackRect(hwnd, NULL, &ti))%@NL@%
    {%@NL@%
        global.rclSelect.xLeft         = ti.rclTrack.xLeft;%@NL@%
        global.rclSelect.yBottom = ti.rclTrack.yBottom;%@NL@%
        global.rclSelect.xRight  = ti.rclTrack.xRight;%@NL@%
        global.rclSelect.yTop         = ti.rclTrack.yTop;%@NL@%
%@NL@%
        global.fShowSelectRc = TRUE;%@NL@%
        global.fTempSelect   = TRUE;%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
        LfShowSelectRc(hps, &global.rclSelect);%@NL@%
        WinReleasePS(hps);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfSelectAll%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Select the entire surface to cut or copy to the clipboard.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfSelectAll(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    HPS hps;%@NL@%
%@NL@%
    global.rclSelect = global.pThrTop->rcl;%@NL@%
%@NL@%
    global.fShowSelectRc = TRUE;%@NL@%
    global.fTempSelect         = TRUE;%@NL@%
    hps = WinGetPS(hwnd);%@NL@%
    LfShowSelectRc(hps, &global.rclSelect);%@NL@%
    WinReleasePS(hps);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfCut%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Cuts the selected rectangle from the bitmap and puts it in the%@NL@%
%@AB@%*   clipboard.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfCut(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    if (LfCopy(hwnd))%@NL@%
        LfClearRect(global.pThrTop, &global.rclCutCopy);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfCopy%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Copies the selected rectangle from the bitmap the clipboard.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfCopy(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    PRECTL prcl;%@NL@%
    SIZEL size;%@NL@%
    BITMAPINFOHEADER bminfo;%@NL@%
    POINTL  aptl[4];%@NL@%
%@NL@%
%@NL@%
%@NL@%
    global.fShowSelectRc = FALSE;%@NL@%
    hps = WinGetPS(hwnd);%@NL@%
    if (global.fTempSelect)%@NL@%
    {%@NL@%
        prcl = &global.rclSelect;%@NL@%
        global.fTempSelect = FALSE;%@NL@%
    }%@NL@%
    else%@NL@%
        prcl = &global.rclCutCopy;%@NL@%
    LfShowSelectRc(hps, prcl);%@NL@%
    WinReleasePS(hps);%@NL@%
%@NL@%
    if (global.fUseClipbrd)%@NL@%
    {%@NL@%
        if (WinOpenClipbrd(global.hab))%@NL@%
        {%@NL@%
            global.fHaveSelectRc = TRUE;%@NL@%
            global.rclCutCopy.xLeft   = global.rclSelect.xLeft;%@NL@%
            global.rclCutCopy.yBottom = global.rclSelect.yBottom;%@NL@%
            global.rclCutCopy.xRight  = global.rclSelect.xRight;%@NL@%
            global.rclCutCopy.yTop    = global.rclSelect.yTop;%@NL@%
%@NL@%
            %@AB@%/* copy bits here */%@AE@%%@NL@%
%@NL@%
            WinCloseClipbrd(global.hab);%@NL@%
%@NL@%
            return TRUE;%@NL@%
        }%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
        global.fHaveSelectRc = TRUE;%@NL@%
        global.rclCutCopy.xLeft   = global.rclSelect.xLeft;%@NL@%
        global.rclCutCopy.yBottom = global.rclSelect.yBottom;%@NL@%
        global.rclCutCopy.xRight  = global.rclSelect.xRight;%@NL@%
        global.rclCutCopy.yTop          = global.rclSelect.yTop;%@NL@%
%@NL@%
        if (global.fHaveCutCopyDC)%@NL@%
        {%@NL@%
            GpiSetBitmap(global.CutCopyPS, NULL);%@NL@%
            GpiDeleteBitmap(global.CutCopyBM);%@NL@%
            GpiDestroyPS(global.CutCopyPS);%@NL@%
            DevCloseDC(global.CutCopyDC);%@NL@%
            global.fHaveCutCopyDC = FALSE;%@NL@%
        }%@NL@%
%@NL@%
        global.CutCopyDC = DevOpenDC(global.hab, OD_MEMORY, "*", 0L, NULL, NULL);%@NL@%
        if (!global.CutCopyDC)%@NL@%
            return FALSE;%@NL@%
%@NL@%
        size.cx = 0L;%@NL@%
        size.cy = 0L;%@NL@%
        global.CutCopyPS = GpiCreatePS(global.hab, global.CutCopyDC, &size,%@NL@%
                                 PU_PELS|GPIT_MICRO|GPIA_ASSOC);%@NL@%
        if (!global.CutCopyPS)%@NL@%
            goto lfc_error_close_dc;%@NL@%
%@NL@%
%@NL@%
        bminfo.cbFix = sizeof(BITMAPINFOHEADER);%@NL@%
        bminfo.cx = (USHORT) (global.rclCutCopy.xRight - global.rclCutCopy.xLeft);%@NL@%
        bminfo.cy = (USHORT) (global.rclCutCopy.yTop   - global.rclCutCopy.yBottom);%@NL@%
        bminfo.cPlanes         = global.pThrTop->cPlanes;%@NL@%
        bminfo.cBitCount = global.pThrTop->cBitCount;%@NL@%
        global.CutCopyBM = GpiCreateBitmap(global.CutCopyPS, &bminfo, 0L, 0L, 0L);%@NL@%
        if (!global.CutCopyBM)%@NL@%
            goto lfc_error_destroy_ps;%@NL@%
        GpiSetBitmap(global.CutCopyPS, global.CutCopyBM);%@NL@%
%@NL@%
        aptl[0].x = 0L;%@NL@%
        aptl[0].y = 0L;%@NL@%
        aptl[1].x = global.rclCutCopy.xRight - global.rclCutCopy.xLeft;%@NL@%
        aptl[1].y = global.rclCutCopy.yTop   - global.rclCutCopy.yBottom;%@NL@%
        aptl[2].x = global.rclCutCopy.xLeft;%@NL@%
        aptl[2].y = global.rclCutCopy.yBottom;%@NL@%
%@NL@%
        GpiBitBlt(global.CutCopyPS, global.pThrTop->hps, 3L, aptl, ROP_SRCCOPY, 0L);%@NL@%
%@NL@%
        global.fHaveCutCopyDC = TRUE;%@NL@%
        return TRUE;%@NL@%
%@NL@%
%@NL@%
lfc_error_destroy_ps:%@NL@%
        GpiDestroyPS(global.CutCopyPS);%@NL@%
lfc_error_close_dc:%@NL@%
        DevCloseDC(global.CutCopyDC);%@NL@%
        return FALSE;%@NL@%
    }%@NL@%
%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfPaste%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Pastes the selected rectangle from the clipboard to the bitmap.%@NL@%
%@AB@%*   Hides the selection rectangle before calling WinTrackRect.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfPaste(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    PRECTL prcl;%@NL@%
    TRACKINFO ti;%@NL@%
    POINTL    aptl[4];%@NL@%
%@NL@%
%@NL@%
    if (global.fShowSelectRc)%@NL@%
    {%@NL@%
        global.fShowSelectRc = FALSE;%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
        if (global.fTempSelect)%@NL@%
        {%@NL@%
            prcl = &global.rclSelect;%@NL@%
            global.fTempSelect = FALSE;%@NL@%
        }%@NL@%
        else%@NL@%
            prcl = &global.rclCutCopy;%@NL@%
        LfShowSelectRc(hps, prcl);%@NL@%
        WinReleasePS(hps);%@NL@%
    }%@NL@%
%@NL@%
    WinSendMsg(global.hwndFrame, WM_QUERYTRACKINFO, (MPARAM)TF_MOVE, (MPARAM)&ti);%@NL@%
%@NL@%
    ti.cxBorder = 1;%@NL@%
    ti.cyBorder = 1;%@NL@%
    ti.rclTrack.xLeft        = global.rclCutCopy.xLeft;%@NL@%
    ti.rclTrack.yBottom = global.rclCutCopy.yBottom;%@NL@%
    ti.rclTrack.xRight        = global.rclCutCopy.xRight;%@NL@%
    ti.rclTrack.yTop        = global.rclCutCopy.yTop;%@NL@%
    ti.fs = TF_MOVE;%@NL@%
    ti.ptlMinTrackSize.x = 1L;%@NL@%
    ti.ptlMinTrackSize.y = 1L;%@NL@%
%@NL@%
    if (WinTrackRect(hwnd, NULL, &ti))%@NL@%
    {%@NL@%
        if (global.fUseClipbrd)%@NL@%
        {%@NL@%
            if (WinOpenClipbrd(global.hab))%@NL@%
            {%@NL@%
                %@AB@%/* copy bits here */%@AE@%%@NL@%
                WinCloseClipbrd(global.hab);%@NL@%
            }%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
            aptl[0].x = ti.rclTrack.xLeft;%@NL@%
            aptl[0].y = ti.rclTrack.yBottom;%@NL@%
            aptl[1].x = ti.rclTrack.xLeft   + (global.rclCutCopy.xRight - global.rclCutCopy.xLeft);%@NL@%
            aptl[1].y = ti.rclTrack.yBottom + (global.rclCutCopy.yTop        - global.rclCutCopy.yBottom);%@NL@%
            aptl[2].x = 0L;%@NL@%
            aptl[2].y = 0L;%@NL@%
%@NL@%
            GpiBitBlt(global.pThrTop->hps, global.CutCopyPS, 3L, aptl, global.ulPasteROP, 0L);%@NL@%
            WinInvalidateRect(global.hwnd, &(ti.rclTrack), FALSE);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfSelectXform%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Select a similarity transform.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfSelectXform(hwnd, pthr, id)%@NL@%
HWND hwnd;%@NL@%
PTHR pthr;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    BOOL fAlreadySaidIt = FALSE;%@NL@%
%@NL@%
%@NL@%
    if ((id != pthr->usCurXform) ||%@NL@%
       ((id != global.usCurXform) && global.fUpdateAttrs))%@NL@%
    {%@NL@%
        if (global.fUpdateAttrs && (global.flMiscAttrs & LFA_CURXFORM))%@NL@%
        {%@NL@%
            MyMessageBox(hwnd, pszAttrs);%@NL@%
            fAlreadySaidIt = TRUE;%@NL@%
        }%@NL@%
%@NL@%
        global.flMiscAttrs |= LFA_CURXFORM;%@NL@%
%@NL@%
        if (LfIsThreadTop(pthr))%@NL@%
        {%@NL@%
            if (fAlreadySaidIt)%@NL@%
                UNCHECK_MENU_ITEM(global.hwndFrame, global.usCurXform);%@NL@%
            else%@NL@%
                UNCHECK_MENU_ITEM(global.hwndFrame, pthr->usCurXform);%@NL@%
            global.usCurXform = id;%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, id);%@NL@%
        }%@NL@%
        else%@NL@%
            global.usCurXform = id;%@NL@%
%@NL@%
        pthr->fUpdateAttrs  = TRUE;%@NL@%
        global.fUpdateAttrs = TRUE;%@NL@%
    }%@NL@%
%@NL@%
    if (pthr->fAutoSelectDims)%@NL@%
    {%@NL@%
        if (global.fUpdateAttrs && (global.flMiscAttrs & (LFA_XSCALE |%@NL@%
                 LFA_YSCALE | LFA_XOFF | LFA_YOFF | LFA_POLYGONSIDES)))%@NL@%
            if (!fAlreadySaidIt)%@NL@%
                MyMessageBox(hwnd, pszAttrs);%@NL@%
%@NL@%
        global.dblXScale      = aXform[id - IDM_SHARKTOOTH].xScale;%@NL@%
        global.dblYScale      = aXform[id - IDM_SHARKTOOTH].yScale;%@NL@%
        global.dblXOff              = aXform[id - IDM_SHARKTOOTH].xOff;%@NL@%
        global.dblYOff              = aXform[id - IDM_SHARKTOOTH].yOff;%@NL@%
        global.usPolygonSides = aXform[id - IDM_SHARKTOOTH].usSides;%@NL@%
%@NL@%
        global.flMiscAttrs |= LFA_XSCALE | LFA_YSCALE | LFA_XOFF | LFA_YOFF |%@NL@%
                              LFA_POLYGONSIDES;%@NL@%
        pthr->fUpdateAttrs  = TRUE;%@NL@%
        global.fUpdateAttrs = TRUE;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfSelectPrim%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Select a drawing primitive.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfSelectPrim(hwnd, pthr, id)%@NL@%
HWND hwnd;%@NL@%
PTHR pthr;%@NL@%
USHORT id;%@NL@%
{%@NL@%
    BOOL fAlreadySaidIt = FALSE;%@NL@%
%@NL@%
%@NL@%
    if ((id != pthr->usCurPrim) ||%@NL@%
       ((id != global.usCurPrim) && global.fUpdateAttrs))%@NL@%
    {%@NL@%
        if (global.fUpdateAttrs && (global.flMiscAttrs & LFA_CURPRIM))%@NL@%
        {%@NL@%
            MyMessageBox(hwnd, "Previous attributes not read yet.");%@NL@%
            fAlreadySaidIt = TRUE;%@NL@%
        }%@NL@%
%@NL@%
        if (LfIsThreadTop(pthr))%@NL@%
        {%@NL@%
            if (fAlreadySaidIt)%@NL@%
                UNCHECK_MENU_ITEM(global.hwndFrame, global.usCurPrim);%@NL@%
            else%@NL@%
                UNCHECK_MENU_ITEM(global.hwndFrame, pthr->usCurPrim);%@NL@%
            global.usCurPrim = id;%@NL@%
            CHECK_MENU_ITEM(global.hwndFrame, id);%@NL@%
        }%@NL@%
        else%@NL@%
            global.usCurPrim = id;%@NL@%
%@NL@%
        global.flMiscAttrs |= LFA_CURPRIM;%@NL@%
        pthr->fUpdateAttrs  = TRUE;%@NL@%
        global.fUpdateAttrs = TRUE;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LFDLG.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\LINEFRAC\LFDLG.C%@AE@%%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   lfdlg.c -- Window procedures for dialog boxes used in LineFractal.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GLOBALS %@NL@%
%@AI@%#define %@AE@%INCL_THREADS %@NL@%
%@AI@%#include %@AE@%"linefrac.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_LFDLG %@NL@%
%@AI@%#define %@AE@%INCL_LFUTIL %@NL@%
%@AI@%#include %@AE@%"lffuncs.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Global Variables%@NL@%
%@AB@%*%@NL@%
%@AB@%*   global        Global data block.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
extern GLOBALDATA global;%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   AboutDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the About box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
AboutDlg(hwnd, usMsg, mp1, mp2)%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_COMMAND:                        %@AB@%/* the user has pressed a button */%@AE@%%@NL@%
        switch (SHORT1FROMMP(mp1))        %@AB@%/* which button? */%@AE@%%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, TRUE);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   TimerDelayDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the dialog box used to set the timer delay%@NL@%
%@AB@%*   values for automatically restarting a drawing.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
TimerDelayDlg(hwnd, usMsg, mp1, mp2)%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
        MySetWindowUShort(hwnd, IDD_MINDELAY, global.usMinTimerDelay);%@NL@%
        MySetWindowUShort(hwnd, IDD_MAXDELAY, global.usMaxTimerDelay);%@NL@%
        return FALSE;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
            MyGetWindowUShort(hwnd, IDD_MINDELAY, &global.usMinTimerDelay);%@NL@%
            MyGetWindowUShort(hwnd, IDD_MAXDELAY, &global.usMaxTimerDelay);%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   BitmapParamsDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the bitmap parameters dialog box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
BitmapParamsDlg( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
%@NL@%
        MySetWindowUShort(hwnd, IDD_BMCX,     global.bm.cx);%@NL@%
        MySetWindowUShort(hwnd, IDD_BMCY,     global.bm.cy);%@NL@%
        MySetWindowUShort(hwnd, IDD_BMPLANES, global.bm.cPlanes);%@NL@%
        MySetWindowUShort(hwnd, IDD_BMBPP,    global.bm.cBitCount);%@NL@%
%@NL@%
        return FALSE;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
%@NL@%
            MyGetWindowUShort(hwnd, IDD_BMCX,          &global.bm.cx);%@NL@%
            MyGetWindowUShort(hwnd, IDD_BMCY,          &global.bm.cy);%@NL@%
            MyGetWindowUShort(hwnd, IDD_BMPLANES, &global.bm.cPlanes);%@NL@%
            MyGetWindowUShort(hwnd, IDD_BMBPP,          &global.bm.cBitCount);%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   SwitchDelayDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the dialog box used to set the switch%@NL@%
%@AB@%*   delay value for automatically switching between threads.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
SwitchDelayDlg(hwnd, usMsg, mp1, mp2)%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
        MySetWindowUShort(hwnd, IDD_SWITCHDELAY, global.usSwitchDelay);%@NL@%
        return FALSE;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
            MyGetWindowUShort(hwnd, IDD_SWITCHDELAY, &global.usSwitchDelay);%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LineAttrsDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the line attributes dialog box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%SETLINEATTR(H, I, J)                                                  \ %@NL@%
        MySetWindow##I(hwnd, J, global.lb.H)%@NL@%
%@NL@%
%@AI@%#define %@AE@%GETLINEATTR(H, I, J, K, L)                                          \ %@NL@%
        {                                                                  \%@NL@%
            J temp;                                                          \%@NL@%
            MyGetWindow##I(hwnd, K, &temp);                                  \%@NL@%
            if (temp != global.lb.H)                                          \%@NL@%
            {                                                                  \%@NL@%
                global.lb.H = temp;                                          \%@NL@%
                global.flLineAttrs |= L;                                  \%@NL@%
            }                                                                  \%@NL@%
        }%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
LineAttrsDlg( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
%@NL@%
        if (!global.fUpdateAttrs || !(global.flLineAttrs & LFA_LINEALL))%@NL@%
            global.lb = global.pThrTop->lb;%@NL@%
%@NL@%
        SETLINEATTR(lColor,        Long,        IDD_LINECOLOR);%@NL@%
        SETLINEATTR(usMixMode,        UShort, IDD_LINEMIX);%@NL@%
        SETLINEATTR(fxWidth,        Long,        IDD_LINEWIDTH);%@NL@%
        SETLINEATTR(lGeomWidth, Long,        IDD_LINEGEOMWIDTH);%@NL@%
        SETLINEATTR(usType,        UShort, IDD_LINETYPE);%@NL@%
        SETLINEATTR(usEnd,        UShort, IDD_LINEEND);%@NL@%
        SETLINEATTR(usJoin,        UShort, IDD_LINEJOIN);%@NL@%
%@NL@%
        return FALSE;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
%@NL@%
            GETLINEATTR(lColor,     Long,   LONG,   IDD_LINECOLOR,     LFA_LINECOLOR);%@NL@%
            GETLINEATTR(usMixMode,  UShort, USHORT, IDD_LINEMIX,       LFA_LINEMIX);%@NL@%
            GETLINEATTR(fxWidth,    Long,   LONG,   IDD_LINEWIDTH,     LFA_LINEWIDTH);%@NL@%
            GETLINEATTR(lGeomWidth, Long,   LONG,   IDD_LINEGEOMWIDTH, LFA_LINEGEOMWIDTH);%@NL@%
            GETLINEATTR(usType,     UShort, USHORT, IDD_LINETYPE,      LFA_LINETYPE);%@NL@%
            GETLINEATTR(usEnd,            UShort, USHORT, IDD_LINEEND,       LFA_LINEEND);%@NL@%
            GETLINEATTR(usJoin,     UShort, USHORT, IDD_LINEJOIN,      LFA_LINEJOIN);%@NL@%
%@NL@%
            if (global.flLineAttrs & LFA_LINEALL)%@NL@%
            {%@NL@%
                global.pThrTop->fUpdateAttrs = TRUE;%@NL@%
                global.fUpdateAttrs = TRUE;%@NL@%
            }%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@AI@%#undef %@AE@%SETLINEATTR %@NL@%
%@AI@%#undef %@AE@%GETLINEATTR %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MarkerAttrsDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the marker attributes dialog box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%SETMARKATTR(H, I, J)                                                  \ %@NL@%
        MySetWindow##I(hwnd, J, global.mb.H)%@NL@%
%@NL@%
%@AI@%#define %@AE@%GETMARKATTR(H, I, J, K, L)                                          \ %@NL@%
        {                                                                  \%@NL@%
            J temp;                                                          \%@NL@%
            MyGetWindow##I(hwnd, K, &temp);                                  \%@NL@%
            if (temp != global.mb.H)                                          \%@NL@%
            {                                                                  \%@NL@%
                global.mb.H = temp;                                          \%@NL@%
                global.flMarkerAttrs |= L;                                  \%@NL@%
            }                                                                  \%@NL@%
        }%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
MarkerAttrsDlg( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
%@NL@%
        if (!global.fUpdateAttrs || !(global.flMarkerAttrs & LFA_MARKALL))%@NL@%
            global.mb = global.pThrTop->mb;%@NL@%
%@NL@%
        SETMARKATTR(lColor,           Long,   IDD_MARKCOLOR);%@NL@%
        SETMARKATTR(lBackColor,    Long,   IDD_MARKBACKCOLOR);%@NL@%
        SETMARKATTR(usMixMode,           UShort, IDD_MARKMIX);%@NL@%
        SETMARKATTR(usBackMixMode, UShort, IDD_MARKBACKMIX);%@NL@%
        SETMARKATTR(usSet,           UShort, IDD_MARKSET);%@NL@%
        SETMARKATTR(usSymbol,           UShort, IDD_MARKSYMBOL);%@NL@%
        SETMARKATTR(sizfxCell.cx,  Long,   IDD_MARKCELLWIDTH);%@NL@%
        SETMARKATTR(sizfxCell.cy,  Long,   IDD_MARKCELLHEIGHT);%@NL@%
%@NL@%
        return FALSE;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
%@NL@%
            GETMARKATTR(lColor,        Long,   LONG,   IDD_MARKCOLOR,          LFA_MARKCOLOR);%@NL@%
            GETMARKATTR(lBackColor,    Long,   LONG,   IDD_MARKBACKCOLOR,  LFA_MARKBACKCOLOR);%@NL@%
            GETMARKATTR(usMixMode,     UShort, USHORT, IDD_MARKMIX,          LFA_MARKMIX);%@NL@%
            GETMARKATTR(usBackMixMode, UShort, USHORT, IDD_MARKBACKMIX,          LFA_MARKBACKMIX);%@NL@%
            GETMARKATTR(usSet,               UShort, USHORT, IDD_MARKSET,          LFA_MARKSET);%@NL@%
            GETMARKATTR(usSymbol,      UShort, USHORT, IDD_MARKSYMBOL,          LFA_MARKSYMBOL);%@NL@%
            GETMARKATTR(sizfxCell.cx,  Long,   LONG,   IDD_MARKCELLWIDTH,  LFA_MARKCELLWIDTH);%@NL@%
            GETMARKATTR(sizfxCell.cy,  Long,   LONG,   IDD_MARKCELLHEIGHT, LFA_MARKCELLHEIGHT);%@NL@%
%@NL@%
            if (global.flMarkerAttrs & LFA_MARKALL)%@NL@%
            {%@NL@%
                global.pThrTop->fUpdateAttrs = TRUE;%@NL@%
                global.fUpdateAttrs = TRUE;%@NL@%
            }%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@AI@%#undef %@AE@%SETMARKATTR %@NL@%
%@AI@%#undef %@AE@%GETMARKATTR %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   AreaAttrsDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the area attributes dialog box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%SETAREAATTR(H, I, J)                                                  \ %@NL@%
        MySetWindow##I(hwnd, J, global.ab.H)%@NL@%
%@NL@%
%@AI@%#define %@AE@%GETAREAATTR(H, I, J, K, L)                                          \ %@NL@%
        {                                                                  \%@NL@%
            J temp;                                                          \%@NL@%
            MyGetWindow##I(hwnd, K, &temp);                                  \%@NL@%
            if (temp != global.ab.H)                                          \%@NL@%
            {                                                                  \%@NL@%
                global.ab.H = temp;                                          \%@NL@%
                global.flAreaAttrs |= L;                                  \%@NL@%
            }                                                                  \%@NL@%
        }%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
AreaAttrsDlg( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
%@NL@%
        if (!global.fUpdateAttrs || !(global.flAreaAttrs & LFA_AREAALL))%@NL@%
            global.ab = global.pThrTop->ab;%@NL@%
%@NL@%
        SETAREAATTR(lColor,           Long,   IDD_AREACOLOR);%@NL@%
        SETAREAATTR(lBackColor,    Long,   IDD_AREABACKCOLOR);%@NL@%
        SETAREAATTR(usMixMode,           UShort, IDD_AREAMIX);%@NL@%
        SETAREAATTR(usBackMixMode, UShort, IDD_AREABACKMIX);%@NL@%
        SETAREAATTR(usSet,           UShort, IDD_AREASET);%@NL@%
        SETAREAATTR(usSymbol,           UShort, IDD_AREASYMBOL);%@NL@%
        SETAREAATTR(ptlRefPoint.x, Long,   IDD_AREAREFX);%@NL@%
        SETAREAATTR(ptlRefPoint.y, Long,   IDD_AREAREFY);%@NL@%
%@NL@%
        return FALSE;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
%@NL@%
            GETAREAATTR(lColor,        Long,   LONG,   IDD_AREACOLOR,         LFA_AREACOLOR);%@NL@%
            GETAREAATTR(lBackColor,    Long,   LONG,   IDD_AREABACKCOLOR, LFA_AREABACKCOLOR);%@NL@%
            GETAREAATTR(usMixMode,     UShort, USHORT, IDD_AREAMIX,         LFA_AREAMIX);%@NL@%
            GETAREAATTR(usBackMixMode, UShort, USHORT, IDD_AREABACKMIX,         LFA_AREABACKMIX);%@NL@%
            GETAREAATTR(usSet,               UShort, USHORT, IDD_AREASET,         LFA_AREASET);%@NL@%
            GETAREAATTR(usSymbol,      UShort, USHORT, IDD_AREASYMBOL,         LFA_AREASYMBOL);%@NL@%
            GETAREAATTR(ptlRefPoint.x, Long,   LONG,   IDD_AREAREFX,         LFA_AREAREFX);%@NL@%
            GETAREAATTR(ptlRefPoint.y, Long,   LONG,   IDD_AREAREFY,         LFA_AREAREFY);%@NL@%
%@NL@%
            if (global.flAreaAttrs & LFA_AREAALL)%@NL@%
            {%@NL@%
                global.pThrTop->fUpdateAttrs = TRUE;%@NL@%
                global.fUpdateAttrs = TRUE;%@NL@%
            }%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@AI@%#undef %@AE@%SETAREAATTR %@NL@%
%@AI@%#undef %@AE@%GETAREAATTR %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   ImageAttrsDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the image attributes dialog box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%SETIMAGEATTR(H, I, J)                                                  \ %@NL@%
        MySetWindow##I(hwnd, J, global.ib.H)%@NL@%
%@NL@%
%@AI@%#define %@AE@%GETIMAGEATTR(H, I, J, K, L)                                          \ %@NL@%
        {                                                                  \%@NL@%
            J temp;                                                          \%@NL@%
            MyGetWindow##I(hwnd, K, &temp);                                  \%@NL@%
            if (temp != global.ib.H)                                          \%@NL@%
            {                                                                  \%@NL@%
                global.ib.H = temp;                                          \%@NL@%
                global.flImageAttrs |= L;                                  \%@NL@%
            }                                                                  \%@NL@%
        }%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
ImageAttrsDlg( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
%@NL@%
        if (!global.fUpdateAttrs || !(global.flImageAttrs & LFA_IMAGEALL))%@NL@%
            global.ib = global.pThrTop->ib;%@NL@%
%@NL@%
        SETIMAGEATTR(lColor,            Long,   IDD_IMAGECOLOR);%@NL@%
        SETIMAGEATTR(lBackColor,    Long,   IDD_IMAGEBACKCOLOR);%@NL@%
        SETIMAGEATTR(usMixMode,     UShort, IDD_IMAGEMIX);%@NL@%
        SETIMAGEATTR(usBackMixMode, UShort, IDD_IMAGEBACKMIX);%@NL@%
%@NL@%
        return FALSE;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
%@NL@%
            GETIMAGEATTR(lColor,        Long,        LONG,        IDD_IMAGECOLOR,           LFA_IMAGECOLOR);%@NL@%
            GETIMAGEATTR(lBackColor,        Long,        LONG,        IDD_IMAGEBACKCOLOR, LFA_IMAGEBACKCOLOR);%@NL@%
            GETIMAGEATTR(usMixMode,        UShort, USHORT, IDD_IMAGEMIX,           LFA_IMAGEMIX);%@NL@%
            GETIMAGEATTR(usBackMixMode, UShort, USHORT, IDD_IMAGEBACKMIX,   LFA_IMAGEBACKMIX);%@NL@%
%@NL@%
            if (global.flImageAttrs & LFA_IMAGEALL)%@NL@%
            {%@NL@%
                global.pThrTop->fUpdateAttrs = TRUE;%@NL@%
                global.fUpdateAttrs = TRUE;%@NL@%
            }%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@AI@%#undef %@AE@%SETIMAGEATTR %@NL@%
%@AI@%#undef %@AE@%GETIMAGEATTR %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MiscAttrsDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the fractal attributes dialog box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%SETMISCATTR(H, I, J)                                                  \ %@NL@%
        MySetWindow##I(hwnd, J, global.H)%@NL@%
%@NL@%
%@AI@%#define %@AE@%GETMISCATTR(H, I, J, K, L)                                          \ %@NL@%
        {                                                                  \%@NL@%
            J temp;                                                          \%@NL@%
            MyGetWindow##I(hwnd, K, &temp);                                  \%@NL@%
            if (temp != global.H)                                          \%@NL@%
            {                                                                  \%@NL@%
                global.H = temp;                                          \%@NL@%
                global.flMiscAttrs |= L;                                  \%@NL@%
            }                                                                  \%@NL@%
        }%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
MiscAttrsDlg( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
%@NL@%
        if (!global.fUpdateAttrs || !(global.flMiscAttrs &%@NL@%
                (LFA_RECURSION|LFA_CPTMAX|LFA_POLYGONSIDES|LFA_ROTATION)))%@NL@%
        {%@NL@%
            global.usRecursion          = global.pThrTop->usRecursion;%@NL@%
            global.cptMax          = global.pThrTop->cptMax;%@NL@%
            global.usPolygonSides = global.pThrTop->usPolygonSides;%@NL@%
            global.dblRotation          = global.pThrTop->dblRotation;%@NL@%
        }%@NL@%
%@NL@%
        SETMISCATTR(usRecursion,    UShort, IDD_RECURSION);%@NL@%
        SETMISCATTR(cptMax,            UShort, IDD_CPTMAX);%@NL@%
        SETMISCATTR(usPolygonSides, UShort, IDD_NUMSIDES);%@NL@%
        SETMISCATTR(dblRotation,    Double, IDD_ROTATION);%@NL@%
%@NL@%
        return FALSE;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
%@NL@%
            GETMISCATTR(usRecursion,        UShort, USHORT, IDD_RECURSION, LFA_RECURSION);%@NL@%
            GETMISCATTR(cptMax,         UShort, USHORT, IDD_CPTMAX,    LFA_CPTMAX);%@NL@%
            GETMISCATTR(usPolygonSides, UShort, USHORT, IDD_NUMSIDES,  LFA_POLYGONSIDES);%@NL@%
            GETMISCATTR(dblRotation,        Double, double, IDD_ROTATION,  LFA_ROTATION);%@NL@%
%@NL@%
            if (global.flMiscAttrs & LFA_POLYGONSIDES)%@NL@%
                if (global.usPolygonSides == 0)%@NL@%
                    global.usPolygonSides = 2;%@NL@%
%@NL@%
            if (global.flMiscAttrs & LFA_CPTMAX)%@NL@%
            {%@NL@%
                if (global.cptMax == 0)%@NL@%
                    global.cptMax = 1;%@NL@%
                else if (global.cptMax > MAX_POINT_COUNT)%@NL@%
                    global.cptMax = MAX_POINT_COUNT;%@NL@%
            }%@NL@%
%@NL@%
            if (global.flMiscAttrs & (LFA_RECURSION|LFA_CPTMAX|%@NL@%
                LFA_POLYGONSIDES|LFA_ROTATION))%@NL@%
            {%@NL@%
                global.pThrTop->fUpdateAttrs = TRUE;%@NL@%
                global.fUpdateAttrs = TRUE;%@NL@%
            }%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@AI@%#undef %@AE@%SETMISCATTR %@NL@%
%@AI@%#undef %@AE@%GETMISCATTR %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   DimensionsDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the fractal dimensions dialog box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%SETDIMENSIONS(H, I, J)                                                  \ %@NL@%
        MySetWindow##I(hwnd, J, global.H)%@NL@%
%@NL@%
%@AI@%#define %@AE@%GETDIMENSIONS(H, I, J, K, L)                                          \ %@NL@%
        {                                                                  \%@NL@%
            J temp;                                                          \%@NL@%
            MyGetWindow##I(hwnd, K, &temp);                                  \%@NL@%
            if (temp != global.H)                                          \%@NL@%
            {                                                                  \%@NL@%
                global.H = temp;                                          \%@NL@%
                global.flMiscAttrs |= L;                                  \%@NL@%
            }                                                                  \%@NL@%
        }%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
DimensionsDlg( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
%@NL@%
        if (!global.fUpdateAttrs || !(global.flMiscAttrs &%@NL@%
            (LFA_XOFF|LFA_YOFF|LFA_XSCALE|LFA_YSCALE)))%@NL@%
        {%@NL@%
            global.dblXOff   = global.pThrTop->dblXOff;%@NL@%
            global.dblYOff   = global.pThrTop->dblYOff;%@NL@%
            global.dblXScale = global.pThrTop->dblXScale;%@NL@%
            global.dblYScale = global.pThrTop->dblYScale;%@NL@%
        }%@NL@%
%@NL@%
        SETDIMENSIONS(dblXOff,         Double, IDD_XOFF);%@NL@%
        SETDIMENSIONS(dblYOff,         Double, IDD_YOFF);%@NL@%
        SETDIMENSIONS(dblXScale, Double, IDD_XSCALE);%@NL@%
        SETDIMENSIONS(dblYScale, Double, IDD_YSCALE);%@NL@%
%@NL@%
        return FALSE;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
%@NL@%
            GETDIMENSIONS(dblXOff,   Double, double, IDD_XOFF,        LFA_XOFF);%@NL@%
            GETDIMENSIONS(dblYOff,   Double, double, IDD_YOFF,        LFA_YOFF);%@NL@%
            GETDIMENSIONS(dblXScale, Double, double, IDD_XSCALE, LFA_XSCALE);%@NL@%
            GETDIMENSIONS(dblYScale, Double, double, IDD_YSCALE, LFA_YSCALE);%@NL@%
%@NL@%
            if (global.flMiscAttrs & (LFA_XOFF|LFA_YOFF|LFA_XSCALE|LFA_YSCALE))%@NL@%
            {%@NL@%
                global.pThrTop->fUpdateAttrs = TRUE;%@NL@%
                global.fUpdateAttrs = TRUE;%@NL@%
            }%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@AI@%#undef %@AE@%SETDIMENSIONS %@NL@%
%@AI@%#undef %@AE@%GETDIMENSIONS %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   PtrPreferencesDlg%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the mouse pointer preferences dialog box.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%SETPTRPREF(H, I, J)                                    \ %@NL@%
        MySetWindow##I(hwnd, J, global.H)%@NL@%
%@NL@%
%@AI@%#define %@AE@%GETPTRPREF(H, I, J)                                    \ %@NL@%
        MyGetWindow##I(hwnd, J, &global.H)%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
PtrPreferencesDlg( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL fRet = FALSE;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_INITDLG:%@NL@%
%@NL@%
        SETPTRPREF(usPtrThreshold, UShort, IDD_PTRTHRESHOLD);%@NL@%
        WinSendDlgItemMsg(hwnd, global.usUserPtr+IDD_USERPTR0,%@NL@%
                          BM_SETCHECK, (MPARAM)TRUE, 0L);%@NL@%
        return FALSE;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1))%@NL@%
        {%@NL@%
        case IDD_OK:%@NL@%
%@NL@%
            GETPTRPREF(usPtrThreshold, UShort, IDD_PTRTHRESHOLD);%@NL@%
            global.usUserPtr = SHORT1FROMMR( WinSendDlgItemMsg(hwnd, IDD_USERPTR0,%@NL@%
                                                  BM_QUERYCHECKINDEX, 0L, 0L));%@NL@%
%@NL@%
%@AB@%/*            if (global.usPtrThreshold < 0)%@NL@%
%@AB@%                global.usPtrThreshold = 0; */%@AE@%%@NL@%
%@NL@%
            if (!global.fAnimatePtr)%@NL@%
                global.usCurPtr = global.usUserPtr;%@NL@%
%@NL@%
            fRet = TRUE;%@NL@%
%@NL@%
            %@AB@%/* fall through to some common code */%@AE@%%@NL@%
%@NL@%
        case IDD_CANCEL:%@NL@%
            WinDismissDlg(hwnd, fRet);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return (ULONG) WinDefDlgProc(hwnd, usMsg, mp1, mp2);%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@AI@%#undef %@AE@%SETPTRPREF %@NL@%
%@AI@%#undef %@AE@%GETPTRPREF %@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LFDRAW.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\LINEFRAC\LFDRAW.C%@AE@%%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   lfdraw.c -- This file contains "line fractal" drawing routines%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Background fractal drawing scheme:%@NL@%
%@AB@%*%@NL@%
%@AB@%*        To enable the user to interact with the system during%@NL@%
%@AB@%*        the drawing of a complicated fractal, the fractal is%@NL@%
%@AB@%*        drawn into a bitmap by a background thread.  This thread%@NL@%
%@AB@%*        is started at the first WM_PAINT message received by the%@NL@%
%@AB@%*        application, and never terminates.%@NL@%
%@AB@%*%@NL@%
%@AB@%*        The thread's execution is controlled by a semaphore,%@NL@%
%@AB@%*        lSemRedraw.  The thread is initially blocked%@NL@%
%@AB@%*        by its semaphore.  When something changes in the environ-%@NL@%
%@AB@%*        ment such that the fractal is to be redrawn, or drawn for%@NL@%
%@AB@%*        the first time, the semaphore is cleared and the thread%@NL@%
%@AB@%*        is off and running.  Note that the environment must be%@NL@%
%@AB@%*        set up BEFORE the semaphore is cleared, otherwise the%@NL@%
%@AB@%*        fractal may be partially drawn with old parameters.%@NL@%
%@AB@%*        The thread automatically resets the semaphore, so that%@NL@%
%@AB@%*        as soon as it's done drawing, it has to wait for the signal%@NL@%
%@AB@%*        to start again.%@NL@%
%@AB@%*%@NL@%
%@AB@%*        The fractal is drawn in batches of up to 8196 points per polyline.%@NL@%
%@AB@%*        After each polyline is drawn, the background thread invalidates%@NL@%
%@AB@%*        the main client rectangle to force a WM_PAINT message to be sent.%@NL@%
%@AB@%*        All the paint procedure does is copy the bitmap, whatever%@NL@%
%@AB@%*        it's current state, to the screen.  The user therefore%@NL@%
%@AB@%*        sees bursts of n points at a time as his fractal is drawn.%@NL@%
%@AB@%*%@NL@%
%@AB@%*        The semaphore is controlled, in greater detail, as follows:%@NL@%
%@AB@%*%@NL@%
%@AB@%*            Disable background drawing (set semaphore):%@NL@%
%@AB@%*%@NL@%
%@AB@%*                LfInit%@NL@%
%@AB@%*                    Don't let second thread start working until a%@NL@%
%@AB@%*                    transform has been defined.%@NL@%
%@AB@%*%@NL@%
%@AB@%*                LineFractalThread%@NL@%
%@AB@%*                    Don't start the next one until the user asks for it.%@NL@%
%@AB@%*%@NL@%
%@AB@%*            Enable background drawing (clear semaphore):%@NL@%
%@AB@%*%@NL@%
%@AB@%*                WM_BUTTON1UP%@NL@%
%@AB@%*                WM_BUTTON2UP%@NL@%
%@AB@%*                WM_SIZE & fAutoSizePS%@NL@%
%@AB@%*                    The level of recursion or dimensions of bitmap have%@NL@%
%@AB@%*                    changed, so redraw the fractal.%@NL@%
%@AB@%*%@NL@%
%@AB@%*                Change of fractal%@NL@%
%@AB@%*                Change of drawing primitive%@NL@%
%@AB@%*                Change of attributes%@NL@%
%@AB@%*                    If the corresponding redraw flag is enabled for one%@NL@%
%@AB@%*                    of these events, then the semaphore is cleared.%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*         Event                                          LineFractalThread%@NL@%
%@AB@%*         -----                                          -----------------%@NL@%
%@AB@%*%@NL@%
%@AB@%*    WM_BUTTON1UP                                  --------<--------%@NL@%
%@AB@%*    WM_BUTTON2UP                                 /                   \%@NL@%
%@AB@%*    WM_SIZE & fAutoSizePS                        |                    |%@NL@%
%@AB@%*    Change of fractal/primitive/attributes        |                    |%@NL@%
%@AB@%*           |                                        |                    |%@NL@%
%@AB@%*           |                                        V                    |%@NL@%
%@AB@%*           +---------clear----------> +----------------------+            |%@NL@%
%@AB@%*                                      |     lSemRedraw             |            |%@NL@%
%@AB@%*           +----------set-----------> +----------------------+            |%@NL@%
%@AB@%*           |                                        |                    |%@NL@%
%@AB@%*           |                              if semaphore is clear            ^%@NL@%
%@AB@%*    initialization                                |                    |%@NL@%
%@AB@%* done with current fractal                        V                    |%@NL@%
%@AB@%*                                      +----------------------+            |%@NL@%
%@AB@%*                                      |    Draw fractal      |            |%@NL@%
%@AB@%*                       WM_PAINT <---- |    into bitmap             |            |%@NL@%
%@AB@%*                                      +----------------------+            |%@NL@%
%@AB@%*                                                |                    |%@NL@%
%@AB@%*                                                |                    |%@NL@%
%@AB@%*                                                 \                    /%@NL@%
%@AB@%*                                                  -------->--------%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#define %@AE@%INCL_DOSSEMAPHORES %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GLOBALS %@NL@%
%@AI@%#define %@AE@%INCL_THREADS %@NL@%
%@AI@%#include %@AE@%"linefrac.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_LFTHREAD %@NL@%
%@AI@%#define %@AE@%INCL_LFDRAW %@NL@%
%@AI@%#include %@AE@%"lffuncs.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Global Variables%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
extern GLOBALDATA global;%@NL@%
extern XFORMDATA  aXform[];%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LineFractalThread%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Organize the drawing of the fractal.  Runs in an independent%@NL@%
%@AB@%*   thread to accumulate the points of the fractal, then calls%@NL@%
%@AB@%*   LfDraw to draw with the selected primitive onto the surface in%@NL@%
%@AB@%*   batches of a size selected by the user.  If this thread is the%@NL@%
%@AB@%*   top, then all or part of the client rectangle is invalidated%@NL@%
%@AB@%*   after drawing to force a WM_PAINT message.        When the paint message%@NL@%
%@AB@%*   is processed, the image will be copied to the display.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   This function is entered via _beginthread, which takes care of%@NL@%
%@AB@%*   putting the parameter on the stack.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID FAR cdecl%@NL@%
LineFractalThread(pthr)%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
    HAB hab;%@NL@%
    int cFracSegs;%@NL@%
    ULONG cptReq;%@NL@%
    BOOL fCached;%@NL@%
    BOOL fCacheable;%@NL@%
    BOOL fModelXformsValid;%@NL@%
    PLINEFRAC pXform;               %@AB@%/* linked list of fractal segments */%@AE@%%@NL@%
%@NL@%
%@NL@%
    hab = WinInitialize(0);              %@AB@%/* initialize ring 2 stack for thread */%@AE@%%@NL@%
%@NL@%
    fModelXformsValid = FALSE;%@NL@%
    fCached              = FALSE;%@NL@%
    fCacheable              = FALSE;%@NL@%
%@NL@%
    pthr->pptl              = NULL;%@NL@%
    pthr->pmatlf      = NULL;%@NL@%
%@NL@%
    while (!pthr->fTimeToDie)%@NL@%
    {%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *%@NL@%
%@AB@%        *  Clear the busy flag to indicate we're at the semaphore.%@NL@%
%@AB@%        *  If we happen to be the top thread, then force the pointer%@NL@%
%@AB@%        *  to be what we expect to see (if we didn't do this, it%@NL@%
%@AB@%        *  might stay as an hour glass until the user moves the mouse).%@NL@%
%@AB@%        *%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        pthr->fBusy = FALSE;%@NL@%
        if (LfIsThreadTop(pthr))%@NL@%
            if ((global.hptr)[global.usCurPtr])%@NL@%
                WinSetPointer(HWND_DESKTOP,(global.hptr)[global.usCurPtr]);%@NL@%
%@NL@%
%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *%@NL@%
%@AB@%        *  Wait for permission to redraw.%@NL@%
%@AB@%        *  See if we're supposed to exit.  If not, clear the suicide%@NL@%
%@AB@%        *  flag, and set the busy flag.  If we're the top thread, then%@NL@%
%@AB@%        *  set the pointer to an hour glass to let the user know we're%@NL@%
%@AB@%        *  working on something.%@NL@%
%@AB@%        *%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        DosSemRequest(&pthr->lSemRedraw, -1L);%@NL@%
%@NL@%
        if (pthr->fTimeToDie)%@NL@%
            goto lfthread_exit;%@NL@%
        pthr->fInterrupted = FALSE;%@NL@%
        pthr->fBusy           = TRUE;%@NL@%
        if (LfIsThreadTop(pthr))%@NL@%
            if (global.hptrWait)%@NL@%
                WinSetPointer(HWND_DESKTOP,global.hptrWait);%@NL@%
%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *%@NL@%
%@AB@%        *  Check for changes of attributes.  If anything has changed,%@NL@%
%@AB@%        *  this subroutine copies the new stuff over within a critical%@NL@%
%@AB@%        *  section.%@NL@%
%@AB@%        *%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        LfUpdateAttrs(pthr);%@NL@%
%@NL@%
%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *%@NL@%
%@AB@%        *  Check the buffers for points and model transforms.  If we%@NL@%
%@AB@%        *  don't have them, or the appropriate attributes have changed%@NL@%
%@AB@%        *  such that the ones we have are invalid, allocate for them.%@NL@%
%@AB@%        *%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        if ((pthr->pptl == NULL) || (pthr->flMiscAttrs & LFA_CPTMAX))%@NL@%
        {%@NL@%
            if (pthr->pptl != NULL)%@NL@%
                DosFreeSeg(*(((PUSHORT)&pthr->pptl)+1));%@NL@%
            if (DosAllocSeg(pthr->cptMax * sizeof(POINTL),%@NL@%
                           ((PUSHORT)&pthr->pptl)+1, 0))%@NL@%
                goto lfthread_exit;%@NL@%
        }%@NL@%
%@NL@%
        if ((pthr->pmatlf == NULL) || (pthr->flMiscAttrs & LFA_POLYGONSIDES))%@NL@%
        {%@NL@%
            if (pthr->pmatlf != NULL)%@NL@%
                DosFreeSeg(*(((PUSHORT)&pthr->pmatlf)+1));%@NL@%
            if (DosAllocSeg(pthr->usPolygonSides * sizeof(MATRIXLF),%@NL@%
                           ((PUSHORT)&pthr->pmatlf)+1, 0))%@NL@%
                goto lfthread_exit;%@NL@%
            fModelXformsValid = FALSE;%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *%@NL@%
%@AB@%        *  See if we can cache the whole lot of points.  This depends%@NL@%
%@AB@%        *  on the fractal, the size of the point cache, and the level%@NL@%
%@AB@%        *  of recursion.  Note that we must execute this code the first%@NL@%
%@AB@%        *  time through, or fCacheable will be undefined.  We're sure%@NL@%
%@AB@%        *  to come here, though, because threads are initialized with%@NL@%
%@AB@%        *  all attributes "changed".%@NL@%
%@AB@%        *%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        if (pthr->flMiscAttrs & (LFA_CPTMAX | LFA_RECURSION | LFA_CURXFORM))%@NL@%
        {%@NL@%
            if (pthr->flMiscAttrs & LFA_CURXFORM)%@NL@%
            {%@NL@%
                PLINEFRAC p;%@NL@%
%@NL@%
                cFracSegs = 0;%@NL@%
                pXform = aXform[pthr->usCurXform - IDM_SHARKTOOTH].pXform;%@NL@%
                p = pXform;%@NL@%
                while (p != EOLIST)%@NL@%
                {%@NL@%
                    ++cFracSegs;%@NL@%
                    p = p->next;%@NL@%
                }%@NL@%
            }%@NL@%
%@NL@%
            cptReq = (ULONG) exp((double)pthr->usRecursion *%@NL@%
                                 log((double)cFracSegs));%@NL@%
%@NL@%
            if ((ULONG)pthr->cptMax > cptReq)%@NL@%
                fCacheable = TRUE;%@NL@%
            else%@NL@%
                fCacheable = FALSE;%@NL@%
%@NL@%
            fCached = FALSE;%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *%@NL@%
%@AB@%        *  If the model transforms are invalid, then recompute them.%@NL@%
%@AB@%        *  Check first to see if any attributes have changed that%@NL@%
%@AB@%        *  would invalidate the transforms.%@NL@%
%@AB@%        *%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        if (fModelXformsValid)%@NL@%
            if (pthr->flMiscAttrs & (LFA_ROTATION | LFA_POLYGONSIDES |%@NL@%
                   LFA_XSCALE | LFA_YSCALE | LFA_XOFF | LFA_YOFF))%@NL@%
                fModelXformsValid = FALSE;%@NL@%
%@NL@%
        if (!fModelXformsValid)%@NL@%
        {%@NL@%
            LfComputeModelXforms(pthr);%@NL@%
            fModelXformsValid = TRUE;%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *%@NL@%
%@AB@%        *  Clear the change-of-attributes flags that have been examined%@NL@%
%@AB@%        *  by the time we get here.%@NL@%
%@AB@%        *%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        pthr->flMiscAttrs &=%@NL@%
          ~(%@NL@%
             LFA_CPTMAX    | LFA_RECURSION | LFA_POLYGONSIDES | LFA_CURXFORM  |%@NL@%
             LFA_XSCALE    | LFA_YSCALE    | LFA_XOFF              | LFA_YOFF      |%@NL@%
             LFA_ROTATION%@NL@%
           );%@NL@%
%@NL@%
%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *%@NL@%
%@AB@%        *  Clear the surface if fClearOnRedraw is enabled.%@NL@%
%@AB@%        *  If the points are cached, then redraw straight from the cache.%@NL@%
%@AB@%        *  Otherwise, anchor the fractal at the left endpoint of the%@NL@%
%@AB@%        *  unit interval, then draw it to the specified depth of recursion.%@NL@%
%@AB@%        *  If we are able to cache all the points, then nothing will have%@NL@%
%@AB@%        *  been drawn when LineFractal returns, so draw the fractal without%@NL@%
%@AB@%        *  flushing the cache.        If we were not able to cache all the%@NL@%
%@AB@%        *  points, and the buffer is not empty, flush the last batch.%@NL@%
%@AB@%        *%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        if (pthr->fClearOnRedraw)%@NL@%
            LfClearRect(pthr, NULL);%@NL@%
%@NL@%
        if (fCached)%@NL@%
            LfDraw(pthr, FALSE);%@NL@%
        else%@NL@%
        {%@NL@%
            pthr->x    =  0.0;%@NL@%
            pthr->y    =  0.0;%@NL@%
%@NL@%
            pthr->cptl = 0L;%@NL@%
            LfAddPoint(pthr);%@NL@%
%@NL@%
            LineFractal(pthr, pthr->usRecursion, (double)pthr->cxWCS,%@NL@%
                        0.0, FALSE, pXform);%@NL@%
%@NL@%
            if (!pthr->fInterrupted)%@NL@%
            {%@NL@%
                if (fCacheable)%@NL@%
                {%@NL@%
                    LfDraw(pthr, FALSE);%@NL@%
                    fCached = TRUE;%@NL@%
                }%@NL@%
                else%@NL@%
                {%@NL@%
                    fCached = FALSE;%@NL@%
                    if (pthr->cptl > 1L)%@NL@%
                        LfDraw(pthr, TRUE);%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/****************************************************************%@NL@%
%@AB@%    *%@NL@%
%@AB@%    *  Common exit point for thread.  Free up memory allocated%@NL@%
%@AB@%    *  by this thread.%@NL@%
%@AB@%    *%@NL@%
%@AB@%    ****************************************************************/%@AE@%%@NL@%
%@NL@%
lfthread_exit:%@NL@%
%@NL@%
    if (pthr->pmatlf != NULL)%@NL@%
        DosFreeSeg(*(((PUSHORT)&pthr->pmatlf)+1));%@NL@%
    if (pthr->pptl != NULL)%@NL@%
        DosFreeSeg(*(((PUSHORT)&pthr->pptl)+1));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfUpdateAttrs%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Update any changed attributes from the global attributes.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfUpdateAttrs(pthr)%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
%@NL@%
    DosEnterCritSec();%@NL@%
    if (pthr->fUpdateAttrs)%@NL@%
    {%@NL@%
        if (global.flLineAttrs         & LFA_LINEALL)%@NL@%
        {%@NL@%
            pthr->lb                 = global.lb;%@NL@%
            pthr->flLineAttrs        |= global.flLineAttrs;%@NL@%
            global.flLineAttrs         = 0L;%@NL@%
        }%@NL@%
        if (global.flMarkerAttrs & LFA_MARKALL)%@NL@%
        {%@NL@%
            pthr->mb                 = global.mb;%@NL@%
            pthr->flMarkerAttrs |= global.flMarkerAttrs;%@NL@%
            global.flMarkerAttrs = 0L;%@NL@%
        }%@NL@%
        if (global.flAreaAttrs         & LFA_AREAALL)%@NL@%
        {%@NL@%
            pthr->ab                 = global.ab;%@NL@%
            pthr->flAreaAttrs        |= global.flAreaAttrs;%@NL@%
            global.flAreaAttrs         = 0L;%@NL@%
        }%@NL@%
        if (global.flImageAttrs  & LFA_IMAGEALL)%@NL@%
        {%@NL@%
            pthr->ib                 = global.ib;%@NL@%
            pthr->flImageAttrs        |= global.flImageAttrs;%@NL@%
            global.flImageAttrs  = 0L;%@NL@%
        }%@NL@%
        if (global.flMiscAttrs         & LFA_MISCALL)%@NL@%
        {%@NL@%
            if (global.flMiscAttrs & LFA_CURPRIM)%@NL@%
                pthr->usCurPrim      = global.usCurPrim;%@NL@%
            if (global.flMiscAttrs & LFA_CURXFORM)%@NL@%
                pthr->usCurXform     = global.usCurXform;%@NL@%
            if (global.flMiscAttrs & LFA_RECURSION)%@NL@%
                pthr->usRecursion    = global.usRecursion;%@NL@%
            if (global.flMiscAttrs & LFA_POLYGONSIDES)%@NL@%
                pthr->usPolygonSides = global.usPolygonSides;%@NL@%
            if (global.flMiscAttrs & LFA_CPTMAX)%@NL@%
                pthr->cptMax             = global.cptMax;%@NL@%
            if (global.flMiscAttrs & LFA_XOFF)%@NL@%
                pthr->dblXOff             = global.dblXOff;%@NL@%
            if (global.flMiscAttrs & LFA_YOFF)%@NL@%
                pthr->dblYOff             = global.dblYOff;%@NL@%
            if (global.flMiscAttrs & LFA_XSCALE)%@NL@%
                pthr->dblXScale      = global.dblXScale;%@NL@%
            if (global.flMiscAttrs & LFA_YSCALE)%@NL@%
                pthr->dblYScale      = global.dblYScale;%@NL@%
            if (global.flMiscAttrs & LFA_ROTATION)%@NL@%
                pthr->dblRotation    = global.dblRotation;%@NL@%
            if (global.flMiscAttrs & LFA_CXWCS)%@NL@%
                pthr->cxWCS             = global.cxWCS;%@NL@%
            if (global.flMiscAttrs & LFA_CYWCS)%@NL@%
                pthr->cyWCS             = global.cyWCS;%@NL@%
            pthr->flMiscAttrs  |= global.flMiscAttrs;%@NL@%
            global.flMiscAttrs        = 0L;%@NL@%
        }%@NL@%
%@NL@%
        pthr->fUpdateAttrs  = FALSE;%@NL@%
        global.fUpdateAttrs = FALSE;%@NL@%
%@NL@%
    }%@NL@%
    DosExitCritSec();%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Take care of the attribute bundles now. The miscellaneous attributes%@NL@%
%@AB@%     * require more processing, so don't clear their flags yet.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    if (pthr->flLineAttrs & LFA_LINEALL)%@NL@%
    {%@NL@%
        GpiSetAttrs(pthr->hps, PRIM_LINE, pthr->flLineAttrs, 0L, &pthr->lb);%@NL@%
        pthr->flLineAttrs = 0L;%@NL@%
    }%@NL@%
    if (pthr->flMarkerAttrs & LFA_MARKALL)%@NL@%
    {%@NL@%
        GpiSetAttrs(pthr->hps, PRIM_MARKER, pthr->flMarkerAttrs, 0L, &pthr->mb);%@NL@%
        pthr->flMarkerAttrs = 0L;%@NL@%
    }%@NL@%
    if (pthr->flAreaAttrs & LFA_AREAALL)%@NL@%
    {%@NL@%
        GpiSetAttrs(pthr->hps, PRIM_AREA, pthr->flAreaAttrs, 0L, &pthr->ab);%@NL@%
        pthr->flAreaAttrs = 0L;%@NL@%
    }%@NL@%
    if (pthr->flImageAttrs)%@NL@%
    {%@NL@%
        GpiSetAttrs(pthr->hps, PRIM_IMAGE, pthr->flImageAttrs, 0L, &pthr->ib);%@NL@%
        pthr->flImageAttrs = 0L;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfComputeModelXforms%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Compute the model transform matrices necessary to draw the fractal%@NL@%
%@AB@%*   on each side of the polygonal frame.  The rotation, scaling, and%@NL@%
%@AB@%*   translation are all rolled into one matrix for simplicity.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfComputeModelXforms(pthr)%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
    double dblXScale, dblYScale;%@NL@%
    double dblXOff, dblYOff;%@NL@%
    double dblTheta;%@NL@%
    double dblRotation, dblSinRotation, dblCosRotation;%@NL@%
    double dblSideLen, dblAngleDecr;%@NL@%
    double dblXExtDims, dblYExtDims;%@NL@%
    double dblHalfXDims, dblHalfYDims;%@NL@%
    double dx, dy;%@NL@%
    PMATRIXLF pmatlf;%@NL@%
    USHORT i;%@NL@%
%@NL@%
%@NL@%
    dblAngleDecr = TWO_PI / (double)pthr->usPolygonSides;%@NL@%
%@NL@%
    if (pthr->usPolygonSides == 1)%@NL@%
    {%@NL@%
        dblSideLen   = 1.0;%@NL@%
        dblRotation  = (double) pthr->dblRotation;%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
        %@AB@%/* C 5.1 incorrectly compiles sin(temp_dbl2) in large%@NL@%
%@AB@%         * model, where temp_dbl2 is expanded to eliminate all%@NL@%
%@AB@%         * temporary variables, therefore I DO use the temp vars.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        double temp_dbl1, temp_dbl2;%@NL@%
%@NL@%
        temp_dbl1    = (double)pthr->usPolygonSides;%@NL@%
        temp_dbl2    = PI / temp_dbl1;%@NL@%
        dblSideLen   = sin(temp_dbl2);%@NL@%
        dblRotation  = PI - dblAngleDecr;%@NL@%
        dblRotation  = 0.5 * dblRotation + pthr->dblRotation;%@NL@%
    }%@NL@%
%@NL@%
    {%@NL@%
        double temp_dbl1, temp_dbl2;%@NL@%
%@NL@%
        temp_dbl1  = (double) pthr->rcl.xRight;%@NL@%
        temp_dbl2  = (double) pthr->cxWCS;%@NL@%
        dblXScale  = temp_dbl1 / temp_dbl2;%@NL@%
        dblXScale *= pthr->dblXScale * dblSideLen;%@NL@%
%@NL@%
        temp_dbl1  = (double) pthr->rcl.yTop;%@NL@%
        temp_dbl2  = (double) pthr->cyWCS;%@NL@%
        dblYScale  = temp_dbl1 / temp_dbl2;%@NL@%
        dblYScale *= pthr->dblYScale * dblSideLen;%@NL@%
    }%@NL@%
%@NL@%
    dblXExtDims  = (double) pthr->rcl.xRight * pthr->dblXScale;%@NL@%
    dblYExtDims  = (double) pthr->rcl.yTop   * pthr->dblYScale;%@NL@%
    dblHalfXDims = 0.5 * dblXExtDims;%@NL@%
    dblHalfYDims = 0.5 * dblYExtDims;%@NL@%
    dblXOff         = (double) pthr->rcl.xRight * pthr->dblXOff + dblHalfXDims;%@NL@%
    dblYOff         = (double) pthr->rcl.yTop   * pthr->dblYOff + dblHalfYDims;%@NL@%
%@NL@%
    dblTheta         = PI + pthr->dblRotation;%@NL@%
%@NL@%
    for (i = 0; i < pthr->usPolygonSides; ++i)%@NL@%
    {%@NL@%
        dblCosRotation = cos(dblRotation);%@NL@%
        dblSinRotation = sin(dblRotation);%@NL@%
%@NL@%
        dx = dblHalfXDims * cos(dblTheta);%@NL@%
        dy = dblHalfYDims * sin(dblTheta);%@NL@%
%@NL@%
        %@AB@%/* 0.000015 = about 1/65536 */%@AE@%%@NL@%
%@NL@%
        pmatlf = pthr->pmatlf + i;%@NL@%
        pmatlf->fxM11 = (FIXED)(( dblCosRotation * dblXScale + 0.000015) * (double) 0x10000L);%@NL@%
        pmatlf->fxM12 = (FIXED)(( dblSinRotation * dblYScale + 0.000015) * (double) 0x10000L);%@NL@%
        pmatlf-> lM13 = 0L;%@NL@%
        pmatlf->fxM21 = (FIXED)((-dblSinRotation * dblXScale + 0.000015) * (double) 0x10000L);%@NL@%
        pmatlf->fxM22 = (FIXED)(( dblCosRotation * dblYScale + 0.000015) * (double) 0x10000L);%@NL@%
        pmatlf-> lM23 = 0L;%@NL@%
        pmatlf-> lM31 = (LONG) (dblXOff + dx + 0.5);%@NL@%
        pmatlf-> lM32 = (LONG) (dblYOff + dy + 0.5);%@NL@%
        pmatlf-> lM33 = 1L;%@NL@%
%@NL@%
        dblRotation -= dblAngleDecr;%@NL@%
        dblTheta    -= dblAngleDecr;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LineFractal%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Draw fractal with the given similarity transform.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   The general idea is to define a transformation to apply to the%@NL@%
%@AB@%*   unit line segment, to get a new polyline.  This same transformation%@NL@%
%@AB@%*   is then applied to each line segment of the new polyline.  The number%@NL@%
%@AB@%*   of successive applications of the similarity transform is set by the%@NL@%
%@AB@%*   user.  It's known as the level of recursion of the fractal.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Since this is where the point accumulation process will usually%@NL@%
%@AB@%*   be, it recognizes the flag        fInterrupted  to allow the current%@NL@%
%@AB@%*   work to be abandoned.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LineFractal(pthr, depth, len, ang, flip, xform)%@NL@%
PTHR pthr;%@NL@%
int depth;%@NL@%
double len;%@NL@%
double ang;%@NL@%
BOOL flip;%@NL@%
PLINEFRAC xform;%@NL@%
{%@NL@%
    double newlen;%@NL@%
    PLINEFRAC newseg;%@NL@%
%@NL@%
%@NL@%
    if (pthr->fInterrupted)%@NL@%
        return;%@NL@%
%@NL@%
    if (depth)%@NL@%
    {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         *  We have not reached the maximum depth of recursion yet,%@NL@%
%@AB@%         *  so apply the similarity transform to the current line%@NL@%
%@AB@%         *  segment.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        --depth;%@NL@%
        newseg = xform;%@NL@%
        do%@NL@%
        {%@NL@%
            newlen  = len * newseg->length;%@NL@%
            ang    += newseg->angle * (flip ? -1 : 1);%@NL@%
            LineFractal(pthr, depth, newlen, ang, (flip ^ newseg->flip), xform);%@NL@%
        } while ((newseg = newseg->next) != EOLIST);%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         *  We have reached the maximum depth of recursion, so%@NL@%
%@AB@%         *  draw a line segment.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        pthr->x += len * cos(ang);%@NL@%
        pthr->y += len * sin(ang);%@NL@%
        LfAddPoint(pthr);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfAddPoint%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Applies the global coordinate transform to the point (x, y), then%@NL@%
%@AB@%*   stuffs it into the global PolyLine point array, and increments the%@NL@%
%@AB@%*   count of points in the array.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfAddPoint(pthr)%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
    if (pthr->cptl == (ULONG)pthr->cptMax)%@NL@%
        LfDraw(pthr, TRUE);%@NL@%
%@NL@%
    if (pthr->cptl < (ULONG)pthr->cptMax)%@NL@%
    {%@NL@%
        (pthr->pptl + pthr->cptl)->x =%@NL@%
            (int)(pthr->x + 0.5);%@NL@%
        (pthr->pptl + pthr->cptl)->y =%@NL@%
            (int)(pthr->y + 0.5);%@NL@%
        ++pthr->cptl;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfDraw%@NL@%
%@AB@%*%@NL@%
%@AB@%*   For each segment of the frame, set the model transform and draw the%@NL@%
%@AB@%*   cache of points in the current primitive.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Invalidate the client rectangle of the main window in case this is%@NL@%
%@AB@%*   the top thread, to cause our latest bitmap to be copied there.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfDraw(pthr, fFlush)%@NL@%
PTHR pthr;%@NL@%
BOOL fFlush;%@NL@%
{%@NL@%
    USHORT i;%@NL@%
    BOOL myFlush;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* If this is a direct DC, but is not the top thread, then%@NL@%
%@AB@%     * don't draw anything.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pthr->dcType == IDM_DCDIRECT)%@NL@%
        if (!LfIsThreadTop(pthr))%@NL@%
        {%@NL@%
            if (fFlush)%@NL@%
                pthr->cptl = 0L;%@NL@%
            return;%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
    if (pthr->fCollectBounds)%@NL@%
        GpiResetBoundaryData(pthr->hps);%@NL@%
%@NL@%
%@NL@%
    myFlush = FALSE;%@NL@%
%@NL@%
    for (i = 0; i < pthr->usPolygonSides; ++i)%@NL@%
    {%@NL@%
        if (pthr->fInterrupted)%@NL@%
            return;%@NL@%
%@NL@%
        %@AB@%/* set model transform */%@AE@%%@NL@%
        GpiSetModelTransformMatrix(pthr->hps, 9L, pthr->pmatlf+i, TRANSFORM_REPLACE);%@NL@%
%@NL@%
        %@AB@%/* we only really flush the last time we use the cache */%@AE@%%@NL@%
        if (i == pthr->usPolygonSides - 1)%@NL@%
            myFlush = fFlush;%@NL@%
%@NL@%
        switch ( pthr->usCurPrim )%@NL@%
        {%@NL@%
        case IDM_POLYLINE:%@NL@%
            LfDrawPolyLine(pthr, myFlush);%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_POLYFILLET:%@NL@%
            LfDrawPolyFillet(pthr, myFlush);%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_POLYSPLINE:%@NL@%
            LfDrawPolySpline(pthr, myFlush);%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_PEANO:%@NL@%
            LfDrawPolyPeano(pthr, myFlush);%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_POLYMARKER:%@NL@%
            LfDrawPolyMarker(pthr, myFlush);%@NL@%
            break;%@NL@%
        }%@NL@%
%@NL@%
        if (pthr->dcType != IDM_DCDIRECT)%@NL@%
            if (LfIsThreadTop(pthr))%@NL@%
            {%@NL@%
                if (pthr->fCollectBounds)%@NL@%
                {%@NL@%
                    GpiQueryBoundaryData(pthr->hps, &pthr->rclBounds);%@NL@%
                    ++(pthr->rclBounds).xRight;%@NL@%
                    ++(pthr->rclBounds).yTop;%@NL@%
                    WinInvalidateRect(global.hwnd, &pthr->rclBounds, FALSE);%@NL@%
                }%@NL@%
                else%@NL@%
                    WinInvalidateRect(global.hwnd, &pthr->rcl, FALSE);%@NL@%
            }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfDrawPolyLine%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Draw a polyline using the thread's point buffer.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfDrawPolyLine(pthr, fFlush)%@NL@%
PTHR pthr;%@NL@%
BOOL fFlush;%@NL@%
{%@NL@%
    %@AB@%/* After drawing the line, save the last point to set the%@NL@%
%@AB@%       current position before the next call. */%@AE@%%@NL@%
%@NL@%
    GpiSetCurrentPosition( pthr->hps, pthr->pptl );%@NL@%
    GpiPolyLine( pthr->hps, pthr->cptl-1L, pthr->pptl+1 );%@NL@%
    if (fFlush)%@NL@%
    {%@NL@%
        *pthr->pptl = *(pthr->pptl + pthr->cptl-1);%@NL@%
        pthr->cptl = 1L;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfDrawPolyFillet%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Draw a polyfillet using the thread's point buffer.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfDrawPolyFillet(pthr, fFlush)%@NL@%
PTHR pthr;%@NL@%
BOOL fFlush;%@NL@%
{%@NL@%
    %@AB@%/* After drawing the curve, save the last point to set the%@NL@%
%@AB@%       current position before the next call. */%@AE@%%@NL@%
%@NL@%
    if (pthr->cptl > 2)%@NL@%
    {%@NL@%
        GpiSetCurrentPosition( pthr->hps, pthr->pptl );%@NL@%
        GpiPolyFillet( pthr->hps, pthr->cptl-1L, pthr->pptl+1 );%@NL@%
        if (fFlush)%@NL@%
        {%@NL@%
            *pthr->pptl = *(pthr->pptl + pthr->cptl-1);%@NL@%
            pthr->cptl = 1L;%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfDrawPolySpline%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Draw a polyspline using the thread's point buffer.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfDrawPolySpline(pthr, fFlush)%@NL@%
PTHR pthr;%@NL@%
BOOL fFlush;%@NL@%
{%@NL@%
    USHORT i;                %@AB@%/* loop counter */%@AE@%%@NL@%
    USHORT cptSlack;        %@AB@%/* # points in pptl not usable by PolySpline */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* GpiPolySpline expects the number of points to be a%@NL@%
%@AB@%       multiple of 3.  If we have a non-multiple of three,%@NL@%
%@AB@%       (excluding the first point, which we've used to set%@NL@%
%@AB@%       the current position), only pass the largest multiple%@NL@%
%@AB@%       of three, saving the rest for the next go-round. */%@AE@%%@NL@%
%@NL@%
    cptSlack = (int)((pthr->cptl-1L) % 3) + 1;%@NL@%
    GpiSetCurrentPosition( pthr->hps, pthr->pptl );%@NL@%
    GpiPolySpline( pthr->hps, pthr->cptl-cptSlack,%@NL@%
                   pthr->pptl+1 );%@NL@%
    if (fFlush)%@NL@%
    {%@NL@%
        for (i = 0; i < cptSlack; ++i)%@NL@%
            *(pthr->pptl + i) = *(pthr->pptl + pthr->cptl-cptSlack+i);%@NL@%
        pthr->cptl = cptSlack;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfDrawPolyPeano%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Draw a chain of Peano primitives using the thread's point buffer.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfDrawPolyPeano(pthr, fFlush)%@NL@%
PTHR pthr;%@NL@%
BOOL fFlush;%@NL@%
{%@NL@%
    LONG a, b, c, d;        %@AB@%/* temporary vars for Peano curvelet calculations */%@AE@%%@NL@%
    int cptPeano;        %@AB@%/* current point in pptl in use by Peano curve */%@AE@%%@NL@%
    POINTL ptPeano[2];        %@AB@%/* Peano curvelet array to pass to PolyLine */%@AE@%%@NL@%
%@NL@%
    for (cptPeano = 0; cptPeano < (int)(pthr->cptl-1L); ++cptPeano)%@NL@%
    {%@NL@%
        ptPeano[0] = *(pthr->pptl + cptPeano);%@NL@%
        ptPeano[1] = *(pthr->pptl + cptPeano+1);%@NL@%
        a = (pthr->pptl + cptPeano+1)->x - (pthr->pptl + cptPeano)->x;%@NL@%
        b = (pthr->pptl + cptPeano+1)->y - (pthr->pptl + cptPeano)->y;%@NL@%
        c = (a + b)/2;%@NL@%
        d = (a - b)/2;%@NL@%
        if (labs(a) > labs(b))%@NL@%
        {%@NL@%
            ptPeano[0].x +=  d;%@NL@%
            ptPeano[0].y +=  c;%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
            ptPeano[0].x +=  c;%@NL@%
            ptPeano[0].y += -d;%@NL@%
        }%@NL@%
%@NL@%
        GpiSetCurrentPosition( pthr->hps, pthr->pptl + cptPeano);%@NL@%
        GpiPolyLine( pthr->hps, 2L, (PPOINTL)ptPeano);%@NL@%
    }%@NL@%
    if (fFlush)%@NL@%
    {%@NL@%
        *pthr->pptl = *(pthr->pptl + pthr->cptl-1);%@NL@%
        pthr->cptl = 1L;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfDrawPolyMarker%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Draw a list of markers using the thread's point buffer.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfDrawPolyMarker(pthr, fFlush)%@NL@%
PTHR pthr;%@NL@%
BOOL fFlush;%@NL@%
{%@NL@%
    %@AB@%/* I want to draw markers at every point in the array, but%@NL@%
%@AB@%       GpiPolyMarker won't draw at the last point!  So, GpiMarker%@NL@%
%@AB@%       does the job instead. */%@AE@%%@NL@%
%@NL@%
    GpiSetCurrentPosition( pthr->hps, pthr->pptl + pthr->cptl-1);%@NL@%
    GpiPolyMarker( pthr->hps, pthr->cptl, pthr->pptl );%@NL@%
    GpiMarker         ( pthr->hps,                  pthr->pptl + pthr->cptl-1 );%@NL@%
%@NL@%
    if (fFlush)%@NL@%
        pthr->cptl = 0L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfClearRect%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Set the area attributes if needed and fill the bitmap with them.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfClearRect(pthr, prcl)%@NL@%
PTHR pthr;%@NL@%
PRECTL prcl;%@NL@%
{%@NL@%
    PRECTL prclT;%@NL@%
%@NL@%
    if (pthr->hps)%@NL@%
    {%@NL@%
        if (prcl)%@NL@%
            prclT = prcl;%@NL@%
        else%@NL@%
            prclT = &pthr->rcl;%@NL@%
%@NL@%
        if (pthr->dcType == IDM_DCDIRECT)%@NL@%
        {%@NL@%
            %@AB@%/* If direct DC, only blt if top thread. */%@AE@%%@NL@%
            if (LfIsThreadTop(pthr))%@NL@%
                GpiBitBlt(pthr->hps, NULL, 2L, (PPOINTL)prclT, ROP_PATCOPY, 0L);%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
            GpiBitBlt(pthr->hps, NULL, 2L, (PPOINTL)prclT, ROP_PATCOPY, 0L);%@NL@%
            if (LfIsThreadTop(pthr))%@NL@%
                WinInvalidateRect(global.hwnd, prclT, FALSE);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LFFILE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\LINEFRAC\LFFILE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   lffile.c -- File handling subroutines for LineFrac.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%INCL_BITMAPFILEFORMAT %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AI@%#undef %@AE@% RC_INVOKED %@NL@%
%@AI@%#include %@AE@%"opendlg.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GLOBALS %@NL@%
%@AI@%#define %@AE@%INCL_THREADS %@NL@%
%@AI@%#include %@AE@%"linefrac.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_LFFILE %@NL@%
%@AI@%#define %@AE@%INCL_LFPS %@NL@%
%@AI@%#define %@AE@%INCL_LFUTIL %@NL@%
%@AI@%#include %@AE@%"lffuncs.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * this is the bitmap resource file format structure%@NL@%
%@AB@% */%@AE@%%@NL@%
typedef struct {%@NL@%
    USHORT    wType;%@NL@%
    ULONG     dwSize;%@NL@%
    int       xHotspot;%@NL@%
    int       yHotspot;%@NL@%
    ULONG     dwBitsOffset;%@NL@%
    USHORT    bmWidth;       %@AB@%/* from here this is a BitmapInfo table */%@AE@%%@NL@%
    USHORT    bmHeight;%@NL@%
    USHORT    bmPlanes;%@NL@%
    USHORT    bmBitcount;%@NL@%
} RCBITMAP;%@NL@%
typedef RCBITMAP FAR *PRCBITMAP;%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Global Variables%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
extern GLOBALDATA global;%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfReadFile%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Calls the OpenDlg function to ask the user what file name to%@NL@%
%@AB@%*   read from.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfReadFile(hwnd, pthr)%@NL@%
HWND hwnd;%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
    HFILE hFile;%@NL@%
    DLF dlf;%@NL@%
%@NL@%
    dlf.rgbAction        = DLG_OPENDLG;%@NL@%
    dlf.rgbFlags        = ATTRDIRLIST;%@NL@%
    dlf.phFile                = &hFile;%@NL@%
    dlf.pszExt                = (PSZ)"\\*.bmp";%@NL@%
    dlf.pszAppName        = "LineFrac";%@NL@%
    dlf.pszTitle        = "Load Bitmap";%@NL@%
    dlf.pszInstructions = NULL;%@NL@%
    dlf.szFileName[0]        = '\0';%@NL@%
    dlf.szOpenFile[0]        = '\0';%@NL@%
%@NL@%
    switch (DlgFile(hwnd,&dlf))%@NL@%
    {%@NL@%
    case TDF_ERRMEM:%@NL@%
    case TDF_INVALID:%@NL@%
        MyMessageBox(hwnd, "Error reading file.");%@NL@%
        break;%@NL@%
%@NL@%
    case TDF_NOOPEN:%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        if (!LfReadBMP(pthr, &dlf))%@NL@%
            MyMessageBox(hwnd, "Error reading file.\nIs AutoResize enabled?");%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfReadBMP%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Read a bitmap in from a BMP format file.  Prepare the DC for the%@NL@%
%@AB@%*   given thread to accept it.        The user can have the DC resized to%@NL@%
%@AB@%*   fit exactly the bitmap, or fit the bits in as best as we can.%@NL@%
%@AB@%*   If we're not resizing and the bitmap is larger than the thread's%@NL@%
%@AB@%*   DC, then load the bits flush with the lower left.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Both old-style (PRCBITMAP) and new-style (PBITMAPFILEHEADER)%@NL@%
%@AB@%*   bitmaps can be read.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Free up memory and close the file before leaving.  The file%@NL@%
%@AB@%*   will have been opened by the time this function is called,%@NL@%
%@AB@%*   and the file handle will be in the *pdlf structure.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfReadBMP(pthr, pdlf)%@NL@%
PTHR pthr;%@NL@%
PDLF pdlf;                %@AB@%/* File information filled by DlgFile. */%@AE@%%@NL@%
{%@NL@%
    HFILE hfile;%@NL@%
    ULONG cScans;%@NL@%
    ULONG ulSize;         %@AB@%/* Number of bytes occupied by bitmap bits.             */%@AE@%%@NL@%
    USHORT cSegs;         %@AB@%/* Number of 64K segments in ulSize.                     */%@AE@%%@NL@%
    USHORT cbExtra;         %@AB@%/* Bytes in last segment of ulSize.                     */%@AE@%%@NL@%
    SEL sel;                 %@AB@%/* Base selector to file data.                      */%@AE@%%@NL@%
    USHORT hugeshift;         %@AB@%/* Segment index shift value.                             */%@AE@%%@NL@%
    USHORT cbRead1;         %@AB@%/* Number of bytes to read first call to DosRead    */%@AE@%%@NL@%
    USHORT cbRead2;         %@AB@%/* Number of bytes to read second call to DosRead   */%@AE@%%@NL@%
    USHORT cbRead;         %@AB@%/* Number of bytes read by DosRead.                     */%@AE@%%@NL@%
    BOOL fRet = FALSE;         %@AB@%/* Function return code.                             */%@AE@%%@NL@%
    USHORT i;                 %@AB@%/* Generic loop index.                              */%@AE@%%@NL@%
    FILESTATUS fsts;%@NL@%
    PBITMAPFILEHEADER pbfh;%@NL@%
    PRCBITMAP  rb;%@NL@%
    PBYTE pImage;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Find out how big the file is so we can read the whole thing in.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    hfile = *(pdlf->phFile);%@NL@%
    if( DosQFileInfo( hfile, 1, &fsts, sizeof(FILESTATUS)) != 0)%@NL@%
        goto lfread_error_close_file;%@NL@%
%@NL@%
    ulSize  = fsts.cbFile;%@NL@%
    cSegs   = (USHORT)(ulSize/0x10000L);%@NL@%
    cbExtra = (USHORT)(ulSize%0x10000L);%@NL@%
    if (DosAllocHuge(cSegs, cbExtra, (PSEL)&sel, 0, 0))%@NL@%
        goto lfread_error_close_file;%@NL@%
    if (DosGetHugeShift(&hugeshift))%@NL@%
        goto lfread_error_free_bits;%@NL@%
%@NL@%
    pImage = (PBYTE)MAKEP(sel, 0);%@NL@%
    rb           = (PRCBITMAP)pImage;%@NL@%
    pbfh   = (PBITMAPFILEHEADER)pImage;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Read the bits in from the file. The DosRead function allows a%@NL@%
%@AB@%    * maximum of 64K-1 bytes read at a time.  We get around this%@NL@%
%@AB@%    * by reading two 32K chunks for each 64K segment, and reading the%@NL@%
%@AB@%    * last segment in one piece.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    for (i = 0; i <= cSegs; ++i)%@NL@%
    {%@NL@%
        if (i < cSegs)%@NL@%
        {%@NL@%
            %@AB@%/* This segment is 64K bytes long, so split it up. */%@AE@%%@NL@%
            cbRead1 = 0x8000;%@NL@%
            cbRead2 = 0x8000;%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
            %@AB@%/* This segment is less than 64K bytes long, so read it all. */%@AE@%%@NL@%
            cbRead1 = cbExtra;%@NL@%
            cbRead2 = 0;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* There's a possibility that cbExtra will be 0, so check%@NL@%
%@AB@%         * to avoid an unnecessary system call.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (cbRead1 > 0)%@NL@%
        {%@NL@%
            if (DosRead( hfile%@NL@%
                       , (PVOID)MAKEP(sel+(i<<hugeshift), 0)%@NL@%
                       , cbRead1%@NL@%
                       , &cbRead))%@NL@%
                goto lfread_error_free_bits;%@NL@%
            if (cbRead1 != cbRead)%@NL@%
                goto lfread_error_free_bits;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* This will always be skipped on the last partial segment. */%@AE@%%@NL@%
        if (cbRead2 > 0)%@NL@%
        {%@NL@%
            if (DosRead( hfile%@NL@%
                       , (PVOID)MAKEP(sel+(i<<hugeshift), cbRead1)%@NL@%
                       , cbRead2%@NL@%
                       , &cbRead))%@NL@%
                goto lfread_error_free_bits;%@NL@%
            if (cbRead2 != cbRead)%@NL@%
                goto lfread_error_free_bits;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * At this point we have the bitmap completely in memory.  Now we%@NL@%
%@AB@%    * look at how the user wants them set into the thread's PS.  If%@NL@%
%@AB@%    * the thread has fAutoResizePS set, then make the PS fit the size%@NL@%
%@AB@%    * of the bitmap (the easy case).  If the flag is not set, then%@NL@%
%@AB@%    * figure out how to place it.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    if (pthr->fAutoSizePS)%@NL@%
    {%@NL@%
        if (pbfh->bmp.cbFix != sizeof(BITMAPINFOHEADER))%@NL@%
        {%@NL@%
            global.bm.cx        = rb->bmWidth;%@NL@%
            global.bm.cy        = rb->bmHeight;%@NL@%
            global.bm.cPlanes        = rb->bmPlanes;%@NL@%
            global.bm.cBitCount = rb->bmBitcount;%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
            global.bm.cx        = pbfh->bmp.cx;%@NL@%
            global.bm.cy        = pbfh->bmp.cy;%@NL@%
            global.bm.cPlanes        = pbfh->bmp.cPlanes;%@NL@%
            global.bm.cBitCount = pbfh->bmp.cBitCount;%@NL@%
        }%@NL@%
%@NL@%
        LfResizePS(pthr);%@NL@%
    }%@NL@%
    else%@NL@%
        goto lfread_error_free_bits;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Tell GPI to put the bits into the thread's PS. The function returns%@NL@%
%@AB@%    * the number of scan lines of the bitmap that were copied.        We want%@NL@%
%@AB@%    * all of them at once.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    if (pbfh->bmp.cbFix != sizeof(BITMAPINFOHEADER))%@NL@%
    {%@NL@%
        pImage += rb->dwBitsOffset;%@NL@%
        rb->dwBitsOffset = sizeof(BITMAPINFOHEADER);%@NL@%
        cScans = GpiSetBitmapBits( pthr->hps%@NL@%
                                 , 0L%@NL@%
                                 , (LONG)rb->bmHeight%@NL@%
                                 , pImage%@NL@%
                                 , (PBITMAPINFO)&(rb->dwBitsOffset));%@NL@%
        if (cScans != (ULONG)rb->bmHeight)  %@AB@%/* compare with original number of scans */%@AE@%%@NL@%
            goto lfread_error_free_bits;%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
        cScans = GpiSetBitmapBits( pthr->hps%@NL@%
                                 , 0L%@NL@%
                                 , (LONG)pbfh->bmp.cy%@NL@%
                                 , pImage + pbfh->offBits%@NL@%
                                 , (PBITMAPINFO)&(pbfh->bmp));%@NL@%
        if (cScans != (ULONG)pbfh->bmp.cy)  %@AB@%/* compare with original number of scans */%@AE@%%@NL@%
            goto lfread_error_free_bits;%@NL@%
    }%@NL@%
    fRet = TRUE;     %@AB@%/* We made it!  The bits are in the thread's PS. */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Close the file, free the buffer space and leave.        This is a%@NL@%
%@AB@%    * common exit point from the function.  Since the same cleanup%@NL@%
%@AB@%    * operations need to be performed for such a large number of%@NL@%
%@AB@%    * possible error conditions, this is a concise way to do the right%@NL@%
%@AB@%    * thing.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
lfread_error_free_bits:%@NL@%
    DosFreeSeg(sel);%@NL@%
lfread_error_close_file:%@NL@%
    DosClose(hfile);%@NL@%
    return fRet;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfWriteFile%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Calls the OpenDlg function to ask the user what file name to%@NL@%
%@AB@%*   save under.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfWriteFile(hwnd, pthr)%@NL@%
HWND hwnd;%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
    HFILE hFile;%@NL@%
    DLF dlf;%@NL@%
    BITMAPINFOHEADER bmih;%@NL@%
%@NL@%
%@NL@%
    SetupDLF( &dlf%@NL@%
            , DLG_SAVEDLG%@NL@%
            , &hFile%@NL@%
            , (PSZ)"\\*.BMP"%@NL@%
            , (PSZ)"LineFrac"%@NL@%
            , (PSZ)"Save Bitmap"%@NL@%
            , NULL );%@NL@%
    dlf.szFileName[0] = '\0';%@NL@%
    dlf.szOpenFile[0] = '\0';%@NL@%
%@NL@%
    switch (DlgFile(hwnd,&dlf))%@NL@%
    {%@NL@%
    case TDF_ERRMEM:%@NL@%
    case TDF_INVALID:%@NL@%
        MyMessageBox(hwnd, "Error opening file.");%@NL@%
        break;%@NL@%
%@NL@%
    case TDF_NOSAVE:%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        bmih.cbFix     = sizeof(BITMAPINFOHEADER);%@NL@%
        bmih.cx        = (USHORT) pthr->rcl.xRight;%@NL@%
        bmih.cy        = (USHORT) pthr->rcl.yTop;%@NL@%
        bmih.cPlanes   = pthr->cPlanes;%@NL@%
        bmih.cBitCount = pthr->cBitCount;%@NL@%
%@NL@%
        if (!LfWriteBMP(pthr->hps, &bmih, &dlf))%@NL@%
            MyMessageBox(hwnd, "Error writing file.");%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfWriteBMP%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Write the bitmap out to a BMP format file.        Write the file%@NL@%
%@AB@%*   header first, then the bitmap bits.  Space for the header%@NL@%
%@AB@%*   and the bits is allocated.        Huge bitmaps are supported.%@NL@%
%@AB@%*   Free up memory and close the file before leaving.  The file%@NL@%
%@AB@%*   will have been opened by the time this function is called,%@NL@%
%@AB@%*   and the file handle will be in the *pdlf structure.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfWriteBMP(hPS, pbmih, pdlf)%@NL@%
HPS hPS;                %@AB@%/* hPS from which to get bitmap bits.          */%@AE@%%@NL@%
PBITMAPINFOHEADER pbmih;%@AB@%/* Bitmap information.                          */%@AE@%%@NL@%
PDLF pdlf;                %@AB@%/* File information filled by DlgFile. */%@AE@%%@NL@%
{%@NL@%
    HFILE hfile;%@NL@%
    ULONG cScans;%@NL@%
    ULONG ulSize;         %@AB@%/* Number of bytes occupied by bitmap bits.             */%@AE@%%@NL@%
    USHORT cSegs;         %@AB@%/* Number of 64K segments in ulSize.                     */%@AE@%%@NL@%
    USHORT cbExtra;         %@AB@%/* Bytes in last segment of ulSize.                     */%@AE@%%@NL@%
    SEL selBits;         %@AB@%/* Base selector to bitmap bits.                     */%@AE@%%@NL@%
    USHORT hugeshift;         %@AB@%/* Segment index shift value.                             */%@AE@%%@NL@%
    USHORT cbBMHdr;         %@AB@%/* Size of bitmap header.                             */%@AE@%%@NL@%
    PBITMAPFILEHEADER pbfh; %@AB@%/* Pointer to private copy of bitmap info data.        */%@AE@%%@NL@%
    USHORT cbWrite1;         %@AB@%/* Number of bytes to write first call to DosWrite  */%@AE@%%@NL@%
    USHORT cbWrite2;         %@AB@%/* Number of bytes to write second call to DosWrite */%@AE@%%@NL@%
    USHORT cbWritten;         %@AB@%/* Number of bytes written by DosWrite.             */%@AE@%%@NL@%
    BOOL fRet = FALSE;         %@AB@%/* Function return code.                             */%@AE@%%@NL@%
    USHORT i;                 %@AB@%/* Generic loop index.                              */%@AE@%%@NL@%
    struct%@NL@%
    {%@NL@%
        LONG cPlanes;%@NL@%
        LONG cBitCount;%@NL@%
    } bmFmt;%@NL@%
%@NL@%
%@NL@%
    hfile = *(pdlf->phFile);%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * If the bitmap was created with either 0 planes or 0 bits per%@NL@%
%@AB@%    * pixel, then query the format to write with.  By asking for just%@NL@%
%@AB@%    * one format (two LONGs, or one instance of structure of bmFmt),%@NL@%
%@AB@%    * we'll get the device's favored format.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    if ((pbmih->cPlanes == 0) || (pbmih->cBitCount))%@NL@%
    {%@NL@%
        if (!GpiQueryDeviceBitmapFormats(hPS, 2L, (PLONG)&bmFmt))%@NL@%
            goto lfwrite_error_close_file;%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
        bmFmt.cPlanes        = pbmih->cPlanes;%@NL@%
        bmFmt.cBitCount = pbmih->cBitCount;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Determine size of bitmap header.        The header consists of a%@NL@%
%@AB@%    * a fixed-size part and a variable-length color table.  The%@NL@%
%@AB@%    * latter has  2^cBitCount  entries, each of which is sizeof(RGB)%@NL@%
%@AB@%    * bytes long.  The exception is when cBitCount is 24, in which%@NL@%
%@AB@%    * case the color table is omitted because the pixels are direct%@NL@%
%@AB@%    * rgb values.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    i = (int) bmFmt.cBitCount;%@NL@%
    if (i == 24)%@NL@%
        cbBMHdr = 0;%@NL@%
    else%@NL@%
        for (cbBMHdr = sizeof(RGB); i > 0; --i)%@NL@%
            cbBMHdr *= 2;%@NL@%
    cbBMHdr += sizeof(BITMAPFILEHEADER);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Copy structure from input to work buffer.  The call to%@NL@%
%@AB@%    * GpiQueryBitmapBits will have write-access to this, so we won't%@NL@%
%@AB@%    * let it have the user's data.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    pbfh = 0;%@NL@%
    if (DosAllocSeg(cbBMHdr, ((PUSHORT)&pbfh)+1, 0))%@NL@%
        goto lfwrite_error_close_file;%@NL@%
    pbfh->bmp = *pbmih;%@NL@%
    if ((pbmih->cPlanes == 0) || (pbmih->cBitCount))%@NL@%
    {%@NL@%
        pbfh->bmp.cPlanes   = (USHORT) bmFmt.cPlanes;%@NL@%
        pbfh->bmp.cBitCount = (USHORT) bmFmt.cBitCount;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Allocate space for the bitmap bits -- all of them at once.%@NL@%
%@AB@%    * The extra ULONG casts are there to force all the arithmetic%@NL@%
%@AB@%    * to be done in 32 bits.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    ulSize = (%@NL@%
               (%@NL@%
                 (%@NL@%
                   (ULONG)pbfh->bmp.cBitCount%@NL@%
                   * (ULONG)pbfh->bmp.cx%@NL@%
                   + 31L%@NL@%
                 ) / 32L%@NL@%
               ) * (ULONG)pbfh->bmp.cPlanes * 4L%@NL@%
             ) * (ULONG)pbfh->bmp.cy;%@NL@%
%@NL@%
    cSegs   = (USHORT)(ulSize/0x10000L);%@NL@%
    cbExtra = (USHORT)(ulSize%0x10000L);%@NL@%
    if (DosAllocHuge(cSegs, cbExtra, (PSEL)&selBits, 0, 0))%@NL@%
        goto lfwrite_error_free_header;%@NL@%
    if (DosGetHugeShift(&hugeshift))%@NL@%
        goto lfwrite_error_free_bits;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Tell GPI to give us the bits. The function returns the number%@NL@%
%@AB@%    * of scan lines of the bitmap that were copied.  We want all of%@NL@%
%@AB@%    * them at once.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    cScans = GpiQueryBitmapBits( hPS%@NL@%
                               , 0L%@NL@%
                               , (ULONG)pbfh->bmp.cy%@NL@%
                               , (PBYTE)MAKEP(selBits, 0)%@NL@%
                               , (PBITMAPINFO)&pbfh->bmp);%@NL@%
    if (cScans != pbfh->bmp.cy)  %@AB@%/* compare with original number of scans */%@AE@%%@NL@%
        goto lfwrite_error_free_bits;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Fill in the extra header fields and write the header out to%@NL@%
%@AB@%    * the file.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    pbfh->usType    = 0x4D42;                  %@AB@%/* 'MB' */%@AE@%%@NL@%
    pbfh->cbSize    = ulSize + cbBMHdr;%@NL@%
    pbfh->xHotspot  = pbfh->bmp.cx / 2;    %@AB@%/* why bother ? */%@AE@%%@NL@%
    pbfh->yHotspot  = pbfh->bmp.cy / 2;%@NL@%
    pbfh->offBits   = cbBMHdr;%@NL@%
%@NL@%
    if (DosWrite( hfile%@NL@%
                , (PVOID)pbfh%@NL@%
                , cbBMHdr%@NL@%
                , &cbWritten))%@NL@%
        goto lfwrite_error_free_bits;%@NL@%
    if (cbWritten != cbBMHdr)%@NL@%
        goto lfwrite_error_free_bits;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Write the bits out to the file. The DosWrite function allows a%@NL@%
%@AB@%    * maximum of 64K-1 bytes written at a time.  We get around this%@NL@%
%@AB@%    * by writing two 32K chunks for each 64K segment, and writing the%@NL@%
%@AB@%    * last segment in one piece.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
    for (i = 0; i <= cSegs; ++i)%@NL@%
    {%@NL@%
        if (i < cSegs)%@NL@%
        {%@NL@%
            %@AB@%/* This segment is 64K bytes long, so split it up. */%@AE@%%@NL@%
            cbWrite1 = 0x8000;%@NL@%
            cbWrite2 = 0x8000;%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
            %@AB@%/* This segment is less than 64K bytes long, so write it all. */%@AE@%%@NL@%
            cbWrite1 = cbExtra;%@NL@%
            cbWrite2 = 0;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* There's a possibility that cbExtra will be 0, so check%@NL@%
%@AB@%         * to avoid an unnecessary system call.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (cbWrite1 > 0)%@NL@%
        {%@NL@%
            if (DosWrite( hfile%@NL@%
                        , (PVOID)MAKEP(selBits+(i<<hugeshift), 0)%@NL@%
                        , cbWrite1%@NL@%
                        , &cbWritten))%@NL@%
                goto lfwrite_error_free_bits;%@NL@%
            if (cbWrite1 != cbWritten)%@NL@%
                goto lfwrite_error_free_bits;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* This will always be skipped on the last partial segment. */%@AE@%%@NL@%
        if (cbWrite2 > 0)%@NL@%
        {%@NL@%
            if (DosWrite( hfile%@NL@%
                        , (PVOID)MAKEP(selBits+(i<<hugeshift), cbWrite1)%@NL@%
                        , cbWrite2%@NL@%
                        , &cbWritten))%@NL@%
                goto lfwrite_error_free_bits;%@NL@%
            if (cbWrite2 != cbWritten)%@NL@%
                goto lfwrite_error_free_bits;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    fRet = TRUE;     %@AB@%/* We made it!  The bits are on the disk. */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*******************************************************************%@NL@%
%@AB@%    * Close the file, free the buffer space and leave.        This is a%@NL@%
%@AB@%    * common exit point from the function.  Since the same cleanup%@NL@%
%@AB@%    * operations need to be performed for such a large number of%@NL@%
%@AB@%    * possible error conditions, this is concise way to do the right%@NL@%
%@AB@%    * thing.%@NL@%
%@AB@%    *******************************************************************/%@AE@%%@NL@%
%@NL@%
lfwrite_error_free_bits:%@NL@%
    DosFreeSeg(selBits);%@NL@%
lfwrite_error_free_header:%@NL@%
    DosFreeSeg(*((PUSHORT)&pbfh+1));%@NL@%
lfwrite_error_close_file:%@NL@%
    DosClose(hfile);%@NL@%
    return fRet;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LFINIT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\LINEFRAC\LFINIT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   lfinit.c -- Initialization portion of LineFractal Application.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GLOBALS %@NL@%
%@AI@%#include %@AE@%"linefrac.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_LFINIT %@NL@%
%@AI@%#define %@AE@%INCL_LFMAIN %@NL@%
%@AI@%#include %@AE@%"lffuncs.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Global Variables%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
extern GLOBALDATA global;%@NL@%
extern ULONG aulRops[];%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfInitApp%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Register application window class and creates standard window.%@NL@%
%@AB@%*%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL FAR%@NL@%
LfInitApp(VOID)%@NL@%
{%@NL@%
    char szTitle[24];%@NL@%
    ULONG ctldata;%@NL@%
    PID pid;%@NL@%
    TID tid;%@NL@%
    HSWITCH hsw;%@NL@%
    static SWCNTRL swctl = { 0, 0, 0, 0, 0, SWL_VISIBLE,%@NL@%
                             SWL_JUMPABLE, "LineFractal", 0 };%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*  Register Application Window Class  */%@AE@%%@NL@%
%@NL@%
    WinLoadString( global.hab, (HMODULE) NULL, IDS_TITLE, sizeof(szTitle), (PCH)szTitle );%@NL@%
    if ( !WinRegisterClass( global.hab, (PCH)szTitle, (PFNWP)LineFracWndProc,%@NL@%
            CS_SIZEREDRAW, 0 ))%@NL@%
        return FALSE;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Load the window's default pointer. */%@AE@%%@NL@%
    if (!((global.hptr)[0]   = WinLoadPointer( HWND_DESKTOP,(HMODULE) NULL, IDR_KOCH0 )))%@NL@%
        return FALSE;%@NL@%
    if (!((global.hptr)[1]   = WinLoadPointer( HWND_DESKTOP,(HMODULE) NULL, IDR_KOCH1 )))%@NL@%
        return FALSE;%@NL@%
    if (!((global.hptr)[2]   = WinLoadPointer( HWND_DESKTOP,(HMODULE) NULL, IDR_KOCH2 )))%@NL@%
        return FALSE;%@NL@%
    if (!((global.hptr)[3]   = WinLoadPointer( HWND_DESKTOP,(HMODULE) NULL, IDR_KOCH3 )))%@NL@%
        return FALSE;%@NL@%
    if (!(global.hptrTrack   = WinLoadPointer( HWND_DESKTOP,(HMODULE) NULL, IDR_TRACKINGPTR )))%@NL@%
        return FALSE;%@NL@%
    if (!(global.hptrPaste   = WinLoadPointer( HWND_DESKTOP,(HMODULE) NULL, IDR_PASTINGPTR )))%@NL@%
        return FALSE;%@NL@%
    if (!(global.hptrWait    = WinQuerySysPointer(HWND_DESKTOP,SPTR_WAIT,FALSE)))%@NL@%
        return FALSE;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Create a window instance of class "LineFractal" */%@AE@%%@NL@%
%@NL@%
    ctldata = FCF_STANDARD &%@NL@%
     ~(ULONG)(FCF_ICON | FCF_ACCELTABLE | FCF_TASKLIST);%@NL@%
%@NL@%
    if (global.hwndFrame = WinCreateStdWindow(%@NL@%
        HWND_DESKTOP,                   %@AB@%/* specify desktop as parent window            */%@AE@%%@NL@%
        WS_VISIBLE,                   %@AB@%/* window styles                            */%@AE@%%@NL@%
        &ctldata,                   %@AB@%/* frame creation flags                    */%@AE@%%@NL@%
        (PCH)szTitle,                   %@AB@%/* window class name                     */%@AE@%%@NL@%
        (PCH)szTitle,                   %@AB@%/* name appearing in window caption            */%@AE@%%@NL@%
        0L,                           %@AB@%/*                                            */%@AE@%%@NL@%
        (HMODULE)NULL,                   %@AB@%/* use current executable module id            */%@AE@%%@NL@%
        IDR_LINEFRACTAL,           %@AB@%/* menu id                                    */%@AE@%%@NL@%
        (HWND FAR *)&global.hwnd   %@AB@%/* window handle                            */%@AE@%%@NL@%
        ))%@NL@%
    {%@NL@%
        global.fFirstThread                  = TRUE;%@NL@%
%@NL@%
        global.fAutoSwitch                  = FALSE;%@NL@%
        global.usSwitchDelay                  = 1 * 1000;          %@AB@%/* 1 sec */%@AE@%%@NL@%
        global.fThreadInheritance          = TRUE;%@NL@%
        global.fUpdateMenusOnThreadSwitch = TRUE;%@NL@%
        global.fTimerOn                   = FALSE;%@NL@%
        global.usMinTimerDelay                  = 1 * 1000;          %@AB@%/* 1 sec */%@AE@%%@NL@%
        global.usMaxTimerDelay                  = 5 * 1000;          %@AB@%/* 5 sec */%@AE@%%@NL@%
%@NL@%
        global.usRopIndex                  = 0;%@NL@%
        global.ulPasteROP                  = aulRops[global.usRopIndex];%@NL@%
        global.usPtrIncr                  = 1;%@NL@%
        global.usPtrCounter                  = 1;%@NL@%
        global.usUserPtr                  = 2;%@NL@%
        global.usCurPtr                   = global.usUserPtr;%@NL@%
        global.usPtrThreshold                  = 5;%@NL@%
        global.fUseClipbrd                  = FALSE;%@NL@%
        global.fTracking                  = FALSE;%@NL@%
        global.fSelecting                  = FALSE;%@NL@%
        global.fPasting                   = FALSE;%@NL@%
        global.fMouseChangesRecursion          = TRUE;%@NL@%
        global.fAnimatePtr                  = TRUE;%@NL@%
        global.fTempSelect                  = FALSE;%@NL@%
        global.fShowSelectRc                  = FALSE;%@NL@%
        global.fHaveSelectRc                  = FALSE;%@NL@%
        global.fHaveCutCopyDC                  = FALSE;%@NL@%
%@NL@%
        global.fUpdateAttrs                  = FALSE;%@NL@%
        global.flLineAttrs                  = 0L;%@NL@%
        global.flMarkerAttrs                  = 0L;%@NL@%
        global.flAreaAttrs                  = 0L;%@NL@%
        global.flImageAttrs                  = 0L;%@NL@%
        global.flMiscAttrs                  = 0L;%@NL@%
%@NL@%
%@NL@%
        WinQueryWindowRect(global.hwnd, &global.rcl);%@NL@%
%@NL@%
        global.cThr = 0;        %@AB@%/* start with no active threads */%@AE@%%@NL@%
        global.pThrTop = NULL;        %@AB@%/* make sure this guy's invalid */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%INIT_MENU_ITEM(val, var)     \ %@NL@%
        TOGGLE_MENU_ITEM(global.hwndFrame, (val), (var))%@NL@%
%@NL@%
        %@AB@%/* Check boolean menu items if they are set to true. */%@AE@%%@NL@%
%@NL@%
        INIT_MENU_ITEM(IDM_AUTOSWITCH,                 global.fAutoSwitch);%@NL@%
        INIT_MENU_ITEM(IDM_UPDATEMENUS,                 global.fUpdateMenusOnThreadSwitch);%@NL@%
        INIT_MENU_ITEM(IDM_THREADINHERITANCE,         global.fThreadInheritance);%@NL@%
        INIT_MENU_ITEM(IDM_USECLIPBRD,                 global.fUseClipbrd);%@NL@%
        INIT_MENU_ITEM(IDM_MOUSECHANGESRECURSION, global.fMouseChangesRecursion);%@NL@%
        INIT_MENU_ITEM(IDM_ANIMATEPTR,                 global.fAnimatePtr);%@NL@%
%@NL@%
        CHECK_MENU_ITEM(global.hwndFrame, IDM_PASTES+global.usRopIndex);%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* Add ourselves to the switch list. */%@AE@%%@NL@%
%@NL@%
        WinQueryWindowProcess(global.hwndFrame, &pid, &tid);%@NL@%
        swctl.hwnd        = global.hwndFrame;%@NL@%
        swctl.idProcess = pid;%@NL@%
        hsw = WinAddSwitchEntry(&swctl);%@NL@%
%@NL@%
        return TRUE;%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LFPS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\LINEFRAC\LFPS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   lfps.c -- Subroutines for PS/DC/BM management for LineFractal.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GLOBALS %@NL@%
%@AI@%#define %@AE@%INCL_THREADS %@NL@%
%@AI@%#include %@AE@%"linefrac.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_LFPS %@NL@%
%@AI@%#define %@AE@%INCL_LFDRAW %@NL@%
%@AI@%#include %@AE@%"lffuncs.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Global Variables%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
extern GLOBALDATA global;%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Data structures for opening the PostScript DC.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
typedef struct _randomdata%@NL@%
{%@NL@%
    long data[12];%@NL@%
} PSRANDOMDATA;%@NL@%
%@NL@%
typedef struct _psdevopendata%@NL@%
{%@NL@%
    char *device;%@NL@%
    char *name;%@NL@%
    PSRANDOMDATA *data;%@NL@%
    char *type;%@NL@%
} PSDEVOPENDATA;%@NL@%
%@NL@%
PSRANDOMDATA psrnddata =%@NL@%
{%@NL@%
    48, 0, 0x65656565, 0, 0, 0, 0, 0, 0, 0, 0, 1%@NL@%
};%@NL@%
%@NL@%
PSDEVOPENDATA dvdata =%@NL@%
{%@NL@%
    "ps.txt",%@NL@%
    "PSCRIPT",%@NL@%
    &psrnddata,%@NL@%
    "IBM_Q_STD"%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfOpenDC%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Open a device context for the thread.  Read the DC type from the%@NL@%
%@AB@%*   thread structure.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL fhdcInUse = FALSE; %@AB@%/* TRUE --> a direct dc thread is active */%@AE@%%@NL@%
HDC hdcPrivate = NULL;        %@AB@%/* non NULL --> it's the window DC */%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfOpenDC(pthr)%@NL@%
PTHR  pthr;%@NL@%
{%@NL@%
    switch (pthr->dcType)%@NL@%
    {%@NL@%
    case IDM_DCDIRECT:%@NL@%
        %@AB@%/* only one direct dc allowed */%@AE@%%@NL@%
        if (fhdcInUse)%@NL@%
            pthr->hdc = NULL;%@NL@%
        else%@NL@%
        {%@NL@%
            if (!hdcPrivate)%@NL@%
                hdcPrivate = WinOpenWindowDC(global.hwnd);%@NL@%
            pthr->hdc = hdcPrivate;%@NL@%
            fhdcInUse = TRUE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_DCMEMORY:%@NL@%
        pthr->hdc = DevOpenDC(global.hab, OD_MEMORY, "*", 0L, NULL, NULL);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_DCPOSTSCRIPT:%@NL@%
        pthr->hdc = DevOpenDC(global.hab, OD_DIRECT, "*", 4L, (PDEVOPENDATA)&dvdata, NULL);%@NL@%
        break;%@NL@%
%@NL@%
    case IDM_DCPROPRINTER:%@NL@%
%@NL@%
    default:%@NL@%
        pthr->hdc = NULL;%@NL@%
    }%@NL@%
%@NL@%
    return (pthr->hdc ? TRUE : FALSE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfCloseDC%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Close the device context for the thread.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfCloseDC(pthr)%@NL@%
PTHR  pthr;%@NL@%
{%@NL@%
    if (pthr->dcType == IDM_DCDIRECT)%@NL@%
        fhdcInUse = FALSE;%@NL@%
    else%@NL@%
    {%@NL@%
        if (pthr->hbm)%@NL@%
            LfDeleteBitmap(pthr);%@NL@%
        if (pthr->hdc)%@NL@%
            DevCloseDC(pthr->hdc);%@NL@%
    }%@NL@%
    pthr->hdc = NULL;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfCreateBitmap%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Create a bitmap of the format specified in the thread structure.%@NL@%
%@AB@%*   If the bitmap is to be automatically sized, then read the window%@NL@%
%@AB@%*   size, otherwise use the values in the thread structure.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfCreateBitmap(pthr)%@NL@%
PTHR  pthr;%@NL@%
{%@NL@%
    BITMAPINFOHEADER bminfo;%@NL@%
%@NL@%
    bminfo.cbFix = sizeof bminfo;%@NL@%
%@NL@%
    bminfo.cx = (USHORT) (pthr->rcl.xRight - pthr->rcl.xLeft);%@NL@%
    bminfo.cy = (USHORT) (pthr->rcl.yTop   - pthr->rcl.yBottom);%@NL@%
    bminfo.cPlanes   = pthr->cPlanes;%@NL@%
    bminfo.cBitCount = pthr->cBitCount;%@NL@%
%@NL@%
    pthr->hbm = GpiCreateBitmap(pthr->hps, &bminfo, 0L, 0L, 0L);%@NL@%
%@NL@%
    return (pthr->hbm ? TRUE : FALSE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfDeleteBitmap%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Delete the thread's bitmap and set the bitmap handle to null.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfDeleteBitmap(pthr)%@NL@%
PTHR  pthr;%@NL@%
{%@NL@%
    GpiDeleteBitmap(pthr->hbm);%@NL@%
    pthr->hbm = NULL;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfCreatePS%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Create a presentation space for the thread.  If the DC type is%@NL@%
%@AB@%*   a memory bitmap, then create a bitmap, select it into the PS, and%@NL@%
%@AB@%*   initialize it to the desired background color.  Compute the scale%@NL@%
%@AB@%*   factors and offsets to use when drawing.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfCreatePS(pthr)%@NL@%
PTHR  pthr;%@NL@%
{%@NL@%
    SIZEL size;%@NL@%
    BOOL fOK = FALSE;%@NL@%
%@NL@%
    if (LfOpenDC(pthr))%@NL@%
    {%@NL@%
        size.cx = 0L;%@NL@%
        size.cy = 0L;%@NL@%
        pthr->hps = GpiCreatePS(global.hab, pthr->hdc, &size,%@NL@%
                                 PU_PELS|GPIT_MICRO|GPIA_ASSOC);%@NL@%
        if (pthr->hps)%@NL@%
        {%@NL@%
            if (pthr->dcType == IDM_DCDIRECT)%@NL@%
            {%@NL@%
                pthr->rcl = global.rcl;%@NL@%
                GpiSetAttrs(pthr->hps, PRIM_LINE,   LFA_LINEALL,  0L, &pthr->lb);%@NL@%
                GpiSetAttrs(pthr->hps, PRIM_MARKER, LFA_MARKALL,  0L, &pthr->mb);%@NL@%
                GpiSetAttrs(pthr->hps, PRIM_AREA,   LFA_AREAALL,  0L, &pthr->ab);%@NL@%
                GpiSetAttrs(pthr->hps, PRIM_IMAGE,  LFA_IMAGEALL, 0L, &pthr->ib);%@NL@%
%@NL@%
            }%@NL@%
            else if (pthr->dcType == IDM_DCMEMORY)%@NL@%
            {%@NL@%
                pthr->rcl.xLeft   = 0L;%@NL@%
                pthr->rcl.yBottom = 0L;%@NL@%
                pthr->rcl.xRight  = global.bm.cx;%@NL@%
                pthr->rcl.yTop          = global.bm.cy;%@NL@%
                pthr->cPlanes          = global.bm.cPlanes;%@NL@%
                pthr->cBitCount   = global.bm.cBitCount;%@NL@%
                if (LfCreateBitmap(pthr))%@NL@%
                    if (GpiSetBitmap(pthr->hps, pthr->hbm) != HBM_ERROR)%@NL@%
                    {%@NL@%
                        GpiSetAttrs(pthr->hps, PRIM_LINE,   LFA_LINEALL,  0L, &pthr->lb);%@NL@%
                        GpiSetAttrs(pthr->hps, PRIM_MARKER, LFA_MARKALL,  0L, &pthr->mb);%@NL@%
                        GpiSetAttrs(pthr->hps, PRIM_AREA,   LFA_AREAALL,  0L, &pthr->ab);%@NL@%
                        GpiSetAttrs(pthr->hps, PRIM_IMAGE,  LFA_IMAGEALL, 0L, &pthr->ib);%@NL@%
%@NL@%
                        LfClearRect(pthr, &pthr->rcl);%@NL@%
                        if (pthr->fCollectBounds)%@NL@%
                            GpiSetDrawControl(pthr->hps, DCTL_BOUNDARY, DCTL_ON);%@NL@%
                        fOK = TRUE;%@NL@%
                    }%@NL@%
%@NL@%
                if (!fOK)%@NL@%
                {%@NL@%
                    LfDeletePS(pthr);%@NL@%
                    return FALSE;%@NL@%
                }%@NL@%
            }%@NL@%
            else%@NL@%
            {%@NL@%
                pthr->rcl = global.rcl;%@NL@%
            }%@NL@%
%@NL@%
            pthr->flMiscAttrs |= LFA_XSCALE | LFA_YSCALE | LFA_XOFF | LFA_YOFF;%@NL@%
%@NL@%
            return TRUE;%@NL@%
        }%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfDeletePS%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Delete the thread's presentation space.  If the DC type is%@NL@%
%@AB@%*   a memory bitmap, then unset the bitmap and delete it.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfDeletePS(pthr)%@NL@%
PTHR  pthr;%@NL@%
{%@NL@%
    if (pthr->hbm)%@NL@%
    {%@NL@%
        GpiSetBitmap(pthr->hps, NULL);%@NL@%
        LfDeleteBitmap(pthr);%@NL@%
    }%@NL@%
    GpiDestroyPS(pthr->hps);%@NL@%
    LfCloseDC(pthr);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfResizePS%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Destroy the current PS and create a new one the size of the%@NL@%
%@AB@%*   current client rectangle.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfResizePS(pthr)%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
    if (pthr->hps)%@NL@%
    {%@NL@%
        pthr->fInterrupted = TRUE;%@NL@%
        while (pthr->fBusy)%@NL@%
            ;%@NL@%
        LfDeletePS(pthr);%@NL@%
    }%@NL@%
%@NL@%
    return LfCreatePS(pthr);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LFTHREAD.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\LINEFRAC\LFTHREAD.C%@AE@%%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   lfthread.c -- Subroutines for thread management for LineFractal.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#define %@AE@%INCL_DOSSEMAPHORES %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_DOSERRORS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#define %@AE@% _MT %@NL@%
%@AI@%#include %@AE@%<process.h> %@NL@%
%@AI@%#include %@AE@%<stddef.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GLOBALS %@NL@%
%@AI@%#define %@AE@%INCL_THREADS %@NL@%
%@AI@%#include %@AE@%"linefrac.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_LFCMD %@NL@%
%@AI@%#define %@AE@%INCL_LFMAIN %@NL@%
%@AI@%#define %@AE@%INCL_LFPS %@NL@%
%@AI@%#define %@AE@%INCL_LFUTIL %@NL@%
%@AI@%#define %@AE@%INCL_LFTHREAD %@NL@%
%@AI@%#define %@AE@%INCL_LFDRAW %@NL@%
%@AI@%#include %@AE@%"lffuncs.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Global Variables%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
extern GLOBALDATA global;%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfStartThread%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Do everything needed to start up a background thread drawing%@NL@%
%@AB@%*   fractals.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   This includes:%@NL@%
%@AB@%*%@NL@%
%@AB@%*        Allocate space for thread structure.%@NL@%
%@AB@%*        Initialize fields of thread structure.%@NL@%
%@AB@%*        Create a presentation space for the thread.%@NL@%
%@AB@%*        Create stack space for the thread.%@NL@%
%@AB@%*        Set the thread's semaphore to block -- i.e. don't start%@NL@%
%@AB@%*            drawing until everything is ready.%@NL@%
%@AB@%*        Start the thread.%@NL@%
%@AB@%*        Set the thread's priority to idle time.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%SIZE_ACCUM_STACK        2048 %@NL@%
%@NL@%
PTHR%@NL@%
LfStartThread(dcType)%@NL@%
USHORT dcType;%@NL@%
{%@NL@%
    PTHR pthr;%@NL@%
%@NL@%
%@NL@%
    pthr = NULL;        %@AB@%/* zero out all 32 bits */%@AE@%%@NL@%
    if (DosAllocSeg(sizeof(THR), ((PUSHORT)&pthr)+1, 0))%@NL@%
        return NULL;%@NL@%
%@NL@%
    pthr->dcType = dcType;%@NL@%
%@NL@%
    LfPreInitThread(pthr);%@NL@%
    if (LfCreatePS(pthr))%@NL@%
    {%@NL@%
        LfPostInitThread(pthr);%@NL@%
        if (DosAllocSeg(SIZE_ACCUM_STACK, &pthr->selStack, 0))%@NL@%
            goto lfst_exit;%@NL@%
%@NL@%
        DosSemSet(&pthr->lSemRedraw);%@NL@%
        pthr->tid = _beginthread(LineFractalThread, MAKEP(pthr->selStack, 0), SIZE_ACCUM_STACK, pthr);%@NL@%
        if (pthr->tid == -1)%@NL@%
        {%@NL@%
            LfDeletePS(pthr);%@NL@%
            goto lfst_exit;%@NL@%
        }%@NL@%
        DosSetPrty(PRTYS_THREAD, PRTYC_IDLETIME, 0, pthr->tid);%@NL@%
%@NL@%
        LfSelectXform(global.hwnd, pthr, pthr->usCurXform);%@NL@%
        DosSemClear(&pthr->lSemRedraw);%@NL@%
%@NL@%
        if (!DevQueryCaps(pthr->hdc, CAPS_HORIZONTAL_RESOLUTION, 2L, (PLONG)&(pthr->AspectRatio)))%@NL@%
        {%@NL@%
            pthr->AspectRatio.lHorz = 1L;%@NL@%
            pthr->AspectRatio.lVert = 1L;%@NL@%
        }%@NL@%
%@NL@%
        return pthr;%@NL@%
    }%@NL@%
lfst_exit:%@NL@%
    DosFreeSeg(*(((PUSHORT)&pthr)+1));%@NL@%
    return NULL;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfPreInitThread%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Initialize constant values in the thread structure needed from%@NL@%
%@AB@%*   the moment the thread starts.  If thread inheritance is enabled,%@NL@%
%@AB@%*   then copy as much as possible from the top thread, if there is%@NL@%
%@AB@%*   one.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfPreInitThread(pthr)%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
    pthr->hps                = NULL;%@NL@%
    pthr->hdc                = NULL;%@NL@%
    pthr->hbm                = NULL;%@NL@%
    pthr->fTimeToDie        = FALSE;%@NL@%
    pthr->fUpdateAttrs        = FALSE;%@NL@%
    pthr->fBusy         = FALSE;%@NL@%
    pthr->pptl                = NULL;%@NL@%
    pthr->cptl                = 0;%@NL@%
    pthr->pmatlf        = NULL;%@NL@%
%@NL@%
    if (global.fThreadInheritance && global.pThrTop)%@NL@%
    {%@NL@%
        pthr->cPlanes               = global.pThrTop->cPlanes          ;%@NL@%
        pthr->cBitCount        = global.pThrTop->cBitCount          ;%@NL@%
%@NL@%
        pthr->cxWCS               = global.pThrTop->cxWCS                  ;%@NL@%
        pthr->cyWCS               = global.pThrTop->cyWCS                  ;%@NL@%
%@NL@%
        pthr->fAutoSizePS      = global.pThrTop->fAutoSizePS          ;%@NL@%
        pthr->fAutoSelectDims  = global.pThrTop->fAutoSelectDims  ;%@NL@%
        pthr->fClearOnRedraw   = global.pThrTop->fClearOnRedraw   ;%@NL@%
        pthr->fAutoStartRedraw = global.pThrTop->fAutoStartRedraw ;%@NL@%
        pthr->fCollectBounds   = global.pThrTop->fCollectBounds   ;%@NL@%
%@NL@%
        pthr->fFracRedraw      = global.pThrTop->fFracRedraw          ;%@NL@%
        pthr->fPrimRedraw      = global.pThrTop->fPrimRedraw          ;%@NL@%
        pthr->fAttrRedraw      = global.pThrTop->fAttrRedraw          ;%@NL@%
%@NL@%
        pthr->lb               = global.pThrTop->lb                  ;%@NL@%
        pthr->flLineAttrs      = LFA_LINEALL                          ;%@NL@%
        pthr->mb               = global.pThrTop->mb                  ;%@NL@%
        pthr->flMarkerAttrs    = LFA_MARKALL                          ;%@NL@%
        pthr->ab               = global.pThrTop->ab                  ;%@NL@%
        pthr->flAreaAttrs      = LFA_AREAALL                          ;%@NL@%
        pthr->ib               = global.pThrTop->ib                  ;%@NL@%
        pthr->flImageAttrs     = LFA_IMAGEALL                          ;%@NL@%
%@NL@%
        pthr->usCurPrim        = global.pThrTop->usCurPrim          ;%@NL@%
        pthr->usCurXform       = global.pThrTop->usCurXform          ;%@NL@%
        pthr->usRecursion      = global.pThrTop->usRecursion          ;%@NL@%
        pthr->usPolygonSides   = global.pThrTop->usPolygonSides   ;%@NL@%
        pthr->cptMax               = global.pThrTop->cptMax           ;%@NL@%
        pthr->dblXOff               = global.pThrTop->dblXOff          ;%@NL@%
        pthr->dblYOff               = global.pThrTop->dblYOff          ;%@NL@%
        pthr->dblXScale        = global.pThrTop->dblXScale          ;%@NL@%
        pthr->dblYScale        = global.pThrTop->dblYScale          ;%@NL@%
        pthr->dblRotation      = global.pThrTop->dblRotation          ;%@NL@%
        pthr->flMiscAttrs      = LFA_MISCALL                          ;%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
        pthr->cPlanes               = global.bm.cPlanes;%@NL@%
        pthr->cBitCount        = global.bm.cBitCount;%@NL@%
%@NL@%
        pthr->cxWCS               = 10000L;%@NL@%
        pthr->cyWCS               = 10000L;%@NL@%
%@NL@%
        pthr->fAutoSizePS      = TRUE;%@NL@%
        pthr->fAutoSelectDims  = TRUE;%@NL@%
        pthr->fClearOnRedraw   = TRUE;%@NL@%
        pthr->fAutoStartRedraw = FALSE;%@NL@%
        pthr->fCollectBounds   = TRUE;%@NL@%
%@NL@%
        pthr->fFracRedraw      = TRUE;%@NL@%
        pthr->fPrimRedraw      = TRUE;%@NL@%
        pthr->fAttrRedraw      = TRUE;%@NL@%
%@NL@%
        pthr->lb.lColor        = CLR_NEUTRAL;%@NL@%
        pthr->lb.usMixMode     = FM_OVERPAINT;%@NL@%
        pthr->lb.fxWidth       = LINEWIDTH_NORMAL;%@NL@%
;         pthr->lb.lGeomWidth        = 1L;%@NL@%
        pthr->lb.usType        = LINETYPE_SOLID;%@NL@%
;         pthr->lb.usEnd         = LINEEND_FLAT;%@NL@%
;         pthr->lb.usJoin        = LINEJOIN_BEVEL;%@NL@%
        pthr->flLineAttrs      = LFA_LINEALL;%@NL@%
%@NL@%
        pthr->mb.lColor        = CLR_NEUTRAL;%@NL@%
        pthr->mb.lBackColor    = CLR_BACKGROUND;%@NL@%
        pthr->mb.usMixMode     = FM_OVERPAINT;%@NL@%
        pthr->mb.usBackMixMode = BM_LEAVEALONE;%@NL@%
        pthr->mb.usSet               = LCID_DEFAULT;%@NL@%
        pthr->mb.usSymbol      = MARKSYM_DIAMOND;%@NL@%
;         pthr->mb.sizfxCell.cx        = 0L;%@NL@%
;         pthr->mb.sizfxCell.cy        = 0L;%@NL@%
        pthr->flMarkerAttrs    = LFA_MARKALL;%@NL@%
%@NL@%
        pthr->ab.lColor        = CLR_NEUTRAL;%@NL@%
        pthr->ab.lBackColor    = CLR_BACKGROUND;%@NL@%
        pthr->ab.usMixMode     = FM_OVERPAINT;%@NL@%
        pthr->ab.usBackMixMode = BM_OVERPAINT;%@NL@%
        pthr->ab.usSet               = LCID_DEFAULT;%@NL@%
        pthr->ab.usSymbol      = PATSYM_NOSHADE;%@NL@%
;         pthr->ab.ptlRefPoint.x = 0L;%@NL@%
;         pthr->ab.ptlRefPoint.y = 0L;%@NL@%
        pthr->flAreaAttrs      = LFA_AREAALL;%@NL@%
%@NL@%
        pthr->ib.lColor        = CLR_NEUTRAL;%@NL@%
        pthr->ib.lBackColor    = CLR_BACKGROUND;%@NL@%
        pthr->ib.usMixMode     = FM_OVERPAINT;%@NL@%
        pthr->ib.usBackMixMode = FM_OVERPAINT;%@NL@%
        pthr->flImageAttrs     = LFA_IMAGEALL;%@NL@%
%@NL@%
        pthr->usCurPrim        = IDM_POLYLINE;%@NL@%
        pthr->usCurXform       = IDM_SAWTOOTH;%@NL@%
        pthr->usRecursion      = 1;%@NL@%
        pthr->usPolygonSides   = 3;%@NL@%
        pthr->cptMax               = MAX_POINT_COUNT;%@NL@%
        pthr->dblXOff               = 0.125;%@NL@%
        pthr->dblYOff               = 0.5;%@NL@%
        pthr->dblXScale        = 0.75;%@NL@%
        pthr->dblYScale        = 0.75;%@NL@%
        pthr->dblRotation      = 0.0;%@NL@%
        pthr->flMiscAttrs      = LFA_MISCALL;%@NL@%
    }%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfPostInitThread%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Initialize various values in the thread structure which required%@NL@%
%@AB@%*   that a PS/DC/BM had been created.  If thread inheritance is enabled,%@NL@%
%@AB@%*   then copy as much as possible from the top thread, if there is%@NL@%
%@AB@%*   one.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfPostInitThread(pthr)%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
    if (!(global.fThreadInheritance && global.pThrTop))%@NL@%
    {%@NL@%
        pthr->lb.lGeomWidth = GpiQueryLineWidthGeom(pthr->hps);%@NL@%
        pthr->lb.usEnd            = (USHORT) GpiQueryLineEnd(pthr->hps);%@NL@%
        pthr->lb.usJoin     = (USHORT) GpiQueryLineJoin(pthr->hps);%@NL@%
%@NL@%
        DevQueryCaps(pthr->hdc, CAPS_MARKER_WIDTH,  1L, (PLONG)&(pthr->mb.sizfxCell.cx));%@NL@%
        DevQueryCaps(pthr->hdc, CAPS_MARKER_HEIGHT, 1L, (PLONG)&(pthr->mb.sizfxCell.cy));%@NL@%
%@NL@%
        GpiQueryPatternRefPoint(pthr->hps,&(pthr->ab.ptlRefPoint));%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfKillThread%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Force the given thread to die and release its resources.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfKillThread(pthr)%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
    USHORT i;%@NL@%
         USHORT j;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* This does not do anything if there aren't any threads. */%@AE@%%@NL@%
%@NL@%
    if (global.cThr && pthr)%@NL@%
    {%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *  Tell the thread to die when it can.%@NL@%
%@AB@%        *  If blocked on lSemRedraw, then it will recognize fTimeToDie%@NL@%
%@AB@%        *  as soon as it's unblocked.  If it's currently drawing,%@NL@%
%@AB@%        *  it will recognize fInterrupted, kick out of the recursion,%@NL@%
%@AB@%        *  loop back up to check lSemRedraw, which will be clear, so%@NL@%
%@AB@%        *  it'll do as already mentioned.  Set the priority to time-%@NL@%
%@AB@%        *  critical to speed things up.%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        pthr->fTimeToDie   = TRUE;%@NL@%
        pthr->fInterrupted = TRUE;%@NL@%
        DosSetPrty(PRTYS_THREAD, PRTYC_TIMECRITICAL, 0, pthr->tid);%@NL@%
        DosSemClear(&pthr->lSemRedraw);%@NL@%
%@NL@%
%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *  Once it's decided it must die, it will clean up after%@NL@%
%@AB@%        *  itself and exit quietly.  To detect when it has actually%@NL@%
%@AB@%        *  exited, so that we can safely free up the stack, we will%@NL@%
%@AB@%        *  loop asking for the thread's priority until an error occurs.%@NL@%
%@AB@%        *  We will assume that an error implies the thread has exited.%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        {%@NL@%
            USHORT usT;%@NL@%
            USHORT usRet;%@NL@%
            while (!(usRet = DosGetPrty(PRTYS_THREAD, &usT, pthr->tid)));%@NL@%
            if (usRet != ERROR_INVALID_THREADID)%@NL@%
            {%@NL@%
                MyMessageBox(global.hwnd,%@NL@%
                    "Cannot kill thread");%@NL@%
                return;%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *  Extract the given thread from the group. This is done%@NL@%
%@AB@%        *  inside a critical section because the drawing threads%@NL@%
%@AB@%        *  call LfIsThreadTop, which reads global.aThr.%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        i = 0;%@NL@%
        while ((i < global.cThr) && (pthr != global.aThr[i]))%@NL@%
            ++i;    %@AB@%/* if i == global.cThr we have a problem */%@AE@%%@NL@%
        DosEnterCritSec();%@NL@%
        for (j = i; j < global.cThr-1; ++j)%@NL@%
            global.aThr[j] = global.aThr[j+1];%@NL@%
        global.aThr[j] = NULL;        %@AB@%/* clear out all copies of pthr */%@AE@%%@NL@%
        --global.cThr;%@NL@%
        DosExitCritSec();%@NL@%
%@NL@%
%@NL@%
        %@AB@%/****************************************************************%@NL@%
%@AB@%        *  Free up resources allocated for the thread.%@NL@%
%@AB@%        ****************************************************************/%@AE@%%@NL@%
%@NL@%
        LfDeletePS(pthr);%@NL@%
        DosFreeSeg(pthr->selStack);%@NL@%
        DosFreeSeg(*(((PUSHORT)&pthr)+1));%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfBringThreadToTop%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Bring the specified thread to the top, and invalidate the window%@NL@%
%@AB@%*   to force a WM_PAINT message to make the thread's image visible.%@NL@%
%@AB@%*   The given thread can be NULL, in which case just set pThrTop to%@NL@%
%@AB@%*   NULL.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfBringThreadToTop(pthr)%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
    USHORT i;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *  Find the given thread in the group.%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    if (pthr)%@NL@%
    {%@NL@%
        i = 0;%@NL@%
        while ((i < global.cThr) && (pthr != global.aThr[i]))%@NL@%
            ++i;    %@AB@%/* if i == global.cThr, we have problems */%@AE@%%@NL@%
    }%@NL@%
    else%@NL@%
        i = 32767; %@AB@%/* should cause gp fault if used */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *  If the user wants the menu items updated, and we're switching%@NL@%
%@AB@%    *  away from an active thread, then uncheck the current thread's%@NL@%
%@AB@%    *  settings.%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    if (global.fUpdateMenusOnThreadSwitch)%@NL@%
    {%@NL@%
        if (global.pThrTop)%@NL@%
        {%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, IDM_AUTORESIZE);%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, IDM_AUTOSELECTDIMS);%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, IDM_CLEARONREDRAW);%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, IDM_AUTOSTARTREDRAW);%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, IDM_COLLECTBOUNDS);%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, IDM_FRACREDRAW);%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, IDM_PRIMREDRAW);%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, IDM_ATTRREDRAW);%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, global.pThrTop->usCurPrim);%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, global.pThrTop->usCurXform);%@NL@%
            UNCHECK_MENU_ITEM(global.hwndFrame, global.pThrTop->dcType);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *  Switch the given thread to the top.%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    DosEnterCritSec();%@NL@%
    global.iThrTop = i;%@NL@%
    global.pThrTop = pthr;%@NL@%
    DosExitCritSec();%@NL@%
%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%    *  If we switched in a living thread, then invalidate the entire%@NL@%
%@AB@%    *  window.        This will cause a WM_PAINT message to be sent, which%@NL@%
%@AB@%    *  will display the image from the new top thread.        If the user%@NL@%
%@AB@%    *  has not disabled updating of the menus, then do that.%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
    if (pthr)%@NL@%
    {%@NL@%
        WinInvalidateRect(global.hwnd, NULL, FALSE);%@NL@%
%@NL@%
        %@AB@%/* If the user wants menu items updated, then do it now. */%@AE@%%@NL@%
        if (global.fUpdateMenusOnThreadSwitch)%@NL@%
        {%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, IDM_AUTORESIZE,           pthr->fAutoSizePS);%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, IDM_AUTOSELECTDIMS,  pthr->fAutoSelectDims);%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, IDM_CLEARONREDRAW,   pthr->fClearOnRedraw);%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, IDM_AUTOSTARTREDRAW, pthr->fAutoStartRedraw);%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, IDM_COLLECTBOUNDS,   pthr->fCollectBounds);%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, IDM_FRACREDRAW,           pthr->fFracRedraw);%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, IDM_PRIMREDRAW,           pthr->fPrimRedraw);%@NL@%
            TOGGLE_MENU_ITEM(global.hwndFrame, IDM_ATTRREDRAW,           pthr->fAttrRedraw);%@NL@%
            CHECK_MENU_ITEM (global.hwndFrame, pthr->usCurPrim);%@NL@%
            CHECK_MENU_ITEM (global.hwndFrame, pthr->usCurXform);%@NL@%
            CHECK_MENU_ITEM (global.hwndFrame, pthr->dcType);%@NL@%
%@NL@%
            LfUpdateThreadMenu();%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfIsThreadTop%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Returns TRUE if the given thread is the top one.  Putting this%@NL@%
%@AB@%*   test in a function isolates it and makes it easier to maintain%@NL@%
%@AB@%*   a critical section.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL%@NL@%
LfIsThreadTop(pthr)%@NL@%
PTHR pthr;%@NL@%
{%@NL@%
    BOOL f;%@NL@%
%@NL@%
    f = FALSE;%@NL@%
    DosEnterCritSec();%@NL@%
    if (pthr == global.pThrTop)%@NL@%
        f = TRUE;%@NL@%
    DosExitCritSec();%@NL@%
%@NL@%
    return f;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfUpdateThreadMenu%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Brings the "Thread Bring thread to top" submenu in line with the%@NL@%
%@AB@%*   currently active threads.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfUpdateThreadMenu()%@NL@%
{%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Enable the numbers for threads that do exist.%@NL@%
%@AB@%     * Disable the numbers for threads that don't exist.%@NL@%
%@AB@%     * Uncheck everything, then check the right one.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    USHORT i;%@NL@%
%@NL@%
    for (i = 0; i < global.cThr; ++i)%@NL@%
    {%@NL@%
        UNCHECK_MENU_ITEM(global.hwndFrame, IDM_THR0TOTOP+i);%@NL@%
        ENABLE_MENU_ITEM (global.hwndFrame, IDM_THR0TOTOP+i);%@NL@%
    }%@NL@%
%@NL@%
    for (     ; i < MAX_THREADS; ++i)%@NL@%
    {%@NL@%
        UNCHECK_MENU_ITEM(global.hwndFrame, IDM_THR0TOTOP+i);%@NL@%
        DISABLE_MENU_ITEM(global.hwndFrame, IDM_THR0TOTOP+i);%@NL@%
    }%@NL@%
%@NL@%
    CHECK_MENU_ITEM(global.hwndFrame, IDM_THR0TOTOP + global.iThrTop);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LFUTIL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\LINEFRAC\LFUTIL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   lfutil.c -- Utility subroutines.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%"linefrac.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_LFUTIL %@NL@%
%@AI@%#include %@AE@%"lffuncs.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MySetWindowUShort%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Sets the given control id to the value specified.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MySetWindowUShort(hWnd, id, num)%@NL@%
HWND hWnd;%@NL@%
USHORT id;%@NL@%
USHORT num;%@NL@%
{%@NL@%
    char szStr[CCHSTR];%@NL@%
%@NL@%
    sprintf((NPCH)szStr, "%u", num);%@NL@%
    WinSetWindowText(WinWindowFromID(hWnd, id), (PCH)szStr);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MySetWindowLong%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Sets the given control id to the value specified.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MySetWindowLong(hWnd, id, num)%@NL@%
HWND hWnd;%@NL@%
USHORT id;%@NL@%
LONG num;%@NL@%
{%@NL@%
    char szStr[CCHSTR];%@NL@%
%@NL@%
    sprintf((NPCH)szStr, "%ld", num);%@NL@%
    WinSetWindowText(WinWindowFromID(hWnd, id), (PCH)szStr);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MySetWindowDouble%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Sets the given control id to the value specified.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MySetWindowDouble(hWnd, id, num)%@NL@%
HWND hWnd;%@NL@%
USHORT id;%@NL@%
double num;%@NL@%
{%@NL@%
    char szStr[CCHSTR];%@NL@%
%@NL@%
    sprintf((NPCH)szStr, "%lf", num);%@NL@%
    WinSetWindowText(WinWindowFromID(hWnd, id), (PCH)szStr);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MyGetWindowUShort%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Returns the value from the given control id.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MyGetWindowUShort(hWnd, id, pus)%@NL@%
HWND hWnd;%@NL@%
USHORT id;%@NL@%
PUSHORT pus;%@NL@%
{%@NL@%
    char szStr[CCHSTR];%@NL@%
%@NL@%
    WinQueryWindowText(WinWindowFromID(hWnd, id), CCHSTR, (PCH)szStr);%@NL@%
    *pus = atoi(szStr);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MyGetWindowLong%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Returns the value from the given control id.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MyGetWindowLong(hWnd, id, pl)%@NL@%
HWND hWnd;%@NL@%
USHORT id;%@NL@%
PLONG  pl;%@NL@%
{%@NL@%
    char szStr[CCHSTR];%@NL@%
%@NL@%
    WinQueryWindowText(WinWindowFromID(hWnd, id), CCHSTR, (PCH)szStr);%@NL@%
    *pl = atol(szStr);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MyGetWindowDouble%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Returns the value from the given control id.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MyGetWindowDouble(hWnd, id, pdbl)%@NL@%
HWND   hWnd;%@NL@%
USHORT id;%@NL@%
PDBL   pdbl;%@NL@%
{%@NL@%
    char szStr[CCHSTR];%@NL@%
%@NL@%
    WinQueryWindowText(WinWindowFromID(hWnd, id), CCHSTR, (PCH)szStr);%@NL@%
    *pdbl = atof(szStr);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   MyMessageBox%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Displays a message box with the given string.  To simplify matters,%@NL@%
%@AB@%*   the box will always have the same title ("LineFractal"), will always%@NL@%
%@AB@%*   have a single button ("Ok"), will always have an exclamation point%@NL@%
%@AB@%*   icon, and will always be application modal.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
MyMessageBox(hWnd, sz)%@NL@%
HWND hWnd;%@NL@%
PSZ sz;%@NL@%
{%@NL@%
    static char *szTitle = "LineFractal";%@NL@%
%@NL@%
    WinMessageBox(HWND_DESKTOP, hWnd, sz, szTitle, 0,%@NL@%
                  MB_OK|MB_ICONEXCLAMATION|MB_APPLMODAL);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LFXFORM.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\LINEFRAC\LFXFORM.C%@AE@%%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   lfxform.c -- Built-in similarity transforms.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"linefrac.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%SQRT_2        1.4142136 %@NL@%
%@AI@%#define %@AE@%SQRT_3        1.7320508 %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   SharkTooth%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Set up the similarity transform for the following linefractal,%@NL@%
%@AB@%*   which looks roughly like:%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*                                 *%@NL@%
%@AB@%*                     ===>      *   *%@NL@%
%@AB@%*                             *             *%@NL@%
%@AB@%*   ***************           *               *%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
LINEFRAC SharkTooth[] =%@NL@%
{%@NL@%
    &SharkTooth[1],  PI / 6.0, (1.0/SQRT_3), FALSE,%@NL@%
    EOLIST,            -PI / 3.0, (1.0/SQRT_3), FALSE%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   SawTooth%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Set up the similarity transform for the following linefractal,%@NL@%
%@AB@%*   which looks roughly like:%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*                     ===>      *%@NL@%
%@AB@%*                             *         *%@NL@%
%@AB@%*   ***************           *           *           *%@NL@%
%@AB@%*                                     *         *%@NL@%
%@AB@%*                                       *%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
LINEFRAC SawTooth[] =%@NL@%
{%@NL@%
    &SawTooth[1],  PI / 4.0, (0.5 / SQRT_2), FALSE,%@NL@%
    &SawTooth[2], -PI / 2.0, (1.0 / SQRT_2), FALSE,%@NL@%
    EOLIST,           PI / 2.0, (0.5 / SQRT_2), FALSE%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   KochIsland%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Set up the similarity transform for the following linefractal,%@NL@%
%@AB@%*   which looks roughly like:%@NL@%
%@AB@%*%@NL@%
%@AB@%*   This is known as the Koch, or snowflake, transform.%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*                                  *%@NL@%
%@AB@%*                     ===>        * *%@NL@%
%@AB@%*                                *   *%@NL@%
%@AB@%*   ***************           *****     *****%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
LINEFRAC Koch[] =%@NL@%
{%@NL@%
     &Koch[1],                 0.0, 1.0 / 3.0, FALSE,%@NL@%
     &Koch[2],            PI / 3.0, 1.0 / 3.0, FALSE,%@NL@%
     &Koch[3], -2 * PI / 3.0, 1.0 / 3.0, FALSE,%@NL@%
     EOLIST,            PI / 3.0, 1.0 / 3.0, FALSE%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   SpaceFiller%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Set up the similarity transform for the following linefractal,%@NL@%
%@AB@%*   which looks roughly like:%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*                           ***B******C***%@NL@%
%@AB@%*                           *                *%@NL@%
%@AB@%*                           A                D%@NL@%
%@AB@%*   **************   ===>  *                *%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*   where sides A and D are reflections.%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
LINEFRAC SpaceFiller[] =%@NL@%
{%@NL@%
    &SpaceFiller[1],  PI / 2.0, 0.5, TRUE,%@NL@%
    &SpaceFiller[2], -PI / 2.0, 0.5, FALSE,%@NL@%
    &SpaceFiller[3],           0.0, 0.5, FALSE,%@NL@%
    EOLIST,             -PI / 2.0, 0.5, TRUE%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   StovePipe%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Set up the similarity transform for the following linefractal,%@NL@%
%@AB@%*   which looks roughly like:%@NL@%
%@AB@%*%@NL@%
%@AB@%*   This is sometimes known as the stovepipe transform.%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*                               ******%@NL@%
%@AB@%*                               *    *%@NL@%
%@AB@%*                     ===>      *    *%@NL@%
%@AB@%*                               *    *%@NL@%
%@AB@%*   **************           *****    *****%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
LINEFRAC StovePipe[] =%@NL@%
{%@NL@%
    &StovePipe[1],         0.0, 1.0 / 3.0, FALSE,%@NL@%
    &StovePipe[2],  PI / 2.0, 1.0 / 3.0, FALSE,%@NL@%
    &StovePipe[3], -PI / 2.0, 1.0 / 3.0, FALSE,%@NL@%
    &StovePipe[4], -PI / 2.0, 1.0 / 3.0, FALSE,%@NL@%
    EOLIST,            PI / 2.0, 1.0 / 3.0, FALSE%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   SquareWave%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Set up the similarity transform for the following linefractal,%@NL@%
%@AB@%*   which looks roughly like:%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*                           ******%@NL@%
%@AB@%*                           *        *%@NL@%
%@AB@%*   **************   ===>  *        *    *%@NL@%
%@AB@%*                                *    *%@NL@%
%@AB@%*                                ******%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
LINEFRAC SquareWave[] =%@NL@%
{%@NL@%
    &SquareWave[1],  PI / 2.0, 0.25, FALSE,%@NL@%
    &SquareWave[2], -PI / 2.0, 0.5,  FALSE,%@NL@%
    &SquareWave[3], -PI / 2.0, 0.5,  FALSE,%@NL@%
    &SquareWave[4],  PI / 2.0, 0.5,  FALSE,%@NL@%
    EOLIST,             PI / 2.0, 0.25, FALSE%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   HourGlass%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Set up the similarity transform for the following linefractal,%@NL@%
%@AB@%*   which looks roughly like:%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*                              * * * * *%@NL@%
%@AB@%*                                *   *%@NL@%
%@AB@%*                                  *%@NL@%
%@AB@%*                     ===>        *   *%@NL@%
%@AB@%*                              *       *%@NL@%
%@AB@%*   **************            *                *%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%HOURGLASSANGLE        0.463648 %@NL@%
%@AI@%#define %@AE@%HOURGLASSLEN        0.83852549 %@NL@%
%@NL@%
LINEFRAC HourGlass[] =%@NL@%
{%@NL@%
    &HourGlass[1],     HOURGLASSANGLE, HOURGLASSLEN, FALSE,%@NL@%
    &HourGlass[2],  PI-HOURGLASSANGLE, 0.5,             FALSE,%@NL@%
    EOLIST,           -PI-HOURGLASSANGLE, HOURGLASSLEN, FALSE%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   aXform%@NL@%
%@AB@%*%@NL@%
%@AB@%*   This lists all the built-in transforms available, with their default%@NL@%
%@AB@%*   coordinate offsets and scale factors.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
XFORMDATA aXform[] =%@NL@%
{%@NL@%
    SharkTooth,  0.200,  0.200,  0.60, 0.60, 3,%@NL@%
    SawTooth,         0.125,  0.125,  0.75, 0.75, 3,%@NL@%
    Koch,         0.125,  0.125,  0.75, 0.75, 3,%@NL@%
    SpaceFiller, 0.000, -0.500,  1.00, 1.00, 1,%@NL@%
    StovePipe,         0.125,  0.125,  0.75, 0.75, 4,%@NL@%
    SquareWave,  0.200,  0.200,  0.60, 0.60, 5,%@NL@%
    HourGlass,         0.250,  0.250,  0.50, 0.50, 2%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LINEFRAC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\LINEFRAC\LINEFRAC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   linefrac.c -- Main window procedure for LineFractal window class.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#define %@AE@%INCL_DOSSEMAPHORES %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%_MT %@NL@%
%@AI@%#include %@AE@%<process.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GLOBALS %@NL@%
%@AI@%#define %@AE@%INCL_THREADS %@NL@%
%@AI@%#include %@AE@%"linefrac.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_LFMAIN %@NL@%
%@AI@%#define %@AE@%INCL_LFINIT %@NL@%
%@AI@%#define %@AE@%INCL_LFTHREAD %@NL@%
%@AI@%#define %@AE@%INCL_LFPS %@NL@%
%@AI@%#define %@AE@%INCL_LFCMD %@NL@%
%@AI@%#define %@AE@%INCL_LFDRAW %@NL@%
%@AI@%#include %@AE@%"lffuncs.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Global Variables%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
GLOBALDATA global;%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   main%@NL@%
%@AB@%*%@NL@%
%@AB@%*   WinInitialize resizes our ring 2 stack, among other things, so%@NL@%
%@AB@%*   we won't GP fault trying to do graphics.  WinCreateMsgQueue defines%@NL@%
%@AB@%*   us as a REAL PM app. (as does the WINDOWAPI in the .DEF file).%@NL@%
%@AB@%*   Call a subroutine to register our window class and create a window.%@NL@%
%@AB@%*   Loop over messages.  Exit cleanly.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID cdecl%@NL@%
main( VOID )%@NL@%
{%@NL@%
    QMSG qMsg;%@NL@%
    int iRet = 0;%@NL@%
%@NL@%
    global.hab         = WinInitialize(0);%@NL@%
    global.hMsgQ = WinCreateMsgQueue(global.hab, 0);%@NL@%
%@NL@%
    if (LfInitApp())%@NL@%
        while (WinGetMsg( global.hab, (PQMSG)&qMsg, (HWND)NULL, 0, 0 ))%@NL@%
            WinDispatchMsg( global.hab, (PQMSG)&qMsg );%@NL@%
    else%@NL@%
        iRet = -1;%@NL@%
%@NL@%
    WinDestroyWindow( global.hwndFrame );%@NL@%
    WinDestroyMsgQueue( global.hMsgQ );%@NL@%
    WinTerminate( global.hab );%@NL@%
    DosExit(EXIT_PROCESS, iRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LineFracWndProc%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Process messages for the LineFractal window class.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
ULONG CALLBACK%@NL@%
LineFracWndProc( hwnd, usMsg, mp1, mp2 )%@NL@%
HWND   hwnd;%@NL@%
USHORT usMsg;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
    HPS     hps;%@NL@%
    USHORT  iNewTop;%@NL@%
    USHORT  i;%@NL@%
    PTHR pthr;%@NL@%
    RECTL rcl;%@NL@%
    BOOL  fIsTimerUsed;%@NL@%
%@NL@%
    switch (usMsg)%@NL@%
    {%@NL@%
    case WM_CREATE:%@NL@%
        if ((global.hptr)[global.usCurPtr])%@NL@%
            WinSetPointer(HWND_DESKTOP,(global.hptr)[global.usCurPtr]);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CLOSE:%@NL@%
        LfClose(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        LfCommand(hwnd, LOUSHORT(mp1));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_TIMER:%@NL@%
        if (LOUSHORT(mp1) == IDT_AUTOSTARTREDRAW)%@NL@%
        {%@NL@%
            fIsTimerUsed = FALSE;%@NL@%
            for (i = 0; i < global.cThr; ++i)%@NL@%
                if (global.aThr[i]->fAutoStartRedraw)%@NL@%
                {%@NL@%
                    DosSemClear(&(global.aThr[i])->lSemRedraw);%@NL@%
                    fIsTimerUsed = TRUE;%@NL@%
                }%@NL@%
            if (!fIsTimerUsed)%@NL@%
                LfStopRedrawTimer();%@NL@%
            else%@NL@%
            {%@NL@%
                LfStopRedrawTimer();%@NL@%
                LfStartRedrawTimer();%@NL@%
            }%@NL@%
        }%@NL@%
        else if (LOUSHORT(mp1) == IDT_AUTOSWITCH)%@NL@%
        {%@NL@%
            DosEnterCritSec();%@NL@%
            iNewTop = (global.iThrTop + 1) % global.cThr;%@NL@%
            DosExitCritSec();%@NL@%
            LfBringThreadToTop(global.aThr[iNewTop]);%@NL@%
        }%@NL@%
        else%@NL@%
            goto pass_it_on;%@NL@%
        break;%@NL@%
%@NL@%
    case WM_ERASEBACKGROUND:%@NL@%
        LfEraseBackground(hwnd, NULL, NULL, NULL);%@NL@%
        return FALSE;%@NL@%
        break;%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        if (!global.pThrTop)%@NL@%
            WinSendMsg(hwnd, WM_COMMAND, (MPARAM)IDM_DCMEMORY, 0);%@NL@%
%@NL@%
        hps = WinBeginPaint(global.hwnd, NULL, &rcl);%@NL@%
        if (global.pThrTop)   %@AB@%/* only try to paint if we have a drawing */%@AE@%%@NL@%
            LfPaint(hps, &rcl);%@NL@%
        WinEndPaint(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CHAR:%@NL@%
        if (LOUSHORT(mp1) & KC_CHAR) %@NL@%
   {%@NL@%
     LfChar(hwnd, (CHAR)(USHORT)(ULONG)(mp2));%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1DOWN:%@NL@%
    case WM_BUTTON2DOWN:%@NL@%
        LfButtonDown(hwnd, mp1);%@NL@%
        WinSetFocus(HWND_DESKTOP, hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1UP:%@NL@%
    case WM_BUTTON2UP:%@NL@%
        LfButtonUp(usMsg);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_MOUSEMOVE:%@NL@%
        LfMouseMove();%@NL@%
        break;%@NL@%
%@NL@%
    case WM_SIZE:%@NL@%
        %@AB@%/* Resize each PS that has fAutoSizePS set to TRUE. */%@AE@%%@NL@%
%@NL@%
        WinQueryWindowRect(global.hwnd, &global.rcl);%@NL@%
        global.bm.cx = (USHORT) (global.rcl.xRight - global.rcl.xLeft);%@NL@%
        global.bm.cy = (USHORT) (global.rcl.yTop   - global.rcl.yBottom);%@NL@%
%@NL@%
        for (i = 0; i < global.cThr; ++i)%@NL@%
            if (pthr = global.aThr[i])%@NL@%
                if (pthr->hps)%@NL@%
                    if (pthr->fAutoSizePS)%@NL@%
                    {%@NL@%
                        global.bm.cPlanes   = pthr->cPlanes;%@NL@%
                        global.bm.cBitCount = pthr->cBitCount;%@NL@%
%@NL@%
                        if (LfResizePS(pthr))%@NL@%
                            DosSemClear(&pthr->lSemRedraw);%@NL@%
                    }%@NL@%
%@NL@%
        %@AB@%/* fall through -- we might want to restart point accumulation,%@NL@%
%@AB@%           but don't want to process the resize message */%@AE@%%@NL@%
%@NL@%
    default:%@NL@%
pass_it_on:%@NL@%
        return( (ULONG)WinDefWindowProc(hwnd, usMsg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfClose%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Kill all the threads still running and delete all our fancy pointers.%@NL@%
%@AB@%*   In general, prepare to terminate the program.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfClose(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    int i;%@NL@%
%@NL@%
    WinSendMsg(hwnd, WM_COMMAND, (MPARAM)IDM_KILLALLTHREADS, 0);%@NL@%
    WinSetPointer(HWND_DESKTOP,%@NL@%
                  WinQuerySysPointer(HWND_DESKTOP,SPTR_ARROW,FALSE));%@NL@%
    for (i = 0; i < NUM_PTR_SHAPES; ++i)%@NL@%
        if ((global.hptr)[i])%@NL@%
            WinDestroyPointer((global.hptr)[i]);%@NL@%
    if (global.hptrTrack)%@NL@%
        WinDestroyPointer(global.hptrTrack);%@NL@%
    if (global.hptrPaste)%@NL@%
        WinDestroyPointer(global.hptrPaste);%@NL@%
    WinPostMsg(hwnd, WM_QUIT, 0L, 0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfEraseBackground%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Erase the window background to a hatch pattern.  This enables the%@NL@%
%@AB@%*   user to see where the bitmap's edges are in case it's smaller%@NL@%
%@AB@%*   than the window.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfEraseBackground(hwnd, hpsCaller, prclUpdate, prclX)%@NL@%
HWND hwnd;%@NL@%
HPS hpsCaller;%@NL@%
PRECTL prclUpdate;%@NL@%
PRECTL prclX;        %@AB@%/* excluded rectangle */%@AE@%%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    RECTL rcl;%@NL@%
    RECTL rclT;%@NL@%
    AREABUNDLE ab;%@NL@%
    HRGN hrgnClipOld;%@NL@%
    HRGN hrgn;%@NL@%
    HRGN hrgnT;%@NL@%
%@NL@%
%@NL@%
    if (hpsCaller)%@NL@%
        hps = hpsCaller;%@NL@%
    else%@NL@%
        hps = WinGetPS(hwnd);%@NL@%
%@NL@%
    if (prclUpdate)%@NL@%
        rcl = *prclUpdate;%@NL@%
    else%@NL@%
        WinQueryUpdateRect(hwnd, (PRECTL)&rcl);%@NL@%
%@NL@%
    ab.lColor          = CLR_BLACK;%@NL@%
    ab.lBackColor = CLR_WHITE;%@NL@%
    ab.usSymbol   = PATSYM_DIAG1;%@NL@%
    GpiSetAttrs(hps, PRIM_AREA, ABB_COLOR|ABB_BACK_COLOR|ABB_SYMBOL,%@NL@%
                0L, (PBUNDLE)&ab);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Make a region out of the nearest rectangle, then copy the real%@NL@%
%@AB@%     * region data into it.  Set this as our clip rectangle.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((hrgn = GpiCreateRegion(hps, 1L, &rcl)) != HRGN_ERROR)%@NL@%
    {%@NL@%
        WinQueryUpdateRegion(hwnd, hrgn);%@NL@%
        GpiSetClipRegion(hps, hrgn, &hrgnClipOld);%@NL@%
    }%@NL@%
%@NL@%
    if (!prclX)%@NL@%
        GpiBitBlt(hps, NULL, 2L, (PPOINTL)&rcl, ROP_PATCOPY, 0L);%@NL@%
    else%@NL@%
    {%@NL@%
        if (prclX->yTop < rcl.yTop)%@NL@%
        {%@NL@%
            rclT.xLeft         = rcl.xLeft;%@NL@%
            rclT.yBottom = prclX->yBottom;%@NL@%
            rclT.xRight  = rcl.xRight;%@NL@%
            rclT.yTop         = rcl.yTop;%@NL@%
            GpiBitBlt(hps, NULL, 2L, (PPOINTL)&rclT, ROP_PATCOPY, 0L);%@NL@%
        }%@NL@%
%@NL@%
        if (prclX->xRight < rcl.xRight)%@NL@%
        {%@NL@%
            rclT.xLeft         = prclX->xRight;%@NL@%
            rclT.yBottom = rcl.yBottom;%@NL@%
            rclT.xRight  = rcl.xRight;%@NL@%
            rclT.yTop         = prclX->yTop;%@NL@%
            GpiBitBlt(hps, NULL, 2L, (PPOINTL)&rclT, ROP_PATCOPY, 0L);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (hrgnClipOld != HRGN_ERROR)%@NL@%
        GpiSetClipRegion(hps, hrgnClipOld, &hrgnT);%@NL@%
    if (hrgn != HRGN_ERROR)%@NL@%
        GpiDestroyRegion(hps, hrgn);%@NL@%
%@NL@%
    if (!hpsCaller)%@NL@%
        WinReleasePS(hps);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfPaint%@NL@%
%@AB@%*%@NL@%
%@AB@%*   If we have a bitmap, blt it to the screen, no matter what state%@NL@%
%@AB@%*   it's in.  If the selection rectangle is still alive, then display%@NL@%
%@AB@%*   it, too.  Note that it goes directly to the screen, so we have to%@NL@%
%@AB@%*   redraw it each time the bitmap is thrown back up.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfPaint(hps, prcl)%@NL@%
HPS  hps;%@NL@%
PRECTL prcl;%@NL@%
{%@NL@%
    POINTL  aptl[4];%@NL@%
%@NL@%
    if (global.pThrTop)%@NL@%
    {%@NL@%
        switch (global.pThrTop->dcType)%@NL@%
        {%@NL@%
        case IDM_DCDIRECT:        %@AB@%/* all drawing is already on the screen */%@AE@%%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_DCPOSTSCRIPT:%@NL@%
        case IDM_DCPROPRINTER:%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_DCMEMORY:%@NL@%
%@NL@%
            GpiSetAttrs(hps, PRIM_IMAGE, IBB_COLOR|IBB_BACK_COLOR, 0L, &global.pThrTop->ib);%@NL@%
%@NL@%
            aptl[0].x = 0L;%@NL@%
            aptl[0].y = 0L;%@NL@%
            aptl[1].x = (global.pThrTop->rcl).xRight;%@NL@%
            aptl[1].y = (global.pThrTop->rcl).yTop;%@NL@%
            aptl[2].x = 0L;%@NL@%
            aptl[2].y = 0L;%@NL@%
%@NL@%
            GpiBitBlt(hps, global.pThrTop->hps, 3L, aptl, ROP_SRCCOPY, (LONG)NULL);%@NL@%
            LfEraseBackground(global.hwnd, hps, prcl, &(global.pThrTop->rcl));%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            break;%@NL@%
        }%@NL@%
        if (global.fShowSelectRc)%@NL@%
            LfShowSelectRc(hps, global.fTempSelect ? &global.rclSelect : &global.rclCutCopy);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfShowSelectRc%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Draw the selection rectangle in the given presentation space.  The%@NL@%
%@AB@%*   rectangle is drawn in xor-mode so this can be called to remove it%@NL@%
%@AB@%*   as well as show it.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfShowSelectRc(hps, lprc)%@NL@%
HPS hps;%@NL@%
PRECTL lprc;%@NL@%
{%@NL@%
    LINEBUNDLE lb;%@NL@%
%@NL@%
%@NL@%
    lb.lColor         = CLR_TRUE;%@NL@%
    lb.usMixMode = FM_XOR;%@NL@%
    lb.usType         = LINETYPE_ALTERNATE;%@NL@%
    GpiSetAttrs(hps, PRIM_LINE, LBB_COLOR|LBB_MIX_MODE|LBB_TYPE,%@NL@%
                0L, (PBUNDLE)&lb);%@NL@%
    GpiSetCurrentPosition(hps, (POINTL *)&(lprc->xLeft));%@NL@%
    GpiBox(hps, DRO_OUTLINE, (POINTL *)&(lprc->xRight), 0L, 0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfChar%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Handle LineFractal's keyboard interface.  This consists of:%@NL@%
%@AB@%*%@NL@%
%@AB@%*   <space>        Cancels the selection rectangle.%@NL@%
%@AB@%*   0-9         Brings thread i to the top, if it exists.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfChar(hwnd, ch)%@NL@%
HWND hwnd;%@NL@%
char ch;%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    PRECTL lprc;%@NL@%
    USHORT i;%@NL@%
%@NL@%
    if (ch == ' ')%@NL@%
    {%@NL@%
        if (global.fShowSelectRc)%@NL@%
        {%@NL@%
            global.fShowSelectRc = FALSE;%@NL@%
            hps = WinGetPS(hwnd);%@NL@%
            if (global.fTempSelect)%@NL@%
            {%@NL@%
                lprc = &global.rclSelect;%@NL@%
                global.fTempSelect = FALSE;%@NL@%
            }%@NL@%
            else%@NL@%
                lprc = &global.rclCutCopy;%@NL@%
            LfShowSelectRc(hps, lprc);%@NL@%
            WinReleasePS(hps);%@NL@%
        }%@NL@%
    }%@NL@%
    else if (ch >= '0' && ch <= '9')%@NL@%
    {%@NL@%
        i = ch - '0';%@NL@%
        if (i < global.cThr)%@NL@%
            LfBringThreadToTop(global.aThr[i]);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfMouseMove%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Handle actions necessary upon each move of the mouse pointer.%@NL@%
%@AB@%*   This consists of resetting the mouse pointer -- if we pass%@NL@%
%@AB@%*   this on to WinDefWindowProc, it will reset it to the arrow.%@NL@%
%@AB@%*   As long as we're setting the pointer so often, we can do a%@NL@%
%@AB@%*   little animation.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfMouseMove()%@NL@%
{%@NL@%
    %@AB@%/* Do this so that if in tracking mode, the correct pointer%@NL@%
%@AB@%       shape appears immediately. */%@AE@%%@NL@%
    if (global.fTracking || global.fSelecting)%@NL@%
    {%@NL@%
        if (global.hptrTrack)%@NL@%
            WinSetPointer(HWND_DESKTOP,global.hptrTrack);%@NL@%
        return;%@NL@%
    }%@NL@%
    if (global.fPasting)%@NL@%
    {%@NL@%
        if (global.hptrPaste)%@NL@%
            WinSetPointer(HWND_DESKTOP,global.hptrPaste);%@NL@%
        return;%@NL@%
    }%@NL@%
    if (global.pThrTop)%@NL@%
    {%@NL@%
         if (global.pThrTop->fBusy)%@NL@%
         {%@NL@%
            if (global.hptrWait)%@NL@%
                WinSetPointer(HWND_DESKTOP,global.hptrWait);%@NL@%
            return;%@NL@%
         }%@NL@%
    }%@NL@%
    global.usPtrCounter = (global.usPtrCounter+1) % global.usPtrThreshold;%@NL@%
    if (global.usPtrCounter == 0)%@NL@%
    {%@NL@%
        global.usCurPtr += global.usPtrIncr;%@NL@%
        if (global.usCurPtr <= 0)%@NL@%
            global.usCurPtr = 0;%@NL@%
        else%@NL@%
            global.usCurPtr %= NUM_PTR_SHAPES;%@NL@%
        if ((global.usCurPtr == NUM_PTR_SHAPES - 1) ||%@NL@%
            (global.usCurPtr == 0))%@NL@%
            global.usPtrIncr *= -1;%@NL@%
    }%@NL@%
    if ((global.hptr)[global.usCurPtr])%@NL@%
        WinSetPointer(HWND_DESKTOP,(global.hptr)[global.usCurPtr]);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfButtonUp%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Handle up clicks of the mouse buttons.  This consists of:%@NL@%
%@AB@%*%@NL@%
%@AB@%*   left button up        increase the depth of recursion%@NL@%
%@AB@%*   right button up        decrease the depth of recursion%@NL@%
%@AB@%*%@NL@%
%@AB@%*                        In both cases, clear the semaphore so the%@NL@%
%@AB@%*                        drawing can restart at the new level of%@NL@%
%@AB@%*                        recursion.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfButtonUp(usMsg)%@NL@%
USHORT usMsg;%@NL@%
{%@NL@%
    if (global.fMouseChangesRecursion)%@NL@%
    {%@NL@%
        if (usMsg == WM_BUTTON1UP)%@NL@%
            global.pThrTop->usRecursion = ++global.pThrTop->usRecursion;%@NL@%
        else if (global.pThrTop->usRecursion > 0)%@NL@%
            global.pThrTop->usRecursion = --global.pThrTop->usRecursion;%@NL@%
%@NL@%
        global.pThrTop->flMiscAttrs |= LFA_RECURSION;%@NL@%
        global.pThrTop->fUpdateAttrs = TRUE;%@NL@%
        global.fUpdateAttrs = TRUE;%@NL@%
%@NL@%
        if (global.pThrTop->hps)%@NL@%
        {%@NL@%
            global.pThrTop->fInterrupted = TRUE;%@NL@%
            DosSemClear(&(global.pThrTop)->lSemRedraw);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfButtonDown%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Handle down clicks of the mouse buttons.  This consists of%@NL@%
%@AB@%*   changing the mouse pointer depending upon which mode we're in%@NL@%
%@AB@%*   and calling off to the subroutine to do the real work given%@NL@%
%@AB@%*   the position at which the mouse button was clicked.  The modes%@NL@%
%@AB@%*   are "tracking", "selecting", and "pasting".  Tracking means the%@NL@%
%@AB@%*   user is defining the new dimensions of the fractal.  Selecting%@NL@%
%@AB@%*   means the user is dragging a rectangle to cut or copy.  Pasting%@NL@%
%@AB@%*   means the user is positioning the cut or copied rectangle in%@NL@%
%@AB@%*   the window.%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfButtonDown(hwnd, mp1)%@NL@%
HWND hwnd;%@NL@%
MPARAM mp1;%@NL@%
{%@NL@%
    POINTS pt;%@NL@%
%@NL@%
    if (global.fTracking)%@NL@%
    {%@NL@%
        if (global.hptrTrack)%@NL@%
            WinSetPointer(HWND_DESKTOP,global.hptrTrack);%@NL@%
        pt.x = LOUSHORT(mp1);%@NL@%
        pt.y = HIUSHORT(mp1);%@NL@%
        LfSelectDimension(hwnd, pt);%@NL@%
        global.fTracking = FALSE;%@NL@%
        if ((global.hptr)[global.usCurPtr])%@NL@%
            WinSetPointer(HWND_DESKTOP,(global.hptr)[global.usCurPtr]);%@NL@%
        if (global.pThrTop->fAttrRedraw)%@NL@%
        {%@NL@%
            global.pThrTop->fInterrupted = TRUE;%@NL@%
            DosSemClear(&(global.pThrTop)->lSemRedraw);%@NL@%
        }%@NL@%
    }%@NL@%
    else if (global.fSelecting)%@NL@%
    {%@NL@%
        if (global.hptrTrack)%@NL@%
            WinSetPointer(HWND_DESKTOP,global.hptrTrack);%@NL@%
        pt.x = LOUSHORT(mp1);%@NL@%
        pt.y = HIUSHORT(mp1);%@NL@%
        LfSelect(hwnd, pt);%@NL@%
        global.fSelecting = FALSE;%@NL@%
        if ((global.hptr)[global.usCurPtr])%@NL@%
            WinSetPointer(HWND_DESKTOP,(global.hptr)[global.usCurPtr]);%@NL@%
    }%@NL@%
    else if (global.fPasting)%@NL@%
    {%@NL@%
        if (global.hptrPaste)%@NL@%
            WinSetPointer(HWND_DESKTOP,global.hptrPaste);%@NL@%
        pt.x = LOUSHORT(mp1);%@NL@%
        pt.y = HIUSHORT(mp1);%@NL@%
        LfPaste(hwnd);%@NL@%
        global.fPasting = FALSE;%@NL@%
        if ((global.hptr)[global.usCurPtr])%@NL@%
            WinSetPointer(HWND_DESKTOP,(global.hptr)[global.usCurPtr]);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfStartRedrawTimer%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfStartRedrawTimer()%@NL@%
{%@NL@%
    USHORT timeout;%@NL@%
%@NL@%
    if (!global.fTimerOn)%@NL@%
    {%@NL@%
        timeout = (USHORT) ((rand()/32767.0) *%@NL@%
                  (global.usMaxTimerDelay  - global.usMinTimerDelay) +%@NL@%
                   global.usMinTimerDelay);%@NL@%
        WinStartTimer(global.hab, global.hwnd, IDT_AUTOSTARTREDRAW, timeout);%@NL@%
        global.fTimerOn = TRUE;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*   LfStopRedrawTimer%@NL@%
%@AB@%*%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID%@NL@%
LfStopRedrawTimer()%@NL@%
{%@NL@%
    WinStopTimer(global.hab, global.hwnd, IDT_AUTOSTARTREDRAW);%@NL@%
    global.fTimerOn = FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LINK.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\MSNGR\LINK.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** MODULE Header ******************************\%@NL@%
%@AB@%* Module Name:  link.c - Messenger application - link module%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created: 8/1/89  sanfords%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"msngr.h" %@NL@%
%@AI@%#include %@AE@%"string.h" %@NL@%
%@NL@%
extern HWND hwndMsngr;%@NL@%
extern HPOINTER hptrLink;%@NL@%
extern SHORT cyText;%@NL@%
extern HAB hab;%@NL@%
extern HSZ hszAppName;%@NL@%
extern HSZ hszEmailName;%@NL@%
extern NPUSERLIST gnpUL;%@NL@%
extern PFNWP lpfnSysEFWndProc;   %@AB@%/* holds the system edit control proc */%@AE@%%@NL@%
%@NL@%
typedef struct _LINKDATA {%@NL@%
    NPUSERLIST pUserItem;%@NL@%
    USHORT state;%@NL@%
    HWND hwndTextIn;%@NL@%
    char **ppszText;%@NL@%
    char szOut[MAX_LINKSTR + 1];%@NL@%
    USHORT cLines;%@NL@%
    USHORT iTop;%@NL@%
} LINKDATA;%@NL@%
typedef LINKDATA *NPLINKDATA;%@NL@%
%@NL@%
PFNWP lpfnStaticWndProc;%@NL@%
%@NL@%
char **AllocTextIn(USHORT cLines);%@NL@%
void FreeTextIn(char **ppsz, USHORT cLines);%@NL@%
void AddTextIn(NPLINKDATA pLinkData, PSZ pszTextIn);%@NL@%
MRESULT EXPENTRY MyTextInWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2);%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   This creates a link window with control data set up as dictated by the%@NL@%
%@AB@%*   parameters given.  state incidates whether the window was created by%@NL@%
%@AB@%*   user or ddeml action.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/18/89     Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
BOOL CreateLinkWindow(pUserItem, state)%@NL@%
NPUSERLIST pUserItem;%@NL@%
USHORT state;%@NL@%
{%@NL@%
    NPLINKDATA pLinkData;%@NL@%
%@NL@%
%@NL@%
    if (pUserItem->hwndLink != 0) {%@NL@%
        WinDestroyWindow(pUserItem->hwndLink);%@NL@%
        pUserItem->hwndLink = 0;%@NL@%
    }%@NL@%
        %@NL@%
    if (!(pLinkData = (NPLINKDATA)WinAllocMem(hheap, sizeof(LINKDATA)))) {%@NL@%
        NotifyUser(SZMEMORYERROR);%@NL@%
        return(0);%@NL@%
    }%@NL@%
    %@NL@%
    pLinkData->pUserItem = pUserItem;%@NL@%
    pLinkData->state = state;%@NL@%
    pUserItem->hwndLink = WinLoadDlg(HWND_DESKTOP, hwndMsngr, LinkDlgProc,%@NL@%
            0L, IDD_LINK, (PVOID)pLinkData);%@NL@%
            %@NL@%
    if (!WinPostMsg(pUserItem->hwndLink, UM_LINK1, 0L, 0L)) {%@NL@%
        WinDestroyWindow(pUserItem->hwndLink);%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
char **AllocTextIn(cLines)%@NL@%
USHORT cLines;%@NL@%
{%@NL@%
    char **ppsz, *psz;%@NL@%
    %@NL@%
    if (!(ppsz = (char **)WinAllocMem(hheap,%@NL@%
            cLines * (MAX_LINKSTR + 1 + sizeof(NPSZ)))))%@NL@%
        return(0);%@NL@%
    psz = (char *)(ppsz + cLines);%@NL@%
    while (cLines--) {%@NL@%
        ppsz[cLines] = psz;%@NL@%
        *psz = '\0';%@NL@%
        psz += MAX_LINKSTR + 1;%@NL@%
    }%@NL@%
    return(ppsz);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void FreeTextIn(ppsz, cLines)%@NL@%
char **ppsz;%@NL@%
USHORT cLines;%@NL@%
{%@NL@%
    WinFreeMem(hheap, (NPBYTE)ppsz, cLines * (MAX_LINKSTR + 1 + sizeof(NPSZ)));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void AddTextIn(pLinkData, pszTextIn)%@NL@%
NPLINKDATA pLinkData;%@NL@%
PSZ pszTextIn;%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    RECTL rcl;%@NL@%
    USHORT cchOut, cLines;%@NL@%
    CHAR ch;%@NL@%
    %@NL@%
    hps = WinGetPS(pLinkData->hwndTextIn);%@NL@%
    %@NL@%
    cLines = 0;%@NL@%
    WinQueryWindowRect(pLinkData->hwndTextIn, &rcl);%@NL@%
    while (*pszTextIn) {%@NL@%
        cchOut = WinDrawText(hps, -1, pszTextIn, &rcl, 0L, 0L,%@NL@%
                DT_LEFT | DT_BOTTOM | DT_WORDBREAK | DT_QUERYEXTENT);%@NL@%
        ch = pszTextIn[cchOut];%@NL@%
        pszTextIn[cchOut] = '\0';%@NL@%
        lstrcpy(pLinkData->ppszText[pLinkData->iTop++], pszTextIn);%@NL@%
        if (pLinkData->iTop == pLinkData->cLines)%@NL@%
            pLinkData->iTop = 0;%@NL@%
        pszTextIn[cchOut] = ch;%@NL@%
        pszTextIn += cchOut;%@NL@%
        while (*pszTextIn == ' ')%@NL@%
           pszTextIn++;%@NL@%
        cLines++;%@NL@%
    }%@NL@%
    WinReleasePS(hps);%@NL@%
    WinQueryWindowRect(pLinkData->hwndTextIn, &rcl);%@NL@%
    WinScrollWindow(pLinkData->hwndTextIn, 0, cyText * cLines,%@NL@%
            NULL, &rcl, NULL, NULL, SW_INVALIDATERGN);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   This is a state-driven dialog which allows user linking.  At createion%@NL@%
%@AB@%*   time the control data is set to contain information on who this link%@NL@%
%@AB@%*   is with, and why this window was created. (user action or another user%@NL@%
%@AB@%*   requesting a link.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/18/89     Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY LinkDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    register NPLINKDATA pLinkData;%@NL@%
    register NPUSERLIST pUserItem;%@NL@%
    char szName[MAX_NAMESTR + 1];%@NL@%
    char szTitle[MAX_TITLESTR + 1];%@NL@%
    SWP swp;%@NL@%
%@NL@%
    if (pLinkData = (NPLINKDATA)WinQueryWindowUShort(hwnd, QWS_USER))%@NL@%
        pUserItem = pLinkData->pUserItem;%@NL@%
%@NL@%
    switch(msg) {%@NL@%
    case WM_INITDLG:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * This is required because currently, automatic ICON resource loading%@NL@%
%@AB@%         * is not supported for dialogs.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (hptrLink == 0) {%@NL@%
            hptrLink = WinLoadPointer(HWND_DESKTOP, NULL, IDD_LINK);%@NL@%
        }%@NL@%
        WinSendMsg(hwnd, WM_SETICON, (MPARAM)hptrLink, 0L);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * we are initialized with a (near) pointer to a LINKDATA structure.%@NL@%
%@AB@%         * Keep it in our window words.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        pLinkData = (NPLINKDATA)(USHORT)mp2;%@NL@%
        WinSetWindowUShort(hwnd, QWS_USER, (USHORT)pLinkData);%@NL@%
        pLinkData->hwndTextIn = WinWindowFromID(hwnd, IDC_TEXTIN);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * set the output window so it is a integral multiple of cyText%@NL@%
%@AB@%         * high.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinQueryWindowPos(pLinkData->hwndTextIn, &swp);%@NL@%
        swp.cy -= swp.cy % cyText;%@NL@%
        pLinkData->cLines = swp.cy / cyText;%@NL@%
        pLinkData->iTop = 0;%@NL@%
        swp.fs = SWP_SIZE;%@NL@%
        WinSetMultWindowPos(hab, &swp, 1);%@NL@%
        %@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * set up constants used for text output.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        lpfnStaticWndProc = WinSubclassWindow(pLinkData->hwndTextIn,%@NL@%
                MyTextInWndProc);%@NL@%
        pLinkData->cLines = swp.cy / cyText;%@NL@%
        pLinkData->ppszText = AllocTextIn(pLinkData->cLines);%@NL@%
        %@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * subclass the edit control so that enter keys send us a message.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        lpfnSysEFWndProc =%@NL@%
                WinSubclassWindow(WinWindowFromID(hwnd, IDC_EF_TEXTOUT),%@NL@%
                EnhancedEFWndProc);%@NL@%
                %@NL@%
        WinSendDlgItemMsg(hwnd, IDC_EF_TEXTOUT, EM_SETTEXTLIMIT,%@NL@%
                MPFROMSHORT(MAX_LINKSTR), 0L);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * return 1 so we don't get the focus - we are still invisible!%@NL@%
%@AB@%         */%@AE@%%@NL@%
        return(1);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         *      Terminate advise loop.%@NL@%
%@AB@%         *      Destroy connection if made%@NL@%
%@AB@%         *          advise loops first.%@NL@%
%@AB@%         *      free control data%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (pUserItem->hConvLink) {%@NL@%
            if (pLinkData->state == LNKST_LINKED) {%@NL@%
                DdeClientXfer(0, 0L, pUserItem->hConvLink,%@NL@%
                        hszEmailName, %@NL@%
                        DDEFMT_TEXT, XTYP_ADVSTOP, ulTimeout, NULL);%@NL@%
            }%@NL@%
            DdeDisconnect(pUserItem->hConvLink);%@NL@%
            pUserItem->hConvLink = 0;%@NL@%
        }%@NL@%
        FreeTextIn(pLinkData->ppszText, pLinkData->cLines);%@NL@%
        WinFreeMem(hheap, (NPBYTE)pLinkData, sizeof(LINKDATA));%@NL@%
        pUserItem->hwndLink = 0;%@NL@%
        break;%@NL@%
%@NL@%
    case UM_LINK1:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * connect on link channel - topic = server name.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (!pUserItem->hConvLink && !(pUserItem->hConvLink =%@NL@%
                DdeConnect(hszAppName, pUserItem->hsz, NULL, (HAPP)mp1))) {%@NL@%
            if (pLinkData->state == LNKST_USERSTART) %@NL@%
                NotifyUser(SZCANTLINK);%@NL@%
            return(FALSE);%@NL@%
        }%@NL@%
        %@NL@%
        if (pLinkData->state == LNKST_USERSTART) {%@NL@%
            return(WinSendMsg(hwnd, UM_DOADVSTART, 0L, 0L));%@NL@%
        } else {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * We were started by a ddeml advise message - return now%@NL@%
%@AB@%             * and post an advise start message to ourselves so we send%@NL@%
%@AB@%             * it AFTER we returned from his advise.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinPostMsg(hwnd, UM_DOADVSTART, 0L, 0L);%@NL@%
            return(TRUE);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case UM_DOADVSTART:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Its time to start the advise loop...return fSuccess %@NL@%
%@AB@%         *%@NL@%
%@AB@%         * Item = client name.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (DdeClientXfer(0, 0L, pUserItem->hConvLink, hszEmailName,%@NL@%
                DDEFMT_TEXT, XTYP_ADVSTART, ulTimeout, NULL)) {%@NL@%
            DdeGetHszString(hszEmailName, szName, MAX_NAMESTR + 1L);%@NL@%
            lstrcat(szTitle, szName, SZMSGLINKWITH);%@NL@%
            DdeGetHszString(pUserItem->hsz, szName, MAX_NAMESTR + 1L);%@NL@%
            lstrcat(szTitle, szTitle, szName);%@NL@%
            WinSetDlgItemText(hwnd, FID_TITLEBAR, szTitle);%@NL@%
            if (pLinkData->state == LNKST_DMGSTART) {%@NL@%
                pLinkData->state = LNKST_LINKED;%@NL@%
                WinSetDlgItemText(hwnd, IDC_INFO, SZLINKED);%@NL@%
            }%@NL@%
            WinShowWindow(hwnd, TRUE);%@NL@%
            return(TRUE);%@NL@%
%@NL@%
        } else {%@NL@%
            if (pLinkData->state == LNKST_USERSTART)%@NL@%
                MyPostError(DdeGetLastError());%@NL@%
            else%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * destroy ouselves lest we have an invisible link window%@NL@%
%@AB@%                 * hanging around.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                WinDestroyWindow(hwnd);%@NL@%
            return(FALSE);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case UM_ADVRCVD:%@NL@%
        if (pLinkData->state == LNKST_USERSTART) {%@NL@%
            pLinkData->state = LNKST_LINKED;%@NL@%
            WinSetDlgItemText(hwnd, IDC_INFO, SZLINKED);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case UM_LINKDATAIN:%@NL@%
        AddTextIn(pLinkData, (PSZ)mp1);%@NL@%
        break;%@NL@%
%@NL@%
    case UM_BREAKLINK:%@NL@%
        if (pLinkData->state == LNKST_LINKED) {%@NL@%
            NotifyUser(SZLINKBROKEN);%@NL@%
            if (WinIsWindow(hab, hwnd))%@NL@%
                WinDestroyWindow(hwnd);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_WINDOWPOSCHANGED:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * hide the Edit control when minimized since it messes up the icon.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((LONG)mp2 & AWP_MINIMIZED)%@NL@%
            WinShowWindow(WinWindowFromID(hwnd, IDC_EF_TEXTOUT), FALSE);%@NL@%
        else if ((LONG)mp2 & AWP_RESTORED)%@NL@%
            WinShowWindow(WinWindowFromID(hwnd, IDC_EF_TEXTOUT), TRUE);%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
        %@NL@%
    case WM_COMMAND:%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
        case IDC_TERMINATE:%@NL@%
            if (pLinkData->state == LNKST_LINKED) {%@NL@%
                pLinkData->state = LNKST_UNLINKED;%@NL@%
                DdeClientXfer(0, 0L, pUserItem->hConvLink, hszEmailName,%@NL@%
                        DDEFMT_TEXT, XTYP_ADVSTOP, ulTimeout, NULL);%@NL@%
            }%@NL@%
            WinDestroyWindow(hwnd);%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case ENHAN_ENTER:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * when the user hits the enter key, it will be passed from the%@NL@%
%@AB@%         * entryfield to here and we will send it to the linkee.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinQueryDlgItemText(hwnd, IDC_EF_TEXTOUT, MAX_LINKSTR + 1,%@NL@%
                pLinkData->szOut);%@NL@%
        WinSetDlgItemText(hwnd, IDC_EF_TEXTOUT, "");%@NL@%
        if (pLinkData->state == LNKST_LINKED)%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * we postadvise to OUR server which is talking to HIS client%@NL@%
%@AB@%             * which has the topic being OUR name and the item being HIS.%@NL@%
%@AB@%             * This results in a UM_LINKDATAOUT being sent to us.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            DdePostAdvise(hszEmailName, pUserItem->hsz);%@NL@%
        break;%@NL@%
%@NL@%
    case UM_LINKDATAOUT:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * returns hDmgData filled.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (pLinkData->state == LNKST_LINKED) {%@NL@%
            return(DdePutData(pLinkData->szOut,%@NL@%
                    (ULONG)(lstrlen(pLinkData->szOut) + 1), 0L,%@NL@%
                    pUserItem->hsz, DDEFMT_TEXT, 0));%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   This function gains control whenever externaly trigered data transfers%@NL@%
%@AB@%*   are sent to the hszEmailName topic.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/17/89     Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA LinkXfer(pXferInfo, hszPartner)%@NL@%
PXFERINFO pXferInfo;%@NL@%
HSZ hszPartner;%@NL@%
{%@NL@%
    NPUSERLIST pUserItem;%@NL@%
    char szTextIn[MAX_LINKSTR + 1];%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * always allow creation of servers on this topic.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pXferInfo->usType == XTYP_INIT)%@NL@%
        return(TRUE);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * we only allow text%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pXferInfo->usFmt != DDEFMT_TEXT)%@NL@%
        return(0);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * if he's gone, this should never happen.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!(pUserItem = FindUser(gnpUL, hszPartner))) {%@NL@%
        NotifyUser(SZINTERNALERROR);%@NL@%
        return(0);%@NL@%
    }%@NL@%
%@NL@%
    if (pXferInfo->usType == XTYP_ADVSTART) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * link Advise startup - if no hwndLink, he started it, we must%@NL@%
%@AB@%         * create a link window and a counter advise loop.  If we do%@NL@%
%@AB@%         * have a hwndLink, we started it and it is his counter advise%@NL@%
%@AB@%         * link request.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (!WinIsWindow(hab, pUserItem->hwndLink)) {%@NL@%
            return((HDMGDATA)CreateLinkWindow(pUserItem, LNKST_DMGSTART));%@NL@%
        } else {%@NL@%
            WinSendMsg(pUserItem->hwndLink, UM_ADVRCVD, 0L, 0L);%@NL@%
            return(DDE_FACK);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * The rest of these are only applicable if we are in an active link%@NL@%
%@AB@%     * situation, so quit if no link window is present.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!WinIsWindow(hab, pUserItem->hwndLink)) %@NL@%
        return(0);%@NL@%
%@NL@%
    switch (pXferInfo->usType) {%@NL@%
    case XTYP_ADVDATA:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * incomming link data%@NL@%
%@AB@%         */%@AE@%%@NL@%
        DdeGetData(pXferInfo->hDmgData, szTextIn, (ULONG)(MAX_LINKSTR + 1), 0L);%@NL@%
        DdeFreeData(pXferInfo->hDmgData);%@NL@%
        WinSendMsg(pUserItem->hwndLink, UM_LINKDATAIN, (MPARAM)szTextIn, 0L);%@NL@%
        return(DDE_FACK);%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_REQUEST:%@NL@%
    case XTYP_ADVREQ:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Outgoing link data%@NL@%
%@AB@%         */%@AE@%%@NL@%
        return((HDMGDATA)WinSendMsg(pUserItem->hwndLink, UM_LINKDATAOUT, 0L, 0L));%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_ADVSTOP:%@NL@%
        WinSendMsg(pUserItem->hwndLink, UM_BREAKLINK, 0L, 0L);%@NL@%
        return(TRUE);%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY MyTextInWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    register NPLINKDATA pLinkData;%@NL@%
    RECTL rcl;%@NL@%
    HPS hps;%@NL@%
    USHORT iLine, cLines;%@NL@%
    %@NL@%
    switch (msg) {%@NL@%
    case WM_PAINT:%@NL@%
        hps = WinBeginPaint(hwnd, NULL, &rcl);%@NL@%
        pLinkData = (NPLINKDATA)WinQueryWindowUShort(%@NL@%
                WinQueryWindow(hwnd, QW_PARENT, FALSE), QWS_USER);%@NL@%
        WinQueryWindowRect(hwnd, &rcl);%@NL@%
        rcl.yBottom = rcl.yTop - cyText;%@NL@%
        %@NL@%
        iLine = pLinkData->iTop;%@NL@%
        cLines = pLinkData->cLines;%@NL@%
        while (cLines--) {%@NL@%
            WinDrawText(hps, -1, pLinkData->ppszText[iLine++], &rcl, 0L, 0L,%@NL@%
                    DT_LEFT | DT_VCENTER | DT_ERASERECT | DT_TEXTATTRS);%@NL@%
            if (iLine == pLinkData->cLines)%@NL@%
                iLine = 0;%@NL@%
            WinOffsetRect(hab, &rcl, 0, -cyText);%@NL@%
        }%@NL@%
        WinEndPaint(hps);%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return((*lpfnStaticWndProc)(hwnd, msg, mp1, mp2));%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MDI.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\MDI\MDI.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* mdi.c - MDI application%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINCOMMON %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINRECTANGLES %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"app.h" %@NL@%
%@AI@%#include %@AE@%"appdata.h" %@NL@%
%@AI@%#include %@AE@%"mdi.h" %@NL@%
%@AI@%#include %@AE@%"mdidata.h" %@NL@%
%@NL@%
VOID MDIDesktopSize(HWND hwnd, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    HWND hwndDoc;%@NL@%
    RECTL rclWindow;%@NL@%
    POINTL ptlBorderSize;%@NL@%
    HENUM henum;%@NL@%
    SWP swp;%@NL@%
    ULONG ulStyle;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * This code keeps maximized MDI windows maximized within the%@NL@%
%@AB@%     * main client window and bottom-left aligns minimized windows.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinQueryWindowRect(hwnd, (PRECTL)&rclWindow);%@NL@%
%@NL@%
    WinSendMsg(hwndMDIFrame, WM_QUERYBORDERSIZE, (MPARAM)&ptlBorderSize,%@NL@%
            0L);%@NL@%
    WinInflateRect(NULL, (PRECTL)&rclWindow, (SHORT)ptlBorderSize.x,%@NL@%
            (SHORT)ptlBorderSize.y);%@NL@%
    rclWindow.yTop += cyTitlebar;%@NL@%
%@NL@%
    swp.hwndInsertBehind = NULL;%@NL@%
%@NL@%
    henum = WinBeginEnumWindows(hwnd);%@NL@%
    while (hwndDoc = WinGetNextWindow(henum)) {%@NL@%
        WinLockWindow(hwndDoc, FALSE);%@NL@%
        ulStyle = WinQueryWindowULong(hwndDoc, QWL_STYLE);%@NL@%
        if (ulStyle & WS_MAXIMIZED) {%@NL@%
            swp.hwnd = hwndDoc;%@NL@%
            swp.x = (SHORT)rclWindow.xLeft;%@NL@%
            swp.y = (SHORT)rclWindow.yBottom;%@NL@%
            swp.cx = (SHORT)rclWindow.xRight - (SHORT)rclWindow.xLeft;%@NL@%
            swp.cy = (SHORT)rclWindow.yTop - (SHORT)rclWindow.yBottom;%@NL@%
            swp.fs = SWP_MOVE | SWP_SIZE;%@NL@%
            WinSetMultWindowPos(NULL, (PSWP)&swp, 1);%@NL@%
        } else if (ulStyle & WS_MINIMIZED) {%@NL@%
%@NL@%
            WinQueryWindowPos(hwndDoc, &swp);%@NL@%
%@NL@%
            swp.x = 0;%@NL@%
            swp.y = 0;%@NL@%
            swp.fs = SWP_MOVE | SWP_ZORDER;%@NL@%
            swp.hwndInsertBehind = HWND_BOTTOM;%@NL@%
%@NL@%
       %@AB@%/*%@NL@%
%@AB@%            swp.y -= (SHORT2FROMMP(mp2) - SHORT2FROMMP(mp1));%@NL@%
%@AB@%            swp.fs = SWP_MOVE;%@NL@%
%@AB@%       */%@AE@%%@NL@%
            WinSetMultWindowPos(NULL, (PSWP)&swp, 1);%@NL@%
%@NL@%
        }%@NL@%
    }%@NL@%
    WinEndEnumWindows(henum);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Adjust yNextNewDoc to keep it top-left aligned.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    yNextNewDoc += (SHORT2FROMMP(mp2) - SHORT2FROMMP(mp1));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID MDIDesktopSetFocus(HWND hwnd, MPARAM mp2)%@NL@%
{%@NL@%
    HWND hwndTopDoc;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If we're getting the focus and there is a document window,%@NL@%
%@AB@%     * set the focus to the top-most document window so the main%@NL@%
%@AB@%     * client window never has the focus.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((SHORT1FROMMP(mp2) != FALSE) &&%@NL@%
            (hwndTopDoc = WinQueryWindow(hwnd, QW_TOP, FALSE))) {%@NL@%
        WinSetFocus(HWND_DESKTOP, hwndTopDoc);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID MDIDesktopActivateDoc(SHORT idMenuitem)%@NL@%
{%@NL@%
    register NPDOC npdoc;%@NL@%
%@NL@%
    npdoc = npdocFirst;%@NL@%
    while (npdoc != NULL) {%@NL@%
        if (npdoc->idMI == (USHORT) idMenuitem) {%@NL@%
            WinSetFocus(HWND_DESKTOP, npdoc->hwndFrame);%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If the document is minimized then%@NL@%
%@AB@%             * restore it as well.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (WinQueryWindowULong(npdoc->hwndFrame, QWL_STYLE) &%@NL@%
                    WS_MINIMIZED) {%@NL@%
                WinSetWindowPos(npdoc->hwndFrame, NULL,%@NL@%
                        0, 0, 0, 0, SWP_RESTORE);%@NL@%
            }%@NL@%
            break;%@NL@%
        }%@NL@%
        npdoc = npdoc->npdocNext;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
MRESULT EXPENTRY MainFrameWndProc(HWND hwnd, USHORT msg, MPARAM mp1,%@NL@%
        MPARAM mp2)%@NL@%
{%@NL@%
    HWND hwndAppMenu;%@NL@%
    NPDOC npdoc;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_NEXTMENU:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Connect child sysmenu with application menus%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        npdoc=NPDOCFROMCLIENT(WinWindowFromID(hwndActiveDoc, FID_CLIENT));%@NL@%
%@NL@%
        if (npdoc->fAabSysMenu == TRUE) {%@NL@%
            %@AB@%/* child sysmenu is already in app menu */%@AE@%%@NL@%
            return (*pfnMainFrameWndProc)(hwnd, msg, mp1, mp2);%@NL@%
            }%@NL@%
%@NL@%
%@AI@%#define %@AE@%hwndCurrent HWNDFROMMP(mp1) %@NL@%
%@NL@%
        hwndAppMenu=NPDOCFROMCLIENT(WinWindowFromID(hwndActiveDoc, FID_CLIENT))%@NL@%
                        ->hwndMainMenu;%@NL@%
%@NL@%
        if (((hwndCurrent == hwndSysMenu) && !SHORT1FROMMP(mp2)) ||%@NL@%
                ((hwndCurrent == hwndAppMenu) && SHORT1FROMMP(mp2))) {%@NL@%
%@NL@%
            if (hwndActiveDoc)%@NL@%
                return (WinWindowFromID(hwndActiveDoc, FID_SYSMENU));%@NL@%
        }%@NL@%
%@NL@%
%@AI@%#undef %@AE@%hwndCurrent %@NL@%
%@NL@%
        break;%@NL@%
    }%@NL@%
    return (*pfnMainFrameWndProc)(hwnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MDIDATA.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\MDI\MDIDATA.C%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINCOMMON %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINACCELERATORS %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"app.h" %@NL@%
%@AI@%#include %@AE@%"mdi.h" %@NL@%
%@NL@%
char szSplitbarClass[] = "PM MDI Splitbar";%@NL@%
USHORT usDocNumber = 0, cDocs = 0;%@NL@%
USHORT cxVertSplitbar, cyHorzSplitbar, cxSplitbarCenter, cySplitbarCenter;%@NL@%
SHORT cxNewDoc, cyNewDoc, xCascadeInc, yCascadeInc;%@NL@%
SHORT xNextNewDoc, yNextNewDoc;%@NL@%
SHORT xCascadeSlot;%@NL@%
SHORT cyTitlebar, cxMinmaxButton;%@NL@%
%@NL@%
%@AB@%/* Frame subclassing globals */%@AE@%%@NL@%
PFNWP pfnFrameWndProc;%@NL@%
PFNWP pfnMainFrameWndProc;%@NL@%
%@NL@%
%@AB@%/* Main MDI globals */%@AE@%%@NL@%
HDC hdcMem;%@NL@%
HPS hpsMem;%@NL@%
HPOINTER hptrHorzSplit, hptrVertSplit, hptrHVSplit, hptrArrow;%@NL@%
%@NL@%
%@AB@%/* Menu globals */%@AE@%%@NL@%
HBITMAP hbmChildSysMenu, hbmAabChildSysMenu;%@NL@%
MENUITEM miAabSysMenu;%@NL@%
HWND hwndFirstMenu;%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MDIDOC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\MDI\MDIDOC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* mdidoc.c - MDI application%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINCOMMON %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINACCELERATORS %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%INCL_WINSCROLLBARS %@NL@%
%@AI@%#define %@AE@%INCL_WINRECTANGLES %@NL@%
%@AI@%#define %@AE@%INCL_WINCOUNTRY %@NL@%
%@AI@%#define %@AE@%INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@AI@%#define %@AE@%INCL_GPILOGCOLORTABLE %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%"app.h" %@NL@%
%@AI@%#include %@AE@%"appdata.h" %@NL@%
%@AI@%#include %@AE@%"mdi.h" %@NL@%
%@AI@%#include %@AE@%"mdidata.h" %@NL@%
%@NL@%
BOOL fDestroying=FALSE;%@NL@%
%@NL@%
%@AB@%/* Function Prototypes */%@AE@%%@NL@%
VOID BuildWindowMenu(VOID);%@NL@%
VOID TrackSplitbars(HWND, USHORT, SHORT, SHORT);%@NL@%
MRESULT MDIFormatFrame(HWND hwnd, PSWP aswp, MPARAM mp2);%@NL@%
MRESULT MDIMinMaxFrame(HWND hwnd, MPARAM mp1, MPARAM mp2);%@NL@%
%@NL@%
VOID SetMainTitleText(HWND hwndDocFrame)%@NL@%
{%@NL@%
    char szDocTitle[80], szMainTitle[80];%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Get the titlebar text for the specified document window.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinQueryWindowText(hwndDocFrame, 80, (PSZ)szDocTitle);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Build up the correct text for the main window.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    strcpy(szMainTitle, " - ");%@NL@%
    strcat(szMainTitle, szDocTitle);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Set the main window's titlebar to the new text.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinSetWindowText(hwndMDIFrame, szMainTitle);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID ClearMainTitleText(VOID)%@NL@%
{%@NL@%
    WinSetWindowText(hwndMDIFrame, "");%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/* *********************************************************************** *\%@NL@%
%@AB@% * AddToWindowMenu%@NL@%
%@AB@% *%@NL@%
%@AB@% * This routines adds a new document to the WINDOW submenu of each document's%@NL@%
%@AB@% * menu so that when any doc is active you can select the other documents%@NL@%
%@AB@% * by selecting it on the main menu bar%@NL@%
%@AB@% *%@NL@%
%@AB@% * History:%@NL@%
%@AB@% *%@NL@%
%@AB@% *      19-Oct-1989 Added multiple menu capabilities -johnba%@NL@%
%@AB@% *%@NL@%
%@AB@%\* *********************************************************************** */%@AE@%%@NL@%
%@NL@%
%@AB@%/* MULTIPLEMENU */%@AE@%%@NL@%
%@NL@%
VOID AddToWindowMenu(NPDOC npdocNew)%@NL@%
{%@NL@%
    MENUITEM mi,miDoc;%@NL@%
    char szItemText[1];%@NL@%
    char szTitleNew[128], szTitleCompare[128];%@NL@%
    register NPDOC npdoc, npdocPrev;%@NL@%
    USHORT usRes;%@NL@%
%@NL@%
    HWND hwndWindowMenu;%@NL@%
    USHORT index;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Add the document to the DOCLIST.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (npdocFirst == NULL) {%@NL@%
        npdocFirst = npdocNew;%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Fill in the DOCLIST for this doc.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        npdocNew->idMI = NULL;%@NL@%
        npdocNew->npdocNext = NULL;%@NL@%
        }%@NL@%
%@NL@%
    else {%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Add the item in the correct%@NL@%
%@AB@%         * sorted location.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        npdoc = npdocFirst;%@NL@%
        npdocPrev = NULL;%@NL@%
%@NL@%
        while (npdoc != NULL) {%@NL@%
            WinQueryWindowText(npdoc->hwndFrame, 128, szTitleCompare);%@NL@%
            WinQueryWindowText(npdocNew->hwndFrame, 128, szTitleNew);%@NL@%
            WinUpper(NULL, NULL, NULL, szTitleCompare);%@NL@%
            WinUpper(NULL, NULL, NULL, szTitleNew);%@NL@%
%@NL@%
            usRes = WinCompareStrings(NULL, NULL, NULL, szTitleNew,%@NL@%
                    szTitleCompare, NULL);%@NL@%
%@NL@%
            if (usRes == WCS_LT) {%@NL@%
                if (npdocPrev == NULL) {%@NL@%
                    npdocFirst = npdocNew;%@NL@%
                    npdocFirst->npdocNext = npdoc;%@NL@%
                    }%@NL@%
                else {%@NL@%
                    npdocPrev->npdocNext = npdocNew;%@NL@%
                    npdocNew->npdocNext = npdoc;%@NL@%
                    }%@NL@%
%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Fill in the DOC for this document.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                npdocNew->idMI = NULL;%@NL@%
                break;%@NL@%
                }%@NL@%
            else {%@NL@%
                if (npdoc->npdocNext == NULL) {%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                     * If we've made it to the end,%@NL@%
%@AB@%                     * just tack it on here.%@NL@%
%@AB@%                     */%@AE@%%@NL@%
                    npdoc->npdocNext =  npdocNew;%@NL@%
%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                     * Fill in the DOC for this document.%@NL@%
%@AB@%                     */%@AE@%%@NL@%
                    npdocNew->idMI = NULL;%@NL@%
                    npdocNew->npdocNext = NULL;%@NL@%
                    }%@NL@%
                }%@NL@%
            npdocPrev = npdoc;%@NL@%
            npdoc = npdoc->npdocNext;%@NL@%
            }%@NL@%
%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
%@AB@%/*  Add menu items to the new doc's menu to make all doc's window menus%@NL@%
%@AB@%    have the same number of docs before this one was added */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Get the hwnd to the IDM_WINDOW submenu for this npdoc's menu bar */%@AE@%%@NL@%
    WinSendMsg(npdocNew->hwndMainMenu, MM_QUERYITEM,%@NL@%
                MPFROM2SHORT(IDM_WINDOW, FALSE), MPFROMP(&mi));%@NL@%
    hwndWindowMenu = mi.hwndSubMenu;%@NL@%
%@NL@%
    %@AB@%/* build blank menuitem structure for all documents */%@AE@%%@NL@%
%@NL@%
    mi.iPosition = MIT_END;%@NL@%
    mi.afStyle = MIS_TEXT;%@NL@%
    mi.afAttribute = 0;%@NL@%
    mi.hwndSubMenu = NULL;%@NL@%
    mi.hItem = NULL;%@NL@%
    szItemText[0] = '\0';%@NL@%
%@NL@%
    for(index=1; index<=cDocs; index++) {%@NL@%
%@NL@%
        mi.id = CMD_WINDOWITEMS + index;%@NL@%
%@NL@%
        WinSendMsg(hwndWindowMenu, MM_INSERTITEM, MPFROMP(&mi),%@NL@%
                MPFROMP(szItemText));%@NL@%
        }%@NL@%
%@NL@%
    cDocs++;%@NL@%
%@NL@%
    %@AB@%/* Now all the document window menus are similiar so we can now add the%@NL@%
%@AB@%       new menu to each of them */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* build menuitem structure for this document */%@AE@%%@NL@%
    miDoc.iPosition = MIT_END;%@NL@%
    miDoc.afStyle = MIS_TEXT;%@NL@%
    miDoc.afAttribute = 0;%@NL@%
    miDoc.id = CMD_WINDOWITEMS + cDocs;%@NL@%
    miDoc.hwndSubMenu = NULL;%@NL@%
    miDoc.hItem = NULL;%@NL@%
    szItemText[0] = '\0';%@NL@%
%@NL@%
    npdoc=npdocFirst;%@NL@%
%@NL@%
    %@AB@%/* insert a blank item into EVERY document's menu */%@AE@%%@NL@%
    while (npdoc!=NULL) {%@NL@%
%@NL@%
        %@AB@%/* This gets the hwnd to the IDM_WINDOW submenu for this npdoc's%@NL@%
%@AB@%           menu bar. */%@AE@%%@NL@%
%@NL@%
        WinSendMsg(npdoc->hwndMainMenu, MM_QUERYITEM,%@NL@%
                    MPFROM2SHORT(IDM_WINDOW, FALSE), MPFROMP(&mi));%@NL@%
        hwndWindowMenu = mi.hwndSubMenu;%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Insert a blank item into the menu.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        WinSendMsg(hwndWindowMenu, MM_INSERTITEM, MPFROMP(&miDoc),%@NL@%
                MPFROMP(szItemText));%@NL@%
%@NL@%
        npdoc=npdoc->npdocNext;%@NL@%
        }%@NL@%
%@NL@%
    npdocNew->idMI=miDoc.id; %@AB@%/* Set the ID for the menu item of the new document */%@AE@%%@NL@%
%@NL@%
    BuildWindowMenu();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID RemoveFromWindowMenu(NPDOC npdocRemove)%@NL@%
{%@NL@%
    register NPDOC npdoc, npdocPrev;%@NL@%
%@NL@%
    MENUITEM mi;%@NL@%
%@NL@%
    HWND hwndWindowMenu;%@NL@%
%@NL@%
%@NL@%
    npdoc=npdocFirst;%@NL@%
%@NL@%
    while (npdoc!=NULL) {%@NL@%
%@NL@%
        %@AB@%/* This gets the hwnd to the IDM_WINDOW submenu for this npdoc's%@NL@%
%@AB@%           menu bar. */%@AE@%%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * If the window menu is gone no need to%@NL@%
%@AB@%         * do any of this stuff.  This can happen%@NL@%
%@AB@%         * when the MDI app is closing.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        if (WinIsWindow(hab, npdoc->hwndMainMenu)) {%@NL@%
%@NL@%
%@NL@%
            WinSendMsg(npdoc->hwndMainMenu, MM_QUERYITEM,%@NL@%
                        MPFROM2SHORT(IDM_WINDOW, FALSE), MPFROMP(&mi));%@NL@%
            hwndWindowMenu = mi.hwndSubMenu;%@NL@%
%@NL@%
            %@AB@%/* Delete item from menu */%@AE@%%@NL@%
            WinSendMsg(hwndWindowMenu, MM_DELETEITEM,%@NL@%
                    MPFROM2SHORT(npdocRemove->idMI, FALSE), NULL);%@NL@%
%@NL@%
            }%@NL@%
        npdoc=npdoc->npdocNext;%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Remove the DOC from the linked-list.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (npdocFirst != NULL) {%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Initialize these for our while loop.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        npdoc = npdocFirst;%@NL@%
        npdocPrev = NULL;%@NL@%
%@NL@%
        while (npdoc != NULL) {%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If we've found the element unlink%@NL@%
%@AB@%             * it from the list.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (npdoc == npdocRemove) {%@NL@%
%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Unlink this document.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                if (npdocPrev != NULL)%@NL@%
                    npdocPrev->npdocNext = npdoc->npdocNext;%@NL@%
                else%@NL@%
                    npdocFirst = npdoc->npdocNext;%@NL@%
%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Break out of the while loop,%@NL@%
%@AB@%                 * we're done here.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                break;%@NL@%
%@NL@%
           %@AB@%/*   cDocs--;  */%@AE@%  /* ?????????????????  this will help the menus%@NL@%
                             sort of.  It will cause problems when we try%@NL@%
                             to reuse the same ID again in a new document window%@NL@%
                             ?????????????????????%@NL@%
                          */%@AE@%%@NL@%
%@NL@%
            }%@NL@%
            npdocPrev = npdoc;%@NL@%
            npdoc = npdoc->npdocNext;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* If we are terminating the app, don't try to build the menu since it%@NL@%
%@AB@%        will make a mess */%@AE@%%@NL@%
%@NL@%
    if (!fDestroying) {%@NL@%
        BuildWindowMenu();%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/* *********************************************************************** *\%@NL@%
%@AB@% * BuildWindowMenu%@NL@%
%@AB@% *%@NL@%
%@AB@% * This routine fills in the IDM_WINDOW submenu items with the titles of%@NL@%
%@AB@% * all the document windows.  It uses the first doc's submenu as a base to%@NL@%
%@AB@% * determine the ID's of the MENUITEMs and then changes the in the IDM_WINDOW%@NL@%
%@AB@% * submenu off ALL the document's menu bars.%@NL@%
%@AB@% *%@NL@%
%@AB@% * History:%@NL@%
%@AB@% *%@NL@%
%@AB@% *      19-Oct-1989 Added multiple menu capabilities -johnba%@NL@%
%@AB@% *%@NL@%
%@AB@%\* *********************************************************************** */%@AE@%%@NL@%
%@NL@%
%@AB@%/* MULTIPLEMENU */%@AE@%%@NL@%
%@NL@%
VOID BuildWindowMenu(VOID)%@NL@%
{%@NL@%
    register NPDOC npdoc;%@NL@%
    NPDOC npdocSetItem;%@NL@%
    char szDocTitle[80];%@NL@%
    char szItemText[80];%@NL@%
    USHORT cWindows;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Get the position of the first%@NL@%
%@AB@%     * window in the Window menu.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    MENUITEM mi;%@NL@%
    HWND hwndFirstWindowMenu;%@NL@%
    HWND hwndMenu;%@NL@%
%@NL@%
    if (npdocFirst==NULL) {%@NL@%
        WinSetParent(hwndFirstMenu, hwndMDIFrame, FALSE);%@NL@%
        WinSendMsg(hwndMDIFrame, WM_UPDATEFRAME, 0L, 0L);%@NL@%
        return;%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* first query the hwnd of the IDM_WINDOW submenu which will be used%@NL@%
%@AB@%       to determine the ID's of all the IDM_WINDOW subitems. */%@AE@%%@NL@%
    hwndMenu = npdocFirst->hwndMainMenu;%@NL@%
    WinSendMsg(hwndMenu, MM_QUERYITEM, MPFROM2SHORT(IDM_WINDOW, FALSE),%@NL@%
               MPFROMP(&mi));%@NL@%
    hwndFirstWindowMenu = mi.hwndSubMenu;%@NL@%
%@NL@%
    npdoc = npdocFirst;%@NL@%
    cWindows = 1;%@NL@%
%@NL@%
    %@AB@%/* scan the documents to get the text of each of their title bars and%@NL@%
%@AB@%       build the item text for each documents entry in the submenu */%@AE@%%@NL@%
    while (npdoc != NULL) {%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Build the item string.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        szItemText[0] = '~';%@NL@%
        itoa(cWindows, szItemText + 1, 10);%@NL@%
        strcat(szItemText, " ");%@NL@%
        WinQueryWindowText(npdoc->hwndFrame, 80, (PSZ)szDocTitle);%@NL@%
        strcat(szItemText, szDocTitle);%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* Now for each item loop through the documents, setting the text of%@NL@%
%@AB@%           this menu item for each of their submenu's */%@AE@%%@NL@%
        npdocSetItem=npdocFirst;%@NL@%
%@NL@%
        while (npdocSetItem !=NULL) {%@NL@%
%@NL@%
            HWND hwndWindowMenu;%@NL@%
%@NL@%
            hwndMenu = npdocSetItem->hwndMainMenu;%@NL@%
            WinSendMsg(hwndMenu, MM_QUERYITEM,%@NL@%
                        MPFROM2SHORT(IDM_WINDOW, FALSE),%@NL@%
                        MPFROMP(&mi));%@NL@%
            hwndWindowMenu = mi.hwndSubMenu;%@NL@%
%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Set the item text for the menuitem.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinSendMsg(hwndWindowMenu, MM_SETITEMTEXT,%@NL@%
                    MPFROMSHORT(npdoc->idMI),%@NL@%
                    MPFROMP(szItemText));%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Clear out the previous attributes.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinSendMsg(hwndWindowMenu, MM_SETITEMATTR,%@NL@%
                        MPFROM2SHORT(npdoc->idMI, FALSE),%@NL@%
                        MPFROM2SHORT(MIA_CHECKED, 0));%@NL@%
%@NL@%
            npdocSetItem=npdocSetItem->npdocNext;%@NL@%
            }%@NL@%
%@NL@%
        cWindows++;%@NL@%
        npdoc = npdoc->npdocNext;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
NPDOC MdiNewDocument(USHORT fsStyle, PSZ pszClassName)%@NL@%
{%@NL@%
    ULONG ctlData, flStyle;%@NL@%
    HWND hwndNewFrame, hwndNewClient, hwndSysMenu;%@NL@%
    HWND hwndMenu;          %@AB@%/* added to handle different menus for each doc%@NL@%
%@AB@%                                   17-Oct-1989 */%@AE@%%@NL@%
    register NPDOC npdocNew;%@NL@%
    register NPVIEW npview;%@NL@%
    char szDocTitle[80], szDocNumber[4];%@NL@%
%@NL@%
    %@AB@%/*  make sure there's no current menu on the frame */%@AE@%%@NL@%
    WinSetParent(WinWindowFromID(hwndMDIFrame, FID_MENU), HWND_OBJECT, FALSE);%@NL@%
%@NL@%
    usDocNumber++;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Setup the window's titlebar text.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    itoa(usDocNumber, szDocNumber, 10);%@NL@%
    strcpy(szDocTitle, "Untitled");%@NL@%
    strcat(szDocTitle, szDocNumber);%@NL@%
%@NL@%
    ctlData = FCF_TITLEBAR | FCF_MINMAX | FCF_SIZEBORDER |%@NL@%
            FCF_VERTSCROLL | FCF_HORZSCROLL;%@NL@%
%@NL@%
    hwndNewFrame = WinCreateStdWindow(hwndMDI,%@NL@%
            FS_ICON | FS_ACCELTABLE,%@NL@%
            (VOID FAR *)&ctlData,%@NL@%
            pszClassName, szDocTitle,%@NL@%
            WS_VISIBLE,%@NL@%
            (HMODULE)NULL, IDR_MDIDOC,%@NL@%
            (HWND FAR *)&hwndNewClient);%@NL@%
%@NL@%
%@AB@%/* MULTIPLEMENU */%@AE@%%@NL@%
%@NL@%
    switch (cDocs) {%@NL@%
        case 0:  %@AB@%/* This is the first document */%@AE@%%@NL@%
            hwndMenu=WinLoadMenu(hwndMDIFrame, NULL, IDR_DOC1MENU);%@NL@%
            break;%@NL@%
%@NL@%
        case 1:%@NL@%
            hwndMenu=WinLoadMenu(hwndMDIFrame, NULL, IDR_DOC2MENU);%@NL@%
            break;%@NL@%
%@NL@%
        case 2:%@NL@%
            hwndMenu=WinLoadMenu(hwndMDIFrame, NULL, IDR_DOC3MENU);%@NL@%
            break;%@NL@%
%@NL@%
        case 3:%@NL@%
            hwndMenu=WinLoadMenu(hwndMDIFrame, NULL, IDR_DOC4MENU);%@NL@%
            break;%@NL@%
%@NL@%
        case 4:%@NL@%
            hwndMenu=WinLoadMenu(hwndMDIFrame, NULL, IDR_DOC5MENU);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            hwndMenu=WinLoadMenu(hwndMDIFrame, NULL, IDR_DOCXMENU);%@NL@%
            break;%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/* The menu needs to be owned by the frame so that its WM_COMMAND messages%@NL@%
%@AB@%       will get sent to the frame to be processed.%@NL@%
%@AB@%    */%@AE@%%@NL@%
%@NL@%
    WinSetParent(hwndMenu, HWND_OBJECT, FALSE);%@NL@%
%@NL@%
    npdocNew = (NPDOC)WinAllocMem(hHeap, sizeof(DOC));%@NL@%
    if (npdocNew == NULL)%@NL@%
        return (FALSE);%@NL@%
%@NL@%
    npdocNew->hwndFrame = hwndNewFrame;%@NL@%
%@AB@%/* MULTIPLEMENU */%@AE@%%@NL@%
    npdocNew->hwndMainMenu = hwndMenu;              %@AB@%/* new for multiple menus */%@AE@%%@NL@%
    npdocNew->fAabSysMenu=FALSE;%@NL@%
%@NL@%
    npdocNew->cxVertSplitPos = 0;%@NL@%
    npdocNew->cyHorzSplitPos = 0;%@NL@%
    npdocNew->fs = 0;%@NL@%
    npdocNew->fsStyle = fsStyle;%@NL@%
%@NL@%
    npview = NPVIEWFROMCLIENT(hwndNewClient);%@NL@%
    npview->npdoc = npdocNew;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Link in the VIEW for FID_CLIENT since we%@NL@%
%@AB@%     * know it exists.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    npdocNew->npviewFirst = npview;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Create the 'splitbar' controls for the frame.%@NL@%
%@AB@%     * This includes the splitbar and the extra client%@NL@%
%@AB@%     * and scrollbar windows.  This routine will also%@NL@%
%@AB@%     * link the appropriate VIEWs into the DOC structure.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (fsStyle & (DS_HORZSPLITBAR | DS_VERTSPLITBAR)) {%@NL@%
        if (CreateSplitbarWindows(hwndNewFrame, npdocNew) == FALSE) {%@NL@%
            WinDestroyWindow(hwndNewFrame);%@NL@%
            return (FALSE);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Load in the document window's system menu.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    hwndSysMenu = WinLoadMenu(hwndNewFrame, (HMODULE)NULL, IDM_DOCSYSMENU);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Make it look like a normal system menu to the frame manager so%@NL@%
%@AB@%     * gets formatted correctly etc.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    flStyle = WinQueryWindowULong(hwndSysMenu, QWL_STYLE);%@NL@%
    WinSetWindowULong(hwndSysMenu, QWL_STYLE, flStyle | MS_TITLEBUTTON);%@NL@%
    WinSetWindowUShort(hwndSysMenu, QWS_ID, FID_SYSMENU);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Set the bitmap to the SBMP_CHILDSYSMENU bitmap.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinSendMsg(hwndSysMenu, MM_SETITEMHANDLE, (MPARAM)SC_DOCSYSMENU,%@NL@%
            (MPARAM)hbmChildSysMenu);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Set the menu window handles in the DOC structure so these%@NL@%
%@AB@%     * controls can be hidden/shown at the correct time.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    npdocNew->hwndSysMenu = hwndSysMenu;%@NL@%
    npdocNew->hwndMinmax = WinWindowFromID(hwndNewFrame, FID_MINMAX);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Subclass the frame so we can handle the accelerators%@NL@%
%@AB@%     * and other MDI stuff.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    pfnFrameWndProc = WinSubclassWindow(hwndNewFrame,%@NL@%
            (PFNWP)DocFrameWndProc);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Add the window to the Window menu.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
 %@AB@%/*    AddToWindowMenu(npdocNew);%@NL@%
%@AB@% */%@AE@%%@NL@%
    return (npdocNew);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID MDISetInitialDocPos(HWND hwndNewFrame)%@NL@%
{%@NL@%
    WinSetWindowPos(hwndNewFrame, NULL, xNextNewDoc, yNextNewDoc,%@NL@%
            cxNewDoc, cyNewDoc, SWP_MOVE | SWP_SIZE | SWP_SHOW);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Insert logic to change xNextNewDoc/yNextNewDoc and cxNewDoc/cyNewDoc.%@NL@%
%@AB@%     */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@AB@%/* ********************************************************************** *\%@NL@%
%@AB@% * AddAabSysMenu - adds the sys menu to the menu bar for the given        *%@NL@%
%@AB@%                   document frame window.%@NL@%
%@AB@%%@NL@%
%@AB@%   History:%@NL@%
%@AB@%    20-Oct-1989 modified to pass an hwnd of the doc frame to add%@NL@%
%@AB@%                the menu to. -johnba%@NL@%
%@AB@%%@NL@%
%@AB@%\* ********************************************************************** */%@AE@%%@NL@%
%@NL@%
VOID AddAabSysMenu(HWND hwnd)%@NL@%
{%@NL@%
    HWND hwndMenu;%@NL@%
    NPDOC npdoc;%@NL@%
%@NL@%
    npdoc=NPDOCFROMCLIENT(WinWindowFromID(hwnd, FID_CLIENT));%@NL@%
    hwndMenu=npdoc->hwndMainMenu;%@NL@%
%@NL@%
    if (npdoc->fAabSysMenu == FALSE) {%@NL@%
        WinSendMsg(hwndMenu, MM_INSERTITEM, MPFROMP(&miAabSysMenu),%@NL@%
                (MPARAM)NULL);%@NL@%
        npdoc->fAabSysMenu = TRUE;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/* ********************************************************************** *\%@NL@%
%@AB@% * RemoveAabSysMenu - removes the sys menu from the menu bar for the given        *%@NL@%
%@AB@%                      document frame window.%@NL@%
%@AB@%%@NL@%
%@AB@%   History:%@NL@%
%@AB@%    20-Oct-1989 modified to pass an hwnd of the doc frame to remove%@NL@%
%@AB@%                the menu from. -johnba%@NL@%
%@AB@%%@NL@%
%@AB@%\* ********************************************************************** */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
VOID RemoveAabSysMenu(HWND hwnd)%@NL@%
{%@NL@%
    HWND hwndMenu;%@NL@%
    NPDOC npdoc;%@NL@%
%@NL@%
    npdoc=NPDOCFROMCLIENT(WinWindowFromID(hwnd, FID_CLIENT));%@NL@%
    hwndMenu=npdoc->hwndMainMenu;%@NL@%
%@NL@%
    if (npdoc->fAabSysMenu == TRUE) {%@NL@%
        WinSendMsg(hwndMenu, MM_REMOVEITEM,%@NL@%
                MPFROMSHORT(IDM_AABDOCSYSMENU), (MPARAM)FALSE);%@NL@%
        npdoc->fAabSysMenu = FALSE;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
BOOL MDICreate(HWND hwndClient)%@NL@%
{%@NL@%
    register NPVIEW npview;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Allocate the DOC structure for this window and stick it in%@NL@%
%@AB@%     * the window structure of the client.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    npview = (NPVIEW)WinAllocMem(hHeap, sizeof(VIEW));%@NL@%
    if (npview == NULL)%@NL@%
        return (FALSE);%@NL@%
%@NL@%
    npview->xOrigin = 0;%@NL@%
    npview->yOrigin = 0;%@NL@%
    npview->fs = 0;%@NL@%
    npview->npviewNext = NULL;%@NL@%
    npview->hwndClient = hwndClient;%@NL@%
%@NL@%
    WinSetWindowUShort(hwndClient, QWS_USER, (USHORT)npview);%@NL@%
%@NL@%
    return (TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID MDIActivate(HWND hwndClient, BOOL fActivate)%@NL@%
{%@NL@%
    HWND hwndFrame;%@NL@%
    register NPDOC npdoc;%@NL@%
%@NL@%
%@NL@%
    MENUITEM mi;%@NL@%
    HWND hwndWindowMenu;%@NL@%
    HWND hwndNewMenu;%@NL@%
    HWND hwndOldMenu;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If our active status is changing, show/hide the AAB Sysmenu, check%@NL@%
%@AB@%     * the correct item on the Window menu, and show/hide the titlebar%@NL@%
%@AB@%     * frame controls.  Also change the main menu bar  17-Oct-1989 johnba%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    hwndFrame = WinQueryWindow(hwndClient, QW_PARENT, FALSE);%@NL@%
%@NL@%
    npdoc = NPDOCFROMCLIENT(hwndClient);%@NL@%
    if (fActivate != FALSE) {%@NL@%
%@NL@%
        %@AB@%/* Receiving activation */%@AE@%%@NL@%
%@NL@%
        hwndOldMenu = WinWindowFromID(hwndMDIFrame, FID_MENU);%@NL@%
%@NL@%
        if (hwndOldMenu!=NULL) {%@NL@%
%@NL@%
            WinSendMsg(hwndOldMenu, MM_QUERYITEM, MPFROM2SHORT(IDM_WINDOW, FALSE),%@NL@%
                       MPFROMP(&mi));%@NL@%
            hwndWindowMenu = mi.hwndSubMenu;%@NL@%
            }%@NL@%
%@NL@%
        hwndNewMenu=NPDOCFROMCLIENT(hwndClient)->hwndMainMenu;%@NL@%
%@NL@%
        if (hwndOldMenu!=NULL) {%@NL@%
            WinSendMsg(hwndOldMenu, MM_REMOVEITEM,%@NL@%
                    MPFROMSHORT(IDM_AABDOCSYSMENU),%@NL@%
                    (MPARAM)FALSE);%@NL@%
%@NL@%
            %@AB@%/* hide current menu */%@AE@%%@NL@%
            WinSetParent(hwndOldMenu, HWND_OBJECT, FALSE);%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Uncheck the appropriate item on the Window menu.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinSendMsg(hwndWindowMenu, MM_SETITEMATTR,%@NL@%
                    MPFROM2SHORT(npdoc->idMI, FALSE),%@NL@%
                    MPFROM2SHORT(MIA_CHECKED, 0));%@NL@%
            }%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* put new menu on main frame window */%@AE@%%@NL@%
        WinSetParent(hwndNewMenu, hwndMDIFrame, FALSE);%@NL@%
        WinSendMsg(hwndMDIFrame, WM_UPDATEFRAME, 0L, 0L);%@NL@%
%@NL@%
        if (WinQueryWindowULong(hwndFrame, QWL_STYLE) & WS_MAXIMIZED) {%@NL@%
            WinSendMsg(hwndNewMenu, MM_INSERTITEM,%@NL@%
                    MPFROMP(&miAabSysMenu),%@NL@%
                    (MPARAM)NULL);%@NL@%
            }%@NL@%
%@NL@%
%@NL@%
        WinSendMsg(hwndNewMenu, MM_QUERYITEM, MPFROM2SHORT(IDM_WINDOW, FALSE),%@NL@%
                   MPFROMP(&mi));%@NL@%
        hwndWindowMenu = mi.hwndSubMenu;%@NL@%
%@NL@%
        hwndActiveDoc = hwndFrame; %@AB@%/* remember the active window in a global */%@AE@%%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Check the appropriate item on the Window menu.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinSendMsg(hwndWindowMenu, MM_SETITEMATTR,%@NL@%
                MPFROM2SHORT(npdoc->idMI, FALSE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, MIA_CHECKED));%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Show the titlebar frame controls.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        WinSetParent(npdoc->hwndSysMenu, hwndFrame, FALSE);%@NL@%
        WinSetParent(npdoc->hwndMinmax, hwndFrame, FALSE);%@NL@%
%@NL@%
        WinSendMsg(hwndFrame, WM_UPDATEFRAME, 0L, 0L);%@NL@%
%@NL@%
    } else {%@NL@%
        %@AB@%/* Losing activation */%@AE@%%@NL@%
%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Remove the titlebar frame controls.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        %@AB@%/* Need to hide them before setting the parent to HWND_OBJECT so%@NL@%
%@AB@%           that they get painted right when they are restored. 02-Aug-1989 */%@AE@%%@NL@%
%@NL@%
        WinShowWindow(npdoc->hwndSysMenu, FALSE);%@NL@%
        WinShowWindow(npdoc->hwndMinmax, FALSE);%@NL@%
%@NL@%
        WinSetParent(npdoc->hwndSysMenu, HWND_OBJECT, FALSE);%@NL@%
        WinSetParent(npdoc->hwndMinmax, HWND_OBJECT, FALSE);%@NL@%
%@NL@%
        WinSendMsg(hwndFrame, WM_UPDATEFRAME, 0L, 0L);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID MDIDestroy(HWND hwndClient)%@NL@%
{%@NL@%
%@NL@%
    WinFreeMem(hHeap, (NPBYTE)WinQueryWindowUShort(hwndClient, QWS_USER),%@NL@%
            sizeof(VIEW));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID MDIClose(HWND hwndClient)%@NL@%
{%@NL@%
    WinDestroyWindow(WinQueryWindow(hwndClient, QW_PARENT, FALSE));%@NL@%
}%@NL@%
%@NL@%
struct ARECTL {%@NL@%
    RECTL rclSrc;%@NL@%
    RECTL rclDest;%@NL@%
    };%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY DocFrameWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    MRESULT mres;%@NL@%
    USHORT cFrameCtls;%@NL@%
    HWND hwndParent, hwndClient;%@NL@%
    register NPDOC npdoc;%@NL@%
    RECTL rclClient;%@NL@%
%@NL@%
struct ARECTL far *prcl;%@NL@%
%@NL@%
    PSWP    pswp;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_ADJUSTWINDOWPOS:%@NL@%
        return (*pfnFrameWndProc)(hwnd, msg, mp1, mp2);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_SYSCOMMAND:%@NL@%
        if (SHORT1FROMMP(mp1) == SC_SPLIT) {%@NL@%
            WinSetPointer(HWND_DESKTOP, hptrHVSplit);%@NL@%
            TrackSplitbars(WinWindowFromID(hwnd, FID_CLIENT),%@NL@%
                    SPS_HORZ | SPS_VERT, -1, -1);%@NL@%
            WinSetPointer(HWND_DESKTOP, hptrArrow);%@NL@%
        } else if (SHORT1FROMMP(mp2) == (SHORT) CMDSRC_ACCELERATOR) {%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If the command was sent because of an accelerator%@NL@%
%@AB@%             * we need to see if it goes to the document or the main%@NL@%
%@AB@%             * frame window.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if ((WinGetKeyState(HWND_DESKTOP, VK_CTRL) & 0x8000)) {%@NL@%
%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * If the control key is down we'll send it%@NL@%
%@AB@%                 * to the document's frame since that means%@NL@%
%@AB@%                 * it's either ctl-esc or one of the document%@NL@%
%@AB@%                 * window's accelerators.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                return (*pfnFrameWndProc)(hwnd, msg, mp1, mp2);%@NL@%
            } else if (SHORT1FROMMP(mp1) == SC_DOCSYSMENU) {%@NL@%
%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * If the window is maximized then we want%@NL@%
%@AB@%                 * to pull down the system menu on the main%@NL@%
%@AB@%                 * menu bar.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                if ((WinQueryWindowULong(hwnd, QWL_STYLE) & WS_MAXIMIZED) &&%@NL@%
                        (SHORT1FROMMP(mp1) == SC_DOCSYSMENU)) {%@NL@%
                    WinPostMsg(miAabSysMenu.hwndSubMenu, MM_STARTMENUMODE,%@NL@%
                            MPFROM2SHORT(TRUE, FALSE), 0L);%@NL@%
                    return (0L);%@NL@%
                } else {%@NL@%
                    WinPostMsg(WinWindowFromID(hwnd, FID_SYSMENU),%@NL@%
                            MM_STARTMENUMODE, MPFROM2SHORT(TRUE, FALSE), 0L);%@NL@%
                }%@NL@%
            } else {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Control isn't down so send it the main%@NL@%
%@AB@%                 * frame window.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                return WinSendMsg(hwndMDIFrame, msg, mp1, mp2);%@NL@%
            }%@NL@%
        } else {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * WM_SYSCOMMAND not caused by an accelerator%@NL@%
%@AB@%             * so hwnd is the window we want to send the%@NL@%
%@AB@%             * message to.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            return (*pfnFrameWndProc)(hwnd, msg, mp1, mp2);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_NEXTMENU:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Connect child sysmenu with application menus for cursor motion.%@NL@%
%@AB@%         * Only return a value if we're the System Menu.  We don't want the%@NL@%
%@AB@%         * MinMax menu or any others that might be there to freak out.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (WinQueryWindowUShort(HWNDFROMMP(mp1), QWS_ID) == FID_SYSMENU) {%@NL@%
            if (SHORT1FROMMP(mp2)) {%@NL@%
                return (MRESULT)hwndSysMenu;%@NL@%
                }%@NL@%
            else {%@NL@%
                %@AB@%/* return (MRESULT) hwndAppMenu; */%@AE@%%@NL@%
                return (MRESULT) (NPDOCFROMCLIENT(WinWindowFromID(hwnd, FID_CLIENT))%@NL@%
                                        ->hwndMainMenu);%@NL@%
                }%@NL@%
        } else {%@NL@%
            return (0L);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_MINMAXFRAME:%@NL@%
        return (MDIMinMaxFrame(hwnd, mp1, mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_WINDOWPOSCHANGED: %@NL@%
%@NL@%
%@AI@%#define %@AE@%aswp    ((PSWP)mp1) %@NL@%
%@NL@%
        npdoc = NPDOCFROMCLIENT(WinWindowFromID(hwnd, FID_CLIENT));%@NL@%
        if (((PSWP)mp1)->fs & SWP_SIZE) {%@NL@%
%@NL@%
            if (npdoc->fs & (DF_SPLITHORZ | DF_HSPLITOVERFLOW)) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * If we were sized then adjust the horizontal splitbar%@NL@%
%@AB@%                 * to be top-aligned.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                npdoc->cyHorzSplitPos += (aswp[0].cy - aswp[1].cy);%@NL@%
%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Set or clear the DF_HSPLITOVERFLOW and DF_SPLITHORZ flags.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                if (npdoc->cyHorzSplitPos < 0) {%@NL@%
                    npdoc->fs |= DF_HSPLITOVERFLOW;%@NL@%
                    npdoc->fs &= ~DF_SPLITHORZ;%@NL@%
                } else {%@NL@%
                    npdoc->fs &= ~DF_HSPLITOVERFLOW;%@NL@%
                    npdoc->fs |= DF_SPLITHORZ;%@NL@%
                }%@NL@%
            }%@NL@%
%@NL@%
            if (npdoc->fs & (DF_SPLITVERT | DF_VSPLITOVERFLOW)) {%@NL@%
%@NL@%
                WinQueryWindowRect(hwnd, &rclClient);%@NL@%
                WinCalcFrameRect(hwnd, &rclClient, TRUE);%@NL@%
%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Set or clear the DF_VSPLITOVERFLOW and DF_SPLITVERT flags.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                if (npdoc->cxVertSplitPos >%@NL@%
                        (((SHORT)rclClient.xRight - (SHORT)rclClient.xLeft) -%@NL@%
                        cxVertSplitbar)) {%@NL@%
                    npdoc->fs |= DF_VSPLITOVERFLOW;%@NL@%
                    npdoc->fs &= ~DF_SPLITVERT;%@NL@%
                } else {%@NL@%
                    npdoc->fs &= ~DF_VSPLITOVERFLOW;%@NL@%
                    npdoc->fs |= DF_SPLITVERT;%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
%@AI@%#undef %@AE@%aswp %@NL@%
%@NL@%
        return (*pfnFrameWndProc)(hwnd, msg, mp1, mp2);%@NL@%
        break;%@NL@%
%@NL@%
%@NL@%
    case WM_CALCVALIDRECTS:%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * We do our own WM_CALCVALIDRECTS processing%@NL@%
%@AB@%         * because the frame manager uses the window%@NL@%
%@AB@%         * rectangle of FID_CLIENT, which in our case%@NL@%
%@AB@%         * might be smaller than the 'client area' due%@NL@%
%@AB@%         * to window splitting.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%prclOld ((PRECTL)&(((PRECTL)mp1)[0])) %@NL@%
%@AI@%#define %@AE@%prclNew ((PRECTL)&(((PRECTL)mp1)[1])) %@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Calculate the client rectangle of hwnd in its%@NL@%
%@AB@%         * parent's coordinates.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinQueryWindowRect(hwnd, (PRECTL)prclOld);%@NL@%
        hwndParent = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
        WinMapWindowPoints(hwnd, hwndParent, (PPOINTL)prclOld, 2);%@NL@%
        WinCalcFrameRect(hwnd, (PRECTL)prclOld, TRUE);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Calculate the client rect for the%@NL@%
%@AB@%         * destination of the frame window.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinCalcFrameRect(hwnd, (PRECTL)prclNew, TRUE);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Top align destination bits.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        prclNew->yBottom += (prclNew->yTop - prclNew->yBottom) -%@NL@%
                            (prclOld->yTop - prclOld->yBottom);%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AI@%#undef %@AE@%prclOld %@NL@%
%@AI@%#undef %@AE@%prclNew %@NL@%
%@NL@%
        prcl = PVOIDFROMMP(mp1);     %@AB@%/* array of src and dest rectangles      */%@AE@%%@NL@%
        pswp = PVOIDFROMMP(mp2);%@NL@%
%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Return 0 since we've already aligned the bits.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        return(0);%@NL@%
        break;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    case WM_QUERYFRAMECTLCOUNT:%@NL@%
        cFrameCtls = (int)(ULONG)(*pfnFrameWndProc)(hwnd, WM_QUERYFRAMECTLCOUNT, mp1, mp2);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Max number of additional frame controls is seven%@NL@%
%@AB@%         * Two splitbars, two additional scrollbars, and three%@NL@%
%@AB@%         * additional client windows.  Throw in 3 more just to%@NL@%
%@AB@%         * be sure we don't trash memory%@NL@%
%@AB@%         */%@AE@%%@NL@%
        return (MRFROMSHORT(cFrameCtls + 7 + 3));%@NL@%
%@NL@%
%@NL@%
    case WM_FORMATFRAME:%@NL@%
        return (MDIFormatFrame(hwnd, ((PSWP)PVOIDFROMMP(mp1)), mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1UP:%@NL@%
        mres =  (*pfnFrameWndProc)(hwnd, msg, mp1, mp2);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * If we're minimized we need to do activation ourself%@NL@%
%@AB@%         * and bring up the system menu.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (!(WinQueryWindowUShort(hwnd, QWS_FLAGS) & FF_ACTIVE)) {%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Only do this if we're minimized.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (WinQueryWindowULong(hwnd, QWL_STYLE) & WS_MINIMIZED) {%@NL@%
%@NL@%
                WinSetActiveWindow(HWND_DESKTOP, hwnd);%@NL@%
%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Bring up the system menu if there is one.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                WinSendDlgItemMsg(hwnd, FID_SYSMENU, MM_STARTMENUMODE,%@NL@%
                        MPFROMSHORT(TRUE), 0L);%@NL@%
            }%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * If this document is maximized, remove the AabSysMenu.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        %@AB@%/* MULTIPLEMENU */%@AE@%%@NL@%
%@NL@%
%@AB@%/* Not needed since we removed the system menu when it lost%@NL@%
%@AB@%        activation ???????????????????? */%@AE@%%@NL@%
%@NL@%
   %@AB@%/*%@NL@%
%@AB@%        if (WinQueryWindowULong(hwnd, QWL_STYLE) & WS_MAXIMIZED)%@NL@%
%@AB@%            RemoveAabSysMenu();%@NL@%
%@AB@%   */%@AE@%%@NL@%
%@NL@%
%@NL@%
        hwndClient = WinWindowFromID(hwnd, FID_CLIENT);%@NL@%
        npdoc = NPDOCFROMCLIENT(hwndClient);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Make sure these windows are on the frame so they%@NL@%
%@AB@%         * get destroyed.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinSetParent(npdoc->hwndSysMenu, hwnd, FALSE);%@NL@%
        WinSetParent(npdoc->hwndMinmax, hwnd, FALSE);%@NL@%
%@NL@%
        WinSendMsg(npdoc->hwndSysMenu, MM_DELETEITEM,%@NL@%
                    MPFROM2SHORT(-127, TRUE),0L);%@NL@%
%@NL@%
%@NL@%
        fDestroying=TRUE;%@NL@%
%@NL@%
        RemoveFromWindowMenu(npdoc);%@NL@%
%@NL@%
        if (WinIsWindow(hab, npdoc->hwndMainMenu)) {%@NL@%
            WinDestroyWindow(npdoc->hwndMainMenu);%@NL@%
            }%@NL@%
%@NL@%
        WinFreeMem(hHeap, (NPBYTE)npdoc, sizeof(DOC));%@NL@%
%@NL@%
        if (npdocFirst==NULL) {%@NL@%
            %@AB@%/* No documents left, so put the first menu back on the main MDI%@NL@%
%@AB@%            window */%@AE@%%@NL@%
%@NL@%
            %@AB@%/* need to make sure the hwndFirstMenu still exists, since it%@NL@%
%@AB@%                is dead by now when the app is being closed down. */%@AE@%%@NL@%
%@NL@%
            if (WinIsWindow(hab, hwndFirstMenu)) {%@NL@%
                WinSetParent(hwndFirstMenu, hwndMDIFrame, FALSE);%@NL@%
                WinSendMsg(hwndMDIFrame, WM_UPDATEFRAME, 0L, 0L);%@NL@%
                }%@NL@%
            }%@NL@%
%@NL@%
        return (*pfnFrameWndProc)(hwnd, msg, mp1, mp2);%@NL@%
%@NL@%
    default:%@NL@%
        return (*pfnFrameWndProc)(hwnd, msg, mp1, mp2);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
MRESULT MDIMinMaxFrame(HWND hwnd, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    PSWP pswp;%@NL@%
%@NL@%
    pswp = (PSWP)PVOIDFROMMP(mp1);%@NL@%
    if ((pswp->fs & SWP_MAXIMIZE) &&%@NL@%
            ((WinQueryWindowULong(hwnd, QWL_STYLE) & WS_MAXIMIZED) == 0L)) {%@NL@%
        pswp->cy += cyTitlebar;%@NL@%
        AddAabSysMenu(hwnd);%@NL@%
        SetMainTitleText(hwnd);%@NL@%
    } else if (((pswp->fs & SWP_RESTORE) || (pswp->fs & SWP_MINIMIZE)) &&%@NL@%
            (WinQueryWindowULong(hwnd, QWL_STYLE) & WS_MAXIMIZED)) {%@NL@%
        RemoveAabSysMenu(hwnd);%@NL@%
        ClearMainTitleText();%@NL@%
    }%@NL@%
    return (*pfnFrameWndProc)(hwnd, WM_MINMAXFRAME, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
MRESULT MDIFormatFrame(HWND hwnd, PSWP aswp, MPARAM mp2)%@NL@%
{%@NL@%
    SWP swpClient;%@NL@%
    PSWP pswpHScroll, pswpVScroll;%@NL@%
    USHORT chwnd, iswpNext;%@NL@%
    register NPDOC npdoc;%@NL@%
    SHORT cyHorzSplitPos, cxVertSplitPos;%@NL@%
%@NL@%
    iswpNext = chwnd = (USHORT) (ULONG)(*pfnFrameWndProc)(hwnd, WM_FORMATFRAME,%@NL@%
                            aswp, mp2);%@NL@%
%@NL@%
    FindSwp(aswp, chwnd, FID_HORZSCROLL, (PSWP FAR *)&pswpHScroll);%@NL@%
    FindSwp(aswp, chwnd, FID_VERTSCROLL, (PSWP FAR *)&pswpVScroll);%@NL@%
%@NL@%
    npdoc = NPDOCFROMCLIENT(aswp[chwnd - 1].hwnd);%@NL@%
%@NL@%
    cyHorzSplitPos = npdoc->cyHorzSplitPos;%@NL@%
    cxVertSplitPos = npdoc->cxVertSplitPos;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Save the client rectangle away because we%@NL@%
%@AB@%     * want to do thing based on the original%@NL@%
%@AB@%     * client rectangle as well as move the%@NL@%
%@AB@%     * client's ordering in the SWP list behind%@NL@%
%@AB@%     * the other client windows.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    swpClient = aswp[chwnd - 1];%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Start from the client window's SWP%@NL@%
%@AB@%     * since we're going to move it to%@NL@%
%@AB@%     * the end.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    iswpNext = (chwnd - 1);%@NL@%
%@NL@%
    if (npdoc->fsStyle & DS_VERTSPLITBAR) {%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * If the horizontal scrollbar is being hidden%@NL@%
%@AB@%         * then we certainly don't need to be around...%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (pswpHScroll->fs & SWP_HIDE) {%@NL@%
%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT2),%@NL@%
                    &iswpNext);%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_HORZSCROLL2),%@NL@%
                    &iswpNext);%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_VERTSPLITBAR),%@NL@%
                    &iswpNext);%@NL@%
%@NL@%
        } else if (npdoc->fs & DF_VSPLITOVERFLOW) {%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * First hide CLIENT3 and VERTSCROLL2%@NL@%
%@AB@%             * since we know they're going away.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT2),%@NL@%
                    &iswpNext);%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_HORZSCROLL2),%@NL@%
                    &iswpNext);%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Hide CLIENT4 since it won't be needed for now.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (npdoc->fsStyle & DS_HORZSPLITBAR) {%@NL@%
                HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT4),%@NL@%
                        &iswpNext);%@NL@%
            }%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If there isn't any room for even the hidden%@NL@%
%@AB@%             * representation then get rid of it...%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (pswpHScroll->cx < (SHORT) (cxVertSplitbar * 3)) {%@NL@%
                HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_VERTSPLITBAR),%@NL@%
                        &iswpNext);%@NL@%
            } else {%@NL@%
                SetSwpPos(&aswp[iswpNext++],%@NL@%
                        WinWindowFromID(hwnd, ID_VERTSPLITBAR), NULL,%@NL@%
                        pswpHScroll->x + pswpHScroll->cx - cxVertSplitbar,%@NL@%
                        pswpHScroll->y + cyBorder, cxVertSplitbar,%@NL@%
                        pswpHScroll->cy - cyBorder, pswpHScroll->fs);%@NL@%
%@NL@%
                pswpHScroll->cx -= cxVertSplitbar;%@NL@%
            }%@NL@%
%@NL@%
        } else if (npdoc->fs & DF_SPLITVERT) {%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Format the client windows.%@NL@%
%@AB@%             *%@NL@%
%@AB@%             * If we're split horzintally as well then we%@NL@%
%@AB@%             * need to show the fourth client.%@NL@%
%@AB@%             */%@AE@%%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If we're split horizontally and there was%@NL@%
%@AB@%             * enough room to be split then format%@NL@%
%@AB@%             * the 'fourth' client window.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if ((npdoc->fs & DF_SPLITHORZ) &&%@NL@%
                    (pswpVScroll->cy > (SHORT) (cyHorzSplitbar * 3))) {%@NL@%
                aswp[iswpNext].hwnd = WinWindowFromID(hwnd, ID_CLIENT4);%@NL@%
                aswp[iswpNext].hwndInsertBehind = NULL;%@NL@%
                aswp[iswpNext].x = swpClient.x +%@NL@%
                        (cxVertSplitPos + cxVertSplitbar);%@NL@%
                aswp[iswpNext].cx = swpClient.cx -%@NL@%
                        (cxVertSplitPos + cxVertSplitbar);%@NL@%
                aswp[iswpNext].y = swpClient.y;%@NL@%
                aswp[iswpNext].cy = cyHorzSplitPos;%@NL@%
                aswp[iswpNext].fs = swpClient.fs | SWP_SHOW;%@NL@%
%@NL@%
                iswpNext++;%@NL@%
            }%@NL@%
%@NL@%
            aswp[iswpNext].hwnd = WinWindowFromID(hwnd, ID_CLIENT2);%@NL@%
            aswp[iswpNext].hwndInsertBehind = NULL;%@NL@%
            aswp[iswpNext].x = swpClient.x +%@NL@%
                    (cxVertSplitPos + cxVertSplitbar);%@NL@%
            aswp[iswpNext].cx = swpClient.cx -%@NL@%
                    (cxVertSplitPos + cxVertSplitbar);%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If we're split horizontally and there was%@NL@%
%@AB@%             * enough room to be split then format%@NL@%
%@AB@%             * the 'second' client window against the%@NL@%
%@AB@%             * 'fourth' client window.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if ((npdoc->fs & DF_SPLITHORZ) &&%@NL@%
                    (pswpVScroll->cy > (SHORT) (cyHorzSplitbar * 3))) {%@NL@%
                aswp[iswpNext].y = swpClient.y +%@NL@%
                        (cyHorzSplitPos + cyHorzSplitbar);%@NL@%
                aswp[iswpNext].cy = swpClient.cy -%@NL@%
                        (cyHorzSplitPos + cyHorzSplitbar);%@NL@%
            } else {%@NL@%
                aswp[iswpNext].y = swpClient.y;%@NL@%
                aswp[iswpNext].cy = swpClient.cy;%@NL@%
            }%@NL@%
            aswp[iswpNext].fs = swpClient.fs | SWP_SHOW;%@NL@%
%@NL@%
            iswpNext++;%@NL@%
%@NL@%
        } else {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If we're not split then format the window with the%@NL@%
%@AB@%             * splitbar to the left of the horizontal scrollbar.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_HORZSCROLL2),%@NL@%
                    &iswpNext);%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT2),%@NL@%
                    &iswpNext);%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Hide ID_CLIENT4 since it won't be needed for now.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (npdoc->fsStyle & DS_HORZSPLITBAR) {%@NL@%
                HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT4),%@NL@%
                        &iswpNext);%@NL@%
            }%@NL@%
%@NL@%
            aswp[iswpNext].hwnd = WinWindowFromID(hwnd, ID_VERTSPLITBAR);%@NL@%
            aswp[iswpNext].hwndInsertBehind = NULL;%@NL@%
            aswp[iswpNext].x = pswpHScroll->x;%@NL@%
            aswp[iswpNext].y = pswpHScroll->y + cyBorder;%@NL@%
            aswp[iswpNext].cx = cxVertSplitbar;%@NL@%
            aswp[iswpNext].cy = pswpHScroll->cy - cyBorder;%@NL@%
            aswp[iswpNext].fs = pswpHScroll->fs;%@NL@%
            pswpHScroll->x += cxVertSplitbar;%@NL@%
            pswpHScroll->cx -= cxVertSplitbar;%@NL@%
%@NL@%
            iswpNext++;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (npdoc->fsStyle & DS_HORZSPLITBAR) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * If the horizontal scrollbar is being hidden%@NL@%
%@AB@%         * then we certainly don't need to be around...%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (pswpVScroll->fs & SWP_HIDE) {%@NL@%
%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT3),%@NL@%
                    &iswpNext);%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_VERTSCROLL2),%@NL@%
                    &iswpNext);%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_HORZSPLITBAR),%@NL@%
                    &iswpNext);%@NL@%
%@NL@%
        } else if (npdoc->fs & DF_HSPLITOVERFLOW) {%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * First hide CLIENT3 and VERTSCROLL2%@NL@%
%@AB@%             * since we know they're going away.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT3),%@NL@%
                    &iswpNext);%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_VERTSCROLL2),%@NL@%
                    &iswpNext);%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Hide CLIENT4 since it won't be needed for now.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (npdoc->fsStyle & DS_VERTSPLITBAR) {%@NL@%
                HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT4),%@NL@%
                        &iswpNext);%@NL@%
            }%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If there isn't any room for even the hidden%@NL@%
%@AB@%             * representation then get rid of it%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (pswpVScroll->cy < (SHORT)(cyHorzSplitbar * 3)) {%@NL@%
                HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_HORZSPLITBAR),%@NL@%
                        &iswpNext);%@NL@%
            } else {%@NL@%
                SetSwpPos(&aswp[iswpNext++],%@NL@%
                        WinWindowFromID(hwnd, ID_HORZSPLITBAR), NULL,%@NL@%
                        pswpVScroll->x, pswpVScroll->y, pswpVScroll->cx - cxBorder,%@NL@%
                        cyHorzSplitbar, pswpVScroll->fs);%@NL@%
%@NL@%
                pswpVScroll->y += cyHorzSplitbar;%@NL@%
                pswpVScroll->cy -= cyHorzSplitbar;%@NL@%
            }%@NL@%
%@NL@%
        } else if (npdoc->fs & DF_SPLITHORZ) {%@NL@%
%@NL@%
            if (pswpVScroll->cy > (SHORT)(cyHorzSplitbar * 3)) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Format the client windows.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                SetSwpPos(&aswp[iswpNext++],%@NL@%
                        WinWindowFromID(hwnd, ID_CLIENT3), NULL,%@NL@%
                        swpClient.x, swpClient.y,%@NL@%
                        %@AB@%/*%@NL@%
%@AB@%                         * If we're split vertically then format%@NL@%
%@AB@%                         * the client against the vertical splitbar%@NL@%
%@AB@%                         * as well as the horzontal splitbar.%@NL@%
%@AB@%                         */%@AE@%%@NL@%
                        (npdoc->fs & DF_SPLITVERT) ? cxVertSplitPos : swpClient.cx,%@NL@%
                        cyHorzSplitPos, swpClient.fs | SWP_SHOW);%@NL@%
%@NL@%
            } else {%@NL@%
                HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT3),%@NL@%
                        &iswpNext);%@NL@%
%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Hide CLIENT4 since it won't be needed for now.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                if (npdoc->fsStyle & DS_VERTSPLITBAR) {%@NL@%
                    HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT4),%@NL@%
                            &iswpNext);%@NL@%
                }%@NL@%
            }%@NL@%
%@NL@%
        } else {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If we're not split then format the window with the%@NL@%
%@AB@%             * splitbar at the top of the vertical scrollbar.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_VERTSCROLL2),%@NL@%
                    &iswpNext);%@NL@%
%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT3),%@NL@%
                    &iswpNext);%@NL@%
%@NL@%
            if (npdoc->fsStyle & DS_VERTSPLITBAR) {%@NL@%
                HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT4),%@NL@%
                    &iswpNext);%@NL@%
            }%@NL@%
%@NL@%
            if (pswpVScroll->cy > (SHORT)(cyHorzSplitbar * 3)) {%@NL@%
                SetSwpPos(&aswp[iswpNext++],%@NL@%
                        WinWindowFromID(hwnd, ID_HORZSPLITBAR), NULL,%@NL@%
                        pswpVScroll->x, pswpVScroll->y + pswpVScroll->cy -%@NL@%
                            cyHorzSplitbar,%@NL@%
                        pswpVScroll->cx - cxBorder, cyHorzSplitbar, pswpVScroll->fs);%@NL@%
%@NL@%
                pswpVScroll->cy -= cyHorzSplitbar;%@NL@%
            } else {%@NL@%
                HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_HORZSPLITBAR),%@NL@%
                        &iswpNext);%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now format the original client window.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    aswp[iswpNext] = swpClient;%@NL@%
%@NL@%
    if (npdoc->fs & (DF_SPLITHORZ | DF_SPLITVERT)) {%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Adjust the main client window for the splitbars.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (npdoc->fs & DF_SPLITVERT) {%@NL@%
            aswp[iswpNext].cx = cxVertSplitPos;%@NL@%
        }%@NL@%
%@NL@%
        if ((npdoc->fs & DF_SPLITHORZ) &&%@NL@%
                (pswpVScroll->cy > (SHORT)(cyHorzSplitbar * 3))) {%@NL@%
            aswp[iswpNext].y += (cyHorzSplitPos + cyHorzSplitbar);%@NL@%
            aswp[iswpNext].cy -= (cyHorzSplitPos + cyHorzSplitbar);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    iswpNext++;%@NL@%
%@NL@%
    if (npdoc->fs & DF_SPLITHORZ) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Format the scrollbars and the splitbar.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (pswpVScroll->cy > (SHORT)(cyHorzSplitbar * 3)) {%@NL@%
            SetSwpPos(&aswp[iswpNext++],%@NL@%
                    WinWindowFromID(hwnd, ID_HORZSPLITBAR), NULL,%@NL@%
                    swpClient.x, swpClient.y + cyHorzSplitPos,%@NL@%
                    swpClient.cx + pswpVScroll->cx - cxBorder, cyHorzSplitbar,%@NL@%
                    pswpVScroll->fs | SWP_SHOW);%@NL@%
%@NL@%
            SetSwpPos(&aswp[iswpNext++],%@NL@%
                    WinWindowFromID(hwnd, ID_VERTSCROLL2), NULL,%@NL@%
                    pswpVScroll->x, pswpVScroll->y,%@NL@%
                    pswpVScroll->cx, cyHorzSplitPos + (cyBorder * 2),%@NL@%
                    pswpVScroll->fs | SWP_SHOW);%@NL@%
%@NL@%
            pswpVScroll->y += (cyHorzSplitPos + cyHorzSplitbar);%@NL@%
            pswpVScroll->cy -= (cyHorzSplitPos + cyHorzSplitbar);%@NL@%
%@NL@%
        } else {%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_VERTSCROLL2),%@NL@%
                    &iswpNext);%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_HORZSPLITBAR),%@NL@%
                    &iswpNext);%@NL@%
            HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT3),%@NL@%
                    &iswpNext);%@NL@%
            if (npdoc->fsStyle & DS_VERTSPLITBAR)%@NL@%
                HideSwp(&aswp[iswpNext], WinWindowFromID(hwnd, ID_CLIENT4),%@NL@%
                        &iswpNext);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (npdoc->fs & DF_SPLITVERT) {%@NL@%
%@NL@%
        SetSwpPos(&aswp[iswpNext++],%@NL@%
                WinWindowFromID(hwnd, ID_VERTSPLITBAR), NULL,%@NL@%
                swpClient.x + cxVertSplitPos, pswpHScroll->y + cyBorder,%@NL@%
                cxVertSplitbar, swpClient.cy + pswpHScroll->cy - cyBorder,%@NL@%
                pswpHScroll->fs);%@NL@%
%@NL@%
        SetSwpPos(&aswp[iswpNext++],%@NL@%
                WinWindowFromID(hwnd, ID_HORZSCROLL2), NULL,%@NL@%
                swpClient.x + cxVertSplitPos + cxVertSplitbar - cyBorder,%@NL@%
                pswpHScroll->y, pswpHScroll->cx - (cxVertSplitPos + cxVertSplitbar),%@NL@%
                pswpHScroll->cy, pswpVScroll->fs | SWP_SHOW);%@NL@%
%@NL@%
        pswpHScroll->cx = cxVertSplitPos + (cxBorder * 2);%@NL@%
    }%@NL@%
%@NL@%
    return ( (MRESULT) iswpNext);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MDIINIT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\MDI\MDIINIT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* mdiinit.c - MDI initialization funtions.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINCOMMON %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINRECTANGLES %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%INCL_GPILCIDS %@NL@%
%@AI@%#define %@AE@%INCL_DEV %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"app.h" %@NL@%
%@AI@%#include %@AE@%"appdata.h" %@NL@%
%@AI@%#include %@AE@%"mdi.h" %@NL@%
%@AI@%#include %@AE@%"mdidata.h" %@NL@%
%@NL@%
%@AB@%/* Function prototypes */%@AE@%%@NL@%
VOID InitMDIPointers(VOID);%@NL@%
BOOL SetupMenuStuff(HPS hps);%@NL@%
VOID InitSplitbars(VOID);%@NL@%
VOID InitInitialDocPlacement(VOID);%@NL@%
%@NL@%
%@NL@%
BOOL MDIInit(VOID)%@NL@%
{%@NL@%
    HPS hps;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Register the splitbar window class.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!WinRegisterClass(NULL, szSplitbarClass, (PFNWP)SplitbarWndProc,%@NL@%
            CS_MOVENOTIFY | CS_SYNCPAINT, 0))%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    InitMDIPointers();%@NL@%
%@NL@%
    pfnMainFrameWndProc = WinSubclassWindow(hwndMDIFrame,%@NL@%
            (PFNWP)MainFrameWndProc);%@NL@%
%@NL@%
    hps = WinGetPS(hwndMDI);%@NL@%
%@NL@%
    if (SetupMenuStuff(hps) == FALSE)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    WinReleasePS(hps);%@NL@%
%@NL@%
    InitSplitbars();%@NL@%
%@NL@%
    InitInitialDocPlacement();%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID InitInitialDocPlacement(VOID)%@NL@%
{%@NL@%
    RECTL rclDesktop;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * New documents will be 2/3 the width of the%@NL@%
%@AB@%     * screen and 1/2 the height of the screen.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    cxNewDoc = (cxScreen * 2) / 3;%@NL@%
    cyNewDoc = cyScreen / 2;%@NL@%
%@NL@%
    WinQueryWindowRect(hwndMDI, &rclDesktop);%@NL@%
    xNextNewDoc = 0;%@NL@%
    yNextNewDoc = (SHORT)rclDesktop.yTop - cyNewDoc;%@NL@%
%@NL@%
    xCascadeInc = cxSizeBorder + (cxMinmaxButton / 2);%@NL@%
    yCascadeInc = cySizeBorder + cyTitlebar - cyBorder;%@NL@%
%@NL@%
    xCascadeSlot = 0;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID InitSplitbars()%@NL@%
{%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Calculate the values cxVertSplitbar and cyHorzSplitbar.%@NL@%
%@AB@%     *%@NL@%
%@AB@%     * The horzontal splitbar is 1/3 the height of the vertical%@NL@%
%@AB@%     * scrollbar arrow.  We use the aspect ratio of the display%@NL@%
%@AB@%     * to determine the width of the vertical splitbar.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    cyHorzSplitbar = cyVScrollArrow / 3;%@NL@%
    cxVertSplitbar = (USHORT)(cyHorzSplitbar *%@NL@%
            rglDevCaps[CAPS_HORIZONTAL_RESOLUTION] /%@NL@%
            rglDevCaps[CAPS_VERTICAL_RESOLUTION]);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID InitMDIPointers(VOID)%@NL@%
{%@NL@%
    hptrHorzSplit = WinLoadPointer(HWND_DESKTOP, NULL, IDP_HSPLIT);%@NL@%
    hptrVertSplit = WinLoadPointer(HWND_DESKTOP, NULL, IDP_VSPLIT);%@NL@%
    hptrHVSplit = WinLoadPointer(HWND_DESKTOP, NULL, IDP_HVSPLIT);%@NL@%
    hptrArrow = WinQuerySysPointer(HWND_DESKTOP, SPTR_ARROW, TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
BOOL SetupMenuStuff(HPS hps)%@NL@%
{%@NL@%
    BITMAPINFOHEADER bmpNew, bmpCurrent;%@NL@%
    SIZEL gsize;%@NL@%
    RECTL rclSrc;%@NL@%
    POINTL ptlDst;%@NL@%
    DRIVDATA driv;%@NL@%
    DEVOPENSTRUC dop;%@NL@%
%@NL@%
    HWND hwndMenu;   %@AB@%/* This is the hwnd of the initial menu bar */%@AE@%%@NL@%
%@NL@%
    hbmChildSysMenu = WinGetSysBitmap(HWND_DESKTOP, SBMP_CHILDSYSMENU);%@NL@%
%@NL@%
    GpiQueryFontMetrics(hps, (ULONG)sizeof(FONTMETRICS),%@NL@%
            (PFONTMETRICS)&fmSystemFont);%@NL@%
%@NL@%
    GpiQueryBitmapParameters(hbmChildSysMenu, &bmpCurrent);%@NL@%
    bmpNew.cbFix = sizeof(BITMAPINFOHEADER);%@NL@%
    bmpNew.cx = bmpCurrent.cx + (((bmpCurrent.cx - cxBorder) / 4) * 2);%@NL@%
    bmpNew.cy = bmpCurrent.cy;%@NL@%
    bmpNew.cPlanes = bmpCurrent.cPlanes;%@NL@%
    bmpNew.cBitCount = bmpCurrent.cBitCount;%@NL@%
    hbmAabChildSysMenu = GpiCreateBitmap(hps, &bmpNew, 0L, NULL, NULL);%@NL@%
%@NL@%
    driv.cb = sizeof(ULONG) * 11;%@NL@%
    driv.lVersion = 0;%@NL@%
    driv.szDeviceName[0] = 0;%@NL@%
    driv.abGeneralData[0] = 0L;%@NL@%
%@NL@%
    dop.pszDriverName = NULL;%@NL@%
    dop.pdriv = (PDRIVDATA)&driv;%@NL@%
%@NL@%
    dop.pszLogAddress =%@NL@%
    dop.pszDataType =%@NL@%
    dop.pszComment =%@NL@%
    dop.pszQueueProcName =%@NL@%
    dop.pszQueueProcParams =%@NL@%
    dop.pszSpoolerParams =%@NL@%
    dop.pszNetworkParams = NULL;%@NL@%
%@NL@%
    gsize.cx = bmpNew.cx;%@NL@%
    gsize.cy = bmpNew.cy;%@NL@%
%@NL@%
    hdcMem = DevOpenDC(hps, OD_MEMORY, "*", 8L, (PDEVOPENDATA)&dop, NULL);%@NL@%
    hpsMem = GpiCreatePS(NULL, hdcMem, (PSIZEL)&gsize,%@NL@%
            PU_PELS | GPIF_DEFAULT | GPIT_MICRO | GPIA_ASSOC);%@NL@%
    GpiSetBitmap(hpsMem, hbmAabChildSysMenu);%@NL@%
%@NL@%
    rclSrc.xLeft = 0;%@NL@%
    rclSrc.yBottom = 0;%@NL@%
    rclSrc.xRight = bmpNew.cx;%@NL@%
    rclSrc.yTop = bmpNew.cy;%@NL@%
    WinFillRect(hpsMem, (PRECTL)&rclSrc, CLR_FALSE);%@NL@%
%@NL@%
    rclSrc.xRight = bmpCurrent.cx - cxBorder;%@NL@%
    rclSrc.yTop = bmpCurrent.cy;%@NL@%
    ptlDst.x = (bmpCurrent.cx - cxBorder) / 4;%@NL@%
    ptlDst.y = 0;%@NL@%
    WinDrawBitmap(hpsMem, hbmChildSysMenu, (PRECTL)&rclSrc, (PPOINTL)&ptlDst,%@NL@%
            CLR_TRUE, CLR_FALSE, DBM_NORMAL);%@NL@%
%@NL@%
    GpiSetBitmap(hpsMem, NULL);%@NL@%
    GpiDestroyPS(hpsMem);%@NL@%
    DevCloseDC(hdcMem);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Get menu window handles.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
    hwndMenu = WinWindowFromID(hwndMDIFrame, FID_MENU);%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ** Must not remember the hwnd of the submenu for the list of doc window's%@NL@%
%@AB@%    ** since it will change as the menu bar changes%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%    WinSendMsg(hwndMenu, MM_QUERYITEM, MPFROM2SHORT(IDM_WINDOW, FALSE),%@NL@%
%@AB@%               MPFROMP(&mi));%@NL@%
%@AB@%    hwndWindowMenu = mi.hwndSubMenu;%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
    hwndSysMenu = WinWindowFromID(hwndMDIFrame, FID_SYSMENU);%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    hwndAppMenu = WinWindowFromID(hwndMDIFrame, FID_MENU);%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
    %@AB@%/* set up menuitem for application menu bar sysmenu */%@AE@%%@NL@%
    WinSendMsg(hwndMenu, MM_QUERYITEM, MPFROM2SHORT(IDM_AABDOCSYSMENU, FALSE),%@NL@%
               MPFROMP(&miAabSysMenu));%@NL@%
    miAabSysMenu.hItem = (ULONG)hbmAabChildSysMenu;%@NL@%
    WinSendMsg(hwndMenu, MM_REMOVEITEM, MPFROM2SHORT(IDM_AABDOCSYSMENU, FALSE),%@NL@%
               (MPARAM)NULL);%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID MDITerminate(VOID)%@NL@%
{%@NL@%
BOOL fAabSysMenu;%@NL@%
NPDOC npdoc;%@NL@%
%@NL@%
    fAabSysMenu=FALSE;%@NL@%
    npdoc=npdocFirst;%@NL@%
%@NL@%
    while ((npdoc!=NULL) && (!fAabSysMenu)) {%@NL@%
        fAabSysMenu=npdoc->fAabSysMenu;%@NL@%
        npdoc=npdoc->npdocNext;%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Only destroy the AabSysMenu if it isn't already in *any* AAB.%@NL@%
%@AB@%     * If it is we don't need to destroy it since the frame window%@NL@%
%@AB@%     * manager will.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
  %@AB@%/*  if (fAabSysMenu == FALSE) ????????????????????????  */%@AE@%%@NL@%
%@NL@%
    if (WinIsWindow(hab,miAabSysMenu.hwndSubMenu)) {%@NL@%
        WinDestroyWindow(miAabSysMenu.hwndSubMenu);%@NL@%
        }%@NL@%
%@NL@%
    GpiDeleteBitmap(hbmChildSysMenu);%@NL@%
    GpiDeleteBitmap(hbmAabChildSysMenu);%@NL@%
%@NL@%
    WinDestroyPointer(hptrHorzSplit);%@NL@%
    WinDestroyPointer(hptrVertSplit);%@NL@%
    WinDestroyPointer(hptrHVSplit);%@NL@%
    WinDestroyPointer(hptrArrow);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MDISPLIT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\MDI\MDISPLIT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* split.c - Code for window splitting%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%INCL_WINCOMMON %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%INCL_WINSCROLLBARS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINRECTANGLES %@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"app.h" %@NL@%
%@AI@%#include %@AE@%"appdata.h" %@NL@%
%@AI@%#include %@AE@%"mdi.h" %@NL@%
%@AI@%#include %@AE@%"mdidata.h" %@NL@%
%@NL@%
VOID InvertRect(HPS, PRECTL);%@NL@%
VOID TrackSplitbars(HWND, USHORT, SHORT, SHORT);%@NL@%
VOID FillSplitbarInteriors(USHORT, HWND, HWND);%@NL@%
HWND QueryBotLeftClient(HWND hwndFrame, NPDOC npdoc);%@NL@%
VOID DrawTrackRects(HPS, PRECTL, SHORT, SHORT, USHORT);%@NL@%
VOID MoveTrackRects(HPS, PRECTL, USHORT, SHORT, SHORT, SHORT, SHORT);%@NL@%
VOID CalcTrackRect(PRECTL, PRECTL, SHORT, USHORT);%@NL@%
VOID SetSplitbarPos(HWND, PRECTL, SHORT, SHORT, USHORT);%@NL@%
HWND QueryBotLeftClient(HWND hwndFrame, NPDOC npdoc);%@NL@%
%@NL@%
MRESULT EXPENTRY SplitbarWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    POINTL ptl;%@NL@%
    RECTL rclPaint;%@NL@%
    HWND hwndClient, hwndFrame, hwndOrigin;%@NL@%
    BOOL fControl;%@NL@%
    register NPDOC npdoc;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        hwndFrame = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
        hwndClient = WinWindowFromID(hwndFrame, FID_CLIENT);%@NL@%
%@NL@%
        npdoc = NPDOCFROMCLIENT(hwndClient);%@NL@%
%@NL@%
        hps = WinBeginPaint(hwnd, NULL, NULL);%@NL@%
%@NL@%
        WinQueryWindowRect(hwnd, &rclPaint);%@NL@%
%@NL@%
        if (WinQueryWindowUShort(hwnd, QWS_ID) == ID_VERTSPLITBAR) {%@NL@%
            if (npdoc->fs & DF_SPLITVERT) {%@NL@%
                WinDrawBorder(hps, &rclPaint, 1, 0, SYSCLR_WINDOWFRAME,%@NL@%
                            SYSCLR_WINDOW, DB_STANDARD);%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Make the interiors of the splitbars%@NL@%
%@AB@%                 * visually correct.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                FillSplitbarInteriors(npdoc->fs, hwnd,%@NL@%
                        WinWindowFromID(hwndFrame, ID_HORZSPLITBAR));%@NL@%
            } else {%@NL@%
                WinFillRect(hps, &rclPaint, SYSCLR_WINDOWFRAME);%@NL@%
            }%@NL@%
        } else {%@NL@%
            if (npdoc->fs & DF_SPLITHORZ) {%@NL@%
                WinDrawBorder(hps, &rclPaint, 0, 1, SYSCLR_WINDOWFRAME,%@NL@%
                        SYSCLR_WINDOW, DB_STANDARD | DB_INTERIOR);%@NL@%
            } else {%@NL@%
                WinFillRect(hps, &rclPaint, SYSCLR_WINDOWFRAME);%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
        WinEndPaint(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_MOUSEMOVE:%@NL@%
        hwndFrame = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
        hwndClient = WinWindowFromID(hwndFrame, FID_CLIENT);%@NL@%
%@NL@%
        npdoc = NPDOCFROMCLIENT(hwndClient);%@NL@%
%@NL@%
        ptl.x = SHORT1FROMMP(mp1);%@NL@%
        ptl.y = SHORT2FROMMP(mp1);%@NL@%
%@NL@%
        hwndOrigin = QueryBotLeftClient(hwndFrame, npdoc);%@NL@%
        WinMapWindowPoints(hwnd, hwndOrigin, (PPOINTL)&ptl, 1);%@NL@%
%@NL@%
        if (WinQueryWindowUShort(hwnd, QWS_ID) == ID_VERTSPLITBAR) {%@NL@%
%@NL@%
            if ((npdoc->fs & DF_SPLITHORZ) &&%@NL@%
                    ((SHORT)ptl.y > (npdoc->cyHorzSplitPos - (cyHorzSplitbar))) &&%@NL@%
                    ((SHORT)ptl.y <= (npdoc->cyHorzSplitPos + (cyHorzSplitbar * 2)))) {%@NL@%
                WinSetPointer(HWND_DESKTOP, hptrHVSplit);%@NL@%
            } else {%@NL@%
                WinSetPointer(HWND_DESKTOP, hptrVertSplit);%@NL@%
            }%@NL@%
        } else {%@NL@%
            if ((npdoc->fs & DF_SPLITVERT) &&%@NL@%
                    ((SHORT)ptl.x > (npdoc->cxVertSplitPos - (cxVertSplitbar))) &&%@NL@%
                    ((SHORT)ptl.x <= (npdoc->cxVertSplitPos + (cxVertSplitbar * 2)))) {%@NL@%
                WinSetPointer(HWND_DESKTOP, hptrHVSplit);%@NL@%
            } else {%@NL@%
                WinSetPointer(HWND_DESKTOP, hptrHorzSplit);%@NL@%
            }%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1DOWN:%@NL@%
    case WM_BUTTON1DBLCLK:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Get the control key state here so the user doesn't%@NL@%
%@AB@%         * have to hold it down the whole time to get the%@NL@%
%@AB@%         * desired effect.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        fControl = (WinGetKeyState(HWND_DESKTOP, VK_CTRL) & 0x8000);%@NL@%
%@NL@%
        hwndFrame = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
        hwndClient = WinWindowFromID(hwndFrame, FID_CLIENT);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Update the entire window before we start%@NL@%
%@AB@%         * tracking with the splitter bars.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinUpdateWindow(hwndFrame);%@NL@%
%@NL@%
        npdoc = NPDOCFROMCLIENT(hwndClient);%@NL@%
%@NL@%
        ptl.x = SHORT1FROMMP(mp1);%@NL@%
        ptl.y = SHORT2FROMMP(mp1);%@NL@%
%@NL@%
        hwndOrigin = QueryBotLeftClient(hwndFrame, npdoc);%@NL@%
        WinMapWindowPoints(hwnd, hwndOrigin, (PPOINTL)&ptl, 1);%@NL@%
%@NL@%
        if (WinQueryWindowUShort(hwnd, QWS_ID) == ID_VERTSPLITBAR) {%@NL@%
            if ((npdoc->fs & DF_SPLITHORZ) &&%@NL@%
                    ((SHORT)ptl.y > (npdoc->cyHorzSplitPos - (cyHorzSplitbar))) &&%@NL@%
                    ((SHORT)ptl.y <= (npdoc->cyHorzSplitPos + (cyHorzSplitbar * 2)))) {%@NL@%
                TrackSplitbars(hwndClient, SPS_VERT | SPS_HORZ, (SHORT)ptl.x,%@NL@%
                        (SHORT)ptl.y);%@NL@%
            } else {%@NL@%
                TrackSplitbars(hwndClient, SPS_VERT, (SHORT)ptl.x,%@NL@%
                        (SHORT)ptl.y);%@NL@%
            }%@NL@%
        } else {%@NL@%
            if ((npdoc->fs & DF_SPLITVERT) &&%@NL@%
                    ((SHORT)ptl.x > (npdoc->cxVertSplitPos - (cxVertSplitbar))) &&%@NL@%
                    ((SHORT)ptl.x <= (npdoc->cxVertSplitPos + (cxVertSplitbar * 2)))) {%@NL@%
                TrackSplitbars(hwndClient, SPS_VERT | SPS_HORZ, (SHORT)ptl.x,%@NL@%
                        (SHORT)ptl.y);%@NL@%
            } else {%@NL@%
                TrackSplitbars(hwndClient, SPS_HORZ, (SHORT)ptl.x,%@NL@%
                        (SHORT)ptl.y);%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * If the control key is down, we leave%@NL@%
%@AB@%         * the focus where it is.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (fControl == FALSE)%@NL@%
            WinSetFocus(HWND_DESKTOP, hwndClient);%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    case WM_MOVE:%@NL@%
    case WM_SIZE:%@NL@%
        WinInvalidateRect(hwnd, NULL, FALSE);%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return (0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID FillSplitbarInteriors(USHORT fs, HWND hwndVert, HWND hwndHorz)%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    RECTL rclVertSplitbar, rclHorzSplitbar;%@NL@%
%@NL@%
    if (fs & DF_SPLITVERT) {%@NL@%
        hps = WinGetPS(hwndVert);%@NL@%
        WinQueryWindowRect(hwndVert, &rclVertSplitbar);%@NL@%
        WinInflateRect(NULL, &rclVertSplitbar, -cxBorder, 0);%@NL@%
        WinFillRect(hps, &rclVertSplitbar, SYSCLR_WINDOW);%@NL@%
        WinReleasePS(hps);%@NL@%
    }%@NL@%
%@NL@%
    if (fs & DF_SPLITHORZ) {%@NL@%
        hps = WinGetPS(hwndHorz);%@NL@%
        WinQueryWindowRect(hwndHorz, &rclHorzSplitbar);%@NL@%
        WinInflateRect(NULL, &rclHorzSplitbar, 0, -cyBorder);%@NL@%
        WinFillRect(hps, &rclHorzSplitbar, SYSCLR_WINDOW);%@NL@%
        WinReleasePS(hps);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
BOOL CreateSplitbarWindows(HWND hwndFrame, NPDOC npdoc)%@NL@%
{%@NL@%
    USHORT fsStyle;%@NL@%
    register NPVIEW npview, npviewNew;%@NL@%
    HWND hwndNewClient;%@NL@%
%@NL@%
    fsStyle = npdoc->fsStyle;%@NL@%
    npview = npdoc->npviewFirst;%@NL@%
%@NL@%
    if (fsStyle & DS_VERTSPLITBAR) {%@NL@%
        if (WinCreateWindow(hwndFrame, WC_SCROLLBAR, "",%@NL@%
                SBS_HORZ, 0, 0, 0, 0, hwndFrame,%@NL@%
                WinWindowFromID(hwndFrame, FID_HORZSCROLL),%@NL@%
                ID_HORZSCROLL2, NULL, NULL) == NULL)%@NL@%
            return (FALSE);%@NL@%
%@NL@%
        if (WinCreateWindow(hwndFrame, szSplitbarClass, "",%@NL@%
                (ULONG)SPS_VERT, 0, 0, 0, 0, hwndFrame,%@NL@%
                WinWindowFromID(hwndFrame, FID_MINMAX),%@NL@%
                ID_VERTSPLITBAR, NULL, NULL) == NULL)%@NL@%
            return (FALSE);%@NL@%
%@NL@%
        hwndNewClient = WinCreateWindow(hwndFrame, szDocClass, "",%@NL@%
                0L, 0, 0, 0, 0, hwndFrame,%@NL@%
                WinWindowFromID(hwndFrame, FID_CLIENT),%@NL@%
                ID_CLIENT2, NULL, NULL);%@NL@%
        if (hwndNewClient == NULL)%@NL@%
            return (FALSE);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Link ID_CLIENT2 into npdoc's view list.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        npviewNew = NPVIEWFROMCLIENT(hwndNewClient);%@NL@%
        npview->npviewNext = npviewNew;%@NL@%
        npview = npviewNew;%@NL@%
    }%@NL@%
%@NL@%
    if (fsStyle & DS_HORZSPLITBAR) {%@NL@%
        if (WinCreateWindow(hwndFrame, WC_SCROLLBAR, "",%@NL@%
                SBS_VERT, 0, 0, 0, 0, hwndFrame,%@NL@%
                WinWindowFromID(hwndFrame, FID_VERTSCROLL),%@NL@%
                ID_VERTSCROLL2, NULL, NULL) == NULL)%@NL@%
            return (FALSE);%@NL@%
%@NL@%
        if (WinCreateWindow(hwndFrame, szSplitbarClass, "",%@NL@%
                (ULONG)SPS_HORZ, 0, 0, 0, 0, hwndFrame,%@NL@%
                WinWindowFromID(hwndFrame, FID_MINMAX),%@NL@%
                ID_HORZSPLITBAR, NULL, NULL) == NULL)%@NL@%
            return (FALSE);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * If we're split vertically as well, then we want to%@NL@%
%@AB@%         * insert ID_CLIENT3 behind ID_CLIENT2 and create%@NL@%
%@AB@%         * ID_CLIENT4 behind CLIENT3, otherwise we just create%@NL@%
%@AB@%         * ID_CLIENT3 behind FID_CLIENT.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (fsStyle & DS_VERTSPLITBAR) {%@NL@%
            hwndNewClient = WinCreateWindow(hwndFrame, szDocClass, "",%@NL@%
                    0L, 0, 0, 0, 0, hwndFrame,%@NL@%
                    WinWindowFromID(hwndFrame, ID_CLIENT2),%@NL@%
                    ID_CLIENT3, NULL, NULL);%@NL@%
            if (hwndNewClient == NULL)%@NL@%
                return (FALSE);%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Link ID_CLIENT3 into npdoc's view list.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            npviewNew = NPVIEWFROMCLIENT(hwndNewClient);%@NL@%
            npview->npviewNext = npviewNew;%@NL@%
            npview = npviewNew;%@NL@%
%@NL@%
            hwndNewClient = WinCreateWindow(hwndFrame, szDocClass, "",%@NL@%
                    0L, 0, 0, 0, 0, hwndFrame,%@NL@%
                    WinWindowFromID(hwndFrame, ID_CLIENT3),%@NL@%
                    ID_CLIENT4, NULL, NULL);%@NL@%
            if (hwndNewClient == NULL)%@NL@%
                return (FALSE);%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Link ID_CLIENT4 into npdoc's view list.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            npviewNew = NPVIEWFROMCLIENT(hwndNewClient);%@NL@%
            npview->npviewNext = npviewNew;%@NL@%
            npview = npviewNew;%@NL@%
%@NL@%
        } else {%@NL@%
            hwndNewClient = WinCreateWindow(hwndFrame, szDocClass, "",%@NL@%
                    0L, 0, 0, 0, 0, hwndFrame,%@NL@%
                    WinWindowFromID(hwndFrame, FID_CLIENT),%@NL@%
                    ID_CLIENT3, NULL, NULL);%@NL@%
            if (hwndNewClient == NULL)%@NL@%
                return (FALSE);%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Link ID_CLIENT3 into npdoc's view list.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            npviewNew = NPVIEWFROMCLIENT(hwndNewClient);%@NL@%
            npview->npviewNext = npviewNew;%@NL@%
            npview = npviewNew;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    return (TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
HWND QueryBotLeftClient(HWND hwndFrame, NPDOC npdoc)%@NL@%
{%@NL@%
    if (npdoc->fs & DF_SPLITHORZ) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * If there isn't enough room to split%@NL@%
%@AB@%         * then only the main client will be%@NL@%
%@AB@%         * visible so we'll use it.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (WinIsWindowVisible(WinWindowFromID(hwndFrame, ID_HORZSPLITBAR)))%@NL@%
            return (WinWindowFromID(hwndFrame, ID_CLIENT3));%@NL@%
        else%@NL@%
            return (WinWindowFromID(hwndFrame, FID_CLIENT));%@NL@%
%@NL@%
    } else {%@NL@%
        return (WinWindowFromID(hwndFrame, FID_CLIENT));%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
VOID TrackSplitbars(HWND hwndClient, register USHORT fsTrack, SHORT xMouse,%@NL@%
        SHORT yMouse)%@NL@%
{%@NL@%
    SHORT x, y;%@NL@%
    SHORT xNew, yNew;%@NL@%
    HPS hps;%@NL@%
    RECTL rclClient, rclClientScreen;%@NL@%
    QMSG qmsg;%@NL@%
    AREABUNDLE abnd;%@NL@%
    HWND hwndFrame, hwndOrigin;%@NL@%
    register NPDOC npdoc;%@NL@%
    POINTL ptlPointer;%@NL@%
%@NL@%
    hwndFrame = WinQueryWindow(hwndClient, QW_PARENT, FALSE);%@NL@%
%@NL@%
    WinLockWindowUpdate(HWND_DESKTOP, hwndFrame);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If we're split horizontally then we want the%@NL@%
%@AB@%     * origin to be a ID_CLIENT3's origin, otherwise%@NL@%
%@AB@%     * we want FID_CLIENT's origin.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    npdoc = NPDOCFROMCLIENT(hwndClient);%@NL@%
    hwndOrigin = QueryBotLeftClient(hwndFrame, npdoc);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * We use WinCalcFrameRect() to get the client rectangle%@NL@%
%@AB@%     * rather than WinQueryWindowRect() because the window%@NL@%
%@AB@%     * might already be split, so hwndClient's rectangle wouldn't%@NL@%
%@AB@%     * necessarily include the area we want.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinQueryWindowRect(hwndFrame, &rclClient);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Map rectangle to screen coordinates because%@NL@%
%@AB@%     * WinCalcFrameRect() will byte-align the client.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinMapWindowPoints(hwndFrame, HWND_DESKTOP, (PPOINTL)&rclClient, 2);%@NL@%
    WinCalcFrameRect(hwndFrame, &rclClient, TRUE);%@NL@%
%@NL@%
    WinCopyRect(NULL, &rclClientScreen, &rclClient);%@NL@%
    WinMapWindowPoints(HWND_DESKTOP, hwndOrigin, (PPOINTL)&rclClient, 2);%@NL@%
%@NL@%
    WinSetCapture(HWND_DESKTOP, hwndOrigin);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * We get a PSF_PARENTCLIP PS so we can draw the%@NL@%
%@AB@%     * splitbars through the other client windows,%@NL@%
%@AB@%     * but still get the PS origin we want.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    hps = WinGetClipPS(hwndOrigin, NULL,%@NL@%
            PSF_PARENTCLIP | PSF_LOCKWINDOWUPDATE);%@NL@%
%@NL@%
    abnd.usSymbol = PATSYM_HALFTONE;%@NL@%
    abnd.lColor = CLR_TRUE;%@NL@%
    abnd.lBackColor = CLR_FALSE;%@NL@%
    GpiSetAttrs(hps, PRIM_AREA, ABB_SYMBOL | ABB_COLOR | ABB_BACK_COLOR, 0L,%@NL@%
            (PBUNDLE)&abnd);%@NL@%
%@NL@%
    if (fsTrack & SPS_HORZ) {%@NL@%
        if (npdoc->fs & DF_SPLITHORZ) {%@NL@%
            y = npdoc->cyHorzSplitPos + (cyHorzSplitbar / 2);%@NL@%
        } else if (npdoc->fs & DF_HSPLITOVERFLOW) {%@NL@%
            y = 0;%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Clear the overflow flag since the%@NL@%
%@AB@%             * user can't track to an overflown%@NL@%
%@AB@%             * position.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            npdoc->fs &= ~DF_HSPLITOVERFLOW;%@NL@%
        } else {%@NL@%
            y = (SHORT)rclClient.yTop - (cyHorzSplitbar / 2);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (fsTrack & SPS_VERT) {%@NL@%
        if (npdoc->fs & DF_SPLITVERT) {%@NL@%
            x = npdoc->cxVertSplitPos + (cxVertSplitbar / 2);%@NL@%
        } else if (npdoc->fs & DF_VSPLITOVERFLOW) {%@NL@%
            x = (SHORT)rclClient.xRight - cxVertSplitbar;%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Clear the overflow flag since the%@NL@%
%@AB@%             * user can't track to an overflown%@NL@%
%@AB@%             * position.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            npdoc->fs &= ~DF_VSPLITOVERFLOW;%@NL@%
        } else {%@NL@%
            x = (cxVertSplitbar / 2);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If xMouse is -1, then we want to set the pointer%@NL@%
%@AB@%     * position to the position of the splitbars.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (xMouse == -1) {%@NL@%
        xMouse = x;%@NL@%
        yMouse = y;%@NL@%
        ptlPointer.x = x;%@NL@%
        ptlPointer.y = y;%@NL@%
        WinMapWindowPoints(hwndOrigin, HWND_DESKTOP, (PPOINTL)&ptlPointer, 1);%@NL@%
        WinSetPointerPos(HWND_DESKTOP, (SHORT)ptlPointer.x, (SHORT)ptlPointer.y);%@NL@%
    }%@NL@%
%@NL@%
    DrawTrackRects(hps, &rclClient, x, y, fsTrack);%@NL@%
%@NL@%
    while (WinGetMsg(NULL, (PQMSG)&qmsg, NULL, NULL, NULL)) {%@NL@%
        switch (qmsg.msg) {%@NL@%
%@NL@%
        case WM_BUTTON1UP:%@NL@%
            DrawTrackRects(hps, &rclClient, x, y, fsTrack);%@NL@%
            WinLockWindowUpdate(HWND_DESKTOP, NULL);%@NL@%
            SetSplitbarPos(hwndClient, &rclClient, x, y, fsTrack);%@NL@%
            goto exit_no_unlock;%@NL@%
%@NL@%
        case WM_CHAR:%@NL@%
            if ((((USHORT) (ULONG) qmsg.mp1 &%@NL@%
                    (KC_KEYUP | KC_DEADKEY | KC_COMPOSITE | KC_INVALIDCOMP))%@NL@%
                    == 0) && ((USHORT) (ULONG) qmsg.mp1 & KC_VIRTUALKEY)) {%@NL@%
%@NL@%
                WinQueryPointerPos(HWND_DESKTOP, (PPOINTL)&ptlPointer);%@NL@%
                switch (SHORT2FROMMP(qmsg.mp2)) {%@NL@%
%@NL@%
                case VK_UP:%@NL@%
                    ptlPointer.y += (cyHorzSplitbar * 2);%@NL@%
                    break;%@NL@%
%@NL@%
                case VK_DOWN:%@NL@%
                    ptlPointer.y -= (cyHorzSplitbar * 2);%@NL@%
                    break;%@NL@%
%@NL@%
                case VK_RIGHT:%@NL@%
                    ptlPointer.x += (cxVertSplitbar * 2);%@NL@%
                    break;%@NL@%
%@NL@%
                case VK_LEFT:%@NL@%
                    ptlPointer.x -= (cxVertSplitbar * 2);%@NL@%
                    break;%@NL@%
%@NL@%
                case VK_ENTER:%@NL@%
                case VK_NEWLINE:%@NL@%
                    DrawTrackRects(hps, &rclClient, x, y, SPS_HORZ | SPS_VERT);%@NL@%
                    WinLockWindowUpdate(HWND_DESKTOP, NULL);%@NL@%
                    SetSplitbarPos(hwndClient, &rclClient, x, y,%@NL@%
                            SPS_HORZ | SPS_VERT);%@NL@%
                    goto exit_no_unlock;%@NL@%
%@NL@%
                case VK_ESC:%@NL@%
                    DrawTrackRects(hps, &rclClient, x, y, SPS_HORZ | SPS_VERT);%@NL@%
                    goto exit;%@NL@%
                }%@NL@%
                if ((SHORT)ptlPointer.x < (SHORT)rclClientScreen.xLeft)%@NL@%
                    ptlPointer.x = rclClientScreen.xLeft;%@NL@%
                else if ((SHORT)ptlPointer.x > (SHORT)rclClientScreen.xRight)%@NL@%
                    ptlPointer.x = rclClientScreen.xRight;%@NL@%
%@NL@%
                if ((SHORT)ptlPointer.y < (SHORT)rclClientScreen.yBottom)%@NL@%
                    ptlPointer.y = rclClientScreen.yBottom;%@NL@%
                else if ((SHORT)ptlPointer.y > (SHORT)rclClientScreen.yTop)%@NL@%
                    ptlPointer.y = rclClientScreen.yTop;%@NL@%
%@NL@%
                WinSetPointerPos(HWND_DESKTOP, (SHORT)ptlPointer.x,%@NL@%
                        (SHORT)ptlPointer.y);%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case WM_MOUSEMOVE:%@NL@%
            xNew = x + (SHORT1FROMMP(qmsg.mp1) - xMouse);%@NL@%
            xMouse = SHORT1FROMMP(qmsg.mp1);%@NL@%
            yNew = y + (SHORT2FROMMP(qmsg.mp1) - yMouse);%@NL@%
            yMouse = SHORT2FROMMP(qmsg.mp1);%@NL@%
%@NL@%
            MoveTrackRects(hps, &rclClient, fsTrack, x, y, xNew, yNew);%@NL@%
            x = xNew;%@NL@%
            y = yNew;%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            WinDispatchMsg(NULL, (PQMSG)&qmsg);%@NL@%
            break;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
exit:%@NL@%
    WinLockWindowUpdate(HWND_DESKTOP, NULL);%@NL@%
exit_no_unlock:%@NL@%
    WinReleasePS(hps);%@NL@%
    WinSetCapture(HWND_DESKTOP, NULL);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID SetSplitbarPos(HWND hwndClient, PRECTL prclClient, SHORT x, SHORT y,%@NL@%
        USHORT fsTrack)%@NL@%
{%@NL@%
    register NPDOC npdoc;%@NL@%
    register NPVIEW npview1, npview2, npview3, npview4;%@NL@%
    HWND hwndFrame;%@NL@%
    RECTL rclTrack;%@NL@%
%@NL@%
    npview1 = (NPVIEW)WinQueryWindowUShort(hwndClient, QWS_USER);%@NL@%
    npdoc = npview1->npdoc;%@NL@%
    hwndFrame = WinQueryWindow(hwndClient, QW_PARENT, FALSE);%@NL@%
%@NL@%
    if (npdoc->fsStyle & DS_VERTSPLITBAR) {%@NL@%
        npview2 = (NPVIEW)WinQueryWindowUShort(%@NL@%
                WinWindowFromID(hwndFrame, ID_CLIENT2), QWS_USER);%@NL@%
    }%@NL@%
%@NL@%
    if (npdoc->fsStyle & DS_HORZSPLITBAR) {%@NL@%
        npview3 = (NPVIEW)WinQueryWindowUShort(%@NL@%
                WinWindowFromID(hwndFrame, ID_CLIENT3), QWS_USER);%@NL@%
    }%@NL@%
%@NL@%
    if (npdoc->fsStyle & (DS_HORZSPLITBAR | DS_VERTSPLITBAR)) {%@NL@%
        npview4 = (NPVIEW)WinQueryWindowUShort(%@NL@%
                WinWindowFromID(hwndFrame, ID_CLIENT4), QWS_USER);%@NL@%
    }%@NL@%
%@NL@%
    if (fsTrack & SPS_VERT) {%@NL@%
        CalcTrackRect(prclClient, &rclTrack, x, SPS_VERT);%@NL@%
        npdoc->cxVertSplitPos = (SHORT) rclTrack.xLeft;%@NL@%
        if ((npdoc->cxVertSplitPos < (SHORT) cxVertSplitbar) ||%@NL@%
                (npdoc->cxVertSplitPos >%@NL@%
                ((SHORT)prclClient->xRight - (cxVertSplitbar * 2)))) {%@NL@%
            npdoc->fs &= ~DF_SPLITVERT;%@NL@%
        } else {%@NL@%
            npdoc->fs |= DF_SPLITVERT;%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Setup ID_CLIENT2 with the same yOrigin%@NL@%
%@AB@%             * as FID_CLIENT.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            npview2->yOrigin = npview1->yOrigin;%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If we were horizontally split already, then%@NL@%
%@AB@%             * set ID_CLIENT4 to the same yOrigin%@NL@%
%@AB@%             * as ID_CLIENT3.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (npdoc->fs & DF_SPLITHORZ)%@NL@%
                npview4->yOrigin = npview3->yOrigin;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (fsTrack & SPS_HORZ) {%@NL@%
        CalcTrackRect(prclClient, &rclTrack, y, SPS_HORZ);%@NL@%
        npdoc->cyHorzSplitPos = (SHORT)rclTrack.yBottom;%@NL@%
        if ((npdoc->cyHorzSplitPos >%@NL@%
                ((SHORT)prclClient->yTop - (cyHorzSplitbar * 2))) ||%@NL@%
                (npdoc->cyHorzSplitPos < (SHORT) cyHorzSplitbar)) {%@NL@%
            npdoc->fs &= ~DF_SPLITHORZ;%@NL@%
        } else {%@NL@%
            npdoc->fs |= DF_SPLITHORZ;%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Setup ID_CLIENT3 with the same xOrigin%@NL@%
%@AB@%             * as FID_CLIENT.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            npview3->xOrigin = npview1->xOrigin;%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * If we were vertically split already, then%@NL@%
%@AB@%             * set ID_CLIENT4 to the same xOrigin%@NL@%
%@AB@%             * as ID_CLIENT2.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (npdoc->fs & DF_SPLITHORZ)%@NL@%
                npview4->xOrigin = npview2->xOrigin;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    WinSendMsg(hwndFrame, WM_UPDATEFRAME, 0L, 0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID CalcTrackRect(PRECTL prclClient, PRECTL prcl, SHORT coord, USHORT fsTrack)%@NL@%
{%@NL@%
    if (fsTrack & SPS_VERT) {%@NL@%
        WinSetRect(NULL, prcl, coord - (cxVertSplitbar / 2), 0,%@NL@%
                coord + (cxVertSplitbar - (cxVertSplitbar / 2)),%@NL@%
                (SHORT)prclClient->yTop);%@NL@%
%@NL@%
        if ((SHORT)prcl->xLeft < 0)%@NL@%
            WinOffsetRect(NULL, prcl, (SHORT)-(prcl->xLeft), 0);%@NL@%
        else if ((SHORT)prcl->xRight > (SHORT)prclClient->xRight)%@NL@%
            WinOffsetRect(NULL, prcl,%@NL@%
                    -((SHORT)prcl->xRight - (SHORT)prclClient->xRight), 0);%@NL@%
    } else if (fsTrack & SPS_HORZ) {%@NL@%
        WinSetRect(NULL, prcl, 0, coord - (cyHorzSplitbar / 2),%@NL@%
                (SHORT)prclClient->xRight,%@NL@%
                coord + (cyHorzSplitbar - (cyHorzSplitbar / 2)));%@NL@%
%@NL@%
        if ((SHORT)prcl->yBottom < 0)%@NL@%
            WinOffsetRect(NULL, prcl, 0, (SHORT)-(prcl->yBottom));%@NL@%
        else if ((SHORT)prcl->yTop > (SHORT)prclClient->yTop)%@NL@%
            WinOffsetRect(NULL, prcl,%@NL@%
                    0, -((SHORT)prcl->yTop - (SHORT)prclClient->yTop));%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID DrawTrackRects(HPS hps, PRECTL prclClient, SHORT x, SHORT y,%@NL@%
        USHORT fsTrack)%@NL@%
{%@NL@%
    RECTL rclFill;%@NL@%
%@NL@%
    VOID CalcTrackRect(PRECTL, PRECTL, SHORT, USHORT);%@NL@%
%@NL@%
    if (fsTrack & SPS_VERT) {%@NL@%
        CalcTrackRect(prclClient, (PRECTL)&rclFill, x, SPS_VERT);%@NL@%
%@NL@%
        InvertRect(hps, (PRECTL)&rclFill);%@NL@%
    }%@NL@%
%@NL@%
    if (fsTrack & SPS_HORZ) {%@NL@%
        CalcTrackRect(prclClient, (PRECTL)&rclFill, y, SPS_HORZ);%@NL@%
%@NL@%
        InvertRect(hps, (PRECTL)&rclFill);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID MoveTrackRects(HPS hps, PRECTL prclClient, USHORT fsTrack, SHORT xOld,%@NL@%
        SHORT yOld, SHORT xNew, SHORT yNew)%@NL@%
{%@NL@%
    RECTL rclOld, rclNew, rclScratch;%@NL@%
    VOID CalcTrackRect(PRECTL, PRECTL, SHORT, USHORT);%@NL@%
%@NL@%
    if (fsTrack & SPS_VERT) {%@NL@%
        CalcTrackRect(prclClient, (PRECTL)&rclOld, xOld, SPS_VERT);%@NL@%
        CalcTrackRect(prclClient, (PRECTL)&rclNew, xNew, SPS_VERT);%@NL@%
%@NL@%
        if (WinSubtractRect(NULL, &rclScratch, &rclOld, &rclNew))%@NL@%
            InvertRect(hps, (PRECTL)&rclScratch);%@NL@%
        if (WinSubtractRect(NULL, &rclScratch, &rclNew, &rclOld))%@NL@%
            InvertRect(hps, (PRECTL)&rclScratch);%@NL@%
    }%@NL@%
%@NL@%
    if (fsTrack & SPS_HORZ) {%@NL@%
        CalcTrackRect(prclClient, (PRECTL)&rclOld, yOld, SPS_HORZ);%@NL@%
        CalcTrackRect(prclClient, (PRECTL)&rclNew, yNew, SPS_HORZ);%@NL@%
%@NL@%
        if (WinSubtractRect(NULL, &rclScratch, &rclOld, &rclNew))%@NL@%
            InvertRect(hps, (PRECTL)&rclScratch);%@NL@%
        if (WinSubtractRect(NULL, &rclScratch, &rclNew, &rclOld))%@NL@%
            InvertRect(hps, (PRECTL)&rclScratch);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID InvertRect(HPS hps, PRECTL prcl)%@NL@%
{%@NL@%
    RECTL rclParm[2];%@NL@%
%@NL@%
    WinCopyRect(NULL, (PRECTL)&rclParm[0], (PRECTL)prcl);%@NL@%
    rclParm[1].xLeft = 0;%@NL@%
    rclParm[1].yBottom = 0;%@NL@%
    GpiBitBlt(hps, (HPS)NULL, 3L, (PPOINTL)rclParm, ROP_PATINVERT, 0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID FindSwp(PSWP aswp, register USHORT cswp, USHORT id, PSWP FAR *ppswp)%@NL@%
{%@NL@%
    register i;%@NL@%
%@NL@%
    for (i = 0; i < (SHORT) cswp; i++) {%@NL@%
        if (WinQueryWindowUShort(aswp[i].hwnd, QWS_ID) == id) {%@NL@%
            *ppswp = &aswp[i];%@NL@%
            return;%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Set the SWP structure to the passed in parameters.%@NL@%
%@AB@% *%@NL@%
%@AB@% * This routine is dependent on the order of elements%@NL@%
%@AB@% * in the SWP structure.%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID SetSwpPos(PSWP pswp, HWND hwnd, HWND hwndInsertBehind, SHORT x, SHORT y,%@NL@%
        SHORT cx, SHORT cy, USHORT fs)%@NL@%
{%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        *pswp = *((PSWP)&fs);%@NL@%
%@AB@%    */%@AE@%%@NL@%
    pswp->hwnd                        =        hwnd;%@NL@%
    pswp->hwndInsertBehind        =        hwndInsertBehind;%@NL@%
    pswp->x                        =        x;%@NL@%
    pswp->y                        =        y;%@NL@%
    pswp->cx                        =        cx;%@NL@%
    pswp->cy                        =        cy;%@NL@%
    pswp->fs                        =        fs;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
VOID HideSwp(PSWP pswp, HWND hwnd, USHORT *piswp)%@NL@%
{%@NL@%
    if (WinIsWindowVisible(hwnd)) {%@NL@%
        SetSwpPos(pswp, hwnd, NULL, 0, 0, 0, 0, SWP_HIDE);%@NL@%
        (*piswp)++;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MEM.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\STOCK\MEM.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***        mem.c - memory definitions%@NL@%
%@AB@% *%@NL@%
%@AB@% *        routines that layer C run-time library memory%@NL@%
%@AB@% *        routines to provide debugging assistance.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        History%@NL@%
%@AB@% *            07-Mar-1990 bens        Initial version.%@NL@%
%@AB@% *            08-Mar-1990 bens        Added heap check code%@NL@%
%@AB@% *            16-Mar-1990 bens        MyAlloc should return NULL on failure!%@NL@%
%@AB@% */%@AE@%%@NL@%
%@AI@%#ifdef %@AE@%CHECKASSERTS %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<memory.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"mem.h" %@NL@%
%@NL@%
typedef ULONG MEMSIG;         // ms%@NL@%
typedef MEMSIG *PMEMSIG; // pms%@NL@%
%@NL@%
typedef struct mh_s {         // mh%@NL@%
    MEMSIG            ms;                 // Head signature%@NL@%
    USHORT            cb;                 // Size of user block%@NL@%
    struct mh_s *   pmhNext;                // Next block%@NL@%
    struct mh_s *   pmhPrev;                // Previous block%@NL@%
    // char ach[?];                        // User block; length is cb%@NL@%
    // MEMSIG ms[?];                        // Tail signature area%@NL@%
} MEMHDR;%@NL@%
typedef MEMHDR *PMEMHDR; // pmh%@NL@%
%@NL@%
%@AI@%#define %@AE@%MEMSIG_HEAD    0x12345678L %@NL@%
%@AI@%#define %@AE@%MEMSIG_TAIL    0x87654321L %@NL@%
%@AI@%#define %@AE@%MEMSIG_BAD     0L %@NL@%
%@AI@%#define %@AE@%TAIL_SIZE   2                        // 8-byte tail %@NL@%
%@NL@%
void FailAssert(char *sz);%@NL@%
%@NL@%
char achBug[CCHMAXPATH];                // Buffer for formatting errors%@NL@%
PMEMHDR pmhList=NULL;                        // List of memory blocks%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        FailAssert - common exit for assertion failure%@NL@%
%@AB@%*%@NL@%
%@AB@%*        ENTRY        sz - message string%@NL@%
%@AB@%*%@NL@%
%@AB@%*        EXIT        issue message and exit%@NL@%
%@AB@%*/%@AE@%%@NL@%
void FailAssert(char *sz)%@NL@%
{%@NL@%
    WinMessageBox(HWND_DESKTOP, HWND_DESKTOP, sz,%@NL@%
        "Assertion Failure", 0, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);%@NL@%
    DosExit(1,2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void MyCheckHeap(char *pszFile,USHORT line)%@NL@%
{%@NL@%
    PMEMHDR pmh;%@NL@%
%@NL@%
    for (pmh = pmhList; pmh != NULL; pmh = pmh->pmhNext)%@NL@%
        MyAssert((char *)pmh+sizeof(MEMHDR),pszFile,line);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void MyAssert(void *pv,char *pszFile,USHORT line)%@NL@%
{%@NL@%
    USHORT  cb;%@NL@%
    int     i;%@NL@%
    PMEMHDR pmh;%@NL@%
    PMEMSIG pms;%@NL@%
%@NL@%
    pmh = (PMEMHDR)((char *)pv - sizeof(MEMHDR));%@NL@%
    if (pmh > pv) {                        // Pointer wrapped%@NL@%
        sprintf(achBug,"%s:%d: panic: NULL pointer(?)",pszFile,line);%@NL@%
        FailAssert(achBug);%@NL@%
    }%@NL@%
%@NL@%
    // Test head signature%@NL@%
    if (pmh->ms != MEMSIG_HEAD) {%@NL@%
        sprintf(achBug,"%s:%d: panic: memory header trashed",pszFile,line);%@NL@%
        FailAssert(achBug);%@NL@%
    } else {%@NL@%
        // Test tail signatures%@NL@%
        pms = (PMEMSIG)( (char *)pmh + sizeof(MEMHDR) + pmh->cb );%@NL@%
        for (i=0; i<TAIL_SIZE; i++) {%@NL@%
            if (*pms++ != MEMSIG_TAIL) {%@NL@%
                sprintf(achBug,"%s:%d: panic: memory tail trashed",pszFile,line);%@NL@%
                FailAssert(achBug);%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void MyFree(void *pv,char *pszFile,USHORT line)%@NL@%
{%@NL@%
    PMEMHDR pmh;%@NL@%
%@NL@%
    MyAssert(pv,pszFile,line);%@NL@%
%@NL@%
    pmh = (PMEMHDR)((char *)pv - sizeof(MEMHDR));%@NL@%
%@NL@%
    // Make previous block point to next block%@NL@%
    if (pmh->pmhPrev != NULL) {         // pmh is not at front of list%@NL@%
        // before: a->p->?%@NL@%
        pmh->pmhPrev->pmhNext = pmh->pmhNext;%@NL@%
        // after:  a->?%@NL@%
    }%@NL@%
    else {                                // pmh is at front of list%@NL@%
        // before: list->p->?%@NL@%
        pmhList = pmh->pmhNext;%@NL@%
        // after: list->?%@NL@%
    }%@NL@%
%@NL@%
    // Make next block point to previous block%@NL@%
    if (pmh->pmhNext != NULL) {         // pmh is not at end of list%@NL@%
        // before: ?<-p<->a%@NL@%
        pmh->pmhNext->pmhPrev = pmh->pmhPrev;%@NL@%
        // after:  ?<-a%@NL@%
    }%@NL@%
%@NL@%
    // Obliterate signature%@NL@%
    pmh->ms = MEMSIG_BAD;%@NL@%
%@NL@%
    // Free memory%@NL@%
    free((char *)pmh);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void *MyAlloc(USHORT cb,char *pszFile,USHORT line)%@NL@%
{%@NL@%
    USHORT        cbAlloc;%@NL@%
    int         i;%@NL@%
    char *        pch;%@NL@%
    PMEMHDR        pmh;%@NL@%
    PMEMSIG        pms;%@NL@%
%@NL@%
    MyCheckHeap(pszFile,line);%@NL@%
%@NL@%
    cbAlloc = cb+sizeof(MEMHDR)+sizeof(MEMSIG_TAIL)*TAIL_SIZE;%@NL@%
    pmh = malloc(cbAlloc);%@NL@%
    if (pmh != NULL) {%@NL@%
        pmh->ms = MEMSIG_HEAD;                // Store head signature%@NL@%
        pmh->cb = cb;                        // Store size of user block%@NL@%
%@NL@%
        // Add block to front of list (Easiest code!)%@NL@%
        if (pmhList != NULL)                // List is not empty%@NL@%
            pmhList->pmhPrev = pmh;        // Point old top block back at us%@NL@%
        pmh->pmhNext = pmhList;         // Next element is old top block%@NL@%
        pmh->pmhPrev = NULL;                // We are first, so no prev block%@NL@%
        pmhList = pmh;                        // Make ourselves first%@NL@%
%@NL@%
        // Fill in tail signatures%@NL@%
        pms = (PMEMSIG)( (char *)pmh + sizeof(MEMHDR) + pmh->cb );%@NL@%
        for (i=0; i<TAIL_SIZE; i++)%@NL@%
            *pms++ = MEMSIG_TAIL;%@NL@%
        return ((char *)pmh + sizeof(MEMHDR));%@NL@%
    }%@NL@%
    else {%@NL@%
        printf("panic: out of memory in MyAlloc\n");%@NL@%
        printf("\n");%@NL@%
        printf("Dump of heap (newest alloc to oldest)\n");%@NL@%
        printf("\n");%@NL@%
        printf("Size  Addr Content\n");%@NL@%
        printf("----- ---- -------\n");%@NL@%
        for (pmh = pmhList; pmh != NULL; pmh = pmh->pmhNext) {%@NL@%
            pch = (char *)pmh + sizeof(MEMHDR);%@NL@%
            printf("%5d %04x %s\n",pmh->cb,(USHORT)pch,pch);%@NL@%
        }%@NL@%
        return NULL;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
char *MyStrDup(char *pch,char *pszFile,USHORT line)%@NL@%
{%@NL@%
    USHORT  cb;%@NL@%
    char *  pchDst;%@NL@%
%@NL@%
    cb = strlen(pch)+1;                 // Count NUL terminator%@NL@%
    pchDst = MyAlloc(cb,pszFile,line);        // Alloc new copy%@NL@%
    if (pchDst != NULL) {                //  Success%@NL@%
        memcpy(pchDst,pch,cb);                // Copy string%@NL@%
    }%@NL@%
    return pchDst;                        // Return string copy%@NL@%
}%@NL@%
%@AI@%#endif %@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MEM.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\MEM.C%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"ddemlp.h" %@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Memory routines%@NL@%
%@AB@% *%@NL@%
%@AB@% *  These routines simplify and centralize memory handling to help reduce%@NL@%
%@AB@% *  selector usage overhead and ease transport to 32 bit memory models.%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Debugging routines --------------------------------------------------%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
PBYTE FarAllocMem(hheap, cb)%@NL@%
HHEAP hheap;%@NL@%
USHORT cb;%@NL@%
{%@NL@%
    register NPBYTE pb;%@NL@%
%@NL@%
    pb = MyAllocMem(hheap, cb);%@NL@%
    if (pb == NULL)%@NL@%
        return(NULL);%@NL@%
    return(MAKEP(SELECTOROF(hheap), pb));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AI@%#ifdef %@AE@%DEBUG %@NL@%
%@NL@%
%@AI@%#define %@AE@%MAX_SQUIRL 400 %@NL@%
%@AI@%#define %@AE@%HPSIG 0xfedc %@NL@%
%@NL@%
PUSHORT asqu[MAX_SQUIRL] = { NULL };%@NL@%
USHORT cMaxSqu = 0;%@NL@%
USHORT cCurSqu = 0;%@NL@%
%@NL@%
VOID Walk(VOID);%@NL@%
VOID Squirl(PBYTE);%@NL@%
VOID Unsquirl(PBYTE);%@NL@%
%@NL@%
%@NL@%
VOID Walk()%@NL@%
{%@NL@%
    static BOOL fRecurse = FALSE;%@NL@%
    register USHORT i;%@NL@%
%@NL@%
    if (fRecurse)%@NL@%
        return;%@NL@%
    fRecurse = TRUE;%@NL@%
    for (i = 0; i < cMaxSqu; i++) {%@NL@%
        if (OFFSETOF(asqu[i]) < CheckSel(SELECTOROF(asqu[i])))%@NL@%
            if (!(*asqu[i] == HPSIG &&%@NL@%
                    (*(PUSHORT)((PBYTE)asqu[i] +%@NL@%
                    (*(asqu[i] - 1)) - 2) == HPSIG))) {%@NL@%
                AssertF(FALSE, "Heap Walk failure");%@NL@%
                asqu[i] = NULL;%@NL@%
            }%@NL@%
    }%@NL@%
    fRecurse = FALSE;%@NL@%
}%@NL@%
%@NL@%
VOID Squirl(p)%@NL@%
PBYTE p;%@NL@%
{%@NL@%
    register USHORT i;%@NL@%
    %@NL@%
    for (i = 0; i < cMaxSqu + 1; i++) {%@NL@%
        if (asqu[i] == NULL) {%@NL@%
            asqu[i] = (PUSHORT)p;%@NL@%
            cCurSqu = min(cCurSqu + 1, MAX_SQUIRL - 1);%@NL@%
            cMaxSqu = max(cCurSqu, cMaxSqu);%@NL@%
            return;%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
VOID Unsquirl(p)%@NL@%
PBYTE p;%@NL@%
{%@NL@%
    register USHORT i;%@NL@%
    %@NL@%
    for (i = 0; i < cMaxSqu + 1; i++) {%@NL@%
        if (asqu[i] == (PUSHORT)p) {%@NL@%
            asqu[i] = NULL;%@NL@%
            cCurSqu--;%@NL@%
            return;%@NL@%
        }%@NL@%
    }%@NL@%
    AssertF(cMaxSqu == (MAX_SQUIRL - 1), "Unsquirl error");%@NL@%
}%@NL@%
%@NL@%
%@NL@%
HHEAP DbgCreateHeap(%@NL@%
SEL sel,%@NL@%
USHORT cb,%@NL@%
USHORT cbGrow,%@NL@%
USHORT cbMinDed,%@NL@%
USHORT cbMaxDed,%@NL@%
USHORT fs)%@NL@%
{%@NL@%
    HHEAP hheap;%@NL@%
    register USHORT i;%@NL@%
%@NL@%
    hheap = WinCreateHeap(sel, cb, cbGrow, cbMinDed, cbMaxDed, fs);%@NL@%
    sel = HIUSHORT(WinLockHeap(hheap));%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * remove all squirled pointers in this segment so we don't%@NL@%
%@AB@%     * get errors later.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    for (i = 0; i < cMaxSqu; i++) {%@NL@%
        if (SELECTOROF(asqu[i]) == sel) {%@NL@%
            asqu[i] = NULL;%@NL@%
            cCurSqu--;%@NL@%
        }%@NL@%
    }%@NL@%
    return(hheap);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
HHEAP DbgDestroyHeap(%@NL@%
HHEAP hheap)%@NL@%
{%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * purge squirl list of any of these pointers.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    register USHORT i;%@NL@%
    %@NL@%
    for (i = 0; i < cMaxSqu; i++) {%@NL@%
        if (SELECTOROF(asqu[i]) == SELECTOROF(hheap)) {%@NL@%
            asqu[i] = NULL;%@NL@%
            cCurSqu--;%@NL@%
        }%@NL@%
    }%@NL@%
    return(WinDestroyHeap(hheap));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
NPBYTE DbgAllocMem(hheap, cb)%@NL@%
HHEAP hheap;%@NL@%
USHORT cb;%@NL@%
{%@NL@%
    register PBYTE p;%@NL@%
%@NL@%
    Walk();%@NL@%
    p = MAKEP(SELECTOROF(hheap), WinAllocMem(hheap, cb + 4));%@NL@%
    if (LOUSHORT(p) == NULL) %@NL@%
        return(NULL);%@NL@%
    Squirl(p);%@NL@%
    *(PUSHORT)p = HPSIG;%@NL@%
    *(PUSHORT)(p + cb + 2) = HPSIG;%@NL@%
    return((NPBYTE)(SHORT)p + 2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * note that cbOld perameter includes the signatures since it was derived%@NL@%
%@AB@% * from the heap itself.  cbNew, however does not incude the signatures.%@NL@%
%@AB@% */%@AE@%%@NL@%
NPBYTE DbgReallocMem(hheap, npMem, cbOld, cbNew)%@NL@%
HHEAP hheap;%@NL@%
NPBYTE npMem;%@NL@%
USHORT cbOld;%@NL@%
USHORT cbNew;%@NL@%
{%@NL@%
    register PBYTE p;%@NL@%
%@NL@%
    Walk();%@NL@%
    p = MAKEP(SELECTOROF(hheap), npMem - 2);%@NL@%
    *(PUSHORT)p = 0;%@NL@%
    *(PUSHORT)(p + cbOld - 2) = 0;%@NL@%
    Unsquirl(p);%@NL@%
    p = MAKEP(SELECTOROF(hheap), WinReallocMem(hheap, npMem - 2, cbOld, cbNew + 4));%@NL@%
    if (LOUSHORT(p) == NULL) {%@NL@%
        AssertF(FALSE, "Reallocation failure");%@NL@%
        return(NULL);%@NL@%
    }%@NL@%
    Squirl(p);%@NL@%
    *(PUSHORT)p = HPSIG;%@NL@%
    *(PUSHORT)(p + cbNew + 2) = HPSIG;%@NL@%
    return((NPBYTE)(SHORT)p + 2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * note that cbMem perameter includes the signatures since it was derived%@NL@%
%@AB@% * from the heap itself.%@NL@%
%@AB@% */%@AE@%%@NL@%
NPBYTE DbgFreeMem(hheap, npMem, cbMem)%@NL@%
HHEAP hheap;%@NL@%
NPBYTE npMem;%@NL@%
USHORT cbMem;%@NL@%
{%@NL@%
    register PBYTE p;%@NL@%
%@NL@%
    Walk();%@NL@%
    p = MAKEP(SELECTOROF(hheap), npMem - 2);%@NL@%
    Unsquirl(p);%@NL@%
    cbMem += 4;%@NL@%
    AssertF(cbMem == *(PUSHORT)(p - 2), "FreeMem:Incorrect cbMem perameter")%@NL@%
        %@NL@%
    if (*(PUSHORT)p != HPSIG || *(PUSHORT)(p + cbMem - 2) != HPSIG)%@NL@%
        AssertF(FALSE, "Freed memory is corrupted");%@NL@%
    *(PUSHORT)p = 0;%@NL@%
    *(PUSHORT)(p + cbMem - 2) = 0;%@NL@%
    p = (PBYTE)WinFreeMem(hheap, npMem - 2, cbMem);%@NL@%
    if (LOUSHORT(p) != 0)%@NL@%
        AssertF(FALSE, "Memory freeing failed");%@NL@%
    return((NPBYTE)LOUSHORT(p));%@NL@%
}%@NL@%
%@NL@%
%@AB@%/* DEBUG ------------------------------------------------------   */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MESSAGE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SPY\MESSAGE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* message.c - procecures to process the message dialog%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%       INCL_WINBUTTONS %@NL@%
%@AI@%#define %@AE@%       INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%       INCL_WINFRAMEMGR %@NL@%
       INCL_WINHEAP                        %@AB@%/* needed for spy.h */%@AE@%%@NL@%
%@AI@%#define %@AE@%       INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%       INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%       INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%       INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%       INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<time.h> %@NL@%
%@AI@%#include %@AE@%"spy.h" %@NL@%
%@AI@%#include %@AE@%"spyhook.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%SIZEOFWND   34 %@NL@%
%@AI@%#define %@AE@%MAXMSGBYTES 100 %@NL@%
%@NL@%
%@AB@%/* Procedure prototypes */%@AE@%%@NL@%
void    UpdMsgsLBSels (USHORT, BOOL);%@NL@%
void    UpdMsgTblFromLB (HWND);%@NL@%
void    ProcessQueueMsg(QMSGSPY *);%@NL@%
void    SelOrDeselWithMouse(BOOL);%@NL@%
void    UpdateMsgBoxCurMsgText(HWND);%@NL@%
void    SelectMessageFromText(HWND);%@NL@%
MRESULT        EXPENTRY SpyMsgDlgProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* MRESULT EXPENTRY SpyMsgDlgProc (hwnd, msg, mp1, mp2)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Message List dialog procedure%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY SpyMsgDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND            hwnd;%@NL@%
USHORT          msg;%@NL@%
MPARAM          mp1;%@NL@%
MPARAM          mp2;%@NL@%
{%@NL@%
    SHORT       i;%@NL@%
    MSGI        *pmsgi;%@NL@%
    USHORT      item;%@NL@%
    SHORT       bHooksNew;%@NL@%
    USHORT      iItemFocus; %@AB@%/* Index to item that has the focus */%@AE@%%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_INITDLG:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Initialize the list box with the list of messages that are%@NL@%
%@AB@%         * defined in our message table%@NL@%
%@AB@%         */%@AE@%%@NL@%
        iCurItemFocus = -1;%@NL@%
        pmsgi = rgmsgi; %@AB@%/* Point to start of list */%@AE@%%@NL@%
        hwndMessageLB = WinWindowFromID(hwnd, DID_OMSGLIST);%@NL@%
        for (i = 0; i < cmsgi; i++) {%@NL@%
            pmsgi->iListBox = item = SHORT1FROMMR(WinSendMsg(hwndMessageLB,%@NL@%
                    LM_INSERTITEM,%@NL@%
                    (MPARAM)(spyopt.fAlphaSortMsgList? LIT_SORTASCENDING : LIT_END),%@NL@%
                    (MPARAM)(PSZ)pmsgi->szMsg));%@NL@%
            WinSendMsg(hwndMessageLB, LM_SETITEMHANDLE, (MPARAM)item,%@NL@%
                (MPARAM)i);%@NL@%
            if (pmsgi->wOptions & MSGI_ENABLED) {%@NL@%
                WinSendMsg(hwndMessageLB, LM_SELECTITEM, (MPARAM)item,%@NL@%
                (MPARAM)TRUE);%@NL@%
            }%@NL@%
            pmsgi++;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* Initialize the Hook type record */%@AE@%%@NL@%
        WinSendDlgItemMsg(hwnd, DID_OINPUT, BM_SETCHECK,%@NL@%
                (MPARAM)(spyopt.bHooks & SPYH_INPUT)?1 : 0, 0L);%@NL@%
%@NL@%
        WinSendDlgItemMsg(hwnd, DID_OSENDMSG, BM_SETCHECK,%@NL@%
                (MPARAM)(spyopt.bHooks & SPYH_SENDMSG)?1 : 0, 0L);%@NL@%
%@NL@%
        WinSendDlgItemMsg(hwnd, DID_OTHERMSGS, BM_SETCHECK,%@NL@%
                (MPARAM)(spyopt.fDispOtherMsgs), 0L);%@NL@%
%@NL@%
        WinSetFocus(HWND_DESKTOP, hwndMessageLB);%@NL@%
        fTrackingListBox = TRUE;%@NL@%
        return ((MRESULT)TRUE);  %@AB@%/* We set the focus */%@AE@%%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CHAR:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Handle VK_ENTER and VK_NEWLINE if our Edit control has%@NL@%
%@AB@%         * the focus and it is a keydown%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (!(SHORT1FROMMP(mp1) & KC_KEYUP) &&%@NL@%
                (SHORT1FROMMP(mp1) & KC_VIRTUALKEY) &&%@NL@%
                ( (SHORT2FROMMP(mp2) == VK_ENTER) ||%@NL@%
                  (SHORT2FROMMP(mp2) == VK_NEWLINE) )) {%@NL@%
%@NL@%
%@NL@%
            if (WinQueryFocus(HWND_DESKTOP, FALSE) ==%@NL@%
                    WinWindowFromID(hwnd, DID_MSGEDIT)) {%@NL@%
                SelectMessageFromText(hwnd);%@NL@%
                break;%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* Normaly pass to dialog procedure to handle message */%@AE@%%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1)) {%@NL@%
        case DID_OK:%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Call to update the Message table select bits%@NL@%
%@AB@%             */%@AE@%%@NL@%
%@NL@%
            UpdMsgTblFromLB (hwnd);%@NL@%
%@NL@%
            %@AB@%/* Setup new hook options */%@AE@%%@NL@%
            bHooksNew = 0;%@NL@%
%@NL@%
            if ((BOOL)(SHORT1FROMMR(WinSendDlgItemMsg(hwnd,%@NL@%
                    DID_OINPUT, BM_QUERYCHECK, 0L, 0L))))%@NL@%
                bHooksNew = SPYH_INPUT;%@NL@%
%@NL@%
            if ((BOOL)(SHORT1FROMMR(WinSendDlgItemMsg(hwnd,%@NL@%
                    DID_OSENDMSG, BM_QUERYCHECK, 0L, 0L))))%@NL@%
                bHooksNew |= SPYH_SENDMSG;%@NL@%
%@NL@%
            if (bHooksNew != (SHORT) spyopt.bHooks) {%@NL@%
                SpyReleaseHook (FALSE);     %@AB@%/* Dont clear queue */%@AE@%%@NL@%
                spyopt.bHooks = bHooksNew;%@NL@%
                SpyInstallHook(hab, hmqSpy, spyopt.bHooks); %@AB@%/* Install hook again */%@AE@%%@NL@%
                WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                    MM_SETITEMATTR, MPFROM2SHORT(CMD_INPUTHOOK, TRUE),%@NL@%
                    MPFROM2SHORT(MIA_CHECKED,%@NL@%
                         (spyopt.bHooks & SPYH_INPUT) ? MIA_CHECKED : 0));%@NL@%
                WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                    MM_SETITEMATTR, MPFROM2SHORT(CMD_SENDMSGHOOK, TRUE),%@NL@%
                    MPFROM2SHORT(MIA_CHECKED,%@NL@%
                         (spyopt.bHooks & SPYH_SENDMSG) ? MIA_CHECKED : 0));%@NL@%
            }%@NL@%
%@NL@%
            %@AB@%/* Fall through to DID_CANCEL */%@AE@%%@NL@%
        case DID_CANCEL:%@NL@%
            %@AB@%/* Now dismiss the dialog */%@AE@%%@NL@%
            hwndMessageLB = NULL;   %@AB@%/* Not here anymore to process */%@AE@%%@NL@%
            fTrackingListBox = FALSE;%@NL@%
            WinDismissDlg(hwnd, SHORT1FROMMP(mp1));%@NL@%
            break;%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * These case simply update the listbox with which messages are%@NL@%
%@AB@%         * enabled%@NL@%
%@AB@%         */%@AE@%%@NL@%
        case DID_MALL:%@NL@%
            UpdMsgsLBSels (0, TRUE);%@NL@%
            break;%@NL@%
        case DID_MNONE:%@NL@%
            UpdMsgsLBSels (0, FALSE);%@NL@%
            break;%@NL@%
        case DID_MCON:%@NL@%
            UpdMsgsLBSels (MSGI_KEY, TRUE);%@NL@%
            break;%@NL@%
        case DID_MCOFF:%@NL@%
            UpdMsgsLBSels (MSGI_KEY, FALSE);%@NL@%
            break;%@NL@%
        case DID_MMON:%@NL@%
            UpdMsgsLBSels (MSGI_MOUSE, TRUE);%@NL@%
            break;%@NL@%
        case DID_MMOFF:%@NL@%
            UpdMsgsLBSels (MSGI_MOUSE, FALSE);%@NL@%
            break;%@NL@%
        case DID_MFON:%@NL@%
            UpdMsgsLBSels (MSGI_FREQ, TRUE);%@NL@%
            break;%@NL@%
        case DID_MFOFF:%@NL@%
            UpdMsgsLBSels (MSGI_FREQ, FALSE);%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Default is to see if the listbox has changed its focus%@NL@%
%@AB@%         * item number.  If it has, then we want to display the information%@NL@%
%@AB@%         * about the window that the listbox cursor is over.  There is no%@NL@%
%@AB@%         * legal way to do this, except to temporarily put the listbox into%@NL@%
%@AB@%         * single selection mode and query the selection.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (fTrackingListBox && (hwndMessageLB != NULL)) {%@NL@%
            WinSetWindowBits(hwndMessageLB, QWL_STYLE, 0L, LS_MULTIPLESEL);%@NL@%
            iItemFocus = SHORT1FROMMR(WinSendMsg(hwndMessageLB, LM_QUERYSELECTION,%@NL@%
                    (MPARAM)LIT_FIRST, 0L));%@NL@%
            WinSetWindowBits(hwndMessageLB, QWL_STYLE, LS_MULTIPLESEL,%@NL@%
                    LS_MULTIPLESEL);%@NL@%
            if (iItemFocus != iCurItemFocus) {%@NL@%
                iCurItemFocus = iItemFocus;%@NL@%
                UpdateMsgBoxCurMsgText(hwnd);%@NL@%
            }%@NL@%
        }%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* void UpdateMsgBoxCurMsgText()%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Updates the text that is displayed in the message text line%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void UpdateMsgBoxCurMsgText(hwndDlg)%@NL@%
HWND    hwndDlg;%@NL@%
{%@NL@%
    SHORT   sMsgI;%@NL@%
    char    szTemp[80];%@NL@%
%@NL@%
%@NL@%
    if (iCurItemFocus >= 0) {%@NL@%
        %@AB@%/* Get the messge index */%@AE@%%@NL@%
        sMsgI = SHORT1FROMMR(WinSendMsg(hwndMessageLB, LM_QUERYITEMHANDLE,%@NL@%
                (MPARAM)iCurItemFocus, 0L));%@NL@%
        sprintf(szTemp, "0x%04x  - %s", rgmsgi[sMsgI].msg,%@NL@%
                rgmsgi[sMsgI].szMsg);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_MSGEDIT, (PSZ)szTemp);%@NL@%
    } else {%@NL@%
        WinSetDlgItemText(hwndDlg, DID_MSGEDIT, (PSZ)"");%@NL@%
    }%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* void SelectMessageFromText(hwndDlg)%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Updates the text that is displayed in the message text line%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void SelectMessageFromText(hwndDlg)%@NL@%
HWND    hwndDlg;%@NL@%
{%@NL@%
    char    szTemp[80];%@NL@%
    USHORT  msg;%@NL@%
    MSGI    *pmsgi;%@NL@%
    int     i;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* First get the edit text from the string */%@AE@%%@NL@%
    WinQueryDlgItemText(hwndDlg, DID_MSGEDIT, sizeof(szTemp),%@NL@%
            (PSZ)szTemp);%@NL@%
%@NL@%
    if ((msg = UConvertStringToNum(szTemp)) != 0xffff) {%@NL@%
%@NL@%
        %@AB@%/* We have a number, now try to find message in message table */%@AE@%%@NL@%
        pmsgi = PmsgiFromMsg(msg);%@NL@%
%@NL@%
    } else {%@NL@%
        %@AB@%/* Assume String, Try to locate string in our table */%@AE@%%@NL@%
        pmsgi = rgmsgi; %@AB@%/* Start at beginning of table */%@AE@%%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * This does simple string compares, it does not map case, nor%@NL@%
%@AB@%         * does it trim the string.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        for (i=0; i < cmsgi; i++) {%@NL@%
            if (strcmpi(pmsgi->szMsg, szTemp) == 0)%@NL@%
                break;%@NL@%
            pmsgi++;%@NL@%
        };%@NL@%
%@NL@%
        if (i >= cmsgi)%@NL@%
            pmsgi = NULL;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Have a pointer to MSGI of message, or NULL if not in list.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if(pmsgi != NULL) {%@NL@%
        %@AB@%/* First make sure it is visible */%@AE@%%@NL@%
        WinSendMsg(hwndMessageLB, LM_SETTOPINDEX,%@NL@%
                MPFROMSHORT(pmsgi->iListBox),  (MPARAM)0L);%@NL@%
%@NL@%
        %@AB@%/* Always set it on */%@AE@%%@NL@%
        WinSendMsg(hwndMessageLB, LM_SELECTITEM,%@NL@%
                MPFROMSHORT(pmsgi->iListBox), MPFROMSHORT(TRUE));%@NL@%
%@NL@%
    } else {%@NL@%
        WinAlarm(HWND_DESKTOP, WA_WARNING);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_MSGEDIT, (PSZ)"");%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* void UpdMsgsLBSels (USHORT uMask, fOnOrOff);%@NL@%
%@AB@%*%@NL@%
%@AB@%* Will update the selected items in the message listbox, that is%@NL@%
%@AB@%*   displayed in the options dialog%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void UpdMsgsLBSels (uMask, fOnOrOff)%@NL@%
USHORT      uMask;%@NL@%
BOOL        fOnOrOff;%@NL@%
{%@NL@%
%@NL@%
    SHORT       i;%@NL@%
    MSGI        *pmsgi;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Loop through all of the items in our list, if the mask is 0 or%@NL@%
%@AB@%     * the bit is on in the item, then update the select state in listbox%@NL@%
%@AB@%     * defined in our message table%@NL@%
%@AB@%     */%@AE@%%@NL@%
    fTrackingListBox = FALSE;%@NL@%
    pmsgi = rgmsgi; %@AB@%/* Point to start of list */%@AE@%%@NL@%
    for (i = 0; i < cmsgi; i++) {%@NL@%
        if ((uMask == 0) || (pmsgi->wOptions & uMask)) {%@NL@%
            WinSendMsg(hwndMessageLB, LM_SELECTITEM,%@NL@%
        (MPARAM)pmsgi->iListBox,  (MPARAM)fOnOrOff);%@NL@%
        }%@NL@%
        pmsgi++;%@NL@%
    }%@NL@%
    fTrackingListBox = TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* void UpdMsgTblFromLB (HWND hwndDialog);%@NL@%
%@AB@%*%@NL@%
%@AB@%* Will update the selected items in the message listbox, that is%@NL@%
%@AB@%*   displayed in the options dialog%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void UpdMsgTblFromLB (hwndDialog)%@NL@%
HWND            hwndDialog;%@NL@%
{%@NL@%
%@NL@%
    USHORT       i;%@NL@%
    register MSGI *pmsgi;%@NL@%
    USHORT      itemSel;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Loop through all of the items in the list and update the selection%@NL@%
%@AB@%     * status depending of if the item is selected in the list box or%@NL@%
%@AB@%     * not.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    %@AB@%/* First simply turn off all of the bits */%@AE@%%@NL@%
    pmsgi = rgmsgi;%@NL@%
    for (i = 0; i < (USHORT) cmsgi; i++) {%@NL@%
        pmsgi->wOptions &= ~MSGI_ENABLED;%@NL@%
        pmsgi++;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* Then turn on all of the selected items */%@AE@%%@NL@%
    itemSel = (USHORT)LIT_FIRST;%@NL@%
%@NL@%
    while ((itemSel = SHORT1FROMMR(WinSendMsg(hwndMessageLB, LM_QUERYSELECTION,%@NL@%
            (MPARAM)itemSel, 0L))) != (USHORT)LIT_NONE) {%@NL@%
%@NL@%
        %@AB@%/* The item handle contains index in our array */%@AE@%%@NL@%
        i = SHORT1FROMMR(WinSendMsg(hwndMessageLB, LM_QUERYITEMHANDLE,%@NL@%
            (MPARAM)itemSel, 0L));%@NL@%
%@NL@%
        rgmsgi[i].wOptions |= MSGI_ENABLED;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* Get the Other message option from checkmark */%@AE@%%@NL@%
    spyopt.fDispOtherMsgs = ((BOOL)SHORT1FROMMR(WinSendDlgItemMsg(hwndDialog, DID_OTHERMSGS,%@NL@%
            BM_QUERYCHECK, 0L, 0L)));%@NL@%
%@NL@%
    %@AB@%/* Now call function to update the hooks message list */%@AE@%%@NL@%
    UpdateHooksMsgTable();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* void UpdateHooksMsgTable(void)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Send the message bitmask to the hook, for interesting messages.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void  UpdateHooksMsgTable()%@NL@%
{%@NL@%
    MSGI            *pmsgi;%@NL@%
    UCHAR           rgb[MAXMSGFILTERBYTES];%@NL@%
    int             i;%@NL@%
    UCHAR           *prgb;%@NL@%
    unsigned char   mask;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * First zero the bitmask%@NL@%
%@AB@%     */%@AE@%%@NL@%
    memset(rgb,'\0', MAXMSGFILTERBYTES);%@NL@%
    mask = 1;%@NL@%
    prgb = rgb;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Loop to set the bits%@NL@%
%@AB@%     */%@AE@%%@NL@%
    pmsgi = rgmsgi;%@NL@%
    for (i = 0; i <= MAXMSGFILTER; i++) {%@NL@%
        %@AB@%/* If enabled, set bit in bit table */%@AE@%%@NL@%
%@NL@%
        if ((SHORT) pmsgi->msg == i) {%@NL@%
            if (pmsgi->wOptions & MSGI_ENABLED)%@NL@%
                *prgb =(UCHAR)(pmsgi->bMPTypes | MP_ENABLED);%@NL@%
%@NL@%
            pmsgi++;%@NL@%
        } else {%@NL@%
            %@AB@%/* Hole in range, set it true */%@AE@%%@NL@%
            *prgb |= mask;%@NL@%
        }%@NL@%
%@NL@%
        prgb++;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* Now call the hook function with the new mask */%@AE@%%@NL@%
    SpySetMessageList((char far *)rgb, spyopt.fDispOtherMsgs);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* EnableOrDisableMsg(BOOL fEnable)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Fast way to enable or disable a particular message code.  The one%@NL@%
%@AB@%*           that is currently selected in the output listbox.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
void EnableOrDisableMsg(fEnable)%@NL@%
BOOL            fEnable;%@NL@%
{%@NL@%
    USHORT      itemSel;%@NL@%
    char        szTemp[100];%@NL@%
    char        *psz;%@NL@%
    MSGI        *pmsgi;%@NL@%
    SHORT       i;%@NL@%
%@NL@%
    itemSel = SHORT1FROMMR(WinSendMsg(hwndSpyList, LM_QUERYSELECTION,%@NL@%
            (MPARAM)LIT_FIRST, 0L));%@NL@%
    if (itemSel == (USHORT)LIT_NONE)%@NL@%
        return;    %@AB@%/* None to process */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Get the message text */%@AE@%%@NL@%
    WinSendMsg(hwndSpyList, LM_QUERYITEMTEXT,%@NL@%
            MPFROM2SHORT(itemSel, sizeof(szTemp)), (MPARAM)(PSZ)szTemp);%@NL@%
%@NL@%
    %@AB@%/* Now lets extract the messgae string from the line */%@AE@%%@NL@%
    psz = &szTemp[3];%@NL@%
    while (*psz != ' ')%@NL@%
        psz++;    %@AB@%/* locate first blank */%@AE@%%@NL@%
    *psz = '\0';    %@AB@%/* Zero terminate string */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Loop through all of the items in our list, until we find a%@NL@%
%@AB@%     * string that matches our string.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    pmsgi = rgmsgi; %@AB@%/* Point to start of list */%@AE@%%@NL@%
    for (i = 0; i < cmsgi; i++) {%@NL@%
        if (strcmpi(&szTemp[2], pmsgi->szMsg) == 0) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Found our message, update the bit of the message, and%@NL@%
%@AB@%             * call the function to let the hook know the new results%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (fEnable)%@NL@%
                pmsgi->wOptions |= MSGI_ENABLED;%@NL@%
            else%@NL@%
                pmsgi->wOptions &= ~MSGI_ENABLED;%@NL@%
%@NL@%
               UpdateHooksMsgTable();      %@AB@%/* Set Spy's Msg table */%@AE@%%@NL@%
            return;%@NL@%
        }%@NL@%
        pmsgi++;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MODEM.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\TERMINAL\MODEM.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***        modem.c%@NL@%
%@AB@% *%@NL@%
%@AB@% * TITLE %@NL@%
%@AB@% *%@NL@%
%@AB@% *        modem.c%@NL@%
%@AB@% *        Created by Microsoft Corporation 1987%@NL@%
%@AB@% *%@NL@%
%@AB@% * DESCRIPTION%@NL@%
%@AB@% *%@NL@%
%@AB@% *         This module contains routines that support Hayes compatible modem. %@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%    INCL_DOSDEVICES %@NL@%
%@AI@%#define %@AE@%    INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%    INCL_DOSPROCESS %@NL@%
%@NL@%
%@AI@%#include %@AE@%       <os2def.h> %@NL@%
%@AI@%#include %@AE@%       <bse.h> %@NL@%
%@AI@%#include %@AE@%       <stdio.h>         %@NL@%
%@AI@%#include %@AE@%       <malloc.h> %@NL@%
%@AI@%#include %@AE@%       <string.h> %@NL@%
%@AI@%#include %@AE@%        <memory.h> %@NL@%
%@AI@%#include %@AE@%        <conio.h> %@NL@%
%@AI@%#include %@AE@%        "term.h" %@NL@%
%@NL@%
min(a,b) (((a)<(b)) ? (a):(b))        %@AB@%/* This is pulled out of the old */%@AE@%%@NL@%
                                        %@AB@%/* v2tov3.h (c v2.0) header file */%@AE@%%@NL@%
%@NL@%
extern char         *ErrMsg[]; %@NL@%
extern HFILE FileHndl;%@NL@%
%@NL@%
make_dial_cmd(char *, int);%@NL@%
void flush_ques(USHORT);%@NL@%
void clr_com_error(void);%@NL@%
void com_clr_flush(void);%@NL@%
%@NL@%
static char Init[]    = {'A', 'T', 'V', '0', 0x0d};%@NL@%
static char Attn[]    = {'A', 'T', 0x0d};%@NL@%
static char Esc[]     = {'+', '+', '+'};%@NL@%
static char OnHook[]  = {'A', 'T', 'H', '0', 0X0d};%@NL@%
static char OffHook[] = {'A', 'T', 'H', '1', 0x0d};%@NL@%
static char Reset[]   = {'A', 'T', 'Z', 0x0d};%@NL@%
%@NL@%
struct s_Cmd{%@NL@%
        char *pCmd;%@NL@%
        int   CmdLen;%@NL@%
} Cmds[] = {%@NL@%
    {Init, sizeof(Init)},                %@AB@%/* Initialize modem */%@AE@%%@NL@%
    {Attn, sizeof(Attn)},                %@AB@%/* Attention cmd */%@AE@%%@NL@%
    {Esc, sizeof(Esc)},                  %@AB@%/* Modem escape sequence*/%@AE@%%@NL@%
    {OnHook, sizeof(OnHook)},            %@AB@%/* Put phone on hook */%@AE@%%@NL@%
    {OffHook, sizeof(OffHook)},          %@AB@%/* Take phone off hook */%@AE@%%@NL@%
    {Reset, sizeof(Reset)}               %@AB@%/* Reset command */%@AE@%%@NL@%
  };%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        make_modem_conn - make modem connection%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine tries to setup the modem connection, retrying if %@NL@%
%@AB@% *        appropriate.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        make_modem_conn()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                TRUE if modem connection was made %@NL@%
%@AB@% *                FALSE if modem connection did not go through%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
make_modem_conn()%@NL@%
{%@NL@%
        USHORT                NumBytes;        %@AB@%/* number of bytes to be written    */%@AE@%%@NL@%
        unsigned        RetCode,        %@AB@%/* return code from system calls    */%@AE@%%@NL@%
                        Result = FALSE; %@AB@%/* to be returned by this routine */%@AE@%%@NL@%
        char                OutBuffer,%@NL@%
                        ModemRetry = TRUE,   %@AB@%/* retry for modem connection   */%@AE@%%@NL@%
                        NumRetries = 0;      %@AB@%/* no. times connection retried */%@AE@%%@NL@%
%@NL@%
        printf("trying modem connection...\n");%@NL@%
%@NL@%
          while (ModemRetry)%@NL@%
          switch (setup_modem_conn()) {%@NL@%
            case MS_CONNECT    :%@NL@%
            case MS_CONNECT1200: %@NL@%
              Result = TRUE;%@NL@%
              ModemRetry = FALSE;%@NL@%
              OutBuffer = '\r';%@NL@%
              if ((RetCode = DosWrite(FileHndl, &OutBuffer, 1,%@NL@%
                                      &NumBytes)) != 0)%@NL@%
                error(ERR_DOSWRITE, RetCode);%@NL@%
              break;%@NL@%
            case MS_NOCARRIER  :%@NL@%
            case MS_NODIALTONE :%@NL@%
              if (++NumRetries > NUM_RETRY) {%@NL@%
                printf("modem connection failed\n");%@NL@%
                ModemRetry = FALSE;%@NL@%
              }%@NL@%
              else%@NL@%
                printf("modem connection failed; retrying...\n");%@NL@%
              break;%@NL@%
            case MS_NOREPLY    :%@NL@%
            case MS_ERROR      : %@NL@%
            case OT_FAILURE    :                %@AB@%/* OTher failure */%@AE@%%@NL@%
            case MS_BUSY       : %@NL@%
            default            : %@NL@%
              ModemRetry = FALSE;%@NL@%
              printf("modem connection failed\n");%@NL@%
              break;%@NL@%
          }                %@AB@%/* switch (setup_modem_conn()) */%@AE@%%@NL@%
%@NL@%
        return(Result);%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        setup_modem_conn - setup modem connection%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This is the helper routine for the make_modem_conn(). It initialises%@NL@%
%@AB@% *        the modem connection and sends out the dial command to the modem.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        setup_modem_conn()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                returns one of the following: MS_CONNECT MS_CONNECT1200 %@NL@%
%@AB@% *                    MS_NOCARRIER MS_NODIALTONE MS_NOREPLY MS_ERROR MS_BUSY %@NL@%
%@AB@% *                    OT_FAILURE%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
int        setup_modem_conn()%@NL@%
{%@NL@%
        int                Result = OT_FAILURE;%@NL@%
%@NL@%
        %@AB@%/* initialise modem connection */%@AE@%%@NL@%
        if (!(send_modem_cmd(MC_INIT)))%@NL@%
          return(Result);%@NL@%
        if (get_modem_reply() != MS_OK)%@NL@%
          return(Result);%@NL@%
        DosSleep(100L);%@NL@%
%@NL@%
        %@AB@%/* write AT string to the modem. This will cause the modem to%@NL@%
%@AB@%         * determine the communications rate of the terminal as well%@NL@%
%@AB@%         * as its parity setting.%@NL@%
%@AB@%          */%@AE@%%@NL@%
        if (!(send_modem_cmd(MC_ATTN)))%@NL@%
          return(Result);%@NL@%
        if (get_modem_reply() != MS_OK)%@NL@%
          return(Result);%@NL@%
        DosSleep(100L);%@NL@%
%@NL@%
        %@AB@%/* send DIAL command to the modem */%@AE@%%@NL@%
        if (!(send_modem_cmd(MC_DIAL)))%@NL@%
          return(Result);%@NL@%
%@NL@%
        return(get_modem_reply());%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        send_modem_cmd - send a command to modem%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine sends a command to the modem and ensures that the echo %@NL@%
%@AB@% *        from the modem matches the input command.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        send_modem_cmd(CmdType)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                CmdType - type of modem command: MC_INIT MC_ATTN MC_ESC %@NL@%
%@AB@% *                                  MC_ONHOOK MC_OFFHOOK MC_RESET MC_DIAL%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                TRUE if command was sent succesfully%@NL@%
%@AB@% *                FALSE if command failed%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
send_modem_cmd(CmdType)%@NL@%
int         CmdType;                    %@AB@%/* The command to send */%@AE@%%@NL@%
{%@NL@%
            int                  Result = TRUE,%@NL@%
                        RetCode;%@NL@%
        USHORT                WriteCnt,%@NL@%
                        ReadCnt,%@NL@%
                        CmdLen;%@NL@%
            char                 Buf[80],%@NL@%
                            Cmd[80],%@NL@%
                            *pDst,%@NL@%
                            *pCmd;%@NL@%
        %@NL@%
%@NL@%
        %@AB@%/* clear COM error and flush transmit/receive queues */%@AE@%%@NL@%
        com_clr_flush();%@NL@%
%@NL@%
        if (CmdType == MC_INIT) {%@NL@%
          send_modem_cmd(MC_RESET);        %@AB@%/* modem command: ATZ */%@AE@%%@NL@%
          %@AB@%/* clear COM error and flush transmit/receive queues */%@AE@%%@NL@%
          com_clr_flush();%@NL@%
        };%@NL@%
%@NL@%
        %@AB@%/* set pCmd -> command string; CmdLen = length of command string */%@AE@%%@NL@%
            if (CmdType == MC_DIAL) {%@NL@%
          CmdLen = make_dial_cmd(Cmd, sizeof(Cmd));%@NL@%
          pCmd = Cmd;%@NL@%
        }%@NL@%
            else {%@NL@%
          pCmd = Cmds[CmdType].pCmd;%@NL@%
          CmdLen = Cmds[CmdType].CmdLen;%@NL@%
        };%@NL@%
%@NL@%
        %@AB@%/* write the command out to the modem */%@AE@%%@NL@%
        if (((RetCode = DosWrite(FileHndl, pCmd, CmdLen, &WriteCnt)) != 0)%@NL@%
            || (WriteCnt != CmdLen))%@NL@%
          return(FALSE);%@NL@%
%@NL@%
        %@AB@%/* wait for the echo & wait for the command to clear */%@AE@%%@NL@%
        DosSleep(250L);%@NL@%
        if (CmdType == MC_DIAL || CmdType == MC_RESET)%@NL@%
          DosSleep(750L);%@NL@%
%@NL@%
        %@AB@%/* read back the echo from the modem & check if it matches the input */%@AE@%%@NL@%
        RetCode = %@NL@%
          DosRead(FileHndl, Buf, min(WriteCnt, sizeof(Buf)), &ReadCnt);%@NL@%
        if ((RetCode != 0) || (ReadCnt != WriteCnt))%@NL@%
          Result = FALSE;%@NL@%
        else {%@NL@%
          pDst = Buf;%@NL@%
          while (--ReadCnt >= 0) {%@NL@%
            if (*pDst++ != *pCmd++) {%@NL@%
              printf("send_modem_cmd: error in echo of modem input\n");%@NL@%
              Result = FALSE;%@NL@%
              break;%@NL@%
            }%@NL@%
          } %@AB@%/* while (--ReadCnt >= 0) */%@AE@%%@NL@%
        } %@NL@%
%@NL@%
            return(Result);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        make_dial_cmd - create a modem command for dialing%@NL@%
%@AB@% *%@NL@%
%@AB@% *        builds the dial command string and returns its length in bytes%@NL@%
%@AB@% *%@NL@%
%@AB@% *        make_dial_cmd(pBuf, BufLen)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                pBuf - ptr to buffer%@NL@%
%@AB@% *                BufLen - length of buffer in bytes%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                pBuf -> dial command string%@NL@%
%@AB@% *                make_dial_cmd = length of dial command string in bytes %@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
make_dial_cmd(pBuf, BufLen)%@NL@%
char         *pBuf;%@NL@%
int          BufLen;%@NL@%
{%@NL@%
            char                 *pSrc,%@NL@%
                            *pDst,%@NL@%
                            Ch,%@NL@%
                            Cmd[80],          %@AB@%/* allocate a huge command buffer */%@AE@%%@NL@%
                        *bin_to_dec();%@NL@%
            int                   Len;%@NL@%
        structModemOptions sModemOptions;                %@AB@%/* modem options */%@AE@%%@NL@%
%@NL@%
        get_modem_options(&sModemOptions);%@NL@%
            pDst = Cmd;%@NL@%
            *pDst++ = 'A';          %@AB@%/* get Modem's attention */%@AE@%%@NL@%
            *pDst++ = 'T';%@NL@%
            *pDst++ = 'S';          %@AB@%/* set R6 for wait for dial tone */%@AE@%%@NL@%
            *pDst++ = '6';%@NL@%
            *pDst++ = '=';%@NL@%
            pDst = bin_to_dec(pDst, sModemOptions.iWaitTone);%@NL@%
            *pDst++ = B_PAUSE;%@NL@%
            *pDst++ = 'S';          %@AB@%/* set R7 for wait for carrier time */%@AE@%%@NL@%
            *pDst++ = '7';%@NL@%
            *pDst++ = '=';%@NL@%
            pDst = bin_to_dec(pDst, sModemOptions.iWaitCarrier); %@NL@%
            *pDst++ = B_PAUSE;%@NL@%
            *pDst++ = 'D';%@NL@%
            *pDst++ = (sModemOptions.chDialType == PULSE) ? 'P' : 'T';%@NL@%
            pSrc = sModemOptions.pPhoneNumber;%@NL@%
            while (Ch = *pSrc++) %@NL@%
          if ((Ch >= '0' && Ch <= '9') || (Ch == ','))%@NL@%
            *pDst++ = Ch;%@NL@%
            *pDst++ = 0x0d;%@NL@%
            *pDst = 0;%@NL@%
%@NL@%
            %@AB@%/* copy the command string into caller's buffer */%@AE@%%@NL@%
            pSrc = Cmd;%@NL@%
            pDst = pBuf;%@NL@%
            for (Len = 0; Len <= BufLen; ++Len)%@NL@%
          if (*pSrc==0)%@NL@%
            break;%@NL@%
          else%@NL@%
            *pDst++ = *pSrc++;%@NL@%
            return(Len);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        bin_to_dec - convert a binary number to ASCII decimal%@NL@%
%@AB@% *%@NL@%
%@AB@% *        bin_to_dec(pDst, i)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                pDst -> buffer to place the ASCII decimal%@NL@%
%@AB@% *                i = integer to be converted to ASCII decimal%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                ASCII decimal placed in the buffer pointed by pDst%@NL@%
%@AB@% *                bin_to_dec -> byte next to ASCII decimal in the buffer%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
char *bin_to_dec(pDst, i)%@NL@%
char         *pDst;%@NL@%
int          i;%@NL@%
{%@NL@%
            if (i > 10)%@NL@%
          pDst = bin_to_dec (pDst, i/10);%@NL@%
            *pDst++ = '0' + (i % 10);%@NL@%
            return(pDst);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        get_modem_reply - get reply from modem%@NL@%
%@AB@% *%@NL@%
%@AB@% *        get_modem_reply()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                get_modem_reply = MS_CONNECT MS_CONNECT1200 MS_NOCARRIER %@NL@%
%@AB@% *                                  MS_NODIALTONE MS_NOREPLY MS_ERROR MS_BUSY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
int get_modem_reply()%@NL@%
{%@NL@%
            char                 Ch;%@NL@%
        USHORT                Cnt;%@NL@%
        int                Result,%@NL@%
                             RetCode;%@NL@%
%@NL@%
            do                  %@AB@%/* skip CR, LF and get resultcode */%@AE@%%@NL@%
          if ((RetCode = DosRead(FileHndl, &Ch, 1, &Cnt)) != 0)%@NL@%
            Error(ERR_DOSREAD, RetCode);%@NL@%
        while ((Cnt == 1) && ((Ch == 0x0d) || (Ch == 0x0a)));%@NL@%
%@NL@%
            switch(Cnt) {%@NL@%
          case 0:  Result = MS_NOREPLY;%@NL@%
                       break;%@NL@%
          case 1:  if ((Ch >= '0') && (Ch <= '7'))%@NL@%
                     Result = Ch - '0';%@NL@%
                   else%@NL@%
                     Result = MS_ERROR;%@NL@%
                   break;%@NL@%
          default: Result = MS_ERROR;%@NL@%
                   break;%@NL@%
        }%@NL@%
%@NL@%
            return(Result);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        discon_modem - disconnect the modem%@NL@%
%@AB@% *%@NL@%
%@AB@% *        discon_modem()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                modem disconnected%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
void discon_modem()%@NL@%
{%@NL@%
            %@AB@%/* Wait for the last command to clear, then be quiet for 1.5 seconds */%@AE@%%@NL@%
        DosSleep(1000L);                %@AB@%/* wait 1. second */%@AE@%%@NL@%
            flush_ques(FLUSHOUTPUT);        %@AB@%/* flush the transmit que */%@AE@%%@NL@%
        DosSleep(1500L);                %@AB@%/* wait 1.5 seconds */%@AE@%%@NL@%
%@NL@%
            send_modem_cmd(MC_ESC);            %@AB@%/* put modem in command mode */%@AE@%%@NL@%
        DosSleep(2000L);                %@AB@%/* wait 2 seconds */%@AE@%%@NL@%
%@NL@%
            send_modem_cmd(MC_ONHOOK);             %@AB@%/* place phone back on hook */%@AE@%%@NL@%
        DosSleep(200L);           %@AB@%/* wait for command to clear*/%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        com_clr_flush - clear COM error and flush transmit/receive queues%@NL@%
%@AB@% *%@NL@%
%@AB@% *        com_clr_flush()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                com error cleared%@NL@%
%@AB@% *                transmit and receive queues of com port flushed out%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
void com_clr_flush()%@NL@%
{%@NL@%
        %@AB@%/* retrieve and clear the com error information */%@AE@%%@NL@%
        clr_com_error();%@NL@%
        %@AB@%/* flush transmit and receive queues */%@AE@%%@NL@%
        flush_ques(FLUSHINPUT);%@NL@%
        flush_ques(FLUSHOUTPUT);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        flush_ques - flush COM transmit/receive queue%@NL@%
%@AB@% *%@NL@%
%@AB@% *        flush_ques(FuncId)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                FuncId - set to one of: FLUSHINPUT FLUSHOUTPUT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                transmit or receive queue of com port flushed%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
void flush_ques(FuncId)%@NL@%
USHORT        FuncId;%@NL@%
{        %@NL@%
        char        FlushData,        %@AB@%/* data returned by flush IOCTL function */%@AE@%%@NL@%
                FlushParm = FLUSH_CMDINFO; %@AB@%/* param to flush IOCTL function */%@AE@%%@NL@%
        int        RetCode;%@NL@%
        %@NL@%
        %@AB@%/* flush transmit/receive queue */%@AE@%%@NL@%
        if ((RetCode = DosDevIOCtl(&FlushData, &FlushParm,%@NL@%
                                   FuncId, GENERIC, FileHndl)) != 0) %@NL@%
          Error(ERR_IOCTLFLUSHQUE, RetCode);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        clr_com_error - retrieve and clear COM error information%@NL@%
%@AB@% *%@NL@%
%@AB@% *        clr_com_error()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                com error cleared%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
void clr_com_error()%@NL@%
%@NL@%
{%@NL@%
        int          ComError,%@NL@%
                RetCode;%@NL@%
%@NL@%
        if ((RetCode = DosDevIOCtl(&ComError, 0L, GETCOMERROR,%@NL@%
                                   SERIAL, FileHndl)) != 0)%@NL@%
          Error(ERR_IOCTLGETCOMERROR, RetCode);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MONITOR.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\MONITOR\MONITOR.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name: monitor.c%@NL@%
%@AB@%*%@NL@%
%@AB@%* This is a small monitoring test program.  It dumps monitor characters to%@NL@%
%@AB@%* a file called monitor.txt.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created:      sanfords%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSNLS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"ddeml.h" %@NL@%
%@AI@%#include %@AE@%"monitor.h" %@NL@%
%@AI@%#include %@AE@%"res.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/*********** declares *********/%@AE@%%@NL@%
%@NL@%
%@NL@%
int        APIENTRY DebugOutput( PCH );        %@AB@%/* private import */%@AE@%%@NL@%
%@NL@%
int lstrlen(PSZ psz);%@NL@%
HDMGDATA EXPENTRY dataxfer(HCONV hConv, HSZ hszTopic, HSZ hszItem,%@NL@%
        USHORT usFmt, USHORT usType, HDMGDATA hDmgData);%@NL@%
%@NL@%
%@NL@%
%@AB@%/************* GLOBAL VARIABLES  ************/%@AE@%%@NL@%
%@NL@%
HAB hab;%@NL@%
HMQ hmq;%@NL@%
HFILE hfile;%@NL@%
HWND hwndFrame;%@NL@%
HWND hwndClient;%@NL@%
USHORT fsOutput = 0;%@NL@%
%@NL@%
void cdecl main(argc, argv)%@NL@%
int argc;%@NL@%
char **argv;%@NL@%
{%@NL@%
    USHORT err;%@NL@%
    QMSG qmsg;%@NL@%
    ULONG ctlData;%@NL@%
    argc; argv;%@NL@%
%@NL@%
    if (argc > 1) {%@NL@%
        DdeDebugBreak();%@NL@%
    }%@NL@%
    %@NL@%
    hab = WinInitialize(0);%@NL@%
%@NL@%
    hmq = WinCreateMsgQueue(hab, 0);%@NL@%
%@NL@%
    if (!InitTestSubs())%@NL@%
        DosExit(1, 0);%@NL@%
        %@NL@%
    if (!WinRegisterClass(hab, "Monitor Class", MonWndProc, 0L, 4L))%@NL@%
        DosExit(1, 0);%@NL@%
    %@NL@%
    ctlData = FCF_STANDARD;%@NL@%
    hwndFrame = WinCreateStdWindow(HWND_DESKTOP, 0L, &ctlData, "Monitor Class",%@NL@%
            (PSZ)"DDE Monitoring window", (ULONG)WS_VISIBLE, (HMODULE)NULL, IDR_MAIN, 0L);%@NL@%
    WinSetWindowPos(hwndFrame, HWND_TOP, 0, 0, 0, 0, SWP_MINIMIZE | SWP_SHOW);%@NL@%
%@NL@%
    if (err = DdeInitialize((PFNCALLBACK)dataxfer, DMGCMD_MONITOR, 0L)) {%@NL@%
        DdePostError(err);%@NL@%
        goto abort;%@NL@%
    }%@NL@%
    %@NL@%
    while (WinGetMsg(hab, &qmsg, 0, 0, 0)) {%@NL@%
        WinDispatchMsg(hab, &qmsg);%@NL@%
    }%@NL@%
%@NL@%
    DdeUninitialize();%@NL@%
%@NL@%
abort:%@NL@%
    DosClose(hfile);%@NL@%
    WinDestroyWindow(hwndFrame);%@NL@%
    WinTerminate(hab);%@NL@%
    DosExit(TRUE, 0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY MonWndProc(%@NL@%
HWND hwnd,%@NL@%
USHORT msg,%@NL@%
MPARAM mp1,%@NL@%
MPARAM mp2)%@NL@%
{%@NL@%
    USHORT usAction;%@NL@%
    %@NL@%
    switch (msg) {%@NL@%
    case WM_INITMENU:%@NL@%
        switch (SHORT1FROMMP(mp1)) {%@NL@%
        case IDSM_OUTPUT:%@NL@%
            WinSendMsg((HWND)mp2, MM_SETITEMATTR, MPFROM2SHORT(IDM_OUTPUT_FILE, FALSE),%@NL@%
                    MPFROM2SHORT(MIA_CHECKED,%@NL@%
                    fsOutput & (IDM_OUTPUT_FILE - IDSM_OUTPUT) ?%@NL@%
                    MIA_CHECKED : NULL));%@NL@%
            WinSendMsg((HWND)mp2, MM_SETITEMATTR, MPFROM2SHORT(IDM_OUTPUT_DEBUG, FALSE),%@NL@%
                    MPFROM2SHORT(MIA_CHECKED,%@NL@%
                    fsOutput & (IDM_OUTPUT_DEBUG - IDSM_OUTPUT) ?%@NL@%
                    MIA_CHECKED : NULL));%@NL@%
            WinSendMsg((HWND)mp2, MM_SETITEMATTR, MPFROM2SHORT(IDM_OUTPUT_SCREEN, FALSE),%@NL@%
                    MPFROM2SHORT(MIA_CHECKED,%@NL@%
                    fsOutput & (IDM_OUTPUT_SCREEN - IDSM_OUTPUT) ?%@NL@%
                    MIA_CHECKED : NULL));%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
        %@NL@%
    case WM_COMMAND:%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
        case IDM_OUTPUT_FILE:%@NL@%
            if (fsOutput & (IDM_OUTPUT_FILE - IDSM_OUTPUT)) {%@NL@%
                DosClose(hfile);%@NL@%
            } else {%@NL@%
                if (DosOpen("monitor.txt", &hfile, &usAction, 0L, FILE_NORMAL, %@NL@%
                        FILE_TRUNCATE | FILE_CREATE,%@NL@%
                        OPEN_ACCESS_WRITEONLY | OPEN_SHARE_DENYNONE |%@NL@%
                        OPEN_FLAGS_WRITE_THROUGH | OPEN_FLAGS_SEQUENTIAL, 0L)) {%@NL@%
                    WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
                    return 0L;%@NL@%
                }%@NL@%
            }%@NL@%
        %@AB@%/* fall through */%@AE@%%@NL@%
        case IDM_OUTPUT_DEBUG:%@NL@%
        case IDM_OUTPUT_SCREEN:%@NL@%
            fsOutput ^= LOUSHORT(mp1) - IDSM_OUTPUT;%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CREATE:%@NL@%
        hwndClient = hwnd;%@NL@%
        %@AB@%/* fall through */%@AE@%%@NL@%
    default:%@NL@%
        return(StrWndProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    %@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
HDMGDATA EXPENTRY dataxfer(hConv, hszTopic, hszItem, usFmt, usType,%@NL@%
        hDmgData)%@NL@%
HCONV hConv;%@NL@%
HSZ hszTopic;%@NL@%
HSZ hszItem;%@NL@%
USHORT usFmt;%@NL@%
USHORT usType;%@NL@%
HDMGDATA hDmgData;%@NL@%
{%@NL@%
    char sz[MAX_MONITORSTR + 1];%@NL@%
    USHORT usWritten;%@NL@%
%@NL@%
    hConv; hszTopic; hszItem; usFmt; usType;%@NL@%
    %@NL@%
    if (usType == XTYP_MONITOR) {%@NL@%
        DdeGetData(hDmgData, (PBYTE)sz, (ULONG)(MAX_MONITORSTR + 1), 0L);%@NL@%
        if (fsOutput & (IDM_OUTPUT_FILE - IDSM_OUTPUT))%@NL@%
            DosWrite(hfile, sz, lstrlen(sz), &usWritten);%@NL@%
        if (fsOutput & (IDM_OUTPUT_DEBUG - IDSM_OUTPUT))%@NL@%
            DebugOutput(sz);%@NL@%
        if (fsOutput & (IDM_OUTPUT_SCREEN - IDSM_OUTPUT))%@NL@%
            DrawString(hwndClient, sz);%@NL@%
        return(TRUE);%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
int lstrlen(psz)%@NL@%
PSZ psz;%@NL@%
{%@NL@%
    int c = 0;%@NL@%
%@NL@%
    while (*psz != 0) {%@NL@%
        psz++;%@NL@%
        c++;%@NL@%
    }%@NL@%
    return(++c);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MSGBOX.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\MSGBOX\MSGBOX.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*      msgbox.c  - Message box control sample application        */%@AE@%%@NL@%
%@AB@%/*      Created by Microsoft Corp., 1989                        */%@AE@%%@NL@%
%@AB@%/*                                                              */%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"msgbox.h" %@NL@%
%@NL@%
%@AB@%/* Procedure prototypes */%@AE@%%@NL@%
MPARAM EXPENTRY MsgBoxDlgProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
void cdecl main(void);%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Main routine -- creates a dialog box window */%@AE@%%@NL@%
void cdecl main(void)%@NL@%
{%@NL@%
    HAB habMsgBox;%@NL@%
    HMQ hmqMsgBox;%@NL@%
%@NL@%
    %@AB@%/* Initialize Anchor Block, Message Queue */%@AE@%%@NL@%
    habMsgBox = WinInitialize(0);%@NL@%
    hmqMsgBox = WinCreateMsgQueue(habMsgBox, 0);%@NL@%
%@NL@%
    %@AB@%/* Summon the dialog box */%@AE@%%@NL@%
    WinDlgBox(HWND_DESKTOP, NULL, MsgBoxDlgProc, (HMODULE) NULL, IDD_MSGBOX, NULL);%@NL@%
%@NL@%
    %@AB@%/* Clean up */%@AE@%%@NL@%
    WinDestroyMsgQueue(hmqMsgBox);%@NL@%
    WinTerminate(habMsgBox);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/* Message box control routine */%@AE@%%@NL@%
MRESULT EXPENTRY MsgBoxDlgProc(hWnd, msg, mp1, mp2)%@NL@%
HWND hWnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    USHORT flStyle;%@NL@%
    SHORT  rc;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_COMMAND:%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
        case DID_OK:%@NL@%
            WinDismissDlg(hWnd, TRUE);%@NL@%
            break;%@NL@%
%@NL@%
        case IDD_SHOWBOX: %@AB@%/* Show Box */%@AE@%%@NL@%
            %@AB@%/* Buttons? */%@AE@%%@NL@%
            rc = SHORT1FROMMR( WinSendDlgItemMsg(hWnd, IDD_OK0,%@NL@%
                    BM_QUERYCHECKINDEX, 0L, 0L));%@NL@%
            flStyle = (rc > 0) ? (USHORT) rc : 0;%@NL@%
%@NL@%
            %@AB@%/* Icon style? */%@AE@%%@NL@%
            rc = SHORT1FROMMR( WinSendDlgItemMsg(hWnd, IDD_ICON0,%@NL@%
                    BM_QUERYCHECKINDEX, 0L, 0L));%@NL@%
            if (rc > 0) flStyle = (flStyle & 0xff0f) | ((USHORT) rc << 4);%@NL@%
%@NL@%
            %@AB@%/* Default style? */%@AE@%%@NL@%
            rc = SHORT1FROMMR( WinSendDlgItemMsg(hWnd, IDD_DEF0,%@NL@%
                    BM_QUERYCHECKINDEX, 0L, 0L));%@NL@%
            if (rc > 0) flStyle = (flStyle & 0xf0ff) | ((USHORT) rc << 8);%@NL@%
%@NL@%
            %@AB@%/* Get modality */%@AE@%%@NL@%
            if (WinSendDlgItemMsg(hWnd, IDD_SYSTEMMODAL, BM_QUERYCHECK, 0L, 0L))%@NL@%
                flStyle |= MB_SYSTEMMODAL;%@NL@%
%@NL@%
            %@AB@%/* Get help button attribute */%@AE@%%@NL@%
            if (WinSendDlgItemMsg(hWnd, IDD_HELP, BM_QUERYCHECK, 0L, 0L))%@NL@%
                flStyle |= MB_HELP;%@NL@%
%@NL@%
            %@AB@%/* Display the Message Box Type */%@AE@%%@NL@%
            WinSetDlgItemShort(hWnd, IDD_MSGBOXSTYLE, flStyle, FALSE);%@NL@%
%@NL@%
            %@AB@%/* Pop up the message box */%@AE@%%@NL@%
            rc = WinMessageBox(HWND_DESKTOP, hWnd,%@NL@%
                    (PSZ)"Message Box Text Body\n(can contain several lines)",%@NL@%
                    (PSZ)"This is the title bar", 1, flStyle);%@NL@%
%@NL@%
            %@AB@%/* Update the return code box */%@AE@%%@NL@%
            WinSetDlgItemShort(hWnd, IDD_RETURNCODE, rc, FALSE);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_INITDLG: %@AB@%/* Push these three buttons */%@AE@%%@NL@%
        WinSendDlgItemMsg(hWnd,  IDD_OK0, BM_SETCHECK, (MPARAM) TRUE, 0L);%@NL@%
        WinSendDlgItemMsg(hWnd,IDD_ICON0, BM_SETCHECK, (MPARAM) TRUE, 0L);%@NL@%
        WinSendDlgItemMsg(hWnd, IDD_DEF0, BM_SETCHECK, (MPARAM) TRUE, 0L);%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hWnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MSNGR.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\MSNGR\MSNGR.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** MODULE Header ******************************\%@NL@%
%@AB@%* Module Name:  msngr.c - Messenger application%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created:  1/1/89  sanfords%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"msngr.h" %@NL@%
%@AI@%#include %@AE@%"string.h" %@NL@%
%@NL@%
%@AB@%/************* FILE GLOBALS  ************/%@AE@%%@NL@%
%@NL@%
char szMessengerClass[] = SZAPPCLASS;%@NL@%
char szTitlePrefix[] = SZAPPTITLEPREFIX;%@NL@%
char szTitle[MAX_TITLESTR + 1]="";%@NL@%
char szEmailName[MAX_NAMESTR + 1] = "";%@NL@%
%@NL@%
HCONVLIST hConvUserList = 0;    %@AB@%/* holds all client conversations */%@AE@%%@NL@%
HAB  hab;%@NL@%
HMQ  hmq;%@NL@%
HWND hwndMsngrFrame;%@NL@%
HWND hwndMsngr;%@NL@%
HWND hwndHolder;%@NL@%
HWND hwndLB;%@NL@%
HHEAP hheap;%@NL@%
HPOINTER hptrLink = 0;%@NL@%
PFNWP lpfnSysEFWndProc;         %@AB@%/* holds the system edit control proc */%@AE@%%@NL@%
NPUSERLIST gnpUL = 0;   %@AB@%/* relates hConvs to hszs. */%@AE@%%@NL@%
SHORT cyText;%@NL@%
ULONG ulTimeout = 500;%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * The following arrays define which interface functions to use for a given%@NL@%
%@AB@% * topic and item.%@NL@%
%@AB@% * Hszize() fills in the hsz portions of this array.%@NL@%
%@AB@% * Note: the order of some of these must corespond to the the index constants%@NL@%
%@AB@% *        in msngr.h.%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
HSZ hszEmailName = 0;%@NL@%
HSZ hszAppName = 0;%@NL@%
%@NL@%
%@AB@%/*                               HSZ    PROCEDURE       PSZ        */%@AE@%%@NL@%
%@NL@%
ITEMLIST sysTopicItemList[] = {%@NL@%
                                { 0, TopicListXfer,  SZDDESYS_ITEM_TOPICS   },%@NL@%
                                { 0, ItemListXfer,   SZDDESYS_ITEM_SYSITEMS },%@NL@%
                                { 0, NotSupported,   SZDDESYS_ITEM_RTNMSG   },%@NL@%
                                { 0, NotSupported,   SZDDESYS_ITEM_STATUS   },%@NL@%
                                { 0, sysFormatsXfer, SZDDESYS_ITEM_FORMATS  },%@NL@%
                              };%@NL@%
%@NL@%
ITEMLIST msgTopicItemList[] = {%@NL@%
                                { 0, msgUserNameXfer, SZUSERNAME},%@NL@%
                                { 0, msgMessageXfer, SZMESSAGEDATA},%@NL@%
                                { 0, bmpXfer, SZBMAPDATA}, %@NL@%
                              };%@NL@%
%@NL@%
%@NL@%
%@AB@%/*                           HSZ   PROCEDURE       #ofITEMS     PSZ     */%@AE@%%@NL@%
   %@NL@%
TOPICLIST topicList[] = {%@NL@%
    %@AB@%/* The system topic is always assumed to be first. */%@AE@%%@NL@%
                            { 0, sysTopicItemList, IIL_SYSLAST, SZDDESYS_TOPIC},%@NL@%
                            { 0, msgTopicItemList, IIL_MSGLAST, SZDDEMSGTOPIC},%@NL@%
                        };%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   Main dude.%@NL@%
%@AB@%* History:      1/1/89  Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void cdecl main(argc, argv)%@NL@%
int argc;%@NL@%
char *argv[];%@NL@%
{%@NL@%
    USHORT err;%@NL@%
    HPS hps;%@NL@%
    QMSG qmsg;%@NL@%
    ULONG createFlags;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * check command line args%@NL@%
%@AB@%     *  User can specify a email name up to MAX_NAMESTR%@NL@%
%@AB@%     *  ! turns on a debug break%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (argc > 1) {%@NL@%
        if (strlen(argv[1]) > MAX_NAMESTR)%@NL@%
            NotifyUser(SZBADCOMPARAMS);%@NL@%
        else if (*argv[1] != '!')%@NL@%
            strcpy(szEmailName, argv[1]);%@NL@%
    }%@NL@%
    %@NL@%
    hab = WinInitialize(0);%@NL@%
    hheap = WinCreateHeap(0, 0, 0, 0, 0, HM_MOVEABLE | HM_VALIDSIZE);%@NL@%
    hmq = WinCreateMsgQueue(hab, 100);  %@AB@%/* Note the larger than normal Q ! */%@AE@%%@NL@%
%@NL@%
    WinRegisterClass(hab, SZHOLDINGCLASS, WinDefWindowProc, 0L, 0L);%@NL@%
    WinRegisterClass(hab, SZAPPCLASS, MainWndProc, CS_SIZEREDRAW, 4L);%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * set up cyText for later%@NL@%
%@AB@%     */%@AE@%%@NL@%
    {%@NL@%
        FONTMETRICS fm;%@NL@%
%@NL@%
        hps = WinGetPS(HWND_DESKTOP);%@NL@%
        GpiQueryFontMetrics(hps, (LONG)sizeof(FONTMETRICS), &fm);%@NL@%
        WinReleasePS(hps);%@NL@%
        cyText = (SHORT)fm.lMaxBaselineExt;%@NL@%
    }%@NL@%
%@NL@%
    InitBmapModule();%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * force the user to set up his email name.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (szEmailName[0] == '\0')%@NL@%
        WinDlgBox(HWND_DESKTOP, NULL, (PFNWP)GetNameDlgProc, (HMODULE)NULL,%@NL@%
                IDD_GETNAME, (PVOID)szEmailName);%@NL@%
                %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Initialize the DDE manager%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((err = DdeInitialize((PFNCALLBACK)Callback, 0L, 0L)) != NULL) {%@NL@%
        DdePostError(err);%@NL@%
        goto abort;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Create all HSZs we expect to need%@NL@%
%@AB@%     */%@AE@%%@NL@%
    Hszize();%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Create our main window%@NL@%
%@AB@%     */%@AE@%%@NL@%
    createFlags = FCF_STANDARD;%@NL@%
    hwndMsngrFrame = WinCreateStdWindow(HWND_DESKTOP, 0L, NULL,%@NL@%
        SZAPPCLASS, "", 0L, (HMODULE)NULL, IDR_MSNGR1, &hwndMsngr);%@NL@%
        %@NL@%
    WinSetWindowPos(hwndMsngrFrame, HWND_TOP, 0, 0,%@NL@%
        250, 150, SWP_SHOW | SWP_ZORDER | SWP_SIZE);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * set up the initial title string.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    SetEmailName(szEmailName);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * process the main window till dismissed.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    while (WinGetMsg(hab, &qmsg, NULL, 0, 0))%@NL@%
        WinDispatchMsg(hab, &qmsg);%@NL@%
%@NL@%
abort:%@NL@%
    if (hptrLink != 0)%@NL@%
        WinDestroyPointer(hptrLink);%@NL@%
%@NL@%
    WinDestroyWindow(hwndMsngrFrame);%@NL@%
    CloseBmapModule();%@NL@%
    DdeAppNameServer(hszAppName, ANS_UNREGISTER | ANS_FILTERON);%@NL@%
    UnHszize();%@NL@%
    DdeUninitialize();%@NL@%
    WinTerminate(hab);%@NL@%
    DosExit(EXIT_PROCESS, 0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/********** Msngr Window Procedure **************/%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY MainWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    char szCaption[MAX_CAPTIONSTR + 1];%@NL@%
    NPUSERLIST pUserItem;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_CREATE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * initialize globals%@NL@%
%@AB@%         */%@AE@%%@NL@%
        hwndMsngr = hwnd;%@NL@%
        hwndLB = WinCreateWindow(hwndMsngr, WC_LISTBOX, "",%@NL@%
                WS_VISIBLE | LS_NOADJUSTPOS, 0, 0, 0, 0, hwndMsngr,%@NL@%
                HWND_TOP, WID_LISTBOX, NULL, NULL);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * create a holding window to be the owner of all the floating%@NL@%
%@AB@%         * dialogs which need to be destroyed on exit.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        hwndHolder = WinCreateWindow(HWND_OBJECT, SZHOLDINGCLASS, "", 0L,%@NL@%
                0, -1, 0, 0, (HWND)NULL, HWND_TOP, 0, (PVOID)NULL, (PVOID)NULL);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * we register our name here so keeping track of who is out there%@NL@%
%@AB@%         * is simplified.  The DLL will now let us know when other%@NL@%
%@AB@%         * instances of this app come and go.%@NL@%
%@AB@%         *%@NL@%
%@AB@%         * As the DLL lets other msngr apps know we are here, they%@NL@%
%@AB@%         * will connect with us, ask us our name, and poke to us their%@NL@%
%@AB@%         * names.  Each poke will cause their name to be added to our%@NL@%
%@AB@%         * user list.%@NL@%
%@AB@%         *%@NL@%
%@AB@%         * If our requested name happens to be the same as one of theirs,%@NL@%
%@AB@%         * they will ignore our registration and assume we will change%@NL@%
%@AB@%         * our name.%@NL@%
%@AB@%         *%@NL@%
%@AB@%         * If we find that a poke from them is the same as our name, we%@NL@%
%@AB@%         * know that we are a duplicate.  We will then alter the email%@NL@%
%@AB@%         * name to be unique and reregister ourselves with the AppNameServer.%@NL@%
%@AB@%         * This will restart the registration notification process as%@NL@%
%@AB@%         * described here.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        DdeAppNameServer(hszAppName, ANS_REGISTER | ANS_FILTERON);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_SIZE:%@NL@%
        WinSetWindowPos(hwndLB, HWND_TOP, -1, -1, SHORT1FROMMP(mp2) + 2,%@NL@%
                SHORT2FROMMP(mp2) + 2, SWP_SIZE | SWP_MOVE | SWP_SHOW);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
        case IDM_DOSENDTEXT:%@NL@%
            if (!(pUserItem = AccessSelection()))%@NL@%
                break;%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndMsngr, SendTextDlgProc, 0L,%@NL@%
                    IDD_SENDTEXT, (PVOID)pUserItem);%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_DOSENDBITMAP:%@NL@%
            if (!(pUserItem = AccessSelection()))%@NL@%
                break;%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndMsngr, SendBitmapDlgProc,%@NL@%
                    0L, IDD_SENDBITMAP, (PVOID)pUserItem);%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_DOSENDSONG:%@NL@%
            if (!(pUserItem = AccessSelection()))%@NL@%
                break;%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndMsngr, SendSongDlgProc, 0L,%@NL@%
                    IDD_SENDSONG, (PVOID)pUserItem);%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_INITLINK:%@NL@%
            if (!(pUserItem = AccessSelection()))%@NL@%
                break;%@NL@%
            if (!WinIsWindow(hab, pUserItem->hwndLink)) {%@NL@%
                CreateLinkWindow(pUserItem, LNKST_USERSTART);%@NL@%
            } else {%@NL@%
                WinSetWindowPos(pUserItem->hwndLink, HWND_TOP,%@NL@%
                        0, 0, 0, 0,%@NL@%
                        SWP_SHOW | SWP_RESTORE | SWP_FOCUSACTIVATE);%@NL@%
            }%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * we use this message so we can do asynchronous incomming message%@NL@%
%@AB@%     * notification.  This prevents us from eternal loops via the%@NL@%
%@AB@%     * callback function.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    case UM_MSG_NOTIFY:%@NL@%
        lstrcat((PSZ)szCaption, (PSZ)SZMSGIN,%@NL@%
                (PSZ)&(((PSZ)mp1)[lstrlen((PSZ)mp1) + 1]));%@NL@%
        NotifyUser2(szCaption, (PSZ)mp1);%@NL@%
        WinFreeMem(hheap, (NPBYTE)(USHORT)mp1,%@NL@%
                MAX_MSGSTR + 1 + MAX_NAMESTR + 1);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CLOSE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * destroy the holder window, and with it, shutdown any floating%@NL@%
%@AB@%         * dialogs.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinDestroyWindow(hwndHolder);%@NL@%
        %@AB@%/* fall through */%@AE@%%@NL@%
    default:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%* This dialog forces the user to enter a string.  It may be used for%@NL@%
%@AB@%* entering the user's initial email name or it can be used to change%@NL@%
%@AB@%* the current email name.%@NL@%
%@AB@%*%@NL@%
%@AB@%* It must be invoked with a psz specified for its cData which is where its%@NL@%
%@AB@%* result will be stored.  The psz can be no larger than MAX_NAMESTR.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/1/89  Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY GetNameDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    PSZ pszName;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_INITDLG: {%@NL@%
            HWND hwndEF;%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * store pszName into window words for later access and set up the%@NL@%
%@AB@%             * default name entry.%@NL@%
%@AB@%             * This assumes mp2=pszText for this dialog's entryfield.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinSetWindowULong(hwnd, QWL_USER, (ULONG)mp2);%@NL@%
            if (*(PSZ)mp2 != '\0') {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * we are changing a name because of a duplicate, change%@NL@%
%@AB@%                 * the title apropriately.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                WinSetDlgItemText(hwnd, FID_TITLEBAR, SZDUPTITLE);%@NL@%
            }%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * set up our entryfield to be enhanced.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            hwndEF = WinWindowFromID(hwnd, IDC_EF_NAME);%@NL@%
            lpfnSysEFWndProc = WinSubclassWindow(hwndEF, EnhancedEFWndProc);%@NL@%
%@NL@%
            WinSetWindowText(hwndEF, (PSZ)mp2);%@NL@%
            WinSendMsg(hwndEF, EM_SETTEXTLIMIT, MPFROMSHORT(MAX_NAMESTR), 0L);%@NL@%
            return(0L);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case ENHAN_ENTER:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * when the user hits the enter key, it will be passed from the%@NL@%
%@AB@%         * entryfield to here and we will use it as a signal to exit.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        pszName = (PSZ)WinQueryWindowULong(hwnd, QWL_USER);%@NL@%
        WinQueryDlgItemText(hwnd, IDC_EF_NAME, MAX_NAMESTR + 1,%@NL@%
                pszName);%@NL@%
        if (*pszName != '\0') {%@NL@%
            WinDismissDlg(hwnd, 0);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%**%@NL@%
%@AB@%*This window proc, which is actually a subclass of the standard entryfield *%@NL@%
%@AB@%*type of window, notifies its owner of more interesting things than the    *%@NL@%
%@AB@%*origonal did.                                                             *%@NL@%
%@AB@%**%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY EnhancedEFWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    switch (msg) {%@NL@%
    case WM_CHAR:%@NL@%
        if (LOUSHORT(mp1) & KC_SCANCODE &&%@NL@%
                LOUSHORT(mp1) & KC_KEYUP &&%@NL@%
                %@AB@%/*---HACK ALERT!---*/%@AE@%%@NL@%
                LOBYTE(LOUSHORT(mp2)) == 0x0d) {%@NL@%
            NOTIFYOWNER(hwnd, ENHAN_ENTER,%@NL@%
                    (MPARAM)WinQueryWindowUShort(hwnd, QWS_ID), 0L);%@NL@%
        }%@NL@%
        break;%@NL@%
    }%@NL@%
    return(lpfnSysEFWndProc(hwnd, msg, mp1, mp2));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY SendTextDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    switch (msg) {%@NL@%
    case WM_INITDLG:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * mp2 should be set to the pUserItem of the person we are sending to.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinSendDlgItemMsg(hwnd, IDC_EF_TEXT, EM_SETTEXTLIMIT,%@NL@%
                MPFROMSHORT(MAX_MSGSTR + 1), 0L);%@NL@%
                %@NL@%
        if (((NPUSERLIST)(SHORT)mp2)->hConvMsg == 0) {%@NL@%
            NotifyUser(SZCANTCONNECT);%@NL@%
            WinDismissDlg(hwnd, 0);%@NL@%
            return(0);%@NL@%
        }%@NL@%
        WinSetWindowULong(hwnd, QWL_USER, (ULONG)((NPUSERLIST)(SHORT)mp2)->hConvMsg);%@NL@%
        return(0);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
        case IDC_SENDTEXT:%@NL@%
            {%@NL@%
                char szMsg[MAX_MSGSTR + 1 + MAX_NAMESTR + 1];%@NL@%
%@NL@%
                WinQueryDlgItemText(hwnd, IDC_EF_TEXT, MAX_MSGSTR + 1,%@NL@%
                        (PSZ)szMsg);%@NL@%
                if (szMsg[0] == '\0') {%@NL@%
                    NotifyUser(SZEMPTYMSG);%@NL@%
                    return(0);%@NL@%
                }%@NL@%
                lstrpak((PSZ)szMsg, (PSZ)szMsg, (PSZ)szEmailName);%@NL@%
                if (!((USHORT)DdeClientXfer((PBYTE)szMsg,%@NL@%
                        (ULONG)(lstrlen((PSZ)szMsg) + lstrlen((PSZ)szEmailName) + 2),%@NL@%
                        (HCONV)WinQueryWindowULong(hwnd, QWL_USER),%@NL@%
                        msgTopicItemList[IIL_MSGXFER].hszItem, DDEFMT_TEXT,%@NL@%
                        XTYP_POKE, ulTimeout, NULL) & DDE_FACK)) {%@NL@%
                    NotifyUser(SZSENDFAILED);%@NL@%
                    MyPostError(DdeGetLastError());%@NL@%
                    return(0);%@NL@%
                }%@NL@%
            }%@NL@%
            WinDismissDlg(hwnd, 0);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * This would handle the DID_OK exit.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY SendSongDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    switch (msg) {%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function is called by the DDE manager DLL and passes control onto%@NL@%
%@AB@%* the apropriate function pointed to by the global topic and item arrays.%@NL@%
%@AB@%* It handles all DDE interaction generated by external events.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  1/1/89  created     sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA EXPENTRY Callback(hConv, hszTopic, hszItem, usFmt, usType,%@NL@%
        hDmgData)%@NL@%
HCONV hConv;%@NL@%
HSZ hszTopic;%@NL@%
HSZ hszItem;%@NL@%
USHORT usFmt;%@NL@%
USHORT usType;%@NL@%
HDMGDATA hDmgData;%@NL@%
{%@NL@%
    SHORT i, j;%@NL@%
    register ITEMLIST *pItemList;%@NL@%
    USHORT iItemLast;%@NL@%
    HDMGDATA hDmgDataRet;%@NL@%
%@NL@%
    UNUSED usFmt;%@NL@%
    UNUSED hConv;%@NL@%
%@NL@%
    if (usType == XTYP_REGISTER || usType == XTYP_UNREGISTER) {%@NL@%
        if (hszItem == hszAppName) %@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * we are being notified that another msngr app is starting up%@NL@%
%@AB@%             * or going away.%@NL@%
%@AB@%             * hDmgData should be the App handle to use for initiateing.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (usType == XTYP_REGISTER) {%@NL@%
                RegisterUser(hDmgData, NULL, TRUE);%@NL@%
            } else {%@NL@%
                UnregisterUser(hDmgData);%@NL@%
            }%@NL@%
        return(0);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    if (usType == XTYP_WILDINIT) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * He wants a hsz list of all our available app/topic pairs%@NL@%
%@AB@%         * that convorm to hszTopic and hszItem(App).%@NL@%
%@AB@%         */%@AE@%%@NL@%
        HSZ ahsz[(ITL_LAST + 3) * 2];%@NL@%
%@NL@%
        if (hszItem != hszAppName && hszItem != NULL) %@NL@%
            return(0);%@NL@%
%@NL@%
        j = 0;%@NL@%
        for (i = 0; i <= ITL_LAST; i++) {%@NL@%
            if (hszTopic == NULL || hszTopic == topicList[i].hszTopic) {%@NL@%
                ahsz[j++] = hszAppName;%@NL@%
                ahsz[j++] = topicList[i].hszTopic;    %@NL@%
            }%@NL@%
        }%@NL@%
        %@NL@%
        if (hszTopic == NULL || hszTopic == hszEmailName) {%@NL@%
            ahsz[j++] = hszAppName;%@NL@%
            ahsz[j++] = hszEmailName;%@NL@%
        }%@NL@%
            %@NL@%
        ahsz[j++] = ahsz[j++] = 0L;%@NL@%
        return(DdePutData((PBYTE)&ahsz[0], (ULONG)sizeof(HSZ) * j, 0L,%@NL@%
                (HSZ)0L, 0, 0));%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Check for Topic/Item convention for Linking.  Remember that ADVDATA%@NL@%
%@AB@%     * is client intended so its backwards.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((hszTopic == hszEmailName) ||%@NL@%
            (usType == XTYP_ADVDATA && hszItem == hszEmailName)) {%@NL@%
        return(LinkXfer((PXFERINFO)&hDmgData, hszTopic == hszEmailName ?%@NL@%
                hszItem : hszTopic));%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Check our hsz tables and send to the apropriate proc.%@NL@%
%@AB@%     * We use DdeCmpHsz() so hsz comparisons are case insensitive.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    for (i = 0; i <= ITL_LAST; i++) {%@NL@%
        if (DdeCmpHsz(topicList[i].hszTopic, hszTopic) == 0) {%@NL@%
            if (usType == XTYP_INIT) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * it must be a request to start another server conversation.%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                return(TRUE);%@NL@%
            }%@NL@%
            pItemList = topicList[i].pItemList;%@NL@%
            iItemLast = topicList[i].iItemLast;%@NL@%
            for (j = 0; j <= iItemLast; j++) {%@NL@%
                if (DdeCmpHsz(pItemList[j].hszItem, hszItem) == 0) {%@NL@%
                    hDmgDataRet = (*pItemList[j].npfnCallback)%@NL@%
                            ((PXFERINFO)&hDmgData);%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                     * The table functions return a boolean or data.%@NL@%
%@AB@%                     * It gets translated here.%@NL@%
%@AB@%                     */%@AE@%%@NL@%
                    switch (usType & XCLASS_MASK) {%@NL@%
                    case XCLASS_DATA:%@NL@%
                        return(hDmgDataRet);%@NL@%
                        break;%@NL@%
                    case XCLASS_FLAGS:%@NL@%
                        return(hDmgDataRet ? DDE_FACK : DDE_NOTPROCESSED);%@NL@%
                        break;%@NL@%
                    case XCLASS_BOOL:%@NL@%
                        return(TRUE);%@NL@%
                    default:%@NL@%
                        return(0);%@NL@%
                        break;%@NL@%
                    }%@NL@%
                    break;%@NL@%
                }%@NL@%
            }%@NL@%
            break;%@NL@%
        }%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This passes out a standard tab-delimited list of topic names for this%@NL@%
%@AB@%* application.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This support is required for other apps to be able to%@NL@%
%@AB@%* find out about us.  This kind of support should be in every DDE%@NL@%
%@AB@%* application.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  1/3/89  created     sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA TopicListXfer(pXferInfo)%@NL@%
PXFERINFO pXferInfo;%@NL@%
{%@NL@%
    USHORT cb, cbAlloc, iTopic, cch;%@NL@%
    PSZ pszTopicList;%@NL@%
    HDMGDATA hDmgData;%@NL@%
    char szT[MAX_NAMESTR + 1];%@NL@%
    SHORT lit;%@NL@%
%@NL@%
    if (pXferInfo->usFmt != DDEFMT_TEXT ||%@NL@%
            (pXferInfo->usType != XTYP_REQUEST &&%@NL@%
            pXferInfo->usType != XTYP_ADVREQ))%@NL@%
        return(0);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * construct the list of topics we have%@NL@%
%@AB@%     */%@AE@%%@NL@%
    cbAlloc = 0;%@NL@%
    for (iTopic = 0; iTopic <= ITL_LAST; iTopic++)%@NL@%
        cbAlloc += lstrlen(topicList[iTopic].pszTopic) + 1;%@NL@%
    lit = 0;%@NL@%
    while (WinSendMsg(hwndLB, LM_QUERYITEMTEXT,%@NL@%
            MPFROM2SHORT(lit, MAX_NAMESTR + 1), (MPARAM)szT)) {%@NL@%
        cbAlloc += lstrlen(szT) + 1;%@NL@%
        lit++;%@NL@%
    }%@NL@%
    pszTopicList = FarAllocMem(hheap, cbAlloc);%@NL@%
    if (!LOUSHORT(pszTopicList)) %@NL@%
        return(0);%@NL@%
    cb = 0;%@NL@%
    for (iTopic = 0; iTopic <= ITL_LAST; iTopic++) {%@NL@%
        cch = lstrlen(topicList[iTopic].pszTopic) + 1;%@NL@%
        DdeCopyBlock(topicList[iTopic].pszTopic, pszTopicList + cb, (ULONG)cch);%@NL@%
        cb += cch;%@NL@%
        pszTopicList[cb - 1] = '\t';%@NL@%
    }%@NL@%
    lit = 0;%@NL@%
    while (WinSendMsg(hwndLB, LM_QUERYITEMTEXT,%@NL@%
            MPFROM2SHORT(lit, MAX_NAMESTR + 1), (MPARAM)szT)) {%@NL@%
        cch = lstrlen(szT) + 1;%@NL@%
        DdeCopyBlock(szT, pszTopicList + cb, (ULONG)cch);%@NL@%
        cb += cch;%@NL@%
        pszTopicList[cb - 1] = '\t';%@NL@%
        lit++;%@NL@%
    }%@NL@%
    pszTopicList[cb - 1] = '\0';%@NL@%
    hDmgData = DdePutData(pszTopicList, (ULONG)cb, 0L, pXferInfo->hszItem,%@NL@%
            DDEFMT_TEXT, 0);%@NL@%
    WinFreeMem(hheap, (NPBYTE)(SHORT)pszTopicList, cbAlloc);%@NL@%
    return(hDmgData);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* This passes out a standard tab-delimited list of item names for the%@NL@%
%@AB@%* specified topic.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This support is required for other apps to be able to%@NL@%
%@AB@%* find out about us.  This kind of support should be in every DDE%@NL@%
%@AB@%* application.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  1/3/89  created     sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA ItemListXfer(pXferInfo)%@NL@%
PXFERINFO pXferInfo;%@NL@%
{%@NL@%
    USHORT cb, cbAlloc, iTopic, iItem, iLast, cch;%@NL@%
    ITEMLIST *pItemList = 0;%@NL@%
    PSZ pszItemList;%@NL@%
    HDMGDATA hDmgData;%@NL@%
%@NL@%
    if (pXferInfo->usFmt != DDEFMT_TEXT ||%@NL@%
                (pXferInfo->usType != XTYP_REQUEST &&%@NL@%
                pXferInfo->usType != XTYP_ADVREQ))%@NL@%
        return(0);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * construct the list of items we support for this topic.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    for (iTopic = 0; iTopic < ITL_LAST; iTopic++) {%@NL@%
        if (pXferInfo->hszTopic == topicList[iTopic].hszTopic) {%@NL@%
            pItemList = topicList[iTopic].pItemList;%@NL@%
            iLast = topicList[iTopic].iItemLast;%@NL@%
            break;%@NL@%
        }%@NL@%
    }%@NL@%
    if (pItemList == 0)%@NL@%
        return(0);%@NL@%
    cbAlloc = 0;%@NL@%
    for (iItem = 0; iItem < iLast; iItem++)%@NL@%
        cbAlloc += lstrlen(pItemList[iItem].pszItem) + 1;%@NL@%
    pszItemList = FarAllocMem(hheap, cbAlloc);%@NL@%
    if (!LOUSHORT(pszItemList))%@NL@%
        return(0);%@NL@%
    cb = 0;%@NL@%
    for (iItem = 0; iItem < iLast; iItem++) {%@NL@%
        cch = lstrlen(pItemList[iItem].pszItem) + 1;%@NL@%
        DdeCopyBlock(pItemList[iItem].pszItem, pszItemList + cb, (ULONG)cch);%@NL@%
        cb += cch;%@NL@%
        pszItemList[cb - 1] = '\t';%@NL@%
    }%@NL@%
    pszItemList[cb - 1] = '\0';%@NL@%
    hDmgData = DdePutData(pszItemList, (ULONG)cb, 0L,%@NL@%
            pXferInfo->hszItem, DDEFMT_TEXT, 0);%@NL@%
    WinFreeMem(hheap, (NPBYTE)(USHORT)pszItemList, cbAlloc);%@NL@%
    return(hDmgData);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Used for unsupported transfers.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  1/1/89  created     sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA NotSupported(pXferInfo)%@NL@%
PXFERINFO pXferInfo;%@NL@%
{%@NL@%
    pXferInfo;%@NL@%
    %@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Gives out a 0 terminated array of dde format numbers supported by this app.%@NL@%
%@AB@%*%@NL@%
%@AB@%* This support is required for other apps to be able to%@NL@%
%@AB@%* find out about us.  This kind of support should be in every DDE%@NL@%
%@AB@%* application.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/1/89  Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA sysFormatsXfer(pXferInfo)%@NL@%
PXFERINFO pXferInfo;%@NL@%
{%@NL@%
    USHORT Formats[2];%@NL@%
%@NL@%
    if (pXferInfo->usFmt != DDEFMT_TEXT ||%@NL@%
            (pXferInfo->usType != XTYP_REQUEST &&%@NL@%
            pXferInfo->usType != XTYP_ADVREQ))%@NL@%
        return(0);%@NL@%
%@NL@%
    Formats[0] = DDEFMT_TEXT;%@NL@%
    Formats[1] = 0;%@NL@%
    return(DdePutData((PBYTE)Formats, 4L, 0L, pXferInfo->hszItem,%@NL@%
            DDEFMT_TEXT, 0));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* Gives out our szEmailName or registers someone elses.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/1/89  Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HDMGDATA msgUserNameXfer(pXferInfo)%@NL@%
PXFERINFO pXferInfo;%@NL@%
{%@NL@%
    CONVINFO ci;%@NL@%
    %@NL@%
    if (pXferInfo->usFmt != DDEFMT_TEXT)%@NL@%
        return(0);%@NL@%
%@NL@%
    switch (pXferInfo->usType) {%@NL@%
    case XTYP_REQUEST:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * someone wants to know our name...cool.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        return(DdePutData(szEmailName, (ULONG)(lstrlen(szEmailName) + 1),%@NL@%
                0L, pXferInfo->hszItem, DDEFMT_TEXT, 0));%@NL@%
        break;%@NL@%
%@NL@%
    case XTYP_POKE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Someone is responding to our initial registration.  Add them%@NL@%
%@AB@%         * to our list.  If their name is the same as ours, WE are at%@NL@%
%@AB@%         * fault and must change our email name and reregister.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        DdeQueryConvInfo(pXferInfo->hConv, &ci, QID_SYNC);%@NL@%
        RegisterUser(ci.hApp, pXferInfo->hDmgData, FALSE); %@NL@%
        return(1);%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This is used for receiving text messages.%@NL@%
%@AB@% */%@AE@%%@NL@%
HDMGDATA msgMessageXfer(pXferInfo)%@NL@%
PXFERINFO pXferInfo;%@NL@%
{%@NL@%
    PSZ pszMsg;%@NL@%
%@NL@%
    if (pXferInfo->usFmt != DDEFMT_TEXT)%@NL@%
        return(DDE_NOTPROCESSED);%@NL@%
%@NL@%
    switch (pXferInfo->usType) {%@NL@%
    case XTYP_POKE:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * we have the message text followed by the users name.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        pszMsg = FarAllocMem(hheap, MAX_MSGSTR + 1 + MAX_NAMESTR + 1);%@NL@%
        DdeGetData(pXferInfo->hDmgData, (PBYTE)pszMsg,%@NL@%
                (ULONG)(MAX_MSGSTR + 1 + MAX_NAMESTR + 1), 0L);%@NL@%
        DdeFreeData(pXferInfo->hDmgData);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * We must do an assynchronous user notification so we don't%@NL@%
%@AB@%         * clog up the DLL in our callback.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinPostMsg(hwndMsngr, UM_MSG_NOTIFY, pszMsg, 0L);%@NL@%
        return(1);%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*  This creates often used global hszs from standard global strings.%@NL@%
%@AB@%*  It also fills the hsz fields of the topic and item tables.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/1/89  Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void Hszize()%@NL@%
{%@NL@%
    register ITEMLIST *pItemList;%@NL@%
    USHORT iTopic, iItem;%@NL@%
%@NL@%
    hszAppName = DdeGetHsz((PSZ)SZDDEAPPNAME, 0, 0);%@NL@%
%@NL@%
    for (iTopic = 0; iTopic <= ITL_LAST; iTopic++) {%@NL@%
        topicList[iTopic].hszTopic = DdeGetHsz(topicList[iTopic].pszTopic, 0, 0);%@NL@%
        pItemList = topicList[iTopic].pItemList;%@NL@%
        for (iItem = 0; iItem <= topicList[iTopic].iItemLast; iItem++) {%@NL@%
            pItemList[iItem].hszItem = DdeGetHsz(pItemList[iItem].pszItem, 0, 0);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*  This destroys often used global hszs from standard global strings.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/1/89  Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void UnHszize()%@NL@%
{%@NL@%
    register ITEMLIST *pItemList;%@NL@%
    USHORT iTopic, iItem;%@NL@%
%@NL@%
    DdeFreeHsz(hszAppName);%@NL@%
    DdeFreeHsz(hszEmailName);%@NL@%
%@NL@%
    for (iTopic = 0; iTopic <= ITL_LAST; iTopic++) {%@NL@%
        DdeFreeHsz(topicList[iTopic].hszTopic);%@NL@%
        pItemList = topicList[iTopic].pItemList;%@NL@%
        for (iItem = 0; iItem <= topicList[iTopic].iItemLast; iItem++) {%@NL@%
            DdeFreeHsz(pItemList[iItem].hszItem);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   This routine returns the userlist item pointed to by the listbox selection.%@NL@%
%@AB@%*   It notifies the user of any errors and returns 0 in that case.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/17/89     Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
NPUSERLIST AccessSelection()%@NL@%
{%@NL@%
    NPUSERLIST pUserItem;%@NL@%
    SHORT lit;%@NL@%
%@NL@%
    lit = (SHORT)WinSendMsg(hwndLB, LM_QUERYSELECTION, 0L, 0L);%@NL@%
    if (lit == LIT_NONE) {%@NL@%
        NotifyUser(SZMAKESELECTION);%@NL@%
        return(0);%@NL@%
    }%@NL@%
    pUserItem = (NPUSERLIST)(SHORT)WinSendMsg(hwndLB, LM_QUERYITEMHANDLE,%@NL@%
            (MPARAM)lit, 0L);%@NL@%
    return(pUserItem);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * if fRegister : (We got the name via a request)%@NL@%
%@AB@% * This routine creates a connection with hApp on the msgTopic and%@NL@%
%@AB@% * gets the user's name from the connection.  It then looks for the%@NL@%
%@AB@% * user's name in our current list.  If the name is already there%@NL@%
%@AB@% * we fail - he is a fault, otherwise we add the user name to our%@NL@%
%@AB@% * list of users. We then poke our name to the server we connected%@NL@%
%@AB@% * with so he knows who we are.%@NL@%
%@AB@% *%@NL@%
%@AB@% * else :   (We got the name via a poke)%@NL@%
%@AB@% * hData contains a valid user name which we will add.%@NL@%
%@AB@% * If it is a dup of ours, we must change our name and reregister.  The%@NL@%
%@AB@% * data handle is freed on return.%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL RegisterUser(%@NL@%
HAPP hApp,%@NL@%
HDMGDATA hData,%@NL@%
BOOL fRegister)%@NL@%
{%@NL@%
    HCONV hConv;%@NL@%
    HSZ hsz;%@NL@%
    BOOL fDup;%@NL@%
%@NL@%
    hConv = DdeConnect(hszAppName, topicList[ITL_MSG].hszTopic, NULL, hApp);%@NL@%
    if (!hConv)  {%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
        %@NL@%
    if (fRegister) %@NL@%
        hData = DdeClientXfer(NULL, 0L, hConv,%@NL@%
                msgTopicItemList[IIL_MSGUSERNAME].hszItem,%@NL@%
                DDEFMT_TEXT, XTYP_REQUEST, DEFTIMEOUT, NULL);%@NL@%
        %@NL@%
    if (!hData) %@NL@%
        return(FALSE);%@NL@%
        %@NL@%
    hsz = DdeGetHsz(DdeAccessData(hData), 0, 0);%@NL@%
    DdeFreeData(hData);%@NL@%
    %@NL@%
    fDup = (hsz == hszEmailName) || FindUser(gnpUL, hsz);%@NL@%
    %@NL@%
    if (fDup && !fRegister) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * OOPS - we are a duplicate name! - Change our name and reregister!!!%@NL@%
%@AB@%         * (we must first stop callbacks so the dialog modal loop%@NL@%
%@AB@%         *  doesn't allow more messy callbacks to come in.)%@NL@%
%@AB@%         */%@AE@%%@NL@%
        DdeEnableCallback(NULL, FALSE);%@NL@%
        while (gnpUL) %@NL@%
            DestroyUser(gnpUL);%@NL@%
        WinSendMsg(hwndLB, LM_DELETEALL, 0L, 0L);%@NL@%
        WinDlgBox(HWND_DESKTOP, NULL, (PFNWP)GetNameDlgProc, (HMODULE)NULL,%@NL@%
                IDD_GETNAME, (PVOID)szEmailName);%@NL@%
        SetEmailName(szEmailName);%@NL@%
        DdeEnableCallback(NULL, TRUE);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * reregister with the name server so others know we changed our name.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        DdeAppNameServer(hszAppName, ANS_UNREGISTER);%@NL@%
        DdeAppNameServer(hszAppName, ANS_REGISTER);%@NL@%
        DdeFreeHsz(hsz);%@NL@%
        DdeFreeData(hData);%@NL@%
        DdeDisconnect(hConv);%@NL@%
        return(FALSE);%@NL@%
    } %@NL@%
    %@NL@%
    if (!fDup)%@NL@%
        AddUser(hConv, hsz, hApp);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now poke our name to him (if he is registering), so he gets updated%@NL@%
%@AB@%     * or discovers he's a duplicate.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (fRegister) {%@NL@%
        DdeClientXfer(szEmailName, lstrlen(szEmailName) + 1L,%@NL@%
                hConv, msgTopicItemList[IIL_MSGUSERNAME].hszItem,%@NL@%
                DDEFMT_TEXT, XTYP_POKE, DEFTIMEOUT, NULL);%@NL@%
    }%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * We search for the hApp in our user list.  If its not there we fail.%@NL@%
%@AB@% * Otherwise, we destroy any associated connections or windows and%@NL@%
%@AB@% * remove the entry from our list.%@NL@%
%@AB@% *%@NL@%
%@AB@% * The case of duplicate name re-registration is covered here since%@NL@%
%@AB@% * we ignore duplicate registrations and so we will not find hApp%@NL@%
%@AB@% * if a duplicate name is being unregistered.%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL UnregisterUser(%@NL@%
HAPP hApp)%@NL@%
{%@NL@%
    NPUSERLIST npUser;%@NL@%
    SHORT lit;%@NL@%
%@NL@%
    if (hApp == 0) {%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    npUser = gnpUL;%@NL@%
    while (npUser) {%@NL@%
        if (hApp == npUser->hApp)%@NL@%
            break;%@NL@%
        npUser = npUser->next;%@NL@%
    }%@NL@%
    %@NL@%
    if (!npUser) {%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
    %@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Remove item from listbox.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (lit = (SHORT)WinSendMsg(hwndLB, LM_QUERYITEMCOUNT, 0L, 0L)) {%@NL@%
        while (lit--) {%@NL@%
            if (npUser == (NPUSERLIST)(SHORT)WinSendMsg(hwndLB,%@NL@%
                    LM_QUERYITEMHANDLE, MPFROMSHORT(lit), 0L)) {%@NL@%
                WinSendMsg(hwndLB, LM_DELETEITEM, MPFROMSHORT(lit), 0L);   %@NL@%
                break;%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
    DestroyUser(npUser);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
VOID SetEmailName(psz)%@NL@%
PSZ psz;%@NL@%
{%@NL@%
    if (hszEmailName) %@NL@%
        DdeFreeHsz(hszEmailName);%@NL@%
    hszEmailName = DdeGetHsz(psz, 0, 0);%@NL@%
    lstrcpy(szEmailName, psz);%@NL@%
    lstrcat(szTitle, szTitlePrefix, szEmailName);%@NL@%
    WinSetWindowText(hwndMsngrFrame, szTitle);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
void NotifyUser(psz)%@NL@%
PSZ psz;%@NL@%
{%@NL@%
    WinMessageBox(HWND_DESKTOP, hwndMsngr, psz, SZNOTIFYCAPTION,%@NL@%
            WID_NOTIFY1,%@NL@%
            MB_OK | MB_DEFBUTTON1 | MB_ICONASTERISK | MB_MOVEABLE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
void NotifyUser2(pszCaption, pszText)%@NL@%
PSZ pszCaption;%@NL@%
PSZ pszText;%@NL@%
{%@NL@%
    WinMessageBox(HWND_DESKTOP, hwndMsngr, pszText, pszCaption, WID_NOTIFY2,%@NL@%
            MB_OK | MB_DEFBUTTON1 | MB_ICONASTERISK | MB_MOVEABLE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%NEAD.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\NEAD\NEAD.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@% This program implements an extended attributes editor.%@NL@%
%@AB@% Included in this file are all of the PM interface procedures.%@NL@%
%@AB@% All of these procs represent procedures for dialog boxes.%@NL@%
%@AB@%%@NL@%
%@AB@% This program was written by Jeff Johnson, 7/89, with pieces%@NL@%
%@AB@% of code pooled from already existing applications.%@NL@%
%@AB@%%@NL@%
%@AB@% This code is not fully implemented as it was written to show%@NL@%
%@AB@% how to use EAs.  Specifically, the Copy, Copy all, and Paste%@NL@%
%@AB@% buttons are not implemented, Icons and bitmaps are not%@NL@%
%@AB@% supported, and Multi-value, single-type EAs are also not%@NL@%
%@AB@% implemented.%@NL@%
%@AB@%%@NL@%
%@AB@% The EA code revolves around the HoldFEA structure.  This%@NL@%
%@AB@% structure is a linked list which contains one EA per%@NL@%
%@AB@% structure.  Each HoldFEA structure is dynamically allocated%@NL@%
%@AB@% as are the two string pointer members of the structure,%@NL@%
%@AB@% szName and aValue.  This is done to make handling the EAs%@NL@%
%@AB@% easier and more flexable.%@NL@%
%@AB@%%@NL@%
%@AB@% Procedures in this file:%@NL@%
%@AB@%   main()          Sets up the PM environment and heap and%@NL@%
%@AB@%                   calls the main dialog procedure MainDlgProc%@NL@%
%@AB@%   MainDlgProc()   Handles the main window messages%@NL@%
%@AB@%   AddEAProc()     Handles new EA name entry and type selection%@NL@%
%@AB@%   AsciiEditProc() Handles editing of EA name/value%@NL@%
%@AB@%   IconDlgProc()   Unimplemented icon procedure handler%@NL@%
%@AB@%   MultiTypeProc() Handles the Multi-type dialog box%@NL@%
%@AB@%   ShowEAType()    Shows Selected EA Type for MainDlgProc%@NL@%
%@AB@%   EditEA()        Handles selection of an EA in the listbox%@NL@%
%@AB@%   GetCurFEA()     Gets a ptr to the hi-lited EA in the listbox%@NL@%
%@AB@%%@NL@%
%@AB@%**************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"nead.h" %@NL@%
%@NL@%
%@AB@%/********************* GLOBALS *******************************/%@AE@%%@NL@%
%@NL@%
CHAR szFileName[CCHMAXPATH];    %@AB@%/* Holds current EA file */%@AE@%%@NL@%
CHAR szEAName[MAXEANAME+1];     %@AB@%/* Used to return the EA name +1 for NULL */%@AE@%%@NL@%
USHORT usRetEAType;             %@AB@%/* Used to return selected EA Type */%@AE@%%@NL@%
BOOL FILE_ISOPEN = FALSE;       %@AB@%/* File Open flag */%@AE@%%@NL@%
BOOL FILE_CHANGED = FALSE;      %@AB@%/* File Changed flag */%@AE@%%@NL@%
BOOL COMMAND_LINE_FILE = FALSE; %@AB@%/* Flag to determine if a file was on the CL */%@AE@%%@NL@%
HHEAP hhp;                      %@AB@%/* Pointer to the heap */%@AE@%%@NL@%
CHAR *szAscii,*szScratch;       %@AB@%/* 2 Pointer used to return misc. strings */%@AE@%%@NL@%
HOLDFEA *pHoldFEA;              %@AB@%/* Global EA linked-list pointer          */%@AE@%%@NL@%
DELETELIST *pDelList;           %@AB@%/* Global ptr to l-l of deleted EAs       */%@AE@%%@NL@%
EADATA ConvTable[EATABLESIZE] = {    %@AB@%/* Setup the table */%@AE@%%@NL@%
   { EA_LPBINARY  ,"Length preceeded hex binary\0        ",IDD_LPDATA},%@NL@%
   { EA_LPASCII   ,"Length preceeded ascii\0             ",IDD_LPDATA},%@NL@%
   { EA_ASCIIZ    ,"Asciiz\0                             ",IDD_ASCIIZ},%@NL@%
   { EA_LPBITMAP  ,"Length preceeded bitmap\0            ",IDD_LPDATA},%@NL@%
   { EA_LPMETAFILE,"Metafile\0                           ",IDD_LPDATA},%@NL@%
   { EA_LPICON    ,"Length preceeded icon\0              ",IDD_LPDATA},%@NL@%
   { EA_ASCIIZFN  ,"Asciiz file name of associated data\0",IDD_ASCIIZ},%@NL@%
   { EA_ASCIIZEA  ,"Asciiz EA of associated data\0       ",IDD_ASCIIZ},%@NL@%
   { EA_MVMT      ,"Multi value multi type field\0       ",IDD_MULTILIST},%@NL@%
   { EA_MVST      ,"Multi value single type field\0      ",IDD_MULTILIST},%@NL@%
   { EA_ASN1      ,"ASN.1 field\0                        ",IDD_ASCIIZ},%@NL@%
   { 0            ,"Non conventional format\0            ",IDD_ASCIIZ}%@NL@%
   };%@NL@%
%@NL@%
%@AB@%/*************************************************************/%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: main()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  argc, argv.  If the user places a file name on the command%@NL@%
%@AB@% *              line, its EAs will be retrieved by default, otherwise%@NL@%
%@AB@% *              the user will be prompted to select a file.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Always returns 0%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Parses the command line, sets up the PM environment, creates%@NL@%
%@AB@% *          a global memory heap, calls the main dialog proc, then%@NL@%
%@AB@% *          cleans up and exits.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: ParseFileName, MainDlgProc (thru PM)%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
int main(int argc, char *argv[])%@NL@%
{%@NL@%
   HAB          hab;%@NL@%
   HMQ          hmq;%@NL@%
%@NL@%
   if(argc > 1)  %@AB@%/* If a command line file, get EAs from it */%@AE@%%@NL@%
      if(ParseFileName(szFileName,argv[1]) != FILE_VALID) %@AB@%/* Bad file name */%@AE@%%@NL@%
         *szFileName=0;%@NL@%
      else%@NL@%
         COMMAND_LINE_FILE = TRUE;%@NL@%
%@NL@%
   %@AB@%/* Note:  The following 3 setup calls aren't currently checked for errors */%@AE@%%@NL@%
   hab = WinInitialize(0);%@NL@%
   hmq = WinCreateMsgQueue(hab, 0);%@NL@%
   hhp = WinCreateHeap(0, 0, GROWSIZE, 0, 0,%@NL@%
                          HM_MOVEABLE | HM_VALIDSIZE | HM_VALIDFLAGS);%@NL@%
%@NL@%
   WinDlgBox(HWND_DESKTOP, HWND_DESKTOP,%@NL@%
                         MainDlgProc,(HMODULE) NULL,IDD_MAIN,NULL);%@NL@%
%@NL@%
   WinDestroyMsgQueue(hmq);%@NL@%
   WinTerminate(hab);%@NL@%
   return 0;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: MainDlgProc()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd, msg, mp1, mp2.  Standard PM Dialog Proc params.%@NL@%
%@AB@% *              No user data is expected in the WM_INITDLG.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Always returns 0, Exits with WinDismissDlg set to TRUE%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Handles all the messages associated with the main window%@NL@%
%@AB@% *          and calls the appropriate handling procedures.  The initialize%@NL@%
%@AB@% *          routine sets up the program icon and posts a load file message%@NL@%
%@AB@% *          to itself.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: Called only by main()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  OpenFile(), AddEA(), DeleteCurEA, WriteEAs, ShowEAType, EditEA%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY MainDlgProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
   HPOINTER hpointer;%@NL@%
   USHORT   usRet;%@NL@%
%@NL@%
   switch(msg)%@NL@%
   {%@NL@%
      case WM_INITDLG:%@NL@%
         hpointer = WinLoadPointer(HWND_DESKTOP,            %@AB@%/* Set Nead Icon */%@AE@%%@NL@%
                                   (HMODULE) NULL,IDR_EAD);%@NL@%
         WinPostMsg(hwnd,WM_SETICON,hpointer,0L);%@NL@%
%@NL@%
         %@AB@%/* Get EAs from file on Command line, or prompt for file name */%@AE@%%@NL@%
         WinPostMsg(hwnd,WM_USER,NULL,NULL);%@NL@%
         return 0L;%@NL@%
%@NL@%
      case WM_USER:  %@AB@%/* Posted by WM_INITDLG allows main window to open 1st */%@AE@%%@NL@%
         OpenFile(hwnd, COMMAND_LINE_FILE ? ARGFILE : 0);%@NL@%
         return 0L;%@NL@%
%@NL@%
      case WM_COMMAND:%@NL@%
         switch(COMMANDMSG(&msg)->cmd)%@NL@%
         {%@NL@%
            case IDD_NEWFILE:     %@AB@%/* Select another file to view/edit EAs */%@AE@%%@NL@%
               OpenFile(hwnd,0);%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDD_ADD:         %@AB@%/* Add an EA to current list in memory  */%@AE@%%@NL@%
               AddEA(hwnd);%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDD_DELETE:      %@AB@%/* Delete an EA from memory             */%@AE@%%@NL@%
               DeleteCurEA(hwnd);%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDD_WRITE:       %@AB@%/* Write EA's out to disk               */%@AE@%%@NL@%
               WriteEAs(hwnd);%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDD_EDIT:        %@AB@%/* Edit the hilited EA                  */%@AE@%%@NL@%
               EditEA(hwnd);%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDD_COPY:        %@AB@%/* Copy and Paste aren't                */%@AE@%%@NL@%
            case IDD_PASTE:       %@AB@%/* currently implemented                */%@AE@%%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDD_QUIT:%@NL@%
               if(FILE_CHANGED)   %@AB@%/* Give user a chance to save changes   */%@AE@%%@NL@%
               {%@NL@%
                  usRet=WinMessageBox(HWND_DESKTOP,hwnd,%@NL@%
                  "The current file has been changed.  Do you \%@NL@%
wish to save the changes before proceeding?",%@NL@%
                  "Warning",0,MB_YESNOCANCEL | MB_ICONQUESTION);%@NL@%
                  switch(usRet)%@NL@%
                  {%@NL@%
                     case MBID_YES:    %@AB@%/* They want to save the EAs       */%@AE@%%@NL@%
                        WriteEAs(hwnd);%@NL@%
                        break;%@NL@%
                     case MBID_CANCEL: %@AB@%/* They don't really want to quit  */%@AE@%%@NL@%
                        return 0L;%@NL@%
                  }%@NL@%
               }%@NL@%
               WinDismissDlg(hwnd,TRUE);%@NL@%
               return 0L;%@NL@%
         }%@NL@%
%@NL@%
      case WM_CONTROL:%@NL@%
         switch(SHORT1FROMMP(mp1))%@NL@%
         {%@NL@%
            case IDD_LBOX:%@NL@%
               switch(SHORT2FROMMP(mp1))%@NL@%
               {%@NL@%
                  case LN_SELECT:       %@AB@%/* A new item has been hi-lited */%@AE@%%@NL@%
                     ShowEAType(hwnd);  %@AB@%/* Display appropriate EA Type  */%@AE@%%@NL@%
                     return 0L;%@NL@%
%@NL@%
                  case LN_ENTER:        %@AB@%/* Edit the selected EA         */%@AE@%%@NL@%
                     EditEA(hwnd);%@NL@%
                     return 0L;%@NL@%
               }%@NL@%
         }%@NL@%
   }%@NL@%
   return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: AddEAProc()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd, msg, mp1, mp2.  Standard PM Dialog Proc params.%@NL@%
%@AB@% *              If user data is passed in, it indicates it is a m-m%@NL@%
%@AB@% *              add and the EA Name is in ->Point and the user should%@NL@%
%@AB@% *              not be allowed to edit it.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Exits with WinDismissDlg set to TRUE if the user selects OK,%@NL@%
%@AB@% *          FALSE if the user selects CANCEL.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Handles the screen that allows the user to enter a new EA Name%@NL@%
%@AB@% *          and select the EA type.  It checks to make sure the name is%@NL@%
%@AB@% *          unique and is not NULL before returning.  The user pointer is%@NL@%
%@AB@% *          used to determine whether the name is allowed to change or not.%@NL@%
%@AB@% *          If it points to a PassData structure, the Point member gives the%@NL@%
%@AB@% *          static EA Name.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: Called by both the add EA routine and the m-m EA add%@NL@%
%@AB@% *                 routine.  This routine places the user typed name in%@NL@%
%@AB@% *                 global szEAName, and the EA type in global usRetEAType.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  EAExists()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY AddEAProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
   static CHAR bPDat = 0; %@AB@%/* flag indicating if the pPDat struct is valid */%@AE@%%@NL@%
   PASSDATA FAR *pPDat;   %@AB@%/* struct used to pass in default EA name       */%@AE@%%@NL@%
%@NL@%
   switch(msg)%@NL@%
   {%@NL@%
      case WM_INITDLG:%@NL@%
         bPDat = 0;%@NL@%
         WinSendDlgItemMsg(hwnd, IDD_EANAME,EM_SETTEXTLIMIT,%@NL@%
                                 MPFROM2SHORT(MAXEANAME,0),NULL);%@NL@%
         WinSendDlgItemMsg(hwnd, EA_LPASCII,BM_CLICK,0L,0L);%@NL@%
%@NL@%
         pPDat=PVOIDFROMMP(mp2);%@NL@%
         if(pPDat)%@NL@%
         {%@NL@%
            bPDat = 1;%@NL@%
            WinSetDlgItemText(hwnd, IDD_EANAME,pPDat->Point);%@NL@%
            WinSetDlgItemText(hwnd, IDD_TITLE,%@NL@%
                              "Add a Multi-type field to the EA");%@NL@%
            WinEnableWindow(WinWindowFromID(hwnd,IDD_EANAME),%@NL@%
                            FALSE);                %@AB@%/* Disable EA Name field */%@AE@%%@NL@%
            WinSetFocus(HWND_DESKTOP,WinWindowFromID(hwnd,DID_OK));%@NL@%
%@NL@%
            return (MRESULT) TRUE;       %@AB@%/* We don't want default focus setting */%@AE@%%@NL@%
         }%@NL@%
         return 0L;%@NL@%
%@NL@%
      case WM_COMMAND:%@NL@%
         switch(COMMANDMSG(&msg)->cmd)%@NL@%
         {%@NL@%
            case DID_OK:%@NL@%
               if(bPDat == 0)          %@AB@%/* It is a new EA (not multi-type)   */%@AE@%%@NL@%
               {%@NL@%
                  WinQueryDlgItemText(hwnd, IDD_EANAME, MAXEANAME+1, szEAName);%@NL@%
%@NL@%
                  if(!strlen(szEAName))    %@AB@%/* Don't allow a Null EA Name    */%@AE@%%@NL@%
                  {%@NL@%
                     WinAlarm(HWND_DESKTOP,WA_ERROR);%@NL@%
                     WinMessageBox(HWND_DESKTOP, hwnd,%@NL@%
                                   "Cannot create a NULL EA name.",%@NL@%
                                   NULL, 0, MB_OK);%@NL@%
                     return 0L;%@NL@%
                  }%@NL@%
%@NL@%
                  if(EAExists(szEAName))   %@AB@%/* Don't allow duplicate EA Name */%@AE@%%@NL@%
                  {%@NL@%
                     WinAlarm(HWND_DESKTOP,WA_ERROR);%@NL@%
                     WinMessageBox(HWND_DESKTOP, hwnd,%@NL@%
                          "EA name already exists.  Can't create that name.",%@NL@%
                          NULL, 0, MB_OK);%@NL@%
                     return 0L;%@NL@%
                  }%@NL@%
               }%@NL@%
               usRetEAType = SHORT1FROMMR( WinSendDlgItemMsg(hwnd, EA_ASCIIZ,%@NL@%
                                                   BM_QUERYCHECKINDEX, 0L, 0L));%@NL@%
               WinDismissDlg(hwnd, TRUE);%@NL@%
               return 0L;%@NL@%
%@NL@%
            case DID_CANCEL:%@NL@%
               WinDismissDlg(hwnd, FALSE);%@NL@%
               return 0L;%@NL@%
         }%@NL@%
         break;%@NL@%
   }%@NL@%
   return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: AddEAProc()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd, msg, mp1, mp2.  Standard PM Dialog Proc params.%@NL@%
%@AB@% *              The user pointer passes in a PassData struct.  The Point%@NL@%
%@AB@% *              member points to the default EA Name and the usIndex%@NL@%
%@AB@% *              member determines whether or not the user can modify the%@NL@%
%@AB@% *              EA Name.  The fFlag member determines the status of the%@NL@%
%@AB@% *              Need/nice bit.  TRUE indicates the Need bit is set.  The%@NL@%
%@AB@% *              default Value is passed in global szAscii.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Exits with WinDismissDlg set to TRUE if the user selects OK,%@NL@%
%@AB@% *          FALSE if the user selects CANCEL.  Global szEAName contains the%@NL@%
%@AB@% *          modified EA Value.  the fFlag member of the passed in data will%@NL@%
%@AB@% *          be updated to reflect the current state of the Need bit.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This proc handles the editing of EA Names and their associated%@NL@%
%@AB@% *          ASCII strings.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: A PassData struct must be passed in when called.%@NL@%
%@AB@% *                 Note that the Value buffer is dynamically allocated and%@NL@%
%@AB@% *                 it is the responsibility of the calling procedure to%@NL@%
%@AB@% *                 deallocate the buffer (szScratch) when finished with it.%@NL@%
%@AB@% *                 Note also that memory allocations are NOT fully error%@NL@%
%@AB@% *                 trapped.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  EAExists()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY AsciiEditProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
   static PASSDATA FAR *pPDat;%@NL@%
%@NL@%
   switch(msg)%@NL@%
   {%@NL@%
      case WM_INITDLG:%@NL@%
         WinSendDlgItemMsg(hwnd, IDD_EANAME,EM_SETTEXTLIMIT,%@NL@%
                                 MPFROM2SHORT(MAXEANAME,0),NULL);%@NL@%
         WinSendDlgItemMsg(hwnd, IDD_EAVALUE,EM_SETTEXTLIMIT,%@NL@%
                                 MPFROM2SHORT(MAXEAVALUE,0),NULL);%@NL@%
         pPDat=PVOIDFROMMP(mp2);%@NL@%
%@NL@%
         WinSetDlgItemText(hwnd, IDD_EANAME,pPDat->Point);%@NL@%
         WinSetDlgItemText(hwnd, IDD_EATYPE,ConvTable[usRetEAType].szFormat);%@NL@%
         WinSendDlgItemMsg(hwnd, IDD_NEEDBIT, BM_SETCHECK,%@NL@%
                           MPFROM2SHORT(pPDat->fFlag,0),NULL);%@NL@%
%@NL@%
         if(szAscii)   %@AB@%/* Set default EA Value if global var is != NULL */%@AE@%%@NL@%
            WinSetDlgItemText(hwnd, IDD_EAVALUE,szAscii);%@NL@%
%@NL@%
         if(pPDat->usIndex) %@AB@%/* Disable EANAME if passed in a non-zero value */%@AE@%%@NL@%
         {%@NL@%
            WinEnableWindow(WinWindowFromID(hwnd,IDD_EANAME),FALSE);%@NL@%
            WinEnableWindow(WinWindowFromID(hwnd,IDD_NEEDBIT),FALSE);%@NL@%
            WinSetFocus(HWND_DESKTOP,WinWindowFromID(hwnd,IDD_EAVALUE));%@NL@%
            return (MRESULT) TRUE;       %@AB@%/* We don't want default focus setting */%@AE@%%@NL@%
         }%@NL@%
         return 0L;%@NL@%
%@NL@%
      case WM_COMMAND:%@NL@%
         switch(COMMANDMSG(&msg)->cmd)%@NL@%
         {%@NL@%
            case DID_OK:%@NL@%
               pPDat->fFlag = (BYTE) SHORT1FROMMR( WinSendDlgItemMsg(hwnd, IDD_NEEDBIT,%@NL@%
                                                       BM_QUERYCHECK,%@NL@%
                                                       0L, 0L) );%@NL@%
               WinQueryDlgItemText(hwnd, IDD_EANAME, MAXEANAME+1, szEAName);%@NL@%
%@NL@%
               if(!strlen(szEAName))    %@AB@%/* They nulled out the name */%@AE@%%@NL@%
               {%@NL@%
                  WinAlarm(HWND_DESKTOP,WA_ERROR);%@NL@%
                  WinMessageBox(HWND_DESKTOP, hwnd,%@NL@%
                                "Cannot create a NULL EA name.",%@NL@%
                                NULL, 0, MB_OK);%@NL@%
                  return 0L;%@NL@%
               }%@NL@%
%@NL@%
               GetMem(szScratch,MAXEAVALUE+1);  %@AB@%/* Allocate buffer for value */%@AE@%%@NL@%
               WinQueryDlgItemText(hwnd, IDD_EAVALUE, MAXEAVALUE+1, szScratch);%@NL@%
%@NL@%
               if(!strlen(szScratch))    %@AB@%/* They nulled out the value */%@AE@%%@NL@%
               {%@NL@%
                  FreeMem(szScratch,MAXEAVALUE+1); %@AB@%/* Free the value buffer */%@AE@%%@NL@%
                  WinAlarm(HWND_DESKTOP,WA_ERROR);%@NL@%
                  WinMessageBox(HWND_DESKTOP, hwnd,%@NL@%
                                "An EA can't have a NULL value.",%@NL@%
                                NULL, 0, MB_OK);%@NL@%
                  return 0L;%@NL@%
               }%@NL@%
%@NL@%
               if(stricmp(szEAName,pPDat->Point)) %@AB@%/* changed the EA name */%@AE@%%@NL@%
               {%@NL@%
                  if(EAExists(szEAName))  %@AB@%/* Can't have duplicate EA names */%@AE@%%@NL@%
                  {%@NL@%
                     WinAlarm(HWND_DESKTOP,WA_ERROR);%@NL@%
                     WinMessageBox(HWND_DESKTOP, hwnd,%@NL@%
                            "EA name already exists.  Can't create that name.",%@NL@%
                            NULL, 0, MB_OK);%@NL@%
%@NL@%
                     FreeMem(szScratch,MAXEAVALUE+1);  %@AB@%/* Free value buffer */%@AE@%%@NL@%
                     return 0L;%@NL@%
                  }%@NL@%
               }%@NL@%
%@NL@%
               ResizeMem(szScratch,MAXEAVALUE+1,%@AB@%/* Resize buf to actual size */%@AE@%%@NL@%
                         strlen(szScratch)+1);%@NL@%
%@NL@%
               WinDismissDlg(hwnd, TRUE);%@NL@%
               return 0L;%@NL@%
%@NL@%
            case DID_CANCEL:%@NL@%
               WinDismissDlg(hwnd, FALSE);%@NL@%
               return 0L;%@NL@%
         }%@NL@%
         break;%@NL@%
   }%@NL@%
   return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: IconDlgProc()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd, msg, mp1, mp2.  Standard PM Dialog Proc params.%@NL@%
%@AB@% *              No user data is expected.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Currently just calls WinDefDlgProc.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This proc is unimplemented, but is intedned to handle displaying%@NL@%
%@AB@% *          and editing icons/bitmaps.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY IconDlgProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
   switch(msg)%@NL@%
   {%@NL@%
      case WM_INITDLG:%@NL@%
         return 0L;%@NL@%
%@NL@%
      case WM_COMMAND:%@NL@%
         switch(COMMANDMSG(&msg)->cmd)%@NL@%
         {%@NL@%
            case DID_OK:%@NL@%
               WinDismissDlg(hwnd, TRUE);%@NL@%
               return 0L;%@NL@%
         }%@NL@%
   }%@NL@%
   return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: MultiTypeProc()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd, msg, mp1, mp2.  Standard PM Dialog Proc params.%@NL@%
%@AB@% *              Expects a user pointer to a PassData structure with Point%@NL@%
%@AB@% *              member pointing to the current pFEA structure.  The Multi%@NL@%
%@AB@% *              member fields of the PassData struct should also be%@NL@%
%@AB@% *              filled in to indicate the location and size of the current%@NL@%
%@AB@% *              m-m field.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Always returns TRUE thru WinDismissDlg when DONE is clicked.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This proc handles the multi-type EA stuff.  Allows the fields%@NL@%
%@AB@% *          in a given m-m to be edited.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  NOTE that this procedure is fully reentrant/recursive%@NL@%
%@AB@% *                  in that it calls EditEAValue() which can call%@NL@%
%@AB@% *                  MultiTypeProc.  Since PassData information is placed%@NL@%
%@AB@% *                  in static variables, the ReEnter structure is used to%@NL@%
%@AB@% *                  hold a dynamic linked list of values passed into the%@NL@%
%@AB@% *                  proc and thus keeps the static data set to the proper%@NL@%
%@AB@% *                  values.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: MultiTypeIndex(), EAValueString(), EditEAValue(), MultiAdd()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY MultiTypeProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
   static HOLDFEA *pFEA;        %@AB@%/* Points to the current EA         */%@AE@%%@NL@%
   static PASSDATA FAR *pPDat;  %@AB@%/* Points to the passed Data struct */%@AE@%%@NL@%
   static REENTER *CurEntry;    %@AB@%/* Points to most recent data frame */%@AE@%%@NL@%
   REENTER *ReEntHold;          %@AB@%/* Temp used to setup the frame     */%@AE@%%@NL@%
   PASSDATA PDat;               %@AB@%/* Used for call to EditEAValue     */%@AE@%%@NL@%
   USHORT *pusPtr,cnt;          %@AB@%/* Utility vars                     */%@AE@%%@NL@%
   SHORT  sOffset;%@NL@%
   CHAR   *pInsert,*pValue,*pDelete;%@NL@%
   CHAR   szCodePage[LENUSHORTBUF];%@NL@%
   BYTE   fNeed;                %@AB@%/* Holds state of need checkbox     */%@AE@%%@NL@%
%@NL@%
   switch(msg)%@NL@%
   {%@NL@%
      case WM_INITDLG:%@NL@%
         pPDat = PVOIDFROMMP(mp2);             %@AB@%/* Set up static vars        */%@AE@%%@NL@%
         pFEA  = (HOLDFEA *) pPDat->Point;%@NL@%
%@NL@%
         GetMem(ReEntHold,sizeof(REENTER));    %@AB@%/* Allows for recusive calls */%@AE@%%@NL@%
         ReEntHold->pPDat = pPDat;%@NL@%
         ReEntHold->pFEA  = pFEA;%@NL@%
         ReEntHold->next  = CurEntry;%@NL@%
         CurEntry = ReEntHold;%@NL@%
%@NL@%
         WinSendDlgItemMsg(hwnd, IDD_NEEDBIT, BM_SETCHECK, %@AB@%/* Need bit setup */%@AE@%%@NL@%
                           MPFROM2SHORT((pFEA->fEA&0x80)? TRUE : FALSE,0),%@NL@%
                           NULL);%@NL@%
%@NL@%
         WinSetDlgItemText(hwnd,IDD_EATYPE,"");  %@AB@%/* Setup the codepage */%@AE@%%@NL@%
         WinSetDlgItemText(hwnd,IDD_EANAME,pFEA->szName);%@NL@%
         WinSendDlgItemMsg(hwnd, IDD_CODEPAGE,EM_SETTEXTLIMIT,%@NL@%
                                 MPFROM2SHORT(LENUSHORTBUF-1,0),NULL);%@NL@%
%@NL@%
         pusPtr= (USHORT *) ((CHAR *) pFEA->aValue+pPDat->usMultiOffset);%@NL@%
         pusPtr++;       %@AB@%/* Skip the EA_Type field and point to codepage */%@AE@%%@NL@%
         sprintf(szCodePage,"%u",*pusPtr);%@NL@%
         WinSetDlgItemText(hwnd, IDD_CODEPAGE,szCodePage);%@NL@%
%@NL@%
         pusPtr++;      %@AB@%/* Skip codepage and point to the field count */%@AE@%%@NL@%
%@NL@%
         for(cnt=0;cnt< *pusPtr;cnt++) %@AB@%/* Add each field to the L-Box */%@AE@%%@NL@%
         {%@NL@%
            pInsert = MultiTypeIndex(pFEA->aValue+pPDat->usMultiOffset,cnt);%@NL@%
            pValue = EAValueString(hwnd,pInsert); %@AB@%/* Ptr to asciiz string */%@AE@%%@NL@%
%@NL@%
            WinSendDlgItemMsg(hwnd, IDD_LBOX, LM_INSERTITEM,%@NL@%
                              MPFROM2SHORT(LIT_END,0),%@NL@%
                              MPFROMP(pValue));%@NL@%
            FreeMem(pValue,strlen(pValue)+1);  %@AB@%/* Free asciiz string */%@AE@%%@NL@%
         }%@NL@%
         return 0L;%@NL@%
%@NL@%
      case WM_CONTROL:%@NL@%
         switch(SHORT1FROMMP(mp1))%@NL@%
         {%@NL@%
            case IDD_LBOX:%@NL@%
               switch(SHORT2FROMMP(mp1))%@NL@%
               {%@NL@%
                  case LN_SELECT:   %@AB@%/* Display proper EA type for selection */%@AE@%%@NL@%
                     sOffset = SHORT1FROMMR( WinSendDlgItemMsg(hwnd, IDD_LBOX,%@NL@%
                                                       LM_QUERYSELECTION,0,0));%@NL@%
                     if(sOffset<0)%@NL@%
                        break;%@NL@%
%@NL@%
                     pValue = MultiTypeIndex(pFEA->aValue+pPDat->usMultiOffset,%@NL@%
                                             sOffset);%@NL@%
                     pusPtr = (USHORT *) pValue;%@NL@%
%@NL@%
                     WinSetDlgItemText(hwnd,IDD_EATYPE,%@NL@%
                                ConvTable[LookupEAType(*pusPtr)].szFormat);%@NL@%
                     break;%@NL@%
%@NL@%
                  case LN_ENTER:  %@AB@%/* Setup and edit a m-m field */%@AE@%%@NL@%
                     sOffset = SHORT1FROMMR( WinSendDlgItemMsg(hwnd, IDD_LBOX,%@NL@%
                                                       LM_QUERYSELECTION,0,0));%@NL@%
                     if(sOffset<0)%@NL@%
                        return 0L;%@NL@%
%@NL@%
                     PDat.Point         = (CHAR *) pFEA; %@AB@%/* Pass curr data */%@AE@%%@NL@%
                     PDat.cbMulti       = pPDat->cbMulti;%@NL@%
                     PDat.usMultiOffset = pPDat->usMultiOffset;%@NL@%
                     PDat.usIndex       = (USHORT) sOffset;%@NL@%
%@NL@%
                     if(EditEAValue(hwnd,&PDat)) %@AB@%/* They didn't cancel */%@AE@%%@NL@%
                     {%@NL@%
                        pInsert=MultiTypeIndex(pFEA->aValue%@NL@%
                                                + pPDat->usMultiOffset,%@NL@%
                                               sOffset);%@NL@%
                        pValue =EAValueString(hwnd,pInsert);%@NL@%
%@NL@%
                        WinSendDlgItemMsg(hwnd, IDD_LBOX, LM_SETITEMTEXT,%@NL@%
                                          MPFROMSHORT(sOffset),%@NL@%
                                          MPFROMP(pValue));%@NL@%
                        FreeMem(pValue,strlen(pValue)+1); %@AB@%/* Free asciiz str */%@AE@%%@NL@%
                     }%@NL@%
                     return 0L;%@NL@%
               }%@NL@%
         }%@NL@%
%@NL@%
      case WM_COMMAND:%@NL@%
         switch(COMMANDMSG(&msg)->cmd)%@NL@%
         {%@NL@%
            case IDD_ADD:                  %@AB@%/* Add an item for a m-m */%@AE@%%@NL@%
               MultiAdd(hwnd, pFEA,pPDat);%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDD_EDIT:  %@AB@%/* Setup and edit a m-m field */%@AE@%%@NL@%
               sOffset = SHORT1FROMMR( WinSendDlgItemMsg(hwnd, IDD_LBOX,%@NL@%
                                                   LM_QUERYSELECTION,0,0));%@NL@%
               if(sOffset<0)%@NL@%
                  return 0L;%@NL@%
%@NL@%
               PDat.Point         = (CHAR *) pFEA; %@AB@%/* Pass curr data */%@AE@%%@NL@%
               PDat.cbMulti       = pPDat->cbMulti;%@NL@%
               PDat.usMultiOffset = pPDat->usMultiOffset;%@NL@%
               PDat.usIndex       = (USHORT) sOffset;%@NL@%
%@NL@%
               if(EditEAValue(hwnd,&PDat)) %@AB@%/* They didn't cancel */%@AE@%%@NL@%
               {%@NL@%
                  pInsert=MultiTypeIndex(pFEA->aValue + pPDat->usMultiOffset,%@NL@%
                                         sOffset);%@NL@%
                  pValue =EAValueString(hwnd,pInsert);%@NL@%
%@NL@%
                  WinSendDlgItemMsg(hwnd, IDD_LBOX, LM_SETITEMTEXT,%@NL@%
                                    MPFROMSHORT(sOffset),%@NL@%
                                    MPFROMP(pValue));%@NL@%
                  FreeMem(pValue,strlen(pValue)+1); %@AB@%/* Free asciiz str */%@AE@%%@NL@%
               }%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDD_DELETE:               %@AB@%/* Delete hi-lited item  */%@AE@%%@NL@%
               sOffset = SHORT1FROMMR( WinSendDlgItemMsg(hwnd, IDD_LBOX,%@NL@%
                                                    LM_QUERYSELECTION,0,0));%@NL@%
               if(sOffset<0)   %@AB@%/* No item is currently selected */%@AE@%%@NL@%
                  return 0L;%@NL@%
%@NL@%
               WinSendDlgItemMsg(hwnd, IDD_LBOX, LM_DELETEITEM,%@NL@%
                                 MPFROMSHORT(sOffset),0L);%@NL@%
%@NL@%
               %@AB@%/* Get pointers to start of selected field and the following%@NL@%
%@AB@%                  field, then move the rest of the EA back, resize the%@NL@%
%@AB@%                  buffer, and change the EA Value counter                  */%@AE@%%@NL@%
%@NL@%
               pDelete = MultiTypeIndex(pFEA->aValue+pPDat->usMultiOffset,%@NL@%
                                        sOffset);%@NL@%
               pValue  = MultiTypeIndex(pFEA->aValue+pPDat->usMultiOffset,%@NL@%
                                        sOffset+1);%@NL@%
               memmove(pDelete,pValue,pFEA->cbValue-(pValue-pFEA->aValue));%@NL@%
               ResizeMem(pFEA->aValue,pFEA->cbValue,%@NL@%
                         pFEA->cbValue-(pValue-pDelete));%@NL@%
               pFEA->cbValue -= pValue-pDelete;%@NL@%
%@NL@%
               %@AB@%/* Decrement the field count in the m-m */%@AE@%%@NL@%
               pusPtr  = (USHORT *) ((CHAR *) pFEA->aValue +%@NL@%
                                              pPDat->usMultiOffset);%@NL@%
               pusPtr+=2;         %@AB@%/* Point to the field count */%@AE@%%@NL@%
               *pusPtr -= 1;      %@AB@%/* Decrement the field cnt  */%@AE@%%@NL@%
%@NL@%
               FILE_CHANGED = TRUE;%@NL@%
               return 0L;%@NL@%
%@NL@%
            case DID_DONE:%@NL@%
               %@AB@%/* Handle the possible change of the need checkbox */%@AE@%%@NL@%
               fNeed = (BYTE) SHORT1FROMMR(WinSendDlgItemMsg(hwnd, IDD_NEEDBIT,%@NL@%
                                                BM_QUERYCHECK,%@NL@%
                                                0L, 0L));%@NL@%
               if(fNeed)%@NL@%
                  fNeed = 0x80;%@NL@%
               if(fNeed != (pFEA->fEA & (BYTE) 0x80)) %@AB@%/* Need changed */%@AE@%%@NL@%
               {%@NL@%
                  pFEA->fEA = (pFEA->fEA & (BYTE) 0x7F) | fNeed;%@NL@%
                  FILE_CHANGED = TRUE;%@NL@%
               }%@NL@%
%@NL@%
               %@AB@%/* Handle the possible change of the codepage */%@AE@%%@NL@%
               WinQueryDlgItemText(hwnd, IDD_CODEPAGE,%@NL@%
                                   LENUSHORTBUF, szCodePage);%@NL@%
               sscanf(szCodePage,"%u",&cnt);%@NL@%
               pusPtr= (USHORT *) ((CHAR *) pFEA->aValue+pPDat->usMultiOffset);%@NL@%
               pusPtr++;    %@AB@%/* Skip the EA_Type field and point to codepage */%@AE@%%@NL@%
               if(*pusPtr != cnt) %@AB@%/* They changed the codepage value */%@AE@%%@NL@%
               {%@NL@%
                  *pusPtr = cnt;%@NL@%
                  FILE_CHANGED = TRUE;%@NL@%
               }%@NL@%
%@NL@%
               ReEntHold = CurEntry->next;       %@AB@%/* Finish recursion safety */%@AE@%%@NL@%
               FreeMem(CurEntry,sizeof(REENTER));%@NL@%
               CurEntry = ReEntHold;%@NL@%
               if(CurEntry)%@NL@%
               {%@NL@%
                  pPDat = CurEntry->pPDat;%@NL@%
                  pFEA  = CurEntry->pFEA;%@NL@%
               }%@NL@%
               WinDismissDlg(hwnd, TRUE);%@NL@%
               return 0L;%@NL@%
         }%@NL@%
   }%@NL@%
   return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: ShowEAType()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd which is the current window handle.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine handles the display of the current EA type by%@NL@%
%@AB@% *          setting the text in the appropriate dialog field.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Routine should be bullet proof as it does its own%@NL@%
%@AB@% *                  error checking.  It assumes that hwnd points to the%@NL@%
%@AB@% *                  correct window with the name listbox in it.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: GetCurFEA(), LookupEAType()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID ShowEAType(HWND hwnd)%@NL@%
{%@NL@%
   USHORT usEAType;         %@AB@%/* Holds the offset of EAType into ConvTable */%@AE@%%@NL@%
   HOLDFEA *pFEA;%@NL@%
%@NL@%
   pFEA = GetCurFEA(hwnd,pHoldFEA); %@AB@%/* Points to the selected EA */%@AE@%%@NL@%
   if(!pFEA)                        %@AB@%/* Kill line if nothing is selected */%@AE@%%@NL@%
   {%@NL@%
      WinSetDlgItemText(hwnd,IDD_EATYPE,"");%@NL@%
      return;%@NL@%
   }%@NL@%
   usEAType = LookupEAType((USHORT) *pFEA->aValue);%@NL@%
%@NL@%
   WinSetDlgItemText(hwnd,IDD_EATYPE,ConvTable[usEAType].szFormat);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: EditEA()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd which is the current window handle.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: TRUE iff the edit was successful.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine handles the editing of an EA when it is selected%@NL@%
%@AB@% *          from the listbox.  It get the item selected, sets up the PassData%@NL@%
%@AB@% *          structure then calls EditEAValue to do the actual edit.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Routine should be bullet proof as it does its own%@NL@%
%@AB@% *                  error checking.  It assumes that hwnd points to the%@NL@%
%@AB@% *                  correct window with the name listbox in it.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: EditEAValue()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
BOOL EditEA(HWND hwnd)%@NL@%
{%@NL@%
   HOLDFEA *pFEA=pHoldFEA;  %@AB@%/* Pointer for selected EA */%@AE@%%@NL@%
   LONG offset,lCnt;        %@AB@%/* Both used to reference offset of selected EA */%@AE@%%@NL@%
   PASSDATA PData;%@NL@%
%@NL@%
   if(!FILE_ISOPEN)%@NL@%
      return(FALSE);%@NL@%
%@NL@%
   offset = lCnt = (LONG) WinSendDlgItemMsg(hwnd, IDD_LBOX,%@NL@%
                                            LM_QUERYSELECTION,0,0);%@NL@%
%@NL@%
   if(offset<0)        %@AB@%/* Nothing was selected */%@AE@%%@NL@%
      return(FALSE);%@NL@%
%@NL@%
   while(lCnt--)         %@AB@%/* Get to the right EA */%@AE@%%@NL@%
      pFEA = pFEA->next;%@NL@%
%@NL@%
   PData.Point         = (CHAR *) pFEA;        %@AB@%/* Set the pass data struct */%@AE@%%@NL@%
   PData.usMultiOffset = 0;%@NL@%
   PData.cbMulti       = 0;%@NL@%
%@NL@%
   if(EditEAValue(hwnd,&PData))  %@AB@%/* It worked */%@AE@%%@NL@%
   {%@NL@%
      WinSendDlgItemMsg(hwnd, IDD_LBOX,LM_SETITEMTEXT,%@NL@%
                        MPFROMSHORT((SHORT) offset),MPFROMP(pFEA->szName));%@NL@%
      return(TRUE);%@NL@%
   }%@NL@%
   return(FALSE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/* This routine returns a pointer to the EA currently highlighted in the%@NL@%
%@AB@%   list box. */%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: GetCurFEA()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd which is the current window handle.%@NL@%
%@AB@% *              pFEA which points to the base FEA in the linked list.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: The current EA as determined by querying the l-box selector,%@NL@%
%@AB@% *          returns NULL if there is an error or nothing is selected.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine returns a pointer to the EA currently highlighted%@NL@%
%@AB@% *          in the list box.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Routine should be bullet proof as it does its own%@NL@%
%@AB@% *                  error checking.  It assumes that hwnd points to the%@NL@%
%@AB@% *                  correct window with the name listbox in it.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: EditEAValue()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
HOLDFEA *GetCurFEA(HWND hwnd, HOLDFEA *pFEA)%@NL@%
{%@NL@%
   LONG lOffset;%@NL@%
%@NL@%
   lOffset = (LONG) WinSendDlgItemMsg(hwnd, IDD_LBOX,%@NL@%
                                      LM_QUERYSELECTION,0,0);%@NL@%
%@NL@%
   if(lOffset<0)      %@AB@%/* Nothing is highlighted */%@AE@%%@NL@%
      return(NULL);%@NL@%
%@NL@%
   while(lOffset--)%@NL@%
   {%@NL@%
      pFEA = pFEA->next;%@NL@%
   }%@NL@%
%@NL@%
   return(pFEA);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%NEADEA.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\NEAD\NEADEA.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@% This module contains subroutines for nead.c that specifically%@NL@%
%@AB@% deal with the manipulation of EAs.%@NL@%
%@AB@%%@NL@%
%@AB@% Procedures in this file:%@NL@%
%@AB@%   AddEA()             Handles the Add button press%@NL@%
%@AB@%   QueryEAs()          Reads in all the EAs associated with a file%@NL@%
%@AB@%   CheckEAIntegrity()  Checks an EA buffer to see if it is valid%@NL@%
%@AB@%   Free_FEAList()      Deallocates memory associated with EA list%@NL@%
%@AB@%   LookupEAType()      Gets an offset into table for an EA type%@NL@%
%@AB@%   DeleteCurEA()       Deletes the highlighted EA%@NL@%
%@AB@%   CurEAType()         Returns EA Type given a HoldFEA ptr%@NL@%
%@AB@%   GetUSHORT()         Returns nth USHORT in ->aValue%@NL@%
%@AB@%   WriteEAs()          Updates EAs state on the disk%@NL@%
%@AB@%   EditEAValues()      Handles editing a given EA (also m-m EAs)%@NL@%
%@AB@%   EAExists()          Determines if the given EA Name exists%@NL@%
%@AB@%   ChangeName()        Handles the change of an EA's name%@NL@%
%@AB@%   MultiTypeIndex()    Gets a specific field in a m-m structure%@NL@%
%@AB@%   EAValueString()     Returns a representational string for an EA%@NL@%
%@AB@%   MultiAdd()          Handles addition of a field for m-m%@NL@%
%@AB@%%@NL@%
%@AB@%**************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"nead.h" %@NL@%
%@NL@%
%@AB@%/************ External GLOBALS *******************************/%@AE@%%@NL@%
%@NL@%
extern CHAR szFileName[CCHMAXPATH];%@NL@%
extern CHAR szEAName[MAXEANAME+1];%@NL@%
extern USHORT usRetEAType;%@NL@%
extern BOOL FILE_ISOPEN;%@NL@%
extern BOOL FILE_CHANGED;%@NL@%
extern BOOL COMMAND_LINE_FILE;%@NL@%
extern HHEAP hhp;%@NL@%
extern CHAR *pAlloc,*szEditBuf,*szAscii,*szScratch;%@NL@%
extern HOLDFEA *pHoldFEA;%@NL@%
extern DELETELIST *pDelList;%@NL@%
extern EADATA ConvTable[EATABLESIZE];%@NL@%
%@NL@%
%@AB@%/*************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: AddEA()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd which is the current window handle.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: TRUE iff the EA is successfully added.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine handles the addition of a new EA to the linked list.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Routine does NOT do full memory error trapping and the%@NL@%
%@AB@% *                  insert message to the l-box is not error checked.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: EditEAValue()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
BOOL AddEA(HWND hwnd)%@NL@%
{%@NL@%
   HOLDFEA  *pFEA=pHoldFEA;  %@AB@%/* Points to the beginning of the EA list */%@AE@%%@NL@%
   HOLDFEA  *pNewFEA;        %@AB@%/* Used to temporarily hold the new EA    */%@AE@%%@NL@%
   PASSDATA PData;%@NL@%
%@NL@%
   if(!FILE_ISOPEN)%@NL@%
      return(FALSE);%@NL@%
%@NL@%
   if(!WinDlgBox(HWND_DESKTOP,         %@AB@%/* get new EA name and type */%@AE@%%@NL@%
                 hwnd,%@NL@%
                 AddEAProc,%@NL@%
                 (HMODULE)NULL,%@NL@%
                 IDD_ADDEA,%@NL@%
                 NULL))%@NL@%
      return(FALSE);                   %@AB@%/* they said cancel */%@AE@%%@NL@%
%@NL@%
   GetMem(pNewFEA, sizeof(HOLDFEA));   %@AB@%/* Allocate space for new EA struct */%@AE@%%@NL@%
%@NL@%
   pNewFEA->cbName = (CHAR) strlen(szEAName);  %@AB@%/* Fill in new structure */%@AE@%%@NL@%
   pNewFEA->cbValue= 0;%@NL@%
   pNewFEA->fEA    = 0; %@AB@%/* Need bit NOT set */%@AE@%%@NL@%
%@NL@%
   GetMem(pNewFEA->szName,pNewFEA->cbName+1);  %@AB@%/* Name returned in szEAName */%@AE@%%@NL@%
   strcpy(pNewFEA->szName,strupr(szEAName));%@NL@%
   pNewFEA->aValue = NULL;%@NL@%
   pNewFEA->next   = NULL;%@NL@%
%@NL@%
   if(pHoldFEA == NULL)           %@AB@%/* It's the first EA for the file */%@AE@%%@NL@%
   {%@NL@%
      pHoldFEA = pNewFEA;%@NL@%
   }%@NL@%
   else                           %@AB@%/* Add EA to the end of the linked list */%@AE@%%@NL@%
   {%@NL@%
      while(pFEA->next)%@NL@%
         pFEA = pFEA->next;%@NL@%
      pFEA->next = pNewFEA;%@NL@%
   }%@NL@%
   PData.Point         = (CHAR *) pNewFEA;  %@AB@%/* Setup user data for call */%@AE@%%@NL@%
   PData.cbMulti       = 0;                 %@AB@%/* to edit of the name and  */%@AE@%%@NL@%
   PData.usMultiOffset = 0;                 %@AB@%/* EA Value                 */%@AE@%%@NL@%
%@NL@%
   if(!EditEAValue(hwnd,&PData)) %@AB@%/* They canceled the edit */%@AE@%%@NL@%
   {%@NL@%
      if(pFEA)               %@AB@%/* It's not the only EA          */%@AE@%%@NL@%
         pFEA->next = NULL;  %@AB@%/* Disconnect the partial new EA */%@AE@%%@NL@%
      else%@NL@%
         pHoldFEA = NULL;    %@AB@%/* The new EA was the first one  */%@AE@%%@NL@%
%@NL@%
      FreeMem(pNewFEA->szName,pNewFEA->cbName+1);%@NL@%
      FreeMem(pNewFEA,sizeof(HOLDFEA));%@NL@%
%@NL@%
      return(FALSE);%@NL@%
   }%@NL@%
%@NL@%
   WinSendDlgItemMsg(hwnd, IDD_LBOX, LM_INSERTITEM, %@AB@%/* Insert name in L-Box */%@AE@%%@NL@%
                     MPFROM2SHORT(LIT_END,0),%@NL@%
                     MPFROMP(pNewFEA->szName));%@NL@%
%@NL@%
   return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: QueryEAs()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd which is the current window handle.%@NL@%
%@AB@% *              pszPath points to the path of the file to grab EAs from.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: TRUE iff it successfully reads in the EAs.  Upon exit, global%@NL@%
%@AB@% *          pHoldFEA points to a linked list of the EAs for the current file.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Call DOS to Query a file's EA names and values.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Routine does NOT do full memory error trapping.%@NL@%
%@AB@% *                  NOTE:  This routine does NOT prevent other processes%@NL@%
%@AB@% *                  from accessing the file's EAs while it is reading them%@NL@%
%@AB@% *                  in, or while the program is editing them.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: Free_FEAList(), CheckEAIntegrity()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
BOOL QueryEAs(HWND hwnd,CHAR *pszPath)%@NL@%
{%@NL@%
   CHAR *pAlloc;       %@AB@%/* Holds the FEA struct returned by DosEnumAttribute */%@AE@%%@NL@%
                       %@AB@%/* also used to create the GEALIST for DosQPathInfo  */%@AE@%%@NL@%
   CHAR *pBigAlloc;    %@AB@%/* Temp buffer to hold each EA as it is read in      */%@AE@%%@NL@%
   USHORT cbBigAlloc;  %@AB@%/* Size of buffer                                    */%@AE@%%@NL@%
%@NL@%
   ULONG ulEntryNum = 1; %@AB@%/* count of current EA to read (1-relative)        */%@AE@%%@NL@%
   ULONG ulEnumCnt;      %@AB@%/* Number of EAs for Enum to return, always 1      */%@AE@%%@NL@%
%@NL@%
   HOLDFEA *pLastIn;     %@AB@%/* Points to last EA added, so new EA can link     */%@AE@%%@NL@%
   HOLDFEA *pNewFEA;     %@AB@%/* Struct to build the new EA in                   */%@AE@%%@NL@%
%@NL@%
   FEA *pFEA;            %@AB@%/* Used to read from Enum's return buffer          */%@AE@%%@NL@%
   GEALIST *pGEAList;    %@AB@%/* Ptr used to set up buffer for DosQPathInfo call */%@AE@%%@NL@%
   EAOP eaopGet;         %@AB@%/* Used to call DosQPathInfo                       */%@AE@%%@NL@%
%@NL@%
   GetMem((HHEAP) pAlloc,(USHORT) MAX_GEA);     %@AB@%/* Allocate enough room for any GEA List     */%@AE@%%@NL@%
   pFEA = (FEA *) pAlloc;      %@AB@%/* pFEA always uses pAlloc buffer            */%@AE@%%@NL@%
%@NL@%
   pHoldFEA = NULL;            %@AB@%/* Reset the pointer for the EA linked list  */%@AE@%%@NL@%
%@NL@%
   while(TRUE) %@AB@%/* Loop continues until there are no more EAs */%@AE@%%@NL@%
   {%@NL@%
      ulEnumCnt = 1;                 %@AB@%/* Only want to get one EA at a time */%@AE@%%@NL@%
      if(DosEnumAttribute(Ref_ASCIIZ,          %@AB@%/* Read into pAlloc Buffer */%@AE@%%@NL@%
                          pszPath,             %@AB@%/* Note that this does not */%@AE@%%@NL@%
                          ulEntryNum,          %@AB@%/* get the aValue field,   */%@AE@%%@NL@%
                          pAlloc,              %@AB@%/* so DosQPathInfo must be */%@AE@%%@NL@%
                          MAX_GEA,             %@AB@%/* called to get it.       */%@AE@%%@NL@%
                          &ulEnumCnt,%@NL@%
                          (LONG) GetInfoLevel1,%@NL@%
                          0L))%@NL@%
        break;                         %@AB@%/* There was some sort of error    */%@AE@%%@NL@%
%@NL@%
      if(ulEnumCnt != 1)               %@AB@%/* All the EAs have been read      */%@AE@%%@NL@%
         break;%@NL@%
%@NL@%
      ulEntryNum++;%@NL@%
%@NL@%
      GetMem(pNewFEA,sizeof(HOLDFEA));%@NL@%
%@NL@%
      if (pNewFEA == NULL)             %@AB@%/* Out of memory */%@AE@%%@NL@%
      {%@NL@%
         FreeMem(pAlloc,MAX_GEA);%@NL@%
         Free_FEAList(pHoldFEA,pDelList);%@NL@%
         return (FALSE);%@NL@%
      }%@NL@%
%@NL@%
      pNewFEA->cbName = pFEA->cbName;  %@AB@%/* Fill in the HoldFEA structure   */%@AE@%%@NL@%
      pNewFEA->cbValue= pFEA->cbValue;%@NL@%
      pNewFEA->fEA    = pFEA->fEA;%@NL@%
      pNewFEA->next = NULL;%@NL@%
%@NL@%
      GetMem(pNewFEA->szName,pFEA->cbName +1); %@AB@%/* Allocate for 2 arrays   */%@AE@%%@NL@%
      GetMem(pNewFEA->aValue,pFEA->cbValue);%@NL@%
%@NL@%
      if (!pNewFEA->szName || !pNewFEA->aValue) %@AB@%/* Out of memory */%@AE@%%@NL@%
      {%@NL@%
         if(pNewFEA->szName)%@NL@%
            FreeMem(pNewFEA->szName,pFEA->cbName+1);%@NL@%
         if(pNewFEA->aValue)%@NL@%
            FreeMem(pNewFEA->aValue,pFEA->cbValue);%@NL@%
%@NL@%
         FreeMem(pAlloc, MAX_GEA);%@NL@%
         FreeMem(pNewFEA,sizeof(HOLDFEA));%@NL@%
%@NL@%
         Free_FEAList(pHoldFEA,pDelList);%@NL@%
         return (FALSE);%@NL@%
      }%@NL@%
      strcpy(pNewFEA->szName,pAlloc+sizeof(FEA));      %@AB@%/* Copy in EA Name */%@AE@%%@NL@%
%@NL@%
      cbBigAlloc = sizeof(FEALIST) + pNewFEA->cbName+1 + pNewFEA->cbValue;%@NL@%
      GetMem(pBigAlloc,cbBigAlloc);%@NL@%
      if (pBigAlloc == NULL)%@NL@%
      {%@NL@%
         FreeMem(pNewFEA->szName,pFEA->cbName+1);%@NL@%
         FreeMem(pNewFEA->aValue,pFEA->cbValue);%@NL@%
         FreeMem(pAlloc, MAX_GEA);%@NL@%
         FreeMem(pNewFEA,sizeof(HOLDFEA));%@NL@%
         Free_FEAList(pHoldFEA,pDelList);%@NL@%
         return (FALSE);%@NL@%
      }%@NL@%
%@NL@%
      pGEAList = (GEALIST *) pAlloc;   %@AB@%/* Set up GEAList structure */%@AE@%%@NL@%
%@NL@%
      pGEAList->cbList = sizeof(GEALIST) + pNewFEA->cbName; %@AB@%/* +1 for NULL */%@AE@%%@NL@%
      pGEAList->list[0].cbName = pNewFEA->cbName;%@NL@%
      strcpy(pGEAList->list[0].szName,pNewFEA->szName);%@NL@%
%@NL@%
      eaopGet.fpGEAList = (GEALIST far *) pAlloc;%@NL@%
      eaopGet.fpFEAList = (FEALIST far *) pBigAlloc;%@NL@%
%@NL@%
      eaopGet.fpFEAList->cbList = cbBigAlloc;%@NL@%
%@NL@%
      DosQPathInfo(pszPath,            %@AB@%/* Get the complete EA info        */%@AE@%%@NL@%
                   GetInfoLevel3,%@NL@%
                   (PVOID) &eaopGet,%@NL@%
                   sizeof(EAOP),%@NL@%
                   0L);%@NL@%
      memcpy(pNewFEA->aValue,          %@AB@%/* Copy the value to HoldFEA       */%@AE@%%@NL@%
             pBigAlloc+sizeof(FEALIST)+pNewFEA->cbName+1,%@NL@%
             pNewFEA->cbValue);%@NL@%
%@NL@%
      FreeMem(pBigAlloc,cbBigAlloc);   %@AB@%/* Release the temp Enum buffer    */%@AE@%%@NL@%
%@NL@%
      if(!CheckEAIntegrity(pNewFEA->aValue,pNewFEA->cbValue)) %@AB@%/* Bad EA   */%@AE@%%@NL@%
      {%@NL@%
         FreeMem(pNewFEA->szName,pFEA->cbName+1);%@NL@%
         FreeMem(pNewFEA->aValue,pFEA->cbValue);%@NL@%
         FreeMem(pNewFEA,sizeof(HOLDFEA));%@NL@%
         continue;                    %@AB@%/* Don't add this EA to linked list */%@AE@%%@NL@%
      }%@NL@%
%@NL@%
      if(pHoldFEA == NULL)             %@AB@%/* If first EA, set pHoldFEA       */%@AE@%%@NL@%
         pHoldFEA = pNewFEA;%@NL@%
      else                             %@AB@%/* Otherwise, add to end of list   */%@AE@%%@NL@%
         pLastIn->next = pNewFEA;%@NL@%
%@NL@%
      pLastIn = pNewFEA;               %@AB@%/* Update the end of the list      */%@AE@%%@NL@%
   }%@NL@%
   FreeMem(pAlloc, MAX_GEA);  %@AB@%/* Free up the GEA buf for DosEnum */%@AE@%%@NL@%
   return (TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: CheckEAIntegrity()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  aBuf points to the buffer to check for a valid EA.%@NL@%
%@AB@% *              cbBuf is the allocated length of aBuf.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: TRUE iff the buffer is a valid EA structure.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine checks the integrity of the passed EA buffer by%@NL@%
%@AB@% *          seeing if there are any non-standard EA types, or bad data that%@NL@%
%@AB@% *          isn't sized correctly.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Routine uses MultiTypeIndex() to check m-m type EAs%@NL@%
%@AB@% *                  since they are potentially recursive.  However, this%@NL@%
%@AB@% *                  may not be a good idea if the m-m EA is severly%@NL@%
%@AB@% *                  corrupted because it may cause MTI() to attempt a read%@NL@%
%@AB@% *                  from protected memory.  Routine does NOT modify the%@NL@%
%@AB@% *                  buffer under any circumstance.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: MultiTypeIndex()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
BOOL CheckEAIntegrity(CHAR *aBuf,USHORT cbBuf)%@NL@%
{%@NL@%
   USHORT *pusPtr = (USHORT *) aBuf;%@NL@%
   USHORT usOffset;%@NL@%
   CHAR   *aEndPtr;%@NL@%
%@NL@%
   usOffset = LookupEAType(*pusPtr);  %@AB@%/* Get the EA type */%@AE@%%@NL@%
%@NL@%
   switch(ConvTable[usOffset].usFldType)%@NL@%
   {%@NL@%
      case IDD_LPDATA:%@NL@%
         pusPtr++;%@NL@%
         if(*pusPtr + 2*sizeof(USHORT) == cbBuf)%@NL@%
            return TRUE;%@NL@%
         else%@NL@%
            return FALSE;%@NL@%
%@NL@%
      case IDD_MULTILIST:%@NL@%
         if(*pusPtr == EA_MVMT)%@NL@%
         {%@NL@%
            pusPtr += 2;%@NL@%
%@NL@%
            %@AB@%/* This checks where the end of the m-m list ends to determine%@NL@%
%@AB@%               the size of the EA.  This is probably not good if the EA is%@NL@%
%@AB@%               badly corrupted and it points to protected memory */%@AE@%%@NL@%
%@NL@%
            aEndPtr = MultiTypeIndex(aBuf,*pusPtr);%@NL@%
            if(aEndPtr - aBuf == (SHORT) cbBuf)%@NL@%
               return TRUE;%@NL@%
            else%@NL@%
               return FALSE;%@NL@%
         }%@NL@%
         else %@AB@%/* Single type, multi-value is not yet implemented */%@AE@%%@NL@%
         {%@NL@%
            return TRUE;%@NL@%
         }%@NL@%
      default:%@NL@%
         return FALSE;%@NL@%
   }%@NL@%
   return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: Free_FEAList()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pFEA points to the beginning of the linked list to be freed.%@NL@%
%@AB@% *              pDList points to the beginning of the deleted linked list.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID.  The two linked lists passed in are cleaned out though.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine frees up the current list of EAs by deallocating%@NL@%
%@AB@% *          the space used by the szName and aValue fields, then deallocating%@NL@%
%@AB@% *          the HoldFEA struct.  Next, it deletes the EAName space, then the%@NL@%
%@AB@% *          DeleteList structure.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Note that NEAD always passes in pHoldFEA and pDelList%@NL@%
%@AB@% *                  which is unnecessary since they are global pointers;%@NL@%
%@AB@% *                  however, this is done to make the routine more flexible%@NL@%
%@AB@% *                  by allowing multiple linked lists to exist.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID Free_FEAList(HOLDFEA *pFEA,DELETELIST *pDList)%@NL@%
{%@NL@%
   HOLDFEA *next;  %@AB@%/* Holds the next field since we free the structure */%@AE@%%@NL@%
                   %@AB@%/* before reading the current next field            */%@AE@%%@NL@%
   DELETELIST *Dnext; %@AB@%/* Same purpose as *next */%@AE@%%@NL@%
%@NL@%
   while(pFEA)%@NL@%
   {%@NL@%
      next = pFEA->next;%@NL@%
      if(pFEA->szName)                         %@AB@%/* Free if non-NULL name  */%@AE@%%@NL@%
         FreeMem(pFEA->szName,pFEA->cbName+1);%@NL@%
      if(pFEA->aValue)                         %@AB@%/* Free if non-NULL value */%@AE@%%@NL@%
         FreeMem(pFEA->aValue,pFEA->cbValue);%@NL@%
%@NL@%
      FreeMem(pFEA,sizeof(HOLDFEA));           %@AB@%/* Free HoldFEA struct    */%@AE@%%@NL@%
      pFEA = next;%@NL@%
   }%@NL@%
%@NL@%
   while(pDList)%@NL@%
   {%@NL@%
      Dnext = pDList->next;%@NL@%
      if(pDList->EAName)%@NL@%
         FreeMem(pDList->EAName,strlen(pDList->EAName)+1);%@NL@%
      FreeMem(pDList,sizeof(DELETELIST));%@NL@%
      pDList = Dnext;%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: LookupEAType()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  usType is tye EA type to be looked up.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: An offset into the ConvTable to the appropriate entry.  If no%@NL@%
%@AB@% *          match is found, the return value points to the last entry,%@NL@%
%@AB@% *          non-conventional format.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine takes EA type and returns an offset into ConvTable%@NL@%
%@AB@% *          which points to an entry that describes the type passed in.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
USHORT LookupEAType(USHORT usType)%@NL@%
{%@NL@%
   USHORT cnt;%@NL@%
%@NL@%
   for(cnt=0;cnt<EATABLESIZE-1;cnt++)%@NL@%
      if(ConvTable[cnt].usPrefix == usType)%@NL@%
         return(cnt);%@NL@%
   return(cnt);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: DeleteCurEA()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd is the current window handle.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID.  Removes one item from global pHoldFEA list and adds one%@NL@%
%@AB@% *          to global pDelList.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine removes in memory the currently highlighted EA from%@NL@%
%@AB@% *          the EA list.  It places the deleted EA in the global pDelList%@NL@%
%@AB@% *          linked list.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  The memory allocation routines are NOT fully error trapped.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: GetCurFEA()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID DeleteCurEA(HWND hwnd)%@NL@%
{%@NL@%
   HOLDFEA *pFEA,*pFEAPrev;%@NL@%
   DELETELIST *pDL,*pDLcnt;  %@AB@%/* Utility ptrs for manipulating the Del list */%@AE@%%@NL@%
   LONG lOffset;%@NL@%
%@NL@%
   pFEA = GetCurFEA(hwnd,pHoldFEA);    %@AB@%/* Gets a pointer to item to delete */%@AE@%%@NL@%
   if (pFEA == NULL)%@NL@%
      return;%@NL@%
%@NL@%
   %@AB@%/* These two allocations should be checked for out of memory */%@AE@%%@NL@%
   GetMem(pDL,sizeof(DELETELIST));     %@AB@%/* Add Name to Delete List */%@AE@%%@NL@%
   GetMem(pDL->EAName,pFEA->cbName+1);%@NL@%
   strcpy(pDL->EAName,pFEA->szName);%@NL@%
   pDL->next = NULL;%@NL@%
%@NL@%
   if(pDelList == NULL)        %@AB@%/* The del list was previously empty  */%@AE@%%@NL@%
      pDelList = pDL;%@NL@%
   else                        %@AB@%/* tack name onto the end of the list */%@AE@%%@NL@%
   {%@NL@%
      pDLcnt = pDelList;%@NL@%
      while(pDLcnt->next)%@NL@%
         pDLcnt = pDLcnt->next;%@NL@%
      pDLcnt->next = pDL;%@NL@%
   }%@NL@%
%@NL@%
   lOffset = (LONG) WinSendDlgItemMsg(hwnd, IDD_LBOX,%@NL@%
                                     LM_QUERYSELECTION,0,0);%@NL@%
   WinSendDlgItemMsg(hwnd, IDD_LBOX,%@NL@%
                     LM_DELETEITEM,MPFROMSHORT((SHORT) lOffset),0L);%@NL@%
%@NL@%
   if(lOffset<1)               %@AB@%/* Remove pFEA from the linked list */%@AE@%%@NL@%
   {%@NL@%
      pHoldFEA = pFEA->next;%@NL@%
   }%@NL@%
   else%@NL@%
   {%@NL@%
      pFEAPrev = pHoldFEA;%@NL@%
%@NL@%
      while(--lOffset)              %@AB@%/* Find previous EA */%@AE@%%@NL@%
         pFEAPrev = pFEAPrev->next;%@NL@%
%@NL@%
      pFEAPrev->next = pFEA->next;%@NL@%
   }%@NL@%
%@NL@%
   FreeMem(pFEA->szName,pFEA->cbName+1);  %@AB@%/* Release the memory */%@AE@%%@NL@%
   FreeMem(pFEA->aValue,pFEA->cbValue);%@NL@%
   FreeMem(pFEA,sizeof(HOLDFEA));%@NL@%
%@NL@%
   FILE_CHANGED = TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: CurEAType()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pFEA points to the FEA struct to use.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: The EA type.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Given an EA structure, this routine returns the Type of the EA%@NL@%
%@AB@% *          which resides in the first USHORT of the aValue member.%@NL@%
%@AB@% *          This function is the same as GetUSHORT(pFEA,0)%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Assumes a valid HoldFEA struct.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
USHORT CurEAType(HOLDFEA *pFEA)   %@AB@%/* Same as GetUSHORT(,0); */%@AE@%%@NL@%
{%@NL@%
   USHORT *pusType;    %@AB@%/* EA Type is stored in first USHORT of aValue field */%@AE@%%@NL@%
%@NL@%
   pusType = (USHORT *) pFEA->aValue;%@NL@%
   return(*pusType);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: GetUSHORT()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pFEA points to the FEA struct to use.%@NL@%
%@AB@% *              index is an offset of the USHORT to be returned%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: The appropriate USHORT from the aValue field%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine returns the nth USHORT value in the aValue member%@NL@%
%@AB@% *          of pFEA using index as the offset.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Assumes a valid HoldFEA struct and that index doesn't%@NL@%
%@AB@% *                  point outside the aValue buffer.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
USHORT GetUSHORT(HOLDFEA *pFEA,USHORT index)%@NL@%
{%@NL@%
   USHORT *pusType;%@NL@%
%@NL@%
   pusType = (USHORT *) pFEA->aValue;%@NL@%
   while(index-- > 0)%@NL@%
      pusType++;%@NL@%
   return(*pusType);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: WriteEAs()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd is the current window handle used only by memory%@NL@%
%@AB@% *              allocation error handling.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID.  But cleans out the pDelList linked list.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine updates the EAs on disk to reflect their current%@NL@%
%@AB@% *          condition in memory.  First, all EAs in the delete list are%@NL@%
%@AB@% *          removed from the disk, then all EAs in the pHoldFEA list are%@NL@%
%@AB@% *          written out to disk.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  NOTE:  This routine is not bulletproof as it does not get%@NL@%
%@AB@% *                  exclusive access to the file EAs, nor does it handle out%@NL@%
%@AB@% *                  of disk space sort of errors. Also, memory fetches are%@NL@%
%@AB@% *                  not fully error trapped.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID WriteEAs(HWND hwnd)%@NL@%
{%@NL@%
   DELETELIST *pDL = pDelList,*pDLnext;%@NL@%
   HOLDFEA    *pHFEA= pHoldFEA;%@NL@%
   EAOP       eaopWrite;%@NL@%
   CHAR       aBuf[MAX_GEA],*aPtr;%@NL@%
   FEA        *pFEA = (FEA *) &aBuf[sizeof(ULONG)];%@NL@%
   USHORT     usRet,usMemNeeded;%@NL@%
   ULONG      *pulPtr=(ULONG *) aBuf; %@AB@%/* Initally points to top of FEALIST */%@AE@%%@NL@%
%@NL@%
   if(!FILE_ISOPEN || !FILE_CHANGED) %@AB@%/* Don't write unless it's necessary */%@AE@%%@NL@%
      return;%@NL@%
%@NL@%
   eaopWrite.fpFEAList = (FEALIST far *) aBuf; %@AB@%/* Setup fields that won't */%@AE@%%@NL@%
   pFEA->fEA     = 0;                          %@AB@%/* change for the delete   */%@AE@%%@NL@%
   pFEA->cbValue = 0;                          %@AB@%/* calls to DosSetPathInfo */%@AE@%%@NL@%
%@NL@%
   while(pDL)                       %@AB@%/* Clean out all the deleted EA names */%@AE@%%@NL@%
   {%@NL@%
      pFEA->cbName = (UCHAR) strlen(pDL->EAName);%@NL@%
      *pulPtr      = sizeof(FEALIST) + pFEA->cbName+1; %@AB@%/* +1 for NULL */%@AE@%%@NL@%
      strcpy(aBuf+sizeof(FEALIST),pDL->EAName);%@NL@%
%@NL@%
      usRet=DosSetPathInfo(szFileName,    %@AB@%/* Delete EA's by saying cbValue=0 */%@AE@%%@NL@%
                           SetInfoLevel2,%@NL@%
                           (PVOID) &eaopWrite,%@NL@%
                           (USHORT) sizeof(EAOP),%@NL@%
                           DSPI_WRTTHRU,%@NL@%
                           0L);%@NL@%
%@NL@%
      pDLnext = pDL->next;                   %@AB@%/* Temp hold next pDL         */%@AE@%%@NL@%
      FreeMem(pDL->EAName, pFEA->cbName+1);  %@AB@%/* Free up current Del struct */%@AE@%%@NL@%
      FreeMem(pDL, sizeof(DELETELIST));%@NL@%
      pDL = pDLnext;                         %@AB@%/* Set pDL to saved value     */%@AE@%%@NL@%
   }%@NL@%
   pDelList = NULL;                          %@AB@%/* DelList is now empty       */%@AE@%%@NL@%
%@NL@%
   while(pHFEA)   %@AB@%/* Go through each HoldFEA */%@AE@%%@NL@%
   {%@NL@%
      usMemNeeded = sizeof(FEALIST) + pHFEA->cbName+1 + pHFEA->cbValue;%@NL@%
      GetMem(aPtr,usMemNeeded);%@NL@%
%@NL@%
      eaopWrite.fpFEAList = (FEALIST far *) aPtr; %@AB@%/* Fill in eaop struct */%@AE@%%@NL@%
      eaopWrite.fpFEAList->cbList = usMemNeeded;%@NL@%
%@NL@%
      eaopWrite.fpFEAList->list[0].fEA     = pHFEA->fEA;%@NL@%
      eaopWrite.fpFEAList->list[0].cbName  = pHFEA->cbName;%@NL@%
      eaopWrite.fpFEAList->list[0].cbValue = pHFEA->cbValue;%@NL@%
%@NL@%
      strcpy(aPtr + sizeof(FEALIST),  pHFEA->szName);%@NL@%
      memcpy(aPtr + sizeof(FEALIST) + pHFEA->cbName+1,%@NL@%
             pHFEA->aValue, pHFEA->cbValue);%@NL@%
%@NL@%
      usRet=DosSetPathInfo(szFileName,             %@AB@%/* Write out the EA */%@AE@%%@NL@%
                           SetInfoLevel2,%@NL@%
                           (PVOID) &eaopWrite,%@NL@%
                           (USHORT) sizeof(EAOP),%@NL@%
                           DSPI_WRTTHRU,0L);%@NL@%
%@NL@%
      FreeMem(aPtr,usMemNeeded);       %@AB@%/* Free up the FEALIST struct */%@AE@%%@NL@%
%@NL@%
      pHFEA = pHFEA->next;%@NL@%
   }%@NL@%
%@NL@%
   FILE_CHANGED = FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: EditEAValue()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd is the current window handle.%@NL@%
%@AB@% *              pPDat is a pointer to PassData which contains Edit EA info.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: TRUE iff the edit was successful.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine allows the entry/edit of an EA value.%@NL@%
%@AB@% *          condition in memory.  First, all EAs in the delete list are%@NL@%
%@AB@% *          removed from the disk, then all EAs in the pHoldFEA list are%@NL@%
%@AB@% *          written out to disk.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Expects the PassData structure to tell it the HoldFEA%@NL@%
%@AB@% *                  to edit, and if it is a subfield of a multi-multi EA,%@NL@%
%@AB@% *                  the rest of the PassData structure will be filled in%@NL@%
%@AB@% *                  to indicated which m-m is being edited.  Note that if%@NL@%
%@AB@% *                  this is a new edit, usRetEAType is expected to be set%@NL@%
%@AB@% *                  to the proper EA type upon entry.  NOTE:  memory sizing%@NL@%
%@AB@% *                  requests are not fully error trapped.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: MultiTypeIndex(), ChangeName(), AsciiEditProc() (thru PM),%@NL@%
%@AB@% *        MultiTypeProc() (thru PM).%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
BOOL EditEAValue(HWND hwnd, PASSDATA *pPDat)%@NL@%
{%@NL@%
   USHORT usEAType; %@AB@%/* Holds the field type to be edited */%@AE@%%@NL@%
   USHORT *pusPtr;%@NL@%
   USHORT usSize;   %@AB@%/* Holds the delta difference of the old and new buffers */%@AE@%%@NL@%
   CHAR   *szNew,*szTrash;     %@AB@%/* Temporary pointers */%@AE@%%@NL@%
   PASSDATA PDat;%@NL@%
   HOLDFEA *pFEA = (HOLDFEA *) pPDat->Point;   %@AB@%/* The EA to be edited */%@AE@%%@NL@%
%@NL@%
   %@AB@%/* Determine the type of EA that will be edited */%@AE@%%@NL@%
   if(pPDat->cbMulti)                  %@AB@%/* It's a multi-type job  */%@AE@%%@NL@%
   {%@NL@%
      pusPtr = (USHORT *) MultiTypeIndex(pFEA->aValue+pPDat->usMultiOffset,%@NL@%
                                         pPDat->usIndex);%@NL@%
      usEAType = *pusPtr;%@NL@%
   }%@NL@%
   else if(pFEA->cbValue) %@AB@%/* It isn't a new EA name */%@AE@%%@NL@%
   {%@NL@%
      pusPtr   = (USHORT *) pFEA->aValue;%@NL@%
      usEAType = *pusPtr;%@NL@%
   }%@NL@%
   else    %@AB@%/* It's a new EA */%@AE@%%@NL@%
   {%@NL@%
      usEAType = ConvTable[usRetEAType].usPrefix;%@NL@%
   }%@NL@%
%@NL@%
   PDat.Point   = pFEA->szName;        %@AB@%/* General setup for AsciiEditProc */%@AE@%%@NL@%
   PDat.usIndex = pPDat->cbMulti ? 1 : 0;   %@AB@%/* =1 if there is a multi  */%@AE@%%@NL@%
   PDat.fFlag   = (BYTE) ((pFEA->fEA & 0x80) ? TRUE : FALSE);%@NL@%
%@NL@%
   switch(usEAType)%@NL@%
   {%@NL@%
      case EA_ASCIIZ:%@NL@%
      case EA_ASCIIZFN:%@NL@%
      case EA_ASCIIZEA:%@NL@%
      case EA_ASN1:%@NL@%
         if(pPDat->cbMulti)            %@AB@%/* It is a multi-type field */%@AE@%%@NL@%
            szAscii=MultiTypeIndex(pFEA->aValue + pPDat->usMultiOffset,%@NL@%
                                   pPDat->usIndex)%@NL@%
                    +sizeof(USHORT);%@NL@%
         else if(pFEA->cbValue)        %@AB@%/* There is a current value */%@AE@%%@NL@%
            szAscii=pFEA->aValue+sizeof(USHORT);%@NL@%
         else                                     %@AB@%/* It's a new EA */%@AE@%%@NL@%
            szAscii=NULL;%@NL@%
%@NL@%
%@NL@%
         if(!WinDlgBox(HWND_DESKTOP,        %@AB@%/* Do an ascii text edit */%@AE@%%@NL@%
                       hwnd,%@NL@%
                       AsciiEditProc,%@NL@%
                       (HMODULE) NULL,%@NL@%
                       IDD_ASCIIEDIT,%@NL@%
                       &PDat))%@NL@%
            return(FALSE);                  %@AB@%/* They said cancel */%@AE@%%@NL@%
%@NL@%
         if(PDat.fFlag)            %@AB@%/* Handle the need/nice bit */%@AE@%%@NL@%
            PDat.fFlag = 0x80;%@NL@%
         if(PDat.fFlag != (BYTE) (PDat.fFlag & 0x80))%@NL@%
            FILE_CHANGED = TRUE;%@NL@%
         pFEA->fEA = (BYTE) (pFEA->fEA & 0x7f) | PDat.fFlag;%@NL@%
%@NL@%
         if(stricmp(strupr(szEAName),pFEA->szName)) %@AB@%/* The name changed */%@AE@%%@NL@%
            ChangeName(hwnd,pFEA,szEAName);%@NL@%
%@NL@%
         if(pFEA->cbValue) %@AB@%/* There is a current value */%@AE@%%@NL@%
         {%@NL@%
            if(!strcmp(szAscii,szScratch))  %@AB@%/* It hasn't changed */%@AE@%%@NL@%
               return(TRUE);%@NL@%
%@NL@%
            if(pPDat->cbMulti) %@AB@%/* Do the whole thing here if m-m */%@AE@%%@NL@%
            {%@NL@%
               usSize = strlen(szScratch)-strlen(szAscii); %@AB@%/* Change in size */%@AE@%%@NL@%
%@NL@%
               if(usSize > 0) %@AB@%/* The new string is longer */%@AE@%%@NL@%
               {%@NL@%
                  ResizeMem(pFEA->aValue,          %@AB@%/* Enlarge the EA size */%@AE@%%@NL@%
                            pFEA->cbValue,%@NL@%
                            pFEA->cbValue+usSize);%@NL@%
                  szTrash=MultiTypeIndex(pFEA->aValue + pPDat->usMultiOffset,%@NL@%
                                         pPDat->usIndex+1);%@NL@%
                  memmove(szTrash+usSize,  %@AB@%/* Move end of EA to make room */%@AE@%%@NL@%
                          szTrash,%@NL@%
                          pFEA->cbValue-(szTrash-pFEA->aValue));%@NL@%
               }%@NL@%
               else %@AB@%/* The new string is shorter */%@AE@%%@NL@%
               {%@NL@%
                  szTrash=MultiTypeIndex(pFEA->aValue + pPDat->usMultiOffset,%@NL@%
                                         pPDat->usIndex+1);%@NL@%
                  memmove(szTrash+usSize, %@AB@%/* Move back the end of the EA */%@AE@%%@NL@%
                          szTrash,%@NL@%
                          pFEA->cbValue-(szTrash-pFEA->aValue));%@NL@%
                  ResizeMem(pFEA->aValue,  %@AB@%/* Shrink the EA buffer */%@AE@%%@NL@%
                            pFEA->cbValue,%@NL@%
                            pFEA->cbValue+usSize);%@NL@%
               }%@NL@%
               szTrash=MultiTypeIndex(pFEA->aValue + pPDat->usMultiOffset,%@NL@%
                                      pPDat->usIndex);%@NL@%
               strcpy(szTrash+sizeof(USHORT),szScratch); %@AB@%/* Copy in new val */%@AE@%%@NL@%
               pFEA->cbValue+=usSize;              %@AB@%/* Change buffer count   */%@AE@%%@NL@%
%@NL@%
               return(FILE_CHANGED = TRUE);  %@AB@%/* Done with m-m edit */%@AE@%%@NL@%
            }%@NL@%
            else%@NL@%
            {%@NL@%
               FreeMem(pFEA->aValue,pFEA->cbValue); %@AB@%/* Release old Value mem */%@AE@%%@NL@%
            }%@NL@%
         }%@NL@%
         GetMem(szNew,strlen(szScratch)+3);  %@AB@%/* +3 for Type & NULL */%@AE@%%@NL@%
         pusPtr = (USHORT *) szNew;%@NL@%
         *pusPtr= usEAType;                  %@AB@%/* Set type in new buffer       */%@AE@%%@NL@%
         strcpy(szNew+2,szScratch);          %@AB@%/* Copy in the new value        */%@AE@%%@NL@%
         pFEA->aValue = szNew;               %@AB@%/* Fix up the structure         */%@AE@%%@NL@%
         pFEA->cbValue= strlen(szScratch)+3;%@NL@%
%@NL@%
         return(FILE_CHANGED = TRUE);%@NL@%
%@NL@%
      case EA_LPBINARY:%@NL@%
      case EA_LPASCII:%@NL@%
      case EA_LPMETAFILE:%@NL@%
         if(pPDat->cbMulti)            %@AB@%/* It is a multi-type field */%@AE@%%@NL@%
         {  %@AB@%/* szTrash points to field to edit, pusPtr to the field length */%@AE@%%@NL@%
            szTrash=MultiTypeIndex(pFEA->aValue + pPDat->usMultiOffset,%@NL@%
                                   pPDat->usIndex);%@NL@%
            pusPtr = (USHORT *) ((CHAR *) szTrash + sizeof(USHORT));%@NL@%
            usSize = *pusPtr;%@NL@%
            if(usSize)  %@AB@%/* It isn't a new EA */%@AE@%%@NL@%
            {%@NL@%
               GetMem(szAscii,usSize+1); %@AB@%/* Set up inital value for edit */%@AE@%%@NL@%
               memcpy(szAscii,szTrash+2*sizeof(USHORT),usSize);%@NL@%
               szAscii[usSize]=0;%@NL@%
            }%@NL@%
            else                       %@AB@%/* No inital value */%@AE@%%@NL@%
               szAscii = NULL;%@NL@%
         }%@NL@%
         else if(pFEA->cbValue)%@NL@%
         {%@NL@%
            usSize=GetUSHORT(pFEA,1);  %@AB@%/* Get size and set inital value */%@AE@%%@NL@%
            if(usSize)%@NL@%
            {%@NL@%
               GetMem(szTrash,usSize+1); %@AB@%/* +1 for null */%@AE@%%@NL@%
               memcpy(szTrash,pFEA->aValue+4,usSize);%@NL@%
               szTrash[usSize]=0;%@NL@%
               szAscii=szTrash;%@NL@%
            }%@NL@%
            else%@NL@%
               szAscii = NULL;%@NL@%
         }%@NL@%
         else%@NL@%
            szAscii = NULL;%@NL@%
%@NL@%
         if(!WinDlgBox(HWND_DESKTOP,        %@AB@%/* Do an ascii text edit */%@AE@%%@NL@%
                       hwnd,%@NL@%
                       AsciiEditProc,%@NL@%
                       (HMODULE) NULL,%@NL@%
                       IDD_ASCIIEDIT,%@NL@%
                       &PDat))%@NL@%
         {  %@AB@%/* Cancel, but check if memory needs to be freed before exit */%@AE@%%@NL@%
            if(pPDat->cbMulti || pFEA->cbValue)%@NL@%
               if(szAscii) %@AB@%/* It's not NULL */%@AE@%%@NL@%
                  FreeMem(szAscii,strlen(szAscii)+1); %@AB@%/* +1 for NULL */%@AE@%%@NL@%
%@NL@%
            return(FALSE);%@NL@%
         }%@NL@%
%@NL@%
         if(PDat.fFlag)              %@AB@%/* Handle the need/nice bit */%@AE@%%@NL@%
            PDat.fFlag = 0x80;%@NL@%
         if(PDat.fFlag != (BYTE) (PDat.fFlag & 0x80))%@NL@%
            FILE_CHANGED = TRUE;%@NL@%
         pFEA->fEA = (BYTE) (pFEA->fEA & 0x7f) | PDat.fFlag;%@NL@%
%@NL@%
         if(stricmp(strupr(szEAName),pFEA->szName)) %@AB@%/* The name changed */%@AE@%%@NL@%
            ChangeName(hwnd,pFEA,szEAName);%@NL@%
%@NL@%
         if(pFEA->cbValue) %@AB@%/* There is a current value */%@AE@%%@NL@%
         {%@NL@%
            if(!strcmp(szAscii,szScratch))  %@AB@%/* It hasn't changed */%@AE@%%@NL@%
            {%@NL@%
               if(szAscii)%@NL@%
                  FreeMem(szAscii,usSize+1);%@NL@%
               return(TRUE);%@NL@%
            }%@NL@%
            if(szAscii)                  %@AB@%/* Free default value buffer */%@AE@%%@NL@%
               FreeMem(szAscii,usSize+1);%@NL@%
%@NL@%
            if(pPDat->cbMulti)   %@AB@%/* Do the whole thing here is multi-type */%@AE@%%@NL@%
            {%@NL@%
               USHORT usDelta = strlen(szScratch) - usSize; %@AB@%/* Change in len */%@AE@%%@NL@%
               if(usDelta > 0) %@AB@%/* The new string is longer, resize first */%@AE@%%@NL@%
               {%@NL@%
                  ResizeMem(pFEA->aValue,pFEA->cbValue,pFEA->cbValue+usDelta);%@NL@%
                  szTrash=MultiTypeIndex(pFEA->aValue + pPDat->usMultiOffset,%@NL@%
                                         pPDat->usIndex+1);%@NL@%
                  memmove(szTrash+usDelta,szTrash,%@NL@%
                          pFEA->cbValue-(szTrash-pFEA->aValue));%@NL@%
               }%@NL@%
               else  %@AB@%/* move first, resize afterwards */%@AE@%%@NL@%
               {%@NL@%
                  szTrash=MultiTypeIndex(pFEA->aValue + pPDat->usMultiOffset,%@NL@%
                                         pPDat->usIndex+1);%@NL@%
                  memmove(szTrash+usDelta,szTrash,%@NL@%
                          pFEA->cbValue-(szTrash-pFEA->aValue));%@NL@%
                  ResizeMem(pFEA->aValue,pFEA->cbValue,pFEA->cbValue+usDelta);%@NL@%
               }%@NL@%
               szTrash=MultiTypeIndex(pFEA->aValue + pPDat->usMultiOffset,%@NL@%
                                      pPDat->usIndex);%@NL@%
               memmove(szTrash+2*sizeof(USHORT),szScratch,strlen(szScratch));%@NL@%
               pusPtr = (USHORT *) ((CHAR *) szTrash + sizeof(USHORT));%@NL@%
               *pusPtr= strlen(szScratch);   %@AB@%/* Set the length field */%@AE@%%@NL@%
%@NL@%
%@NL@%
               pFEA->cbValue += usDelta;     %@AB@%/* Adjust struct len field */%@AE@%%@NL@%
%@NL@%
              return(FILE_CHANGED = TRUE);%@NL@%
            }%@NL@%
%@NL@%
            FreeMem(pFEA->aValue,pFEA->cbValue); %@AB@%/* Free up old value */%@AE@%%@NL@%
         }%@NL@%
         GetMem(szNew,strlen(szScratch)+4);    %@AB@%/* Get space for new value */%@AE@%%@NL@%
         pusPtr = (USHORT *) szNew;%@NL@%
         *pusPtr= usEAType;                    %@AB@%/* Set type field */%@AE@%%@NL@%
         pusPtr++;%@NL@%
         *pusPtr= strlen(szScratch);           %@AB@%/* Set length field */%@AE@%%@NL@%
         memcpy(szNew+4,szScratch,*pusPtr);    %@AB@%/* Copy in new value */%@AE@%%@NL@%
         pFEA->aValue = szNew;                 %@AB@%/* Adjust pointers */%@AE@%%@NL@%
         pFEA->cbValue= strlen(szScratch)+4;   %@AB@%/* +4 for type and LP cnt */%@AE@%%@NL@%
%@NL@%
         return(FILE_CHANGED = TRUE);%@NL@%
%@NL@%
      case EA_MVMT:                    %@AB@%/* It's multi-value multi-type */%@AE@%%@NL@%
         if(pFEA->cbValue == 0) %@AB@%/* It's a new EA */%@AE@%%@NL@%
         {%@NL@%
            GetMem(pFEA->aValue,3*sizeof(USHORT)); %@AB@%/* Allocate empty m-m EA */%@AE@%%@NL@%
            pFEA->cbValue = 3*sizeof(USHORT);%@NL@%
            pusPtr      = (USHORT *) pFEA->aValue;%@NL@%
            *pusPtr = 0xffdf;                 %@AB@%/* Multi-value, multi-type */%@AE@%%@NL@%
            pusPtr+=2;                        %@AB@%/* Skip type, codepage */%@AE@%%@NL@%
            *pusPtr = 0;                      %@AB@%/* No fields initially     */%@AE@%%@NL@%
            FILE_CHANGED = TRUE;%@NL@%
         }%@NL@%
%@NL@%
         %@AB@%/* Set up passed in data */%@AE@%%@NL@%
         if(pPDat->cbMulti) %@AB@%/* It's a multi-type job  */%@AE@%%@NL@%
         {%@NL@%
            szNew   = MultiTypeIndex(pFEA->aValue + pPDat->usMultiOffset,%@NL@%
                                     pPDat->usIndex);%@NL@%
            szTrash = MultiTypeIndex(pFEA->aValue + pPDat->usMultiOffset,%@NL@%
                                     pPDat->usIndex+1);%@NL@%
            PDat.usMultiOffset = szNew - pFEA->aValue;%@NL@%
            PDat.cbMulti       = szTrash - szNew;%@NL@%
         }%@NL@%
         else%@NL@%
         {%@NL@%
            PDat.usMultiOffset = 0;%@NL@%
            PDat.cbMulti       = pFEA->cbValue;%@NL@%
         }%@NL@%
         PDat.Point         = (CHAR *) pFEA;%@NL@%
%@NL@%
         WinDlgBox(HWND_DESKTOP,           %@AB@%/* Do the Multi-type edit */%@AE@%%@NL@%
                   hwnd,%@NL@%
                   MultiTypeProc,%@NL@%
                   (HMODULE) NULL,%@NL@%
                   IDD_MULTIBOX,%@NL@%
                   &PDat);%@NL@%
         return(TRUE);%@NL@%
%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: EAExists()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  szEAName points to the EA Name to check for.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: TRUE iff an EA with a name matching szEAName exists.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine goes through the linked list pointed to by global%@NL@%
%@AB@% *          pHoldFEA and determines whether or not an EA of the passed name%@NL@%
%@AB@% *          already exists.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  The comparison is NOT case sensitive.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
BOOL EAExists(CHAR *szEAName)%@NL@%
{%@NL@%
   HOLDFEA *phFEA=pHoldFEA;%@NL@%
%@NL@%
   while(phFEA)%@NL@%
   {%@NL@%
      if(!stricmp(szEAName,phFEA->szName))%@NL@%
         return(TRUE);%@NL@%
      phFEA=phFEA->next;%@NL@%
   }%@NL@%
   return(FALSE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: ChangeName()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd is the current window used for error messages.%@NL@%
%@AB@% *              pFEA points to the current FEA.%@NL@%
%@AB@% *              szName points to the new EA name.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID.  Fixes up the pFEA structure and global pDelList.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine copies the current EA Name to the delete list, then%@NL@%
%@AB@% *          allocates a new space, copies the new name into it, and sets the%@NL@%
%@AB@% *          FEA pointer to it.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  NOTE:  Not all the memory allocations are fully error%@NL@%
%@AB@% *                         trapped.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID ChangeName(HWND hwnd,HOLDFEA *pFEA,CHAR *szName)%@NL@%
{%@NL@%
   CHAR *szTemp;%@NL@%
   DELETELIST *pDL;%@NL@%
%@NL@%
   GetMem(szTemp,strlen(szName+1));  %@AB@%/* Allocate space for new name */%@AE@%%@NL@%
   if(!szTemp)%@NL@%
      return;%@NL@%
%@NL@%
   GetMem(pDL,(USHORT) sizeof(DELETELIST)); %@AB@%/* Allocate a new delete struct  */%@AE@%%@NL@%
   pDL->EAName = pFEA->szName;              %@AB@%/* Fill in DeleteList struct     */%@AE@%%@NL@%
   pDL->next   = pDelList;%@NL@%
   pDelList    = pDL;%@NL@%
%@NL@%
   strcpy(szTemp,szName);                   %@AB@%/* Copy name to permanent buffer */%@AE@%%@NL@%
   pFEA->szName = szTemp;                   %@AB@%/* Fix up struct                 */%@AE@%%@NL@%
   pFEA->cbName = (CHAR) strlen(szName);%@NL@%
%@NL@%
   FILE_CHANGED = TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: MultiTypeIndex()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pMulti points to the current m-m field.%@NL@%
%@AB@% *              usIndex is the field the caller is interested in.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: a pointer to the field specified by the usIndex param.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine takes a pointer to a Multi-Multi data field and%@NL@%
%@AB@% *          returns a pointer to the nth data field in this buffer.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  NOTE:  Memory bounds are not checked and a corrupt%@NL@%
%@AB@% *                         EA field could cause unspecified results.%@NL@%
%@AB@% *                  Recursively calls itself to handle nesting. Does not%@NL@%
%@AB@% *                  support multi-value single type fields.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: LookupEAType, MultiTypeIndex()%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
CHAR *MultiTypeIndex(CHAR *pMulti, USHORT usIndex)%@NL@%
{%@NL@%
   USHORT *pusPtr;%@NL@%
   USHORT usOffset;%@NL@%
%@NL@%
   pMulti += 3*sizeof(USHORT);  %@AB@%/* skip over 0xffdf, codepage, and field cnt */%@AE@%%@NL@%
%@NL@%
   while(usIndex--)             %@AB@%/* loop to skip over correct # of flds  */%@AE@%%@NL@%
   {%@NL@%
      pusPtr   = (USHORT *) pMulti;%@NL@%
      usOffset = LookupEAType(*pusPtr);    %@AB@%/* Get offset of field type */%@AE@%%@NL@%
%@NL@%
      pMulti += sizeof(USHORT);            %@AB@%/* Skip over the type field */%@AE@%%@NL@%
%@NL@%
      switch(ConvTable[usOffset].usFldType)%@NL@%
      {%@NL@%
         case IDD_ASCIIZ:%@NL@%
            while(*pMulti++);              %@AB@%/* Increment to point after NULL */%@AE@%%@NL@%
            break;%@NL@%
%@NL@%
         case IDD_LPDATA:%@NL@%
            pusPtr = (USHORT *) pMulti;                %@AB@%/* Get the length */%@AE@%%@NL@%
            pMulti += *pusPtr + sizeof(USHORT);        %@AB@%/* skip to end */%@AE@%%@NL@%
            break;%@NL@%
%@NL@%
         case IDD_MULTILIST:%@NL@%
            if(*pusPtr == EA_MVMT) %@AB@%/* m-m, do a recursive call to skip fld */%@AE@%%@NL@%
            {%@NL@%
               pusPtr = (USHORT *) pMulti; %@AB@%/* points to field cnt */%@AE@%%@NL@%
               pMulti = MultiTypeIndex(pMulti-sizeof(USHORT),*pusPtr);%@NL@%
               break;%@NL@%
            }%@NL@%
            %@AB@%/* Not yet implemented for Multi-valued single-type stuff... */%@AE@%%@NL@%
            break;%@NL@%
      }%@NL@%
   }%@NL@%
   return(pMulti);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: EAValueString()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd is the current window handle.%@NL@%
%@AB@% *              aEAVal is a pointer to an EA value field.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: a pointer to an ASCII description of the field value.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine takes a pointer to an EA Value (i.e. starting with%@NL@%
%@AB@% *          with $ffxx) and returns a pointer to a string representing the%@NL@%
%@AB@% *          value of the EA.  This string must be Freed by the user when%@NL@%
%@AB@% *          finished with it.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  NOTE:  Not all GetMem's are totally error trapped.%@NL@%
%@AB@% *                  The string returned is allocated in this procedure,%@NL@%
%@AB@% *                  but it is the caller's responsibility to free the buffer.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
CHAR *EAValueString(HWND hwnd,CHAR *aEAVal)%@NL@%
{%@NL@%
   USHORT *pusPtr= (USHORT *) aEAVal;  %@AB@%/* Points to EA Type     */%@AE@%%@NL@%
   CHAR *szRet,*szTemp;        %@AB@%/* szRet points to return string */%@AE@%%@NL@%
%@NL@%
   switch(*pusPtr)%@NL@%
   {%@NL@%
      case EA_ASCIIZ:    %@AB@%/* For asciiz strings, return MAXSHOWSIZE-1 chars */%@AE@%%@NL@%
      case EA_ASCIIZFN:%@NL@%
      case EA_ASCIIZEA:%@NL@%
      case EA_ASN1:%@NL@%
         aEAVal += sizeof(USHORT);%@NL@%
         if(strlen(aEAVal)<MAXSHOWSIZE)%@NL@%
         {%@NL@%
            GetMem(szRet,strlen(aEAVal)+1);%@NL@%
            strcpy(szRet,aEAVal);%@NL@%
         }%@NL@%
         else%@NL@%
         {%@NL@%
            GetMem(szRet,MAXSHOWSIZE);%@NL@%
            strncpy(szRet,aEAVal,MAXSHOWSIZE-4);%@NL@%
            strcpy (szRet+MAXSHOWSIZE-4,"...");%@NL@%
            szRet[MAXSHOWSIZE-1]=0;%@NL@%
         }%@NL@%
         return(szRet);%@NL@%
%@NL@%
      case EA_LPASCII:   %@AB@%/* Display up to first MAXSHOWSIZE-1 chars */%@AE@%%@NL@%
      case EA_LPMETAFILE:%@NL@%
         pusPtr++;%@NL@%
         aEAVal += 2*sizeof(USHORT);%@NL@%
         if(*pusPtr < MAXSHOWSIZE)%@NL@%
         {%@NL@%
            GetMem(szRet,*pusPtr +1);%@NL@%
            strncpy(szRet,aEAVal,*pusPtr);%@NL@%
            szRet[*pusPtr]=0;%@NL@%
         }%@NL@%
         else%@NL@%
         {%@NL@%
            GetMem(szRet,MAXSHOWSIZE);%@NL@%
            strncpy(szRet,aEAVal,MAXSHOWSIZE-4);%@NL@%
            strcpy (szRet+MAXSHOWSIZE-4,"...");%@NL@%
            szRet[MAXSHOWSIZE-1]=0;%@NL@%
         }%@NL@%
         return(szRet);%@NL@%
%@NL@%
      %@AB@%/* For the rest of the types, just display the field type */%@AE@%%@NL@%
%@NL@%
      case EA_LPBINARY:%@NL@%
         szTemp = "*** LP Binary ***";%@NL@%
         break;%@NL@%
%@NL@%
      case EA_LPBITMAP:%@NL@%
         szTemp = "*** LP Bitmap ***";%@NL@%
         break;%@NL@%
%@NL@%
      case EA_LPICON:%@NL@%
         szTemp = "*** LP Icon ***";%@NL@%
         break;%@NL@%
%@NL@%
      case EA_MVMT:%@NL@%
         szTemp = "*** Multi-value Multi-type ***";%@NL@%
         break;%@NL@%
%@NL@%
      case EA_MVST:%@NL@%
         szTemp = "*** Multi-value Single-type ***";%@NL@%
         break;%@NL@%
%@NL@%
      default:%@NL@%
         szTemp = "*** Unknown EA type ***";%@NL@%
         break;%@NL@%
%@NL@%
   }%@NL@%
   GetMem(szRet,strlen(szTemp)+1); %@AB@%/* Copy string from static to dynamic */%@AE@%%@NL@%
   strcpy(szRet,szTemp);%@NL@%
   return(szRet);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: MultiAdd()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd is the current window handle.%@NL@%
%@AB@% *              pFEA points to the current FEA.%@NL@%
%@AB@% *              pPDat gives the current m-m data.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID.  Modifies the current pFEA.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine is called by MultiTypeProc and handles the addition%@NL@%
%@AB@% *          of a subvalue to a multi-value, multi-type EA.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  NOTE:  Not all GetMem's are totally error trapped.%@NL@%
%@AB@% *                  It is also possible that the add to the listbox could fail.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: AddEAProc() (thru PM), MultiTypeIndex()%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID MultiAdd(HWND hwnd, HOLDFEA *pFEA,PASSDATA FAR *pPDat)%@NL@%
{%@NL@%
   USHORT   usSize;%@NL@%
   USHORT   *pusPtr;%@NL@%
   CHAR     aUtility[6];      %@AB@%/* Used to hold the header for all EA types */%@AE@%%@NL@%
   CHAR     *pInsert,*pValue;%@NL@%
   PASSDATA PDat;%@NL@%
%@NL@%
   PDat.Point = pFEA->szName;%@NL@%
%@NL@%
   if(!WinDlgBox(HWND_DESKTOP,        %@AB@%/* Get the name and type */%@AE@%%@NL@%
                 hwnd,%@NL@%
                 AddEAProc,%@NL@%
                 (HMODULE) NULL,%@NL@%
                 IDD_ADDEA,%@NL@%
                 &PDat))%@NL@%
      return;                         %@AB@%/* They said cancel */%@AE@%%@NL@%
%@NL@%
   pusPtr = (USHORT *) aUtility;%@NL@%
   *pusPtr= ConvTable[usRetEAType].usPrefix;   %@AB@%/* Set the type in header buf */%@AE@%%@NL@%
%@NL@%
   switch(ConvTable[usRetEAType].usFldType)%@NL@%
   {%@NL@%
      case IDD_ASCIIZ:     %@AB@%/* make buffer look like: xx FF 00, size 3 */%@AE@%%@NL@%
         usSize = 3;%@NL@%
         aUtility[2]=0;%@NL@%
         break;%@NL@%
%@NL@%
      case IDD_LPDATA:     %@AB@%/* make the buffer look like: xx FF 00 00, size 4 */%@AE@%%@NL@%
         usSize = 4;%@NL@%
         pusPtr = (USHORT *) &aUtility[2];%@NL@%
         *pusPtr= 0;%@NL@%
         break;%@NL@%
%@NL@%
      case IDD_MULTILIST:%@NL@%
         usSize = 6;%@NL@%
         pusPtr = (USHORT *) &aUtility[2];%@NL@%
         *pusPtr= 0; %@AB@%/* Zero out codepage */%@AE@%%@NL@%
         pusPtr++;%@NL@%
         *pusPtr= 0; %@AB@%/* Zero out fld cnt */%@AE@%%@NL@%
         break;%@NL@%
   }%@NL@%
   %@AB@%/* Increase EA size to accomodate the header */%@AE@%%@NL@%
   ResizeMem(pFEA->aValue,pFEA->cbValue,pFEA->cbValue+usSize);%@NL@%
%@NL@%
   pusPtr  = (USHORT *) ((CHAR *) pFEA->aValue + pPDat->usMultiOffset);%@NL@%
   pusPtr+=2;    %@AB@%/* Point to the current number of m-m fields */%@AE@%%@NL@%
%@NL@%
   %@AB@%/* Get ptr to beginning of current EA, scoot the rest down and insert%@NL@%
%@AB@%      the 3-4 byte header at the end of the list.                        */%@AE@%%@NL@%
   pInsert = MultiTypeIndex(pFEA->aValue+pPDat->usMultiOffset, *pusPtr);%@NL@%
   memmove(pInsert+usSize,pInsert, pFEA->cbValue-(pInsert-pFEA->aValue));%@NL@%
   memcpy(pInsert,aUtility,usSize);%@NL@%
%@NL@%
   pFEA->cbValue += usSize;   %@AB@%/* Fix up the counts */%@AE@%%@NL@%
   pPDat->cbMulti+= usSize;%@NL@%
                                                  %@AB@%/* Set the PDat for call */%@AE@%%@NL@%
   PDat.Point         = (CHAR *) pFEA;%@NL@%
   PDat.cbMulti       = pPDat->cbMulti;%@NL@%
   PDat.usMultiOffset = pPDat->usMultiOffset;%@NL@%
   PDat.usIndex       = *pusPtr;%@NL@%
%@NL@%
   if(!EditEAValue(hwnd,&PDat)) %@AB@%/* They canceled the edit */%@AE@%%@NL@%
   {  %@AB@%/* Move the EA's back to effectively kill the inserted header */%@AE@%%@NL@%
      memmove(pInsert,pInsert+usSize,pFEA->cbValue-(pInsert-pFEA->aValue));%@NL@%
      ResizeMem(pFEA->aValue,pFEA->cbValue,pFEA->cbValue-usSize);%@NL@%
      pFEA->cbValue -= usSize;   %@AB@%/* Adjust counters */%@AE@%%@NL@%
      pPDat->cbMulti-= usSize;%@NL@%
%@NL@%
      return;%@NL@%
   }%@NL@%
%@NL@%
   %@AB@%/* Reset pusPtr since EditEAValue could have moved the base address */%@AE@%%@NL@%
   pusPtr  = (USHORT *) ((CHAR *) pFEA->aValue + pPDat->usMultiOffset);%@NL@%
   pusPtr+=2;%@NL@%
%@NL@%
   pInsert = MultiTypeIndex(pFEA->aValue+pPDat->usMultiOffset, *pusPtr);%@NL@%
%@NL@%
   *pusPtr += 1; %@AB@%/* Field cnt incremented AFTER call to Edit */%@AE@%%@NL@%
%@NL@%
   pValue = EAValueString(hwnd,pInsert);   %@AB@%/* Add new field to the list box */%@AE@%%@NL@%
%@NL@%
   WinSendDlgItemMsg(hwnd, IDD_LBOX, LM_INSERTITEM,%@NL@%
                     MPFROM2SHORT(LIT_END,0),%@NL@%
                     MPFROMP(pValue));%@NL@%
   FreeMem(pValue,strlen(pValue)+1);%@NL@%
%@NL@%
   FILE_CHANGED = TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%NEADFILE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\NEAD\NEADFILE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@% This module contains subroutines for nead.c that specifically%@NL@%
%@AB@% deal with the Open file interface.  Most of the routines were%@NL@%
%@AB@% taken from Charles Petzold's book "Programming the OS/2%@NL@%
%@AB@% Presentation Manager" and were slightly modified.%@NL@%
%@AB@%%@NL@%
%@AB@% Procedures in this file:%@NL@%
%@AB@%   OpenFile()          Asks user for new file name and opens it%@NL@%
%@AB@%   OpenFileProc()      Dialog proc that prompts user for file name%@NL@%
%@AB@%   FillDirListBox()    Fills the directory list box%@NL@%
%@AB@%   FillFileListBox()   Fills the file list box%@NL@%
%@AB@%%@NL@%
%@AB@%**************************************************************/%@AE@%%@NL@%
%@AI@%#include %@AE@%"nead.h" %@NL@%
%@NL@%
%@AB@%/************ External GLOBALS *******************************/%@AE@%%@NL@%
%@NL@%
extern CHAR szFileName[CCHMAXPATH];%@NL@%
extern CHAR szEAName[MAXEANAME+1];%@NL@%
extern USHORT usRetEAType;%@NL@%
extern BOOL FILE_ISOPEN;%@NL@%
extern BOOL FILE_CHANGED;%@NL@%
extern BOOL COMMAND_LINE_FILE;%@NL@%
extern HHEAP hhp;%@NL@%
extern CHAR *pAlloc,*szEditBuf,*szAscii,*szScratch;%@NL@%
extern HOLDFEA *pHoldFEA;%@NL@%
extern DELETELIST *pDelList;%@NL@%
extern EADATA ConvTable[EATABLESIZE];%@NL@%
%@NL@%
%@AB@%/*************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: OpenFile()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd which is the current window handle.%@NL@%
%@AB@% *              usMode which will attempt to load the file from the command%@NL@%
%@AB@% *              line iff usMode == ARGFILE which is set in main().  Otherwise,%@NL@%
%@AB@% *              the selector box is brought up for the user to select from.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: TRUE iff a file is open upon exit.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine handles opening a new file.  It will also query the%@NL@%
%@AB@% *          user for the disposition of the current file if it has been%@NL@%
%@AB@% *          modified before loading the new file.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Routine should be bullet proof as it does its own%@NL@%
%@AB@% *                  error checking.  It assumes that hwnd points to the%@NL@%
%@AB@% *                  correct window with the name listbox in it.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: WriteEAs(), Free_FEAList()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
BOOL OpenFile(HWND hwnd,USHORT usMode)%@NL@%
{%@NL@%
   CHAR szOldFile[CCHMAXPATH];%@NL@%
   USHORT usRet;%@NL@%
%@NL@%
   strcpy(szOldFile,szFileName);  %@AB@%/* Save name of the currently open file */%@AE@%%@NL@%
%@NL@%
   if(usMode != ARGFILE)          %@AB@%/* It isn't the command line file */%@AE@%%@NL@%
   {%@NL@%
      if(!WinDlgBox(HWND_DESKTOP, %@AB@%/* Get the file name from the user */%@AE@%%@NL@%
                    hwnd,%@NL@%
                    OpenFileProc,%@NL@%
                    (HMODULE) NULL,%@NL@%
                    IDD_OPENBOX,%@NL@%
                    NULL))%@NL@%
      {%@NL@%
         strcpy(szFileName,szOldFile); %@AB@%/* They canceled, restore old file */%@AE@%%@NL@%
         return(FILE_ISOPEN);%@NL@%
      }%@NL@%
   }%@NL@%
%@NL@%
   if(FILE_CHANGED) %@AB@%/* Give them a chance to save modifications */%@AE@%%@NL@%
   {%@NL@%
      usRet=WinMessageBox(HWND_DESKTOP,hwnd,%@NL@%
                          "The current file has been changed.  Do you \%@NL@%
wish to save the changes before proceeding?",%@NL@%
                          "Warning",0,MB_YESNOCANCEL | MB_ICONQUESTION);%@NL@%
      switch(usRet)%@NL@%
      {%@NL@%
         case MBID_YES:%@NL@%
            WriteEAs(hwnd);%@NL@%
            break;%@NL@%
         case MBID_CANCEL:%@NL@%
            return FILE_ISOPEN;%@NL@%
      }%@NL@%
   }%@NL@%
%@NL@%
   if(FILE_ISOPEN) %@AB@%/* Free up everything associated with the current file */%@AE@%%@NL@%
   {%@NL@%
      Free_FEAList(pHoldFEA,pDelList);%@NL@%
      FILE_ISOPEN = FALSE;%@NL@%
   }%@NL@%
%@NL@%
   if(QueryEAs(hwnd,szFileName)) %@AB@%/* We were successful */%@AE@%%@NL@%
   {%@NL@%
      HOLDFEA *pFEA=pHoldFEA;%@NL@%
%@NL@%
      FILE_ISOPEN = TRUE;%@NL@%
      FILE_CHANGED = FALSE;%@NL@%
%@NL@%
      WinSendDlgItemMsg(hwnd, IDD_LBOX, LM_DELETEALL,0L,0L); %@AB@%/* Fill L-box */%@AE@%%@NL@%
%@NL@%
      while(pFEA)%@NL@%
      {%@NL@%
         WinSendDlgItemMsg(hwnd, IDD_LBOX, LM_INSERTITEM,%@NL@%
                           MPFROM2SHORT(LIT_END,0),%@NL@%
                           MPFROMP(pFEA->szName));%@NL@%
         pFEA = pFEA->next;%@NL@%
      }%@NL@%
   }%@NL@%
   else %@AB@%/* We couldn't query the EAs */%@AE@%%@NL@%
   {%@NL@%
      *szFileName = '\000';%@NL@%
      WinSetDlgItemText(hwnd,IDD_FNAME,szFileName);%@NL@%
      return(FILE_ISOPEN = FALSE);%@NL@%
   }%@NL@%
   WinSetDlgItemText(hwnd,IDD_FNAME,szFileName);%@NL@%
   pDelList = NULL;%@NL@%
   return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: OpenFileProc()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd, msg, mp1, mp2.  Standard PM Dialog Proc params.%@NL@%
%@AB@% *              Expects no user pointer.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: TRUE if user selects OK, FALSE if Cancel is selected.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This proc handles the user interface to select a file name.%@NL@%
%@AB@% *          Some elementary checks are done to make sure the filename is%@NL@%
%@AB@% *          valid.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  The interface is NOT foolproof as it is possible to%@NL@%
%@AB@% *                  continue with a non-existant file name.  Also, users%@NL@%
%@AB@% *                  are not currently allowed to view/edit the EAs attached%@NL@%
%@AB@% *                  to a directory.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: FillDirListBox(), FillFileListBox(), ParseFileName()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY OpenFileProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
   static CHAR szCurrentPath[CCHMAXPATH],szBuffer[CCHMAXPATH];%@NL@%
   CHAR        szParsedPath[CCHMAXPATH];%@NL@%
   SHORT       sSelect;%@NL@%
%@NL@%
   switch(msg)%@NL@%
   {%@NL@%
      case WM_INITDLG:%@NL@%
         FillDirListBox(hwnd,szCurrentPath);%@NL@%
         FillFileListBox(hwnd);%@NL@%
         WinSendDlgItemMsg(hwnd, IDD_FILEEDIT,EM_SETTEXTLIMIT,%@NL@%
                                 MPFROM2SHORT(260,0),NULL);%@NL@%
         return 0L;%@NL@%
%@NL@%
      case WM_CONTROL:%@NL@%
         if(SHORT1FROMMP(mp1) == IDD_DIRLIST ||  %@AB@%/* An lbox item is selected */%@AE@%%@NL@%
            SHORT1FROMMP(mp1) == IDD_FILELIST)%@NL@%
         {%@NL@%
            sSelect = SHORT1FROMMR( WinSendDlgItemMsg(hwnd, %@AB@%/* Get item->szBuffer */%@AE@%%@NL@%
                               SHORT1FROMMP(mp1),%@NL@%
                               LM_QUERYSELECTION, 0L, 0L));%@NL@%
%@NL@%
            WinSendDlgItemMsg(hwnd, SHORT1FROMMP(mp1),%@NL@%
                              LM_QUERYITEMTEXT,%@NL@%
                              MPFROM2SHORT(sSelect, sizeof szBuffer),%@NL@%
                              MPFROMP(szBuffer));%@NL@%
         }%@NL@%
%@NL@%
         switch(SHORT1FROMMP(mp1))%@NL@%
         {%@NL@%
            case IDD_DIRLIST:              %@AB@%/* Item was in the directory lbox */%@AE@%%@NL@%
               switch(SHORT2FROMMP(mp1))%@NL@%
               {%@NL@%
                  case LN_ENTER:           %@AB@%/* Go to the select drive/dir */%@AE@%%@NL@%
                     if(*szBuffer == ' ')%@NL@%
                        DosSelectDisk(*(szBuffer+1) - '@');%@NL@%
                     else%@NL@%
                        DosChDir(szBuffer, 0L);%@NL@%
%@NL@%
                     FillDirListBox(hwnd, szCurrentPath);%@NL@%
                     FillFileListBox(hwnd);%@NL@%
%@NL@%
                     WinSetDlgItemText(hwnd, IDD_FILEEDIT, "");%@NL@%
                     return 0L;%@NL@%
               }%@NL@%
               break;%@NL@%
%@NL@%
            case IDD_FILELIST:             %@AB@%/* Item was in the file lbox */%@AE@%%@NL@%
               switch(SHORT2FROMMP(mp1))%@NL@%
               {%@NL@%
                  case LN_SELECT:          %@AB@%/* Copy name to entry field  */%@AE@%%@NL@%
                     WinSetDlgItemText(hwnd, IDD_FILEEDIT, szBuffer);%@NL@%
                     return 0L;%@NL@%
%@NL@%
                  case LN_ENTER:           %@AB@%/* Try to query the file */%@AE@%%@NL@%
                     if(ParseFileName(szFileName, szBuffer) != FILE_VALID)%@NL@%
                        return 0; %@AB@%/* Some error, don't finish */%@AE@%%@NL@%
                     WinDismissDlg(hwnd, TRUE);%@NL@%
                     return 0L;%@NL@%
               }%@NL@%
               break;%@NL@%
         }%@NL@%
         break;%@NL@%
%@NL@%
      case WM_COMMAND:%@NL@%
         switch(COMMANDMSG(&msg)->cmd)%@NL@%
         {%@NL@%
            case DID_OK:            %@AB@%/* Try to query file in the entry field */%@AE@%%@NL@%
               WinQueryDlgItemText(hwnd, IDD_FILEEDIT,%@NL@%
                                   sizeof szBuffer, szBuffer);%@NL@%
%@NL@%
               switch(ParseFileName(szParsedPath, szBuffer))%@NL@%
               {%@NL@%
                  case FILE_INVALID:    %@AB@%/* Can't open the file */%@AE@%%@NL@%
                     WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
                     FillDirListBox(hwnd, szCurrentPath);%@NL@%
                     FillFileListBox(hwnd);%@NL@%
                     return 0L;%@NL@%
%@NL@%
                  case FILE_PATH:    %@AB@%/* It was an incomplete path name */%@AE@%%@NL@%
                     strcpy(szCurrentPath,szBuffer);%@NL@%
                     FillDirListBox(hwnd, szCurrentPath);%@NL@%
                     FillFileListBox(hwnd);%@NL@%
                     WinSetDlgItemText(hwnd, IDD_FILEEDIT, "");%@NL@%
                     return 0L;%@NL@%
%@NL@%
                  case FILE_VALID:    %@AB@%/* It was valid */%@AE@%%@NL@%
                     strcpy(szFileName, szParsedPath);%@NL@%
                     WinDismissDlg(hwnd, TRUE);%@NL@%
                     return 0L;%@NL@%
               }%@NL@%
               break;%@NL@%
%@NL@%
            case DID_CANCEL:%@NL@%
               WinDismissDlg(hwnd, FALSE);%@NL@%
               return 0L;%@NL@%
         }%@NL@%
         break;%@NL@%
   }%@NL@%
   return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: FillDirListBox()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd points to the current window handle%@NL@%
%@AB@% *              pcCurrentPath points to a buffer which will be filled in%@NL@%
%@AB@% *              with the current path.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine is called by OpenFileProc to fill in the directory%@NL@%
%@AB@% *          list box%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Adequete error checking is NOT done on the return%@NL@%
%@AB@% *                  values of the system calls.  Also, it is remotely%@NL@%
%@AB@% *                  possible that the calls to add to the list box could fail.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID FillDirListBox(HWND hwnd, CHAR *pcCurrentPath)%@NL@%
{%@NL@%
   static CHAR szDrive [] = "  :";%@NL@%
   FILEFINDBUF findbuf;%@NL@%
   HDIR        hDir = 1;%@NL@%
   SHORT       sDrive;%@NL@%
   USHORT      usDriveNum, usCurPathLen, usSearchCount = 1;%@NL@%
   ULONG       ulDriveMap;%@NL@%
%@NL@%
   DosQCurDisk(&usDriveNum, &ulDriveMap);%@NL@%
   *pcCurrentPath     = (CHAR)((CHAR) usDriveNum + '@');%@NL@%
   *(pcCurrentPath+1) = ':';%@NL@%
   *(pcCurrentPath+2) = '\\';%@NL@%
   usCurPathLen = CCHMAXPATH;%@NL@%
   DosQCurDir(0, pcCurrentPath + 3, &usCurPathLen);%@NL@%
%@NL@%
   WinSetDlgItemText(hwnd, IDD_PATH, pcCurrentPath);%@NL@%
   WinSendDlgItemMsg(hwnd, IDD_DIRLIST, LM_DELETEALL, NULL, NULL);%@NL@%
%@NL@%
   for(sDrive = ('A'-'A'); sDrive <= ('Z'-'A'); sDrive++)%@NL@%
   {%@NL@%
      if(ulDriveMap & (1L << sDrive))%@NL@%
      {%@NL@%
         *(szDrive+1) = (CHAR)((CHAR) sDrive + 'A');%@NL@%
%@NL@%
         WinSendDlgItemMsg(hwnd, IDD_DIRLIST, LM_INSERTITEM,%@NL@%
                           MPFROM2SHORT(LIT_END, 0),%@NL@%
                           MPFROMP(szDrive));%@NL@%
      }%@NL@%
   }%@NL@%
   DosFindFirst("*", &hDir, FILE_DIRECTORY | FILE_ALL, &findbuf,%@NL@%
                sizeof findbuf, &usSearchCount, 0L);%@NL@%
   while(usSearchCount)%@NL@%
   {%@NL@%
      if((findbuf.attrFile & FILE_DIRECTORY) &&%@NL@%
         (findbuf.achName[0] != '.' || findbuf.achName[1]))%@NL@%
%@NL@%
         WinSendDlgItemMsg(hwnd, IDD_DIRLIST, LM_INSERTITEM,%@NL@%
                           MPFROM2SHORT(LIT_SORTASCENDING, 0),%@NL@%
                           MPFROMP(findbuf.achName));%@NL@%
%@NL@%
      if(DosFindNext(hDir, &findbuf, sizeof findbuf, &usSearchCount))%@NL@%
         break;%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/* This routine is called by OpenFileProc to fill the file list box */%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: FillFileListBox()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd points to the current window handle%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine is called by OpenFileProc to fill in the file%@NL@%
%@AB@% *          list box with files in the current directory.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Adequete error checking is NOT done on the return%@NL@%
%@AB@% *                  values of the system calls.  Also, it is remotely%@NL@%
%@AB@% *                  possible that the calls to add to the list box could fail.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID FillFileListBox(HWND hwnd)%@NL@%
{%@NL@%
   FILEFINDBUF findbuf;%@NL@%
   HDIR        hDir = 1;%@NL@%
   USHORT      usSearchCount = 1; %@AB@%/* Read 1 entry at a time */%@AE@%%@NL@%
%@NL@%
   WinSendDlgItemMsg(hwnd, IDD_FILELIST, LM_DELETEALL, NULL, NULL);%@NL@%
%@NL@%
   DosFindFirst("*", &hDir, FILE_ALL, &findbuf, sizeof findbuf,%@NL@%
                       &usSearchCount, 0L);%@NL@%
   while(usSearchCount)%@NL@%
   {%@NL@%
      WinSendDlgItemMsg(hwnd, IDD_FILELIST, LM_INSERTITEM,%@NL@%
                        MPFROM2SHORT(LIT_SORTASCENDING, 0),%@NL@%
                        MPFROMP(findbuf.achName));%@NL@%
%@NL@%
      if(DosFindNext(hDir, &findbuf, sizeof findbuf, &usSearchCount))%@NL@%
         break;%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: ParseFileName()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pcOut points to a buffer for the return file specification.%@NL@%
%@AB@% *              pcIn  points to the buffer containing the raw input spec.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: FILE_INVALID if pcIn had invalid drive or no directory%@NL@%
%@AB@% *          FILE_PATH    if pcIn was empty or had just a path/no file name.%@NL@%
%@AB@% *          FILE_VALID   if pcIn point to good file.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine changes drive and directory as per pcIn string.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  Note that pcOut is only valid if FILE_VALID is returned.%@NL@%
%@AB@% *                  in place of strupr(), a codepage should be fetched and%@NL@%
%@AB@% *                  DosCaseMap() should be used to allow for extended chars.%@NL@%
%@AB@% *                  This routine could use some cleanup work.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
SHORT ParseFileName(CHAR *pcOut, CHAR *pcIn)%@NL@%
{%@NL@%
   CHAR   *pcLastSlash, *pcFileOnly ;%@NL@%
   ULONG  ulDriveMap ;%@NL@%
   USHORT usDriveNum, usDirLen = CCHMAXPATH;%@NL@%
%@NL@%
   strupr(pcIn);  %@AB@%/* Does NOT handle extended chars, should use DosCaseMap */%@AE@%%@NL@%
%@NL@%
   if(*pcIn == '\000')  %@AB@%/* If string is empty, return FILE_PATH */%@AE@%%@NL@%
%@NL@%
      return FILE_PATH;%@NL@%
%@NL@%
   %@AB@%/* Get drive from input string or use current drive */%@AE@%%@NL@%
%@NL@%
   if(*(pcIn+1) == ':') %@AB@%/* Yup, they specified a drive */%@AE@%%@NL@%
   {%@NL@%
      if(DosSelectDisk(*pcIn - '@')) %@AB@%/* Change to selected drive */%@AE@%%@NL@%
         return FILE_INVALID;%@NL@%
      pcIn += 2;%@NL@%
   }%@NL@%
   DosQCurDisk(&usDriveNum, &ulDriveMap); %@AB@%/* Get current drive */%@AE@%%@NL@%
%@NL@%
   *pcOut++ = (CHAR)((CHAR) usDriveNum + '@'); %@AB@%/* Build drive letter */%@AE@%%@NL@%
   *pcOut++ = ':';%@NL@%
   *pcOut++ = '\\';%@NL@%
%@NL@%
   if(*pcIn == '\000') %@AB@%/* If rest of the string is empty, return FILE_PATH */%@AE@%%@NL@%
      return FILE_PATH;%@NL@%
%@NL@%
   %@AB@%/* Search for the last backslash.  If none, it could be a directory. */%@AE@%%@NL@%
%@NL@%
   if(!(pcLastSlash = strrchr(pcIn, '\\'))) %@AB@%/* No slashes? */%@AE@%%@NL@%
   {%@NL@%
      if(!DosChDir(pcIn, 0L))%@NL@%
         return FILE_PATH;            %@AB@%/* It was a directory */%@AE@%%@NL@%
%@NL@%
      DosQCurDir(0, pcOut, &usDirLen); %@AB@%/* Get current dir & attach input fn */%@AE@%%@NL@%
%@NL@%
      if(*(pcOut+strlen(pcOut)-1) != '\\')%@NL@%
         strcat(pcOut++, "\\");%@NL@%
%@NL@%
      strcat(pcOut, pcIn);%@NL@%
      return FILE_VALID;%@NL@%
   }%@NL@%
%@NL@%
   %@AB@%/* If the only backslash is at the beginning, change to root */%@AE@%%@NL@%
%@NL@%
   if(pcIn == pcLastSlash)%@NL@%
   {%@NL@%
      DosChDir("\\", 0L);%@NL@%
%@NL@%
      if(*(pcIn+1) == '\000')%@NL@%
         return FILE_PATH;%@NL@%
%@NL@%
      strcpy(pcOut, pcIn+1);%@NL@%
      return FILE_VALID;%@NL@%
   }%@NL@%
%@NL@%
   %@AB@%/* Attempt to change directory -- Get current dir if OK */%@AE@%%@NL@%
%@NL@%
   *pcLastSlash = 0;%@NL@%
%@NL@%
   if(DosChDir(pcIn, 0L))%@NL@%
      return FILE_INVALID;%@NL@%
%@NL@%
   DosQCurDir(0, pcOut, &usDirLen);%@NL@%
%@NL@%
   %@AB@%/* Append input filename if any */%@AE@%%@NL@%
%@NL@%
   pcFileOnly = pcLastSlash+1;%@NL@%
%@NL@%
   if(*pcFileOnly == '\000')%@NL@%
      return FILE_PATH;%@NL@%
%@NL@%
   if(*(pcOut+strlen(pcOut)-1) != '\\')%@NL@%
      strcat(pcOut++, "\\");%@NL@%
%@NL@%
   strcat(pcOut, pcFileOnly);%@NL@%
   return FILE_VALID;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%OPTIONS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\TERMINAL\OPTIONS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***%@NL@%
%@AB@% *%@NL@%
%@AB@% * TITLE %@NL@%
%@AB@% *%@NL@%
%@AB@% *        options.c%@NL@%
%@AB@% *        Created by Microsoft Corporation 1987%@NL@%
%@AB@% *%@NL@%
%@AB@% * DESCRIPTION%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This module handles the user interface for setting the options for%@NL@%
%@AB@% *      the COM port and the MODEM.%@NL@%
%@AB@% *%@NL@%
%@AB@% *         If a filename was specified in the command line, the initialisation %@NL@%
%@AB@% *        of the COM port and the MODEM will be performed as indicated in %@NL@%
%@AB@% *        the file (creation of this file will be described later). If an error %@NL@%
%@AB@% *        is encountered in opening the file or, if no file was specified in the %@NL@%
%@AB@% *        command line, an option screen is displayed. The user is then required %@NL@%
%@AB@% *        to specify the appropriate options for initialisation of the COM port %@NL@%
%@AB@% *        and the MODEM.%@NL@%
%@AB@% * %@NL@%
%@AB@% *         The program will request the following information from the user via %@NL@%
%@AB@% *        the option screen:%@NL@%
%@AB@% *%@NL@%
%@AB@% *                Port        :%@NL@%
%@AB@% *                Baud Rate   :%@NL@%
%@AB@% *                Data Bits   :%@NL@%
%@AB@% *                Stop Bits   :%@NL@%
%@AB@% *                Parity      :%@NL@%
%@AB@% *                Connect     : %@NL@%
%@AB@% *                Dial Type   : %@NL@%
%@AB@% *                Wait Tone   :%@NL@%
%@AB@% *                Wait Carrier:%@NL@%
%@AB@% *                Phone Number:%@NL@%
%@AB@% *                Setup File  :%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Port:%@NL@%
%@AB@% *                Specify com port. The available options are com1, com2.%@NL@%
%@AB@% *        Baud Rate:%@NL@%
%@AB@% *                The available options are 1200, 2400, 4800, 9600, 110,%@NL@%
%@AB@% *                150, 300, 600.%@NL@%
%@AB@% *        Data Bits:%@NL@%
%@AB@% *                The available options are 7 and 8.%@NL@%
%@AB@% *        Stop Bits:%@NL@%
%@AB@% *                The available options are 1 and 2.%@NL@%
%@AB@% *        Parity:%@NL@%
%@AB@% *                The available options are even, none and odd.%@NL@%
%@AB@% *        Connect: %@NL@%
%@AB@% *                The available options are computer and modem.%@NL@%
%@AB@% *        Dial Type:%@NL@%
%@AB@% *                The available options are tone and pulse.%@NL@%
%@AB@% *        Wait Tone:%@NL@%
%@AB@% *                The available options are 10, 15, 20, 25, 50, 75, 100, %@NL@%
%@AB@% *                125, 150, 175, 200, 225 and 250 seconds.%@NL@%
%@AB@% *                Determines how long the modem waits after "picking up%@NL@%
%@AB@% *                the telephone" before it dials the first digit of the%@NL@%
%@AB@% *                telephone number. This delay allows time for the central%@NL@%
%@AB@% *                office to detect the "off-hook" condition of the line and%@NL@%
%@AB@% *                apply a dial tone.%@NL@%
%@AB@% *        Wait Carrier: %@NL@%
%@AB@% *                The available options are 10, 15, 20, 25, and 30.%@NL@%
%@AB@% *                Sets the time that the local modem waits for carrier from%@NL@%
%@AB@% *                the remote modem before hanging up.%@NL@%
%@AB@% *        Phone Number:%@NL@%
%@AB@% *                Type the telephone number of the service. Type the entire%@NL@%
%@AB@% *                number including 1 and the area code if necessary. %@NL@%
%@AB@% *                Commas instruct the modem to pause before dialing a number.%@NL@%
%@AB@% *                For example, if you must dial 9 to get an outside line, type%@NL@%
%@AB@% *                a comma after the 9. This allows time to wait for a dial%@NL@%
%@AB@% *                tone before the modem dials the number. You can use hyphens %@NL@%
%@AB@% *                in the number for clarity; the modem ignores them.%@NL@%
%@AB@% *        Setup File:%@NL@%
%@AB@% *                This is the name of file in which the options will be saved.%@NL@%
%@AB@% *                The default file name is terminal.ini . If you prefer%@NL@%
%@AB@% *              a different name, delete the default name and type the%@NL@%
%@AB@% *              name you prefer. You may include the path name.%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%    INCL_DOSSIGNALS %@NL@%
%@AI@%#define %@AE@%    INCL_SUB %@NL@%
%@NL@%
%@AI@%#include %@AE@%       <os2def.h> %@NL@%
%@AI@%#include %@AE@%       <bse.h> %@NL@%
%@AI@%#include %@AE@%       <stdio.h> %@NL@%
%@AI@%#include %@AE@%       <malloc.h> %@NL@%
%@AI@%#include %@AE@%       <string.h> %@NL@%
%@AI@%#include %@AE@%        <memory.h> %@NL@%
%@AI@%#include %@AE@%        <conio.h> %@NL@%
%@AI@%#include %@AE@%        "term.h" %@NL@%
%@NL@%
extern void far error (int, int);%@NL@%
%@NL@%
extern char         *ErrMsg[NUM_MSG];%@NL@%
%@NL@%
%@AI@%#define %@AE@%Z_ALPHA     0x01 %@NL@%
%@AI@%#define %@AE@%Z_DIGIT     0x02 %@NL@%
%@AI@%#define %@AE@%Z_WHITE     0x04 %@NL@%
%@AI@%#define %@AE@%Z_PATH            0x08 %@NL@%
%@AI@%#define %@AE@%Z_PHONE     0x10 %@NL@%
%@NL@%
%@AI@%#define %@AE@%    O_WIDTH        62 %@NL@%
%@AI@%#define %@AE@%    O_HEIGHT        21 %@NL@%
%@NL@%
char optScreen[O_HEIGHT][O_WIDTH+1] = {%@NL@%
   %@AB@%/* 123456789 123456789 123456789 123456789 123456789 123456789 1 */%@AE@%%@NL@%
    "                    [ Terminal Parameters ]                   ", %@AB@%/*  0 */%@AE@%%@NL@%
    "                                                              ", %@AB@%/*  1 */%@AE@%%@NL@%
    "   Port        :     com1                                     ", %@AB@%/*  2 */%@AE@%%@NL@%
    "   Baud Rate   :     1200                                     ", %@AB@%/*  3 */%@AE@%%@NL@%
    "   Data Bits   :        7                                     ", %@AB@%/*  4 */%@AE@%%@NL@%
    "   Stop Bits   :        2                                     ", %@AB@%/*  5 */%@AE@%%@NL@%
    "   Parity      :     even                                     ", %@AB@%/*  6 */%@AE@%%@NL@%
    "   Connect     : computer                                     ", %@AB@%/*  7 */%@AE@%%@NL@%
    "   Dial Type   :     tone                                     ", %@AB@%/*  8 */%@AE@%%@NL@%
    "   Wait Tone   :       30                                     ", %@AB@%/*  9 */%@AE@%%@NL@%
    "   Wait Carrier:       10                                     ", %@AB@%/* 10 */%@AE@%%@NL@%
    "                                                              ", %@AB@%/* 11 */%@AE@%%@NL@%
    "   Phone Number: 9,555-1212                                   ", %@AB@%/* 12 */%@AE@%%@NL@%
    "                                                              ", %@AB@%/* 13 */%@AE@%%@NL@%
    "   Setup File  : terminal.ini                                 ", %@AB@%/* 14 */%@AE@%%@NL@%
    "                                                              ", %@AB@%/* 15 */%@AE@%%@NL@%
    "                                                              ", %@AB@%/* 16 */%@AE@%%@NL@%
    "       Use UP and DOWN cursor keys to move between fields.    ", %@AB@%/* 17 */%@AE@%%@NL@%
    "       Use LEFT and RIGHT cursor keys to change a field.      ", %@AB@%/* 18 */%@AE@%%@NL@%
    "                                                              ", %@AB@%/* 19 */%@AE@%%@NL@%
    "                   [ Press Enter to return ]                  "  %@AB@%/* 20 */%@AE@%%@NL@%
};%@NL@%
%@NL@%
%@AI@%#define %@AE@%    rowPort        2 %@NL@%
%@AI@%#define %@AE@%    colPort    21 %@NL@%
%@NL@%
%@AI@%#define %@AE@%    rowBaud        3 %@NL@%
%@AI@%#define %@AE@%    colBaud    21 %@NL@%
%@NL@%
%@AI@%#define %@AE@%    rowData        4 %@NL@%
%@AI@%#define %@AE@%    colData    24 %@NL@%
%@NL@%
%@AI@%#define %@AE@%    rowStop        5 %@NL@%
%@AI@%#define %@AE@%    colStop    24 %@NL@%
%@NL@%
%@AI@%#define %@AE@%    rowParity        6 %@NL@%
%@AI@%#define %@AE@%    colParity  21 %@NL@%
%@NL@%
%@AI@%#define %@AE@%           rowConnect  7 %@NL@%
%@AI@%#define %@AE@%    colConnect 17 %@NL@%
%@NL@%
%@AI@%#define %@AE@%    rowDial     8 %@NL@%
%@AI@%#define %@AE@%    colDial    20 %@NL@%
%@NL@%
%@AI@%#define %@AE@%    rowTone     9 %@NL@%
%@AI@%#define %@AE@%    colTone    22 %@NL@%
%@NL@%
%@AI@%#define %@AE@%    rowCarrier  10 %@NL@%
%@AI@%#define %@AE@%    colCarrier  23 %@NL@%
%@NL@%
%@AI@%#define %@AE@%    rowPhone   12 %@NL@%
%@AI@%#define %@AE@%    colPhone   17 %@NL@%
    wPhone     20                %@AB@%/* width of phone string */%@AE@%%@NL@%
%@AI@%#define %@AE@%    sPhone  (Z_DIGIT | Z_PHONE) %@NL@%
                         %@AB@%/*012345678901234567890*/%@AE@%%@NL@%
char strPhone[wPhone+1] = "9,555-1212           ";%@NL@%
%@AI@%#define %@AE@%    lenPhone   12 %@NL@%
%@NL@%
%@AI@%#define %@AE@%    rowFile    14 %@NL@%
%@AI@%#define %@AE@%    colFile    17 %@NL@%
%@AI@%#define %@AE@%    wFile      40 %@NL@%
%@AI@%#define %@AE@%    sFile   (Z_PATH | Z_ALPHA | Z_DIGIT) %@NL@%
                     %@AB@%/*01234567890123456789012345678901234567890*/%@AE@%%@NL@%
char strFile[wFile+1]="terminal.ini                             ";%@NL@%
%@AI@%#define %@AE@%    lenFile    13 %@NL@%
%@NL@%
int O_ROW;        %@AB@%/* Coordinates of top left corner of option menu */%@AE@%%@NL@%
int O_COL;%@NL@%
%@NL@%
char *csBaud[] = {%@NL@%
    "1200",%@NL@%
    "2400",%@NL@%
    "4800",%@NL@%
    "9600",%@NL@%
    " 110",%@NL@%
    " 150",%@NL@%
    " 300",%@NL@%
    " 600"%@NL@%
};%@NL@%
%@NL@%
%@AI@%#define %@AE@%nBaud        (sizeof(csBaud)/sizeof(char*)) %@NL@%
%@AI@%#define %@AE@%wBaud   4         %@NL@%
int intBaud[nBaud] = {%@NL@%
   1200,%@NL@%
   2400,%@NL@%
   4800,%@NL@%
   9600,%@NL@%
    110,%@NL@%
    150,%@NL@%
    300,%@NL@%
    600%@NL@%
};%@NL@%
%@NL@%
char *csPort[] = {%@NL@%
    "com1",%@NL@%
    "com2"%@NL@%
};%@NL@%
%@AI@%#define %@AE@%nPort        (sizeof(csPort)/sizeof(char*)) %@NL@%
%@AI@%#define %@AE@%wPort        4 %@NL@%
%@NL@%
char *csData[] = {%@NL@%
    "7",%@NL@%
    "8"%@NL@%
};%@NL@%
%@AI@%#define %@AE@%nData        (sizeof(csData)/sizeof(char*)) %@NL@%
%@AI@%#define %@AE@%wData        1 %@NL@%
%@NL@%
UCHAR chData[nData] = {%@NL@%
    7,%@NL@%
    8%@NL@%
};%@NL@%
%@NL@%
NPCH csStop[] = {%@NL@%
    "1",%@NL@%
    "2"%@NL@%
};%@NL@%
%@AI@%#define %@AE@%nStop        (sizeof(csStop)/sizeof(char*)) %@NL@%
%@AI@%#define %@AE@%wStop        1 %@NL@%
%@NL@%
UCHAR chStop[nStop] = {%@NL@%
    0,%@NL@%
    2%@NL@%
};%@NL@%
%@NL@%
NPCH csParity[] = {%@NL@%
    "even",%@NL@%
    " odd",%@NL@%
    "none"%@NL@%
};%@NL@%
%@AI@%#define %@AE@%nParity   (sizeof(csParity)/sizeof(char*)) %@NL@%
%@AI@%#define %@AE@%wParity   4 %@NL@%
%@NL@%
UCHAR chParity[nParity] = {%@NL@%
    EVEN,%@NL@%
    ODD,%@NL@%
    NONE%@NL@%
};%@NL@%
%@NL@%
NPCH csConnect[] = {%@NL@%
    "computer",%@NL@%
    "   modem"%@NL@%
};%@NL@%
%@AI@%#define %@AE@%nConnect   (sizeof(csConnect)/sizeof(char*)) %@NL@%
%@AI@%#define %@AE@%wConnect   8 %@NL@%
UCHAR chConnect[nConnect] = {%@NL@%
    COMPUTER,%@NL@%
    MODEM%@NL@%
};%@NL@%
%@NL@%
NPCH csDial[] = {%@NL@%
    " tone",%@NL@%
    "pulse"%@NL@%
};%@NL@%
%@AI@%#define %@AE@%nDial   (sizeof(csDial)/sizeof(char*)) %@NL@%
%@AI@%#define %@AE@%wDial   5 %@NL@%
UCHAR chDial[nConnect] = {%@NL@%
    TONE,%@NL@%
    PULSE%@NL@%
};%@NL@%
%@NL@%
NPCH csTone[] = {%@NL@%
    " 10",%@NL@%
    " 15",%@NL@%
    " 20",%@NL@%
    " 25",%@NL@%
    " 50",%@NL@%
    " 75",%@NL@%
    "100",%@NL@%
    "125",%@NL@%
    "150",%@NL@%
    "175",%@NL@%
    "200",%@NL@%
    "225",%@NL@%
    "250"%@NL@%
};%@NL@%
%@AB@%/* register S6 in Hayes Modem */%@AE@%%@NL@%
%@AI@%#define %@AE@%nTone   (sizeof(csTone)/sizeof(char*)) %@NL@%
%@AI@%#define %@AE@%wTone   3 %@NL@%
int iTone[nTone] = {10,15,20,25,50,75,100,125,150,175,200,225,250};%@NL@%
%@NL@%
NPCH csCarrier[] = {%@NL@%
    "30",%@NL@%
    "25",%@NL@%
    "20",%@NL@%
    "15",%@NL@%
    "10",%@NL@%
    " 5"%@NL@%
};%@NL@%
%@AB@%/* register S7 in Hayes Modem */%@AE@%%@NL@%
%@AI@%#define %@AE@%nCarrier   (sizeof(csCarrier)/sizeof(char*)) %@NL@%
%@AI@%#define %@AE@%wCarrier   2 %@NL@%
int iCarrier[nCarrier] = {30, 25, 20, 15, 10, 5};%@NL@%
%@NL@%
OT_SET            0                %@AB@%/* Option types */%@AE@%%@NL@%
%@AI@%#define %@AE@%OT_ASCIIZ   1 %@NL@%
%@NL@%
UCHAR cMap[256];%@NL@%
%@NL@%
typedef struct {%@NL@%
    int sc_n;                        %@AB@%/* number of different values */%@AE@%%@NL@%
    char **sc_name;                %@AB@%/* array of value names */%@AE@%%@NL@%
} setControl_s;%@NL@%
%@NL@%
typedef struct {%@NL@%
    UCHAR az_Set;        %@AB@%/* flags of valid characters */%@AE@%%@NL@%
} azControl_s;%@NL@%
%@NL@%
typedef struct {%@NL@%
    int ctl_type;                %@AB@%/* Type of control */%@AE@%%@NL@%
    int ctl_row;                %@AB@%/* row to display value name */%@AE@%%@NL@%
    int ctl_col;                %@AB@%/* column to display value name */%@AE@%%@NL@%
    int ctl_width;                %@AB@%/* width of value names */%@AE@%%@NL@%
    union {%@NL@%
        setControl_s  sc;%@NL@%
        azControl_s   az;%@NL@%
    } ctl_union;%@NL@%
} control_s;%@NL@%
%@NL@%
typedef union {%@NL@%
    struct {%@NL@%
        char *oaz_str;%@NL@%
        int   oaz_cur;                %@AB@%/* cursor position */%@AE@%%@NL@%
    } oaz;%@NL@%
    int   osc;%@NL@%
} option_u;%@NL@%
%@NL@%
control_s  control[] = {%@NL@%
    {OT_SET   ,rowPort          ,colPort    ,wPort    ,{nPort    ,csPort    }},%@NL@%
    {OT_SET   ,rowBaud          ,colBaud    ,wBaud    ,{nBaud    ,csBaud    }},%@NL@%
    {OT_SET   ,rowData          ,colData    ,wData    ,{nData    ,csData    }},%@NL@%
    {OT_SET   ,rowStop          ,colStop    ,wStop    ,{nStop    ,csStop    }},%@NL@%
    {OT_SET   ,rowParity  ,colParity  ,wParity  ,{nParity  ,csParity  }},%@NL@%
    {OT_SET   ,rowConnect ,colConnect ,wConnect ,{nConnect ,csConnect }},%@NL@%
    {OT_SET   ,rowDial    ,colDial    ,wDial    ,{nDial    ,csDial    }},%@NL@%
    {OT_SET   ,rowTone    ,colTone    ,wTone    ,{nTone    ,csTone    }},%@NL@%
    {OT_SET   ,rowCarrier ,colCarrier ,wCarrier ,{nCarrier ,csCarrier }},%@NL@%
    {OT_ASCIIZ,rowPhone   ,colPhone   ,wPhone   ,{sPhone              }},%@NL@%
    {OT_ASCIIZ,rowFile          ,colFile    ,wFile    ,{sFile                      }}%@NL@%
};%@NL@%
%@NL@%
option_u option[] = {                 %@AB@%/* Current option settings */%@AE@%%@NL@%
        {0},                        %@AB@%/* port        */%@AE@%%@NL@%
        {0},                        %@AB@%/* baud        */%@AE@%%@NL@%
        {0},                        %@AB@%/* data bits   */%@AE@%%@NL@%
        {0},                        %@AB@%/* stop bits   */%@AE@%%@NL@%
        {0},                        %@AB@%/* parity      */%@AE@%%@NL@%
        {0},                        %@AB@%/* connect     */%@AE@%%@NL@%
        {0},                        %@AB@%/* dial type   */%@AE@%%@NL@%
        {0},                        %@AB@%/* wait tone   */%@AE@%%@NL@%
        {0},                        %@AB@%/* wait carrier*/%@AE@%%@NL@%
        {strPhone,0},                %@AB@%/* phone       */%@AE@%%@NL@%
        {strFile ,0}                %@AB@%/* file        */%@AE@%%@NL@%
};%@NL@%
%@AI@%#define %@AE@%nOption    (sizeof(option)/sizeof(option_u)) %@NL@%
%@NL@%
static char         AttrPanel  = COLOR_PANEL,%@NL@%
                     AttrOption = COLOR_OPTION,%@NL@%
                      AttrCursor = COLOR_CURSOR;%@NL@%
static int        N_of_Cols,                %@AB@%/* number of columns on screen */%@AE@%%@NL@%
                N_of_Rows;                %@AB@%/* number of rows on screen */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***         get_options - get COM port settings and modem settings%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine determines the type of display and sets the display%@NL@%
%@AB@% *        attributes appropriately. If a filename was specified in the command%@NL@%
%@AB@% *        line, it opens the file and displays the COM port and the MODEM options%@NL@%
%@AB@% *        from the file. These options may be modified but the modifications will%@NL@%
%@AB@% *        not be written out to the file. If the file open failed, or, if no file%@NL@%
%@AB@% *        was specified in the command line, this routine wil display the default%@NL@%
%@AB@% *        options on the screen. The user may modify the options and it will be%@NL@%
%@AB@% *        writen out to the file specified in the options screen.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        get_options(argc,argv)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                argc - number of command line arguments%@NL@%
%@AB@% *                argv - pointer to an array of pointers (to command line args)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
void get_options(argc, argv)%@NL@%
int         argc;%@NL@%
char         *argv[];%@NL@%
{%@NL@%
        FILE                *fp;%@NL@%
        char                OptionsSet = FALSE; %@AB@%/* indicate if options are set  */%@AE@%%@NL@%
        unsigned        RetCode;%@NL@%
        static VIOCONFIGINFO DispConfigData = {sizeof(DispConfigData),};%@NL@%
%@NL@%
        %@AB@%/* if the display is monochrome, change the attributes */%@AE@%%@NL@%
        if ((RetCode = VioGetConfig(RESERVED,&DispConfigData,RESERVED)) != 0)%@NL@%
          error(ERR_VIOGETCONFIG, RetCode);%@NL@%
        if ((DispConfigData.adapter == MONOCHROME) ||%@NL@%
            (DispConfigData.display == MONOCHROME)) {%@NL@%
          AttrPanel  = MONO_PANEL;%@NL@%
          AttrOption = MONO_OPTION;%@NL@%
          AttrCursor = MONO_CURSOR;%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
        if (argc > 1) {          %@AB@%/* get com/modem settings from the file */%@AE@%%@NL@%
          if ((fp = fopen(argv[1], "r")) != NULL) {%@NL@%
%@NL@%
            %@AB@%/* clear the phone-number and file-name string buffers */%@AE@%%@NL@%
            strnset(strPhone, ' ', wPhone+1);%@NL@%
            strnset(strFile, ' ', sFile+1);%@NL@%
%@NL@%
            %@AB@%/* read the option settings from the file */%@AE@%%@NL@%
            fscanf(fp, "%d %d %d %d %d %d %d %d %d \n",%@NL@%
                   &option[PORT_NAME].osc, &option[BAUD_RATE].osc, %@NL@%
                   &option[DATA_BITS].osc, &option[STOP_BITS].osc, %@NL@%
                   &option[PARITY].osc, &option[CONNECT].osc, %@NL@%
                   &option[DIAL_TYPE].osc, &option[WAIT_TONE].osc, %@NL@%
                   &option[WAIT_CARRIER].osc);%@NL@%
            fscanf(fp, "%21s \n", option[PHONE_NUMBER].oaz.oaz_str);%@NL@%
            fscanf(fp, "%41s \n", option[SETUP_FILE].oaz.oaz_str);%@NL@%
            printf("file name = %s \n", option[SETUP_FILE].oaz.oaz_str);%@NL@%
            option[PHONE_NUMBER].oaz.oaz_cur = 0;  %@AB@%/* init cursor position */%@AE@%%@NL@%
            option[SETUP_FILE].oaz.oaz_cur = 0;    %@AB@%/* init cursor position */%@AE@%%@NL@%
%@NL@%
            %@AB@%/* show the options on the screen */%@AE@%%@NL@%
                screen_init();                %@AB@%/* init the physical screen */%@AE@%%@NL@%
                option_init();%@NL@%
                show_option();%@NL@%
%@NL@%
            OptionsSet = TRUE;%@NL@%
            fclose(fp);%@NL@%
          }%@NL@%
        }%@NL@%
%@NL@%
        if (!OptionsSet) {                %@AB@%/* get options from the user */%@AE@%%@NL@%
              screen_init();                        %@AB@%/* init the physical screen */%@AE@%%@NL@%
              option_init();%@NL@%
              show_option();%@NL@%
          %@AB@%/* write option settings to the file specified. */%@AE@%%@NL@%
          if ((fp = fopen(option[SETUP_FILE].oaz.oaz_str, "w")) != NULL) {%@NL@%
            DosHoldSignal(HLDSIG_DISABLE);%@NL@%
            fprintf(fp, "%d %d %d %d %d %d %d %d %d \n",%@NL@%
                    option[PORT_NAME].osc, option[BAUD_RATE].osc, %@NL@%
                    option[DATA_BITS].osc, option[STOP_BITS].osc, %@NL@%
                    option[PARITY].osc, option[CONNECT].osc, %@NL@%
                    option[DIAL_TYPE].osc, option[WAIT_TONE].osc, %@NL@%
                    option[WAIT_CARRIER].osc);%@NL@%
            fprintf(fp, "%21s \n", option[PHONE_NUMBER].oaz.oaz_str);%@NL@%
            fprintf(fp, "%41s \n", option[SETUP_FILE].oaz.oaz_str);%@NL@%
            fclose(fp);%@NL@%
            DosHoldSignal(HLDSIG_ENABLE);}%@NL@%
        } %@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        get_com_options - get Com port options%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine copies the current com port options into a structure%@NL@%
%@AB@% *        provided by the caller. %@NL@%
%@AB@% *%@NL@%
%@AB@% *        get_com_options(psComOptions)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                psComOptions = ptr to structure of com port options%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                the structure pointed by psComOptions is filled with com %@NL@%
%@AB@% *                port options%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
void get_com_options(psComOptions)%@NL@%
structComOptions *psComOptions;                %@AB@%/* ptr to struct of com port options */%@AE@%%@NL@%
{%@NL@%
        psComOptions->pPortName  = csPort[(option[PORT_NAME].osc)];%@NL@%
        psComOptions->iBaudRate  = intBaud[(option[BAUD_RATE].osc)];%@NL@%
        psComOptions->chDataBits = chData[(option[DATA_BITS].osc)];%@NL@%
        psComOptions->chStopBits = chStop[(option[STOP_BITS].osc)];%@NL@%
        psComOptions->chParity   = chParity[(option[PARITY].osc)];%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        get_modem_options - get modem options%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine copies the current modem options into a structure%@NL@%
%@AB@% *        provided by the caller. %@NL@%
%@AB@% *%@NL@%
%@AB@% *        get_modem_options(psModemOptions)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                psModemOptions = ptr to structure of modem options%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                the structure pointed by psModemOptions is filled with %@NL@%
%@AB@% *                modem options%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
void get_modem_options(psModemOptions)%@NL@%
structModemOptions *psModemOptions;        %@AB@%/* ptr to struct of modem options */%@AE@%%@NL@%
{%@NL@%
        psModemOptions->chDialType   = chDial[(option[DIAL_TYPE].osc)];%@NL@%
        psModemOptions->iWaitTone    = iTone[(option[WAIT_TONE].osc)];%@NL@%
        psModemOptions->iWaitCarrier = iCarrier[(option[WAIT_CARRIER].osc)];%@NL@%
        psModemOptions->pPhoneNumber = option[PHONE_NUMBER].oaz.oaz_str;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        modem - determines if modem connection was requested%@NL@%
%@AB@% *%@NL@%
%@AB@% *        modem()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                modem = TRUE if modem connection was requested%@NL@%
%@AB@% *                        FALSE otherwise%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
modem()%@NL@%
{%@NL@%
        return (chConnect[(option[CONNECT].osc)] == MODEM);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        clear_screen - blank out the entire screen%@NL@%
%@AB@% *%@NL@%
%@AB@% *        clear_screen()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
clear_screen()%@NL@%
{%@NL@%
    Cell                 c;%@NL@%
    int                        RetCode;%@NL@%
%@NL@%
    c.ch = ' ';%@NL@%
    c.at = ATTR(WHITE,BLACK);%@NL@%
    if ((RetCode = VioWrtNCell((PBYTE)(&c), N_of_Rows*N_of_Cols,%@NL@%
                               0, 0, RESERVED)) != 0)%@NL@%
      error(ERR_VIOWRTNCELL, RetCode);%@NL@%
}   %@AB@%/* clear_screen */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        option_init - initialize option screen%@NL@%
%@AB@% *%@NL@%
%@AB@% *        option_init()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
option_init()%@NL@%
{%@NL@%
            int                 i;%@NL@%
%@NL@%
            O_ROW = (N_of_Rows - O_HEIGHT)/2;%@NL@%
            O_COL = (N_of_Cols - O_WIDTH)/2;%@NL@%
            for (i=0; i<nOption; i++) {   %@AB@%/* adjust to real screen coordinates */%@AE@%%@NL@%
          control[i].ctl_row += O_ROW;%@NL@%
          control[i].ctl_col += O_COL;%@NL@%
            }%@NL@%
            init_cmap();%@NL@%
}           %@AB@%/* option_init */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        init_cmap - initialise valid character set%@NL@%
%@AB@% *%@NL@%
%@AB@% *        init_cmap()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
init_cmap()%@NL@%
{%@NL@%
            register int         i;%@NL@%
%@NL@%
            for (i=0; i<256; i++)%@NL@%
          cMap[i] = 0;%@NL@%
            for (i='a'; i<='z'; i++)%@NL@%
          cMap[i] |= Z_ALPHA;%@NL@%
            for (i='A'; i<='Z'; i++)%@NL@%
          cMap[i] |= Z_ALPHA;%@NL@%
            for (i='0'; i<='9'; i++)%@NL@%
          cMap[i] |= Z_DIGIT;%@NL@%
            cMap[':']  |= Z_PATH;%@NL@%
            cMap['\\'] |= Z_PATH;%@NL@%
            cMap['/']  |= Z_PATH;%@NL@%
            cMap['.']  |= Z_PATH;%@NL@%
            cMap['-']  |= Z_PATH;%@NL@%
            cMap[' ']  |= Z_WHITE;%@NL@%
            cMap['\t'] |= Z_WHITE;%@NL@%
            cMap['-']  |= Z_PHONE;%@NL@%
            cMap[',']  |= Z_PHONE;%@NL@%
}           %@AB@%/* init_cmap */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        show_option - display option screen and record user modifications%@NL@%
%@AB@% *%@NL@%
%@AB@% *        show_option()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
show_option()%@NL@%
{%@NL@%
        int                RetCode;%@NL@%
%@NL@%
            do_option();%@NL@%
        clear_screen();%@NL@%
        if ((RetCode = VioSetCurPos(0, 0, RESERVED)) != 0)%@NL@%
          error(ERR_VIOSETCURPOS, RetCode);%@NL@%
}           %@AB@%/* show_option */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        do_option - show and update option screen%@NL@%
%@AB@% *%@NL@%
%@AB@% *        do_option()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
do_option()%@NL@%
{%@NL@%
        USHORT                row, col;%@NL@%
        BYTE                a;%@NL@%
            int                 RetCode,%@NL@%
                        i,%@NL@%
                            key,%@NL@%
                            iOpt,lastOpt;%@NL@%
%@NL@%
            a = AttrPanel;%@NL@%
            for (row=0; row<O_HEIGHT; row++)            %@AB@%/* display option panel */%@AE@%%@NL@%
          if ((RetCode = VioWrtCharStrAtt(optScreen[row],O_WIDTH,row+O_ROW,%@NL@%
                                          O_COL, &a, RESERVED)) != 0)%@NL@%
            error(ERR_VIOWRTCHARSTRATT, RetCode);%@NL@%
            for (i=0; i<nOption; i++)           %@AB@%/* Fill in options */%@AE@%%@NL@%
          show_opt(i, AttrOption);%@NL@%
%@NL@%
            key = 0;%@NL@%
            iOpt = 0;        %@AB@%/* Start with first option */%@AE@%%@NL@%
            lastOpt = iOpt;%@NL@%
            while (key != ENTER_KEY) {%@NL@%
          if (iOpt != lastOpt)            %@AB@%/* user moved to different field */%@AE@%%@NL@%
            show_opt(lastOpt, AttrOption); %@AB@%/* revert to normal color */%@AE@%%@NL@%
          show_opt(iOpt, AttrCursor);        %@AB@%/* highlight current field */%@AE@%%@NL@%
          lastOpt = iOpt;%@NL@%
          key = get_key();%@NL@%
          switch (key) {%@NL@%
            case UP_KEY:%@NL@%
                        if (--iOpt < 0)%@NL@%
                              iOpt = nOption - 1;%@NL@%
                        break;%@NL@%
            case DOWN_KEY:%@NL@%
                        if (++iOpt > (nOption - 1))%@NL@%
                              iOpt = 0;%@NL@%
                        break;%@NL@%
            case RIGHT_KEY:%@NL@%
                        mod_option(iOpt,  1);%@NL@%
                        break;%@NL@%
            case LEFT_KEY:%@NL@%
                        mod_option(iOpt, -1);%@NL@%
                        break;%@NL@%
            case DEL_KEY:%@NL@%
                        if (control[iOpt].ctl_type == OT_ASCIIZ)%@NL@%
                              do_right_del(iOpt);%@NL@%
                        break;%@NL@%
            case HOME_KEY:%@NL@%
                        if (control[iOpt].ctl_type == OT_ASCIIZ)%@NL@%
                              option[iOpt].oaz.oaz_cur = 0;%@NL@%
                        break;%@NL@%
            case BKSP_KEY:%@NL@%
                        if (control[iOpt].ctl_type == OT_ASCIIZ)%@NL@%
                              do_left_del(iOpt);%@NL@%
                        break;%@NL@%
            default:%@NL@%
                        switch (control[iOpt].ctl_type) {%@NL@%
                          case OT_SET:    %@AB@%/* Ignore other key strokes */%@AE@%%@NL@%
                                        break;%@NL@%
                          case OT_ASCIIZ:%@NL@%
                                        do_insert(iOpt,key);%@NL@%
                                        break;%@NL@%
                              default:%@NL@%
                                        error(ERR_DO_OPT_INVOPT, NO_RETCODE);%@NL@%
                        }%@NL@%
                        break;%@NL@%
          }           %@AB@%/* switch */%@AE@%%@NL@%
            }        %@AB@%/* while */%@AE@%%@NL@%
}           %@AB@%/* do_option */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        do_insert - insert character in a string%@NL@%
%@AB@% *%@NL@%
%@AB@% *        do_insert(iOpt,key)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                iOpt = which option (setup File or Phone Number)%@NL@%
%@AB@% *                key  = character to insert%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                char inserted into string (setup File name or Phone Number)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
do_insert(iOpt,key)%@NL@%
int          iOpt;%@NL@%
unsigned key;%@NL@%
{%@NL@%
            int           ch;%@NL@%
            int           cur;%@NL@%
            int           i,n;%@NL@%
            int           width;%@NL@%
            char         *s,*d,*p;%@NL@%
%@NL@%
            ch = key >> 8;%@NL@%
            if (ch > 0x7F)        %@AB@%/* Ignore */%@AE@%%@NL@%
          return(0);%@NL@%
            if ((cMap[ch] & control[iOpt].ctl_union.az.az_Set) == 0)%@NL@%
          return(0);         %@AB@%/* Not valid char */%@AE@%%@NL@%
%@NL@%
            %@AB@%/*        oaz_cur - points to insertion point%@NL@%
%@AB@%                We throw away characters at end of string.%@NL@%
%@AB@%%@NL@%
%@AB@%                before: aaaaaaabbbbbbbbbbbbc%@NL@%
%@AB@%                               ^%@NL@%
%@AB@%                after:        aaaaaaaxbbbbbbbbbbbb%@NL@%
%@AB@%                                ^%@NL@%
%@AB@%            */%@AE@%%@NL@%
            cur = option[iOpt].oaz.oaz_cur;%@NL@%
            width = control[iOpt].ctl_width;%@NL@%
            p = option[iOpt].oaz.oaz_str;%@NL@%
%@NL@%
            d = p+width-1;                %@AB@%/* End of string */%@AE@%%@NL@%
            s = d-1;                %@AB@%/* End of string - 1 */%@AE@%%@NL@%
            n = (width-cur)-1;        %@AB@%/* Number of chars to shift */%@AE@%%@NL@%
            for (i=n; i>0; i--)%@NL@%
          *d-- = *s--;                %@AB@%/* Shift string */%@AE@%%@NL@%
            p[cur] = ch;                %@AB@%/* Insert character */%@AE@%%@NL@%
            cur++;                        %@AB@%/* Advance insertion point */%@AE@%%@NL@%
            if (cur > (width-1))    %@AB@%/* cursor wrapped */%@AE@%%@NL@%
          cur = 0;%@NL@%
            option[iOpt].oaz.oaz_cur = cur;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        do_left_del - delete a character which is to the left of the cursor%@NL@%
%@AB@% *%@NL@%
%@AB@% *        do_left_del(iOpt)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                iOpt = which option (setup File or Phone Number)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                char deleted from string (setup File name or Phone Number)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
do_left_del(iOpt)%@NL@%
int         iOpt;%@NL@%
{%@NL@%
            if (option[iOpt].oaz.oaz_cur != 0)        %@AB@%/* Ignore at start of field */%@AE@%%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                We delete the character to the left of the cursor and shift%@NL@%
%@AB@%                rest of characters left 1.  Ignore at beginning of field.%@NL@%
%@AB@%%@NL@%
%@AB@%                before: aaaaaaaxbbbbbbbbbbbb%@NL@%
%@AB@%                                ^%@NL@%
%@AB@%                after:        aaaaaaabbbbbbbbbbbb%@NL@%
%@AB@%                                      ^%@NL@%
%@AB@%            */%@AE@%%@NL@%
            do_del(iOpt,0,-1);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        do_right_del - delete a character which is at the cursor%@NL@%
%@AB@% *%@NL@%
%@AB@% *         do_right_del(iOpt)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                iOpt = which option (setup File or Phone Number)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                char deleted from string (setup File name or Phone Number)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
do_right_del(iOpt)%@NL@%
int         iOpt;%@NL@%
{%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                We delete the character at the cursor and shift%@NL@%
%@AB@%                rest of characters left 1.%@NL@%
%@AB@%%@NL@%
%@AB@%                before: aaaaaaaxbbbbbbbbbbbb%@NL@%
%@AB@%                                      ^%@NL@%
%@AB@%                after:        aaaaaaabbbbbbbbbbbb%@NL@%
%@AB@%                               ^%@NL@%
%@AB@%            */%@AE@%%@NL@%
            do_del(iOpt,1,0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        do_del - delete a character%@NL@%
%@AB@% *%@NL@%
%@AB@% *        do_del(iOpt,iShift,iCur)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                iOpt = which option (setup File or Phone Number)%@NL@%
%@AB@% *                iShift = amount by which string should be shifted%@NL@%
%@AB@% *                iCur = amount by which cursor should be moved%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                char deleted from string (setup File name or Phone Number)%@NL@%
%@AB@% *                cursor position within the string updated%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
do_del(iOpt,iShift,iCur)%@NL@%
int         iOpt,%@NL@%
        iShift,%@NL@%
        iCur;%@NL@%
{%@NL@%
            int         cur,width,i,n;%@NL@%
            char         *s,*d,*p;%@NL@%
%@NL@%
            cur = option[iOpt].oaz.oaz_cur;%@NL@%
            width = control[iOpt].ctl_width;%@NL@%
            p = option[iOpt].oaz.oaz_str;%@NL@%
%@NL@%
            s = p+cur+iShift;%@NL@%
            d = s-1;%@NL@%
            n = (width-(cur+iCur))-1;        %@AB@%/* Number of chars to shift */%@AE@%%@NL@%
            for (i=n; i>0; i--)%@NL@%
          *d++ = *s++;                        %@AB@%/* Shift string */%@AE@%%@NL@%
            cur += iCur;                        %@AB@%/* Adjust cursor */%@AE@%%@NL@%
            p[width-1] = ' ';                %@AB@%/* Put blank at end */%@AE@%%@NL@%
            option[iOpt].oaz.oaz_cur = cur;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        mod_option - modify option%@NL@%
%@AB@% *%@NL@%
%@AB@% *        mod_option(iOpt, inc)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                iOpt = which option (Port, Baud Rate, ..., setup File)%@NL@%
%@AB@% *                inc  =  1 ( -> key was pressed)%@NL@%
%@AB@% *                       -1 ( <- key was pressed)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                option array entry 'osc' updated for all iOpt except for %@NL@%
%@AB@% *                setupFile and PhoneNumber. In the case of setupFile and %@NL@%
%@AB@% *                PhoneNumber, the cursor position is updated (cursor moved %@NL@%
%@AB@% *                left if '<-' key was pressed; cursor moved right if '->' %@NL@%
%@AB@% *                key was pressed)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
mod_option(iOpt, inc)%@NL@%
int         iOpt,%@NL@%
        inc;%@NL@%
{%@NL@%
            int         col;%@NL@%
            int         width;%@NL@%
%@NL@%
    switch (control[iOpt].ctl_type) {%@NL@%
        case OT_SET:        %@AB@%/* Ignore other key strokes */%@AE@%%@NL@%
            if (inc > 0) {  %@AB@%/* Increment value */%@AE@%%@NL@%
                if (++option[iOpt].osc > (control[iOpt].ctl_union.sc.sc_n - 1))%@NL@%
                    option[iOpt].osc = 0;%@NL@%
            }%@NL@%
            else            %@AB@%/* Decrement value */%@AE@%%@NL@%
                if (--option[iOpt].osc < 0 )%@NL@%
                    option[iOpt].osc = control[iOpt].ctl_union.sc.sc_n - 1;%@NL@%
            break;%@NL@%
        case OT_ASCIIZ:%@NL@%
            col = option[iOpt].oaz.oaz_cur;%@NL@%
            width = control[iOpt].ctl_width;%@NL@%
            if (inc > 0) {  %@AB@%/* move cursor right */%@AE@%%@NL@%
                if (++col > (width-1))%@NL@%
                    col = 0;%@NL@%
            }%@NL@%
            else            %@AB@%/* move cursor left */%@AE@%%@NL@%
                if (--col < 0 )%@NL@%
                    col = (width-1);%@NL@%
            option[iOpt].oaz.oaz_cur = col;%@NL@%
            break;%@NL@%
        default:%@NL@%
            error(ERR_MOD_OPT_INVOPT, NO_RETCODE);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        show_opt - show option%@NL@%
%@AB@% *%@NL@%
%@AB@% *        show_opt(iOpt, color)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                iOpt = which option (Port, Baud Rate, . . ., Phone Number)%@NL@%
%@AB@% *                color = color in which the option is to be displayed%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                option indicated by iOpt is displayed on the screen%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
show_opt(iOpt, color)%@NL@%
int        iOpt;%@NL@%
char        color;%@NL@%
{%@NL@%
        USHORT                row,col,width,%@NL@%
                        curCol;%@NL@%
            char                 *name;%@NL@%
            unsigned         RetCode;%@NL@%
%@NL@%
            row = control[iOpt].ctl_row;%@NL@%
            col = control[iOpt].ctl_col;%@NL@%
            width = control[iOpt].ctl_width;%@NL@%
            switch (control[iOpt].ctl_type) {%@NL@%
          case OT_SET:%@NL@%
            name = control[iOpt].ctl_union.sc.sc_name[option[iOpt].osc];%@NL@%
            curCol = col+width-1;%@NL@%
            break;%@NL@%
          case OT_ASCIIZ:%@NL@%
            name = option[iOpt].oaz.oaz_str;%@NL@%
            curCol = col+option[iOpt].oaz.oaz_cur;%@NL@%
            break;%@NL@%
          default:%@NL@%
            error(ERR_SHOW_OPT_INVOPT, NO_RETCODE);%@NL@%
            };%@NL@%
        if ((RetCode = VioWrtCharStrAtt(name, width, row, col,%@NL@%
                                        &color, RESERVED)) != 0)%@NL@%
          error(ERR_VIOWRTCHARSTRATT, RetCode);%@NL@%
        if ((RetCode = VioSetCurPos(row, curCol, RESERVED)) != 0)%@NL@%
          error(ERR_VIOSETCURPOS, RetCode);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        get_key - return two-byte key stroke; includes IBM extended ASCII codes%@NL@%
%@AB@% *%@NL@%
%@AB@% *        get_key()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
get_key()%@NL@%
{%@NL@%
    char         c;%@NL@%
    unsigned         key;%@NL@%
%@NL@%
    if (c = getch())                    %@AB@%/* Get character */%@AE@%%@NL@%
      key = c << 8;                    %@AB@%/* Make scan code zero */%@AE@%%@NL@%
    else%@NL@%
      key = getch();                    %@AB@%/* Get scan code */%@AE@%%@NL@%
    return(key);%@NL@%
}   %@AB@%/* get_key */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        screen_init - Initialize the screen%@NL@%
%@AB@% *%@NL@%
%@AB@% *        screen_init()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
screen_init()%@NL@%
{%@NL@%
        VIOMODEINFO TheModeData;    %@AB@%/* Mode data from VioGetMode */%@AE@%%@NL@%
        int            RetCode;%@NL@%
%@NL@%
        if ((RetCode = VioGetMode(&TheModeData, RESERVED)) != 0)%@NL@%
          error(ERR_VIOGETMODE, RetCode);%@NL@%
            N_of_Cols = TheModeData.col;%@NL@%
            N_of_Rows = TheModeData.row;%@NL@%
        clear_screen();%@NL@%
}           %@AB@%/* screen_init */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%OPTIONS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SPY\OPTIONS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* options.c - Spy code for several options type dialogs%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%       INCL_WINBUTTONS %@NL@%
%@AI@%#define %@AE@%       INCL_WINDIALOGS %@NL@%
       INCL_WINHEAP                %@AB@%/* needed for spy.h */%@AE@%%@NL@%
%@AI@%#define %@AE@%       INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%       INCL_WINMESSAGEMGR %@NL@%
       INCL_WINPOINTERS        %@AB@%/* needed for spy.h */%@AE@%%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"spyhook.h" %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<time.h> %@NL@%
%@AI@%#include %@AE@%"spy.h" %@NL@%
%@NL@%
%@AB@%/* Prototypes */%@AE@%%@NL@%
MRESULT EXPENTRY SpyOutputsDlgProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT EXPENTRY SpySaveListDlgProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT EXPENTRY AboutWndProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* MRESULT EXPENTRY SpyOutputsDlgProc (hwnd, msg, mp1, mp2)%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY SpyOutputsDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND            hwnd;%@NL@%
USHORT          msg;%@NL@%
MPARAM          mp1;%@NL@%
MPARAM          mp2;%@NL@%
{%@NL@%
    USHORT      wAction;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_INITDLG:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Now initialize the output options in the dialog%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinSendDlgItemMsg(hwnd, DID_WINDOW, BM_SETCHECK,%@NL@%
            (MPARAM)spyopt.fWindow, 0L);%@NL@%
        WinSendDlgItemMsg(hwnd, DID_FILE, BM_SETCHECK,%@NL@%
            (MPARAM)spyopt.fFile, 0L);%@NL@%
%@NL@%
        WinSetDlgItemShort(hwnd, DID_WINDOWLINES, spyopt.cWindowLines, FALSE);%@NL@%
        WinSetDlgItemText(hwnd, DID_FILENAME, spystr.szFileName);%@NL@%
%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1)) {%@NL@%
        case DID_OK:%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Now retrieve the output options from the%@NL@%
%@AB@%             * dialog%@NL@%
%@AB@%             */%@AE@%%@NL@%
            spyopt.fWindow = (BOOL)SHORT1FROMMR(WinSendDlgItemMsg(hwnd,%@NL@%
                DID_WINDOW, BM_QUERYCHECK, 0L, 0L));%@NL@%
            spyopt.fFile = (BOOL)SHORT1FROMMR(WinSendDlgItemMsg(hwnd,%@NL@%
                DID_FILE, BM_QUERYCHECK, 0L, 0L));%@NL@%
%@NL@%
            WinQueryDlgItemShort(hwnd, DID_WINDOWLINES, &spyopt.cWindowLines, FALSE);%@NL@%
            WinQueryDlgItemText(hwnd, DID_FILENAME,%@NL@%
                sizeof(spystr.szFileName), spystr.szFileName);%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Now take care of file operations%@NL@%
%@AB@%             * If a file is already active, we will continue to use it, and%@NL@%
%@AB@%             * ignore the case where the user may have changed file names%@NL@%
%@AB@%             * Will truncate any file.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (spyopt.fFile) {%@NL@%
                 if (spyopt.hfileSpy == NULL)%@NL@%
                    if (DosOpen((PSZ)spystr.szFileName, &spyopt.hfileSpy,%@NL@%
                            (USHORT far *)&wAction, 0L, 0,%@NL@%
                            0x0012, 0x00C1, 0L) != 0)%@NL@%
                        spyopt.hfileSpy = NULL; %@AB@%/* Failed on open */%@AE@%%@NL@%
            } else {%@NL@%
                if (spyopt.hfileSpy != NULL) {%@NL@%
                    %@AB@%/* file open, not outputing, close it now */%@AE@%%@NL@%
                    DosClose (spyopt.hfileSpy);%@NL@%
                    spyopt.hfileSpy = NULL;%@NL@%
                }%@NL@%
            }%@NL@%
            %@AB@%/* Fall through to DID_CANCEL */%@AE@%%@NL@%
        case DID_CANCEL:%@NL@%
            %@AB@%/* Now dismiss the dialog */%@AE@%%@NL@%
            WinDismissDlg(hwnd, SHORT1FROMMP(mp1));%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* MRESULT EXPENTRY SpySaveListDlgProc(hwnd, msg, mp1, mp2)%@NL@%
%@AB@%*%@NL@%
%@AB@%* The Spy Windows Dialog procedure%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY SpySaveListDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    HFILE   hfileOut;%@NL@%
    char    szTemp[100];%@NL@%
    char    szTime[10];%@NL@%
    char    szDate[10];%@NL@%
    SHORT   cItems;%@NL@%
    SHORT   iItem;%@NL@%
    USHORT  cch;%@NL@%
    USHORT  cchWritten;%@NL@%
    USHORT  wAction;%@NL@%
    ULONG   lTemp;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_INITDLG:%@NL@%
        WinSendDlgItemMsg(hwnd, DID_APPEND, BM_SETCHECK,%@NL@%
            (MPARAM)spyopt.fAppend, 0L);%@NL@%
        %@AB@%/* Initialize the dialog items */%@AE@%%@NL@%
        WinSetDlgItemText(hwnd, DID_FILENAME, spystr.szSaveFileName);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1)) {%@NL@%
        case DID_OK:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Get the file name, and try to open the file,%@NL@%
%@AB@%             * Then loop through and dump the listbox contents to the%@NL@%
%@AB@%             * file.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            spyopt.fAppend = (BOOL)SHORT1FROMMR(WinSendDlgItemMsg(hwnd,%@NL@%
                DID_APPEND, BM_QUERYCHECK, 0L, 0L));%@NL@%
%@NL@%
            WinQueryDlgItemText(hwnd, DID_FILENAME,%@NL@%
                sizeof(spystr.szSaveFileName), spystr.szSaveFileName);%@NL@%
%@NL@%
            if (DosOpen((PSZ)spystr.szSaveFileName, (HFILE far *)&hfileOut,%@NL@%
                    (USHORT far *)&wAction, 0L, 0,%@NL@%
                    spyopt.fAppend? 0x0011 : 0x0012, 0x00C1, 0L) == 0) {%@NL@%
%@NL@%
                %@AB@%/* If append, get to the end of the file */%@AE@%%@NL@%
                if (spyopt.fAppend)%@NL@%
                    DosChgFilePtr(hfileOut, 0L, 2, (PULONG)&lTemp);%@NL@%
%@NL@%
                %@AB@%/* Get count of items */%@AE@%%@NL@%
                cItems = SHORT1FROMMR(WinSendMsg(hwndSpyList, LM_QUERYITEMCOUNT,%@NL@%
                            0L, 0L));%@NL@%
%@NL@%
                %@AB@%/* Write out a title block to the file */%@AE@%%@NL@%
                _strdate(szDate);%@NL@%
                _strtime(szTime);%@NL@%
                DosWrite(hfileOut,%@NL@%
                        (PSZ)"***************************************\r\n",%@NL@%
                                41, (PUSHORT)&cchWritten);%@NL@%
                cch = sprintf(szTemp, "* Spy: %-10s %-10s          *\r\n",%@NL@%
                    szDate, szTime);%@NL@%
                DosWrite(hfileOut, (PSZ)szTemp, cch, (PUSHORT)&cchWritten);%@NL@%
%@NL@%
                DosWrite(hfileOut,%@NL@%
                        (PSZ)"***************************************\r\n",%@NL@%
                                41, (PUSHORT)&cchWritten);%@NL@%
%@NL@%
%@NL@%
                        %@AB@%/* Now output the list to the file */%@AE@%%@NL@%
                for (iItem = 0; iItem < cItems; iItem++) {%@NL@%
                    cch = SHORT1FROMMR(WinSendMsg(hwndSpyList, LM_QUERYITEMTEXT,%@NL@%
                            MPFROM2SHORT(iItem, sizeof(szTemp)),%@NL@%
                            (MPARAM)(PSZ)szTemp));%@NL@%
                    %@AB@%/* Add Newline at end of string */%@AE@%%@NL@%
                    szTemp[cch++] = '\r';%@NL@%
                    szTemp[cch++] = '\n';%@NL@%
                    szTemp[cch] = '\0';%@NL@%
                    DosWrite(hfileOut, (PSZ)szTemp, cch,%@NL@%
                            (PUSHORT)&cchWritten);%@NL@%
                }%@NL@%
                DosClose(hfileOut);%@NL@%
            }%@NL@%
%@NL@%
        case DID_CANCEL:%@NL@%
            %@AB@%/* Now dismiss the dialog */%@AE@%%@NL@%
            WinDismissDlg(hwnd, SHORT1FROMMP(mp1));%@NL@%
            break;%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/**************************************************************************\%@NL@%
%@AB@%* AboutWndProc(HWND hwnd, USHORT message, MPARAM mp1, MPARAM mp2)%@NL@%
%@AB@%*%@NL@%
%@AB@%* About Spy... Dialog procedure%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY AboutWndProc(hwnd, message, mp1, mp2)%@NL@%
HWND    hwnd;%@NL@%
USHORT  message;%@NL@%
MPARAM   mp1;%@NL@%
MPARAM   mp2;%@NL@%
{%@NL@%
    switch (message) {%@NL@%
        case WM_COMMAND:%@NL@%
            WinDismissDlg(hwnd, TRUE);%@NL@%
            break;%@NL@%
        default:%@NL@%
            return(WinDefDlgProc(hwnd, message, mp1, mp2));%@NL@%
            break;%@NL@%
    }%@NL@%
    return 0L;%@NL@%
%@NL@%
} %@AB@%/* end aboutwndproc */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PAINT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CLOCK\PAINT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    paint.c -- Paints the clock%@NL@%
%@AB@%%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"clock.h" %@NL@%
%@AI@%#include %@AE@%"dialogs.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%MATLF_SIZE ( sizeof ( MATRIXLF ) / sizeof ( LONG ) ) %@NL@%
%@NL@%
%@AI@%#define %@AE@%CLK_MAJORTICKS        0x0001 %@NL@%
%@AI@%#define %@AE@%CLK_MINORTICKS        0x0002 %@NL@%
%@NL@%
extern BOOL fIconic , fShowSecondHand ;%@NL@%
extern DATETIME dt ;%@NL@%
extern HPS hps ;%@NL@%
%@NL@%
VOID ClkPaint ( HWND ) ;%@NL@%
VOID ClkDrawHand ( HPS , SHORT , SHORT ) ;%@NL@%
VOID ClkDrawFace ( HPS ) ;%@NL@%
VOID ClkDrawTicks ( HPS , USHORT ) ;%@NL@%
%@NL@%
static FIXED fxSin [60] = {%@NL@%
    0x00000000, 0x00001ac2, 0x00003539, 0x00004f1b, 0x0000681f, 0x00007fff,%@NL@%
    0x00009679, 0x0000ab4c, 0x0000be3e, 0x0000cf1b, 0x0000ddb3, 0x0000e9de,%@NL@%
    0x0000f378, 0x0000fa67, 0x0000fe98, 0x0000ffff, 0x0000fe98, 0x0000fa67,%@NL@%
    0x0000f378, 0x0000e9de, 0x0000ddb3, 0x0000cf1b, 0x0000be3e, 0x0000ab4c,%@NL@%
    0x00009679, 0x00008000, 0x00006820, 0x00004f1b, 0x00003539, 0x00001ac2,%@NL@%
    0x00000000, 0xffffe53e, 0xffffcac7, 0xffffb0e5, 0xffff97e1, 0xffff8001,%@NL@%
    0xffff6988, 0xffff54b5, 0xffff41c2, 0xffff30e5, 0xffff224d, 0xffff1622,%@NL@%
    0xffff0c88, 0xffff0599, 0xffff0168, 0xffff0001, 0xffff0167, 0xffff0599,%@NL@%
    0xffff0c88, 0xffff1622, 0xffff224d, 0xffff30e5, 0xffff41c2, 0xffff54b4,%@NL@%
    0xffff6987, 0xffff8000, 0xffff97e0, 0xffffb0e4, 0xffffcac6, 0xffffe53e%@NL@%
} ;%@NL@%
%@NL@%
USHORT usMajorTickPref = CLKTM_ALWAYS ;%@NL@%
USHORT usMinorTickPref = CLKTM_NOTICONIC ;%@NL@%
LONG clrBackground = CLR_DARKCYAN ;%@NL@%
LONG clrFace = CLR_CYAN ;%@NL@%
LONG clrHourHand = CLR_PINK ;%@NL@%
LONG clrMinuteHand = CLR_DARKPINK ;%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkPaint()  -- Paints the clock client window%@NL@%
%@AB@%*/%@AE@%%@NL@%
VOID ClkPaint ( HWND hwnd )%@NL@%
{%@NL@%
    RECTL rclUpdate ;%@NL@%
%@NL@%
    %@AB@%/* fill the invalid rectangle */%@AE@%%@NL@%
    WinBeginPaint ( hwnd , hps , & rclUpdate ) ;%@NL@%
    WinFillRect ( hps , & rclUpdate , clrBackground ) ;%@NL@%
%@NL@%
    %@AB@%/* draw the face, the hour hand, and the minute hand */%@AE@%%@NL@%
    ClkDrawFace ( hps ) ;%@NL@%
    ClkDrawHand ( hps , HT_HOUR , dt . hours ) ;%@NL@%
    ClkDrawHand ( hps , HT_MINUTE , dt . minutes ) ;%@NL@%
%@NL@%
    %@AB@%/* draw the tick marks */%@AE@%%@NL@%
    if ( ( usMajorTickPref == CLKTM_ALWAYS ) ||%@NL@%
         ( ( usMajorTickPref == CLKTM_NOTICONIC ) && ! fIconic ) )%@NL@%
        ClkDrawTicks ( hps , CLK_MAJORTICKS ) ;%@NL@%
%@NL@%
    if ( ( usMinorTickPref == CLKTM_ALWAYS ) ||%@NL@%
         ( ( usMinorTickPref == CLKTM_NOTICONIC ) && ! fIconic ) )%@NL@%
        ClkDrawTicks ( hps , CLK_MINORTICKS ) ;%@NL@%
%@NL@%
    %@AB@%/* draw the second hand last, so xor will work */%@AE@%%@NL@%
    if ( fShowSecondHand )%@NL@%
        ClkDrawHand ( hps , HT_SECOND , dt . seconds ) ;%@NL@%
%@NL@%
    %@AB@%/* restore the presentation space */%@AE@%%@NL@%
    WinEndPaint ( hps ) ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkDrawHand() -- Draws specified hand at specified hour in given PS%@NL@%
%@AB@%*/%@AE@%%@NL@%
VOID ClkDrawHand ( HPS hps , SHORT sHandType , SHORT sAngle )%@NL@%
{%@NL@%
    static POINTL aptlHour [ ] = { { 8 , 0 } , { 0 , 60 } , { -8 , 0 } ,%@NL@%
                                   { 0 , -10 } , { 8 , 0 } } ;%@NL@%
    static POINTL aptlMinute [ ] = { { 6 , 0 } , { 0 , 80 } , { -6 , 0 } ,%@NL@%
                                     { 0 , -15 } , { 6 , 0 } } ;%@NL@%
    static POINTL aptlSecond [ ] = { { 0 , -15 } , { 0 , 85 } } ;%@NL@%
    static LONG cptlHour = sizeof ( aptlHour ) / sizeof ( POINTL ) ;%@NL@%
    static LONG cptlMinute = sizeof ( aptlMinute ) / sizeof ( POINTL ) ;%@NL@%
    static LONG cptlSecond = sizeof ( aptlSecond ) / sizeof ( POINTL ) ;%@NL@%
    BOOL f ;%@NL@%
    static MATRIXLF matlfModel = {%@NL@%
        MAKEFIXED ( 1 , 0 ) ,            MAKEFIXED ( 0 , 0 ) ,        0L ,%@NL@%
        MAKEFIXED ( 0 , 0 ) ,            MAKEFIXED ( 1 , 0 ) ,        0L ,%@NL@%
        100L ,                            100L ,                        1L } ;%@NL@%
%@NL@%
    %@AB@%/* prepare a rotation transform and set it into the ps */%@AE@%%@NL@%
    %@AB@%/*            cos x    - sin x        0     *\%@NL@%
%@AB@%    |            sin x      cos x        0      |%@NL@%
%@AB@%    \*            100        100        1     */%@AE@%%@NL@%
%@NL@%
    matlfModel . fxM11 =%@NL@%
    matlfModel . fxM22 = fxSin [ ( sAngle + 15 ) % 60 ] ;%@NL@%
    matlfModel . fxM12 = fxSin [ ( sAngle + 30 ) % 60 ] ;%@NL@%
    matlfModel . fxM21 = fxSin [ sAngle ] ;%@NL@%
    f = GpiSetModelTransformMatrix ( hps , ( LONG ) MATLF_SIZE ,%@NL@%
                                     & matlfModel , TRANSFORM_REPLACE ) ;%@NL@%
%@NL@%
    %@AB@%/* draw the specified hand */%@AE@%%@NL@%
%@NL@%
    switch ( sHandType ) {%@NL@%
%@NL@%
        case HT_HOUR:%@NL@%
            GpiSetColor ( hps , clrHourHand ) ;%@NL@%
            GpiBeginPath ( hps , 1L ) ;%@NL@%
            GpiSetCurrentPosition ( hps , aptlHour ) ;%@NL@%
            GpiPolyLine ( hps , cptlHour , aptlHour ) ;%@NL@%
            GpiEndPath ( hps ) ;%@NL@%
            GpiFillPath ( hps , 1L , FPATH_ALTERNATE ) ;%@NL@%
            break;%@NL@%
%@NL@%
        case HT_MINUTE:%@NL@%
            GpiSetColor ( hps , clrMinuteHand ) ;%@NL@%
            GpiBeginPath ( hps , 1L ) ;%@NL@%
            GpiSetCurrentPosition ( hps , aptlMinute ) ;%@NL@%
            GpiPolyLine ( hps , cptlMinute , aptlMinute ) ;%@NL@%
            GpiEndPath ( hps ) ;%@NL@%
            GpiFillPath ( hps , 1L , FPATH_ALTERNATE ) ;%@NL@%
            break;%@NL@%
%@NL@%
        case HT_SECOND:%@NL@%
            %@AB@%/* draw in XOR mixmode, so we can undraw later */%@AE@%%@NL@%
            GpiSetMix ( hps , FM_INVERT ) ;%@NL@%
            GpiSetCurrentPosition ( hps , aptlSecond ) ;%@NL@%
            GpiPolyLine ( hps , cptlSecond , aptlSecond ) ;%@NL@%
            GpiSetMix ( hps , FM_OVERPAINT ) ;%@NL@%
            break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkDrawFace() -- Draws clock face and tick marks%@NL@%
%@AB@%*/%@AE@%%@NL@%
VOID ClkDrawFace ( HPS hps )%@NL@%
{%@NL@%
    BOOL f ;%@NL@%
    LONG l ;%@NL@%
    static POINTL ptlOrigin = { 0L , 0L } ;%@NL@%
%@NL@%
    %@AB@%/*              1         0      0     *\%@NL@%
%@AB@%    *              0         1      0      *%@NL@%
%@AB@%    \*            100       100      1     */%@AE@%%@NL@%
%@NL@%
    static MATRIXLF matlfModel = {%@NL@%
        MAKEFIXED ( 1 , 0 ) ,            MAKEFIXED ( 0 , 0 ) ,        0L ,%@NL@%
        MAKEFIXED ( 0 , 0 ) ,            MAKEFIXED ( 1 , 0 ) ,        0L ,%@NL@%
        100L ,                            100L ,                        1L } ;%@NL@%
%@NL@%
    %@AB@%/* center at (100, 100) and draw the clock face */%@AE@%%@NL@%
    f = GpiSetModelTransformMatrix ( hps , ( LONG ) MATLF_SIZE ,%@NL@%
                                     & matlfModel , TRANSFORM_REPLACE ) ;%@NL@%
    GpiSetColor ( hps , clrFace ) ;%@NL@%
    GpiSetCurrentPosition ( hps , & ptlOrigin ) ;%@NL@%
    l = GpiFullArc ( hps , DRO_OUTLINEFILL , MAKEFIXED ( 85 , 0 ) ) ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkDrawTicks() -- Draws clock ticks%@NL@%
%@AB@%*/%@AE@%%@NL@%
VOID ClkDrawTicks ( HPS hps , USHORT usTicks )%@NL@%
{%@NL@%
    BOOL f ;%@NL@%
    USHORT usAngle ;%@NL@%
%@NL@%
    %@AB@%/* prepare a transform to use when rotating the ticks */%@AE@%%@NL@%
    %@AB@%/*            cos x    - sin x        0     *\%@NL@%
%@AB@%    |            sin x      cos x        0      |%@NL@%
%@AB@%    \*            100        100        1     */%@AE@%%@NL@%
%@NL@%
    static MATRIXLF matlfModel = {%@NL@%
        MAKEFIXED ( 1 , 0 ) ,            MAKEFIXED ( 0 , 0 ) ,        0L ,%@NL@%
        MAKEFIXED ( 0 , 0 ) ,            MAKEFIXED ( 1 , 0 ) ,        0L ,%@NL@%
        100L ,                            100L ,                        1L } ;%@NL@%
%@NL@%
    %@AB@%/* define what the tick marks look like */%@AE@%%@NL@%
    static POINTL aptlMajorTick [ ] = { { -3 , 94 } , { 3 , 100 } } ;%@NL@%
    static POINTL aptlMinorTick [ ] = { { 0 , 94 } , { 0 , 95 } } ;%@NL@%
%@NL@%
    %@AB@%/* draw in the default color */%@AE@%%@NL@%
    GpiSetColor ( hps , CLR_DEFAULT ) ;%@NL@%
%@NL@%
    %@AB@%/* have we been asked to draw the major ticks? */%@AE@%%@NL@%
    if ( usTicks & CLK_MAJORTICKS )%@NL@%
        for ( usAngle = 0 ; usAngle < 60 ; usAngle += 5 ) {%@NL@%
%@NL@%
            %@AB@%/* set the rotation transform */%@AE@%%@NL@%
            matlfModel . fxM11 =%@NL@%
            matlfModel . fxM22 = fxSin [ ( usAngle + 15 ) % 60 ] ;%@NL@%
            matlfModel . fxM12 = fxSin [ ( usAngle + 30 ) % 60 ] ;%@NL@%
            matlfModel . fxM21 = fxSin [ usAngle ] ;%@NL@%
            f = GpiSetModelTransformMatrix ( hps , ( LONG ) MATLF_SIZE ,%@NL@%
                                             & matlfModel ,%@NL@%
                                             TRANSFORM_REPLACE ) ;%@NL@%
%@NL@%
            %@AB@%/* draw a major tick mark */%@AE@%%@NL@%
            GpiSetCurrentPosition ( hps , & aptlMajorTick [ 0 ] ) ;%@NL@%
            GpiBox ( hps , DRO_FILL , & aptlMajorTick [ 1 ] , 0L , 0L ) ;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* have we been asked to draw the minor ticks? */%@AE@%%@NL@%
    if ( usTicks & CLK_MINORTICKS )%@NL@%
        for ( usAngle = 0 ; usAngle < 60 ; usAngle ++ ) {%@NL@%
%@NL@%
            matlfModel . fxM11 =%@NL@%
            matlfModel . fxM22 = fxSin [ ( usAngle + 15 ) % 60 ] ;%@NL@%
            matlfModel . fxM12 = fxSin [ ( usAngle + 30 ) % 60 ] ;%@NL@%
            matlfModel . fxM21 = fxSin [ usAngle ] ;%@NL@%
%@NL@%
            %@AB@%/* set the transform */%@AE@%%@NL@%
            f = GpiSetModelTransformMatrix ( hps , ( LONG ) MATLF_SIZE ,%@NL@%
                                             & matlfModel ,%@NL@%
                                             TRANSFORM_REPLACE ) ;%@NL@%
%@NL@%
            %@AB@%/* draw a minor tick mark */%@AE@%%@NL@%
            GpiSetCurrentPosition ( hps , & aptlMinorTick [ 0 ] ) ;%@NL@%
            GpiLine ( hps , & aptlMinorTick [ 1 ] ) ;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\PIPES\PC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Child program for pipes example. This program%@NL@%
%@AB@% * is a filter which transliterates lower case%@NL@%
%@AB@% * characters into upper case and passes others%@NL@%
%@AB@% * through unchanged.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Created by Microsoft Corp. 1987%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2def.h> %@NL@%
%@AI@%#include %@AE@%<bsedos.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
main()%@NL@%
{%@NL@%
        int c;%@NL@%
%@NL@%
        while((c = getchar()) != EOF)%@NL@%
                putchar(toupper(c));%@NL@%
        printf("Child saw an EOF\n");%@NL@%
        fflush(stdout);%@NL@%
        DosExit(EXIT_THREAD,0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PCHILD.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\PIPES\PCHILD.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***        pchild.c - child program%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Example of DosMakePipe usage in parent/child communication%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This is the child program which read the data sent down%@NL@%
%@AB@% *        from the parent in the pipe.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Created by Microsoft Corp. 1987%@NL@%
%@AB@% */%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2def.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<bsedos.h> %@NL@%
%@NL@%
typedef struct {%@NL@%
        SHANDLE read_handle;               %@AB@%/* pipe read handle */%@AE@%%@NL@%
        SHANDLE write_handle;               %@AB@%/* pipe write handle */%@AE@%%@NL@%
} SharedData;%@NL@%
%@NL@%
%@NL@%
main()%@NL@%
{%@NL@%
%@NL@%
        static char pname[] = "\\SHAREMEM\\public";   %@AB@%/* shared mem seg name */%@AE@%%@NL@%
        char *written = "Writing to the child";              %@AB@%/* string in pipe */%@AE@%%@NL@%
        char readin[21];                %@AB@%/* DosRead input buffer */%@AE@%%@NL@%
        int retcode;                        %@AB@%/* holds return code from call */%@AE@%%@NL@%
        SharedData far *fp;                %@AB@%/* pointer to shared memory */%@AE@%%@NL@%
        SEL mem_handle;                 %@AB@%/* selector of the allocated segment */%@AE@%%@NL@%
        USHORT buflen = 21;                %@AB@%/* DosRead buffer length */%@AE@%%@NL@%
        USHORT read;                        %@AB@%/* number bytes read by DosRead */%@AE@%%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* access shared memory 'public' */%@AE@%%@NL@%
        printf("Accessing shared memory\n");%@NL@%
        retcode = DosGetShrSeg((PSZ)pname, &mem_handle);%@NL@%
        %@NL@%
        %@AB@%/* create pointer to shared memory segment */%@AE@%%@NL@%
        fp = (SharedData far *)MAKEP(mem_handle,0);%@NL@%
%@NL@%
        %@AB@%/* read from the pipe */%@AE@%%@NL@%
        printf("Reading from pipe\n");%@NL@%
        if( retcode = DosRead( fp->read_handle, readin, buflen,%@NL@%
                        &read)) {%@NL@%
                printf("Read from pipe handle %d failed, retcode %d\n", %@NL@%
                    fp->read_handle, retcode);%@NL@%
        }%@NL@%
        else {%@NL@%
                printf("DosRead read %d bytes from handle %d, retcode %d\n", %@NL@%
                    read, fp->read_handle, retcode);%@NL@%
%@NL@%
                %@AB@%/* verify the string */%@AE@%%@NL@%
                if ( retcode = strcmp( written, readin ) ) {%@NL@%
                        printf("The child didn't read pipe data correctly");%@NL@%
                        printf(", retcode %d\n", retcode);%@NL@%
                        printf("read string %s\n", readin);%@NL@%
                        printf("expected string %s\n", written);%@NL@%
                }%@NL@%
                else%@NL@%
                        printf("Read pipe data ok\n");%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* free the segment and return to parent */%@AE@%%@NL@%
        DosFreeSeg( mem_handle );%@NL@%
%@NL@%
        printf("Exiting child\n");%@NL@%
%@NL@%
        %@AB@%/* Exit without terminating other children */%@AE@%%@NL@%
%@NL@%
        DosExit(EXIT_THREAD,0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PIPES.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\PIPES\PIPES.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***        pipes.c - parent program%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Example of DosMakePipe usage in parent/child communication%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This program gets some shared memory, makes a pipe, writes%@NL@%
%@AB@% *        a string into it, and then execs a child.  The child gets%@NL@%
%@AB@% *        the shared memory segment, then reads from the pipe using%@NL@%
%@AB@% *        the handle passed in the shared memory segment.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Created by Microsoft Corp. 1987%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSQUEUES %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2def.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<bsedos.h> %@NL@%
%@NL@%
typedef struct {                        %@AB@%/* structure of shared mem segment */%@AE@%%@NL@%
        SHANDLE  read_handle;                %@AB@%/* pipe read handle */%@AE@%%@NL@%
        SHANDLE  write_handle;                %@AB@%/* pipe write handle */%@AE@%%@NL@%
} SharedData;%@NL@%
%@NL@%
SharedData far *fp;                        %@AB@%/* pointer to shared memory */%@AE@%%@NL@%
SEL mem_handle;                         %@AB@%/* selector of the allocated segment */%@AE@%%@NL@%
%@NL@%
%@NL@%
main()%@NL@%
{%@NL@%
%@NL@%
        static char pname[] = "\\SHAREMEM\\public";           %@AB@%/* shared mem name */%@AE@%%@NL@%
        static char writeout[] = "Writing to the child";   %@AB@%/* pipe string */%@AE@%%@NL@%
        char exec_buf[100];                %@AB@%/* buffer for DosExecPgm ObjName */%@AE@%%@NL@%
        char *pgmname = "pchild.exe";        %@AB@%/* name of child program */%@AE@%%@NL@%
        int i;%@NL@%
        int retcode;                        %@AB@%/* holds return code from call */%@AE@%%@NL@%
        RESULTCODES           tcodes;        %@AB@%/* termination codes from DosExecPgm */%@AE@%%@NL@%
        unsigned far *fpinit;                %@AB@%/* pointer to shared memory */%@AE@%%@NL@%
        USHORT buflen;                        %@AB@%/* DosWrite buffer length */%@AE@%%@NL@%
        USHORT memsiz = 1024;                %@AB@%/* size of memory segment requested */%@AE@%%@NL@%
        USHORT pipe_size;                %@AB@%/* size to reserve for the pipe */%@AE@%%@NL@%
        USHORT written;                 %@AB@%/* number bytes written by DosWrite */%@AE@%%@NL@%
%@NL@%
        %@AB@%/* allocate 1k shared memory segment and initialize it */%@AE@%%@NL@%
        printf("Getting shared memory segment\n");%@NL@%
        retcode = DosAllocShrSeg( memsiz, (PSZ)pname,%@NL@%
                        (PSEL)&mem_handle);%@NL@%
%@NL@%
        %@AB@%/* create pointers to shared memory segment */%@AE@%%@NL@%
        fp = (SharedData far *)MAKEP(mem_handle,0);%@NL@%
        fpinit = (unsigned far *)MAKEP(mem_handle,0);%@NL@%
%@NL@%
        %@AB@%/* zero initialize the segment */%@AE@%%@NL@%
        for (i = 0; i < memsiz / 2; i++) {%@NL@%
            *fpinit = 0;%@NL@%
            fpinit++;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* make the pipe */%@AE@%%@NL@%
        pipe_size = 0;                        %@AB@%/* use default size */%@AE@%%@NL@%
        printf("Making the pipe\n");%@NL@%
        retcode = DosMakePipe((PHFILE)&fp->read_handle,%@NL@%
                        (PHFILE)&fp->write_handle, pipe_size);%@NL@%
%@NL@%
        if ( retcode ) {%@NL@%
            printf("DosMakePipe returned error %d, aborting\n", retcode);%@NL@%
            exit(2);%@NL@%
        }%@NL@%
        else%@NL@%
            printf("DosMakePipe retcode %d, read_handle %d, write_handle %d\n",%@NL@%
                retcode, fp->read_handle, fp->write_handle);%@NL@%
%@NL@%
        %@AB@%/* write string to pipe */%@AE@%%@NL@%
        buflen = strlen(writeout) + 1;%@NL@%
        if( retcode = DosWrite( fp->write_handle, (PCHAR)writeout,%@NL@%
                        buflen, &written)) {%@NL@%
                printf("Write to pipe failed, retcode %d\n", retcode);%@NL@%
                exit(2);%@NL@%
        }%@NL@%
        else %@NL@%
                printf("Write to write_handle %d, bytes written %d\n",%@NL@%
                    fp->write_handle, written);%@NL@%
        %@NL@%
        %@AB@%/* create the child */%@AE@%%@NL@%
        printf("Creating child\n");%@NL@%
        retcode = DosExecPgm( exec_buf, 100, EXEC_SYNC,%@NL@%
                        (PSZ)0L, (PSZ)0L,%@NL@%
                        &tcodes, pgmname );%@NL@%
%@NL@%
        if ( retcode )%@NL@%
                printf("DosExecPgm of child error %d\n", retcode);%@NL@%
        else %@NL@%
                printf("Back in parent\n");%@NL@%
        %@NL@%
        %@AB@%/* close the pipe */%@AE@%%@NL@%
        DosClose( fp->read_handle );%@NL@%
        DosClose( fp->write_handle );%@NL@%
%@NL@%
        DosExit(EXIT_PROCESS,0);   %@AB@%/* Terminate, kill any dangling children */%@AE@%%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PMCAP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\PMCAP\PMCAP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------%@NL@%
%@AB@%   PMCAP.C -- Captures PM Screen to .BMP File%@NL@%
%@AB@%  --------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%"pmcap.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%ID_TIMER    1 %@NL@%
%@NL@%
typedef struct%@NL@%
     {%@NL@%
     BOOL  fMonochrome ;%@NL@%
     BOOL  fHideWindow ;%@NL@%
     BOOL  fAutoDialog ;%@NL@%
     BOOL  fIncludePtr ;%@NL@%
     SHORT sDelay ;%@NL@%
     SHORT sDisplay ;%@NL@%
     }%@NL@%
     SETTINGS ;%@NL@%
%@NL@%
MRESULT CALLBACK ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT CALLBACK AboutDlgProc  (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT CALLBACK SaveDlgProc   (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
CHAR szClientClass [] = "PMCAP" ;%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static SWCNTRL swctl ;%@NL@%
     static ULONG   flFrameFlags = FCF_TITLEBAR   | FCF_SYSMENU |%@NL@%
                                   FCF_SIZEBORDER | FCF_MINMAX  |%@NL@%
                                   FCF_MENU       | FCF_ACCELTABLE |%@NL@%
                                   FCF_SHELLPOSITION;%@NL@%
     HMQ            hmq ;%@NL@%
     HSWITCH        hsw ;%@NL@%
     HWND           hwndFrame, hwndClient ;%@NL@%
     QMSG           qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass,%@NL@%
                                     "PMCAP - Captures PM Screen",%@NL@%
                                     0L, (HMODULE) NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     swctl.hwnd = hwndFrame ;%@NL@%
     hsw = WinAddSwitchEntry (&swctl) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinRemoveSwitchEntry (hsw) ;%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT CALLBACK ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR     szFilename [81],%@NL@%
                     szFilePaint [81],%@NL@%
                     szAppName [] = "PMCAP",%@NL@%
                     szKeySet  [] = "SETTINGS",%@NL@%
                     szKeyFile [] = "FILENAME" ,%@NL@%
                     szKeyPaint[] = "FILEPAINT" ;%@NL@%
     static HBITMAP  hbm ;%@NL@%
     static HWND     hwndFrame, hwndMenu ;%@NL@%
     static SETTINGS set = { FALSE, FALSE, TRUE, FALSE,%@NL@%
                             IDM_DELAY15, IDM_ACTUAL } ;%@NL@%
     static SHORT    cxScreen, cyScreen, sCountDown ;%@NL@%
     HBITMAP         hbmClip ;%@NL@%
     HPS             hps ;%@NL@%
     RECTL           rcl ;%@NL@%
     SHORT           sSaveResult, sLen ;%@NL@%
     USHORT          usfInfo ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               cxScreen = (SHORT) WinQuerySysValue (HWND_DESKTOP, SV_CXSCREEN);%@NL@%
               cyScreen = (SHORT) WinQuerySysValue (HWND_DESKTOP, SV_CYSCREEN);%@NL@%
%@NL@%
               WinQueryProfileData   (hab, szAppName, szKeySet, &set, &sLen);%@NL@%
               WinQueryProfileString (hab, szAppName, szKeyFile,%@NL@%
                                      "BITMAP00.BMP", szFilename,%@NL@%
                                      sizeof szFilename - 1) ;%@NL@%
               WinQueryProfileString (hab, szAppName, szKeyPaint,%@NL@%
                                      "PAINT00.MSP", szFilePaint,%@NL@%
                                      sizeof szFilePaint - 1) ;%@NL@%
%@NL@%
               SaveColorSettings (TRUE, set.fMonochrome) ;%@NL@%
%@NL@%
               hwndFrame = WinQueryWindow (hwnd, QW_PARENT, FALSE) ;%@NL@%
               hwndMenu  = WinWindowFromID (hwndFrame, FID_MENU) ;%@NL@%
%@NL@%
               CheckMenuItem (hwndMenu, IDM_MONO,     set.fMonochrome) ;%@NL@%
               CheckMenuItem (hwndMenu, IDM_HIDE,     set.fHideWindow) ;%@NL@%
               CheckMenuItem (hwndMenu, IDM_AUTODLG,  set.fAutoDialog) ;%@NL@%
               CheckMenuItem (hwndMenu, IDM_POINTER,  set.fIncludePtr) ;%@NL@%
               CheckMenuItem (hwndMenu, set.sDelay,   TRUE) ;%@NL@%
               CheckMenuItem (hwndMenu, set.sDisplay, TRUE) ;%@NL@%
%@NL@%
               AddItemToSysMenu (hwndFrame) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_INITMENU:%@NL@%
               switch (SHORT1FROMMP (mp1))%@NL@%
                    {%@NL@%
                    case IDM_FILE:%@NL@%
                         EnableMenuItem (hwndMenu, IDM_SAVE, hbm != NULL) ;%@NL@%
                         EnableMenuItem (hwndMenu, IDM_SAVEPAINT,%@NL@%
                                         IsBitmapMonoEGA (hbm)) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_EDIT:%@NL@%
                         EnableMenuItem (hwndMenu, IDM_COPY, hbm != NULL) ;%@NL@%
                         EnableMenuItem (hwndMenu, IDM_PASTE,%@NL@%
                              WinQueryClipbrdFmtInfo (hab, CF_BITMAP, &usfInfo)%@NL@%
                                   && usfInfo == CFI_HANDLE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_ABOUT:%@NL@%
                         WinDlgBox (HWND_DESKTOP, hwnd, AboutDlgProc,%@NL@%
                                    (HMODULE) NULL, IDD_ABOUT, NULL) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_SAVE:%@NL@%
                         if (!WinDlgBox (HWND_DESKTOP, hwnd, SaveDlgProc,%@NL@%
                                         (HMODULE) NULL, IDD_SAVE, szFilename))%@NL@%
                              return 0 ;%@NL@%
%@NL@%
                         if (hbm != NULL)%@NL@%
                              {%@NL@%
                              WinSetPointer (HWND_DESKTOP,%@NL@%
                                   WinQuerySysPointer (HWND_DESKTOP,%@NL@%
                                                       SPTR_WAIT, FALSE)) ;%@NL@%
%@NL@%
                              sSaveResult = SaveBitmap (hbm, szFilename) ;%@NL@%
%@NL@%
                              WinSetPointer (HWND_DESKTOP,%@NL@%
                                   WinQuerySysPointer (HWND_DESKTOP,%@NL@%
                                                       SPTR_ARROW, FALSE)) ;%@NL@%
%@NL@%
                              if (sSaveResult)%@NL@%
                                   ErrorMessage (hwnd, sSaveResult) ;%@NL@%
                              else%@NL@%
                                   IncrementFilename (szFilename) ;%@NL@%
                              }%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_SAVEPAINT:%@NL@%
                         if (!WinDlgBox (HWND_DESKTOP, hwnd, SaveDlgProc,%@NL@%
                                         (HMODULE) NULL, IDD_SAVEPAINT, szFilePaint))%@NL@%
                              return 0 ;%@NL@%
%@NL@%
                         if (IsBitmapMonoEGA (hbm))%@NL@%
                              {%@NL@%
                              WinSetPointer (HWND_DESKTOP,%@NL@%
                                   WinQuerySysPointer (HWND_DESKTOP,%@NL@%
                                                       SPTR_WAIT, FALSE)) ;%@NL@%
%@NL@%
                              sSaveResult = SavePaintFormat (hbm, szFilePaint);%@NL@%
%@NL@%
                              WinSetPointer (HWND_DESKTOP,%@NL@%
                                   WinQuerySysPointer (HWND_DESKTOP,%@NL@%
                                                       SPTR_ARROW, FALSE)) ;%@NL@%
%@NL@%
                              if (sSaveResult)%@NL@%
                                   ErrorMessage (hwnd, sSaveResult) ;%@NL@%
                              else%@NL@%
                                   IncrementFilename (szFilePaint) ;%@NL@%
                              }%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_COPY:%@NL@%
                                             // Make copy of stored bitmap%@NL@%
%@NL@%
                         hbmClip = CopyBitmap (hbm) ;%@NL@%
%@NL@%
                                             // Set clipboard data to copy%@NL@%
%@NL@%
                         if (hbmClip != NULL)%@NL@%
                              {%@NL@%
                              WinOpenClipbrd (hab) ;%@NL@%
                              WinEmptyClipbrd (hab) ;%@NL@%
                              WinSetClipbrdData (hab, (ULONG) hbmClip,%@NL@%
                                                 CF_BITMAP, CFI_HANDLE) ;%@NL@%
                              WinCloseClipbrd (hab) ;%@NL@%
                              }%@NL@%
                         else%@NL@%
                              ErrorMessage (hwnd, IDS_BMPCREATE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_PASTE:%@NL@%
                                              // Get bitmap from clipboard%@NL@%
%@NL@%
                         WinOpenClipbrd (hab) ;%@NL@%
                         hbmClip = (HBITMAP) WinQueryClipbrdData (hab, CF_BITMAP) ;%@NL@%
%@NL@%
                         if (hbmClip != NULL)%@NL@%
                              {%@NL@%
                              if (hbm != NULL)%@NL@%
                                   GpiDeleteBitmap (hbm) ;%@NL@%
%@NL@%
                                             // Make copy of it%@NL@%
%@NL@%
                              hbm = CopyBitmap (hbmClip) ;%@NL@%
%@NL@%
                              if (hbm == NULL)%@NL@%
                                   ErrorMessage (hwnd, IDS_BMPCREATE) ;%@NL@%
                              }%@NL@%
                         WinCloseClipbrd (hab) ;%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_BEGIN:%@NL@%
                         if (WinStartTimer (hab, hwnd, ID_TIMER, 1000))%@NL@%
                              {%@NL@%
                              EnableMenuItem (hwndMenu, IDM_BEGIN, FALSE) ;%@NL@%
                              EnableMenuItem (hwndMenu, IDM_ABORT, TRUE) ;%@NL@%
                              sCountDown = set.sDelay - IDM_DELAY ;%@NL@%
%@NL@%
                              if (set.fHideWindow)%@NL@%
                                   WinShowWindow (hwndFrame, FALSE) ;%@NL@%
                              }%@NL@%
                         else%@NL@%
                              ErrorMessage (hwnd, IDS_TIMER) ;%@NL@%
%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ABORT:%@NL@%
                         EnableMenuItem (hwndMenu, IDM_BEGIN, TRUE) ;%@NL@%
                         EnableMenuItem (hwndMenu, IDM_ABORT, FALSE) ;%@NL@%
%@NL@%
                         WinStopTimer (hab, hwnd, ID_TIMER) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_MONO:%@NL@%
                         CheckMenuItem (hwndMenu, IDM_MONO,%@NL@%
                                        set.fMonochrome = !set.fMonochrome) ;%@NL@%
                         %@NL@%
                         SaveColorSettings (FALSE, set.fMonochrome) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_HIDE:%@NL@%
                         CheckMenuItem (hwndMenu, IDM_HIDE,%@NL@%
                                        set.fHideWindow = !set.fHideWindow) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_AUTODLG:%@NL@%
                         CheckMenuItem (hwndMenu, IDM_AUTODLG,%@NL@%
                                        set.fAutoDialog = !set.fAutoDialog) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_POINTER:%@NL@%
                         CheckMenuItem (hwndMenu, IDM_POINTER,%@NL@%
                                        set.fIncludePtr = !set.fIncludePtr) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_DELAY5:%@NL@%
                    case IDM_DELAY10:%@NL@%
                    case IDM_DELAY15:%@NL@%
                    case IDM_DELAY30:%@NL@%
                    case IDM_DELAY60:%@NL@%
                         CheckMenuItem (hwndMenu, set.sDelay, FALSE) ;%@NL@%
                         set.sDelay = COMMANDMSG(&msg)->cmd ;%@NL@%
                         CheckMenuItem (hwndMenu, set.sDelay, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ACTUAL:%@NL@%
                    case IDM_STRETCH:%@NL@%
                         CheckMenuItem (hwndMenu, set.sDisplay, FALSE) ;%@NL@%
                         set.sDisplay = COMMANDMSG(&msg)->cmd ;%@NL@%
                         CheckMenuItem (hwndMenu, set.sDisplay, TRUE) ;%@NL@%
%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
%@NL@%
          case WM_TIMER:%@NL@%
               switch (SHORT1FROMMP (mp1))%@NL@%
                    {%@NL@%
                    case ID_TIMER:%@NL@%
                         if (--sCountDown)%@NL@%
                              {%@NL@%
                              DosBeep (1024, 100) ;%@NL@%
                              return 0 ;%@NL@%
                              }%@NL@%
%@NL@%
                         DosBeep (1024, 1000) ;%@NL@%
                         WinStopTimer (hab, hwnd, ID_TIMER) ;%@NL@%
                         EnableMenuItem (hwndMenu, IDM_BEGIN, TRUE) ;%@NL@%
                         EnableMenuItem (hwndMenu, IDM_ABORT, FALSE) ;%@NL@%
%@NL@%
                                             // Delete old bitmap%@NL@%
                         if (hbm != NULL)%@NL@%
                              GpiDeleteBitmap (hbm) ;%@NL@%
%@NL@%
                                             // Copy screen to bitmap%@NL@%
%@NL@%
                         hbm = ScreenToBitmap (cxScreen, cyScreen,%@NL@%
                                               set.fIncludePtr,%@NL@%
                                               set.fMonochrome) ;%@NL@%
%@NL@%
                         if (set.fHideWindow)%@NL@%
                              WinShowWindow (hwndFrame, TRUE) ;%@NL@%
%@NL@%
                         if (hbm == NULL)%@NL@%
                              ErrorMessage (hwnd, IDS_BMPCREATE) ;%@NL@%
%@NL@%
                         else if (set.fAutoDialog)%@NL@%
                              WinPostMsg (hwnd, WM_COMMAND,%@NL@%
                                   MPFROMSHORT (%@NL@%
                                        set.fMonochrome ? IDM_SAVEPAINT%@NL@%
                                                        : IDM_SAVE),%@NL@%
                                        NULL) ;%@NL@%
%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         WinUpdateWindow (hwnd) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               if (hbm != NULL)%@NL@%
                    {%@NL@%
                    WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
                    WinDrawBitmap (hps, hbm, NULL, (PPOINTL) &rcl,%@NL@%
                                   CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                                   set.sDisplay == IDM_STRETCH ?%@NL@%
                                        DBM_STRETCH : DBM_NORMAL) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               if (hbm != NULL)%@NL@%
                    GpiDeleteBitmap (hbm) ;%@NL@%
%@NL@%
               WinWriteProfileString (hab, szAppName, szKeyFile, szFilename) ;%@NL@%
               WinWriteProfileString (hab, szAppName, szKeyPaint,szFilePaint);%@NL@%
               WinWriteProfileData   (hab, szAppName, szKeySet,%@NL@%
                                      &set, sizeof set) ;%@NL@%
%@NL@%
               if (set.fMonochrome)%@NL@%
                    SaveColorSettings (FALSE, FALSE) ;%@NL@%
%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT CALLBACK AboutDlgProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case DID_OK:%@NL@%
                    case DID_CANCEL:%@NL@%
                         WinDismissDlg (hwnd, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
          }%@NL@%
     return WinDefDlgProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT CALLBACK SaveDlgProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static PCHAR szFilename ;%@NL@%
     FILE         *file ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_INITDLG:%@NL@%
               szFilename = PVOIDFROMMP (mp2) ;%@NL@%
%@NL@%
               WinSendDlgItemMsg (hwnd, IDD_FILENAME, EM_SETTEXTLIMIT,%@NL@%
                                  MPFROMSHORT (80), NULL) ;%@NL@%
%@NL@%
               WinSetDlgItemText (hwnd, IDD_FILENAME, szFilename) ;%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case DID_OK:%@NL@%
                         WinQueryDlgItemText (hwnd, IDD_FILENAME,%@NL@%
                                              80, szFilename) ;%@NL@%
%@NL@%
                                   // Test if file exists%@NL@%
%@NL@%
                         if (file = fopen (szFilename, "r"))%@NL@%
                              {%@NL@%
                              fclose (file) ;%@NL@%
%@NL@%
                              if (MBID_NO == WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                                                  "File exists.  Replace it?",%@NL@%
                                                  szClientClass, 0,%@NL@%
                                                  MB_YESNO | MB_ICONQUESTION |%@NL@%
                                                  MB_DEFBUTTON2 | MB_MOVEABLE))%@NL@%
                                   return 0 ;%@NL@%
                              }%@NL@%
%@NL@%
                         WinDismissDlg (hwnd, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case DID_CANCEL:%@NL@%
                         WinDismissDlg (hwnd, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
          }%@NL@%
     return WinDefDlgProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PMCAP2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\PMCAP\PMCAP2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------%@NL@%
%@AB@%   PMCAP2.C -- Routines for PMCAP.C%@NL@%
%@AB@%  ----------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#define %@AE@%INCL_BITMAPFILEFORMAT %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<ctype.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"pmcap.h" %@NL@%
%@NL@%
extern CHAR szClientClass [] ;%@NL@%
extern HAB  hab ;%@NL@%
%@NL@%
VOID CheckMenuItem (HWND hwndMenu, SHORT idItem, BOOL fCheck)%@NL@%
     {%@NL@%
     WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                 MPFROM2SHORT (idItem, TRUE),%@NL@%
                 MPFROM2SHORT (MIA_CHECKED, fCheck ? MIA_CHECKED : 0)) ;%@NL@%
     }%@NL@%
%@NL@%
VOID EnableMenuItem (HWND hwndMenu, SHORT idItem, BOOL fEnable)%@NL@%
     {%@NL@%
     WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                 MPFROM2SHORT (idItem, TRUE),%@NL@%
                 MPFROM2SHORT (MIA_DISABLED, fEnable ? 0 : MIA_DISABLED)) ;%@NL@%
     }%@NL@%
%@NL@%
VOID ErrorMessage (HWND hwnd, SHORT idError)%@NL@%
     {%@NL@%
     CHAR achString [80] ;%@NL@%
%@NL@%
     WinLoadString (hab, (HMODULE) NULL, idError, sizeof achString, achString) ;%@NL@%
%@NL@%
     WinMessageBox (HWND_DESKTOP, hwnd, achString, szClientClass, 0,%@NL@%
                    MB_OK | MB_ICONEXCLAMATION | MB_MOVEABLE) ;%@NL@%
     }%@NL@%
%@NL@%
VOID AddItemToSysMenu (HWND hwndFrame)%@NL@%
     {%@NL@%
     static CHAR     *szMenuText [2] = { NULL, "~Begin countdown" } ;%@NL@%
     static MENUITEM mi [2] = {%@NL@%
                              MIT_END, MIS_SEPARATOR, 0,         0, 0, 0,%@NL@%
                              MIT_END, MIS_TEXT,      0, IDM_BEGIN, 0, 0%@NL@%
                              } ;%@NL@%
     HWND            hwndSysMenu, hwndSysSubMenu ;%@NL@%
     MENUITEM        miSysMenu ;%@NL@%
     SHORT           idSysMenu, sItem ;%@NL@%
%@NL@%
     hwndSysMenu = WinWindowFromID (hwndFrame, FID_SYSMENU) ;%@NL@%
     idSysMenu   = SHORT1FROMMR (WinSendMsg (hwndSysMenu,%@NL@%
                                             MM_ITEMIDFROMPOSITION,%@NL@%
                                             NULL, NULL)) ;%@NL@%
%@NL@%
     WinSendMsg (hwndSysMenu, MM_QUERYITEM,%@NL@%
                 MPFROM2SHORT (idSysMenu, FALSE),%@NL@%
                 MPFROMP (&miSysMenu)) ;%@NL@%
%@NL@%
     hwndSysSubMenu = miSysMenu.hwndSubMenu ;%@NL@%
%@NL@%
     for (sItem = 0 ; sItem < 2 ; sItem++)%@NL@%
          WinSendMsg (hwndSysSubMenu, MM_INSERTITEM,%@NL@%
                      MPFROMP (mi + sItem),%@NL@%
                      MPFROMP (szMenuText [sItem])) ;%@NL@%
     return ;%@NL@%
     }%@NL@%
%@NL@%
VOID SaveColorSettings (BOOL fSave, BOOL fSetMono)%@NL@%
     {%@NL@%
     static LONG clrTableDef [2 * SYSCLR_CSYSCOLORS] ;%@NL@%
     static LONG clrTable [] = { SYSCLR_WINDOWSTATICTEXT, 0x000000,%@NL@%
                                 SYSCLR_SCROLLBAR,        0xC0C0C0,%@NL@%
                                 SYSCLR_BACKGROUND,       0xFFFFFF,%@NL@%
                                 SYSCLR_ACTIVETITLE,      0x000000,%@NL@%
                                 SYSCLR_INACTIVETITLE,    0xFFFFFF,%@NL@%
                                 SYSCLR_MENU,             0xFFFFFF,%@NL@%
                                 SYSCLR_WINDOW,           0xFFFFFF,%@NL@%
                                 SYSCLR_WINDOWFRAME,      0x000000,%@NL@%
                                 SYSCLR_MENUTEXT,         0x000000,%@NL@%
                                 SYSCLR_WINDOWTEXT,       0x000000,%@NL@%
                                 SYSCLR_TITLETEXT,        0xFFFFFF,%@NL@%
                                 SYSCLR_ACTIVEBORDER,     0xA0A0A0,%@NL@%
                                 SYSCLR_INACTIVEBORDER,   0xFFFFFF,%@NL@%
                                 SYSCLR_APPWORKSPACE,     0xE0E0E0,%@NL@%
                                 SYSCLR_HELPBACKGROUND,   0xFFFFFF,%@NL@%
                                 SYSCLR_HELPTEXT,         0x000000,%@NL@%
                                 SYSCLR_HELPHILITE,       0x000000 } ;%@NL@%
     SHORT i ;%@NL@%
%@NL@%
     if (fSave)%@NL@%
          for (i = 0 ; i < SYSCLR_CSYSCOLORS ; i++)%@NL@%
               clrTableDef[2*i+1] = WinQuerySysColor (HWND_DESKTOP,%@NL@%
                                        clrTableDef[2*i] = clrTable[2*i], 0L);%@NL@%
%@NL@%
     if (fSetMono)%@NL@%
          WinSetSysColors (HWND_DESKTOP, 0L, LCOLF_INDRGB,%@NL@%
                           0L, 2 * SYSCLR_CSYSCOLORS, clrTable) ;%@NL@%
     else%@NL@%
          WinSetSysColors (HWND_DESKTOP, 0L, LCOLF_INDRGB,%@NL@%
                           0L, 2 * SYSCLR_CSYSCOLORS, clrTableDef) ;%@NL@%
     return ;%@NL@%
     }%@NL@%
%@NL@%
VOID IncrementFilename (CHAR *pchName)%@NL@%
     {%@NL@%
     SHORT sIndex ;%@NL@%
%@NL@%
     for (sIndex = strlen (pchName) - 1 ; sIndex >= 0 ; sIndex--)%@NL@%
          {%@NL@%
          if (pchName [sIndex] == '\\')      // past filename%@NL@%
               return ;%@NL@%
%@NL@%
          if (isdigit (pchName [sIndex]))%@NL@%
               break ;%@NL@%
          }%@NL@%
%@NL@%
     for ( ; sIndex >= 0 ; sIndex--)%@NL@%
          {%@NL@%
          if (!isdigit (pchName [sIndex]))%@NL@%
               return ;%@NL@%
%@NL@%
          if (pchName [sIndex] == '9')%@NL@%
               pchName [sIndex] = '0' ;%@NL@%
          else%@NL@%
               {%@NL@%
               pchName [sIndex] += '\001' ;%@NL@%
               return ;%@NL@%
               }%@NL@%
          }%@NL@%
     return ;%@NL@%
     }%@NL@%
%@NL@%
HBITMAP CopyBitmap (HBITMAP hbmSrc)%@NL@%
     {%@NL@%
     BITMAPINFOHEADER bmp ;%@NL@%
     HBITMAP          hbmDst ;%@NL@%
     HDC              hdcSrc, hdcDst ;%@NL@%
     HPS              hpsSrc, hpsDst ;%@NL@%
     POINTL           aptl[3] ;%@NL@%
     SIZEL            sizl ;%@NL@%
%@NL@%
     hdcSrc = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
     hdcDst = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
%@NL@%
     sizl.cx = sizl.cy = 0 ;%@NL@%
     hpsSrc = GpiCreatePS (hab, hdcSrc, &sizl, PU_PELS    | GPIF_DEFAULT |%@NL@%
                                               GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
     hpsDst = GpiCreatePS (hab, hdcDst, &sizl, PU_PELS    | GPIF_DEFAULT |%@NL@%
                                               GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
     GpiQueryBitmapParameters (hbmSrc, &bmp) ;%@NL@%
     hbmDst = GpiCreateBitmap (hpsDst, &bmp, 0L, NULL, NULL) ;%@NL@%
%@NL@%
     if (hbmDst != NULL)%@NL@%
          {%@NL@%
          GpiSetBitmap (hpsSrc, hbmSrc) ;%@NL@%
          GpiSetBitmap (hpsDst, hbmDst) ;%@NL@%
%@NL@%
          aptl[0].x = aptl[0].y = 0 ;%@NL@%
          aptl[1].x = bmp.cx ;%@NL@%
          aptl[1].y = bmp.cy ;%@NL@%
          aptl[2]   = aptl[0] ;%@NL@%
%@NL@%
          GpiBitBlt (hpsDst, hpsSrc, 3L, aptl, ROP_SRCCOPY, BBO_IGNORE) ;%@NL@%
          }%@NL@%
     GpiDestroyPS (hpsSrc) ;%@NL@%
     GpiDestroyPS (hpsDst) ;%@NL@%
     DevCloseDC (hdcSrc) ;%@NL@%
     DevCloseDC (hdcDst) ;%@NL@%
%@NL@%
     return hbmDst ;%@NL@%
     }%@NL@%
%@NL@%
VOID CopyPointerToScreen (HPS hpsScreen, LONG alBitmapFormats[], BOOL fCopy)%@NL@%
     {%@NL@%
     static HBITMAP     hbm ;%@NL@%
     static HDC         hdcMemory ;%@NL@%
     static HPS         hpsMemory ;%@NL@%
     static POINTERINFO ptri ;%@NL@%
     static POINTL      ptlPointer, aptl[3] ;%@NL@%
     static SHORT       cxPointer, cyPointer ;%@NL@%
     BITMAPINFOHEADER   bmp ;%@NL@%
     HPOINTER           hptr ;%@NL@%
     SIZEL              sizl ;%@NL@%
%@NL@%
     if (WinQuerySysValue (HWND_DESKTOP, SV_MOUSEPRESENT) == 0L)%@NL@%
          return ;%@NL@%
%@NL@%
     if (fCopy)%@NL@%
          {%@NL@%
                                   // Get Pointer Information%@NL@%
%@NL@%
          cxPointer = (SHORT) WinQuerySysValue (HWND_DESKTOP, SV_CXPOINTER) ;%@NL@%
          cyPointer = (SHORT) WinQuerySysValue (HWND_DESKTOP, SV_CYPOINTER) ;%@NL@%
%@NL@%
          hptr = WinQueryPointer (HWND_DESKTOP) ;%@NL@%
          WinQueryPointerInfo (hptr, &ptri) ;%@NL@%
          WinQueryPointerPos (HWND_DESKTOP, &ptlPointer) ;%@NL@%
%@NL@%
                                   // Create memory DC and PS%@NL@%
%@NL@%
          hdcMemory = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
%@NL@%
          sizl.cx = sizl.cy = 0 ;%@NL@%
          hpsMemory = GpiCreatePS (hab, hdcMemory, &sizl,%@NL@%
                                   PU_PELS    | GPIF_DEFAULT |%@NL@%
                                   GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
                                   // Create bitmap for destination%@NL@%
%@NL@%
          bmp.cbFix     = sizeof bmp ;%@NL@%
          bmp.cx        = cxPointer ;%@NL@%
          bmp.cy        = cyPointer ;%@NL@%
          bmp.cPlanes   = (USHORT) alBitmapFormats[0] ;%@NL@%
          bmp.cBitCount = (USHORT) alBitmapFormats[1] ;%@NL@%
%@NL@%
          hbm = GpiCreateBitmap (hpsMemory, &bmp, 0L, NULL, NULL) ;%@NL@%
%@NL@%
                                   // Copy from screen to bitmap%@NL@%
%@NL@%
          GpiSetBitmap (hpsMemory, hbm) ;%@NL@%
%@NL@%
          aptl[0].x = 0 ;%@NL@%
          aptl[0].y = 0 ;%@NL@%
          aptl[1].x = cxPointer ;%@NL@%
          aptl[1].y = cyPointer ;%@NL@%
          aptl[2].x = ptlPointer.x - ptri.xHotspot ;%@NL@%
          aptl[2].y = ptlPointer.y - ptri.yHotspot ;%@NL@%
%@NL@%
          GpiBitBlt (hpsMemory, hpsScreen, 3L, aptl, ROP_SRCCOPY, BBO_IGNORE) ;%@NL@%
%@NL@%
                                   // Draw pointer on screen%@NL@%
%@NL@%
          WinDrawPointer (hpsScreen, (SHORT) aptl[2].x, (SHORT) aptl[2].y,%@NL@%
                          hptr, DP_NORMAL) ;%@NL@%
          }%@NL@%
     else%@NL@%
          {%@NL@%
                                   // Copy from bitmap to screen%@NL@%
%@NL@%
          aptl[0].x = ptlPointer.x - ptri.xHotspot ;%@NL@%
          aptl[0].y = ptlPointer.y - ptri.yHotspot ;%@NL@%
          aptl[1].x = aptl[0].x + cxPointer ;%@NL@%
          aptl[1].y = aptl[0].y + cyPointer ;%@NL@%
          aptl[2].x = 0 ;%@NL@%
          aptl[2].y = 0 ;%@NL@%
%@NL@%
          GpiBitBlt (hpsScreen, hpsMemory, 3L, aptl, ROP_SRCCOPY, BBO_IGNORE) ;%@NL@%
%@NL@%
                                   // Clean up%@NL@%
%@NL@%
          GpiSetBitmap (hpsMemory, NULL) ;%@NL@%
          GpiDestroyPS (hpsMemory) ;%@NL@%
          DevCloseDC (hdcMemory) ;%@NL@%
          GpiDeleteBitmap (hbm) ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
HBITMAP ScreenToBitmap (SHORT cxScreen, SHORT cyScreen, BOOL fIncludePtr,%@NL@%
                                                        BOOL fMonochrome)%@NL@%
     {%@NL@%
     BITMAPINFOHEADER bmp ;%@NL@%
     HBITMAP          hbm ;%@NL@%
     HDC              hdcMemory ;%@NL@%
     HPS              hpsScreen, hpsMemory ;%@NL@%
     LONG             alBitmapFormats [2] ;%@NL@%
     POINTL           aptl[3] ;%@NL@%
     SIZEL            sizl ;%@NL@%
%@NL@%
                                   // Create memory DC and PS%@NL@%
%@NL@%
     hdcMemory = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
%@NL@%
     sizl.cx = sizl.cy = 0 ;%@NL@%
     hpsMemory = GpiCreatePS (hab, hdcMemory, &sizl,%@NL@%
                              PU_PELS    | GPIF_DEFAULT |%@NL@%
                              GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
                                   // Create bitmap for destination%@NL@%
%@NL@%
%@NL@%
     bmp.cbFix     = sizeof bmp ;%@NL@%
     bmp.cx        = cxScreen ;%@NL@%
     bmp.cy        = cyScreen ;%@NL@%
%@NL@%
     if (fMonochrome)%@NL@%
          {%@NL@%
          bmp.cPlanes   = 1 ;%@NL@%
          bmp.cBitCount = 1 ;%@NL@%
          }%@NL@%
     else%@NL@%
          {%@NL@%
          GpiQueryDeviceBitmapFormats (hpsMemory, 2L, alBitmapFormats) ;%@NL@%
%@NL@%
          bmp.cPlanes   = (USHORT) alBitmapFormats[0] ;%@NL@%
          bmp.cBitCount = (USHORT) alBitmapFormats[1] ;%@NL@%
          }%@NL@%
%@NL@%
     hbm = GpiCreateBitmap (hpsMemory, &bmp, 0L, NULL, NULL) ;%@NL@%
%@NL@%
                                   // Copy from screen to bitmap%@NL@%
%@NL@%
     if (hbm != NULL)%@NL@%
          {%@NL@%
          GpiSetBitmap (hpsMemory, hbm) ;%@NL@%
          hpsScreen = WinGetScreenPS (HWND_DESKTOP) ;%@NL@%
%@NL@%
          aptl[0].x = 0 ;%@NL@%
          aptl[0].y = 0 ;%@NL@%
          aptl[1].x = cxScreen ;%@NL@%
          aptl[1].y = cyScreen ;%@NL@%
          aptl[2].x = 0 ;%@NL@%
          aptl[2].y = 0 ;%@NL@%
%@NL@%
          if (fIncludePtr)%@NL@%
               CopyPointerToScreen (hpsScreen, alBitmapFormats, TRUE) ;%@NL@%
%@NL@%
          WinLockVisRegions (HWND_DESKTOP, TRUE) ;%@NL@%
%@NL@%
          GpiBitBlt (hpsMemory, hpsScreen, 3L, aptl,%@NL@%
                     fMonochrome ? ROP_NOTSRCCOPY : ROP_SRCCOPY, BBO_IGNORE) ;%@NL@%
%@NL@%
          WinLockVisRegions (HWND_DESKTOP, FALSE) ;%@NL@%
%@NL@%
          if (fIncludePtr)%@NL@%
               CopyPointerToScreen (hpsScreen, alBitmapFormats, FALSE) ;%@NL@%
%@NL@%
          WinReleasePS (hpsScreen) ;%@NL@%
          GpiDestroyPS (hpsMemory) ;%@NL@%
          DevCloseDC (hdcMemory) ;%@NL@%
          }%@NL@%
%@NL@%
     return hbm ;%@NL@%
     }%@NL@%
%@NL@%
BOOL IsBitmapMonoEGA (HBITMAP hbm)%@NL@%
     {%@NL@%
     BITMAPINFOHEADER bmp ;%@NL@%
%@NL@%
     if (hbm != NULL)%@NL@%
          {%@NL@%
          GpiQueryBitmapParameters (hbm, &bmp) ;%@NL@%
%@NL@%
          if (bmp.cx        == 640 &&%@NL@%
              bmp.cy        == 350 &&%@NL@%
              bmp.cPlanes   == 1   &&%@NL@%
              bmp.cBitCount == 1)%@NL@%
%@NL@%
               return TRUE ;%@NL@%
          }%@NL@%
     return FALSE ;%@NL@%
     }%@NL@%
%@NL@%
SHORT SaveBitmap (HBITMAP hbm, CHAR *szFilename)%@NL@%
     {%@NL@%
     BITMAPFILEHEADER bfh ;%@NL@%
     BITMAPINFO       *pbmi ;%@NL@%
     BYTE             *pbScan ;%@NL@%
     FILE             *file ;%@NL@%
     HDC              hdcMemory ;%@NL@%
     HPS              hpsMemory ;%@NL@%
     LONG             lBmpDataSize ;%@NL@%
     SHORT            sRgbTableSize, sScanLineSize, sScan ;%@NL@%
     SIZEL            sizl ;%@NL@%
%@NL@%
                              // Get bitmap information%@NL@%
%@NL@%
     bfh.bmp.cbFix = sizeof (BITMAPINFOHEADER) ;%@NL@%
     GpiQueryBitmapParameters (hbm, &bfh.bmp) ;%@NL@%
%@NL@%
     if (bfh.bmp.cPlanes != 1)%@NL@%
          return IDS_MULTIPLANE ;%@NL@%
%@NL@%
     sRgbTableSize = (1 << bfh.bmp.cPlanes * bfh.bmp.cBitCount) * sizeof (RGB);%@NL@%
     sScanLineSize = ((bfh.bmp.cBitCount * bfh.bmp.cx + 31) / 32) * 4 *%@NL@%
                       bfh.bmp.cPlanes ;%@NL@%
     lBmpDataSize  = (LONG) sScanLineSize * bfh.bmp.cy ;%@NL@%
%@NL@%
                              // Open file%@NL@%
%@NL@%
     if (NULL == (file = fopen (szFilename, "wb")))%@NL@%
          return IDS_FILEOPEN ;%@NL@%
%@NL@%
                              // Set up file header and write it to file%@NL@%
%@NL@%
     bfh.usType   = BFT_BMAP ;%@NL@%
     bfh.cbSize   = sizeof (BITMAPFILEHEADER) + sRgbTableSize + lBmpDataSize ;%@NL@%
     bfh.xHotspot = 0 ;%@NL@%
     bfh.yHotspot = 0 ;%@NL@%
     bfh.offBits  = sizeof (BITMAPFILEHEADER) + sRgbTableSize ;%@NL@%
%@NL@%
     fwrite (&bfh, sizeof bfh, 1, file) ;%@NL@%
%@NL@%
                              // Create memory DC and PS, and set bitmap in it%@NL@%
%@NL@%
     hdcMemory = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
%@NL@%
     sizl.cx = sizl.cy = 0 ;%@NL@%
     hpsMemory = GpiCreatePS (hab, hdcMemory, &sizl, PU_PELS | GPIF_DEFAULT |%@NL@%
                                                     GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
     GpiSetBitmap (hpsMemory, hbm) ;%@NL@%
%@NL@%
                              // Allocate memory for BITMAPINFO table & scans%@NL@%
%@NL@%
     pbmi = malloc (sizeof (BITMAPINFOHEADER) + sRgbTableSize) ;%@NL@%
%@NL@%
     pbmi->cbFix     = sizeof (BITMAPINFOHEADER) ;%@NL@%
     pbmi->cPlanes   = bfh.bmp.cPlanes ;%@NL@%
     pbmi->cBitCount = bfh.bmp.cBitCount ;%@NL@%
%@NL@%
     pbScan = malloc (sScanLineSize) ;%@NL@%
%@NL@%
                              // Loop through scan lines%@NL@%
%@NL@%
     for (sScan = 0 ; sScan < (SHORT) bfh.bmp.cy ; sScan++)%@NL@%
          {%@NL@%
          GpiQueryBitmapBits (hpsMemory, (LONG) sScan, 1L, pbScan, pbmi) ;%@NL@%
%@NL@%
          if (sScan == 0)%@NL@%
               fwrite (&pbmi->argbColor[0], sRgbTableSize, 1, file) ;%@NL@%
%@NL@%
          if (fwrite (pbScan, sScanLineSize, 1, file) == 0)%@NL@%
               break ;%@NL@%
          }%@NL@%
                              // Cleanup after completion%@NL@%
%@NL@%
     fclose (file) ;%@NL@%
     free (pbmi) ;%@NL@%
     free (pbScan) ;%@NL@%
     GpiDestroyPS (hpsMemory) ;%@NL@%
     DevCloseDC (hdcMemory) ;%@NL@%
%@NL@%
     if (sScan != (SHORT) bfh.bmp.cy)%@NL@%
          {%@NL@%
          unlink (szFilename) ;%@NL@%
          return IDS_DISKFULL ;%@NL@%
          }%@NL@%
%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
typedef struct%@NL@%
     {%@NL@%
     SHORT key1 ;%@NL@%
     SHORT key2 ;%@NL@%
     SHORT dxFile ;%@NL@%
     SHORT dyFile ;%@NL@%
     SHORT ScrAspectX ;%@NL@%
     SHORT ScrAspectY ;%@NL@%
     SHORT PrnAspectX ;%@NL@%
     SHORT PrnAspectY ;%@NL@%
     SHORT dxPrinter ;%@NL@%
     SHORT dyPrinter ;%@NL@%
     SHORT AspCorX ;%@NL@%
     SHORT AspCorY ;%@NL@%
     SHORT wCheck ;%@NL@%
     SHORT res1 ;%@NL@%
     SHORT res2 ;%@NL@%
     SHORT res3 ;%@NL@%
     SHORT bitmap[350][40] ;%@NL@%
     }%@NL@%
     PAINT ;%@NL@%
%@NL@%
SHORT SavePaintFormat (HBITMAP hbm, CHAR *szFilename)%@NL@%
     {%@NL@%
     BITMAPINFO *pbmi ;%@NL@%
     FILE       *file ;%@NL@%
     HDC        hdcMemory ;%@NL@%
     HPS        hpsMemory ;%@NL@%
     PAINT      *ppaint ;%@NL@%
     SHORT      i, j, sHold, sWrite ;%@NL@%
     SIZEL      sizl ;%@NL@%
                              // Allocate memory and open file%@NL@%
%@NL@%
     if (!IsBitmapMonoEGA (hbm))%@NL@%
          return IDS_MONOEGA ;%@NL@%
%@NL@%
     if (NULL == (ppaint = malloc (sizeof (PAINT))))%@NL@%
          return IDS_MEMORY ;%@NL@%
%@NL@%
     if (NULL == (file = fopen (szFilename, "wb")))%@NL@%
          {%@NL@%
          free (ppaint) ;%@NL@%
          return IDS_FILEOPEN ;%@NL@%
          }%@NL@%
                              // Set up Paint header for EGA%@NL@%
%@NL@%
     ppaint->key1       = 0x6144 ;%@NL@%
     ppaint->key2       = 0x4D6E ;%@NL@%
     ppaint->dxFile     = 0x0280 ;%@NL@%
     ppaint->dyFile     = 0x015E ;%@NL@%
     ppaint->ScrAspectX = 0x0026 ;%@NL@%
     ppaint->ScrAspectY = 0x0030 ;%@NL@%
     ppaint->PrnAspectX = 0x0026 ;%@NL@%
     ppaint->PrnAspectY = 0x0030 ;%@NL@%
     ppaint->dxPrinter  = 0x0280 ;%@NL@%
     ppaint->dyPrinter  = 0x015E ;%@NL@%
     ppaint->AspCorX    = 0x0000 ;%@NL@%
     ppaint->AspCorY    = 0x0000 ;%@NL@%
     ppaint->wCheck     = 0x2C2A ;%@NL@%
     ppaint->res1       = 0xB80E ;%@NL@%
     ppaint->res2       = 0x0050 ;%@NL@%
     ppaint->res3       = 0x8D50 ;%@NL@%
%@NL@%
                              // Create memory DC and PS, and set bitmap in it%@NL@%
%@NL@%
     hdcMemory = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
%@NL@%
     sizl.cx = sizl.cy = 0 ;%@NL@%
     hpsMemory = GpiCreatePS (hab, hdcMemory, &sizl, PU_PELS | GPIF_DEFAULT |%@NL@%
                                                     GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
     GpiSetBitmap (hpsMemory, hbm) ;%@NL@%
%@NL@%
                              // Allocate memory for bitmap header info%@NL@%
%@NL@%
     pbmi = malloc (sizeof (BITMAPINFO) + sizeof (RGB)) ;%@NL@%
%@NL@%
     pbmi->cbFix     = sizeof (BITMAPINFOHEADER) ;%@NL@%
     pbmi->cx        = 640 ;%@NL@%
     pbmi->cy        = 350 ;%@NL@%
     pbmi->cPlanes   = 1 ;%@NL@%
     pbmi->cBitCount = 1 ;%@NL@%
                              // Get bitmap bits%@NL@%
%@NL@%
     GpiQueryBitmapBits (hpsMemory, 0L, 350L, (PBYTE) ppaint->bitmap, pbmi) ;%@NL@%
%@NL@%
     free (pbmi) ;%@NL@%
                              // Convert to paint format and write%@NL@%
%@NL@%
     for (i = 0 ; i < 350 / 2 ; i++)%@NL@%
          for (j = 0 ; j < 40 ; j++)%@NL@%
               {%@NL@%
               sHold = ~ppaint->bitmap[i][j] ;%@NL@%
               ppaint->bitmap[i][j] = ~ppaint->bitmap[350-i-1][j] ;%@NL@%
               ppaint->bitmap[350-i-1][j] = sHold ;%@NL@%
               }%@NL@%
%@NL@%
     sWrite = fwrite (ppaint, sizeof (PAINT), 1, file) ;%@NL@%
%@NL@%
                              // Clean up after completion%@NL@%
     fclose (file) ;%@NL@%
     free (ppaint) ;%@NL@%
     GpiDestroyPS (hpsMemory) ;%@NL@%
     DevCloseDC (hdcMemory) ;%@NL@%
%@NL@%
     if (sWrite == 0)%@NL@%
          {%@NL@%
          unlink (szFilename) ;%@NL@%
          return IDS_DISKFULL ;%@NL@%
          }%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\PIPES\PP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * DosMakePipe example (pp.c, needs related program pc.c).%@NL@%
%@AB@% *%@NL@%
%@AB@% * Pipes are a byte stream oriented IPC mechanism which uses%@NL@%
%@AB@% * standard DosRead and DosWrite file system calls. Since file%@NL@%
%@AB@% * handles are used to access the pipe, each process using the%@NL@%
%@AB@% * pipe needs to know the handles. There are two general ways%@NL@%
%@AB@% * this is done:%@NL@%
%@AB@% *%@NL@%
%@AB@% *        1. Have very closely cooperating processes which notify%@NL@%
%@AB@% *           each other of the file handles via some private method%@NL@%
%@AB@% *           such as shared memory or command line arguments.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        2. With unrelated processes, a process which reads and writes%@NL@%
%@AB@% *           from STDIN (handle 0) and STDOUT (handle 1) can be attached%@NL@%
%@AB@% *           to a pipe without being aware of it.%@NL@%
%@AB@% *%@NL@%
%@AB@% * This example demonstrates case #2 since that is the harder of the%@NL@%
%@AB@% * two to set up. This process, pp.exe, creates a pipe and exec's a%@NL@%
%@AB@% * child process pc.exe whose stdin is attached to the pipe. The parent%@NL@%
%@AB@% * process writes a lower case message repeatedly into the pipe, and%@NL@%
%@AB@% * the child process translates it into upper case and prints it on%@NL@%
%@AB@% * the screen.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Compile as: cl -AL -G2 -Lp pp.c   (parent process)%@NL@%
%@AB@% *             cl -AL -G2 -Lp pc.c   (child process)%@NL@%
%@AB@% *%@NL@%
%@AB@% * Created by Microsoft Corp. 1987%@NL@%
%@AB@% */%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_DOSQUEUES %@NL@%
%@AI@%#define %@AE@%INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2def.h> %@NL@%
%@AI@%#include %@AE@%<bsedos.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
PSIZE 256                        %@AB@%/* pipe buffer size */%@AE@%%@NL@%
%@NL@%
char msg[] = "hello there!\n";                %@AB@%/* message to write down pipe */%@AE@%%@NL@%
char exec_buf[100];                        %@AB@%/* buffer for DosExecPgm ObjName */%@AE@%%@NL@%
char *pgmname = "pc.exe";                %@AB@%/* name of child program */%@AE@%%@NL@%
%@NL@%
main()%@NL@%
{%@NL@%
        HFILE pread;                        %@AB@%/* pipe read handle */%@AE@%%@NL@%
        HFILE pwrite;                        %@AB@%/* pipe write handle */%@AE@%%@NL@%
        HFILE newstdin, newstdout;        %@AB@%/* stdin as a pipe handle */%@AE@%%@NL@%
        USHORT FileHandlState;                %@AB@%/* Used to modify handle inheritance */%@AE@%%@NL@%
        int i;%@NL@%
        USHORT bytecount;                %@AB@%/* bytes written result */%@AE@%%@NL@%
        RESULTCODES rc2;               %@AB@%/* double return codes for EXEC */%@AE@%%@NL@%
%@NL@%
        DosMakePipe(&pread, &pwrite, PSIZE);        %@AB@%/* create the pipe */%@AE@%%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Now close our stdin which is attached to the console,%@NL@%
%@AB@%         * and make it refer to the pipe instead.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        DosClose(0);                        %@AB@%/* close stdin */%@AE@%%@NL@%
        newstdin = 0;%@NL@%
        DosDupHandle(pread, &newstdin); %@AB@%/* make pipe = stdin */%@AE@%%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Since the child process will normaly inherit the handles of%@NL@%
%@AB@%         * the parent we need to close the input of the pipe.  If we%@NL@%
%@AB@%         * don't then the child will hang on the output of the pipe. (since%@NL@%
%@AB@%         * it still has an open handle to the input).%@NL@%
%@AB@%         *%@NL@%
%@AB@%         * We don't really close the input, simply make it non-inheritable%@NL@%
%@AB@%         * to the child.  Thus the only input to the pipe is from the parent.%@NL@%
%@AB@%         * When the parent closes the pipe, any outstanding READs from the%@NL@%
%@AB@%         * child will return a length of 0 (EOF).%@NL@%
%@AB@%         */%@AE@%%@NL@%
        i = DosQFHandState(pwrite, &FileHandlState);%@NL@%
        if (i) printf("Query of pwrite failed\n");%@NL@%
        FileHandlState &= 0x7F88;        %@AB@%/* Mask bits offensive to the call */%@AE@%%@NL@%
        FileHandlState |= 0x080;        %@AB@%/* Deny inheritance to child */%@AE@%%@NL@%
        i = DosSetFHandState(pwrite, FileHandlState);%@NL@%
        if (i) printf("Set of pwrite failed, i = %x\n",i);%@NL@%
%@AI@%#ifdef %@AE@%NOCODE %@NL@%
        i = DosQFHandState(pread, &FileHandlState);%@NL@%
        if (i) printf("Query of pread failed\n");%@NL@%
        FileHandlState &= 0x7F88;        %@AB@%/* Mask bits offensive to the call */%@AE@%%@NL@%
        FileHandlState |= 0x080;        %@AB@%/* Deny inheritance to child */%@AE@%%@NL@%
        i = DosSetFHandState(pread, FileHandlState);%@NL@%
        if (i) printf("Set of pread failed, i = %x\n",i);%@NL@%
%@AI@%#endif %@AE@%%@NL@%
        %@AB@%/* exec child program, which will inherit new stdin */%@AE@%%@NL@%
        DosExecPgm(exec_buf, sizeof(exec_buf), EXEC_ASYNC, (PSZ)0L,%@NL@%
                        (PSZ)0L, &rc2, pgmname);%@NL@%
%@NL@%
        %@AB@%/* write 20 messages down the pipe */%@AE@%%@NL@%
        printf("Writing messages to the pipe\n");%@NL@%
        for(i = 0; i < 20; i++)%@NL@%
                DosWrite(pwrite, msg, sizeof(msg) - 1, &bytecount);%@NL@%
%@NL@%
        DosClose(pwrite);%@NL@%
        DosClose(pread);%@NL@%
        printf("Parent exiting\n");%@NL@%
        DosExit(EXIT_PROCESS,0); %@AB@%/* Terminate, kill any lingering children */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PRINT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\INIEDIT\PRINT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/******************************* Module Header ******************************\%@NL@%
%@AB@%* Module Name: Print.c%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* PM OS2.ini Editor%@NL@%
%@AB@%*%@NL@%
%@AB@%* Printing Functions%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%LINT_ARGS %@NL@%
%@AI@%#define %@AE@%INCL_WINSHELLDATA %@NL@%
%@AI@%#define %@AE@%INCL_GPIBITMAPS %@NL@%
%@AI@%#define %@AE@%INCL_GPIREGIONS %@NL@%
%@AI@%#define %@AE@%INCL_GPILCIDS %@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@AI@%#define %@AE@%INCL_DEV %@NL@%
%@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"noncomm.h" %@NL@%
%@AI@%#include %@AE@%"IniEdit.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************* Constants *********************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%LEFT_MARGIN      3 %@NL@%
%@AI@%#define %@AE@%TOP_MARGIN       7 %@NL@%
%@AI@%#define %@AE@%BOTTOM_MARGIN   15 %@NL@%
%@AI@%#define %@AE@%       MAX_PRINT_LEN        1024 %@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************* Externals *********************************/%@AE@%%@NL@%
%@NL@%
extern USHORT        cAppNames;%@NL@%
extern PGROUPSTRUCT  pGroups;%@NL@%
extern HAB           habIniEdit;%@NL@%
extern USHORT        usLineHeight;%@NL@%
extern USHORT        usPrintFormat;%@NL@%
%@NL@%
%@AB@%/******************************* Internals ********************************/%@AE@%%@NL@%
CHAR        szBuf[MAX_STRING_LEN];                        // Output character buffer%@NL@%
CHAR        szPrinter[MAX_PRINT_LEN];                // Logical Printer Name%@NL@%
CHAR        szDetails[MAX_PRINT_LEN];                // Logical Printer Details%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Function Header *****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* PrintThread%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Prints the ini info in specified format%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID PrintThread()%@NL@%
{%@NL@%
    HAB      habPrint;                          // HAB of Print Thread%@NL@%
    HDC      hdcPrint;                          // DC of Printer%@NL@%
    HPS      hpsPrint;                          // PS of Printer%@NL@%
    SIZEL    sizel;                             // Size of PS to Create%@NL@%
    POINTL   ptlOutput;                         // Output location%@NL@%
    BYTE     abOut[50];                         // DevEscape Output%@NL@%
    ULONG    ulOut;                             // DevEscape Output Count%@NL@%
    USHORT   usHeight;                          // Height of Printer Page%@NL@%
    USHORT   cch;                               // Count of Characters in buffer%@NL@%
    USHORT   i,j;                               // Loop Counters%@NL@%
    DEVOPENSTRUC  dop;                          // DevOpenDC Info%@NL@%
    CHAR     szMessage[80];%@NL@%
%@NL@%
    %@AB@%/* initialization of thread */%@AE@%%@NL@%
    if (!(habPrint = WinInitialize(0))) DosExit(EXIT_THREAD, -1);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*** Select Port ***/%@AE@%%@NL@%
    %@AB@%/* get name of default logical printer */%@AE@%%@NL@%
    cch = WinQueryProfileString(habPrint, "PM_SPOOLER", "PRINTER",%@NL@%
                           "",                %@AB@%/* default  */%@AE@%%@NL@%
                           szPrinter,%@NL@%
                           MAX_PRINT_LEN);    %@AB@%/* max chars */%@AE@%%@NL@%
%@NL@%
    szPrinter[cch-2] = 0;                     %@AB@%/* remove terminating ';' */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* get specifics of default logical printer */%@AE@%%@NL@%
    cch = WinQueryProfileString(habPrint, "PM_SPOOLER_PRINTER", szPrinter,%@NL@%
                           "",                %@AB@%/* default  */%@AE@%%@NL@%
                           szDetails,%@NL@%
                           MAX_PRINT_LEN);    %@AB@%/* max chars */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* info in form of "port; driver; logical address" */%@AE@%%@NL@%
    %@AB@%/* grab driver name; one past semicolon */%@AE@%%@NL@%
    dop.pszDriverName = strchr( szDetails, ';' )+1;%@NL@%
%@NL@%
    %@AB@%/* Grab logical address */%@AE@%%@NL@%
    dop.pszLogAddress = strchr( dop.pszDriverName, ';' )+1;%@NL@%
%@NL@%
    %@AB@%/* Make driver and Logical address Null terminated */%@AE@%%@NL@%
    dop.pszLogAddress = strtok( dop.pszLogAddress, ",;" );%@NL@%
    dop.pszDriverName = strtok( dop.pszDriverName, ",.;" );  %@AB@%/* Driver.Model */%@AE@%%@NL@%
%@NL@%
    dop.pdriv = NULL;%@NL@%
    dop.pszDataType = NULL;%@NL@%
%@NL@%
    %@AB@%/* Create Printer DC */%@AE@%%@NL@%
    hdcPrint = DevOpenDC( habPrint, OD_QUEUED, "*", 3L, (PDEVOPENDATA)&dop,%@NL@%
            (HDC)NULL);%@NL@%
%@NL@%
    if( hdcPrint == (HDC)NULL )%@NL@%
        {%@NL@%
        DosExit(EXIT_THREAD, -1);%@NL@%
        }%@NL@%
%@NL@%
    strcpy( szBuf, (usPrintFormat == APP_FORM) ? SZAPP : SZALL );%@NL@%
    DevEscape( hdcPrint, DEVESC_STARTDOC, (LONG)strlen( szBuf ), (PBYTE)szBuf,%@NL@%
            &ulOut, (PBYTE)NULL );%@NL@%
%@NL@%
    %@AB@%/* Determine size of page */%@AE@%%@NL@%
    DevQueryCaps( hdcPrint, CAPS_HEIGHT, 1L, (PLONG)&usHeight );%@NL@%
    ptlOutput.y = usHeight - TOP_MARGIN - usLineHeight;%@NL@%
    ptlOutput.x = LEFT_MARGIN;%@NL@%
%@NL@%
    %@AB@%/* Create Printer PS */%@AE@%%@NL@%
    sizel.cx = sizel.cy = 0L;%@NL@%
    hpsPrint = GpiCreatePS( habPrint, hdcPrint, &sizel,%@NL@%
            PU_PELS | GPIF_DEFAULT | GPIT_NORMAL | GPIA_ASSOC );%@NL@%
%@NL@%
    if( hpsPrint == (HPS)NULL )%@NL@%
        {%@NL@%
        DosExit(EXIT_THREAD, -1);%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* print items */%@AE@%%@NL@%
    if( usPrintFormat == APP_FORM )%@NL@%
        {%@NL@%
        for( i=0; i<cAppNames; i++ )%@NL@%
            {%@NL@%
            sprintf(szMessage,"CharString: X = %ld,  Y = %ld",%@NL@%
                                                    ptlOutput.x, ptlOutput.y);%@NL@%
            GpiCharStringAt( hpsPrint, &ptlOutput, (LONG)strlen( pGroups[i].szAppName ),%@NL@%
                    pGroups[i].szAppName );%@NL@%
            ptlOutput.y -= usLineHeight;%@NL@%
%@NL@%
            if( ptlOutput.y <= BOTTOM_MARGIN )%@NL@%
                {%@NL@%
                DevEscape( hdcPrint, DEVESC_NEWFRAME, 0L, (PBYTE)NULL , &ulOut, abOut );%@NL@%
                ptlOutput.y = usHeight - TOP_MARGIN - usLineHeight;%@NL@%
                }%@NL@%
%@NL@%
            }%@NL@%
        }  %@AB@%/* if */%@AE@%%@NL@%
    else%@NL@%
        {%@NL@%
        %@AB@%/* Print App Names */%@AE@%%@NL@%
        for( i=0; i<cAppNames; i++ )%@NL@%
            {%@NL@%
            GpiCharStringAt( hpsPrint, &ptlOutput, (LONG)strlen( pGroups[i].szAppName ),%@NL@%
                    pGroups[i].szAppName );%@NL@%
            ptlOutput.y -= usLineHeight;%@NL@%
            if( ptlOutput.y <= BOTTOM_MARGIN )%@NL@%
                {%@NL@%
                DevEscape( hdcPrint, DEVESC_NEWFRAME, 0L, (PBYTE)NULL , &ulOut, abOut );%@NL@%
                ptlOutput.y = usHeight - TOP_MARGIN - usLineHeight;%@NL@%
                }%@NL@%
%@NL@%
            %@AB@%/* Print Key Value Pairs for current App Name */%@AE@%%@NL@%
            for( j=0; j<pGroups[i].cKeys; j++ )%@NL@%
                {%@NL@%
                sprintf( szBuf, "   %s: %s", pGroups[i].pPairs[j].szKey,%@NL@%
                        pGroups[i].pPairs[j].szValue );%@NL@%
%@NL@%
                if( GpiCharStringAt( hpsPrint, &ptlOutput, (LONG)strlen( szBuf ), szBuf ) == GPI_ERROR )%@NL@%
                        ;%@NL@%
%@NL@%
                ptlOutput.y -= usLineHeight;%@NL@%
                if( ptlOutput.y <= BOTTOM_MARGIN )%@NL@%
                    {%@NL@%
                    DevEscape( hdcPrint, DEVESC_NEWFRAME, 0L, (PBYTE)NULL , &ulOut, abOut );%@NL@%
                    ptlOutput.y = usHeight - TOP_MARGIN - usLineHeight;%@NL@%
                    }%@NL@%
                }  %@AB@%/* for */%@AE@%%@NL@%
            }  %@AB@%/* for */%@AE@%%@NL@%
%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/* Cleanup */%@AE@%%@NL@%
    DevEscape( hdcPrint, DEVESC_ENDDOC, 0L, (PBYTE)NULL , &ulOut, abOut );%@NL@%
    GpiAssociate( hpsPrint, (HDC)NULL );%@NL@%
    GpiDestroyPS( hpsPrint );%@NL@%
    DevCloseDC( hdcPrint );%@NL@%
    DosExit(EXIT_THREAD, 0);%@NL@%
}  %@AB@%/* PrintThread */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PRINT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\STOCK\PRINT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***        print.c - printing support%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This file presents code to make if VERY EASY for an application%@NL@%
%@AB@% *        to select a printer, manipulate job properties, and open a DC%@NL@%
%@AB@% *        for printing.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Author:%@NL@%
%@AB@% *            Benjamin W. Slivka%@NL@%
%@AB@% *%@NL@%
%@AB@% *        History:%@NL@%
%@AB@% *            12-May-1990 bens        Initial version%@NL@%
%@AB@% *            16-May-1990 bens        Skeletal job property routines%@NL@%
%@AB@% *            31-May-1990 bens        Final job property routines%@NL@%
%@AB@% *%@NL@%
%@AB@% *        APIs Offered:%@NL@%
%@AB@% *            PrintQueryPrinterList    - Get printer list%@NL@%
%@AB@% *            PrintQueryNextPrinter    - Enumerate members of printer list%@NL@%
%@AB@% *            PrintQueryDefaultPrinter - Get default printer%@NL@%
%@AB@% *            PrintQueryPrinterInfo    - Get information about a printer%@NL@%
%@AB@% *%@NL@%
%@AB@% *            PrintOpenDC              - Open a printer DC%@NL@%
%@AB@% *%@NL@%
%@AB@% *            PrintQueryJobProperties  - Get JP from a printer%@NL@%
%@AB@% *            PrintChangeJobProperties - Interact with user to change JP%@NL@%
%@AB@% *            PrintMatchPrinter             - Find printer which matches JP%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Key points:%@NL@%
%@AB@% *%@NL@%
%@AB@% *        1)  [PM_SPOOLER,PRINTER] in OS2SYS.INI specifies the default printer.%@NL@%
%@AB@% *                This entry is of use *only* if [PM_SPOOLER,QUEUE] is empty.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        2)  If a [PM_SPOOLER_PRINTER,xxx] entry in OS2SYS.INI entry refers%@NL@%
%@AB@% *                to *more than one* driver, *and* the printer is *not*%@NL@%
%@AB@% *                associated with a queue, then we always use the first driver%@NL@%
%@AB@% *                in the list.  There is no information in the system to help%@NL@%
%@AB@% *                us choose among the drivers, so we make the easy choice.%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DEV %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINSHELLDATA %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<limits.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"ids.h" %@NL@%
%@AI@%#include %@AE@%"file.h" %@NL@%
%@AI@%#include %@AE@%"mem.h" %@NL@%
%@AI@%#include %@AE@%"print.h" %@NL@%
%@NL@%
%@NL@%
/%@AB@%/************************************************************************%@NL@%
%@AB@%//%@NL@%
%@AB@%//  PRIVATE Types and Definitions%@NL@%
%@AB@%//%@NL@%
/%@AB@%/************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%// SEARCHP - Search structure for PrinterBegin/Next/EndSearch%@NL@%
%@AB@%//%@NL@%
typedef struct { %@AB@%/* srchp */%@AE@%%@NL@%
    char *  pchName;                        // Driver name list%@NL@%
    char *  pchNext;                        // Next name in achNames to consume%@NL@%
} SEARCHP;%@NL@%
typedef SEARCHP *PSEARCHP; %@AB@%/* psrchp */%@AE@%%@NL@%
%@NL@%
%@NL@%
// PRINTER - Structure for printer destination (used for DevOpenDC)%@NL@%
//%@NL@%
typedef struct _printer {  %@AB@%/* prt */%@AE@%%@NL@%
    LONG    lType;                        // Printer type (OD_DIRECT/OD_QUEUED)%@NL@%
    char *  pszName;                        // Name (either queue or printer name)%@NL@%
                                        //  NOTE: This pointer always points%@NL@%
                                        //          to either pszLogAddr or%@NL@%
                                        //          pszPrinter.  This pointer%@NL@%
                                        //          should never be freed!%@NL@%
    char *  pszLogAddr;                 // Logical address for DevOpenDC%@NL@%
    char *  pszPrinter;                 // Printer Name%@NL@%
    char *  pszDriver;                        // Driver name%@NL@%
    char *  pszModel;                        // Driver model name%@NL@%
    char *  pszDescription;                // Description%@NL@%
    BOOL    fMultipleDrivers;                // TRUE => pszDriver/pszModel contain%@NL@%
                                        //        the first driver in the printer%@NL@%
                                        //        definition.  If this is a queue%@NL@%
                                        //        (lType == OD_QUEUED), the%@NL@%
                                        //        driver/model must be gotten%@NL@%
                                        //        from PM_SPOOLER_QUEUE_DD.%@NL@%
    USHORT  cbDriverData;                // Length of driver data%@NL@%
    BYTE *  pbDriverData;                // Driver data%@NL@%
    struct _printer *pprtNext;                // Link to next printer%@NL@%
    struct _printer *pprtPrev;                // Link to previous printer%@NL@%
    struct _printerlist *pprtlist;        // Owning list%@NL@%
} PRINTER;%@NL@%
typedef PRINTER *PPRINTER;  %@AB@%/* pprt */%@AE@%%@NL@%
%@NL@%
%@NL@%
//  PRINTERLIST - Structure for list of printers%@NL@%
//%@NL@%
typedef struct _printerlist { %@AB@%/* prtlist */%@AE@%%@NL@%
    HAB         hab;                        // Anchor block for list%@NL@%
    PPRINTER        pprtHead;                // Head of printer list%@NL@%
    PPRINTER        pprtTail;                // Tail of printer list%@NL@%
    PPRINTER        pprtDefault;                // System default printer%@NL@%
} PRINTERLIST;%@NL@%
typedef PRINTERLIST *PPRINTERLIST; %@AB@%/* pprtlist */%@AE@%%@NL@%
%@NL@%
%@NL@%
//  JOBPROP - Structure for exporting/importing job properties%@NL@%
//%@NL@%
typedef struct {    %@AB@%/* jp */%@AE@%%@NL@%
    USHORT  cb;                         // Total buffer size%@NL@%
    USHORT  cbName;                        // Size of printer name (counting NUL)%@NL@%
    USHORT  cbDriver;                        // Size of driver name (counting NUL)%@NL@%
    USHORT  cbModel;                        // Size of model name (counting NUL)%@NL@%
    USHORT  cbData;                        // Size of driver data%@NL@%
 //%@NL@%
 // The "fields" below show the order in which the strings/data follow the%@NL@%
 // structure "header":%@NL@%
 //%@NL@%
 // CHAR    achName[];                        // Printer name (asciiz)%@NL@%
 // CHAR    achDriver[];                // Driver name (asciiz)%@NL@%
 // CHAR    achModel[];                 // Model name (asciiz)%@NL@%
 // BYTE    abData[];                        // Driver data (binary)%@NL@%
 //%@NL@%
} JOBPROP;%@NL@%
typedef JOBPROP *PJOBPROP;  %@AB@%/* pjp */%@AE@%%@NL@%
%@NL@%
%@NL@%
/%@AB@%/************************************************************************%@NL@%
%@AB@%//%@NL@%
%@AB@%//  PRIVATE Global Variables%@NL@%
%@AB@%//%@NL@%
/%@AB@%/************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%static        char        achPath[CCHMAXPATH];%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
/%@AB@%/************************************************************************%@NL@%
%@AB@%//%@NL@%
%@AB@%//  PRIVATE Function Prototypes%@NL@%
%@AB@%//%@NL@%
/%@AB@%/************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%BOOL          AddPrinter(PPRINTERLIST pprtlist,PPRINTER pprtNew);%@NL@%
%@AB@%PPRINTER  ClonePrinter(PPRINTER pprtOriginal,char *pszLogAddr);%@NL@%
%@AB@%PPRINTER  CreatePrinter(LONG  lType,%@NL@%
%@AB@%                        char *pszLogAddr,%@NL@%
%@AB@%                        char *Printer,%@NL@%
%@AB@%                        char *pszDriver,%@NL@%
%@AB@%                        char *pszModel,%@NL@%
%@AB@%                        BOOL  fMultipleDrivers);%@NL@%
%@AB@%VOID          DestroyPrinter(PPRINTER pprt);%@NL@%
%@AB@%VOID          GetDriverData(PPRINTER pprt);%@NL@%
%@AB@%VOID          GetDriverModel(PPRINTER pprt);%@NL@%
%@AB@%VOID          GetDescription(PPRINTER pprt);%@NL@%
%@AB@%PPRINTER  GetPrinterData(char *pszPrinter);%@NL@%
%@AB@%PPRINTER  MatchPrinter(PPRINTERLIST pprtlist,char *pszQueue,char *pszPrinter);%@NL@%
%@AB@%PSEARCHP  PrinterBeginSearch(PPRINTER *ppprt);%@NL@%
%@AB@%BOOL          PrinterEndSearch(PSEARCHP psrchp);%@NL@%
%@AB@%PPRINTER  PrinterNextSearch(PSEARCHP psrchp);%@NL@%
%@AB@%VOID          QueryDefaultPrinterQueue(char **ppszQueue,char **ppszPrinter);%@NL@%
%@AB@%PPRINTER  SplitPrinter(PPRINTERLIST pprtlist,PPRINTER pprtOld);%@NL@%
%@AB@%void          TrimTrailingSemicolon(char *psz);%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
/%@AB@%/************************************************************************%@NL@%
%@AB@%//%@NL@%
%@AB@%//  PUBLIC Functions%@NL@%
%@AB@%//%@NL@%
/%@AB@%/************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%/***        PrintCreatePrinterList - Get list of printers%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Use PrintQueryNextPrinter to enumerate printers.%@NL@%
%@AB@% *        Use PrintQueryPrinterInfo to get information on a printer.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hab - anchor block handle%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns HPRINTERLIST%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns NULL%@NL@%
%@AB@% */%@AE@%%@NL@%
HPRINTERLIST PrintCreatePrinterList(HAB hab)%@NL@%
{%@NL@%
    PSEARCHP            psrchp=NULL;%@NL@%
    static PPRINTER pprt;%@NL@%
    PPRINTER            pprtQueue=NULL;%@NL@%
    PPRINTER            pprtPrinter=NULL;%@NL@%
    PPRINTERLIST    pprtlist;%@NL@%
    static char *   pszPrinter;%@NL@%
    static char *   pszQueue;%@NL@%
%@NL@%
    // Build initial printer list%@NL@%
%@NL@%
    psrchp = PrinterBeginSearch(&pprt); // Get first printer%@NL@%
    if (psrchp == NULL)                 // No printers installed%@NL@%
        return NULL;                        //  Fail%@NL@%
%@NL@%
    pprtlist = MemAlloc(sizeof(PRINTERLIST)); // Create list%@NL@%
    if (pprtlist == NULL) {                // No memory%@NL@%
        PrinterEndSearch(psrchp);        // Done searching%@NL@%
        return NULL;                        // Fail%@NL@%
    }%@NL@%
    pprtlist->pprtHead = NULL;%@NL@%
    pprtlist->pprtTail = NULL;%@NL@%
%@NL@%
    // Add all printers%@NL@%
%@NL@%
    while (pprt != NULL) {                // Get all printers%@NL@%
        AddPrinter(pprtlist,pprt);        // Add to list%@NL@%
        pprt = PrinterNextSearch(psrchp); // Get another printer%@NL@%
    }%@NL@%
    PrinterEndSearch(psrchp);                // Done searching%@NL@%
%@NL@%
    // Now we have a list of printers that may have multiple queues%@NL@%
    // associated with them, and may have multiple drivers.%@NL@%
    //%@NL@%
    // Here, we split entries to get one per queue%@NL@%
    // It may still be the case that the driver.model are incorrect%@NL@%
    // for the Queue.  However, we do a "lazy evaluation" of this,%@NL@%
    // using the fMultipleDrivers flag.  See PrintQueryPrinterInfo%@NL@%
    // and GetDriverModel for more details.%@NL@%
%@NL@%
    // Split any multi-queue entries%@NL@%
%@NL@%
    for (pprt=pprtlist->pprtHead; pprt!=NULL; ) {%@NL@%
        pprt = SplitPrinter(pprtlist,pprt);         // Split, if necessary%@NL@%
    }%@NL@%
%@NL@%
    // Find default printer%@NL@%
%@NL@%
    QueryDefaultPrinterQueue(&pszQueue,&pszPrinter);%@NL@%
    pprt = MatchPrinter(pprtlist,pszQueue,pszPrinter);%@NL@%
    if (pprt == NULL)                        // No default printer%@NL@%
        pprt = pprtlist->pprtHead;        //  Choose first printer%@NL@%
    pprtlist->pprtDefault = pprt;        // Remember default printer%@NL@%
%@NL@%
    if (pszQueue != NULL)                // Free default printer/queue names%@NL@%
        MemFree(pszQueue);%@NL@%
    if (pszPrinter != NULL)%@NL@%
        MemFree(pszPrinter);%@NL@%
%@NL@%
    pprtlist->hab = hab;                // Remember hab%@NL@%
    return pprtlist;                        // Return list to caller%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrintDestroyPrinterList - Destroy printer list%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hprtlist - printer list%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns TRUE, list destroyed%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns FALSE%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL          PrintDestroyPrinterList(HPRINTERLIST hprtlist)%@NL@%
{%@NL@%
    PPRINTER            pprt;%@NL@%
    PPRINTERLIST    pprtlist = hprtlist;%@NL@%
    PPRINTER            pprtNext;%@NL@%
%@NL@%
    if (pprtlist == NULL)%@NL@%
        return FALSE;%@NL@%
%@NL@%
    MemAssert(pprtlist);%@NL@%
%@NL@%
    pprt = pprtlist->pprtHead;                // Start with first printer%@NL@%
    while (pprt != NULL) {                // Loop through list%@NL@%
        pprtNext = pprt->pprtNext;        // Next printer%@NL@%
        DestroyPrinter(pprt);                // Destroy this one%@NL@%
        pprt = pprtNext;                // Advance%@NL@%
    }%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrintQueryNextPrinter - Get a printer from a list of printers%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Use PrintQueryPrinterInfo to get information on a printer.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hprtlist - printer list%@NL@%
%@AB@% *            hprt     - starting printer%@NL@%
%@AB@% *                          NULL => return first printer in list%@NL@%
%@AB@% *                         !NULL => return printer after hprt%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns HPRT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns NULL%@NL@%
%@AB@% */%@AE@%%@NL@%
HPRINTER PrintQueryNextPrinter(HPRINTERLIST hprtlist,HPRINTER hprt)%@NL@%
{%@NL@%
    PPRINTERLIST    pprtlist = hprtlist;%@NL@%
    PPRINTER            pprt = hprt;%@NL@%
%@NL@%
    MemAssert(pprtlist);%@NL@%
    if (pprt == NULL)                        // Get first printer%@NL@%
        return pprtlist->pprtHead;%@NL@%
    else {                                // Get next printer%@NL@%
        MemAssert(pprt);%@NL@%
        if (pprt->pprtlist != pprtlist) // Verify hprt is on specified list%@NL@%
            MemAssert(NULL);%@NL@%
        return pprt->pprtNext;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrintQueryDefaultPrinter - Return default printer%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hprtlist - printer list%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            Returns HPRINTER of default printer.%@NL@%
%@AB@% */%@AE@%%@NL@%
HPRINTER PrintQueryDefaultPrinter(HPRINTERLIST hprtlist)%@NL@%
{%@NL@%
    PPRINTERLIST    pprtlist = hprtlist;%@NL@%
%@NL@%
    MemAssert(pprtlist);%@NL@%
    return pprtlist->pprtDefault;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrintQueryPrinterInfo - Get info on a printer%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hprt  - printer handle%@NL@%
%@AB@% *            index - index of printer info%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns requested information%@NL@%
%@AB@% *                PQPI_NAME          - char * - Nice name%@NL@%
%@AB@% *                PQPI_LOG_ADDRESS  - char * - Logical address%@NL@%
%@AB@% *                PQPI_DRIVER          - char * - Driver name%@NL@%
%@AB@% *                PQPI_MODEL          - char * - Model name%@NL@%
%@AB@% *                PQPI_TYPE          - ULONG  - OD_QUEUED or OD_DIRECT%@NL@%
%@AB@% *                PQPI_PRINTER          - char * - Printer name%@NL@%
%@AB@% *                PQPI_DESCRIPTION  - char * - Description%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns -1L%@NL@%
%@AB@% */%@AE@%%@NL@%
ULONG PrintQueryPrinterInfo(HPRINTER hprt,USHORT index)%@NL@%
{%@NL@%
    PPRINTER        pprt = hprt;%@NL@%
%@NL@%
    MemAssert(pprt);%@NL@%
    switch (index) {%@NL@%
        case PQPI_NAME:%@NL@%
            return (ULONG)(VOID FAR *)pprt->pszName;%@NL@%
%@NL@%
        case PQPI_LOG_ADDRESS:%@NL@%
            return (ULONG)(VOID FAR *)pprt->pszLogAddr;%@NL@%
%@NL@%
        case PQPI_DRIVER:%@NL@%
            GetDriverModel(pprt);        // Make sure we get correct data%@NL@%
            return (ULONG)(VOID FAR *)pprt->pszDriver;%@NL@%
%@NL@%
        case PQPI_MODEL:%@NL@%
            GetDriverModel(pprt);        // Make sure we get correct data%@NL@%
            return (ULONG)(VOID FAR *)pprt->pszModel;%@NL@%
%@NL@%
        case PQPI_TYPE:%@NL@%
            return pprt->lType;%@NL@%
%@NL@%
        case PQPI_PRINTER:%@NL@%
            return (ULONG)(VOID FAR *)pprt->pszPrinter;%@NL@%
%@NL@%
        case PQPI_DESCRIPTION:%@NL@%
            GetDescription(pprt);        // Get appropriate description%@NL@%
            return (ULONG)(VOID FAR *)pprt->pszDescription;%@NL@%
%@NL@%
        default:%@NL@%
            return -1L;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrintOpenDC - Open DC on specified printer%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hab         - Anchor block%@NL@%
%@AB@% *            hprt        - Printer handle%@NL@%
%@AB@% *            pszDataType - "PM_Q_STD" or "PM_Q_RAW"%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns hdc%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns NULL%@NL@%
%@AB@% */%@AE@%%@NL@%
HDC PrintOpenDC(HAB hab,HPRINTER hprt,char *pszDataType)%@NL@%
{%@NL@%
    DEVOPENSTRUC    dop;%@NL@%
    HDC             hdc;%@NL@%
    PPRINTER            pprt = hprt;%@NL@%
%@NL@%
    MemAssert(pprt);%@NL@%
    GetDriverData(pprt);                // Make sure we have driver data%@NL@%
%@NL@%
    dop.pszLogAddress = pprt->pszLogAddr; // Logical address%@NL@%
    dop.pszDriverName = pprt->pszDriver; // Driver name (PSCRIPT)%@NL@%
    dop.pdriv              = (VOID *)pprt->pbDriverData; // Driver data%@NL@%
    dop.pszDataType   = pszDataType;        // PM_Q_STD or PM_Q_RAW%@NL@%
%@NL@%
 // dop.pszComment    = "stock chart";        // Comment for OD_Q%@NL@%
 // dop.pszQueueProcName   = NULL;        // queue processor; NULL => use default%@NL@%
 // dop.pszQueueProcParams = NULL;        // parms for queue processor%@NL@%
 // dop.pszSpoolerParams   = NULL;        // spooler parms (use NULL!)%@NL@%
 // dop.pszNetworkParams   = NULL;        // network parms (use NULL!)%@NL@%
%@NL@%
    hdc = DevOpenDC(%@NL@%
            hab,                        // anchor block%@NL@%
            pprt->lType,                // DC type: OD_DIRECT or OD_QUEUED%@NL@%
            "*",                        // device info(?) "*"%@NL@%
            4L,                         // count of info in DEVOPENSTRUC%@NL@%
            (PDEVOPENDATA)&dop,         // DEVOPENSTRUC%@NL@%
            NULL                        // Compatible DC (use NULL?)%@NL@%
    );%@NL@%
    return hdc;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrintQueryJobProperties - Get printer job properties%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hprt    - printer handle%@NL@%
%@AB@% *            pcbData - pointer to size of pb buffer in bytes%@NL@%
%@AB@% *                        Pass 0 to determine required buffer size.%@NL@%
%@AB@% *            pbData  - pointer to buffer to receive job properties%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns TRUE, job properties retrieved%@NL@%
%@AB@% *                pb filled in with job property data%@NL@%
%@AB@% *                pcb filled in with size of pb data%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns FALSE, pb too small for job properties%@NL@%
%@AB@% *                pcb filled in with required size%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Note%@NL@%
%@AB@% *            (1) It is valid for a printer to require no job properties.%@NL@%
%@AB@% *                In this case, *pcb == 0.%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL PrintQueryJobProperties(HPRINTER hprt,USHORT *pcbData,BYTE *pbData)%@NL@%
{%@NL@%
    USHORT        cb;                        // Total buffer size%@NL@%
    USHORT        cbData;                 // Size of driver data%@NL@%
    USHORT        cbDriver;                // Size of driver name (counting NUL)%@NL@%
    USHORT        cbModel;                // Size of model name (counting NUL)%@NL@%
    USHORT        cbName;                 // Size of printer name (counting NUL)%@NL@%
    BYTE *        pb;%@NL@%
    PJOBPROP        pjp;%@NL@%
    PPRINTER        pprt = hprt;%@NL@%
%@NL@%
    MemAssert(pprt);%@NL@%
    GetDriverData(pprt);                // Make sure we have driver data%@NL@%
%@NL@%
    cbName   = strlen(pprt->pszName)+1; // Count NUL%@NL@%
    cbDriver = strlen(pprt->pszDriver)+1; // Count NUL%@NL@%
    cbModel  = strlen(pprt->pszModel)+1; // Count NUL%@NL@%
    cbData   = pprt->cbDriverData;        // Driver data length%@NL@%
%@NL@%
    // Check size of return buffer%@NL@%
%@NL@%
    cb = sizeof(JOBPROP)+cbName+cbDriver+cbModel+cbData;%@NL@%
    if (*pcbData < cb) {                // Check buffer size%@NL@%
        *pcbData = cb;                        //  Too small, return required size%@NL@%
        return FALSE;                        // Indicate failure%@NL@%
    }%@NL@%
%@NL@%
    // Fill in return buffer%@NL@%
%@NL@%
    pjp = (PJOBPROP)pbData;%@NL@%
    pjp->cb          = cb;%@NL@%
    pjp->cbName   = cbName;%@NL@%
    pjp->cbDriver = cbDriver;%@NL@%
    pjp->cbModel  = cbModel;%@NL@%
    pjp->cbData   = cbData;%@NL@%
%@NL@%
    pb = (BYTE *)pjp+sizeof(JOBPROP);        // Start of data space%@NL@%
%@NL@%
    pb = memcpy(pb,pprt->pszName,cbName);%@NL@%
    pb += cbName;%@NL@%
%@NL@%
    pb = memcpy(pb,pprt->pszDriver,cbDriver);%@NL@%
    pb += cbDriver;%@NL@%
%@NL@%
    pb = memcpy(pb,pprt->pszModel,cbModel);%@NL@%
    pb += cbModel;%@NL@%
%@NL@%
    memcpy(pb,pprt->pbDriverData,cbData);%@NL@%
%@NL@%
    *pcbData = cb;                        // Return actual size%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrintChangeJobProperties - Let user change printer job properties%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hprt    - printer handle%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns TRUE, job properties changed%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns FALSE, job properties not changed%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL PrintChangeJobProperties(HPRINTER hprt)%@NL@%
{%@NL@%
    HAB         hab;%@NL@%
    BYTE *        pb;%@NL@%
    PPRINTER        pprt = hprt;%@NL@%
    char *        pszName;%@NL@%
    LONG        rc;%@NL@%
%@NL@%
    MemAssert(pprt);%@NL@%
    MemAssert(pprt->pprtlist);%@NL@%
    hab = pprt->pprtlist->hab;%@NL@%
%@NL@%
    GetDriverData(pprt);                // Try to get driver data%@NL@%
%@NL@%
    if (pprt->pbDriverData != NULL) {        // We do have it%@NL@%
        pb = pprt->pbDriverData;        //  Use our data as starting point%@NL@%
        pszName = NULL;                 // Do not use printer name%@NL@%
    }%@NL@%
    else {%@NL@%
        pb = NULL;                        // We have no data%@NL@%
        pszName = pprt->pszName;        // Tell driver to get it from printer%@NL@%
    }%@NL@%
%@NL@%
    rc = DevPostDeviceModes(%@NL@%
            hab,                        // Anchor block%@NL@%
            (VOID *)pb,                 // Buffer for data%@NL@%
            pprt->pszDriver,                // Driver name%@NL@%
            pprt->pszModel,                // Device name%@NL@%
            pszName,                        // Printer name%@NL@%
            DPDM_POSTJOBPROP                // Option%@NL@%
    );%@NL@%
    return (rc == DEV_OK);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrintResetJobProperties - Reset printer to default job properties%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hprt - printer handle%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            Job properties set to default for printer%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID PrintResetJobProperties(HPRINTER hprt)%@NL@%
{%@NL@%
    HAB         hab;%@NL@%
    PPRINTER        pprt = hprt;%@NL@%
%@NL@%
    MemAssert(pprt);%@NL@%
    MemAssert(pprt->pprtlist);%@NL@%
    hab = pprt->pprtlist->hab;%@NL@%
%@NL@%
    // Free properties, if present%@NL@%
%@NL@%
    if (pprt->pbDriverData != NULL) {%@NL@%
        MemFree(pprt->pbDriverData);%@NL@%
        pprt->pbDriverData = NULL;%@NL@%
        pprt->cbDriverData = 0;%@NL@%
    }%@NL@%
%@NL@%
    // Get job properties%@NL@%
%@NL@%
    GetDriverData(pprt);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrintMatchPrinter - Select printer that matches job properties%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hprtlist - printer list%@NL@%
%@AB@% *            cbData   - size of pb buffer in bytes%@NL@%
%@AB@% *            pbData   - buffer with job properties%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns valid HPRINTER that matches Job Properties%@NL@%
%@AB@% *            Supplied job properties are set for printer.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns NULL, no matching printer%@NL@%
%@AB@% *                Caller should use default printer (PrintQueryDefaultPrinter)%@NL@%
%@AB@% */%@AE@%%@NL@%
HPRINTER PrintMatchPrinter(HPRINTERLIST hprtlist,USHORT cbData,BYTE *pbData)%@NL@%
{%@NL@%
    ULONG            cb;%@NL@%
    HAB             hab;%@NL@%
    BYTE *            pb;                 // Driver data%@NL@%
    PJOBPROP            pjp;%@NL@%
    PPRINTER            pprt;%@NL@%
    PPRINTER            pprtMatch;%@NL@%
    PPRINTERLIST    pprtlist = hprtlist;%@NL@%
    char *            pszDriver;                // Driver name%@NL@%
    char *            pszModel;                // Model name%@NL@%
    char *            pszName;                // Printer name%@NL@%
%@NL@%
    MemAssert(pprtlist);%@NL@%
    hab = pprtlist->hab;%@NL@%
%@NL@%
    // Buffer must be at least as large as header%@NL@%
%@NL@%
    if (cbData < sizeof(JOBPROP))        // Too small%@NL@%
        return NULL;                        //  Fail%@NL@%
%@NL@%
    // Check internal length%@NL@%
%@NL@%
    pjp = (PJOBPROP)pbData;                // Point at header%@NL@%
    if (pjp->cb != cbData)                // Internal length does not match%@NL@%
        return NULL;                        //  Fail%@NL@%
%@NL@%
    // Check internal counts%@NL@%
%@NL@%
    cb = pjp->cbName+pjp->cbDriver+pjp->cbModel+pjp->cbData+sizeof(JOBPROP);%@NL@%
    if (cb > (ULONG)USHRT_MAX)                // Numbers too large%@NL@%
        return NULL;%@NL@%
    if ((USHORT)cb != cbData)                // Lengths do not match%@NL@%
        return NULL;%@NL@%
%@NL@%
    // Set string/data pointers%@NL@%
%@NL@%
    pszName = (BYTE *)pjp+sizeof(JOBPROP); // Name%@NL@%
    pszDriver = pszName + pjp->cbName;           // Driver%@NL@%
    pszModel = pszDriver + pjp->cbDriver;  // Model%@NL@%
    pb = pszModel + pjp->cbModel;           // Data%@NL@%
%@NL@%
    // Try to find close match%@NL@%
    //%@NL@%
    // If we find a printer that matches Name, Driver, Model, and driver%@NL@%
    // data size, we have an exact match, and return that.%@NL@%
    //%@NL@%
    // If we find a printer that matches all but the Name, we return the%@NL@%
    // first such printer (after examining all printers to make sure there%@NL@%
    // is no exact match.%@NL@%
    //%@NL@%
    // Otherwise, we return NULL.%@NL@%
%@NL@%
    pprtMatch = NULL;                        // No match, yet%@NL@%
    for (pprt=pprtlist->pprtHead; pprt!=NULL; pprt=pprt->pprtNext) {%@NL@%
        if ( (stricmp(pprt->pszDriver,pszDriver) == 0) &&%@NL@%
             (stricmp(pprt->pszModel,pszModel) == 0) ) { // Match Driver.Model%@NL@%
%@NL@%
            cb = DevPostDeviceModes(        // Get driver data size%@NL@%
                    hab,                // Anchor block%@NL@%
                    NULL,                // Buffer for data (NULL returns size)%@NL@%
                    pprt->pszDriver,        // Driver name%@NL@%
                    pprt->pszModel,        // Device name%@NL@%
                    NULL,                // Printer name%@NL@%
                    DPDM_QUERYJOBPROP        // Option%@NL@%
            );%@NL@%
%@NL@%
            if (cb == pjp->cbData) {        // Match driver data size%@NL@%
                if (stricmp(pprt->pszName,pszName) == 0) { // Exact match?%@NL@%
                    pprtMatch = pprt;        // Exact match%@NL@%
                    break;                // Exit loop%@NL@%
                }%@NL@%
                else if (pprtMatch == NULL) // First close match%@NL@%
                    pprtMatch = pprt;        // Remember close match%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    // Update job properties in printer%@NL@%
%@NL@%
    if (pprtMatch != NULL) {                // Found a match%@NL@%
        if (pprt->pbDriverData == NULL) // No buffer, yet%@NL@%
            pprt->pbDriverData = MemAlloc(pjp->cbData); // Alloc buffer%@NL@%
%@NL@%
        if (pprt->pbDriverData != NULL) { // Have buffer%@NL@%
            memcpy(pprt->pbDriverData,pb,pjp->cbData); // Save job properties%@NL@%
            pprt->cbDriverData = pjp->cbData; // Save JP size%@NL@%
        }%@NL@%
    }%@NL@%
    return pprtMatch;                        // Return best match%@NL@%
}%@NL@%
%@NL@%
%@NL@%
/%@AB@%/************************************************************************%@NL@%
%@AB@%//%@NL@%
%@AB@%//  PRIVATE Functions%@NL@%
%@AB@%//%@NL@%
/%@AB@%/************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%/***        MatchPrinter - Look for printer in list%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            pprtlist   - Printer list%@NL@%
%@AB@% *            pszQueue   - Queue name to match (may be NULL)%@NL@%
%@AB@% *            pszPrinter - Printer name to match (may be NULL)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns TRUE%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns FALSE%@NL@%
%@AB@% */%@AE@%%@NL@%
PPRINTER MatchPrinter(PPRINTERLIST pprtlist,char *pszQueue,char *pszPrinter)%@NL@%
{%@NL@%
    PPRINTER        pprt;%@NL@%
%@NL@%
    for (pprt=pprtlist->pprtHead; pprt!=NULL; pprt=pprt->pprtNext) {%@NL@%
        if ((pprt->lType == OD_QUEUED) && (pszQueue != NULL)) { // A queue%@NL@%
            if (strcmp(pprt->pszLogAddr,pszQueue) == 0)%@NL@%
                return pprt;%@NL@%
        }%@NL@%
        else if (pszPrinter != NULL) {        // A direct printer%@NL@%
            if (strcmp(pprt->pszPrinter,pszPrinter) == 0)%@NL@%
                return pprt;%@NL@%
        }%@NL@%
    }%@NL@%
    return NULL;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        AddPrinter - Add printer to printer list (if unique)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        NOTE: If the printer is not added, it is freed!%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            pprtlist - printer list%@NL@%
%@AB@% *            pprt     - printer to be added%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns TRUE%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns FALSE%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL AddPrinter(PPRINTERLIST pprtlist,PPRINTER pprtNew)%@NL@%
{%@NL@%
    PPRINTER        pprt;%@NL@%
%@NL@%
    // Avoid duplicate entry%@NL@%
%@NL@%
    if (pprtNew->lType == OD_QUEUED) {        // Queue, check for duplicate%@NL@%
        pprt = MatchPrinter(pprtlist,pprtNew->pszLogAddr,NULL);%@NL@%
        if (pprt != NULL) {                // Found a match%@NL@%
            pprt->fMultipleDrivers = TRUE; // Force query of driver/model%@NL@%
            DestroyPrinter(pprtNew);        // No need for new printer%@NL@%
            return TRUE;                // Do not add printer%@NL@%
        }%@NL@%
    }%@NL@%
    else {                                // Direct printer%@NL@%
        // Do nothing, since Print Manager/Spooler never produce%@NL@%
        // duplicate printers.%@NL@%
        ;                                // Do nothing%@NL@%
    }%@NL@%
%@NL@%
    // Link onto list%@NL@%
%@NL@%
    pprtNew->pprtPrev = pprtlist->pprtTail; // Set previous printer%@NL@%
    if (pprtlist->pprtHead == NULL)        // List is empty%@NL@%
        pprtlist->pprtHead = pprtNew;        // Put at head of list%@NL@%
    else%@NL@%
        pprtlist->pprtTail->pprtNext = pprtNew; // Add at end of list%@NL@%
    pprtlist->pprtTail = pprtNew;        // New tail of list%@NL@%
    pprtNew->pprtNext = NULL;                // Set next printer%@NL@%
%@NL@%
    pprtNew->pprtlist = pprtlist;        // Point at owning list%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        SplitPrinter - Split printer if it contains multiple queue names%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            pprtlist - printer list%@NL@%
%@AB@% *            pprt     - printer to be split%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            Returns next PPRINTER%@NL@%
%@AB@% */%@AE@%%@NL@%
PPRINTER SplitPrinter(PPRINTERLIST pprtlist,PPRINTER pprtOld)%@NL@%
{%@NL@%
    PPRINTER        pprt;%@NL@%
    PPRINTER        pprtNext;%@NL@%
    PPRINTER        pprtPrev;%@NL@%
    char *        psz;%@NL@%
    char *        psz1;%@NL@%
    USHORT        cprtAdded=0;%@NL@%
%@NL@%
    if (pprtOld->lType != OD_QUEUED)        // If not a queue%@NL@%
        return pprtOld->pprtNext;        //  Next printer%@NL@%
%@NL@%
    psz = strpbrk(pprtOld->pszLogAddr,","); // Find queue name separator%@NL@%
    if (psz == NULL)                        // If no separator%@NL@%
        return pprtOld->pprtNext;        //  Next printer%@NL@%
%@NL@%
    // Split up the printer%@NL@%
%@NL@%
    strcpy(achPath,pprtOld->pszLogAddr); // Get working copy of queue name%@NL@%
    psz = achPath;%@NL@%
    while (psz != NULL) {%@NL@%
        psz1 = strpbrk(psz,",");        // Find separator%@NL@%
        if (psz1 != NULL) {                // Found one%@NL@%
            *psz1 = '\0';                // Terminate this queue name%@NL@%
            psz1++;                        // Advance to next queue name%@NL@%
        }%@NL@%
        pprt = ClonePrinter(pprtOld,psz); // Clone with different pszLogAddr%@NL@%
        if (pprt == NULL)                // Clone failed%@NL@%
            psz = NULL;                 // Exit loop%@NL@%
        else {                                // Clone successful%@NL@%
            AddPrinter(pprtlist,pprt);        // Add new printer%@NL@%
            cprtAdded++;                // Printer (may have been) added%@NL@%
            psz = psz1;                 // Advance to next queue (if any)%@NL@%
            // Note: AddPrinter may not have actually added the printer,%@NL@%
            //             because it the split printer may have been a duplicate.%@NL@%
            //             That is okay, though, because we use cprtAdded only%@NL@%
            //             to know if we can delete pprtOld.%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    // Delete old printer, if we were able to split it%@NL@%
    //%@NL@%
    // If we were not able to clone the printer at all, then we leave%@NL@%
    // it in the list, since the queue list was truncated to the first%@NL@%
    // queue name!%@NL@%
    //%@NL@%
    // The normal case, however, is that we did split it successfully,%@NL@%
    // so we want to delete the old printer.%@NL@%
    //%@NL@%
    // NOTE: If we were guaranteed that one of the AddPrinter calls actually%@NL@%
    //             added a printer, we would *know* that pprtNext would never be%@NL@%
    //             NULL.  However, it is possible that a split could result in%@NL@%
    //             printers that are *all* already in the list.  Besides, the%@NL@%
    //             code is more robust this way.%@NL@%
%@NL@%
    pprtNext = pprtOld->pprtNext;        // Next printer%@NL@%
    if (cprtAdded != 0) {                // Have to delete old printer%@NL@%
        pprtPrev = pprtOld->pprtPrev;        // Previous printer%@NL@%
        if (pprtNext != NULL)                // There is a following printer%@NL@%
            pprtNext->pprtPrev = pprtPrev; // Set back link%@NL@%
        if (pprtPrev != NULL)                // There is a preceding printer%@NL@%
            pprtPrev->pprtNext = pprtNext; // Set forward link%@NL@%
        DestroyPrinter(pprtOld);        // No need for this anymore%@NL@%
    }%@NL@%
%@NL@%
    return pprtNext;                        // Next printer%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        ClonePrinter - Create a duplicate PRINTER with a different pszLogAddr%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            pprt       - printer to clone%@NL@%
%@AB@% *            pszLogAddr - logical address to set (QUEUE1)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns PPRINTER%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns NULL%@NL@%
%@AB@% */%@AE@%%@NL@%
PPRINTER ClonePrinter(PPRINTER pprtOriginal,char *pszLogAddr)%@NL@%
{%@NL@%
    PPRINTER        pprt;%@NL@%
%@NL@%
    pprt = CreatePrinter(%@NL@%
                pprtOriginal->lType,                // Copy type%@NL@%
                pszLogAddr,                        // New logical address%@NL@%
                pprtOriginal->pszPrinter,        // Copy printer%@NL@%
                pprtOriginal->pszDriver,        // Copy driver%@NL@%
                pprtOriginal->pszModel,         // Copy model%@NL@%
                pprtOriginal->fMultipleDrivers        // Copy flag%@NL@%
           );%@NL@%
    return pprt;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        GetDriverModel - Get Driver and Model for a printer%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            pprt - printer%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            If printer was a queue, and the existing printer/model may%@NL@%
%@AB@% *            not be the one the user setup, get it from the HINI_SYSTEM.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Uses%@NL@%
%@AB@% *            achPath%@NL@%
%@AB@% *%@NL@%
%@AB@% *        NOTE 1:%@NL@%
%@AB@% *            We *need* to query the PM_SPOOLER_QUEUE_DD section *only* if the%@NL@%
%@AB@% *            queue might have more than one driver associated with it.  This%@NL@%
%@AB@% *            could happen in several cases:%@NL@%
%@AB@% *%@NL@%
%@AB@% *                1)  If the queue is associated with a single printer, but%@NL@%
%@AB@% *                        that printer has more than one driver/model pair.%@NL@%
%@AB@% *%@NL@%
%@AB@% *                2)  If the queue is associated with more than one printer,%@NL@%
%@AB@% *                        and the set of driver/model pairs supported by%@NL@%
%@AB@% *                        these printers has more than one member.%@NL@%
%@AB@% *%@NL@%
%@AB@% *            (1) Is easy to compute (we keep a flag when we build the PRINTER%@NL@%
%@AB@% *                object).%@NL@%
%@AB@% *%@NL@%
%@AB@% *            (2) Is more complicated, so we compute a cheaper version:%@NL@%
%@AB@% *%@NL@%
%@AB@% *                2a) If the queue is associated with more than one printer.%@NL@%
%@AB@% *%@NL@%
%@AB@% *                We compute this in AddPrinter.        If AddPrinter tries to add%@NL@%
%@AB@% *                a PRINTER that has a pszLogAddr that matches one already%@NL@%
%@AB@% *                added, then it knows we have a queue pointing to more than%@NL@%
%@AB@% *                one printer.  So, it sets the fMultipleDrivers flag, and then%@NL@%
%@AB@% *                the code below can use that single flag to determine if it%@NL@%
%@AB@% *                has to get the driver/model from HINI_SYSTEM).%@NL@%
%@AB@% *%@NL@%
%@AB@% *        NOTE 2:%@NL@%
%@AB@% *             For an OD_DIRECT printer (no queue) there is no way to figure%@NL@%
%@AB@% *             out which driver/model pair to use, so we take the first one%@NL@%
%@AB@% *             in the list!  Since that is what we did when we built the%@NL@%
%@AB@% *             printer object initialy, we have nothing to do.%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID GetDriverModel(PPRINTER pprt)%@NL@%
{%@NL@%
    LONG    cb;%@NL@%
    char *  psz;%@NL@%
    char *  pszDriver;%@NL@%
    char *  pszModel;%@NL@%
%@NL@%
%@NL@%
    if (pprt->lType != OD_QUEUED)        // Not a queue%@NL@%
        return;                         //  Driver.model are correct%@NL@%
%@NL@%
    if (!pprt->fMultipleDrivers)        // Only one driver%@NL@%
        return;                         //  No change needed%@NL@%
%@NL@%
    // We have a queue with multiple driver.model choices%@NL@%
%@NL@%
    pprt->fMultipleDrivers = FALSE;        // Only do this computation once%@NL@%
%@NL@%
    // Get driver.model for this queue%@NL@%
%@NL@%
    cb = PrfQueryProfileString(%@NL@%
            HINI_SYSTEM,                // system ini%@NL@%
            "PM_SPOOLER_QUEUE_DD",        // app section%@NL@%
            pprt->pszName,                // printer name%@NL@%
            "",                         // Default value%@NL@%
            achPath,                        // Buffer to receive value%@NL@%
            (ULONG)sizeof(achPath)        // Buffer size%@NL@%
    );%@NL@%
    if (cb <= 1)                        // No driver.model%@NL@%
        return;                         // Use existing one%@NL@%
%@NL@%
    // Parse driver.model string%@NL@%
%@NL@%
    psz = achPath;%@NL@%
    // A: "IBM4201;"%@NL@%
    //           ^%@NL@%
    // B: "LASERJET.HP LaserJet IID;"%@NL@%
    //           ^%@NL@%
%@NL@%
    // Parse the driver and model names%@NL@%
%@NL@%
    pszDriver = psz;                        // Set driver name%@NL@%
    psz = strpbrk(psz,".;");                // Find separator%@NL@%
    if (psz == NULL)                        // Bad format%@NL@%
        return;                         //  Exit without changing%@NL@%
    if (*psz == '.') {                        // Found model name separator%@NL@%
        *psz = '\0';                        // Null terminate driver name%@NL@%
        pszModel = psz + 1;                // Set model name%@NL@%
        psz = strpbrk(pszModel,";");        // Find end of model name%@NL@%
        if (psz == NULL)                // Bad format%@NL@%
            return;                        //  Exit without changing%@NL@%
    }%@NL@%
    else                                // No model name%@NL@%
        pszModel = pszDriver;                // Make model same as driver name%@NL@%
    *psz = '\0';                        // Null terminate driver name%@NL@%
%@NL@%
    // Create string copies%@NL@%
%@NL@%
    pszDriver = MemStrDup(pszDriver);%@NL@%
    if (pszDriver == NULL)%@NL@%
        return;%@NL@%
%@NL@%
    pszModel = MemStrDup(pszModel);%@NL@%
    if (pszModel == NULL) {%@NL@%
        MemFree(pszDriver);%@NL@%
        return;%@NL@%
    }%@NL@%
%@NL@%
    // Update printer structure%@NL@%
%@NL@%
    if (pprt->pszDriver != NULL)%@NL@%
        MemFree(pprt->pszDriver);%@NL@%
    if (pprt->pszModel != NULL)%@NL@%
        MemFree(pprt->pszModel);%@NL@%
%@NL@%
    pprt->pszDriver = pszDriver;%@NL@%
    pprt->pszModel = pszModel;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        GetDescription - Get description from HINI_SYSTEM%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Get printer description or queue description, as appropriate.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            pprt - printer%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            Set description from HINI_SYSTEM.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Uses%@NL@%
%@AB@% *            achPath%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID GetDescription(PPRINTER pprt)%@NL@%
{%@NL@%
    LONG    cb;%@NL@%
    char *  psz;%@NL@%
    char *  pszApp;%@NL@%
%@NL@%
    if (pprt->lType == OD_QUEUED)    // Queue%@NL@%
        pszApp = "PM_SPOOLER_QUEUE_DESCR";%@NL@%
    else%@NL@%
        pszApp = "PM_SPOOLER_PRINTER_DESCR";%@NL@%
%@NL@%
    cb = PrfQueryProfileString(%@NL@%
            HINI_SYSTEM,                // System ini%@NL@%
            pszApp,                        // App%@NL@%
            pprt->pszName,                // Queue/printer name%@NL@%
            "",                         // Default value%@NL@%
            achPath,                        // Buffer to receive value%@NL@%
            (ULONG)sizeof(achPath)        // Buffer size%@NL@%
    );%@NL@%
    if (cb <= 1)                        // No description%@NL@%
        return;                         // Use existing one%@NL@%
%@NL@%
    // Parse description%@NL@%
%@NL@%
    psz = achPath;%@NL@%
    psz = strpbrk(psz,";");                // Find end of description%@NL@%
    if (psz == NULL)                        // Bad format%@NL@%
        return;                         //  Exit without changing%@NL@%
    *psz = '\0';                        // Null terminate desription%@NL@%
%@NL@%
    // Duplicate description%@NL@%
%@NL@%
    psz = MemStrDup(achPath);%@NL@%
    if (psz == NULL)%@NL@%
        return;%@NL@%
%@NL@%
    if (pprt->pszDescription != NULL)%@NL@%
        MemFree(pprt->pszDescription);%@NL@%
    pprt->pszDescription = psz;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        QueryDefaultPrinterQueue - Get the default printer and queue%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            ppszQueue        - pointer to receive pointer to queue name%@NL@%
%@AB@% *            ppszPrinter - pointer to receive pointer to printer name%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            One or both of ppszQueue/ppszPrinter may be set to NULL!%@NL@%
%@AB@% *            Caller must call MemFree on ppszQueue/Printer!%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Uses%@NL@%
%@AB@% *            achPath%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID QueryDefaultPrinterQueue(char **ppszQueue,char **ppszPrinter)%@NL@%
{%@NL@%
    ULONG   cb;%@NL@%
%@NL@%
    // Get default printer and queue%@NL@%
%@NL@%
    cb = PrfQueryProfileString(%@NL@%
            HINI_USER,                        // OS2.INI%@NL@%
            "PM_SPOOLER",                // Application%@NL@%
            "PRINTER",                        // Variable%@NL@%
            "",                         // Default value%@NL@%
            achPath,                        // Buffer to receive value%@NL@%
            (ULONG)sizeof(achPath)        // Buffer size%@NL@%
         );%@NL@%
    if (cb == 0)                        // Couldn't get value%@NL@%
        *ppszPrinter = NULL;%@NL@%
    else {%@NL@%
        TrimTrailingSemicolon(achPath); // Get rid of trailing ";"%@NL@%
        *ppszPrinter = MemStrDup(achPath);%@NL@%
    }%@NL@%
%@NL@%
    cb = PrfQueryProfileString(%@NL@%
            HINI_USER,                        // OS2.INI%@NL@%
            "PM_SPOOLER",                // Application%@NL@%
            "QUEUE",                        // Variable%@NL@%
            "",                         // Default value%@NL@%
            achPath,                        // Buffer to receive value%@NL@%
            (ULONG)sizeof(achPath)        // Buffer size%@NL@%
         );%@NL@%
    if (cb == 0)%@NL@%
        *ppszQueue = NULL;                // Couldn't get value%@NL@%
    else {%@NL@%
        TrimTrailingSemicolon(achPath); // Get rid of trailing ";"%@NL@%
        *ppszQueue = MemStrDup(achPath);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        TrimTrailingSemicolon - truncate string at first semicolon%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            psz - string to truncate%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            String truncated at first semicolon (if any)%@NL@%
%@AB@% */%@AE@%%@NL@%
void TrimTrailingSemicolon(char *psz)%@NL@%
{%@NL@%
    while ((*psz != '\0') && (*psz != ';'))%@NL@%
        psz++;%@NL@%
    *psz = '\0';%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrinterBeginSearch - Start enumeration of installed printers%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            ppprt - pointer to receive pointer to printer%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns search handle, ppprt filled in%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns NULL%@NL@%
%@AB@% */%@AE@%%@NL@%
PSEARCHP PrinterBeginSearch(PPRINTER *ppprt)%@NL@%
{%@NL@%
    ULONG        cb;%@NL@%
    ULONG        cb1;%@NL@%
    BOOL        f;%@NL@%
    PSEARCHP        psrchp;%@NL@%
%@NL@%
    // Get size of buffer for printer names%@NL@%
%@NL@%
    f = PrfQueryProfileSize(%@NL@%
            HINI_SYSTEM,                // Only look in system profile%@NL@%
            "PM_SPOOLER_PRINTER",        // Pointer to application name%@NL@%
            NULL,                        // Pointer to keyname%@NL@%
            &cb                         // Pointer to return buffer size%@NL@%
            );%@NL@%
    if (!f)%@NL@%
        return NULL;                        // Failed%@NL@%
%@NL@%
    // Create search structure%@NL@%
%@NL@%
    psrchp = MemAlloc(sizeof(SEARCHP));%@NL@%
    if (psrchp == NULL)%@NL@%
        return NULL;%@NL@%
    psrchp->pchNext = NULL;%@NL@%
%@NL@%
    // Allocate buffer for names%@NL@%
%@NL@%
    psrchp->pchName = MemAlloc((USHORT)cb);%@NL@%
    if (psrchp->pchName == NULL) {%@NL@%
        PrinterEndSearch(psrchp);        // Frees search structure%@NL@%
        return NULL;                        // Failed%@NL@%
    }%@NL@%
%@NL@%
    // Get all printer names%@NL@%
%@NL@%
    cb1 = PrfQueryProfileString(%@NL@%
            HINI_SYSTEM,                // Only look in system profile%@NL@%
            "PM_SPOOLER_PRINTER",        // Application name%@NL@%
            NULL,                        // Keyname%@NL@%
            "",                         // Default value%@NL@%
            psrchp->pchName,                // Name list to be returned%@NL@%
            cb                                // Buffer size%@NL@%
            );%@NL@%
%@NL@%
    if (cb1 == 0) {                        // No printers installed%@NL@%
        PrinterEndSearch(psrchp);%@NL@%
        return NULL;%@NL@%
    }%@NL@%
%@NL@%
    // Get first printer%@NL@%
%@NL@%
    psrchp->pchNext = psrchp->pchName;        // Start at first printer%@NL@%
    *ppprt = PrinterNextSearch(psrchp); // Get a printer%@NL@%
    if (*ppprt != NULL)                 // Found one%@NL@%
        return psrchp;                        //  Return success%@NL@%
    else {%@NL@%
        PrinterEndSearch(psrchp);        // No printer found%@NL@%
        return NULL;                        //  Return failure%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrinterNextSearch - Continue enumeration of installed printers%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            psrchp - search handle from PrinterBeginSearch%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns PPRINTER%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns NULL%@NL@%
%@AB@% */%@AE@%%@NL@%
PPRINTER PrinterNextSearch(PSEARCHP psrchp)%@NL@%
{%@NL@%
    PPRINTER        pprt=NULL;%@NL@%
%@NL@%
    // Scan printers until we find a valid one, or the list is exhausted%@NL@%
    while ((*psrchp->pchNext != '\0') && (pprt == NULL)) {%@NL@%
        pprt = GetPrinterData(psrchp->pchNext); // Get printer%@NL@%
        psrchp->pchNext += strlen(psrchp->pchNext)+1; // Next printer%@NL@%
    }%@NL@%
    return pprt;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrinterEndSearch - End enumeration of installed printer drivers%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            psearchp - search handle from PrinterBeginSearch%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns TRUE%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns FALSE%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL PrinterEndSearch(PSEARCHP psrchp)%@NL@%
{%@NL@%
    if (psrchp == NULL)%@NL@%
        return TRUE;%@NL@%
%@NL@%
    if (psrchp->pchName != NULL)%@NL@%
        MemFree(psrchp->pchName);%@NL@%
    MemFree(psrchp);%@NL@%
    return TRUE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        GetPrinterData - Get printer data%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            achPrinter - printer name%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            returns PPRINTER%@NL@%
%@AB@% *%@NL@%
%@AB@% *            NOTE 1: if lType == OD_QUEUED, then pprt->pszLogAddr is one or%@NL@%
%@AB@% *                    more queue names (separated by ",").%@NL@%
%@AB@% *%@NL@%
%@AB@% *                    The caller should clone the PRINTER structure as many%@NL@%
%@AB@% *                    times as necessary so that there is one for each queue.%@NL@%
%@AB@% *%@NL@%
%@AB@% *            NOTE 2: pprt->pszDescription is not filled in.%@NL@%
%@AB@% *%@NL@%
%@AB@% *                    After the caller solves Note 1, the description should%@NL@%
%@AB@% *                    be retrieved from OS2.INI.        Use PM_SPOOLER_QUEUE_DESCR%@NL@%
%@AB@% *                    for a queue, and PM_SPOOLER_PRINTER_DESCR for a port%@NL@%
%@AB@% *                    (both in HINI_SYSTEM)%@NL@%
%@AB@% *%@NL@%
%@AB@% *            NOTE 3: pprt->pszDriver/pszModel may not be correct%@NL@%
%@AB@% *%@NL@%
%@AB@% *                    After the caller solves Note 1, for each queue the%@NL@%
%@AB@% *                    driver/model should be retrieved from PM_SPOOLER_QUEUE_DD%@NL@%
%@AB@% *                    (in HINI_SYSTEM).%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns NULL%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Uses%@NL@%
%@AB@% *            achPath%@NL@%
%@AB@% */%@AE@%%@NL@%
PPRINTER GetPrinterData(char *pszPrinter)%@NL@%
{%@NL@%
    USHORT        cb;%@NL@%
    BOOL        fComma;                 // True if multiple drivers%@NL@%
    ULONG        lType;%@NL@%
    PPRINTER        pprt;%@NL@%
    char *        psz;%@NL@%
    char *        pszDriver;%@NL@%
    char *        pszLogAddr;%@NL@%
    char *        pszModel;%@NL@%
    char *        pszQueue;%@NL@%
%@NL@%
    // Get the printer details%@NL@%
    cb = (USHORT)PrfQueryProfileString(%@NL@%
            HINI_SYSTEM,                // Only look in system profile%@NL@%
            "PM_SPOOLER_PRINTER",        // Application name%@NL@%
            pszPrinter,                 // Keyname%@NL@%
            "",                         // Default value%@NL@%
            achPath,                        // Buffer to receive value%@NL@%
            (ULONG)sizeof(achPath)        // Buffer size%@NL@%
         );%@NL@%
%@NL@%
    if (cb == 0)%@NL@%
        return NULL;%@NL@%
%@NL@%
    // Get the logical address name, driver name, model name, and queue name%@NL@%
%@NL@%
    psz = achPath;%@NL@%
%@NL@%
    // Parse off logical address (usually a port name)%@NL@%
    //%@NL@%
    // A: "LPT1;LASERJET.HP LaserJet IID;QUEUE1;;"%@NL@%
    //           ^%@NL@%
    // B: "LPT1;LASERJET.HP LaserJet IID,PSCRIPT;QUEUE1,QUEUE2;;"%@NL@%
    //           ^%@NL@%
%@NL@%
    pszLogAddr = achPath;                // Set logical address%@NL@%
    psz = strchr(psz,';');                // Find end of log addr%@NL@%
    if (psz == NULL)                        // Bad format%@NL@%
        return NULL;                        //  FAIL%@NL@%
%@NL@%
    *psz = '\0';                        // Null terminate log addr%@NL@%
    psz++;                                // Skip separator%@NL@%
%@NL@%
    // Parse off driver name and model%@NL@%
    //%@NL@%
    // NOTE:  These are provisional.  For a print queue, the driver/model%@NL@%
    //              have to be retrieved (by the caller) from PM_SPOOLER_QUEUE_DD%@NL@%
    //              in HINI_SYSTEM.%@NL@%
    //%@NL@%
    // A: "LPT1_LASERJET.HP LaserJet IID;QUEUE1;;"%@NL@%
    //                ^%@NL@%
    // B: "LPT1_LASERJET.HP LaserJet IID,POSTSCRIPT;QUEUE1,QUEUE2;;"%@NL@%
    //                ^%@NL@%
%@NL@%
    pszDriver = psz;                        // Set driver name%@NL@%
    psz = strpbrk(psz,".,;");                // Find separator%@NL@%
    if (psz == NULL)                        // Bad format%@NL@%
        return NULL;                        //  FAIL%@NL@%
    fComma = FALSE;                        // Assume no comma%@NL@%
    if (*psz == '.') {                        // Found model name separator%@NL@%
        *psz = '\0';                        // Null terminate driver name%@NL@%
        pszModel = psz + 1;                // Set model name%@NL@%
        psz = strpbrk(pszModel,",;");        // Find end of model name%@NL@%
        if (psz == NULL)                // Bad format%@NL@%
            return NULL;                //  FAIL%@NL@%
    }%@NL@%
    else if (*psz == ',' || *psz == ';') // No model name%@NL@%
        pszModel = pszDriver;                // Make model same as driver name%@NL@%
%@NL@%
    // A: "LPT1_LASERJET_HP LaserJet IID;QUEUE1;;"%@NL@%
    //                                        ^%@NL@%
    // B: "LPT1_LASERJET_HP LaserJet IID,POSTSCRIPT;QUEUE1,QUEUE2;;"%@NL@%
    //                                        ^%@NL@%
    if (*psz == ',')                        // More drivers, remember to skip them%@NL@%
        fComma = TRUE;%@NL@%
    *psz = '\0';                        // Null terminate driver name%@NL@%
    psz++;                                // Skip separator%@NL@%
%@NL@%
    // A: "LPT1_LASERJET_HP LaserJet IID_QUEUE1;;"%@NL@%
    //                                         ^%@NL@%
    // B: "LPT1_LASERJET_HP LaserJet IID_POSTSCRIPT;QUEUE1,QUEUE2;;"%@NL@%
    //                                         ^%@NL@%
    if (fComma) {                        // Need to skip rest of field%@NL@%
        psz = strpbrk(psz,";");         // Skip to end of driver field%@NL@%
        if (psz == NULL)                // Bad format%@NL@%
            return NULL;                //  FAIL%@NL@%
        psz++;                                // Skip separator%@NL@%
    }%@NL@%
%@NL@%
    // A: "LPT1_LASERJET_HP LaserJet IID_QUEUE1;;"%@NL@%
    //                                                ^%@NL@%
    // B: "LPT1_LASERJET_HP LaserJet IID_POSTSCRIPT;QUEUE1,QUEUE2;;"%@NL@%
    //                                                    ^%@NL@%
    // NOTE: We leave the list of queues, so that caller can enumerate%@NL@%
    //             all queues!%@NL@%
    //%@NL@%
    if (*psz == ';')                        // No queue%@NL@%
        pszQueue = NULL;%@NL@%
    else {                                // Queue present%@NL@%
        pszQueue = psz;                 // Set queue name%@NL@%
        psz = strpbrk(psz,";");         // Find end of queue name(s)!%@NL@%
        if (psz == NULL)                // Bad format%@NL@%
            return NULL;                //  FAIL%@NL@%
        *psz = '\0';                        // Null terminate queue name%@NL@%
    }%@NL@%
%@NL@%
    // Figure out whether this printer is queued or not%@NL@%
%@NL@%
    if (pszQueue != NULL) {                // Printer is queued%@NL@%
        lType = OD_QUEUED;%@NL@%
        psz = pszQueue;%@NL@%
    }%@NL@%
    else {                                // Printer is direct%@NL@%
        lType = OD_DIRECT;%@NL@%
        psz = pszLogAddr;%@NL@%
    }%@NL@%
%@NL@%
    // Create printer structure%@NL@%
%@NL@%
    pprt = CreatePrinter(%@NL@%
            lType,                        // Set type%@NL@%
            psz,                        // Set logical address%@NL@%
            pszPrinter,                 // Set printer%@NL@%
            pszDriver,                        // Set driver%@NL@%
            pszModel,                        // Set model%@NL@%
            fComma                        // Set flag%@NL@%
       );%@NL@%
    return pprt;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        CreatePrinter - Create a PRINTER%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            lType      - printer type (OD_DIRECT or OD_QUEUED)%@NL@%
%@AB@% *            pszLogAddr - logical address (LPT1 or QUEUE1)%@NL@%
%@AB@% *            pszPrinter - printer name%@NL@%
%@AB@% *            pszDriver  - driver name%@NL@%
%@AB@% *            pszModel   - model name%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns PPRINTER%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns NULL%@NL@%
%@AB@% */%@AE@%%@NL@%
PPRINTER CreatePrinter(LONG lType,%@NL@%
                       char *pszLogAddr,%@NL@%
                       char *pszPrinter,%@NL@%
                       char *pszDriver,%@NL@%
                       char *pszModel,%@NL@%
                       BOOL fMultipleDrivers)%@NL@%
{%@NL@%
    PPRINTER        pprt;%@NL@%
%@NL@%
    pprt = MemAlloc(sizeof(PRINTER));%@NL@%
    if (pprt == NULL)%@NL@%
        return NULL;%@NL@%
%@NL@%
    // Create copies of strings to complete printer structure%@NL@%
%@NL@%
    pprt->pszLogAddr = MemStrDup(pszLogAddr); // Duplicate logical address%@NL@%
    pprt->pszPrinter = MemStrDup(pszPrinter); // Duplicate printer name%@NL@%
    pprt->pszDriver  = MemStrDup(pszDriver);  // Duplicate driver%@NL@%
    pprt->pszModel   = MemStrDup(pszModel);  // Duplicate Model%@NL@%
%@NL@%
    // Set other fields%@NL@%
%@NL@%
    pprt->fMultipleDrivers = fMultipleDrivers; // Set flag%@NL@%
    pprt->lType = lType;                // Set type%@NL@%
    pprt->pszDescription = NULL;        // No description, yet%@NL@%
    pprt->cbDriverData = 0;                // No job properites%@NL@%
    pprt->pbDriverData = NULL;                // No job properites%@NL@%
%@NL@%
    // Set consistent printer "name"%@NL@%
    if (lType == OD_QUEUED)%@NL@%
        pprt->pszName = pprt->pszLogAddr; // Use queue name%@NL@%
    else%@NL@%
        pprt->pszName = pprt->pszPrinter; // Use printer name%@NL@%
%@NL@%
    // Make sure copies succeeded%@NL@%
%@NL@%
    if ((pprt->pszLogAddr     == NULL) || // One or more dups failed%@NL@%
        (pprt->pszDriver      == NULL) ||%@NL@%
        (pprt->pszModel       == NULL) ||%@NL@%
        (pprt->pszPrinter     == NULL)) {%@NL@%
        DestroyPrinter(pprt);                // Destroy printer%@NL@%
        pprt = NULL;%@NL@%
    }%@NL@%
    return pprt;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        DestroyPrinter - Destroy a PRINTER%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            pprt - printer to destroy%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            NONE%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID DestroyPrinter(PPRINTER pprt)%@NL@%
{%@NL@%
    MemAssert(pprt);%@NL@%
    if (pprt->pszLogAddr != NULL)%@NL@%
        MemFree(pprt->pszLogAddr);%@NL@%
    if (pprt->pszDriver != NULL)%@NL@%
        MemFree(pprt->pszDriver);%@NL@%
    if (pprt->pszModel != NULL)%@NL@%
        MemFree(pprt->pszModel);%@NL@%
    if (pprt->pszPrinter != NULL)%@NL@%
        MemFree(pprt->pszPrinter);%@NL@%
    if (pprt->pszDescription != NULL)%@NL@%
        MemFree(pprt->pszDescription);%@NL@%
    if (pprt->pbDriverData != NULL)%@NL@%
        MemFree(pprt->pbDriverData);%@NL@%
    MemFree(pprt);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        GetDriverData - Get driver data for printer (if not already set)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This function attempts to set the Job Properties for a printer%@NL@%
%@AB@% *        by querying the driver.  If successful, the Job Properties are%@NL@%
%@AB@% *        stored in the printer.        Otherwise, they are left as NULL, and%@NL@%
%@AB@% *        the driver will use its own default job properties.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            pprt - printer%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            pprt->pbDriverData set to driver data, if at all possible.%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID GetDriverData(PPRINTER pprt)%@NL@%
{%@NL@%
    HAB     hab;%@NL@%
    LONG    cb;%@NL@%
    BYTE *  pb;%@NL@%
    LONG    rc;%@NL@%
%@NL@%
    MemAssert(pprt);%@NL@%
    MemAssert(pprt->pprtlist);%@NL@%
    hab = pprt->pprtlist->hab;%@NL@%
%@NL@%
    // See if job properties already set%@NL@%
%@NL@%
    if (pprt->pbDriverData != NULL)        // They are%@NL@%
        return;                         //  Nothing to do%@NL@%
%@NL@%
    // Assume no job properties%@NL@%
%@NL@%
    pprt->cbDriverData = 0;%@NL@%
    pprt->pbDriverData = NULL;%@NL@%
%@NL@%
    // Get size%@NL@%
%@NL@%
    cb =  DevPostDeviceModes(%@NL@%
            hab,                        // Anchor block%@NL@%
            NULL,                        // Buffer for data (NULL returns size)%@NL@%
            pprt->pszDriver,                // Driver name%@NL@%
            pprt->pszModel,                // Device name%@NL@%
            pprt->pszPrinter,                // Printer name%@NL@%
            DPDM_QUERYJOBPROP                // Option%@NL@%
    );%@NL@%
%@NL@%
    if (cb == DPDM_NONE)                // No job properties available%@NL@%
        return;                         //  Do nothing%@NL@%
%@NL@%
    if (cb == DPDM_ERROR)                // Could not get job properties%@NL@%
        return;                         //  Do nothing%@NL@%
%@NL@%
    pb = MemAlloc((USHORT)cb);                // Allocate buffer%@NL@%
    if (pb == NULL)                        // Could not allocate it%@NL@%
        return;                         //  Nothing to do%@NL@%
%@NL@%
    // Made it this far, get driver data%@NL@%
%@NL@%
    rc = DevPostDeviceModes(%@NL@%
            hab,                        // Anchor block%@NL@%
            (VOID *)pb,                 // Buffer for data%@NL@%
            pprt->pszDriver,                // Driver name%@NL@%
            pprt->pszModel,                // Device name%@NL@%
            pprt->pszPrinter,                // Printer name%@NL@%
            DPDM_QUERYJOBPROP                // Option%@NL@%
    );%@NL@%
%@NL@%
    if (rc == DEV_OK) {%@NL@%
        pprt->cbDriverData = (USHORT)cb;%@NL@%
        pprt->pbDriverData = pb;%@NL@%
    }%@NL@%
    return;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%QUEUES.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SPY\QUEUES.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* queues.c - Spy code to manager the queue list dialog%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%       INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%       INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%       INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%       INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%       INCL_WINMESSAGEMGR %@NL@%
       INCL_WINPOINTERS                %@AB@%/* needed for spy.h */%@AE@%%@NL@%
%@AI@%#define %@AE@%       INCL_WINWINDOWMGR %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"spyhook.h" %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<time.h> %@NL@%
%@AI@%#include %@AE@%"spy.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%SIZEOFWND   34 %@NL@%
%@AI@%#define %@AE@%MAXMSGBYTES 100 %@NL@%
%@NL@%
%@AB@%/* File Global Variables */%@AE@%%@NL@%
HMQ      hmqDlgDisp;%@NL@%
SHORT   chmqWatched = 0;%@NL@%
SHORT   chmqInList = 0;%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Function Prototypes */%@AE@%%@NL@%
MRESULT EXPENTRY SpyQueuesDlgProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
%@NL@%
void    InitQueueList(VOID);%@NL@%
void    DisplayQueueInfoForWindow(HWND, HWND);%@NL@%
void    DisplayQueueInfo(HWND, HMQ);%@NL@%
void    SelectQueueFromText(HWND hwndDlg);%@NL@%
void    BuildQueueWatchList(void);%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* MRESULT EXPENTRY SpyQueuesDlgProc(hwnd, msg, mp1, mp2)%@NL@%
%@AB@%*%@NL@%
%@AB@%* The Spy Windows Dialog procedure%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY SpyQueuesDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL        fSelect = TRUE;%@NL@%
    SHORT       cQueues;%@NL@%
    HWND        hwndPoint;%@NL@%
    HMQ         hmqDisp;%@NL@%
    HMQ         hmqItem;   %@AB@%/* from handle of list item */%@AE@%%@NL@%
    USHORT      iItemFocus; %@AB@%/* Index to item that has the focus */%@AE@%%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_INITDLG:%@NL@%
        %@AB@%/* Initialize the dialog items */%@AE@%%@NL@%
        hwndWindowLB = WinWindowFromID(hwnd, DID_WINDOWLIST);%@NL@%
        InitQueueList();%@NL@%
        hmqDlgDisp = NULL;%@NL@%
        fTrackingListBox = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CHAR:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Handle VK_ENTER and VK_NEWLINE if our Edit control has%@NL@%
%@AB@%         * the focus and it is a keydown%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (!(SHORT1FROMMP(mp1) & KC_KEYUP) &&%@NL@%
                (SHORT1FROMMP(mp1) & KC_VIRTUALKEY) &&%@NL@%
                ( (SHORT2FROMMP(mp2) == VK_ENTER) ||%@NL@%
                  (SHORT2FROMMP(mp2) == VK_NEWLINE) )) {%@NL@%
%@NL@%
%@NL@%
            if (WinQueryFocus(HWND_DESKTOP, FALSE) ==%@NL@%
                    WinWindowFromID(hwnd, DID_WHANDLE)) {%@NL@%
                SelectQueueFromText(hwnd);%@NL@%
                break;%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* Normaly pass to dialog procedure to handle message */%@AE@%%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1)) {%@NL@%
        case DID_OK:%@NL@%
            BuildQueueWatchList();%@NL@%
%@NL@%
        case DID_CANCEL:%@NL@%
            %@AB@%/* Now dismiss the dialog */%@AE@%%@NL@%
            WinDismissDlg(hwnd, SHORT1FROMMP(mp1));%@NL@%
            break;%@NL@%
        case DID_WUNSELALL:%@NL@%
            fSelect = FALSE;%@NL@%
        case DID_WSELALL:%@NL@%
            cQueues = SHORT1FROMMR( WinSendMsg(hwndWindowLB, LM_QUERYITEMCOUNT,%@NL@%
                0L, 0L));%@NL@%
%@NL@%
            fTrackingListBox = FALSE;%@NL@%
            while (cQueues) {%@NL@%
                %@AB@%/* Loop through all windows, selecting or unselcting all */%@AE@%%@NL@%
                WinSendMsg(hwndWindowLB, LM_SELECTITEM, (MPARAM)--cQueues,%@NL@%
                    (MPARAM)fSelect);%@NL@%
            }%@NL@%
            fTrackingListBox = TRUE;%@NL@%
            break;%@NL@%
%@NL@%
        case DID_WSELMOUSE:%@NL@%
            %@AB@%/* Call function to track mouse, returns window handle */%@AE@%%@NL@%
            hwndPoint = HwndSelWinWithMouse(hwnd, DisplayQueueInfoForWindow);%@NL@%
            if (hwndPoint == NULL)%@NL@%
                break;    %@AB@%/* No window to process */%@AE@%%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Now find the window in the list, Make the item visible%@NL@%
%@AB@%             * and set the item as selected.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            hmqDisp = (HMQ)WinQueryWindowULong(hwndPoint, QWL_HMQ);%@NL@%
            cQueues = SHORT1FROMMR(WinSendMsg(hwndWindowLB, LM_QUERYITEMCOUNT,%@NL@%
                    0L, 0L));%@NL@%
%@NL@%
            while (cQueues) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Loop through all windows until we wind the right%@NL@%
%@AB@%                 * one with the correct window handle%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                hmqItem = (HMQ)WinSendMsg(hwndWindowLB, LM_QUERYITEMHANDLE,%@NL@%
                        (MPARAM)--cQueues, 0L);%@NL@%
%@NL@%
                if (hmqItem == hmqDisp) {%@NL@%
                    %@AB@%/* found the right item, move it to top */%@AE@%%@NL@%
                    WinSendMsg(hwndWindowLB, LM_SETTOPINDEX, (MPARAM)cQueues, 0L);%@NL@%
                    WinSendMsg(hwndWindowLB, LM_SELECTITEM, (MPARAM)cQueues,%@NL@%
                            (MPARAM)TRUE);%@NL@%
                    break;%@NL@%
                }%@NL@%
            }%@NL@%
            break;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
%@NL@%
    default:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Default is to see if the listbox has changed its focus%@NL@%
%@AB@%         * item number.  If it has, then we want to display the information%@NL@%
%@AB@%         * about the window that the listbox cursor is over.  There is no%@NL@%
%@AB@%         * legal way to do this, One approach appears to temporary set the%@NL@%
%@AB@%         * listbox to be a single selection listbox, then query its selection%@NL@%
%@AB@%         * and set it back into multiple selection mode.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (fTrackingListBox && hwndWindowLB != NULL) {%@NL@%
%@NL@%
            WinSetWindowBits(hwndWindowLB, QWL_STYLE, 0L, LS_MULTIPLESEL);%@NL@%
            iItemFocus = SHORT1FROMMR(WinSendMsg(hwndWindowLB, LM_QUERYSELECTION,%@NL@%
                    (MPARAM)LIT_FIRST, 0L));%@NL@%
            WinSetWindowBits(hwndWindowLB, QWL_STYLE, LS_MULTIPLESEL,%@NL@%
                    LS_MULTIPLESEL);%@NL@%
%@NL@%
            if (iItemFocus != iCurItemFocus) {%@NL@%
                iCurItemFocus = iItemFocus;%@NL@%
                if (iItemFocus != (USHORT)-1) {%@NL@%
%@NL@%
                    hmqDisp = (HMQ)WinSendMsg(hwndWindowLB, LM_QUERYITEMHANDLE,%@NL@%
                            (MPARAM)iItemFocus, 0L);%@NL@%
                    DisplayQueueInfo(hwnd, hmqDisp);%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* InitQueueList ()%@NL@%
%@AB@%*%@NL@%
%@AB@%* Builds the list of Queues displayed in the queues dialog%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void InitQueueList()%@NL@%
{%@NL@%
    HENUM       henum;%@NL@%
    char        szClassName[50];    %@AB@%/* Class name of window */%@AE@%%@NL@%
    HWND        hwnd;%@NL@%
    ULONG       ulHMQ;%@NL@%
    PID         pidWindow;%@NL@%
    TID         tidWindow;%@NL@%
    SHORT       item;%@NL@%
    HMQ         *ahmqWatched;%@NL@%
    HMQ         *phmqT;%@NL@%
    SHORT       chmqAlloc;%@NL@%
    SHORT       i;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * We will enumerate through all of the OBJECT windows looking for%@NL@%
%@AB@%     * windows that have the  WC_QUEUE type.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (chmqWatched > 0) {%@NL@%
        ahmqWatched = (HMQ *)WinAllocMem(hHeap, sizeof(HMQ) * chmqWatched);%@NL@%
        chmqAlloc = chmqWatched;%@NL@%
        if (ahmqWatched != NULL)%@NL@%
            chmqWatched = SpyGetQueueList(chmqWatched, ahmqWatched);%@NL@%
    } else%@NL@%
        ahmqWatched = NULL;%@NL@%
%@NL@%
    henum = WinBeginEnumWindows(HWND_OBJECT);%@NL@%
    if (henum == NULL)%@NL@%
        return;%@NL@%
%@NL@%
    chmqInList = 0;%@NL@%
    while ((hwnd = WinGetNextWindow(henum)) != NULL) {%@NL@%
        WinLockWindow(hwnd, FALSE);%@NL@%
        WinQueryClassName(hwnd, sizeof(szClassName),%@NL@%
            (PSZ)szClassName);%@NL@%
%@NL@%
        if (strcmp(szClassName, "#32767") == 0) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * We found an HMQ, add it to our list, Do not add our own%@NL@%
%@AB@%             * HMQ to the list!.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            ulHMQ = (ULONG)WinQueryWindowULong(hwnd, QWL_HMQ);%@NL@%
            if ((HMQ)ulHMQ != hmqSpy) {%@NL@%
                WinQueryWindowProcess(hwnd, &pidWindow, &tidWindow);%@NL@%
%@NL@%
                %@AB@%/* Reuse szClassName */%@AE@%%@NL@%
                sprintf(szClassName, "0x%04x (PID:%d TID:%d)",%@NL@%
                        (USHORT)ulHMQ, (SHORT)pidWindow, (SHORT)tidWindow);%@NL@%
%@NL@%
                item = SHORT1FROMMR(WinSendMsg(hwndWindowLB, LM_INSERTITEM,%@NL@%
                        (MPARAM)LIT_END, (MPARAM)(PSZ)szClassName));%@NL@%
%@NL@%
                %@AB@%/* Set the item handle to the handle of the window */%@AE@%%@NL@%
                WinSendMsg(hwndWindowLB, LM_SETITEMHANDLE, (MPARAM)item,%@NL@%
                        (MPARAM)ulHMQ);%@NL@%
                chmqInList++;%@NL@%
%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Now see if we should select the item%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                if (phmqT = ahmqWatched) {%@NL@%
                    for (i = 0; i < chmqWatched; i++) {%@NL@%
                        if ((HMQ)ulHMQ == *phmqT++) {%@NL@%
                            WinSendMsg(hwndWindowLB, LM_SELECTITEM, (MPARAM)item,%@NL@%
                                    (MPARAM)TRUE);%@NL@%
                            break;%@NL@%
                        }%@NL@%
                    }%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
    }%@NL@%
%@NL@%
    WinEndEnumWindows(henum);%@NL@%
%@NL@%
    if (ahmqWatched)%@NL@%
        WinFreeMem(hHeap, (char *)ahmqWatched, chmqAlloc * sizeof(HMQ));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* DisplayQueueInfoForWindow(HWND hwndDialog, HWND hwnd)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Displays the information about the selected window in the dialog%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void DisplayQueueInfoForWindow(hwndDlg, hwndDisp)%@NL@%
HWND            hwndDlg;%@NL@%
HWND            hwndDisp;%@NL@%
{%@NL@%
HMQ             hmqDisp;%@NL@%
%@NL@%
    %@AB@%/* simply get the HMQ for the window and call display function */%@AE@%%@NL@%
    hmqDisp = (HMQ)WinQueryWindowULong(hwndDisp, QWL_HMQ);%@NL@%
    DisplayQueueInfo(hwndDlg, hmqDisp);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* DisplayQueueInfo(HWND hwndDialog, HWND hwnd)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Displays the information about the selected window in the dialog%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void DisplayQueueInfo(hwndDlg, hmqDisp)%@NL@%
HWND            hwndDlg;%@NL@%
HMQ             hmqDisp;%@NL@%
{%@NL@%
    HWND        hwnd;%@NL@%
    HMQ         hmqWindow;%@NL@%
    HENUM       henum;%@NL@%
    char        szTemp[50];%@NL@%
    PID         pidWindow;%@NL@%
    TID         tidWindow;%@NL@%
%@NL@%
%@NL@%
    if (hmqDisp != hmqDlgDisp)%@NL@%
    {%@NL@%
        hmqDlgDisp = hmqDisp;%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * See if we can find a top level window for this HMQ%@NL@%
%@AB@%         */%@AE@%%@NL@%
        henum = WinBeginEnumWindows(HWND_DESKTOP);%@NL@%
        if (henum == NULL)%@NL@%
            return;%@NL@%
%@NL@%
        while ((hwnd = WinGetNextWindow(henum)) != NULL) {%@NL@%
            WinLockWindow(hwnd, FALSE);%@NL@%
            hmqWindow = (HMQ)WinQueryWindowULong(hwnd, QWL_HMQ);%@NL@%
%@NL@%
            if (hmqWindow == hmqDisp)%@NL@%
                break;%@NL@%
        }%@NL@%
        WinEndEnumWindows(henum);%@NL@%
%@NL@%
%@NL@%
        if (hwnd == NULL) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * No top level windows found look for object window.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            henum = WinBeginEnumWindows(HWND_OBJECT);%@NL@%
            if (henum == NULL)%@NL@%
                return;%@NL@%
%@NL@%
            while ((hwnd = WinGetNextWindow(henum)) != NULL) {%@NL@%
                WinLockWindow(hwnd, FALSE);%@NL@%
                hmqWindow = (HMQ)WinQueryWindowULong(hwnd, QWL_HMQ);%@NL@%
%@NL@%
                if (hmqWindow == hmqDisp)%@NL@%
                    break;%@NL@%
            }%@NL@%
            WinEndEnumWindows(henum);%@NL@%
            if (hwnd == NULL)%@NL@%
                return;%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* output information to window now */%@AE@%%@NL@%
        sprintf(szTemp, "0x%04x", (SHORT)(LONG)hmqDisp);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WHMQ, (PSZ)szTemp);%@NL@%
%@NL@%
        sprintf(szTemp, "0x%04x", (SHORT)(LONG)hwnd);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WHANDLE, (PSZ)szTemp);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Warning, we only query the text if the window is not an object%@NL@%
%@AB@%         * window.  If it is an object window, the message queue may not%@NL@%
%@AB@%         * be processing messages, which could hang us%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (WinIsChild(hwnd, HWND_OBJECT))%@NL@%
            szTemp[0] = '\0';   %@AB@%/* No text available */%@AE@%%@NL@%
        else%@NL@%
            WinQueryWindowText(hwnd, sizeof(szTemp), (PSZ)szTemp);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WTEXT, (PSZ)szTemp);%@NL@%
%@NL@%
        WinQueryWindowProcess(hwnd, &pidWindow, &tidWindow);%@NL@%
        sprintf(szTemp, "%d", (SHORT)pidWindow);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WPID, (PSZ)szTemp);%@NL@%
        sprintf(szTemp, "%d", (SHORT)tidWindow);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WTID, (PSZ)szTemp);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* void SelectQueueFromText(hwndDlg)%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Updates the text that is displayed in the message text line%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void SelectQueueFromText(hwndDlg)%@NL@%
HWND    hwndDlg;%@NL@%
{%@NL@%
    char    szTemp[80];%@NL@%
    HMQ     hmqSelect;%@NL@%
    SHORT   cItems;%@NL@%
    SHORT   i;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* First get the edit text from the string */%@AE@%%@NL@%
    WinQueryDlgItemText(hwndDlg, DID_WHANDLE, sizeof(szTemp),%@NL@%
            (PSZ)szTemp);%@NL@%
%@NL@%
    hmqSelect = (HMQ)UConvertStringToNum(szTemp);%@NL@%
%@NL@%
    cItems = SHORT1FROMMR(WinSendMsg(hwndWindowLB, LM_QUERYITEMCOUNT,%@NL@%
            0L, 0L));%@NL@%
%@NL@%
    for (i=0; i < cItems; i++) {%@NL@%
        if ((HMQ)WinSendMsg(hwndWindowLB, LM_QUERYITEMHANDLE,%@NL@%
                (MPARAM)i, 0L) == hmqSelect)%@NL@%
            break;  %@AB@%/* found it */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    if (i < cItems) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * found the hmq, bring to top, and select it%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinSendMsg(hwndWindowLB, LM_SETTOPINDEX,%@NL@%
                MPFROMSHORT(i),  (MPARAM)0L);%@NL@%
%@NL@%
        %@AB@%/* Always set it on */%@AE@%%@NL@%
        WinSendMsg(hwndWindowLB, LM_SELECTITEM,%@NL@%
                MPFROMSHORT(i), MPFROMSHORT(TRUE));%@NL@%
%@NL@%
    } else {%@NL@%
        WinAlarm(HWND_DESKTOP, WA_WARNING);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WHANDLE, (PSZ)"");%@NL@%
    }%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* BuildQueueWatchList()%@NL@%
%@AB@%*%@NL@%
%@AB@%* Updates the list of windows to be watched from the listbox%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void BuildQueueWatchList(void)%@NL@%
{%@NL@%
%@NL@%
    USHORT  itemPrevious;%@NL@%
    USHORT  item;%@NL@%
%@NL@%
    HMQ     *ahmqList;%@NL@%
    HMQ     *phmqT;%@NL@%
%@NL@%
%@NL@%
    ahmqList = (HMQ *)WinAllocMem(hHeap, sizeof(HMQ) * chmqInList);%@NL@%
    if ((phmqT = ahmqList) == NULL)%@NL@%
        return;     %@AB@%/* Error */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Simply loop through asking for the next selected item in the%@NL@%
%@AB@%     * list.  Make sure not to overrun our list.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    itemPrevious = (USHORT)LIT_FIRST;%@NL@%
    chmqWatched = 0;%@NL@%
%@NL@%
    while ((item = SHORT1FROMMR(WinSendMsg(hwndWindowLB, LM_QUERYSELECTION,%@NL@%
            (MPARAM)itemPrevious, 0L))) != (USHORT)LIT_NONE) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Get the items handle, which has the value of the window handle%@NL@%
%@AB@%         */%@AE@%%@NL@%
        *phmqT++ = (HMQ)WinSendMsg(hwndWindowLB, LM_QUERYITEMHANDLE,%@NL@%
                (MPARAM)item, 0L);%@NL@%
        chmqWatched++;%@NL@%
%@NL@%
        itemPrevious = item;    %@AB@%/* Where to cointinue the search */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    SpySetQueueList (chmqWatched, ahmqList);%@NL@%
%@NL@%
    WinFreeMem(hHeap, (char *)ahmqList, sizeof(HMQ) * chmqInList);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SHARE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SHARE\SHARE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This example illustrates the use of shared memory and ram semaphores%@NL@%
%@AB@% * between separate processes.  One process reads and stores keystrokes%@NL@%
%@AB@% * into a circular buffer in shared memory, and another reads the buffer%@NL@%
%@AB@% * and writes to standard output. The output program throttles output to%@NL@%
%@AB@% * one character per sec so the effect of buffering can be seen. Type%@NL@%
%@AB@% * CONTROL-d to terminate.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Note the mutual exclusion on access to the head and tail pointers of the%@NL@%
%@AB@% * buffer and on clearing and setting the full and empty semaphores.  For a%@NL@%
%@AB@% * discussion, see Peterson & Silberschatz, "Operating System Concepts",%@NL@%
%@AB@% * 2nd ed., chapter 9.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Be aware when running this that the system does keyboard buffering%@NL@%
%@AB@% * underneath this program, so you can type ahead more than you might think.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Needs shrchild.c as companion program.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Compile as: cl -AL -G2 -Lp share.c%@NL@%
%@AB@% *%@NL@%
%@AB@% * Created by Microsoft Corp. 1986%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_SUB %@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2def.h> %@NL@%
%@AI@%#include %@AE@%<bse.h> %@NL@%
"share.h"                %@AB@%/* common declarations between processes */%@AE@%%@NL@%
%@NL@%
       CHILD1PROG        "SHRCHILD.EXE"                %@AB@%/* child process */%@AE@%%@NL@%
       CTRLd                4                        %@AB@%/* termination character */%@AE@%%@NL@%
%@AI@%#define %@AE@%FBSZ                32 %@NL@%
%@NL@%
KBDKEYINFO KeyData;            %@AB@%/* declared in subcalls.h */%@AE@%%@NL@%
%@NL@%
main()%@NL@%
{%@NL@%
        SEL                Selector;%@NL@%
        RESULTCODES        childID;     %@AB@%/* child process id */%@AE@%%@NL@%
        unsigned        rc;                %@AB@%/* return code */%@AE@%%@NL@%
        char                c,%@NL@%
                        fbuf[FBSZ];        %@AB@%/* failing object buffer */%@AE@%%@NL@%
        struct ShareRec *SmemPtr;        %@AB@%/* shared memory pointer */%@AE@%%@NL@%
%@NL@%
        %@AB@%/* allocate the shared memory segment */%@AE@%%@NL@%
        if (rc = DosAllocShrSeg( SHRSEGSIZE, (PSZ)SHRSEGNAME,%@NL@%
                                &Selector ))  {%@NL@%
                printf("alloc of shared memory failed, error: %d\n", rc);%@NL@%
                DosExit(EXIT_PROCESS, 0);%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* Get a far pointer from a 16 bit selector */%@AE@%%@NL@%
        SmemPtr = (struct ShareRec *) MAKEP(Selector, 0);%@NL@%
%@NL@%
        %@AB@%/* Initialize circular buffer flags */%@AE@%%@NL@%
        DosSemClear((HSEM)&(SmemPtr->fullsem));%@NL@%
        DosSemSet((HSEM)&(SmemPtr->emptysem));%@NL@%
        DosSemClear((HSEM)&(SmemPtr->mutexsem));%@NL@%
        SmemPtr->head = 0;%@NL@%
        SmemPtr->tail = 0;%@NL@%
%@NL@%
        %@AB@%/* exec asynchronously the consumer process */%@AE@%%@NL@%
        if (rc = DosExecPgm(%@NL@%
                (PCHAR) fbuf,                        %@AB@%/* ObjNameBuf                */%@AE@%%@NL@%
                FBSZ,                                %@AB@%/* ObjNameLen                */%@AE@%%@NL@%
                EXEC_ASYNC,                        %@AB@%/* AsyncTraceFlags        */%@AE@%%@NL@%
                (PSZ) 0L,                        %@AB@%/* Argument Strings        */%@AE@%%@NL@%
                (PSZ) 0L,                        %@AB@%/* Environment Strings        */%@AE@%%@NL@%
                &childID,%@NL@%
                                                %@AB@%/* ID & Termination Codes */%@AE@%%@NL@%
                (PSZ) CHILD1PROG )) {                %@AB@%/* Program Filename        */%@AE@%%@NL@%
            %@NL@%
                printf("exec of child process failed, error: %d\n", rc);%@NL@%
                DosExit(EXIT_PROCESS, 0);%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* Here, we read chars from the keyboard, and put them in a */%@AE@%%@NL@%
        %@AB@%/* circular buffer in shared memory */%@AE@%%@NL@%
%@NL@%
        KbdCharIn(&KeyData, 0, 0);        %@AB@%/* read character from keyboard */%@AE@%%@NL@%
%@NL@%
        while((c = KeyData.chChar) != CTRLd) {%@NL@%
%@NL@%
            %@AB@%/* block if buffer full */%@AE@%%@NL@%
            DosSemWait((HSEM)&(SmemPtr->fullsem), WAITFOREVER);%@NL@%
%@NL@%
            %@AB@%/* mutual exclusion on buffer pointers and semaphores */%@AE@%%@NL@%
            DosSemRequest((HSEM)&(SmemPtr->mutexsem), WAITFOREVER);%@NL@%
            SmemPtr->CircBuffer[SmemPtr->head] = c;%@NL@%
            SmemPtr->head++;                    %@AB@%/* step pointer */%@AE@%%@NL@%
            SmemPtr->head %= CIRCBUFSIZE;   %@AB@%/* wrap at end  */%@AE@%%@NL@%
            if(BUFFUL(SmemPtr))%@NL@%
                DosSemSet((HSEM)&(SmemPtr->fullsem)); %@AB@%/* indicate buf full   */%@AE@%%@NL@%
            DosSemClear((HSEM)&(SmemPtr->emptysem));  %@AB@%/* indicate buf !emtpy */%@AE@%%@NL@%
            DosSemClear((HSEM)&(SmemPtr->mutexsem));%@NL@%
%@NL@%
%@NL@%
            KbdCharIn(&KeyData, 0, 0);        %@AB@%/* read character from keyboard */%@AE@%%@NL@%
        }%@NL@%
        DosKillProcess( 1, childID.codeTerminate);        %@AB@%/* kill consumer */%@AE@%%@NL@%
        DosExit( EXIT_PROCESS, 0 );           %@AB@%/* exit, terminating all threads */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SHRCHILD.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SHARE\SHRCHILD.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * This is the child process exec'd asynchronously from share.c.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Created by Microsoft Corp. 1986%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSSEMAPHORES %@NL@%
%@AI@%#define %@AE@%INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2def.h> %@NL@%
<bsedos.h>                %@AB@%/* necessary whenever doscalls are made */%@AE@%%@NL@%
"share.h"                %@AB@%/* common shared memory declarations */%@AE@%%@NL@%
%@NL@%
main()%@NL@%
{%@NL@%
        SEL                        Selector;%@NL@%
        unsigned                rc;                %@AB@%/* return code */%@AE@%%@NL@%
        USHORT                        nBytes;%@NL@%
        char                        c;%@NL@%
        struct ShareRec         *SmemPtr;        %@AB@%/* shared memory pointer */%@AE@%%@NL@%
%@NL@%
        %@AB@%/* get selector to the shared memory segment defined in parent */%@AE@%%@NL@%
%@NL@%
        if (rc = DosGetShrSeg( (PSZ) SHRSEGNAME,%@NL@%
                                &Selector ))  {%@NL@%
                DosExit(EXIT_PROCESS, 0);%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* Get a far pointer from a 16 bit selector */%@AE@%%@NL@%
%@NL@%
        SmemPtr = (struct ShareRec *) MAKEP(Selector, 0);%@NL@%
        %@NL@%
        for (;;) {%@NL@%
%@NL@%
            %@AB@%/* block if buffer empty */%@AE@%%@NL@%
            DosSemWait((HSEM)&(SmemPtr->emptysem), WAITFOREVER);%@NL@%
%@NL@%
            %@AB@%/* mutual exclusion on buffer pointers and semaphores */%@AE@%%@NL@%
            DosSemRequest((HSEM)&(SmemPtr->mutexsem), WAITFOREVER);%@NL@%
            c = SmemPtr->CircBuffer[SmemPtr->tail];        %@AB@%/* get next char */%@AE@%%@NL@%
            SmemPtr->tail++;                    %@AB@%/* step pointer */%@AE@%%@NL@%
            SmemPtr->tail %= CIRCBUFSIZE;   %@AB@%/* wrap at end  */%@AE@%%@NL@%
            if (SmemPtr->tail == SmemPtr->head)%@NL@%
                DosSemSet((HSEM)&(SmemPtr->emptysem)); %@AB@%/* indicate buf empty */%@AE@%%@NL@%
            DosSemClear((HSEM)&(SmemPtr->fullsem));    %@AB@%/* indicate buf !full */%@AE@%%@NL@%
            DosSemClear((HSEM)&(SmemPtr->mutexsem));%@NL@%
%@NL@%
            DosWrite( 1, (PVOID) &c, 1, &nBytes );     %@AB@%/* display next char */%@AE@%%@NL@%
            DosSleep(1000L);        %@AB@%/* max 1 per sec to demo buffering & sems */%@AE@%%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SNAP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SNAP\SNAP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    snap.c -- PM snapshot utility%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%               INCL_WIN %@NL@%
%@AI@%#define %@AE@%               INCL_GPI %@NL@%
%@AI@%#define %@AE@%               INCL_DEV %@NL@%
%@AI@%#include %@AE@%       <os2.h> %@NL@%
%@AI@%#include %@AE@%       "snap.h" %@NL@%
%@NL@%
%@AB@%/* Global variables */%@AE@%%@NL@%
char szSnap[5];%@NL@%
%@NL@%
HAB    habSnap;%@NL@%
HMQ    hmqSnap;%@NL@%
HWND   hwndSnap, hwndSnapFrame;%@NL@%
HWND   hwndNextClipViewer;%@NL@%
HPS    hpsScr;%@NL@%
HHEAP  hHeap;%@NL@%
%@NL@%
HPOINTER hptrSnap;%@NL@%
HPOINTER hptrHand;%@NL@%
HPOINTER hptrSelect;%@NL@%
%@NL@%
RECTL wrcRgn;                   %@AB@%/* holds coordinates of selected region. */%@AE@%%@NL@%
RECTL rcScreen;                 %@AB@%/* rectangle for the screen for bounding */%@AE@%%@NL@%
%@NL@%
int AboutCount = 0;%@NL@%
%@NL@%
int  wSnapMode = IDM_WINDOW;    %@AB@%/* snap either selected window or region. */%@AE@%%@NL@%
%@NL@%
BOOL fSnapWnd = FALSE;  %@AB@%/* snap selected window? */%@AE@%%@NL@%
BOOL fSnapRgn = FALSE;  %@AB@%/* snap selected region? */%@AE@%%@NL@%
BOOL fSelect = FALSE;   %@AB@%/* in the process of selecting region? */%@AE@%%@NL@%
BOOL fNCArea = FALSE;   %@AB@%/* exclude nonclient area of window in snap? */%@AE@%%@NL@%
BOOL fHide = TRUE;      %@AB@%/* hide snap's window while snapping */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Function prototypes */%@AE@%%@NL@%
MRESULT EXPENTRY SnapWndProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT EXPENTRY AboutWndProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
MRESULT EXPENTRY SaveFileDlgProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
HFILE OpenSaveFile(HWND);%@NL@%
void SnapWindow(ULONG);%@NL@%
BOOL SnapInit(void);%@NL@%
void SnapPaint(HPS);%@NL@%
void SnapRegion(HPS);%@NL@%
void DrawRgn(HPS);%@NL@%
void SortRect(PRECTL, PRECTL);%@NL@%
void SaveBitmap(void);%@NL@%
void SaveBitmap2(HFILE hFile, HBITMAP hbm);%@NL@%
void convert(NPBYTE pbuf, USHORT cch, USHORT cch2);%@NL@%
HDC CreateDC(PSZ, HDC);%@NL@%
void Copy(NPBYTE, NPBYTE, USHORT);%@NL@%
int cdecl main(void);%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Routines */%@AE@%%@NL@%
int cdecl main(void)%@NL@%
{%@NL@%
    QMSG msg;%@NL@%
    ULONG ctlData;%@NL@%
%@NL@%
    if (!SnapInit())%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    ctlData = FCF_TITLEBAR | FCF_MINMAX | FCF_SIZEBORDER |%@NL@%
            FCF_SYSMENU | FCF_MENU | FCF_ICON;%@NL@%
    hwndSnapFrame = WinCreateStdWindow(HWND_DESKTOP,%@NL@%
            FS_ICON, &ctlData,%@NL@%
            (PCH)szSnap, (PCH)szSnap,%@NL@%
            0L,%@NL@%
            (HMODULE) NULL, 1,%@NL@%
            (HWND far *)&hwndSnap);%@NL@%
%@NL@%
%@NL@%
    if (!hwndSnap)%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    WinSetWindowPos(hwndSnapFrame, 0, 0, 0, 200, 75, SWP_SIZE | SWP_MOVE);%@NL@%
    WinShowWindow(hwndSnapFrame, TRUE);%@NL@%
%@NL@%
    WinSetFocus(HWND_DESKTOP, hwndSnap);%@NL@%
    WinQueryWindowRect(HWND_DESKTOP, &rcScreen);%@NL@%
%@NL@%
    if (WinOpenClipbrd(habSnap)) {%@NL@%
        WinSetClipbrdViewer(habSnap, hwndSnap);%@NL@%
        WinCloseClipbrd(habSnap);%@NL@%
    }%@NL@%
%@NL@%
    while (WinGetMsg(habSnap, (PQMSG)&msg, NULL, 0, 0)) {%@NL@%
        WinDispatchMsg(habSnap, (PQMSG)&msg);%@NL@%
    }%@NL@%
%@NL@%
    WinDestroyPointer(hptrSnap);%@NL@%
    WinDestroyPointer(hptrHand);%@NL@%
    WinDestroyPointer(hptrSelect);%@NL@%
%@NL@%
    WinDestroyWindow(hwndSnapFrame);%@NL@%
    WinDestroyHeap(hHeap);%@NL@%
    WinDestroyMsgQueue(hmqSnap);%@NL@%
%@NL@%
    WinTerminate(habSnap);%@NL@%
%@NL@%
    return 0;%@NL@%
} %@AB@%/* end winmain */%@AE@%%@NL@%
%@NL@%
%@NL@%
HDC CreateDC(lpszDriver, hdcCompat)%@NL@%
PSZ lpszDriver;%@NL@%
HDC hdcCompat;%@NL@%
{%@NL@%
    struct {%@NL@%
        ULONG FAR *lpLogAddr;%@NL@%
        PSZ lpszDriver;%@NL@%
    } opendc;%@NL@%
%@NL@%
    opendc.lpLogAddr = NULL;%@NL@%
    opendc.lpszDriver = lpszDriver;%@NL@%
%@NL@%
    return((HDC)DevOpenDC(habSnap, OD_MEMORY, (PSZ)"*", 2L,%@NL@%
            (PDEVOPENDATA)&opendc, hdcCompat));%@NL@%
}%@NL@%
%@NL@%
BOOL SnapInit(void)%@NL@%
{%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Initialize the HAB%@NL@%
%@AB@%     */%@AE@%%@NL@%
    habSnap = WinInitialize(0);%@NL@%
%@NL@%
    hmqSnap = WinCreateMsgQueue(NULL, 0);%@NL@%
%@NL@%
    WinLoadString(habSnap, (HMODULE) NULL, IDS_SNAP, sizeof(szSnap), (PCH)szSnap);%@NL@%
%@NL@%
    hptrSnap = WinLoadPointer(HWND_DESKTOP, (HMODULE)NULL, IDR_PTR_SNAP);%@NL@%
    hptrHand = WinLoadPointer(HWND_DESKTOP, (HMODULE)NULL, IDR_PTR_HAND);%@NL@%
    hptrSelect = WinLoadPointer(HWND_DESKTOP, (HMODULE)NULL, IDR_PTR_SELECT);%@NL@%
%@NL@%
    if (!WinRegisterClass(habSnap, (PCH)szSnap, SnapWndProc, (ULONG)0, 0))%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    if ((hHeap = WinCreateHeap(0, 0, 0, 0, 0, 0)) == NULL)%@NL@%
        return(FALSE);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * We assume an empty clipboard when we start.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinOpenClipbrd(habSnap);%@NL@%
    WinEmptyClipbrd(habSnap);%@NL@%
    WinCloseClipbrd(habSnap);%@NL@%
} %@AB@%/* end snapinit */%@AE@%%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY SnapWndProc(hwnd, message, mp1, mp2)%@NL@%
HWND    hwnd;%@NL@%
USHORT  message;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
    HWND hwndMenu;%@NL@%
    HPS hps;%@NL@%
    RECTL wrcUpdate;%@NL@%
    POINTL wptTemp;%@NL@%
%@NL@%
    switch (message) {%@NL@%
        case WM_BUTTON1DOWN:%@NL@%
            if (fSnapWnd) {%@NL@%
                WinSetPointer(HWND_DESKTOP, hptrSnap);%@NL@%
                SnapWindow(LONGFROMMP(mp1));%@NL@%
                WinSetCapture(HWND_DESKTOP, (HWND)NULL);%@NL@%
                fSnapWnd = FALSE;%@NL@%
            } else if (fSnapRgn) {%@NL@%
                wptTemp.x = SHORT1FROMMP(mp1);%@NL@%
                wptTemp.y = SHORT2FROMMP(mp1);%@NL@%
                WinMapWindowPoints(hwndSnap, (HWND)HWND_DESKTOP,%@NL@%
                        (PPOINTL)&wptTemp, 1);%@NL@%
                wrcRgn.yTop = wrcRgn.yBottom = wptTemp.y;%@NL@%
                wrcRgn.xRight = wrcRgn.xLeft = wptTemp.x;%@NL@%
                hpsScr = WinGetScreenPS(HWND_DESKTOP);%@NL@%
                DrawRgn(hpsScr);%@NL@%
                WinReleasePS(hpsScr);%@NL@%
                fSelect = TRUE;%@NL@%
                break;%@NL@%
            } else {%@NL@%
                return(WinDefWindowProc(hwnd, message, mp1, mp2));%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case WM_MOUSEMOVE:%@NL@%
            if (fSelect) {%@NL@%
                hpsScr = WinGetScreenPS(HWND_DESKTOP);%@NL@%
                DrawRgn(hpsScr);%@NL@%
                wptTemp.x = LOUSHORT(mp1);%@NL@%
                wptTemp.y = HIUSHORT(mp1);%@NL@%
                WinMapWindowPoints(hwndSnap, (HWND)HWND_DESKTOP,%@NL@%
                        (PPOINTL)&wptTemp, 1);%@NL@%
                wrcRgn.yTop = wptTemp.y;%@NL@%
                wrcRgn.xRight = wptTemp.x;%@NL@%
                DrawRgn(hpsScr);%@NL@%
                WinReleasePS(hpsScr);%@NL@%
                break;%@NL@%
            }%@NL@%
            if (fSnapWnd || fSnapRgn) {%@NL@%
                break;%@NL@%
            } else {%@NL@%
                return(WinDefWindowProc(hwnd, message, mp1, mp2));%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case WM_BUTTON1UP:%@NL@%
            if (fSelect) {%@NL@%
                WinSetCapture(HWND_DESKTOP, (HWND)NULL);%@NL@%
                hpsScr = WinGetScreenPS(HWND_DESKTOP);%@NL@%
                DrawRgn(hpsScr);%@NL@%
                SnapRegion(hpsScr);%@NL@%
                WinReleasePS(hpsScr);%@NL@%
                fSnapRgn = FALSE;%@NL@%
                fSelect = FALSE;%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case WM_DRAWCLIPBOARD:%@NL@%
            WinInvalidateRect(hwnd, (PRECTL)NULL, TRUE);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_PAINT:%@NL@%
            hps = WinBeginPaint(hwnd, NULL, &wrcUpdate);%@NL@%
            WinFillRect(hps, &wrcUpdate, SYSCLR_WINDOW);%@NL@%
            SnapPaint(hps);%@NL@%
            WinEndPaint(hps);%@NL@%
            break;%@NL@%
%@NL@%
        case WM_INITMENU:%@NL@%
            hwndMenu = WinWindowFromID(hwndSnapFrame, FID_MENU);%@NL@%
            WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(IDM_REGION, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, wSnapMode == IDM_REGION ? MIA_CHECKED : 0));%@NL@%
            WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(IDM_WINDOW, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, wSnapMode == IDM_WINDOW ? MIA_CHECKED : 0));%@NL@%
            WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(IDM_NCAREA, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, fNCArea ? MIA_CHECKED : 0));%@NL@%
            WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(IDM_HIDE, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, fHide ? MIA_CHECKED : 0));%@NL@%
            WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(IDM_NCAREA, TRUE),%@NL@%
                MPFROM2SHORT(MIA_DISABLED, wSnapMode == IDM_WINDOW ? 0 : MIA_DISABLED));%@NL@%
            break;%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
            switch (SHORT1FROMMP(mp1)) {%@NL@%
                case IDM_SAVE:%@NL@%
                    SaveBitmap();%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_SNAP:%@NL@%
                    WinSetCapture(HWND_DESKTOP, hwnd);%@NL@%
                    if (fHide)%@NL@%
                        WinShowWindow(hwndSnapFrame, FALSE);%@NL@%
                    if (wSnapMode == IDM_WINDOW) {%@NL@%
                        fSnapWnd = TRUE;%@NL@%
                        WinSetPointer(HWND_DESKTOP, hptrHand);%@NL@%
                    } else {%@NL@%
                        fSnapRgn = TRUE;%@NL@%
                        WinSetPointer(HWND_DESKTOP, hptrSelect);%@NL@%
                    }%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_WINDOW:%@NL@%
                case IDM_REGION:%@NL@%
                    wSnapMode = SHORT1FROMMP(mp1);%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_NCAREA:%@NL@%
                    fNCArea = !fNCArea;%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_HIDE:%@NL@%
                    fHide = !fHide;%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_ABOUT:%@NL@%
                    WinDlgBox(HWND_DESKTOP, hwnd,%@NL@%
                        (PFNWP)AboutWndProc, (HMODULE) NULL, IDD_INFO, (PCH)NULL);%@NL@%
                    break;%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return(WinDefWindowProc(hwnd, message, mp1, mp2));%@NL@%
    }%@NL@%
%@NL@%
    return(0L);%@NL@%
%@NL@%
} %@AB@%/* end snapwndproc */%@AE@%%@NL@%
%@NL@%
%@NL@%
void SnapPaint(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    HBITMAP hbm;%@NL@%
    POINTL   pt;%@NL@%
    BITMAPINFOHEADER bminfo;%@NL@%
    RECTL rc;%@NL@%
%@NL@%
    WinOpenClipbrd(habSnap);%@NL@%
    WinQueryWindowRect(hwndSnap, &rc);%@NL@%
%@NL@%
    if (hbm = (HBITMAP) WinQueryClipbrdData(habSnap, CF_BITMAP)) {%@NL@%
        GpiQueryBitmapParameters(hbm, &bminfo);%@NL@%
        pt.x = 0;%@NL@%
        pt.y = rc.yTop - bminfo.cy;%@NL@%
        WinDrawBitmap(hps, hbm, (PRECTL)NULL, (PPOINTL)&pt,%@NL@%
                0L, 0L, DBM_NORMAL | DBM_IMAGEATTRS);%@NL@%
    }%@NL@%
%@NL@%
    WinCloseClipbrd(habSnap);%@NL@%
%@NL@%
} %@AB@%/* end SnapPaint */%@AE@%%@NL@%
%@NL@%
%@NL@%
void SnapWindow(loc)%@NL@%
ULONG loc;%@NL@%
{%@NL@%
    BITMAPINFOHEADER bminfo;%@NL@%
    POINTL  pt;%@NL@%
    HWND hwnd;%@NL@%
    HWND hwndT;%@NL@%
    RECTL rc, rcTmp;%@NL@%
    HPS  hpsWnd, hpsMem;%@NL@%
    HDC  hdc;%@NL@%
    HBITMAP hbm, hbmOld;%@NL@%
    int  cx, cy;%@NL@%
    POINTL rgpt[3];%@NL@%
    SIZEL size;%@NL@%
%@NL@%
    pt.y = HIUSHORT(loc);%@NL@%
    pt.x = LOUSHORT(loc);%@NL@%
%@NL@%
    WinMapWindowPoints(hwndSnap, HWND_DESKTOP, (PPOINTL)&pt, 1);%@NL@%
    if ((hwnd = WinWindowFromPoint(HWND_DESKTOP, (PPOINTL)&pt, FALSE, FALSE)) == NULL)%@NL@%
        return;%@NL@%
    %@AB@%/* get size of target window. clip to screen. */%@AE@%%@NL@%
    if (fNCArea)  %@AB@%/* snap only the client area if it exists */%@AE@%%@NL@%
        if ((hwndT = WinWindowFromID(hwnd, FID_CLIENT)) != NULL)%@NL@%
            hwnd = hwndT;%@NL@%
    WinQueryWindowRect(hwnd, &rcTmp);%@NL@%
    %@AB@%/* bound window rectangle to screen. */%@AE@%%@NL@%
    WinMapWindowPoints(hwnd, HWND_DESKTOP, (PPOINTL)&rcTmp.xLeft, 2);%@NL@%
    WinIntersectRect(habSnap, &rc, &rcTmp, &rcScreen);%@NL@%
    WinMapWindowPoints(HWND_DESKTOP, hwnd, (PPOINTL)&rc.xLeft, 2);%@NL@%
    cx = (USHORT)(rc.xRight - rc.xLeft);%@NL@%
    cy = (USHORT)(rc.yTop - rc.yBottom);%@NL@%
%@NL@%
    %@AB@%/* get window PS */%@AE@%%@NL@%
    hpsWnd = WinGetPS(hwnd);%@NL@%
%@NL@%
    %@AB@%/* Create a memory DC */%@AE@%%@NL@%
    hdc = CreateDC((PSZ)"MEMORY", (HDC)NULL);%@NL@%
%@NL@%
    %@AB@%/* create a memory PS */%@AE@%%@NL@%
    size.cx = cx;%@NL@%
    size.cy = cy;%@NL@%
    hpsMem = GpiCreatePS( habSnap, hdc, &size,%@NL@%
            PU_ARBITRARY | GPIT_NORMAL | GPIA_ASSOC );%@NL@%
%@NL@%
    %@AB@%/* Create a bitmap */%@AE@%%@NL@%
    bminfo.cbFix = 12;%@NL@%
    bminfo.cx = cx;%@NL@%
    bminfo.cy = cy;%@NL@%
    bminfo.cPlanes = 1;%@NL@%
    bminfo.cBitCount = 4;%@NL@%
    if (!(hbm = GpiCreateBitmap(hpsMem, (PBITMAPINFOHEADER)&bminfo, 0L, 0, 0)))%@NL@%
        WinMessageBox((HWND)HWND_DESKTOP, hwndSnap,%@NL@%
            (PCH)"Insufficient memory to create the bitmap.", (PCH)NULL,%@NL@%
            0, MB_OK);%@NL@%
    else {%@NL@%
        %@AB@%/* put the bitmap into the memory PS */%@AE@%%@NL@%
        hbmOld = GpiSetBitmap(hpsMem, hbm);%@NL@%
%@NL@%
        %@AB@%/* copy the window to the memory PS */%@AE@%%@NL@%
        rgpt[0].x = 0;%@NL@%
        rgpt[0].y = 0;%@NL@%
        rgpt[1].x = cx;%@NL@%
        rgpt[1].y = cy;%@NL@%
        rgpt[2].x = rc.xLeft;%@NL@%
        rgpt[2].y = rc.yBottom;%@NL@%
        GpiBitBlt(hpsMem, hpsWnd, 3L, (PPOINTL)&rgpt[0], ROP_SRCCOPY, 0L);%@NL@%
%@NL@%
        %@AB@%/* free the bitmap */%@AE@%%@NL@%
        GpiSetBitmap(hpsMem, hbmOld);%@NL@%
%@NL@%
        %@AB@%/* store the bitmap */%@AE@%%@NL@%
        WinOpenClipbrd(habSnap);%@NL@%
        WinEmptyClipbrd(habSnap);%@NL@%
        WinSetClipbrdData(habSnap, (ULONG)hbm, CF_BITMAP, CFI_HANDLE);%@NL@%
        WinCloseClipbrd(habSnap);%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* destroy the memory DC */%@AE@%%@NL@%
    GpiAssociate( hpsMem, NULL );%@NL@%
    DevCloseDC(hdc);%@NL@%
%@NL@%
    %@AB@%/* get rid of the PSs */%@AE@%%@NL@%
    GpiDestroyPS(hpsMem);%@NL@%
    WinReleasePS(hpsWnd);%@NL@%
%@NL@%
    if (fHide)%@NL@%
        WinShowWindow(hwndSnapFrame, TRUE);%@NL@%
%@NL@%
} %@AB@%/* end snapwindow */%@AE@%%@NL@%
%@NL@%
%@NL@%
void SnapRegion(hpsScr)%@NL@%
HPS hpsScr;%@NL@%
{%@NL@%
    HDC hdc;%@NL@%
    HBITMAP hbm, hbmOld;%@NL@%
    BITMAPINFOHEADER bminfo;%@NL@%
    RECTL rcTmp;%@NL@%
    int cx, cy;%@NL@%
    POINTL rgpt[3];%@NL@%
    HPS hpsMem;%@NL@%
    SIZEL size;%@NL@%
%@NL@%
    SortRect((PRECTL)&wrcRgn, (PRECTL)&rcTmp);%@NL@%
%@NL@%
    cx = (USHORT)(rcTmp.xRight - rcTmp.xLeft);%@NL@%
    cy = (USHORT)(rcTmp.yTop - rcTmp.yBottom);%@NL@%
%@NL@%
    %@AB@%/* Create a memory DC */%@AE@%%@NL@%
    hdc = CreateDC((PSZ)"MEMORY", (HDC)NULL);%@NL@%
%@NL@%
    %@AB@%/* create a memory PS */%@AE@%%@NL@%
    size.cx = cx;%@NL@%
    size.cy = cy;%@NL@%
    hpsMem = GpiCreatePS( habSnap, hdc, &size,%@NL@%
            PU_ARBITRARY | GPIT_NORMAL | GPIA_ASSOC );%@NL@%
%@NL@%
    %@AB@%/* Create a bitmap */%@AE@%%@NL@%
    bminfo.cbFix = 12;%@NL@%
    bminfo.cx = cx;%@NL@%
    bminfo.cy = cy;%@NL@%
    bminfo.cPlanes = 1;%@NL@%
    bminfo.cBitCount = 4;%@NL@%
    if (!(hbm = GpiCreateBitmap(hpsMem, (PBITMAPINFOHEADER)&bminfo, 0L, 0, 0))) {%@NL@%
        WinMessageBox((HWND)HWND_DESKTOP, hwndSnap,%@NL@%
            (PCH)"Insufficient memory to create the bitmap.", (PCH)NULL,%@NL@%
            0, MB_OK);%@NL@%
    } else {%@NL@%
        %@AB@%/* put the bitmap into the memory PS */%@AE@%%@NL@%
        hbmOld = GpiSetBitmap(hpsMem, hbm);%@NL@%
%@NL@%
        %@AB@%/* copy the window to the memory PS */%@AE@%%@NL@%
        rgpt[0].x = 0;%@NL@%
        rgpt[0].y = 0;%@NL@%
        rgpt[1].x = cx;%@NL@%
        rgpt[1].y = cy;%@NL@%
        rgpt[2].x = rcTmp.xLeft;%@NL@%
        rgpt[2].y = rcTmp.yBottom;%@NL@%
        GpiBitBlt(hpsMem, hpsScr, 3L, (PPOINTL)&rgpt[0], ROP_SRCCOPY, 0L);%@NL@%
%@NL@%
        %@AB@%/* free the bitmap */%@AE@%%@NL@%
        GpiSetBitmap(hpsMem, hbmOld);%@NL@%
%@NL@%
        %@AB@%/* store the bitmap */%@AE@%%@NL@%
        WinOpenClipbrd(habSnap);%@NL@%
        WinEmptyClipbrd(habSnap);%@NL@%
        WinSetClipbrdData(habSnap, (ULONG)hbm, CF_BITMAP, CFI_HANDLE);%@NL@%
        WinCloseClipbrd(habSnap);%@NL@%
    }%@NL@%
    %@AB@%/* destroy the memory DC */%@AE@%%@NL@%
    GpiAssociate( hpsMem, NULL );%@NL@%
    DevCloseDC(hdc);%@NL@%
%@NL@%
    %@AB@%/* get rid of the PS */%@AE@%%@NL@%
    GpiDestroyPS(hpsMem);%@NL@%
%@NL@%
    if (fHide)%@NL@%
        WinShowWindow(hwndSnapFrame, TRUE);%@NL@%
%@NL@%
} %@AB@%/* end snapregion */%@AE@%%@NL@%
%@NL@%
void DrawRgn(hps)%@NL@%
HPS hps;%@NL@%
{%@NL@%
    RECTL rc;%@NL@%
%@NL@%
    SortRect((PRECTL)&wrcRgn, (PRECTL)&rc);%@NL@%
%@NL@%
    WinDrawBorder(hps, (PRECTL)&rc, 1, 1, SYSCLR_WINDOW, SYSCLR_WINDOW,%@NL@%
            DB_DESTINVERT | DB_STANDARD);%@NL@%
}%@NL@%
%@NL@%
void SortRect(pwrcIn, pwrcSorted)%@NL@%
PRECTL pwrcIn, pwrcSorted;%@NL@%
{%@NL@%
    if (pwrcIn->yTop > pwrcIn->yBottom) {%@NL@%
        pwrcSorted->yTop = pwrcIn->yTop;%@NL@%
        pwrcSorted->yBottom = pwrcIn->yBottom;%@NL@%
    } else {%@NL@%
        pwrcSorted->yTop = pwrcIn->yBottom;%@NL@%
        pwrcSorted->yBottom = pwrcIn->yTop;%@NL@%
    }%@NL@%
    if (pwrcIn->xRight > pwrcIn-> xLeft) {%@NL@%
        pwrcSorted->xRight = pwrcIn->xRight;%@NL@%
        pwrcSorted->xLeft = pwrcIn->xLeft;%@NL@%
    } else {%@NL@%
        pwrcSorted->xRight = pwrcIn->xLeft;%@NL@%
        pwrcSorted->xLeft = pwrcIn->xRight;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
MRESULT EXPENTRY AboutWndProc(hwnd, message, mp1, mp2)%@NL@%
HWND    hwnd;%@NL@%
USHORT  message;%@NL@%
MPARAM   mp1;%@NL@%
MPARAM   mp2;%@NL@%
{%@NL@%
    switch (message) {%@NL@%
        case WM_COMMAND:%@NL@%
            WinDismissDlg(hwnd, TRUE);%@NL@%
            break;%@NL@%
        default:%@NL@%
            return(WinDefDlgProc(hwnd, message, mp1, mp2));%@NL@%
            break;%@NL@%
    }%@NL@%
    return 0L;%@NL@%
%@NL@%
} %@AB@%/* end aboutwndproc */%@AE@%%@NL@%
%@NL@%
void SaveBitmap(void)%@NL@%
{%@NL@%
    HFILE hFile;%@NL@%
    HBITMAP hbm;%@NL@%
    HPOINTER hptr, hptrWait;%@NL@%
%@NL@%
    WinOpenClipbrd(habSnap);%@NL@%
    if ((hbm = (HBITMAP) WinQueryClipbrdData(habSnap, CF_BITMAP)) == NULL) {%@NL@%
        WinCloseClipbrd(habSnap);%@NL@%
        return;%@NL@%
    }%@NL@%
%@NL@%
    if (hFile = OpenSaveFile(hwndSnap)) {%@NL@%
        hptr = WinQueryPointer(HWND_DESKTOP);%@NL@%
        hptrWait = WinQuerySysPointer(HWND_DESKTOP, SPTR_WAIT, TRUE);%@NL@%
        WinSetPointer(HWND_DESKTOP, hptrWait);%@NL@%
        SaveBitmap2(hFile, hbm);%@NL@%
        WinSetPointer(HWND_DESKTOP, hptr);%@NL@%
        WinDestroyPointer(hptrWait);%@NL@%
    } else%@NL@%
        WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
%@NL@%
    WinCloseClipbrd(habSnap);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* hFile is a handle to an open file.  This is closed on exit.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void SaveBitmap2(hFile, hbm)%@NL@%
HFILE hFile;%@NL@%
HBITMAP hbm;%@NL@%
{%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Currently, this puts stuff out in Win386 paint format.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    typedef struct _WIN386PAINT {%@NL@%
        USHORT key1;%@NL@%
        USHORT key2;%@NL@%
        USHORT dxFile;%@NL@%
        USHORT dyFile;%@NL@%
        USHORT ScrAspectX;%@NL@%
        USHORT ScrAspectY;%@NL@%
        USHORT PrnAspectX;%@NL@%
        USHORT PrnAspectY;%@NL@%
        USHORT dxPrinter;%@NL@%
        USHORT dyPrinter;%@NL@%
        USHORT AspCorX;%@NL@%
        USHORT AspCorY;%@NL@%
        USHORT wCheck;%@NL@%
        USHORT res1;%@NL@%
        USHORT res2;%@NL@%
        USHORT res3;%@NL@%
    } FHDR;%@NL@%
    FHDR hdr;%@NL@%
    USHORT i;%@NL@%
    USHORT cBytesWritten;%@NL@%
    USHORT *pIndex;%@NL@%
    USHORT *pIndexT;%@NL@%
    NPBYTE pScanLine, pBits, pBitsT;%@NL@%
    USHORT *phdr;%@NL@%
    USHORT cbIndexTable, cbScanLine, cbScanLineExp, cbBmpLine;%@NL@%
    HDC hdc;%@NL@%
    HBITMAP hbmOld;%@NL@%
    BITMAPINFOHEADER bminfo;%@NL@%
    HPS hpsMem;%@NL@%
    SIZEL size;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * write header%@NL@%
%@AB@%     */%@AE@%%@NL@%
    GpiQueryBitmapParameters(hbm, &bminfo);%@NL@%
    hdr.key1 = 0x694C;%@NL@%
    hdr.key2 = 0x536E;%@NL@%
    hdr.dxFile = bminfo.cx;%@NL@%
    hdr.dyFile = bminfo.cy;%@NL@%
    hdr.ScrAspectX = 26;%@NL@%
    hdr.ScrAspectY = 30;%@NL@%
    hdr.PrnAspectX = 0x12c;%@NL@%
    hdr.PrnAspectY = 0x12c;%@NL@%
    hdr.dxPrinter = 0x8df;%@NL@%
    hdr.dyPrinter = 0xce1;%@NL@%
    hdr.AspCorX = 0;%@NL@%
    hdr.AspCorY = 0;%@NL@%
%@NL@%
    phdr = (USHORT *)&hdr;%@NL@%
    hdr.wCheck = 0;%@NL@%
    for (i=0; i < 12; i++)%@NL@%
        hdr.wCheck ^= *phdr++;%@NL@%
%@NL@%
    hdr.res1 = 0;%@NL@%
    hdr.res2 = 0;%@NL@%
    hdr.res3 = 0;%@NL@%
%@NL@%
    DosWrite(hFile, (PSZ)&hdr, sizeof(FHDR), (PUSHORT)&cBytesWritten);%@NL@%
%@NL@%
    %@AB@%/* calculate sizes */%@AE@%%@NL@%
    cbIndexTable = sizeof(unsigned int) * bminfo.cy;%@NL@%
    cbScanLine = (bminfo.cx + 7) >> 3;%@NL@%
    cbScanLineExp = cbScanLine + ((cbScanLine + 0xff) >> 8);%@NL@%
    cbBmpLine = (cbScanLine + 3) & 0xfffc;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Write index table - (no compression)%@NL@%
%@AB@%     */%@AE@%%@NL@%
    %@AB@%/* allocate pIndex */%@AE@%%@NL@%
    if ((pIndex = (USHORT *)WinAllocMem(hHeap, cbIndexTable)) == NULL) {%@NL@%
        WinFreeMem(hHeap, (NPBYTE)pIndex, cbIndexTable);%@NL@%
        goto Exit;%@NL@%
    }%@NL@%
    pIndexT = pIndex;%@NL@%
    for (i=0; i < bminfo.cy; i++)%@NL@%
        *pIndexT++ = cbScanLineExp;%@NL@%
%@NL@%
    DosWrite(hFile, (PSZ)pIndex, cbIndexTable, &cBytesWritten);%@NL@%
%@NL@%
    %@AB@%/* free pIndex */%@AE@%%@NL@%
    WinFreeMem(hHeap, (NPBYTE)pIndex, cbIndexTable);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Write out each scan line%@NL@%
%@AB@%     */%@AE@%%@NL@%
    %@AB@%/* allocate pScanLine */%@AE@%%@NL@%
    if ((pScanLine = WinAllocMem(hHeap, cbScanLineExp)) == NULL) {%@NL@%
        WinFreeMem(hHeap, (NPBYTE)pScanLine, cbScanLineExp);%@NL@%
        goto Exit;%@NL@%
    }%@NL@%
    %@AB@%/* allocate pBits */%@AE@%%@NL@%
    if ((pBits = WinAllocMem(hHeap, cbBmpLine * bminfo.cy)) == NULL) {%@NL@%
        WinFreeMem(hHeap, pBits, cbBmpLine * bminfo.cy);%@NL@%
        goto Exit;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* specify the bitmap format we want */%@AE@%%@NL@%
    bminfo.cPlanes = 1;%@NL@%
    bminfo.cBitCount = 1;%@NL@%
%@NL@%
    %@AB@%/* Create memory DC */%@AE@%%@NL@%
    hdc = CreateDC((PSZ)"MEMORY", (HDC)NULL);%@NL@%
%@NL@%
    %@AB@%/* create a memory PS */%@AE@%%@NL@%
    size.cx = bminfo.cx;%@NL@%
    size.cy = bminfo.cy;%@NL@%
    hpsMem = GpiCreatePS( habSnap, hdc, &size,%@NL@%
            PU_ARBITRARY | GPIT_NORMAL | GPIA_ASSOC);%@NL@%
%@NL@%
    hbmOld = GpiSetBitmap(hpsMem, hbm);%@NL@%
    GpiQueryBitmapBits(hpsMem, (LONG)0, (LONG)bminfo.cy, (PBYTE)pBits,%@NL@%
            (PBITMAPINFO)&bminfo);%@NL@%
%@NL@%
    pBitsT = pBits + cbBmpLine * bminfo.cy;%@NL@%
    for (i = 0; i < bminfo.cy; i++) {%@NL@%
        pBitsT -= cbBmpLine;%@NL@%
        Copy(pBitsT, pScanLine, cbScanLine);%@NL@%
        convert(pScanLine, cbScanLine, cbScanLineExp);%@NL@%
        DosWrite(hFile, (PSZ)pScanLine, cbScanLineExp, &cBytesWritten);%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* free pBits and pScanLine */%@AE@%%@NL@%
    WinFreeMem(hHeap, pBits, cbScanLine * bminfo.cy);%@NL@%
    WinFreeMem(hHeap, pScanLine, cbScanLineExp);%@NL@%
%@NL@%
    GpiAssociate(hpsMem, NULL);%@NL@%
    DevCloseDC(hdc);%@NL@%
    GpiDestroyPS(hpsMem);%@NL@%
%@NL@%
Exit:%@NL@%
    DosClose(hFile);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* Insert apropriate repeat count bytes into the scanline given.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void convert(pbuf, cch, cch2)%@NL@%
NPBYTE pbuf;%@NL@%
USHORT cch; %@AB@%/* exact length of buffer BEFORE count bytes have been added */%@AE@%%@NL@%
USHORT cch2; %@AB@%/* AFTER conversion size */%@AE@%%@NL@%
{%@NL@%
    NPBYTE pWrite, pRead;%@NL@%
%@NL@%
    pWrite = pbuf + cch2 - 1;%@NL@%
    pRead = pbuf + cch - 1;%@NL@%
    while (pWrite > pbuf) {%@NL@%
        *pWrite-- = *pRead--;%@NL@%
        if (((pWrite - pbuf) & 0x00ff) == 0) {%@NL@%
            *pWrite-- = (BYTE)((pbuf + cch2 - pWrite) < 0x100 ?%@NL@%
                    (pbuf + cch2 - pWrite) : 0xff);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
void Copy(src, dest, cb)%@NL@%
NPBYTE src;%@NL@%
NPBYTE dest;%@NL@%
USHORT cb;%@NL@%
{%@NL@%
    USHORT i;%@NL@%
%@NL@%
    for (i = 0; i < cb; i++)%@NL@%
        *dest++ = *src++;%@NL@%
}%@NL@%
%@NL@%
HFILE OpenSaveFile(hwnd)%@NL@%
HWND hwnd;%@NL@%
{%@NL@%
    HFILE   hFile= 0L;%@NL@%
    DLGP    dlgp;%@NL@%
    char    fName[32];%@NL@%
    USHORT  action;%@NL@%
%@NL@%
    dlgp.cch = 32;%@NL@%
    dlgp.psz = fName;%@NL@%
    if (WinDlgBox(HWND_DESKTOP, hwnd, (PFNWP)SaveFileDlgProc, (HMODULE) NULL,%@NL@%
            IDD_SAVEFILE, (PVOID)&dlgp) != 0) {%@NL@%
        DosOpen(fName, &hFile, &action, 0L, 0, 0x0011, 0x0011, 0L);%@NL@%
    }%@NL@%
    return(hFile);%@NL@%
}%@NL@%
%@NL@%
MRESULT EXPENTRY SaveFileDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    DLGP FAR *pdlgp;%@NL@%
    SHORT cch;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_INITDLG:%@NL@%
        %@AB@%/* squirl away the dlgp pointer in a reentrant fashion */%@AE@%%@NL@%
        WinSetWindowULong(hwnd, QWL_USER, (ULONG)mp2);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CHAR:%@NL@%
        if ( (SHORT1FROMMP(mp1) & KC_VIRTUALKEY) &&%@NL@%
                ((SHORT2FROMMP(mp2) == VK_NEWLINE) ||%@NL@%
                 (SHORT2FROMMP(mp2) == VK_ENTER)) ) {%@NL@%
            if (pdlgp = (DLGP FAR *)WinQueryWindowULong(hwnd, QWL_USER)) {%@NL@%
                cch = WinQueryWindowText(WinWindowFromID(hwnd, ID_FILEENTRY),%@NL@%
                        pdlgp->cch, pdlgp->psz);%@NL@%
                WinDismissDlg(hwnd, cch);%@NL@%
            } else {%@NL@%
                WinDismissDlg(hwnd, 0);%@NL@%
            }%@NL@%
            return(0);%@NL@%
        }%@NL@%
        break;%@NL@%
    }%@NL@%
%@NL@%
    return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SORT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SORT\SORT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@% This program demonstrates the use of many threads by doing%@NL@%
%@AB@% LISTCNT simultaneous sorts.  Each sorting algorithm runs%@NL@%
%@AB@% from a separate thread, the routine which updates the display%@NL@%
%@AB@% is run from another thread, and the main thread is used to%@NL@%
%@AB@% handle the main window's messages.  The display thread is%@NL@%
%@AB@% started when the program begins and is not terminated (allows%@NL@%
%@AB@% default cleanup to terminate thread) as the display routine%@NL@%
%@AB@% is used throughout the program's life.%@NL@%
%@AB@% This code was written to allow easy modification.  To change%@NL@%
%@AB@% the number of simultaneous sorts, change the LISTCNT #define%@NL@%
%@AB@% and modify the global arrays which control the screen%@NL@%
%@AB@% drawing color, the sort each thread is to use, and the sort name.%@NL@%
%@AB@% Note:  This program was not intended to infer the relative%@NL@%
%@AB@%        speeds of the various sorting algorithms.%@NL@%
%@AB@%%@NL@%
%@AB@% This program was written by Jeff Johnson, 8/89.%@NL@%
%@AB@%%@NL@%
%@AB@% Procedures in this file:%@NL@%
%@AB@%   main()             Sets up the PM environment and calls%@NL@%
%@AB@%                      the main dialog procedure ClientWndProc%@NL@%
%@AB@%   ClientWndProc()    Handles the main window messages%@NL@%
%@AB@%   CalcThread()       Generic stub that sets up, executes, and%@NL@%
%@AB@%                      terminates each sort in an aux. thread%@NL@%
%@AB@%   DispThread()       Updates the display during the sorts%@NL@%
%@AB@%   BubbleSort()       Implements a bubble sort%@NL@%
%@AB@%   InsertionSort()    Implements an insertion sort%@NL@%
%@AB@%   BatcherSort()      Stub that calls recursive Batcher sort%@NL@%
%@AB@%   BatcherSortR()     Implements a Batcher sort%@NL@%
%@AB@%   QuickSort()        Stub that calls recursive Quick sort%@NL@%
%@AB@%   QuickSortR()       Implements a Quick sort%@NL@%
%@AB@%   EnableMenuItem()   Activates/deactivates a menu choice%@NL@%
%@AB@%   EntryFldDlgProc()  Handles the set number of disks dialog box%@NL@%
%@AB@%   RandomizeData()    Randomizes the data arrays for the sorts%@NL@%
%@AB@%%@NL@%
%@AB@%**************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"sort.h" %@NL@%
%@NL@%
%@AB@%/********************* GLOBALS *******************************/%@AE@%%@NL@%
%@NL@%
CHAR szClientClass[] = "Sort";%@NL@%
USHORT Data[LISTCNT][NELEMS];     %@AB@%/* Array that contains the data to sort  */%@AE@%%@NL@%
%@NL@%
%@AB@%/* Global data that defines each of the sort routines */%@AE@%%@NL@%
ULONG  ulColors[LISTCNT] =   { CLR_RED,        %@AB@%/* Color of each of the     */%@AE@%%@NL@%
                               CLR_BLUE,       %@AB@%/* LISTCNT data lists.      */%@AE@%%@NL@%
                               CLR_DARKGREEN,%@NL@%
                               CLR_YELLOW };%@NL@%
VOID((*pExecSub[LISTCNT])())=  { BubbleSort,     %@AB@%/* List of sorts to be      */%@AE@%%@NL@%
                               BatcherSort,    %@AB@%/* executed for each of the */%@AE@%%@NL@%
                               QuickSort,      %@AB@%/* LISTCNT threads.         */%@AE@%%@NL@%
                               InsertionSort };%@NL@%
CHAR *szSubNames[LISTCNT] =  { "Bubble Sort",  %@AB@%/* Ascii names of sorts     */%@AE@%%@NL@%
                               "Batcher Sort",%@NL@%
                               "Quick Sort",%@NL@%
                               "Insertion Sort" };%@NL@%
%@NL@%
%@AB@%/*************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: main()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  NONE%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Always returns 0%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Sets up the PM environment, calls the main window proc,%@NL@%
%@AB@%            handles the window's messages then cleans up and exits.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: ClientWndProc() (thru PM)%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
int main()%@NL@%
{%@NL@%
   HAB          hab;%@NL@%
   HMQ          hmq;%@NL@%
   HWND         hwndFrame, hwndClient;%@NL@%
   QMSG         qmsg;%@NL@%
%@NL@%
   ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU | FCF_MINMAX    |%@NL@%
                        FCF_SHELLPOSITION | FCF_MENU    | FCF_TASKLIST  |%@NL@%
                        FCF_SIZEBORDER    | FCF_ICON;%@NL@%
%@NL@%
   %@AB@%/* These PM calls should be error checked */%@AE@%%@NL@%
   hab = WinInitialize(0);%@NL@%
   hmq = WinCreateMsgQueue(hab, 0);%@NL@%
%@NL@%
   if(!WinRegisterClass(hab, szClientClass,ClientWndProc,0L,0))%@NL@%
   {%@NL@%
      WinAlarm(HWND_DESKTOP, WA_ERROR);        %@AB@%/* Register failed */%@AE@%%@NL@%
      DosExit(EXIT_PROCESS,1);%@NL@%
   }%@NL@%
%@NL@%
   hwndFrame = WinCreateStdWindow(HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                  &flFrameFlags, szClientClass, NULL,%@NL@%
                                  0L, (HMODULE) NULL, ID_MAINMENU, &hwndClient);%@NL@%
   if(!hwndFrame)%@NL@%
   {%@NL@%
      WinAlarm(HWND_DESKTOP, WA_ERROR); %@AB@%/* Window create failed */%@AE@%%@NL@%
      DosExit(EXIT_PROCESS,1);%@NL@%
   }%@NL@%
%@NL@%
   while(WinGetMsg(hab,&qmsg,NULL,0,0))        %@AB@%/* Message loop */%@AE@%%@NL@%
      WinDispatchMsg(hab,&qmsg);%@NL@%
%@NL@%
   WinDestroyWindow(hwndFrame);                %@AB@%/* Clean up     */%@AE@%%@NL@%
   WinDestroyMsgQueue(hmq);%@NL@%
   WinTerminate(hab);%@NL@%
   return 0;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: ClientWndProc()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd, msg, mp1, mp2.  Standard PM Dialog Proc params.%@NL@%
%@AB@% *              No user data is expected in the WM_CREATE.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Returns with WM_QUIT message%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Handles all the messages associated with the main window%@NL@%
%@AB@% *          and calls the appropriate handling procedures.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: Called only by main()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls: RandomizeData(), DispThread() (thru thread),%@NL@%
%@AB@%          CalcThread() (thru thread)%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
   HPS    hps;                           %@AB@%/* Handle for painting            */%@AE@%%@NL@%
   RECTL  rcl;                           %@AB@%/* Rectangle struct for painting  */%@AE@%%@NL@%
   POINTL ptl;                           %@AB@%/* Point struct for painting      */%@AE@%%@NL@%
   static CALCPARAM cp[LISTCNT];         %@AB@%/* Struct passed to sort threads  */%@AE@%%@NL@%
   static TID    tidCalc[LISTCNT];       %@AB@%/* Sort threads IDs               */%@AE@%%@NL@%
   static VOID   *pThreadStack[LISTCNT]; %@AB@%/* Pointer to sort threads stacks */%@AE@%%@NL@%
   static CALCPARAM cpDisp;              %@AB@%/* Struct passed to disp thread   */%@AE@%%@NL@%
   static TID    tidDisplay;             %@AB@%/* Secondary display thread ID    */%@AE@%%@NL@%
   static VOID   *pDisplayStack;         %@AB@%/* Ptr to secondary display stack */%@AE@%%@NL@%
   static USHORT usWindowYCoord=1;       %@AB@%/* Holds current client window ht */%@AE@%%@NL@%
   static BYTE   cThreadCnt = 0;         %@AB@%/* Count of sort threads running  */%@AE@%%@NL@%
   static USHORT cSetSize = NELEMS;      %@AB@%/* User sort set size             */%@AE@%%@NL@%
   USHORT cnt,cnt2,usID;                 %@AB@%/* Utility counters               */%@AE@%%@NL@%
   ULONG  ulBlip;                        %@AB@%/* Holds the marker pos for Paint */%@AE@%%@NL@%
%@NL@%
   switch(msg)%@NL@%
   {%@NL@%
      case WM_CREATE:%@NL@%
         RandomizeData(cSetSize);        %@AB@%/* Initially randomize data set   */%@AE@%%@NL@%
%@NL@%
         %@AB@%/* Start display thread */%@AE@%%@NL@%
         if((pDisplayStack = malloc(STACKSIZE)) == NULL)%@NL@%
         {%@NL@%
            WinAlarm(HWND_DESKTOP, WA_ERROR);      %@AB@%/* Can't allocate stack */%@AE@%%@NL@%
            DosExit(EXIT_PROCESS,1);%@NL@%
         }%@NL@%
%@NL@%
         cpDisp.hwnd        = hwnd;%@NL@%
         cpDisp.Array       = &usWindowYCoord;%@NL@%
         cpDisp.pcThreadCnt = &cThreadCnt;%@NL@%
         cpDisp.pcSetSize   = &cSetSize;%@NL@%
%@NL@%
         if((tidDisplay = _beginthread(DispThread,pDisplayStack,%@NL@%
                                         STACKSIZE, &cpDisp))  == -1)%@NL@%
         {%@NL@%
            free(pDisplayStack);          %@AB@%/* Couldn't start display thread */%@AE@%%@NL@%
            WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
            DosExit(EXIT_PROCESS,1);%@NL@%
         }%@NL@%
         %@AB@%/* Up the display priority an arbitrary amount to cause it to%@NL@%
%@AB@%            update more rapidly and to give it a higher priority than%@NL@%
%@AB@%            the sort threads.*/%@AE@%%@NL@%
         DosSetPrty(PRTYS_THREAD,%@NL@%
                    PRTYC_REGULAR,5,tidDisplay);%@NL@%
         return 0L;%@NL@%
%@NL@%
      case WM_SIZE:%@NL@%
         WinInvalidateRect(hwnd,NULL,FALSE);     %@AB@%/* Force a redraw */%@AE@%%@NL@%
         return WinDefWindowProc(hwnd, msg, mp1, mp2);%@NL@%
%@NL@%
      case WM_PAINT:%@NL@%
         hps = WinBeginPaint(hwnd,NULL,NULL);   %@AB@%/* Get paint handle      */%@AE@%%@NL@%
         WinQueryWindowRect(hwnd,&rcl);%@NL@%
         usWindowYCoord = (USHORT) rcl.yTop;%@NL@%
%@NL@%
         if((XOFFSET < (USHORT) (rcl.xRight-rcl.xLeft)) && %@AB@%/* Draw if screen */%@AE@%%@NL@%
            (YOFFSET < (USHORT) (rcl.yTop-rcl.yBottom)))   %@AB@%/* is big enough  */%@AE@%%@NL@%
         {%@NL@%
            DrawRect(rcl.xLeft,rcl.yBottom,         %@AB@%/* White out the screen  */%@AE@%%@NL@%
                     rcl.xRight,rcl.yTop,CLR_WHITE);%@NL@%
%@NL@%
            DrawLine(XOFFSET, YOFFSET,              %@AB@%/* Draw baseline         */%@AE@%%@NL@%
                     rcl.xRight,YOFFSET,CLR_BLACK);%@NL@%
%@NL@%
            DrawLine(XOFFSET, YOFFSET,              %@AB@%/* Draw vertical line    */%@AE@%%@NL@%
                     XOFFSET,rcl.yTop,CLR_BLACK);%@NL@%
%@NL@%
            for(cnt=0;cnt<LISTCNT;cnt++)            %@AB@%/* Draw data points      */%@AE@%%@NL@%
            {%@NL@%
               for(cnt2=0;cnt2<cSetSize;cnt2++)%@NL@%
               {%@NL@%
                  ulBlip = (rcl.yTop-YOFFSET-5) * Data[cnt][cnt2] / RAND_MAX%@NL@%
                           + YOFFSET+1;%@NL@%
%@NL@%
                  Draw2Pel(XOFFSET+1 + cnt2, ulBlip, ulColors[cnt]);%@NL@%
               }%@NL@%
            }%@NL@%
            for(cnt=0;cnt<COLUMNCNT;cnt++)          %@AB@%/* Do bottom legend      */%@AE@%%@NL@%
            {%@NL@%
               for(cnt2=1;cnt2<=ROWCNT;cnt2++)%@NL@%
               {%@NL@%
                  usID = cnt*ROWCNT + cnt2-1;%@NL@%
                  if(usID >= LISTCNT)%@NL@%
                     break;%@NL@%
%@NL@%
                  ptl.x = XOFFSET + cnt*COLUMNOFFSET;%@NL@%
                  ptl.y = YOFFSET - cnt2*ROWOFFSET;%@NL@%
%@NL@%
                  GpiSetColor(hps,ulColors[usID]);%@NL@%
                  GpiCharStringAt(hps,&ptl,(LONG) strlen(szSubNames[usID]),%@NL@%
                                  szSubNames[usID]);%@NL@%
               }%@NL@%
            }%@NL@%
         }%@NL@%
%@NL@%
         WinEndPaint(hps);%@NL@%
         return 0L;%@NL@%
%@NL@%
      case WM_COMMAND:%@NL@%
         switch(COMMANDMSG(&msg)->cmd)%@NL@%
         {%@NL@%
            case IDM_START:%@NL@%
%@NL@%
               %@AB@%/* Try to get stack space */%@AE@%%@NL@%
               for(cnt=0;cnt<LISTCNT;cnt++)%@NL@%
               {%@NL@%
                  if((pThreadStack[cnt] = malloc(STACKSIZE)) == NULL)%@NL@%
                  {%@NL@%
                     WinAlarm(HWND_DESKTOP, WA_ERROR); %@AB@%/* Can't get memory */%@AE@%%@NL@%
                     return 0L;%@NL@%
                  }%@NL@%
                  cp[cnt].hwnd          = hwnd;  %@AB@%/* Set the static struct  */%@AE@%%@NL@%
                  cp[cnt].fContinueCalc = TRUE;%@NL@%
                  cp[cnt].pFunc         = pExecSub[cnt];%@NL@%
                  cp[cnt].usID          = cnt;%@NL@%
                  cp[cnt].Array         = Data[cnt];%@NL@%
                  cp[cnt].cArray        = cSetSize;%@NL@%
%@NL@%
                  %@AB@%/* Try to start the thread */%@AE@%%@NL@%
                  if((tidCalc[cnt] = _beginthread(CalcThread,pThreadStack[cnt],%@NL@%
                                                  STACKSIZE, &cp[cnt]))  == -1)%@NL@%
                  {%@NL@%
                     free(pThreadStack[cnt]);    %@AB@%/* Thread wouldn't start  */%@AE@%%@NL@%
                     WinAlarm(HWND_DESKTOP, WA_ERROR);%@NL@%
                     return 0L;%@NL@%
                  }%@NL@%
                  if(cThreadCnt++ == 0)  %@AB@%/* When the first thread starts */%@AE@%%@NL@%
                  {%@NL@%
                     %@AB@%/* Disable Start, Set, and Randomize, enable Stop */%@AE@%%@NL@%
                     EnableMenuItem(hwnd,IDM_START,FALSE);%@NL@%
                     EnableMenuItem(hwnd,IDM_SET,FALSE);%@NL@%
                     EnableMenuItem(hwnd,IDM_RANDOM,FALSE);%@NL@%
                     EnableMenuItem(hwnd,IDM_STOP,TRUE);%@NL@%
                  }%@NL@%
               }%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDM_STOP:%@NL@%
               for(cnt=0;cnt<LISTCNT;cnt++)%@NL@%
                  cp[cnt].fContinueCalc = FALSE;  %@AB@%/* Notify thread to quit  */%@AE@%%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDM_RANDOM:%@NL@%
               RandomizeData(cSetSize);                %@AB@%/* Randomize data */%@AE@%%@NL@%
               WinInvalidateRect(hwnd,NULL,FALSE);     %@AB@%/* Force a redraw */%@AE@%%@NL@%
               return 0L;%@NL@%
%@NL@%
            case IDM_SET:%@NL@%
               if(WinDlgBox(HWND_DESKTOP, hwnd, %@AB@%/* Pop up the query/set box */%@AE@%%@NL@%
                            EntryFldDlgProc,(HMODULE) NULL,ID_SETCOUNT,%@NL@%
                            (VOID FAR *) &cSetSize))%@NL@%
               {%@NL@%
                  WinInvalidateRect(hwnd,NULL,FALSE);     %@AB@%/* Force a redraw */%@AE@%%@NL@%
               }%@NL@%
               return 0L;%@NL@%
%@NL@%
            default:%@NL@%
               return WinDefWindowProc(hwnd, msg, mp1, mp2);%@NL@%
         }%@NL@%
%@NL@%
      case UM_CALC_DONE:%@NL@%
         usID = (USHORT) SHORT1FROMMP(mp1); %@AB@%/* Get ID of quit thread     */%@AE@%%@NL@%
%@NL@%
         if(--cThreadCnt == 0)              %@AB@%/* If all quit, enable menus */%@AE@%%@NL@%
         {%@NL@%
            EnableMenuItem(hwnd,IDM_START,TRUE);%@NL@%
            EnableMenuItem(hwnd,IDM_SET,TRUE);%@NL@%
            EnableMenuItem(hwnd,IDM_RANDOM,TRUE);%@NL@%
            EnableMenuItem(hwnd,IDM_STOP,FALSE);%@NL@%
         }%@NL@%
%@NL@%
         free(pThreadStack[usID]);          %@AB@%/* Free thread's stack space */%@AE@%%@NL@%
         return 0L;%@NL@%
%@NL@%
      default:%@NL@%
         return WinDefWindowProc(hwnd, msg, mp1, mp2);%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: CalcThread()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pcp is a struct which contains the hwnd handle, the%@NL@%
%@AB@% *              continue flag which is initially set to TRUE, the ID%@NL@%
%@AB@% *              which is the%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This generic stub calls the passed "sort" function with a pointer%@NL@%
%@AB@% *          to the data and an item count, then when the sort terminates, it%@NL@%
%@AB@% *          cleans up by Posting a done message, then terminating the thread.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: No DosExitCritSec() is called since _endthread()%@NL@%
%@AB@% *                 clears the critical section when the thread is%@NL@%
%@AB@% *                 terminated.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  Whatever function is passed in pcp->pFunc.  (As initially%@NL@%
%@AB@% *         configured, it calls:  BubbleSort(), InsertionSort(),%@NL@%
%@AB@% *         BatcherSort(), and QuickSort()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID _cdecl FAR CalcThread(PCALCPARAM pcp)%@NL@%
{%@NL@%
   (*pcp->pFunc)(pcp);                      %@AB@%/* Execute recurs routine */%@AE@%%@NL@%
%@NL@%
   DosEnterCritSec(); %@AB@%/* Set Crit so the UM_CALC_DONE isn't processed */%@AE@%%@NL@%
                      %@AB@%/* until this thread has completely terminated  */%@AE@%%@NL@%
   WinPostMsg(pcp->hwnd,UM_CALC_DONE,%@NL@%
              MPFROMSHORT(pcp->usID),NULL);              %@AB@%/* Post done */%@AE@%%@NL@%
%@NL@%
   _endthread();                %@AB@%/* Terminate thread and exit crit sec */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: DispThread()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pcp is a struct which contains the hwnd handle, the%@NL@%
%@AB@% *              count of active threads, the ->Array element points to%@NL@%
%@AB@% *              the current height of the window which can be dynamically%@NL@%
%@AB@% *              resized by the user, the pcSetSize points to the current%@NL@%
%@AB@% *              set size which can be changed by the user only when the%@NL@%
%@AB@% *              sort is stopped.%@NL@%
%@AB@% *              None of the other pcp members are used.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine is run as a secondary thread to update the screen%@NL@%
%@AB@% *          when the sort threads are running.  It works by making passes%@NL@%
%@AB@% *          through the data lists and redrawing them.  A DosSleep(0) is%@NL@%
%@AB@% *          called at the end of each pass to help sychronize things a bit.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: Note that this thread is started when the program is%@NL@%
%@AB@% *                 initialized, and is never terminated.  Note that%@NL@%
%@AB@% *                 fDoUpdate is used in such a way that the screen is%@NL@%
%@AB@% *                 ALWAYS updated once after all threads have terminated.%@NL@%
%@AB@% *                 This avoids the possibility of the display not being%@NL@%
%@AB@% *                 fully accurate when the sorts terminate.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID _cdecl FAR DispThread(PCALCPARAM pcp)%@NL@%
{%@NL@%
   HAB hab;              %@AB@%/* Anchor block, used just for WinInitialize() */%@AE@%%@NL@%
   USHORT cnt,cnt2;      %@AB@%/* Utility counters                            */%@AE@%%@NL@%
   HPS hps;              %@AB@%/* Presentation space handle                   */%@AE@%%@NL@%
   POINTL ptl;           %@AB@%/* Used for various drawing macros             */%@AE@%%@NL@%
   ULONG  ulBlip;        %@AB@%/* Holds the Y offset for a given data point   */%@AE@%%@NL@%
   BYTE   fDoUpdate = 0; %@AB@%/* Used to ensure screen is fully updated      */%@AE@%%@NL@%
                         %@AB@%/* after all sort threads terminate            */%@AE@%%@NL@%
   USHORT *pusYCoord = pcp->Array; %@AB@%/* Points to location that always    */%@AE@%%@NL@%
                                   %@AB@%/* contains current client wind hgt  */%@AE@%%@NL@%
%@NL@%
   hab = WinInitialize(0);    %@AB@%/* Called to increase Ring 2 stack size   */%@AE@%%@NL@%
   hps = WinGetPS(pcp->hwnd);%@NL@%
%@NL@%
   while(TRUE)%@NL@%
   {%@NL@%
      if(*pcp->pcThreadCnt != 0)          %@AB@%/* Set update flag if at least 1 */%@AE@%%@NL@%
         fDoUpdate = (BYTE) (*pcp->pcThreadCnt+1); %@AB@%/* sort thread is still running  */%@AE@%%@NL@%
%@NL@%
      while(!fDoUpdate && !(*pcp->pcThreadCnt));  %@AB@%/* Only update when a    */%@AE@%%@NL@%
                                                  %@AB@%/* sort is running       */%@AE@%%@NL@%
      for(cnt=0;cnt<*pcp->pcSetSize;cnt++)        %@AB@%/* Update data set       */%@AE@%%@NL@%
      {%@NL@%
         DrawLine(XOFFSET+1 + cnt,YOFFSET+1,      %@AB@%/* Erase vertical column */%@AE@%%@NL@%
                  XOFFSET+1 + cnt,*pusYCoord, CLR_WHITE);%@NL@%
%@NL@%
         for(cnt2=0;cnt2<LISTCNT;cnt2++)          %@AB@%/* Draw each point       */%@AE@%%@NL@%
         {%@NL@%
            ulBlip = (ULONG) (*pusYCoord-YOFFSET-5)*Data[cnt2][cnt] / RAND_MAX%@NL@%
                      + YOFFSET+1;%@NL@%
            Draw2Pel(XOFFSET+1 + cnt, ulBlip, ulColors[cnt2]);%@NL@%
         }%@NL@%
      }%@NL@%
      fDoUpdate--;  %@AB@%/* Decrement update flag */%@AE@%%@NL@%
   }%@NL@%
%@NL@%
   %@AB@%/* Note that these 3 lines NEVER get executed, but should the program be%@NL@%
%@AB@%      modified to end the thread, this is the appropriate termination code. */%@AE@%%@NL@%
   WinReleasePS(hps);%@NL@%
   WinTerminate(hab);%@NL@%
   _endthread();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: BubbleSort()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pcp is a struct which contains the hwnd handle, a%@NL@%
%@AB@% *              pointer to the data array, and a count of the items in%@NL@%
%@AB@% *              the data array.%@NL@%
%@AB@% *              None of the other pcp members are used.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose:  Implements a bubble sort which is an O(n^2) algorithm.  It%@NL@%
%@AB@% *           works by repeatedly going through the data and comparing%@NL@%
%@AB@% *           consecutive elements and swapping them if they aren't in%@NL@%
%@AB@% *           the correct order.  This guarantees that each pass will%@NL@%
%@AB@% *           place at least one additional item in its appropriate%@NL@%
%@AB@% *           place.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID BubbleSort(PCALCPARAM pcp)%@NL@%
{%@NL@%
   BOOL fModified = FALSE; %@AB@%/* Set whenever a swap is done, if an entire */%@AE@%%@NL@%
                           %@AB@%/* pass doesn't set the flag, the we're done */%@AE@%%@NL@%
   SHORT cnt,cnt2;         %@AB@%/* Counters used for the 2-level loops       */%@AE@%%@NL@%
   USHORT usTemp;          %@AB@%/* Used to hold a data item during a swap    */%@AE@%%@NL@%
%@NL@%
   for(cnt=pcp->cArray-1;cnt>=0;cnt--) %@AB@%/* Set for the max no. of passes */%@AE@%%@NL@%
   {%@NL@%
      for(cnt2=0;cnt2<cnt;cnt2++) %@AB@%/* Only sort thru current cnt pass    */%@AE@%%@NL@%
      {%@NL@%
         if(!pcp->fContinueCalc)  %@AB@%/* User wishes to terminate the sort  */%@AE@%%@NL@%
            return;%@NL@%
%@NL@%
         if(pcp->Array[cnt2]>pcp->Array[cnt2+1]) %@AB@%/* Items need to swap  */%@AE@%%@NL@%
         {%@NL@%
            fModified = TRUE;%@NL@%
%@NL@%
            usTemp = pcp->Array[cnt2];%@NL@%
            pcp->Array[cnt2] = pcp->Array[cnt2+1];%@NL@%
            pcp->Array[cnt2+1]= usTemp;%@NL@%
         }%@NL@%
      }%@NL@%
      if(!fModified)          %@AB@%/* Nothing changed during the entire pass */%@AE@%%@NL@%
         break;%@NL@%
      fModified = FALSE;                       %@AB@%/* Reset the modify flag */%@AE@%%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: InsertionSort()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pcp is a struct which contains the hwnd handle, a%@NL@%
%@AB@% *              pointer to the data array, and a count of the items in%@NL@%
%@AB@% *              the data array.%@NL@%
%@AB@% *              None of the other pcp members are used.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose:  Implements an insertion sort which is an O(n^2) algorithm.%@NL@%
%@AB@% *           This sort works much faster and does not require that much%@NL@%
%@AB@% *           additional code to implement.  It works by setting a sorted%@NL@%
%@AB@% *           list to be just the first element, the working each%@NL@%
%@AB@% *           successive item into the already sorted list.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID InsertionSort(PCALCPARAM pcp)%@NL@%
{%@NL@%
   SHORT cnt,cnt2;         %@AB@%/* Counters used for the 2-level loops       */%@AE@%%@NL@%
   USHORT usTemp;          %@AB@%/* Used to hold a data item during a swap    */%@AE@%%@NL@%
%@NL@%
   for(cnt=1;cnt<(SHORT)pcp->cArray;cnt++)         %@AB@%/* Insert each item in turn */%@AE@%%@NL@%
   {%@NL@%
      if(!pcp->fContinueCalc)      %@AB@%/* User wishes to terminate the sort */%@AE@%%@NL@%
         return;%@NL@%
      usTemp=pcp->Array[cnt];                   %@AB@%/* Hold value to insert */%@AE@%%@NL@%
      cnt2=cnt-1;%@NL@%
      while(pcp->Array[cnt2]>usTemp)    %@AB@%/* Move items down to make room */%@AE@%%@NL@%
      {%@NL@%
         pcp->Array[cnt2+1]=pcp->Array[cnt2];%@NL@%
         cnt2--;%@NL@%
         if(cnt2<0)%@NL@%
            break;%@NL@%
      }%@NL@%
      pcp->Array[cnt2+1] = usTemp;                   %@AB@%/* Insert the item */%@AE@%%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: BatcherSort()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pcp is a struct which contains the continue flag,%@NL@%
%@AB@% *              a pointer to the data array, and a count of the items in%@NL@%
%@AB@% *              the data array.%@NL@%
%@AB@% *              None of the other pcp members are used.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose:  This routine is a stub that calls the recursive Batcher sort%@NL@%
%@AB@% *           with the proper initial arguments.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  It passes the pcp, the size of the array to be sorted,%@NL@%
%@AB@% *                  the offset to start sorting at(0), the number number%@NL@%
%@AB@% *                  of elements each item is from neighboring elements (1),%@NL@%
%@AB@% *                  and Half flag to sort the halves (1=YES).%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  BatcherSortR()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID BatcherSort(PCALCPARAM pcp)%@NL@%
{%@NL@%
   BatcherSortR(pcp,pcp->cArray,0,1,1);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: BatcherSortR()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pcp is a struct which contains the continue flag,%@NL@%
%@AB@% *              a pointer to the data array.%@NL@%
%@AB@% *              None of the other pcp members are used.%@NL@%
%@AB@% *              usArrSize is the number of elements in the current sort set.%@NL@%
%@AB@% *              usStart is the offset to the 1st element in the set.%@NL@%
%@AB@% *              usSkip is the spacing between consecutive elements.%@NL@%
%@AB@% *              fHalves sorts the 2 halves when set, otherwise skips the%@NL@%
%@AB@% *                      1st 2 of the 4 sub-sorts.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose:  Implements Batcher sort which is O(n lg n).  The advantage%@NL@%
%@AB@% *           of the batcher sort is that the comparisons made do NOT%@NL@%
%@AB@% *           depend upon the outcome of previous comparisons.  This makes%@NL@%
%@AB@% *           it a good algorithm for parallelism.  The algorithm works as%@NL@%
%@AB@% *           follows:  Sort the first half, sort the second half, sort the%@NL@%
%@AB@% *           odd elements, sort the even elements, then compare swap%@NL@%
%@AB@% *           elements 2/3, 4/5, ...%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  There are several adaptations to the algorithm to%@NL@%
%@AB@% *                  allow it to work with arbitrary sized data sets%@NL@%
%@AB@% *                  (the original required a power of 2 sized data%@NL@%
%@AB@% *                  set):  if the set size is less than 2, the routine%@NL@%
%@AB@% *                  returns, the first "half" is always the largest%@NL@%
%@AB@% *                  possible power of two, and the top value for the%@NL@%
%@AB@% *                  final compare/swap is adjusted to round up in%@NL@%
%@AB@% *                  case of an odd data set.%@NL@%
%@AB@% *                  Another optimization is that involving the fHalves%@NL@%
%@AB@% *                  flag.  This stems from the observation that when%@NL@%
%@AB@% *                  the odd/even sort recurses, the first and second%@NL@%
%@AB@% *                  halves are already sorted, thus the first 2%@NL@%
%@AB@% *                  recursive calls are unnecessary in this case.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  BatcherSortR() (recursively)%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID BatcherSortR(PCALCPARAM pcp, USHORT usArrSize, USHORT usStart,%@NL@%
                  USHORT usSkip, BOOL fHalves)%@NL@%
{%@NL@%
   USHORT cnt,usUpper,usTemp; %@AB@%/* Utility variables */%@AE@%%@NL@%
%@NL@%
   if(!pcp->fContinueCalc) %@AB@%/* User wishes to terminate the sort */%@AE@%%@NL@%
      return;%@NL@%
%@NL@%
   if(usArrSize<2) %@AB@%/* No sorting needed if <2 items in the set */%@AE@%%@NL@%
      return;%@NL@%
%@NL@%
   if(usArrSize==2) %@AB@%/* Do simple compare/swap if there are 2 elements */%@AE@%%@NL@%
   {%@NL@%
      if(pcp->Array[usStart]>pcp->Array[usStart+usSkip])%@NL@%
      {%@NL@%
         usTemp = pcp->Array[usStart];%@NL@%
         pcp->Array[usStart] = pcp->Array[usStart+usSkip];%@NL@%
         pcp->Array[usStart+usSkip]= usTemp;%@NL@%
      }%@NL@%
      return;%@NL@%
   }%@NL@%
%@NL@%
   usTemp=1;                  %@AB@%/* usTemp ends up holding the smallest power */%@AE@%%@NL@%
   while(usTemp < usArrSize)  %@AB@%/* of 2 that is at least as big as usArrSize */%@AE@%%@NL@%
      usTemp *= 2;%@NL@%
%@NL@%
   if(fHalves)  %@AB@%/* If the sort was NOT called by the odd/even recurses */%@AE@%%@NL@%
   {%@NL@%
      BatcherSortR(pcp,usTemp/2,usStart,usSkip,1);    %@AB@%/* Sort 1st half */%@AE@%%@NL@%
      BatcherSortR(pcp,usArrSize-usTemp/2,            %@AB@%/* Sort 2nd half */%@AE@%%@NL@%
                   usStart+usTemp/2*usSkip,usSkip,1);%@NL@%
   }%@NL@%
   BatcherSortR(pcp,usArrSize-usArrSize/2,usStart,usSkip*2,0); %@AB@%/* Sort evens */%@AE@%%@NL@%
   BatcherSortR(pcp,usArrSize/2,usStart+usSkip,usSkip*2,0);    %@AB@%/* Sort odds  */%@AE@%%@NL@%
%@NL@%
   if(!pcp->fContinueCalc) %@AB@%/* User wishes to terminate the sort */%@AE@%%@NL@%
      return;%@NL@%
%@NL@%
   usUpper=usStart+usSkip+(usArrSize-usArrSize/2-1)*2*usSkip;%@NL@%
   for(cnt=usStart+usSkip;cnt<usUpper;cnt+=usSkip*2) %@AB@%/* Do final compares */%@AE@%%@NL@%
   {%@NL@%
      if(pcp->Array[cnt]>pcp->Array[cnt+usSkip])%@NL@%
      {%@NL@%
         usTemp = pcp->Array[cnt];%@NL@%
         pcp->Array[cnt] = pcp->Array[cnt+usSkip];%@NL@%
         pcp->Array[cnt+usSkip]= usTemp;%@NL@%
      }%@NL@%
      if(!pcp->fContinueCalc) %@AB@%/* User wishes to terminate the sort */%@AE@%%@NL@%
         return;%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: QuickSort()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pcp is a struct which contains the continue flag,%@NL@%
%@AB@% *              a pointer to the data array, and a count of the items in%@NL@%
%@AB@% *              the data array.%@NL@%
%@AB@% *              None of the other pcp members are used.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose:  This routine is a stub that calls the recursive Quick sort%@NL@%
%@AB@% *           with the proper initial arguments.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:  It passes the pcp (Which contains the array ptr),%@NL@%
%@AB@% *                  the offset to start sorting at(0), and the offset to%@NL@%
%@AB@% *                  finish sorting at (Array size-1).%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  QuickSortR()%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID QuickSort(PCALCPARAM pcp)%@NL@%
{%@NL@%
   QuickSortR(pcp,0,pcp->cArray-1);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: QuickSortR()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  pcp is a struct which contains the continue flag,%@NL@%
%@AB@% *              a pointer to the data array.%@NL@%
%@AB@% *              None of the other pcp members are used.%@NL@%
%@AB@% *              sLeft is the offset of the leftmost sort element (smallest).%@NL@%
%@AB@% *              sRight is the offset of rightmost sort element (largest).%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose:  Implements Quick sort which is O(n lg n).  Quick sort is a%@NL@%
%@AB@% *           good all-purpose sorting algorithm and is widely used.  This%@NL@%
%@AB@% *           implementation works by placing the first element in the list%@NL@%
%@AB@% *           into its correct place, by moving all elements smaller to its%@NL@%
%@AB@% *           left, and all numbers larger to its right.  The Quick sort%@NL@%
%@AB@% *           recurses on the 2 halves on either side of the properly placed%@NL@%
%@AB@% *           element.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:  QuickSortR() (recursively)%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID QuickSortR(PCALCPARAM pcp, SHORT sLeft, SHORT sRight)%@NL@%
{%@NL@%
   SHORT sTempLeft  = sLeft;    %@AB@%/* Holds lower bound on split position      */%@AE@%%@NL@%
   SHORT sTempRight = sRight;   %@AB@%/* Holds upper bound on split position      */%@AE@%%@NL@%
   SHORT sSplit;                %@AB@%/* Used to hold offset of positioned elem   */%@AE@%%@NL@%
   USHORT usTemp;               %@AB@%/* Holds temp element during positioning    */%@AE@%%@NL@%
%@NL@%
   if(sLeft>=sRight)            %@AB@%/* If there is <=1 element, return          */%@AE@%%@NL@%
      return;%@NL@%
%@NL@%
   if(!pcp->fContinueCalc)      %@AB@%/* User wishes to terminate the sort        */%@AE@%%@NL@%
      return;%@NL@%
%@NL@%
   %@AB@%/* Split list, sSplit will contain the split element */%@AE@%%@NL@%
   usTemp = pcp->Array[sTempLeft];%@NL@%
%@NL@%
   while(TRUE)       %@AB@%/* Loop thru 2 cases until the split position is found */%@AE@%%@NL@%
   {%@NL@%
      while(pcp->Array[sTempRight] > usTemp && %@AB@%/* Skip elems on right side  */%@AE@%%@NL@%
                        sTempRight > sLeft)    %@AB@%/* that are > the split elem */%@AE@%%@NL@%
         sTempRight--;%@NL@%
%@NL@%
      if(sTempRight<=sTempLeft)  %@AB@%/* Left and Right have met, split is found */%@AE@%%@NL@%
      {%@NL@%
         pcp->Array[sTempLeft]=usTemp;  %@AB@%/* Place split elem at proper place */%@AE@%%@NL@%
         sSplit = sTempLeft;%@NL@%
         break;%@NL@%
      }%@NL@%
      pcp->Array[sTempLeft++] =%@NL@%
                    pcp->Array[sTempRight];    %@AB@%/* Move small element to LHS */%@AE@%%@NL@%
%@NL@%
      while(pcp->Array[sTempLeft] < usTemp &&  %@AB@%/* Skip elems on left side   */%@AE@%%@NL@%
                        sTempLeft < sRight)    %@AB@%/* that are < the split elem */%@AE@%%@NL@%
         sTempLeft++;%@NL@%
%@NL@%
      if(sTempRight<=sTempLeft)  %@AB@%/* Left and Right have met, split is found */%@AE@%%@NL@%
      {%@NL@%
         pcp->Array[sTempRight]=usTemp; %@AB@%/* Place split elem at proper place */%@AE@%%@NL@%
         sSplit = sTempRight;%@NL@%
         break;%@NL@%
      }%@NL@%
      pcp->Array[sTempRight--] =%@NL@%
                    pcp->Array[sTempLeft];     %@AB@%/* Move large element to RHS */%@AE@%%@NL@%
   }%@NL@%
%@NL@%
   QuickSortR(pcp,sLeft,sSplit-1);     %@AB@%/* Sort the 1st half of the list     */%@AE@%%@NL@%
%@NL@%
   if(!pcp->fContinueCalc)             %@AB@%/* User wishes to terminate the sort */%@AE@%%@NL@%
      return;%@NL@%
%@NL@%
   QuickSortR(pcp,sSplit+1,sRight);    %@AB@%/* Sort the 2nd half of the list     */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: EnableMenuItem()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd is a handle of the current window.%@NL@%
%@AB@% *              sMenuItem is the ID of the item to Enable/Disable.%@NL@%
%@AB@% *              fEnable will enable item if TRUE, otherwise disables it.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine handles enabling/disabling of menu items.  This%@NL@%
%@AB@% *          is done by getting Parent and Menu hwnd handles then sending%@NL@%
%@AB@% *          the appropriate message.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings:%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID EnableMenuItem(HWND hwnd, SHORT sMenuItem, BOOL fEnable)%@NL@%
{%@NL@%
   HWND hwndParent = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
   HWND hwndMenu   = WinWindowFromID(hwndParent, FID_MENU);%@NL@%
%@NL@%
   WinSendMsg(hwndMenu, MM_SETITEMATTR,%@NL@%
              MPFROM2SHORT(sMenuItem, TRUE),%@NL@%
              MPFROM2SHORT(MIA_DISABLED, fEnable ? 0 : MIA_DISABLED));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: EntryFldDlgProc()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  hwnd, msg, mp1, mp2.  Standard PM Dialog Proc params.%@NL@%
%@AB@% *              A pointer to the current set size is passed in WM_INITDLG.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: Terminates with a TRUE iff a new valid data set size is entered.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: Handles all the messages associated with the set entry field%@NL@%
%@AB@% *          and calls the appropriate handling procedures.  The purpose%@NL@%
%@AB@% *          of this dialog box is to get a new data set size for the%@NL@%
%@AB@% *          sort routines.%@NL@%
%@AB@% *%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: If the value entered is valid, the proc will set the%@NL@%
%@AB@% *                 variable passed in through the WM_INITDLG to the value.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY EntryFldDlgProc(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
   SHORT sNewSize;                                     %@AB@%/* Holds new set set */%@AE@%%@NL@%
   static USHORT FAR *pcSetSize;    %@AB@%/* Set to point to user-passed set size */%@AE@%%@NL@%
   switch(msg)%@NL@%
   {%@NL@%
      case WM_INITDLG:%@NL@%
         pcSetSize=PVOIDFROMMP(mp2);%@NL@%
         WinSendDlgItemMsg(hwnd, ID_ENTRYFLD,EM_SETTEXTLIMIT,  %@AB@%/* Limit len */%@AE@%%@NL@%
                                 MPFROM2SHORT(3,0),NULL);%@NL@%
         WinSetDlgItemShort(hwnd, ID_ENTRYFLD,(SHORT) *pcSetSize,TRUE);%@NL@%
         return 0L;                           %@AB@%/* Allow normal focus setting */%@AE@%%@NL@%
%@NL@%
      case WM_COMMAND:%@NL@%
         switch(COMMANDMSG(&msg)->cmd)%@NL@%
         {%@NL@%
            case DID_OK:%@NL@%
               WinQueryDlgItemShort(hwnd, ID_ENTRYFLD,%@NL@%
                                    &sNewSize, TRUE); %@AB@%/* Get the short      */%@AE@%%@NL@%
               if(sNewSize>0 && sNewSize<=NELEMS)  %@AB@%/* Set new data set size */%@AE@%%@NL@%
               {%@NL@%
                  *pcSetSize = (USHORT) sNewSize;%@NL@%
                  WinDismissDlg(hwnd,TRUE);%@NL@%
               }%@NL@%
               else                                   %@AB@%/* Invalid value      */%@AE@%%@NL@%
                  WinDismissDlg(hwnd,FALSE);%@NL@%
               return 0L;%@NL@%
%@NL@%
            case DID_CANCEL:%@NL@%
               WinDismissDlg(hwnd,FALSE);%@NL@%
               return 0L;%@NL@%
%@NL@%
            default:%@NL@%
               return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
         }%@NL@%
%@NL@%
      default:%@NL@%
         return WinDefDlgProc(hwnd, msg, mp1, mp2);%@NL@%
   }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Function name: RandomizeData()%@NL@%
%@AB@% *%@NL@%
%@AB@% * Parameters:  cSetSize is the current size of the data set%@NL@%
%@AB@% *%@NL@%
%@AB@% * Returns: VOID%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: This routine randomizes the data arrays.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Usage/Warnings: This routine assumes that LISTCNT and NELEMS define%@NL@%
%@AB@% *                 the dimensions of the global Data array which is%@NL@%
%@AB@% *                 randomized.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Calls:%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
VOID RandomizeData(USHORT cSetSize)%@NL@%
{%@NL@%
   USHORT cnt,cnt2;%@NL@%
   for(cnt=0;cnt<LISTCNT;cnt++)%@NL@%
      for(cnt2=0;cnt2<cSetSize;cnt2++)%@NL@%
         Data[cnt][cnt2] = rand();%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SPY.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SPY\SPY.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* spy.c - Spy application%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%       INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%       INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%       INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%       INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%       INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%       INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%       INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%       INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%       INCL_WINSHELLDATA %@NL@%
%@AI@%#define %@AE@%       INCL_WINSYS %@NL@%
%@AI@%#define %@AE@%       INCL_WINWINDOWMGR %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"spyhook.h" %@NL@%
%@AI@%#include %@AE@%<time.h> %@NL@%
%@AI@%#include %@AE@%"spy.h" %@NL@%
%@NL@%
%@AB@%/* File Local Variables */%@AE@%%@NL@%
HAB         hab;%@NL@%
HMQ         hmqSpy;%@NL@%
HWND        hwndSpy;%@NL@%
HWND        hwndSpyFrame;%@NL@%
HWND        hwndSpyList = NULL;%@NL@%
HWND        hwndWindowLB;%@NL@%
HWND        hwndMessageLB;%@NL@%
HHEAP       hHeap;%@NL@%
SHORT       cxBorder;%@NL@%
SHORT       cyBorder;%@NL@%
%@NL@%
HPOINTER    hptrArrow;%@NL@%
HPOINTER    hptrSelWin;%@NL@%
%@NL@%
USHORT      iCurItemFocus;              %@AB@%/* Index to item that has the focus */%@AE@%%@NL@%
BOOL        fSpyActive = MIA_CHECKED;   %@AB@%/* Any non-zero is true */%@AE@%%@NL@%
BOOL        fTrackingListBox = FALSE;   %@AB@%/* Tracking windows active ? */%@AE@%%@NL@%
BOOL        fAllFrames = 0;             %@AB@%/* Are we processing all frames ? */%@AE@%%@NL@%
BOOL        fAllWindows = 0;            %@AB@%/* Are we processing all windows ? */%@AE@%%@NL@%
%@NL@%
%@NL@%
HWND        hwndWinDlgDisp = NULL;      %@AB@%/* hwnds info in Window Dialog */%@AE@%%@NL@%
%@NL@%
SHORT       wDumpCount = 0;             %@AB@%/* Count of which window is being dumped */%@AE@%%@NL@%
SPWD        *pspwd = NULL;%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Define memory semaphore to have second thread sleep on */%@AE@%%@NL@%
ULONG       semThread = 0L;             %@AB@%/* Thread to wait on */%@AE@%%@NL@%
int         AboutCount = 0;%@NL@%
UCHAR       rgMsgData[MAXMSGBYTES];     %@AB@%/* Max bytes to extract per message */%@AE@%%@NL@%
%@NL@%
%@NL@%
char szSpyClass[] = "Spy";%@NL@%
char szTitle[] = "";%@NL@%
%@NL@%
%@AB@%/* Function Prototypes */%@AE@%%@NL@%
int        cdecl main(int, char **);%@NL@%
void    FAR ProcHookThread(void);    %@AB@%/* will process the hook messages */%@AE@%%@NL@%
void    ProcessQueueMsg(QMSGSPY *);%@NL@%
void    UpdateMsgBoxCurMsgText(HWND);%@NL@%
void    InitializeOptions(int, char **);    %@AB@%/* initialize Spy initial state */%@AE@%%@NL@%
PSZ     DumpParam(PSZ prgData, MPARAM mp, SHORT cb, UCHAR bMPType);%@NL@%
MRESULT EXPENTRY SpyWndProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
VOID        SpyPaint(VOID);%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* int cdecl main (argc, argv)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Spy Main function%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
int cdecl main(argc, argv)%@NL@%
int argc;%@NL@%
char **argv;%@NL@%
{%@NL@%
    ULONG   flCreateFlags;%@NL@%
    QMSG    qmsg;%@NL@%
    RECTL   rcl;%@NL@%
    TID     tid;%@NL@%
    char    *prgStack;%@NL@%
%@NL@%
%@NL@%
    hab = WinInitialize(0);%@NL@%
%@NL@%
    hmqSpy = WinCreateMsgQueue(hab, 0);%@NL@%
%@NL@%
    if (!WinRegisterClass((HAB)NULL, szSpyClass, (PFNWP)SpyWndProc,%@NL@%
            CS_SYNCPAINT, 0)) {%@NL@%
        WinAlarm(HWND_DESKTOP, 0xffff);%@NL@%
        return(0);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Create a heap for the program%@NL@%
%@AB@%     */%@AE@%%@NL@%
    hHeap = WinCreateHeap(0, 0, 0, 0, 0, 0);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Create a stack for the thread - also initialize the stack by zeroing%@NL@%
%@AB@%     * the first 32 bytes, and filling the remainder with a known value%@NL@%
%@AB@%     */%@AE@%%@NL@%
    prgStack = WinAllocMem(hHeap, CBSTACK);%@NL@%
    if (prgStack == NULL)%@NL@%
        goto Abort;%@NL@%
    memset(prgStack, '\0', 32); %@AB@%/* Init first 32 bytes to zero */%@AE@%%@NL@%
    memset(prgStack+32,'\345', CBSTACK-32); %@AB@%/* Remainder to known value */%@AE@%%@NL@%
%@NL@%
    hptrArrow = WinQuerySysPointer(HWND_DESKTOP, SPTR_ARROW, TRUE);%@NL@%
    cxBorder = (SHORT)WinQuerySysValue(HWND_DESKTOP, SV_CXBORDER);%@NL@%
    cyBorder = (SHORT)WinQuerySysValue(HWND_DESKTOP, SV_CYBORDER);%@NL@%
%@NL@%
    hptrSelWin = WinQuerySysPointer(HWND_DESKTOP, SPTR_MOVE, TRUE);%@NL@%
%@NL@%
    SpyInstallHook(hab, hmqSpy, spyopt.bHooks);%@NL@%
    SpySetAllWindowOpt (fAllWindows);%@NL@%
    SpySetAllFrameOpt (fAllFrames);%@NL@%
%@NL@%
    flCreateFlags = FCF_STANDARD;%@NL@%
    hwndSpyFrame = WinCreateStdWindow(HWND_DESKTOP,%@NL@%
            WS_VISIBLE,%@NL@%
            (VOID FAR *)&flCreateFlags,%@NL@%
            szSpyClass, szTitle,%@NL@%
            WS_VISIBLE,%@NL@%
            (HMODULE)NULL, IDR_SPY,%@NL@%
            (HWND FAR *)&hwndSpy);%@NL@%
%@NL@%
    WinQueryWindowRect(hwndSpy, &rcl);%@NL@%
    hwndSpyList = WinCreateWindow (hwndSpy, WC_LISTBOX, "",%@NL@%
            WS_VISIBLE | LS_NOADJUSTPOS,%@NL@%
            -cxBorder, -cyBorder,%@NL@%
            (SHORT)(rcl.xRight - rcl.xLeft) + 2 * cxBorder,%@NL@%
            (SHORT)(rcl.yTop - rcl.yBottom) + 2 * cyBorder,%@NL@%
            hwndSpy, HWND_TOP, DID_SPYLIST, NULL, NULL);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Read the os2.ini information if it exists, and set the menu items%@NL@%
%@AB@%     * to correspond to the initial state read from OS2.INI.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    InitializeOptions(argc, argv);    %@AB@%/* initialize Spy initial state */%@AE@%%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Set the focus to the list box.  Note: Only call WinSetFocus if%@NL@%
%@AB@%     * our frame is the active window.  As we may have been started in%@NL@%
%@AB@%     * the background.  If this is the case, we want to set the frame's%@NL@%
%@AB@%     * focus save to the listbox, such that it will be the active window%@NL@%
%@AB@%     * when our frame is activated.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (WinQueryWindow(HWND_DESKTOP, QW_TOP, FALSE) == hwndSpyFrame)%@NL@%
        WinSetFocus(HWND_DESKTOP, hwndSpyList);%@NL@%
    else%@NL@%
        WinSetWindowULong(hwndSpyFrame, QWL_HWNDFOCUSSAVE,%@NL@%
            (ULONG)hwndSpyList);%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Start the thread that will process the messages from the hook */%@AE@%%@NL@%
    DosCreateThread(ProcHookThread, (PTID)&tid,%@NL@%
        (PBYTE)(prgStack + CBSTACK - 1));%@NL@%
%@NL@%
    UpdateHooksMsgTable();      %@AB@%/* Set Spy's Message Table */%@AE@%%@NL@%
    SpyHookOnOrOff (TRUE);      %@AB@%/* Turn the hook on */%@AE@%%@NL@%
%@NL@%
%@NL@%
   %@AB@%/*%@NL@%
%@AB@%    * Now process all of the messages%@NL@%
%@AB@%    */%@AE@%%@NL@%
    while (WinGetMsg(NULL, (PQMSG)&qmsg, NULL, 0, 0)) {%@NL@%
        WinDispatchMsg(NULL, (PQMSG)&qmsg);%@NL@%
    }%@NL@%
%@NL@%
    SpyReleaseHook (TRUE);      %@AB@%/* Release input hook */%@AE@%%@NL@%
%@NL@%
    WinDestroyWindow(hwndSpyFrame);%@NL@%
%@NL@%
    WinDestroyPointer(hptrArrow);%@NL@%
    WinDestroyPointer(hptrSelWin);%@NL@%
%@NL@%
Abort:%@NL@%
    WinDestroyMsgQueue(hmqSpy);%@NL@%
    WinTerminate(hab);%@NL@%
%@NL@%
    %@AB@%/* If the spy output file is open, close it now */%@AE@%%@NL@%
    if (spyopt.hfileSpy != NULL)%@NL@%
        DosClose(spyopt.hfileSpy);%@NL@%
%@NL@%
%@NL@%
    DosExit(EXIT_PROCESS, 0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* InitializeOptions(argc, argv)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Initialize spy, first from the default options, second from%@NL@%
%@AB@%* OS2.INI file, and override from command switches.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
VOID InitializeOptions(argc, argv)%@NL@%
int argc;%@NL@%
char **argv;%@NL@%
{%@NL@%
    USHORT      cch;%@NL@%
    USHORT      wAction;%@NL@%
    HWND        hwndMenu;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If the OS2.INI information exists, initialize our options to%@NL@%
%@AB@%     * the stored values.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (WinQueryProfileSize (hab, "Spy", "Options", &cch) == 0) {%@NL@%
        cch = sizeof(SPYOPT);%@NL@%
%@NL@%
        WinQueryProfileData(hab, "Spy", "Options", (PSZ)&spyopt,%@NL@%
                &cch);%@NL@%
        WinQueryProfileString(hab, "Spy", "FileName", "spy.out",%@NL@%
                (PSZ)spystr.szFileName, sizeof(spystr.szFileName));%@NL@%
        WinQueryProfileString(hab, "Spy", "SaveFileName", "spy.lis",%@NL@%
                (PSZ)spystr.szSaveFileName, sizeof(spystr.szSaveFileName));%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Then check for command line overrides%@NL@%
%@AB@%     */%@AE@%%@NL@%
    while  (argc > 1) {%@NL@%
        argv++; %@AB@%/* get beyond the program name */%@AE@%%@NL@%
%@NL@%
        %@AB@%/* Test for send message hook flag */%@AE@%%@NL@%
        if (!strcmpi(*argv, "+s"))%@NL@%
            spyopt.bHooks |= SPYH_SENDMSG;%@NL@%
        if (!strcmpi(*argv, "-s"))%@NL@%
            spyopt.bHooks &= ~SPYH_SENDMSG;%@NL@%
%@NL@%
        %@AB@%/* Test for input hook flag */%@AE@%%@NL@%
        if (!strcmpi(*argv, "+i"))%@NL@%
            spyopt.bHooks |= SPYH_INPUT;%@NL@%
        if (!strcmpi(*argv, "-i"))%@NL@%
            spyopt.bHooks &= ~SPYH_INPUT;%@NL@%
%@NL@%
        argc--;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now we need to update the menu items to the final%@NL@%
%@AB@%     * state%@NL@%
%@AB@%     */%@AE@%%@NL@%
    hwndMenu = WinWindowFromID(hwndSpyFrame, FID_MENU);%@NL@%
%@NL@%
    WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(CMD_INPUTHOOK, TRUE),%@NL@%
            MPFROM2SHORT(MIA_CHECKED,%@NL@%
             (spyopt.bHooks & SPYH_INPUT) ? MIA_CHECKED : 0));%@NL@%
    WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(CMD_SENDMSGHOOK, TRUE),%@NL@%
             MPFROM2SHORT(MIA_CHECKED,%@NL@%
             (spyopt.bHooks & SPYH_SENDMSG) ? MIA_CHECKED : 0));%@NL@%
%@NL@%
    WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(CMD_SENDEXTEND, TRUE),%@NL@%
            MPFROM2SHORT(MIA_CHECKED,%@NL@%
             spyopt.fSendExtend ? MIA_CHECKED : 0));%@NL@%
%@NL@%
    WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(CMD_SENDSTACK, TRUE),%@NL@%
            MPFROM2SHORT(MIA_CHECKED,%@NL@%
            spyopt.fSendStack ? MIA_CHECKED : 0));%@NL@%
    WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(CMD_OUTSCREEN, TRUE),%@NL@%
            MPFROM2SHORT(MIA_CHECKED, spyopt.fWindow ? MIA_CHECKED : 0));%@NL@%
%@NL@%
    WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(CMD_OUTFILE, TRUE),%@NL@%
            MPFROM2SHORT(MIA_CHECKED, spyopt.fFile ? MIA_CHECKED : 0));%@NL@%
%@NL@%
    WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(CMD_ALPHASORT, TRUE),%@NL@%
            MPFROM2SHORT(MIA_CHECKED,%@NL@%
                    spyopt.fAlphaSortMsgList ? MIA_CHECKED : 0));%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If the options specify output to file, open the file now%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (spyopt.fFile) {%@NL@%
        if (DosOpen((PSZ)spystr.szFileName, &spyopt.hfileSpy,%@NL@%
                (USHORT far *)&wAction, 0L, 0,%@NL@%
                0x0012, 0x00C1, 0L) != 0)%@NL@%
            spyopt.hfileSpy = NULL; %@AB@%/* Failed on open */%@AE@%%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* MRESULT EXPENTRY SpyWndProc(hwnd, msg, mp1, mp2)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Spy Client window procedure%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY SpyWndProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    QMSGSPY qmsgspy;%@NL@%
    SHORT   cBytes;%@NL@%
    USHORT      wAction;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_CREATE:%@NL@%
        %@AB@%/* Set up this global first thing in case we need it elsewhere */%@AE@%%@NL@%
        hwndSpy = hwnd;%@NL@%
        break;%@NL@%
%@NL@%
    case WM_SEM2:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Other thread told use there are some messages out there.  Loop%@NL@%
%@AB@%         * through and process all of the pending messages, and output%@NL@%
%@AB@%         * the listbox position at the end.  Also make sure to flush%@NL@%
%@AB@%         * the file buffer before we go back to sleep.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        while (SpyGetNextMessage(&qmsgspy, rgMsgData, sizeof(rgMsgData), 0L)) {%@NL@%
            ProcessQueueMsg(&qmsgspy);%@NL@%
        }%@NL@%
%@NL@%
        if (spyopt.fFile)%@NL@%
            DosBufReset(spyopt.hfileSpy);%@NL@%
%@NL@%
        DosSemClear((HSEM)(PULONG)&semThread);%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1)) {%@NL@%
        case CMD_ACTIVE:%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * THe active menu item was selected, we will toggle the%@NL@%
%@AB@%             * the selection by setting active to 0 or MIA_CHECKED.%@NL@%
%@AB@%             * Call the hook, and then update the checkmark on the menu%@NL@%
%@AB@%             */%@AE@%%@NL@%
            fSpyActive ^= MIA_CHECKED;  %@AB@%/* Toggle on or off */%@AE@%%@NL@%
            SpyHookOnOrOff (fSpyActive);%@NL@%
            WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                MM_SETITEMATTR, MPFROM2SHORT(CMD_ACTIVE, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, fSpyActive));%@NL@%
%@NL@%
            break;%@NL@%
        case CMD_ABOUT:%@NL@%
            WinDlgBox(HWND_DESKTOP, hwnd, (PFNWP)AboutWndProc, NULL, AboutDlg, (PCH)NULL);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_EXIT:%@NL@%
            WinPostMsg(NULL, WM_QUIT, 0L, 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_CLRWIN:%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Delete all items in the list.  Simply do this%@NL@%
%@AB@%             * By deleting the first item, until the count goes to%@NL@%
%@AB@%             * zero%@NL@%
%@AB@%             */%@AE@%%@NL@%
            WinSendMsg(hwndSpyList, LM_DELETEALL, 0L, 0L);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_SAVEWIN:%@NL@%
            SpyHookOnOrOff (FALSE);%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndSpyFrame,%@NL@%
                (PFNWP)SpySaveListDlgProc, (HMODULE)NULL,%@NL@%
                SaveListDlg, (PCH)NULL);%@NL@%
            SpyHookOnOrOff (fSpyActive);%@NL@%
            break;%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * This command saves out the current options to OS2.ini%@NL@%
%@AB@%         */%@AE@%%@NL@%
        case CMD_SAVEOPT:%@NL@%
            WinWriteProfileData(hab, "Spy", "Options", (PSZ)&spyopt,%@NL@%
                    sizeof(SPYOPT));%@NL@%
            WinWriteProfileString(hab, "Spy", "FileName",%@NL@%
                    (PSZ)spystr.szFileName);%@NL@%
            WinWriteProfileString(hab, "Spy", "SaveFileName",%@NL@%
                    (PSZ)spystr.szSaveFileName);%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_LISTNEAR:%@NL@%
            WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                MM_SETITEMATTR, MPFROM2SHORT(CMD_LISTNEAR, TRUE),%@NL@%
                MPFROM2SHORT(MIA_DISABLED, MIA_DISABLED));%@NL@%
            WinLoadDlg(HWND_DESKTOP, hwndSpyFrame,%@NL@%
                (PFNWP)ListNearDlgProc, (HMODULE)NULL,%@NL@%
                ListNearDlg, (PCH)NULL);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_WINDOWS:%@NL@%
            SpyHookOnOrOff (FALSE);%@NL@%
            hwndWindowLB = NULL;%@NL@%
            iCurItemFocus = (USHORT)-1;%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndSpyFrame,%@NL@%
                (PFNWP)SpyWindowsDlgProc, (HMODULE)NULL,%@NL@%
                WindowsDlg, (PCH)NULL);%@NL@%
%@NL@%
            SpyHookOnOrOff (fSpyActive);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_QUEUES:%@NL@%
            SpyHookOnOrOff (FALSE);%@NL@%
            hwndWindowLB = NULL;%@NL@%
            iCurItemFocus = (USHORT)-1;%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndSpyFrame,%@NL@%
                (PFNWP)SpyQueuesDlgProc, (HMODULE)NULL,%@NL@%
                MsgQueueDlg, (PCH)NULL);%@NL@%
%@NL@%
            SpyHookOnOrOff (fSpyActive);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_WNMSSEL:%@NL@%
        case CMD_WNMSDSL:%@NL@%
            SpyHookOnOrOff (FALSE);%@NL@%
            SelOrDeselWithMouse(SHORT1FROMMP(mp1) == CMD_WNMSSEL);%@NL@%
            SpyHookOnOrOff (fSpyActive);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_ALLWNDWS:%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * The user selected the ALLFRAMES, toggle the state, and%@NL@%
%@AB@%             * update the menu and the hook state.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            fAllWindows ^= MIA_CHECKED;  %@AB@%/* Toggle on or off */%@AE@%%@NL@%
            SpySetAllWindowOpt (fAllWindows);%@NL@%
            WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                MM_SETITEMATTR, MPFROM2SHORT(CMD_ALLWNDWS, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, fAllWindows));%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_ALLFRAMES:%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * The user selected the ALLFRAMES, toggle the state, and%@NL@%
%@AB@%             * update the menu and the hook state.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            fAllFrames ^= MIA_CHECKED;  %@AB@%/* Toggle on or off */%@AE@%%@NL@%
            SpySetAllFrameOpt (fAllFrames);%@NL@%
            WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                MM_SETITEMATTR, MPFROM2SHORT(CMD_ALLFRAMES, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, fAllFrames));%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_WNDPWIN:%@NL@%
            wDumpCount = 0;%@NL@%
            DumpOneWindowInfo();%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_WNDPALL:%@NL@%
            wDumpCount = 0;%@NL@%
            pspwd = (SPWD *)WinAllocMem(hHeap, sizeof(SPWD)* MAXSPYDUMP);%@NL@%
            cBytes = DumpAllWindowsInfo(HWND_DESKTOP, 0);%@NL@%
            cBytes += DumpAllWindowsInfo(HWND_OBJECT, -10);%@NL@%
            DumpWindowIndex(cBytes);%@NL@%
            WinFreeMem(hHeap, (char *)pspwd, sizeof(SPWD)* MAXSPYDUMP);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_MESSAGES:%@NL@%
            SpyHookOnOrOff (FALSE);%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndSpyFrame,%@NL@%
                (PFNWP)SpyMsgDlgProc, (HMODULE)NULL,%@NL@%
                MessagesDlg, (PCH)NULL);%@NL@%
            SpyHookOnOrOff (fSpyActive);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_ALPHASORT:%@NL@%
            spyopt.fAlphaSortMsgList ^= TRUE;%@NL@%
%@NL@%
            WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                    MM_SETITEMATTR, MPFROM2SHORT(CMD_ALPHASORT, TRUE),%@NL@%
                    MPFROM2SHORT(MIA_CHECKED,%@NL@%
                            spyopt.fAlphaSortMsgList ? MIA_CHECKED : 0));%@NL@%
            break;%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * The command in this section are defined in the Hooks Menu.%@NL@%
%@AB@%         * All of these items toggle selections on or off.  The first two%@NL@%
%@AB@%         * items must be registered with the input hook.  The last two simply%@NL@%
%@AB@%         * retrict how much information is displayed for send messages.%@NL@%
%@AB@%         */%@AE@%%@NL@%
%@NL@%
        case CMD_INPUTHOOK:%@NL@%
            spyopt.bHooks ^= SPYH_INPUT;%@NL@%
            WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                MM_SETITEMATTR, MPFROM2SHORT(CMD_INPUTHOOK, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED,%@NL@%
                     (spyopt.bHooks & SPYH_INPUT) ? MIA_CHECKED : 0));%@NL@%
                SpyReleaseHook (FALSE);     %@AB@%/* Dont clear queue */%@AE@%%@NL@%
                SpyInstallHook(hab, hmqSpy, spyopt.bHooks);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_SENDMSGHOOK:%@NL@%
            spyopt.bHooks ^= SPYH_SENDMSG;%@NL@%
            WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                MM_SETITEMATTR, MPFROM2SHORT(CMD_SENDMSGHOOK, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED,%@NL@%
                     (spyopt.bHooks & SPYH_SENDMSG) ? MIA_CHECKED : 0));%@NL@%
                SpyReleaseHook (FALSE);     %@AB@%/* Dont clear queue */%@AE@%%@NL@%
                SpyInstallHook(hab, hmqSpy, spyopt.bHooks);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_SENDEXTEND:%@NL@%
            spyopt.fSendExtend ^= 1;  %@AB@%/* Toggle on or off */%@AE@%%@NL@%
            WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                MM_SETITEMATTR, MPFROM2SHORT(CMD_SENDEXTEND, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED,%@NL@%
                     spyopt.fSendExtend ? MIA_CHECKED : 0));%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_SENDSTACK:%@NL@%
            spyopt.fSendStack ^= 1;  %@AB@%/* Toggle on or off */%@AE@%%@NL@%
            WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                MM_SETITEMATTR, MPFROM2SHORT(CMD_SENDSTACK, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED,%@NL@%
                    spyopt.fSendStack ? MIA_CHECKED : 0));%@NL@%
            break;%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * The commands in this section are defined in the Outputs Menu.%@NL@%
%@AB@%         * The first 3 items simply toggle outputs on or off, where the%@NL@%
%@AB@%         * last item allows the user to change all of the output options.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        case CMD_OUTSCREEN:%@NL@%
            spyopt.fWindow ^= 1;  %@AB@%/* Toggle on or off */%@AE@%%@NL@%
            WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                MM_SETITEMATTR, MPFROM2SHORT(CMD_OUTSCREEN, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, spyopt.fWindow ? MIA_CHECKED : 0));%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_OUTFILE:%@NL@%
            spyopt.fFile ^= 1;  %@AB@%/* Toggle on or off */%@AE@%%@NL@%
            WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
                MM_SETITEMATTR, MPFROM2SHORT(CMD_OUTFILE, TRUE),%@NL@%
                MPFROM2SHORT(MIA_CHECKED, spyopt.fFile ? MIA_CHECKED : 0));%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Open or close the output file%@NL@%
%@AB@%             */%@AE@%%@NL@%
            if (spyopt.fFile) {%@NL@%
                 if (spyopt.hfileSpy == NULL)%@NL@%
                    if (DosOpen((PSZ)spystr.szFileName, &spyopt.hfileSpy,%@NL@%
                            (USHORT far *)&wAction, 0L, 0,%@NL@%
                            0x0012, 0x00C1, 0L) != 0)%@NL@%
                        spyopt.hfileSpy = NULL; %@AB@%/* Failed on open */%@AE@%%@NL@%
            } else {%@NL@%
                if (spyopt.hfileSpy != NULL) {%@NL@%
                    %@AB@%/* file open, not outputing, close it now */%@AE@%%@NL@%
                    DosClose (spyopt.hfileSpy);%@NL@%
                    spyopt.hfileSpy = NULL;%@NL@%
                }%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_OUTPUTS:%@NL@%
            SpyHookOnOrOff (FALSE);%@NL@%
            WinDlgBox(HWND_DESKTOP, hwndSpyFrame,%@NL@%
                (PFNWP)SpyOutputsDlgProc, (HMODULE)NULL,%@NL@%
                OutputsDlg, (PCH)NULL);%@NL@%
            SpyHookOnOrOff (fSpyActive);%@NL@%
            break;%@NL@%
%@NL@%
        case CMD_MGDABLE:%@NL@%
        case CMD_MGEABLE:%@NL@%
            EnableOrDisableMsg(SHORT1FROMMP(mp1) == CMD_MGEABLE);%@NL@%
            break;%@NL@%
        }%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    case WM_SIZE:%@NL@%
        %@AB@%/* We need to resize the listbox, if it exists */%@AE@%%@NL@%
        if (hwndSpyList != NULL) {%@NL@%
            WinSetWindowPos(hwndSpyList, HWND_TOP, -cxBorder, -cyBorder,%@NL@%
                SHORT1FROMMP(mp2) + 2 * cxBorder,%@NL@%
                SHORT2FROMMP(mp2) + 2 * cyBorder, SWP_MOVE | SWP_SIZE);%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* Now fall through to process the message */%@AE@%%@NL@%
    default:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* USHORT UConvertStringToNum(psz)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Converts the passed string to a number 0xffff if not number%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
USHORT  UConvertStringToNum(psz)%@NL@%
register char   *psz;%@NL@%
{%@NL@%
    register USHORT uNum;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If the first few chars are 0x, we assume the user typed in a%@NL@%
%@AB@%     * HEX number, else if 0-9, we assume decimal, else we use the string.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    %@AB@%/* First see if digit in first position */%@AE@%%@NL@%
    if ((*psz >= '0') && (*psz <= '9')) {%@NL@%
        %@AB@%/* Assume numbers now */%@AE@%%@NL@%
        if ((*psz == '0') && (*(psz+1) == 'x')) {%@NL@%
%@NL@%
            %@AB@%/* We are in hex mode */%@AE@%%@NL@%
            psz += 2;%@NL@%
            uNum = 0;%@NL@%
            for (;;) {%@NL@%
                if ((*psz >= '0') && (*psz <= '9'))%@NL@%
                    uNum = uNum * 16 + (USHORT)(*psz - '0');%@NL@%
                else if ((*psz >= 'a') && (*psz <= 'f'))%@NL@%
                    uNum = uNum * 16 + (USHORT)(*psz - 'a');%@NL@%
                else if ((*psz >= 'F') && (*psz <= 'F'))%@NL@%
                    uNum = uNum * 16 + (USHORT)(*psz - 'A');%@NL@%
                else%@NL@%
                    break;%@NL@%
                psz++;%@NL@%
            }%@NL@%
%@NL@%
        } else {%@NL@%
            %@AB@%/* Decimal mode */%@AE@%%@NL@%
            uNum = (USHORT)(*psz++ - '0');%@NL@%
            while ((*psz >= '0') && (*psz <= '9')) {%@NL@%
                uNum = uNum * 10 + (USHORT)(*psz++ - '0');%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
        return (uNum);%@NL@%
    } else%@NL@%
        %@AB@%/* Not num, return 0xffff */%@AE@%%@NL@%
        return (0xffff);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* void ProcHookThread()%@NL@%
%@AB@%*%@NL@%
%@AB@%*   This function will wait for the hook to have messages,  when it%@NL@%
%@AB@%*   does, it will set a memory semaphore, post a WM_SEM1 message to the other%@NL@%
%@AB@%*   thread, and wait for the other thread has processed all of the messages.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
void FAR ProcHookThread()%@NL@%
{%@NL@%
    while (TRUE) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Wait for a message to become available.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (!SpyGetNextMessage(NULL, NULL, 0, -1L))%@NL@%
            break;%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Now we have a message, set our semaphore, Post a WM_SEM2%@NL@%
%@AB@%         * message to the Client window, and wait for the client to%@NL@%
%@AB@%         * clear the semaphore.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        DosSemSet((HSEM)(PULONG)&semThread);%@NL@%
        WinPostMsg(hwndSpy, WM_SEM2, (MPARAM)1, (MPARAM)1);%@NL@%
        DosSemWait((HSEM)(PULONG)&semThread, -1L);%@NL@%
    }%@NL@%
%@NL@%
    DosExit(EXIT_THREAD, 0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* void ProcessQueueMsg(pqmsg)%@NL@%
%@AB@%*%@NL@%
%@AB@%*   This function will process the hook, by calling the hooks which get%@NL@%
%@AB@%*   messages.  We will than post the message to the current output destinations.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
void ProcessQueueMsg(pqmsgspy)%@NL@%
    QMSGSPY    *pqmsgspy;%@NL@%
{%@NL@%
    MSGI    *pmsgi;%@NL@%
    SHORT   item;%@NL@%
    CHAR    cSource;%@NL@%
    CHAR    cThread;%@NL@%
    char    szNextMessage[100];%@NL@%
    char    szTime[12];%@NL@%
    SHORT   cch;%@NL@%
    CHAR    bAscii;%@NL@%
    PSZ     prgData;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now let's build the message to output%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (WinIsWindow(hab, pqmsgspy->qmsg.hwnd)) {%@NL@%
        if (WinIsChild(pqmsgspy->qmsg.hwnd, hwndSpy))%@NL@%
            return;     %@AB@%/* don't want endless loops */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    cThread = ':';%@NL@%
    if (pqmsgspy->qmsg.time == (ULONG)-1) {%@NL@%
        %@AB@%/* Sent message */%@AE@%%@NL@%
        szTime[0] = '\0';%@NL@%
        cSource = 'S';%@NL@%
        if (pqmsgspy->fs)%@NL@%
            cThread = '*';%@NL@%
    } else {%@NL@%
        cSource = 'I';%@NL@%
        if (pqmsgspy->fs != PM_REMOVE)%@NL@%
            cThread = '-';  %@AB@%/* Show different for non-remove */%@AE@%%@NL@%
%@NL@%
        sprintf (szTime, "%-08lx", pqmsgspy->qmsg.time);%@NL@%
    }%@NL@%
%@NL@%
    if ((pmsgi = PmsgiFromMsg(pqmsgspy->qmsg.msg)) == NULL) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Message not in list, use default%@NL@%
%@AB@%         */%@AE@%%@NL@%
        cch = sprintf(szNextMessage,%@NL@%
            "%c%cMSG:0x%04x            H:%04x 1:%08lx 2:%08lx T:%s",%@NL@%
            cSource, cThread, (SHORT)pqmsgspy->qmsg.msg, (SHORT)(ULONG)pqmsgspy->qmsg.hwnd,%@NL@%
            pqmsgspy->qmsg.mp1, pqmsgspy->qmsg.mp2, szTime);%@NL@%
    } else if (pmsgi->wOptions & MSGI_MOUSE) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Mouse message, decode to mouse types%@NL@%
%@AB@%         */%@AE@%%@NL@%
        cch = sprintf(szNextMessage,%@NL@%
            "%c%c%-20s H:%04x X:%-4d Y:%-4d HT:%04x T:%s",%@NL@%
            cSource, cThread, pmsgi->szMsg, (SHORT)(LONG)pqmsgspy->qmsg.hwnd,%@NL@%
            SHORT1FROMMP(pqmsgspy->qmsg.mp1), SHORT2FROMMP(pqmsgspy->qmsg.mp1),%@NL@%
            SHORT1FROMMP(pqmsgspy->qmsg.mp2), szTime);%@NL@%
    } else if (pmsgi->wOptions & MSGI_KEY) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Key messages, output special%@NL@%
%@AB@%         */%@AE@%%@NL@%
        bAscii = (CHAR)SHORT1FROMMP(pqmsgspy->qmsg.mp2);%@NL@%
        if ((bAscii < ' ') || (bAscii > '~'))%@NL@%
            bAscii = ' ';%@NL@%
%@NL@%
        cch = sprintf(szNextMessage,%@NL@%
            "%c%c%-20s H:%04x F:%04x R:%d S:%2x C:%04x(%c) V:%02x T:%s",%@NL@%
            cSource, cThread, pmsgi->szMsg, (SHORT)(LONG)pqmsgspy->qmsg.hwnd,%@NL@%
            SHORT1FROMMP(pqmsgspy->qmsg.mp1),%@NL@%
            CHAR3FROMMP(pqmsgspy->qmsg.mp1),  CHAR4FROMMP(pqmsgspy->qmsg.mp1),%@NL@%
            SHORT1FROMMP(pqmsgspy->qmsg.mp2), bAscii,%@NL@%
            SHORT2FROMMP(pqmsgspy->qmsg.mp2), szTime);%@NL@%
    } else {%@NL@%
        %@AB@%/* No special format */%@AE@%%@NL@%
        cch = sprintf(szNextMessage,%@NL@%
            "%c%c%-20s H:%04x 1:%08lx 2:%08lx T:%s",%@NL@%
            cSource, cThread, pmsgi->szMsg, (SHORT)(ULONG) pqmsgspy->qmsg.hwnd,%@NL@%
            pqmsgspy->qmsg.mp1, pqmsgspy->qmsg.mp2, szTime);%@NL@%
    }%@NL@%
%@NL@%
    OutputString(szNextMessage, cch);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now dump out any additional information associated with the%@NL@%
%@AB@%     * message.  The processing depends of the type of message on%@NL@%
%@AB@%     * how we are going to process the data.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (spyopt.fSendExtend) {%@NL@%
        prgData = DumpParam((PSZ)rgMsgData, pqmsgspy->qmsg.mp1,%@NL@%
                pqmsgspy->cbDataMP1, pqmsgspy->bMPType);%@NL@%
        DumpParam(prgData, pqmsgspy->qmsg.mp2, pqmsgspy->cbDataMP2,%@NL@%
                (UCHAR)((pqmsgspy->bMPType) >> 3));%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If this is a send message, also display the call stack information%@NL@%
%@AB@%     * of who called WinSendMsg%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (spyopt.fSendStack && (pqmsgspy->qmsg.time == (ULONG)-1)) {%@NL@%
        cch = sprintf(szNextMessage,%@NL@%
            "    PID: %-3d TID: %-2d   Stack:",%@NL@%
            pqmsgspy->pidSend, pqmsgspy->tidSend);%@NL@%
%@NL@%
        %@AB@%/* Now loop and add the stack info */%@AE@%%@NL@%
        for (item=0; (item < MAXSTRACE) &&%@NL@%
                (pqmsgspy->pvoidStack[item] != NULL); item++) {%@NL@%
            cch += sprintf(szTime, " %p", pqmsgspy->pvoidStack[item]);%@NL@%
            strcat(szNextMessage, szTime);%@NL@%
        }%@NL@%
%@NL@%
        OutputString(szNextMessage, cch);%@NL@%
    }%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* PSZ DumpParam(PSZ prgData, MPARAM mp, SHORT cb, UCHAR bMPType)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Dump the additional information that was captured for the message.%@NL@%
%@AB@%*   using the currently defined types.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns: PSZ - Pointer to next available byte after process DATA%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
PSZ DumpParam(prgData, mp, cb, bMPType)%@NL@%
PSZ         prgData;%@NL@%
MPARAM      mp;%@NL@%
SHORT       cb;%@NL@%
UCHAR       bMPType;%@NL@%
{%@NL@%
    char    szNextMessage[100];%@NL@%
    SHORT   cch;%@NL@%
%@NL@%
%@NL@%
    if (FGuessValidPointer((PSZ)mp, cb)) {%@NL@%
        %@AB@%/* Process by type */%@AE@%%@NL@%
        switch (bMPType & 0x07) {%@NL@%
        case MPT_SWP:%@NL@%
            cch = sprintf(szNextMessage,%@NL@%
                "    SWP:               fs:%04x cx:%d cy:%d y:%d x:%d HB:%04x H:%04x",%@NL@%
                ((PSWP)prgData)->fs, ((PSWP)prgData)->cy, ((PSWP)prgData)->cx,%@NL@%
                ((PSWP)prgData)->y, ((PSWP)prgData)->x,%@NL@%
                (SHORT)(ULONG)((PSWP)prgData)->hwndInsertBehind,%@NL@%
                (SHORT)(ULONG)((PSWP)prgData)->hwnd);%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
        case MPT_RECTL:%@NL@%
            cch = sprintf(szNextMessage,%@NL@%
                "    RECTL:             xLeft:%d yBottom:%d xRight:%d yTop:%d",%@NL@%
                ((PRECTL)prgData)->xLeft, ((PRECTL)prgData)->yBottom,%@NL@%
                ((PRECTL)prgData)->xRight, ((PRECTL)prgData)->yTop);%@NL@%
            break;%@NL@%
%@NL@%
        case MPT_QMSG:%@NL@%
            cch = sprintf(szNextMessage,%@NL@%
                "    QMSG: H:%04x       M:%04x M1:%08lx M2:%08lx T:%08lx (%d, %d)",%@NL@%
                (SHORT)(ULONG)((PQMSG)prgData)->hwnd, ((PQMSG)prgData)->msg,%@NL@%
                ((PQMSG)prgData)->mp1,((PQMSG)prgData)->mp2,%@NL@%
                ((PQMSG)prgData)->time,%@NL@%
                ((PQMSG)prgData)->ptl.x, ((PQMSG)prgData)->ptl.y);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            goto NoData;%@NL@%
        }%@NL@%
%@NL@%
        OutputString(szNextMessage, cch);%@NL@%
    }%@NL@%
NoData:%@NL@%
    return (prgData + cb);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* void OutputString(char szOut, SHORT cch);%@NL@%
%@AB@%*%@NL@%
%@AB@%*   This function will output the specified string to the%@NL@%
%@AB@%*   destinations.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
void OutputString(szOut, cch)%@NL@%
char        szOut[];%@NL@%
SHORT       cch;%@NL@%
{%@NL@%
    SHORT   item;%@NL@%
    char    *psz;%@NL@%
    USHORT  cchWritten;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Now display the new line on the screen */%@AE@%%@NL@%
    if (spyopt.fWindow) {%@NL@%
        item = SHORT1FROMMR(WinSendMsg(hwndSpyList, LM_INSERTITEM,%@NL@%
            (MPARAM)LIT_END, (MPARAM)(PSZ)szOut));%@NL@%
%@NL@%
        WinSendMsg(hwndSpyList, LM_SETTOPINDEX, (MPARAM)item, 0L);%@NL@%
%@NL@%
        %@AB@%/* See if we have too many lines now */%@AE@%%@NL@%
        while (item >= spyopt.cWindowLines)%@NL@%
            item = SHORT1FROMMR(WinSendMsg(hwndSpyList, LM_DELETEITEM,%@NL@%
                    (MPARAM)0, 0L));%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* now for file need cr/lf */%@AE@%%@NL@%
    psz = szOut + cch;    %@AB@%/* point to trailing null */%@AE@%%@NL@%
    *psz++ = '\r';%@NL@%
    *psz++ = '\n';%@NL@%
    *psz = '\0';%@NL@%
%@NL@%
    if (spyopt.fFile)%@NL@%
        DosWrite(spyopt.hfileSpy, (PSZ)szOut, cch+2,%@NL@%
                (PUSHORT)&cchWritten);%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* MSGI  * PmsgiFromMsg(USHORT msg)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Locate the msg in the array of message items%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns: pointer to item that has the specified msg, or NULL%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MSGI *PmsgiFromMsg(msg)%@NL@%
USHORT msg;%@NL@%
{%@NL@%
    register MSGI   *pmsgi = rgmsgi;    %@AB@%/* Start at beginning */%@AE@%%@NL@%
    register SHORT i;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Currently is a simple linear search, should be made faster%@NL@%
%@AB@%     * probably by using binary search.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    for (i=0; i< cmsgi; i++) {%@NL@%
        if (pmsgi->msg == msg)%@NL@%
            return (pmsgi);%@NL@%
        if (pmsgi->msg > msg)%@NL@%
            return (NULL);%@NL@%
        pmsgi++;%@NL@%
    };%@NL@%
%@NL@%
    return (NULL);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SPYHOOK.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SPY\SPYHOOK.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* spyhook.c - Spy global input hook interface library%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*%@NL@%
%@AB@%* This dynlink is needed because global input hooks must reside in a DLL.%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%       INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%       INCL_WINHOOKS %@NL@%
%@AI@%#define %@AE@%       INCL_WINWINDOWMGR %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"spyhook.h" %@NL@%
%@NL@%
ULONG spyhookSem = 0L;          %@AB@%/* global semaphore for this module */%@AE@%%@NL@%
HMODULE hmodSpy;                %@AB@%/* dynlink module handle            */%@AE@%%@NL@%
SHORT    SpybHooks;             %@AB@%/* Which hook do we use?            */%@AE@%%@NL@%
%@NL@%
HAB habOwner = (HAB)0;          %@AB@%/* Hook owner's anchor block        */%@AE@%%@NL@%
HMQ hmqOwner = (HMQ)0;          %@AB@%/* Hook owner's message queue       */%@AE@%%@NL@%
BOOL fRecording = FALSE;        %@AB@%/* Are we recording now?            */%@AE@%%@NL@%
BOOL fAnythingToWatch = FALSE;  %@AB@%/* Is there anything to watch?      */%@AE@%%@NL@%
BOOL fDispMsgsNotInList = TRUE; %@AB@%/* Disp msgs not in list?           */%@AE@%%@NL@%
%@NL@%
%@AB@%/* Define array of window handles that we are going to process */%@AE@%%@NL@%
BOOL fProcessAllFrames = FALSE; %@AB@%/* Are we processing all frame messages?*/%@AE@%%@NL@%
BOOL fProcessAllWindows = FALSE;%@AB@%/* Are we processing all windows?*/%@AE@%%@NL@%
HWND *pahwndSpy = NULL;         %@AB@%/* Array of hwnds to spy on, no max here */%@AE@%%@NL@%
int  chwndSpy = 0;                  %@AB@%/* Max windows to spy */%@AE@%%@NL@%
%@NL@%
%@AB@%/* Define array of HMQ's to spy on */%@AE@%%@NL@%
HMQ *pahmqSpy = NULL;           %@AB@%/* HMQ list to spy on */%@AE@%%@NL@%
int chmqSpy = 0;                %@AB@%/* Count of hmqs we are spying on */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Define message filter array */%@AE@%%@NL@%
UCHAR rgMessageFilter[MAXMSGFILTERBYTES] = "";%@NL@%
UCHAR  GMsgEnableAndType(USHORT);       %@AB@%/* Is message in message list?*/%@AE@%%@NL@%
VOID   GrabMsgDataWords(SHORT, UCHAR);  %@AB@%/* Get extra words for message */%@AE@%%@NL@%
VOID   CopyStruct(UCHAR FAR *pbSrc, UCHAR FAR *pbDst, SHORT cb);%@AB@%/* Copy bytes */%@AE@%%@NL@%
%@NL@%
%@AB@%/* Define an array of messages to pass to whomever calls us */%@AE@%%@NL@%
ULONG spyMsgSem =  0L;          %@AB@%/* global semaphore for this module */%@AE@%%@NL@%
%@NL@%
QMSGSPY  rgqmsgSpy[MAXMSGCNT];  %@AB@%/* Array of messages to process */%@AE@%%@NL@%
SHORT cmsgSpy = 0;              %@AB@%/* Count of messages yet to be read */%@AE@%%@NL@%
SHORT imsgWrite = 0;            %@AB@%/* Index to message to write out */%@AE@%%@NL@%
SHORT imsgRead = 0;             %@AB@%/* Index to message to read */%@AE@%%@NL@%
%@NL@%
HHEAP hheapSpyHook;             %@AB@%/* Heap for SpyHook DLL */%@AE@%%@NL@%
SHORT acbMPTypes[MP_MASK+1] = { %@AB@%/* Number of desired bytes to extract */%@AE@%%@NL@%
    0,                          %@AB@%/* Normal fields, no pointers */%@AE@%%@NL@%
    sizeof(SWP),                %@AB@%/* MPT_SWP */%@AE@%%@NL@%
    sizeof(RECTL),              %@AB@%/* MPT_RECTL */%@AE@%%@NL@%
    0,                          %@AB@%/* MPT_WNDPRMS we don't process yet */%@AE@%%@NL@%
    sizeof(QMSG)                %@AB@%/* MPT_QMSG */%@AE@%%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Information for getting selector information in different PID context */%@AE@%%@NL@%
PID     pidLNSpy = 0xffff;      %@AB@%/* Which process */%@AE@%%@NL@%
USHORT  selectorLNSpy = 0;      %@AB@%/* Which Selector */%@AE@%%@NL@%
WHOISINFO   whoIsLNSpy;         %@AB@%/* Symbol information */%@AE@%%@NL@%
int     rcLNSpy = -1;           %@AB@%/* Return code */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Define all external functions */%@AE@%%@NL@%
extern VOID  BuildStackTrace(CHAR FAR *, SHORT, SHORT);%@NL@%
%@NL@%
%@AB@%/* Define all function prototypes */%@AE@%%@NL@%
VOID SpyCheckPIDForSymbol(VOID);%@NL@%
BOOL FAR PASCAL SpyInputHook(HAB, PQMSG, USHORT);%@NL@%
BOOL FAR PASCAL SpySendMsgHook(HAB, PSMHSTRUCT, USHORT);%@NL@%
VOID PASCAL Init(HMODULE);%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpyInputHook( hab, lpqmsg, fs )%@NL@%
%@AB@%* HAB hab;%@NL@%
%@AB@%* PQMSG  lpqmsg;%@NL@%
%@AB@%* USHORT    fs;%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  This is the global input hook procedure.  Note that hook%@NL@%
%@AB@%*   procedures can be chained, so we always return FALSE to pass the%@NL@%
%@AB@%*   message to the next guy in the chain.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Return value:  FALSE to pass message to next hook procedure.%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpyInputHook( hab, lpqmsg, fs )%@NL@%
HAB        hab;%@NL@%
PQMSG        lpqmsg;%@NL@%
USHORT  fs;%@NL@%
{%@NL@%
    UCHAR       bMPType;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Check first to see if we are looking for a process's symbols%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pidLNSpy != 0xffff)%@NL@%
        SpyCheckPIDForSymbol();%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * First check to see if we are processing any hook messages%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!fRecording || !fAnythingToWatch || (cmsgSpy >= MAXMSGCNT))%@NL@%
        return (FALSE); %@AB@%/* No, let the next one have it now */%@AE@%%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * See if we have any messages to process - re-check to make sure we%@NL@%
%@AB@%     * don't overwrite our queue.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (DosSemRequest((HSEM)(PULONG)&spyhookSem, 100L) != 0)%@NL@%
        return (FALSE);%@NL@%
    if (cmsgSpy < MAXMSGCNT) {%@NL@%
        if (SpyFWindowInList(lpqmsg->hwnd, FALSE) &&%@NL@%
                (bMPType = GMsgEnableAndType(lpqmsg->msg))) {%@NL@%
            rgqmsgSpy[imsgWrite].fs = fs;       %@AB@%/* Save the flags */%@AE@%%@NL@%
            rgqmsgSpy[imsgWrite].qmsg = *lpqmsg;   %@AB@%/* Save the message */%@AE@%%@NL@%
%@NL@%
            GrabMsgDataWords(imsgWrite, bMPType);%@NL@%
            imsgWrite++;%@NL@%
%@NL@%
            if (imsgWrite == MAXMSGCNT)%@NL@%
                imsgWrite = 0;  %@AB@%/* Wrap around */%@AE@%%@NL@%
            cmsgSpy++;%@NL@%
            DosSemClear((HSEM)(PULONG)&spyMsgSem);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    DosSemClear( (HSEM)(PULONG)&spyhookSem );%@NL@%
    return FALSE;   %@AB@%/* Let system take normal action */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpySendMsgHook( hab, lpsmh, fInterTask )%@NL@%
%@AB@%* HAB                hab;%@NL@%
%@AB@%* PSMHSTRUCT        lpsmh;%@NL@%
%@AB@%* BOOL                fInterTask;%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  This is the global input hook procedure.  Note that hook%@NL@%
%@AB@%*   procedures can be chained, so we always return FALSE to pass the%@NL@%
%@AB@%*   message to the next guy in the chain.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Return value:  FALSE to pass message to next hook procedure.%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpySendMsgHook( hab, lpsmh, fInterTask )%@NL@%
HAB                hab;%@NL@%
PSMHSTRUCT      lpsmh;%@NL@%
BOOL            fInterTask;%@NL@%
{%@NL@%
    UCHAR           bMPType;%@NL@%
    PIDINFO         pidinfo;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Check first to see if we are looking for a process's symbols%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pidLNSpy != 0xffff)%@NL@%
        SpyCheckPIDForSymbol();%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * First check to see if we are processing any hook messages%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (!fRecording || !fAnythingToWatch || (cmsgSpy >= MAXMSGCNT))%@NL@%
        return (FALSE); %@AB@%/* No, let the next one have it now */%@AE@%%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * See if we have any messages to process%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (DosSemRequest((HSEM)(PULONG)&spyhookSem, 100L) != 0)%@NL@%
        return (FALSE);%@NL@%
    %@AB@%/* Make sure no one got in by mistake */%@AE@%%@NL@%
    if (cmsgSpy < MAXMSGCNT) {%@NL@%
        if (SpyFWindowInList(lpsmh->hwnd, FALSE) &&%@NL@%
                (bMPType = GMsgEnableAndType(lpsmh->msg))) {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Store out message, must move pieces separately%@NL@%
%@AB@%             */%@AE@%%@NL@%
            rgqmsgSpy[imsgWrite].fs = fInterTask;%@NL@%
            rgqmsgSpy[imsgWrite].qmsg.hwnd = lpsmh->hwnd;%@NL@%
            rgqmsgSpy[imsgWrite].qmsg.msg  = lpsmh->msg;%@NL@%
            rgqmsgSpy[imsgWrite].qmsg.mp1  = lpsmh->mp1;%@NL@%
            rgqmsgSpy[imsgWrite].qmsg.mp2  = lpsmh->mp2;%@NL@%
            rgqmsgSpy[imsgWrite].qmsg.time = (ULONG)-1;%@NL@%
            rgqmsgSpy[imsgWrite].qmsg.ptl.x  = 0;%@NL@%
            rgqmsgSpy[imsgWrite].qmsg.ptl.y  = 0;%@NL@%
%@NL@%
            GrabMsgDataWords(imsgWrite, bMPType);%@NL@%
%@NL@%
            %@AB@%/* Now get the PID/TID info, and do the stack backtrace */%@AE@%%@NL@%
            DosGetPID(&pidinfo);%@NL@%
            rgqmsgSpy[imsgWrite].pidSend = pidinfo.pid;%@NL@%
            rgqmsgSpy[imsgWrite].tidSend = pidinfo.tid;%@NL@%
            BuildStackTrace((CHAR FAR *)rgqmsgSpy[imsgWrite].pvoidStack,%@NL@%
                    CALLSTOSKIP, MAXSTRACE);%@NL@%
%@NL@%
            imsgWrite++;%@NL@%
            if (imsgWrite == MAXMSGCNT)%@NL@%
                imsgWrite = 0;  %@AB@%/* Wrap around */%@AE@%%@NL@%
            cmsgSpy++;%@NL@%
            DosSemClear((HSEM)(PULONG)&spyMsgSem);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    DosSemClear( (HSEM)(PULONG)&spyhookSem );%@NL@%
    return FALSE;   %@AB@%/* Let system take normal action */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpyInstallHook( hab, hmq, fSendMessage, bHooks)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  This routine installs a system-wide HK_INPUT hook.  The hab%@NL@%
%@AB@%*   hmq are remembered for message posting.  Note that we only allow%@NL@%
%@AB@%*   one input hook to be installed through this routine, but other%@NL@%
%@AB@%*   apps may call WinSetHook directly.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns value:  TRUE if hook installed successfully, FALSE otherwise.%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpyInstallHook( hab, hmq, bHooks )%@NL@%
HAB     hab;%@NL@%
HMQ     hmq;%@NL@%
USHORT  bHooks;%@NL@%
{%@NL@%
    BOOL fRet;%@NL@%
    SEL  selHeap;%@NL@%
%@NL@%
    DosSemRequest( (HSEM)(PULONG)&spyhookSem, -1L);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If this is the first time through, we need to create a local heap%@NL@%
%@AB@%     * to store message information.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (hheapSpyHook == NULL) {%@NL@%
        selHeap = (SEL)(((ULONG)((PSZ)&hheapSpyHook)) >> 16);%@NL@%
        hheapSpyHook = WinCreateHeap(selHeap, 1024, 0, 0, 100,%@NL@%
            HM_MOVEABLE | HM_VALIDSIZE);%@NL@%
        if (hheapSpyHook == NULL)%@NL@%
            return (FALSE);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Look at hook index.%@NL@%
%@AB@%     *%@NL@%
%@AB@%     * if it equals  HK_INPUT then%@NL@%
%@AB@%     *                install a system-wide input hook%@NL@%
%@AB@%     * else%@NL@%
%@AB@%     *                set system wide SENDMSG hook%@NL@%
%@AB@%     */%@AE@%%@NL@%
    SpybHooks = bHooks;%@NL@%
    if (SpybHooks & SPYH_INPUT)%@NL@%
        fRet = WinSetHook( hab, (HMQ)0, HK_INPUT, (PFN)SpyInputHook,%@NL@%
                    hmodSpy );%@NL@%
%@NL@%
    if (SpybHooks & SPYH_SENDMSG)%@NL@%
        fRet = WinSetHook( hab, (HMQ)0, HK_SENDMSG, (PFN)SpySendMsgHook,%@NL@%
                    hmodSpy );%@NL@%
    if (fRet) {%@NL@%
        habOwner = hab;%@NL@%
        hmqOwner = hmq;%@NL@%
    }%@NL@%
%@NL@%
    DosSemSet((HSEM)(PULONG)&spyMsgSem);    %@AB@%/* Init, no messages avail */%@AE@%%@NL@%
    DosSemClear( (HSEM)(PULONG)&spyhookSem );%@NL@%
%@NL@%
    return fRet;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpySetWindowList( chwnd, rghwnd)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  This routine sets the list of window that we are interested%@NL@%
%@AB@%*   in watching the messages for.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns value:  TRUE%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpySetWindowList( chwnd, rghwnd )%@NL@%
SHORT       chwnd;%@NL@%
HWND FAR    *rghwnd;%@NL@%
{%@NL@%
    SHORT   i;%@NL@%
    HWND    *phwndT;%@NL@%
%@NL@%
    DosSemRequest( (HSEM)(PULONG)&spyhookSem, -1L);%@NL@%
%@NL@%
    if (pahwndSpy) {%@NL@%
        WinFreeMem(hheapSpyHook, (char *)pahwndSpy, sizeof(HWND) * chwndSpy);%@NL@%
        pahwndSpy = NULL;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    chwndSpy = chwnd;%@NL@%
%@NL@%
    if (chwndSpy > 0 ) {%@NL@%
%@NL@%
        phwndT = pahwndSpy = (HWND *) WinAllocMem(hheapSpyHook,%@NL@%
                sizeof(HWND) * chwndSpy);%@NL@%
%@NL@%
        if (phwndT != NULL) {%@NL@%
            for (i=0; i < chwnd; i++) {%@NL@%
                *phwndT++ = *rghwnd++;%@NL@%
            }%@NL@%
        } else%@NL@%
            chwndSpy = 0;%@NL@%
    }%@NL@%
%@NL@%
    fAnythingToWatch = (chwndSpy > 0) || (chmqSpy > 0) ||%@NL@%
            fProcessAllWindows || fProcessAllFrames;%@NL@%
%@NL@%
    DosSemClear( (HSEM)(PULONG)&spyhookSem );%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpyGetWindowList( chwnd, rghwnd)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  This routine sets the list of window that we are interested%@NL@%
%@AB@%*   in watching the messages for.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns value:  TRUE%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
SHORT FAR PASCAL SpyGetWindowList( chwnd, rghwnd )%@NL@%
SHORT       chwnd;%@NL@%
HWND FAR    *rghwnd;%@NL@%
{%@NL@%
    SHORT   i;%@NL@%
    HWND    *phwndT;%@NL@%
%@NL@%
    DosSemRequest( (HSEM)(PULONG)&spyhookSem, -1L);%@NL@%
%@NL@%
    if (chwnd > chwndSpy)%@NL@%
            chwnd = chwndSpy;%@NL@%
%@NL@%
    phwndT = pahwndSpy;%@NL@%
    for (i=0; i < chwnd; i++) {%@NL@%
        *rghwnd++ = *pahwndSpy++;%@NL@%
    }%@NL@%
%@NL@%
    DosSemClear( (HSEM)(PULONG)&spyhookSem );%@NL@%
%@NL@%
    return(chwnd);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpySetQueueList( chmq, rghmq )%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  This routine sets the list of queues whose messages we watch.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns value:  TRUE%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpySetQueueList( chmq, rghmq )%@NL@%
SHORT       chmq;%@NL@%
HMQ FAR    *rghmq;%@NL@%
{%@NL@%
    SHORT   i;%@NL@%
    HMQ     *phmqT;%@NL@%
%@NL@%
    DosSemRequest( (HSEM)(PULONG)&spyhookSem, -1L);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If we previously had a list of HMQs to spy on, free the old list%@NL@%
%@AB@%     * now%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (pahmqSpy != NULL) {%@NL@%
        WinFreeMem(hheapSpyHook, (char *)pahmqSpy, sizeof(HMQ) * chmqSpy);%@NL@%
        pahmqSpy = NULL;%@NL@%
    }%@NL@%
%@NL@%
    chmqSpy = chmq;%@NL@%
%@NL@%
    if (chmqSpy > 0) {%@NL@%
        phmqT = pahmqSpy = (HWND *) WinAllocMem(hheapSpyHook, sizeof(HMQ) * chmqSpy);%@NL@%
%@NL@%
        if (phmqT != NULL) {%@NL@%
            for (i=0; i < chmq; i++) {%@NL@%
                *phmqT++ = *rghmq++;%@NL@%
            }%@NL@%
        } else%@NL@%
            chmqSpy = 0;%@NL@%
    }%@NL@%
%@NL@%
    fAnythingToWatch = (chwndSpy > 0) || (chmqSpy > 0) ||%@NL@%
            fProcessAllWindows || fProcessAllFrames;%@NL@%
    DosSemClear( (HSEM)(PULONG)&spyhookSem );%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpyGetQueueList( chmq, rghmq )%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  This routine gets the list of queues whose messages we watch.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns value:  TRUE%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
SHORT FAR PASCAL SpyGetQueueList( chmq, rghmq )%@NL@%
SHORT       chmq;%@NL@%
HMQ FAR    *rghmq;%@NL@%
{%@NL@%
    SHORT   i;%@NL@%
    HMQ     *phmqT;%@NL@%
%@NL@%
    DosSemRequest( (HSEM)(PULONG)&spyhookSem, -1L);%@NL@%
%@NL@%
    if (chmq > chmqSpy)%@NL@%
        chmq = chmqSpy;%@NL@%
%@NL@%
    phmqT = pahmqSpy;%@NL@%
%@NL@%
    for (i=0; i < chmq; i++) {%@NL@%
        *rghmq++ = *phmqT++;%@NL@%
    }%@NL@%
%@NL@%
    DosSemClear( (HSEM)(PULONG)&spyhookSem );%@NL@%
%@NL@%
    return(chmq);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpySetMessageList(UCHAR FAR *prgNewMsgFilter,%@NL@%
%@AB@%*                   BOOL fNewDispMsgsNotInList)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  This routine sets the list of windows that whose message we watch.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns value:  TRUE%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpySetMessageList(prgNewMsgFilter, fNewDispMsgsNotInList)%@NL@%
UCHAR FAR           *prgNewMsgFilter;%@NL@%
BOOL                fNewDispMsgsNotInList;%@NL@%
{%@NL@%
    SHORT           i;%@NL@%
    unsigned char   *prgb;%@NL@%
%@NL@%
    DosSemRequest( (HSEM)(PULONG)&spyhookSem, -1L);%@NL@%
%@NL@%
    prgb = rgMessageFilter;%@NL@%
%@NL@%
%@NL@%
    fDispMsgsNotInList = fNewDispMsgsNotInList;%@NL@%
%@NL@%
    for (i=0; i < MAXMSGFILTERBYTES; i++) {%@NL@%
        *prgb++ = *prgNewMsgFilter++;%@NL@%
    }%@NL@%
%@NL@%
    DosSemClear( (HSEM)(PULONG)&spyhookSem );%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpyFWindowInList (hwnd, fInWindowListOnly)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  This function checks our current list of windows, and returns%@NL@%
%@AB@%*          TRUE if the window is in the list, else returns FALSE.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns value:  TRUE if window is in list.  Also, if we are in the special%@NL@%
%@AB@%*           state we will pass through all frame windows.%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpyFWindowInList (hwnd, fInWindowListOnly)%@NL@%
register HWND  hwnd;%@NL@%
BOOL            fInWindowListOnly;%@NL@%
{%@NL@%
    register int    i;%@NL@%
    char            szClassName[10];    %@AB@%/* Class name of window */%@AE@%%@NL@%
    CLASSINFO       classinfo;          %@AB@%/* Information about class */%@AE@%%@NL@%
    HMQ             hmqWindow;          %@AB@%/* HMQ of window        */%@AE@%%@NL@%
    HMQ             *phmqT;             %@AB@%/* Temporary pointer in hmq list */%@AE@%%@NL@%
    HWND            *phwndT;            %@AB@%/* Temporary pointer to HWND list */%@AE@%%@NL@%
%@NL@%
    phwndT = pahwndSpy;%@NL@%
    for (i=0; i < chwndSpy; i++) {%@NL@%
        if (hwnd == *phwndT++)%@NL@%
            return (TRUE);%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* See if we are restricting to only windows in list */%@AE@%%@NL@%
    if (fInWindowListOnly)%@NL@%
        return (FALSE);%@NL@%
%@NL@%
    if (fProcessAllWindows)%@NL@%
        return (TRUE);      %@AB@%/* All windows pass through */%@AE@%%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * See if we are watching any message queues%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (phmqT = pahmqSpy) {%@NL@%
        hmqWindow = (HMQ)WinQueryWindowULong(hwnd, QWL_HMQ);%@NL@%
        for (i=0; i < chmqSpy; i++) {%@NL@%
            if (*phmqT++ == hmqWindow)%@NL@%
                return (TRUE);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (fProcessAllFrames) {%@NL@%
        %@AB@%/* See if frame class */%@AE@%%@NL@%
        if (hwnd == NULL)%@NL@%
            return (TRUE);      %@AB@%/* pass queue messages through */%@AE@%%@NL@%
        WinQueryClassName(hwnd, sizeof(szClassName),%@NL@%
            (PSZ)szClassName);%@NL@%
        WinQueryClassInfo((HAB)NULL, (PSZ)szClassName,%@NL@%
            &classinfo);%@NL@%
        if (classinfo.flClassStyle & CS_FRAME)%@NL@%
            return (TRUE);%@NL@%
    }%@NL@%
%@NL@%
    return (FALSE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpyReleaseHook(fZeroQueue)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  This routine releases the input hook, if it is installed.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns value: TRUE if hook is released, FALSE otherwise.%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpyReleaseHook(fZeroQueue)%@NL@%
BOOL    fZeroQueue;%@NL@%
{%@NL@%
    BOOL fRet;%@NL@%
%@NL@%
    DosSemRequest ( (HSEM)(PULONG)&spyhookSem, -1L );%@NL@%
%@NL@%
    if ( habOwner ) {%@NL@%
        if (SpybHooks & SPYH_INPUT)%@NL@%
                fRet = WinReleaseHook( habOwner, (HMQ)0, HK_INPUT,%@NL@%
                    (PFN)SpyInputHook, hmodSpy );%@NL@%
%@NL@%
        if (SpybHooks & SPYH_SENDMSG)%@NL@%
                fRet = WinReleaseHook( habOwner, (HMQ)0, HK_SENDMSG,%@NL@%
                    (PFN)SpySendMsgHook, hmodSpy );%@NL@%
            if ( fRet ) {%@NL@%
                habOwner = (HAB)0;%@NL@%
                hmqOwner = (HMQ)0;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * When the hook is freed, we want to clear message count out,%@NL@%
%@AB@%     * make sure any process waiting will abort%@NL@%
%@AB@%     * Only do this if the Zeroqueu flag was passed%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (fZeroQueue) {%@NL@%
        cmsgSpy = 0;%@NL@%
        imsgWrite = 0;%@NL@%
        imsgRead = 0;%@NL@%
        if (pahwndSpy != NULL)%@NL@%
            WinFreeMem(hheapSpyHook, (char *)pahwndSpy,%@NL@%
                    sizeof(HWND) * chwndSpy);%@NL@%
        pahwndSpy = NULL;%@NL@%
        chwndSpy = 0;           %@AB@%/* Max windows to spy */%@AE@%%@NL@%
        fRecording = FALSE;     %@AB@%/* Set recording to off */%@AE@%%@NL@%
        if (pahmqSpy != NULL)%@NL@%
            WinFreeMem(hheapSpyHook, (char *)pahmqSpy, sizeof(HMQ) * chmqSpy);%@NL@%
%@NL@%
        pahmqSpy = NULL;%@NL@%
        chmqSpy = 0;%@NL@%
        fAnythingToWatch = FALSE;%@NL@%
        DosSemClear((HSEM)(PULONG)&spyMsgSem);    %@AB@%/* Free any process */%@AE@%%@NL@%
    }%@NL@%
    DosSemClear((HSEM)(PULONG)&spyhookSem);%@NL@%
%@NL@%
    return fRet;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpyHookOnOrOff( fOn)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  This routine allows the application to turn the hook%@NL@%
%@AB@%*   processing on or off.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns:        TRUE%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpyHookOnOrOff(fOn)%@NL@%
BOOL fOn;%@NL@%
{%@NL@%
    DosSemRequest ( (HSEM)(PULONG)&spyhookSem, -1L);%@NL@%
%@NL@%
    fRecording = fOn;%@NL@%
%@NL@%
    DosSemClear( (HSEM)(PULONG)&spyhookSem );%@NL@%
    return (TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpySetAllFrameOpt(fAllFrames)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  Special state if TRUE will cause the window filter to pass%@NL@%
%@AB@%*       all frame windows through.  This is useful when debugging%@NL@%
%@AB@%*       interactions between frame windows, when the windows are%@NL@%
%@AB@%*       net yet created.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns:        TRUE%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpySetAllFrameOpt(fAllFrames)%@NL@%
BOOL fAllFrames;%@NL@%
{%@NL@%
    fProcessAllFrames = fAllFrames;%@NL@%
    fAnythingToWatch = (chwndSpy > 0) || (chmqSpy > 0) ||%@NL@%
            fProcessAllWindows || fProcessAllFrames;%@NL@%
    return (TRUE);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpySetAllWindowOpt(fAllWindows)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  Special state if TRUE will cause the window filter to pass%@NL@%
%@AB@%*       all windows through.  This is useful when debugging%@NL@%
%@AB@%*       interactions between all of the windows.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns:        TRUE%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpySetAllWindowOpt(fAllWindows)%@NL@%
BOOL fAllWindows;%@NL@%
{%@NL@%
    fProcessAllWindows = fAllWindows;%@NL@%
    fAnythingToWatch = (chwndSpy > 0) || (chmqSpy > 0) ||%@NL@%
            fProcessAllWindows || fProcessAllFrames;%@NL@%
    return (TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* BOOL FAR PASCAL SpySetLNSymbolPID(PID pid, SELECTOR sel);%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  Tell the hook to be on the lookout for a specific PID.%@NL@%
%@AB@%*       If found running in the context of the specified process, we%@NL@%
%@AB@%*       will get the selector information for the specified selector.%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpySetLNSymbolPID(pid, selector)%@NL@%
PID     pid;%@NL@%
USHORT  selector;%@NL@%
{%@NL@%
    if (pidLNSpy == 0xffff) {%@NL@%
        selectorLNSpy = selector;%@NL@%
        rcLNSpy = -1;               %@AB@%/* Assume error for now */%@AE@%%@NL@%
        pidLNSpy = pid;             %@AB@%/* Save PID to look for */%@AE@%%@NL@%
        return (TRUE);%@NL@%
    } else%@NL@%
        return (FALSE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* VOID SpyCheckPIDForSymbol(VOID)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  Only called when we are looking for a symbol%@NL@%
%@AB@%*%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
VOID SpyCheckPIDForSymbol()%@NL@%
{%@NL@%
    PIDINFO         pidinfo;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Get the spy semaphore to serialize access and see if we are the%@NL@%
%@AB@%     * correct PID;%@NL@%
%@AB@%     */%@AE@%%@NL@%
    DosGetPID(&pidinfo);%@NL@%
    if (DosSemRequest((HSEM)(PULONG)&spyhookSem, 100L) != 0)%@NL@%
        return;%@NL@%
%@NL@%
    if (pidinfo.pid == pidLNSpy) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * We are the correct process, so continue to try go get the%@NL@%
%@AB@%         * symbol information.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        pidLNSpy = 0xffff;       %@AB@%/* reset to not enter again */%@AE@%%@NL@%
        rcLNSpy = IdentifyCodeSelector( selectorLNSpy,%@NL@%
            (PWHOISINFO)&whoIsLNSpy);%@NL@%
    }%@NL@%
%@NL@%
    DosSemClear( (HSEM)(PULONG)&spyhookSem );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* int FAR PASCAL SpyGetLNSymbolSelector(pwhoinfo)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  Get the information about the specified selector.%@NL@%
%@AB@%*       If the specified process has not been executed since the%@NL@%
%@AB@%*       function SpySetLNSymbolPID has been called, it will return -1,%@NL@%
%@AB@%*       else it will return what was returned from IdentifyCodeSelector.%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
int FAR PASCAL SpyGetLNSymbolSelector(pwhoIsinfo)%@NL@%
PWHOISINFO    pwhoIsinfo;%@NL@%
{%@NL@%
    *pwhoIsinfo = whoIsLNSpy;%@NL@%
    return (rcLNSpy);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/**********************************************************************\%@NL@%
%@AB@%* VOID GrabMsgDataWords (SHORT imsg, UCHAR bMPType)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  Gets the next message from the list.%@NL@%
%@AB@%*%@NL@%
%@AB@%*        if timeout != 0 on message processing threads, problems may occur.%@NL@%
%@AB@%*        if lpqmsg==NULL, this function acts like a query or wait function.%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
VOID GrabMsgDataWords(imsg, bMPType)%@NL@%
SHORT       imsg;%@NL@%
UCHAR       bMPType;%@NL@%
{%@NL@%
    UCHAR   bMP1Type;%@NL@%
    UCHAR   bMP2Type;%@NL@%
    SHORT   cbMPs;%@NL@%
    SHORT   cbMP1;%@NL@%
    SHORT   cbMP2;%@NL@%
    UCHAR   *rgBuf;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * This function will use the MPType data to know if MP1 and/or MP2%@NL@%
%@AB@%     * are pointers to any known data, that we want to extract off%@NL@%
%@AB@%     * and save for spy to display later%@NL@%
%@AB@%     */%@AE@%%@NL@%
    rgqmsgSpy[imsg].bMPType = bMPType;%@NL@%
    bMP1Type = (UCHAR)(bMPType & MP_MASK);%@NL@%
    cbMPs = cbMP1 = rgqmsgSpy[imsg].cbDataMP1 = acbMPTypes[bMP1Type];%@NL@%
%@NL@%
    bMP2Type = (UCHAR)((bMPType >> 3) & MP_MASK);%@NL@%
    cbMPs += (cbMP2 = rgqmsgSpy[imsg].cbDataMP2 = acbMPTypes[bMP2Type]);%@NL@%
%@NL@%
    if (cbMPs > 0) {%@NL@%
        %@AB@%/* Allocate memory to save the data into */%@AE@%%@NL@%
        rgBuf = rgqmsgSpy[imsg].rgData = WinAllocMem(hheapSpyHook, cbMPs);%@NL@%
%@NL@%
        if (rgBuf != NULL) {%@NL@%
            %@AB@%/* Copy the data down, Note: if count is 0 will NOP */%@AE@%%@NL@%
            if (cbMP1) {%@NL@%
                CopyStruct((CHAR FAR *)rgqmsgSpy[imsg].qmsg.mp1,%@NL@%
                        rgBuf, cbMP1);%@NL@%
                rgBuf += cbMP1;%@NL@%
            }%@NL@%
%@NL@%
            if (cbMP2) {%@NL@%
                CopyStruct((CHAR FAR *)rgqmsgSpy[imsg].qmsg.mp2,%@NL@%
                        rgBuf, cbMP2);%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
    } else {%@NL@%
        rgqmsgSpy[imsg].rgData = NULL;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/**********************************************************************\%@NL@%
%@AB@%* SpyGetNextMessage (lpqmsg, lpBuf, cbBuf, lTimeOut)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:  Get the next message from the list.%@NL@%
%@AB@%*         if timeout != 0 on message processing threads, problems may occur.%@NL@%
%@AB@%*        if lpqmsg==NULL, this function acts like a query or wait function.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns:        Whether SpyGetNextMessage succeeds or not.%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
BOOL FAR PASCAL SpyGetNextMessage(lpqmsg, lpBuf, cbBuf, lTimeOut)%@NL@%
PQMSGSPY   lpqmsg;      %@AB@%/* Pointer where the user wants the message stored */%@AE@%%@NL@%
PSZ        lpBuf;       %@AB@%/* pointer to buffer */%@AE@%%@NL@%
SHORT      cbBuf;       %@AB@%/* size of buffer in bytes */%@AE@%%@NL@%
LONG    lTimeOut;       %@AB@%/* Timeout value */%@AE@%%@NL@%
{%@NL@%
%@NL@%
    SHORT       cbMsg;  %@AB@%/* Count of bytes associated with message */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Quick escape hatch */%@AE@%%@NL@%
    if ((lTimeOut == 0) && (cmsgSpy == 0))%@NL@%
        return (FALSE);     %@AB@%/* Don't Wait */%@AE@%%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now let's possibly wait for a message%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (cmsgSpy == 0) {%@NL@%
        if (DosSemWait((HSEM)(PULONG)&spyMsgSem, lTimeOut) != 0)%@NL@%
            return (FALSE); %@AB@%/* No messages after timeout */%@AE@%%@NL@%
        if (cmsgSpy == 0)%@NL@%
            return (FALSE); %@AB@%/* Still no messages, return condition */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * If the lpqmsg is NULL, the user is simply asking if there is%@NL@%
%@AB@%     * a message and/or waiting for the message, so don't extract%@NL@%
%@AB@%     * the message, but simply return the status.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (lpqmsg != NULL) {%@NL@%
        if (DosSemRequest((HSEM)(PULONG)&spyhookSem, lTimeOut) == 0) {%@NL@%
            *lpqmsg = rgqmsgSpy[imsgRead];   %@AB@%/* Extract the message */%@AE@%%@NL@%
%@NL@%
            cbMsg = rgqmsgSpy[imsgRead].cbDataMP1%@NL@%
                    + rgqmsgSpy[imsgRead].cbDataMP2;%@NL@%
%@NL@%
            if ((cbMsg > 0) && (lpBuf != NULL)) {%@NL@%
                if (cbMsg < cbBuf)%@NL@%
                    cbBuf = cbMsg;  %@AB@%/* Number of bytes to copy */%@AE@%%@NL@%
                CopyStruct(rgqmsgSpy[imsgRead].rgData, lpBuf, cbBuf);%@NL@%
            }%@NL@%
%@NL@%
            if (cbMsg > 0)%@NL@%
                WinFreeMem(hheapSpyHook, rgqmsgSpy[imsgRead].rgData, cbMsg);%@NL@%
%@NL@%
            %@AB@%/* Also give the caller any additional information on message */%@AE@%%@NL@%
%@NL@%
            imsgRead++;%@NL@%
            if (imsgRead == MAXMSGCNT)%@NL@%
                imsgRead = 0;  %@AB@%/* Wrap around */%@AE@%%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Decrement count of messages, if we go to zero, set%@NL@%
%@AB@%             * the semaphore, so that the next read will suspend until%@NL@%
%@AB@%             * the next message%@NL@%
%@AB@%             */%@AE@%%@NL@%
            cmsgSpy--;%@NL@%
            if (cmsgSpy == 0)%@NL@%
                DosSemSet((HSEM)(PULONG)&spyMsgSem);%@NL@%
%@NL@%
            DosSemClear( (HSEM)(PULONG)&spyhookSem );%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    return (TRUE);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* VOID PASCAL Init( hmod )%@NL@%
%@AB@%* %@NL@%
%@AB@%* Effect:        Saves the Spy module handle%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
VOID PASCAL Init( hmod )%@NL@%
HMODULE hmod;%@NL@%
{%@NL@%
    %@AB@%/* Save the module handle */%@AE@%%@NL@%
    hmodSpy = hmod;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***********************************************************************\%@NL@%
%@AB@%* UCHAR GMsgEnableAndType (USHORT msg)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Effect:%@NL@%
%@AB@%*   Should the message be processed?%@NL@%
%@AB@%*%@NL@%
%@AB@%*   If the message is out of range %@NL@%
%@AB@%*        or bit is set in message bitmask then return TRUE;%@NL@%
%@AB@%\***********************************************************************/%@AE@%%@NL@%
UCHAR GMsgEnableAndType(msg)%@NL@%
USHORT  msg;%@NL@%
{%@NL@%
    if (msg > MAXMSGFILTER)%@NL@%
        return ((UCHAR)(fDispMsgsNotInList? MP_ENABLED : 0));%@NL@%
%@NL@%
    return (rgMessageFilter[msg]);   %@AB@%/* One byte per message */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SPYHSTRT.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SPY\SPYHSTRT.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%;  SPYHOOK library initialization routine%@AE@%%@NL@%
%@AB@%;  Created by Microsoft Corporation, 1989%@AE@%%@NL@%
%@NL@%
?WIN=1            %@AB@%; Use Windows prolog/epilog%@AE@%%@NL@%
?PLM=1            %@AB@%; Use PLM calling convention%@AE@%%@NL@%
DOS5=1%@NL@%
.xlist%@NL@%
include cmacros.inc%@NL@%
.list%@NL@%
%@NL@%
%@AB@%; Define some constants to help build stack trace%@AE@%%@NL@%
savedCS = 4%@NL@%
savedIP = 2%@NL@%
savedBP = 0%@NL@%
savedDS = -2%@NL@%
%@NL@%
sBegin        DATA%@NL@%
assumes DS,DATA%@NL@%
public        __acrtused%@NL@%
__acrtused = 1%@NL@%
sEnd        DATA%@NL@%
%@NL@%
sBegin        CODE%@NL@%
assumes cs,CODE%@NL@%
assumes ds,DATA%@NL@%
%@NL@%
EXTRN        Init:NEAR%@NL@%
.286p%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Registers set up by DosLoadModule...%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   SI = heap size%@AE@%%@NL@%
%@AB@%;   DI = module ID%@AE@%%@NL@%
%@AB@%;   DS = library's automatic data segment%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc        LoadProc,<FAR,PUBLIC>%@NL@%
cBegin        LoadProc%@NL@%
%@NL@%
        push di%@NL@%
        call Init              %@AB@%; Init( hmod );%@AE@%%@NL@%
%@NL@%
cEnd        LoadProc%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%; CopyStruct%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; CopyStruct(pbSrc, pbDst, cb)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc        CopyStruct,<NEAR,PUBLIC>,<DS,SI,DI>%@NL@%
ParmD  pbSrc%@NL@%
ParmD  pbDest%@NL@%
ParmW  cb%@NL@%
cBegin%@NL@%
%@NL@%
        mov        cx,cb%@NL@%
        jcxz        lcopydone            %@AB@%; all done if cb == 0%@AE@%%@NL@%
%@NL@%
        mov        bx,seg_pbDest%@NL@%
        lar        ax,bx                    %@AB@%; make sure we have access%@AE@%%@NL@%
        jnz        lcopyDone            %@AB@%; no access%@AE@%%@NL@%
        les        di,pbDest%@NL@%
%@NL@%
        lsl        ax,bx                    %@AB@%; get the segment limit%@AE@%%@NL@%
        mov        bx,di                    %@AB@%; check range%@AE@%%@NL@%
        add        bx,cx                    %@AB@%; ending byte to copy%@AE@%%@NL@%
        jc        lcopyDone            %@AB@%; overflowed%@AE@%%@NL@%
        cmp        ax,bx%@NL@%
        jc        lcopyDone            %@AB@%; no room at destination%@AE@%%@NL@%
%@NL@%
        mov        bx,seg_pbSrc%@NL@%
        lar        ax,bx                    %@AB@%; make sure we have access%@AE@%%@NL@%
        jnz        lcopyDone            %@AB@%; no access%@AE@%%@NL@%
%@NL@%
        lds        si,pbSrc%@NL@%
        lsl        ax,bx                    %@AB@%; get the segment limit%@AE@%%@NL@%
        mov        bx,si                    %@AB@%; check range%@AE@%%@NL@%
        add        bx,cx                    %@AB@%; ending byte to copy%@AE@%%@NL@%
        jc        lcopyDone            %@AB@%; overflowed%@AE@%%@NL@%
        cmp        ax,bx%@NL@%
        jc        lcopyDone            %@AB@%; Source is not big enough%@AE@%%@NL@%
%@NL@%
        cmp        si,di%@NL@%
        jae        lcopyok%@NL@%
        mov        ax,cx%@NL@%
        dec        ax%@NL@%
        add        si,ax%@NL@%
        add        di,ax%@NL@%
        std%@NL@%
        rep        movsb%@NL@%
        cld%@NL@%
        jmp        short lcopydone%@NL@%
lcopyok:%@NL@%
        cld%@NL@%
        rep        movsb%@NL@%
lcopydone:%@NL@%
cEnd%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
cProc        BuildStackTrace,<NEAR,PUBLIC>,<SI,DI>%@NL@%
ParmD        pStackSave%@NL@%
ParmW        cCallsIgnore%@NL@%
ParmW        cCallsSave%@NL@%
%@NL@%
cBegin%@NL@%
        les        di,pStackSave                %@AB@%; where to save away stack info%@AE@%%@NL@%
        mov        bx,bp%@NL@%
        mov        dx,ss%@NL@%
        lsl        dx,dx%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; First we need to ignore the defined number of entries%@AE@%%@NL@%
        mov        cx,cCallsIgnore%@NL@%
        jcxz        SaveLoop                %@AB@%; Dont ignore any?%@AE@%%@NL@%
NextBPToIgnore:%@NL@%
        and        bx,0FFFEh                %@AB@%; Flush any INC BP bit%@AE@%%@NL@%
        jz        SaveLoop                %@AB@%; End of chain if zero%@AE@%%@NL@%
        cmp        bx,dx                        %@AB@%; BP outside of stack segment?%@AE@%%@NL@%
        jae        SaveLoop                %@AB@%; Yes, end of chain%@AE@%%@NL@%
        mov        si,bx                        %@AB@%; Save current BP%@AE@%%@NL@%
        mov        bx,ss:[bx].savedBP        %@AB@%; SS:BX -> next frame in BP chain%@AE@%%@NL@%
        and        bl,0FEh                 %@AB@%; Flush any INC BP bit%@AE@%%@NL@%
        cmp        bx,si                        %@AB@%; savedBP valid?%@AE@%%@NL@%
        jbe        SaveLoop                %@AB@%; No, end of chain%@AE@%%@NL@%
        dec        cx                        %@AB@%; decrement count of calls to ignore%@AE@%%@NL@%
        jnz        NextBPToIgnore                %@AB@%; Process the next one%@AE@%%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; This loop will save away the specified number of calls into the%@AE@%%@NL@%
%@AB@%; passed in save area%@AE@%%@NL@%
%@NL@%
SaveLoop:%@NL@%
        mov        cx,cCallsSave                %@AB@%; get count of calls to save%@AE@%%@NL@%
%@NL@%
NextBPToSave:%@NL@%
        and        bx,0FFFEh                %@AB@%; Flush any INC BP bit%@AE@%%@NL@%
        jz        EndBPChain                    %@AB@%; End of chain if zero%@AE@%%@NL@%
        cmp        bx,dx                        %@AB@%; BP outside of stack segment?%@AE@%%@NL@%
        jae        EndBPChain                    %@AB@%; Yes, end of chain%@AE@%%@NL@%
%@AB@%; see if short or long call and setup selLast%@AE@%%@NL@%
        mov        si,ss:[bx].savedCS        %@AB@%; Get the code segment%@AE@%%@NL@%
        lar        ax,si                        %@AB@%; get the access rights%@AE@%%@NL@%
        jnz        CSNotValid                %@AB@%; No access assume not selector%@AE@%%@NL@%
        and        ah,018h                 %@AB@%; see if code segment%@AE@%%@NL@%
        cmp        ah,018h                 %@AB@%;%@AE@%%@NL@%
        jz        CSValid                 %@AB@%; code segment, so  save it%@AE@%%@NL@%
%@NL@%
CSNotValid:%@NL@%
        xor        si,si                        %@AB@%; Not valid, set selector to NULL%@AE@%%@NL@%
CSValid:%@NL@%
        mov        ax,ss:[bx].savedIP        %@AB@%; save away IP of caller%@AE@%%@NL@%
        stosw%@NL@%
        mov        ax,si                        %@AB@%; and save away the code selector%@AE@%%@NL@%
        stosw%@NL@%
        dec        cx                        %@AB@%; decrement count of how many to save%@AE@%%@NL@%
%@NL@%
        mov        si,bx                        %@AB@%; Save current BP%@AE@%%@NL@%
        mov        bx,ss:[bx].savedBP        %@AB@%; SS:BX -> next frame in BP chain%@AE@%%@NL@%
        and        bl,0FEh                 %@AB@%; Flush any INC BP bit%@AE@%%@NL@%
        cmp        bx,si                        %@AB@%; savedBP valid?%@AE@%%@NL@%
        jbe        EndBPChain                %@AB@%; No%@AE@%%@NL@%
        jcxz        StackOverflowsSave        %@AB@%; Stack is deeper than save area%@AE@%%@NL@%
%@NL@%
        jmp        NextBPToSave%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; We reached the end of the BP chain before we saved the specified number%@AE@%%@NL@%
%@AB@%; of stack items.  zero out the next item to signal caller how many items%@AE@%%@NL@%
%@AB@%; were filled in%@AE@%%@NL@%
%@NL@%
EndBPChain:%@NL@%
        jcxz        FillInSelectors%@NL@%
        xor        ax,ax                        %@AB@%; Ended BP Chain Before count%@AE@%%@NL@%
        stosw                                %@AB@%; Put A 0:0 to signal end%@AE@%%@NL@%
        stosw%@NL@%
        sub        di,4                        %@AB@%; realign DI to last saved call%@AE@%%@NL@%
        mov        ax,es:[di-2]                %@AB@%; ax = Selector of last saved call%@AE@%%@NL@%
        jmp        FillInSelectors         %@AB@%;%@AE@%%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; We saved the specified number of items, before we reached the end of the%@AE@%%@NL@%
%@AB@%; BP chain.  If the last item we saved was a local call, we should continue%@AE@%%@NL@%
%@AB@%; to go through the stack until we find a valid far return address.%@AE@%%@NL@%
%@NL@%
StackOverflowsSave:%@NL@%
        or        ax,ax                        %@AB@%; Was last call local?%@AE@%%@NL@%
        jnz        FillInSelectors         %@AB@%;%@AE@%%@NL@%
%@NL@%
%@AB@%; loop to locate a FAR return address%@AE@%%@NL@%
NextBPToCheck:%@NL@%
        and        bx,0FFFEh                %@AB@%; Flush any INC BP bit%@AE@%%@NL@%
        jz        FarReturnNotFound        %@AB@%; End of chain if zero%@AE@%%@NL@%
        cmp        bx,dx                        %@AB@%; BP outside of stack segment?%@AE@%%@NL@%
        jae        FarReturnNotFound        %@AB@%; Yes, end of chain%@AE@%%@NL@%
%@AB@%; see if short or long call and setup selLast%@AE@%%@NL@%
        mov        ax,ss:[bx].savedCS        %@AB@%; Get the code segment%@AE@%%@NL@%
        lar        cx,ax                        %@AB@%; get the access rights%@AE@%%@NL@%
        jnz        CSNotValid2                %@AB@%; No access assume not selector%@AE@%%@NL@%
        and        ch,018h                 %@AB@%; see if code segment%@AE@%%@NL@%
        cmp        ch,018h                 %@AB@%;%@AE@%%@NL@%
        jz        FillInSelectors         %@AB@%; ax has valid code selector, use it%@AE@%%@NL@%
%@NL@%
CSNotValid2:%@NL@%
        mov        si,bx                        %@AB@%; Save current BP%@AE@%%@NL@%
        mov        bx,ss:[bx].savedBP        %@AB@%; SS:BX -> next frame in BP chain%@AE@%%@NL@%
        and        bl,0FEh                 %@AB@%; Flush any INC BP bit%@AE@%%@NL@%
        cmp        bx,si                        %@AB@%; savedBP valid?%@AE@%%@NL@%
        jg        NextBPToCheck%@NL@%
FarReturnNotFound:%@NL@%
        mov        ax,0ffffh                %@AB@%; use special value to show%@AE@%%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Loop through and convert all Short return addresses into long return%@AE@%%@NL@%
%@AB@%; addresses%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
FillInSelectors:%@NL@%
        mov        cx,off_pStackSave%@NL@%
FillInLoop:%@NL@%
        cmp        di,cx                        %@AB@%; have we back tracked all the way?%@AE@%%@NL@%
        jz        FillInEnd                %@AB@%; Yes%@AE@%%@NL@%
        sub        di,4                        %@AB@%; point back to previous item%@AE@%%@NL@%
        cmp        WORD PTR es:[di+2],0        %@AB@%; is the selector zero?%@AE@%%@NL@%
        jz        LocalReturn                %@AB@%; Yes, local return%@AE@%%@NL@%
        mov        ax,es:[di+2]                %@AB@%; No FAR return, save CS selector%@AE@%%@NL@%
        jmp        FillInLoop%@NL@%
LocalReturn:%@NL@%
        mov        es:[di+2],ax                %@AB@%; Make long return using saved CS%@AE@%%@NL@%
        jmp        FillInLoop%@NL@%
%@NL@%
FillInEnd:%@NL@%
cEnd%@NL@%
%@NL@%
sEnd        CODE%@NL@%
%@NL@%
end        LoadProc%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SPYTBLS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SPY\SPYTBLS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* spytbls.c%@NL@%
%@AB@%*%@NL@%
%@AB@%*    Includes the definitions of the different tables used in the spy%@NL@%
%@AB@%*    program%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
       INCL_WINHEAP                %@AB@%/* for spy.h */%@AE@%%@NL@%
       INCL_WINPOINTERS        %@AB@%/* for spy.h */%@AE@%%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"spyhook.h" %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"spy.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * First define the message information table.  This table will be%@NL@%
%@AB@% * used to display messages with%@NL@%
%@AB@% */%@AE@%%@NL@%
MSGI rgmsgi[] =%@NL@%
{%@NL@%
    {0x0000, "WM_NULL", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0001, "WM_CREATE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0002, "WM_DESTROY", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0003, "WM_OTHERWINDOWDESTROYED", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0004, "WM_ENABLE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0005, "WM_SHOW", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0006, "WM_MOVE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0007, "WM_SIZE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0008, "WM_ADJUSTWINDOWPOS", MSGI_ENABLED, MPTS(MPT_SWP, 0), 0},%@NL@%
        {0x0009, "WM_CALCVALIDRECTS", MSGI_ENABLED, MPTS(MPT_RECTL, MPT_SWP), 0},%@NL@%
        {0x000a, "WM_SETWINDOWPARAMS", MSGI_ENABLED, MPTS(MPT_WNDPRMS, 0), 0},%@NL@%
        {0x000b, "WM_QUERYWINDOWPARAMS", MSGI_ENABLED, 0, 0},%@NL@%
        {0x000c, "WM_HITTEST", MSGI_FREQ, 0, 0},%@NL@%
        {0x000d, "WM_ACTIVATE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x000f, "WM_SETFOCUS", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0010, "WM_SETSELECTION", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0020, "WM_COMMAND", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0021, "WM_SYSCOMMAND", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0022, "WM_HELP", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0023, "WM_PAINT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0024, "WM_TIMER", MSGI_FREQ, 0, 0},%@NL@%
        {0x0025, "WM_SEM1", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0026, "WM_SEM2", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0027, "WM_SEM3", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0028, "WM_SEM4", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0029, "WM_CLOSE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x002a, "WM_QUIT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x002b, "WM_SYSCOLORCHANGE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x002d, "WM_SYSVALUECHANGED", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0030, "WM_CONTROL", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0031, "WM_VSCROLL", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0032, "WM_HSCROLL", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0033, "WM_INITMENU", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0034, "WM_MENUSELECT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0035, "WM_MENUEND", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0036, "WM_DRAWITEM", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0037, "WM_MEASUREITEM", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0038, "WM_CONTROLPOINTER", MSGI_FREQ, 0, 0},%@NL@%
        {0x0039, "WM_CONTROLHEAP", MSGI_ENABLED, 0, 0},%@NL@%
        {0x003a, "WM_QUERYDLGCODE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x003b, "WM_INITDLG", MSGI_ENABLED, 0, 0},%@NL@%
        {0x003c, "WM_SUBSTITUTESTRING", MSGI_ENABLED, 0, 0},%@NL@%
        {0x003d, "WM_MATCHMNEMONIC", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0040, "WM_FLASHWINDOW", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0041, "WM_FORMATFRAME", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0042, "WM_UPDATEFRAME", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0043, "WM_FOCUSCHANGE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0044, "WM_SETBORDERSIZE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0045, "WM_TRACKFRAME", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0046, "WM_MINMAXFRAME", MSGI_ENABLED, MPTS(MPT_SWP, 0), 0},%@NL@%
        {0x0047, "WM_SETICON", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0048, "WM_QUERYICON", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0049, "WM_SETACCELTABLE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x004a, "WM_QUERYACCELTABLE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x004b, "WM_TRANSLATEACCEL", MSGI_ENABLED, MPTS(MPT_QMSG, 0), 0},%@NL@%
        {0x004c, "WM_QUERYTRACKINFO", MSGI_ENABLED, 0, 0},%@NL@%
        {0x004d, "WM_QUERYBORDERSIZE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x004e, "WM_NEXTMENU", MSGI_ENABLED, 0, 0},%@NL@%
        {0x004f, "WM_ERASEBACKGROUND", MSGI_ENABLED, MPTS(MPT_RECTL, 0), 0},%@NL@%
        {0x0050, "WM_QUERYFRAMEINFO", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0051, "WM_QUERYFOCUSCHAIN", MSGI_ENABLED, MPTS(MPT_SWP, 0), 0},%@NL@%
        {0x0053, "WM_CALCFRAMERECT", MSGI_ENABLED, MPTS(MPT_RECTL, 0), 0},%@NL@%
        {0x0059, "WM_QUERYFRAMECTLCOUNT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0060, "WM_RENDERFMT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0061, "WM_RENDERALLFMTS", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0062, "WM_DESTROYCLIPBOARD", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0063, "WM_PAINTCLIPBOARD", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0064, "WM_SIZECLIPBOARD", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0065, "WM_HSCROLLCLIPBOARD", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0066, "WM_VSCROLLCLIPBOARD", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0067, "WM_DRAWCLIPBOARD", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0070, "WM_MOUSEMOVE", MSGI_FREQ| MSGI_MOUSE, 0, 0},%@NL@%
        {0x0071, "WM_BUTTON1DOWN", MSGI_ENABLED| MSGI_MOUSE, 0, 0},%@NL@%
        {0x0072, "WM_BUTTON1UP", MSGI_ENABLED| MSGI_MOUSE, 0, 0},%@NL@%
        {0x0073, "WM_BUTTON1DBLCLK", MSGI_ENABLED| MSGI_MOUSE, 0, 0},%@NL@%
        {0x0074, "WM_BUTTON2DOWN", MSGI_ENABLED| MSGI_MOUSE, 0, 0},%@NL@%
        {0x0075, "WM_BUTTON2UP", MSGI_ENABLED| MSGI_MOUSE, 0, 0},%@NL@%
        {0x0076, "WM_BUTTON2DBLCLK", MSGI_ENABLED| MSGI_MOUSE, 0, 0},%@NL@%
        {0x0077, "WM_BUTTON3DOWN", MSGI_ENABLED| MSGI_MOUSE, 0, 0},%@NL@%
        {0x0078, "WM_BUTTON3UP", MSGI_ENABLED| MSGI_MOUSE, 0, 0},%@NL@%
        {0x0079, "WM_BUTTON3DBLCLK", MSGI_ENABLED| MSGI_MOUSE, 0, 0},%@NL@%
        {0x007a, "WM_CHAR", MSGI_ENABLED | MSGI_KEY, 0, 0},%@NL@%
        {0x00A0, "WM_DDE_INITIATE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x00A1, "WM_DDE_REQUEST", MSGI_ENABLED, 0, 0},%@NL@%
        {0x00A2, "WM_DDE_ACK", MSGI_ENABLED, 0, 0},%@NL@%
        {0x00A3, "WM_DDE_DATA", MSGI_ENABLED, 0, 0},%@NL@%
        {0x00A4, "WM_DDE_ADVISE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x00A5, "WM_DDE_UNADVISE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x00A6, "WM_DDE_POKE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x00A7, "WM_DDE_EXECUTE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x00A8, "WM_DDE_TERMINATE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x00A9, "WM_DDE_INITIATEACK", MSGI_ENABLED, 0, 0},%@NL@%
        {0x00af, "WM_DDE_LAST", MSGI_ENABLED, 0, 0},%@NL@%
        {0x00b0, "WM_QUERYCONVERTPOS", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0120, "BM_CLICK", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0121, "BM_QUERYCHECKINDEX", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0122, "BM_QUERYHILITE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0123, "BM_SETHILITE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0124, "BM_QUERYCHECK", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0125, "BM_SETCHECK", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0126, "BM_SETDEFAULT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0140, "EM_QUERYCHANGED", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0141, "EM_QUERYSEL", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0142, "EM_SETSEL", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0143, "EM_SETTEXTLIMIT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0144, "EM_CUT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0145, "EM_COPY", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0146, "EM_CLEAR", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0147, "EM_PASTE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0148, "EM_QUERYFIRSTCHAR", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0149, "EM_SETFIRSTCHAR", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0160, "LM_QUERYITEMCOUNT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0161, "LM_INSERTITEM", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0162, "LM_SETTOPINDEX", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0163, "LM_DELETEITEM", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0164, "LM_SELECTITEM", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0165, "LM_QUERYSELECTION", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0166, "LM_SETITEMTEXT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0167, "LM_QUERYITEMTEXTLENGTH", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0168, "LM_QUERYITEMTEXT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0169, "LM_SETITEMHANDLE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x016a, "LM_QUERYITEMHANDLE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x016b, "LM_SEARCHSTRING", MSGI_ENABLED, 0, 0},%@NL@%
        {0x016c, "LM_SETITEMHEIGHT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x016d, "LM_QUERYTOPINDEX", MSGI_ENABLED, 0, 0},%@NL@%
        {0x016e, "LM_DELETEALL", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0180, "MM_INSERTITEM", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0181, "MM_DELETEITEM", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0182, "MM_QUERYITEM", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0183, "MM_SETITEM", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0184, "MM_QUERYITEMCOUNT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0185, "MM_STARTMENUMODE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0186, "MM_ENDMENUMODE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0187, "MM_DISMISSMENU", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0188, "MM_REMOVEITEM", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0189, "MM_SELECTITEM", MSGI_ENABLED, 0, 0},%@NL@%
        {0x018a, "MM_QUERYSELITEMID", MSGI_ENABLED, 0, 0},%@NL@%
        {0x018b, "MM_QUERYITEMTEXT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x018c, "MM_QUERYITEMTEXTLENGTH", MSGI_ENABLED, 0, 0},%@NL@%
        {0x018d, "MM_SETITEMHANDLE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x018e, "MM_SETITEMTEXT", MSGI_ENABLED, 0, 0},%@NL@%
        {0x018f, "MM_ITEMPOSITIONFROMID", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0190, "MM_ITEMIDFROMPOSITION", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0191, "MM_QUERYITEMATTR", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0192, "MM_SETITEMATTR", MSGI_ENABLED, 0, 0},%@NL@%
        {0x0193, "MM_ISITEMVALID", MSGI_ENABLED, 0, 0},%@NL@%
        {0x01a0, "SBM_SETSCROLLBAR", MSGI_ENABLED, 0, 0},%@NL@%
        {0x01a1, "SBM_SETPOS", MSGI_ENABLED, 0, 0},%@NL@%
        {0x01a2, "SBM_QUERYPOS", MSGI_ENABLED, 0, 0},%@NL@%
        {0x01a3, "SBM_QUERYRANGE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x01a4, "SBM_SETHILITE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x01a5, "SBM_QUERYHILITE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x01e3, "TBM_SETHILITE", MSGI_ENABLED, 0, 0},%@NL@%
        {0x01e4, "TBM_QUERYHILITE", MSGI_ENABLED, 0, 0},%@NL@%
};%@NL@%
%@NL@%
SHORT cmsgi = sizeof(rgmsgi) / sizeof(MSGI);%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Now define the table of system known window ids, that is%@NL@%
%@AB@% * used to display the list of windows with%@NL@%
%@AB@% */%@AE@%%@NL@%
%@AB@%/* Define table of window ids */%@AE@%%@NL@%
IDTONAME    rgidtoname[] = {%@NL@%
        {0x8001, "FID_SIZEBORDER"},%@NL@%
        {0x8002, "FID_SYSMENU"},%@NL@%
        {0x8003, "FID_TITLEBAR"},%@NL@%
        {0x8004, "FID_MINMAX"},%@NL@%
        {0x8005, "FID_MENU"},%@NL@%
        {0x8006, "FID_VERTSCROLL"},%@NL@%
        {0x8007, "FID_HORZSCROLL"},%@NL@%
        {0x8008, "FID_CLIENT"}%@NL@%
};%@NL@%
%@NL@%
SHORT cToName =  sizeof(rgidtoname) / sizeof(IDTONAME);%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * And define the system options%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
SPYOPT spyopt = {%@NL@%
    %@AB@%/* Output options */%@AE@%%@NL@%
    TRUE, FALSE, 100, NULL, SPYH_INPUT | SPYH_SENDMSG,%@NL@%
        TRUE, TRUE,%@NL@%
        FALSE,%@NL@%
        TRUE, FALSE%@NL@%
%@NL@%
};%@NL@%
%@NL@%
SPYSTR spystr = {%@NL@%
    "spy.out",      %@AB@%/* Default output file */%@AE@%%@NL@%
    "spy.lis"       %@AB@%/* Default save to list file */%@AE@%%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SPYUTIL.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SPY\SPYUTIL.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%;  SPY Assembly language utility functions.%@AE@%%@NL@%
%@NL@%
?WIN=1            %@AB@%; Use Windows prolog/epilog%@AE@%%@NL@%
?PLM=1            %@AB@%; Use PLM calling convention%@AE@%%@NL@%
DOS5=1%@NL@%
.xlist%@NL@%
include cmacros.inc%@NL@%
.list%@NL@%
%@NL@%
%@NL@%
%@NL@%
EXTRN        DOSCHGFILEPTR:FAR%@NL@%
EXTRN        DOSREAD:FAR%@NL@%
%@NL@%
%@NL@%
sBegin        CODE%@NL@%
assumes cs,CODE%@NL@%
assumes ds,DATA%@NL@%
.286p%@NL@%
%@NL@%
%@AB@%; FValidPointer%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; FValidPointer(VOID FAR *pVoid, SHORT cbStruct)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc        FValidPointer,<NEAR,PUBLIC>%@NL@%
ParmD  pVoid%@NL@%
ParmW        cbStruct%@NL@%
cBegin%@NL@%
        xor        ax,ax                        %@AB@%; Assume Bad address%@AE@%%@NL@%
        mov        bx,SEG_pVoid                %@AB@%; Get the selector of the address%@AE@%%@NL@%
        lar        cx,bx                        %@AB@%; make sure we have access%@AE@%%@NL@%
        jnz        NoAccess                %@AB@%; no access%@AE@%%@NL@%
%@NL@%
        lsl        cx,bx                        %@AB@%; get the segment limit%@AE@%%@NL@%
        mov        bx,OFF_pVoid                %@AB@%; check range%@AE@%%@NL@%
        add        bx,cbStruct                %@AB@%; Add number of bytes on%@AE@%%@NL@%
        jc        NoAccess                %@AB@%; overflowed%@AE@%%@NL@%
        cmp        cx,bx%@NL@%
        jc        NoAccess                %@AB@%; Would overflow, again bad pointer%@AE@%%@NL@%
        inc        ax                        %@AB@%; Return No zero for TRUE%@AE@%%@NL@%
%@NL@%
NoAccess:%@NL@%
cEnd%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%; FGuessValidPointer%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; FGuessValidPointer(VOID FAR *pVoid, SHORT cbStruct)%@AE@%%@NL@%
%@AB@%; Since a pointer may have come from a different process, we can not%@AE@%%@NL@%
%@AB@%; actually validate the pointer.  The Best we can do is simply look%@AE@%%@NL@%
%@AB@%; at the selector, and see if it looks reasonable.  For now simply check%@AE@%%@NL@%
%@AB@%; that the selector is for ring 3.  Ie the low order two bits are set.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc        FGuessValidPointer,<NEAR,PUBLIC>%@NL@%
ParmD  pVoid%@NL@%
ParmW        cbStruct%@NL@%
cBegin%@NL@%
        xor        ax,ax                        %@AB@%; Assume Bad address%@AE@%%@NL@%
        mov        bx,SEG_pVoid                %@AB@%; Get the selector of the address%@AE@%%@NL@%
        and        bx,03h                        %@AB@%; only look at two low order bits%@AE@%%@NL@%
        cmp        bx,03h                        %@AB@%; Are they both set%@AE@%%@NL@%
        jnz        NoGVAccess                %@AB@%; not ring 3 assume no access%@AE@%%@NL@%
        inc        ax                        %@AB@%; Return No zero for TRUE%@AE@%%@NL@%
%@NL@%
NoGVAccess:%@NL@%
cEnd%@NL@%
%@NL@%
%@NL@%
%@NL@%
cProc        DebugFileSeek,<PUBLIC,NEAR,PASCAL>%@NL@%
    parmW   fh%@NL@%
    parmD   amt%@NL@%
    parmW   typ%@NL@%
cBegin%@NL@%
        push        ax%@NL@%
        push        ax%@NL@%
        mov        bx,sp%@NL@%
        push        fh%@NL@%
        mov        dx,SEG_amt%@NL@%
        mov        ax,OFF_amt%@NL@%
        mov        cx,typ%@NL@%
        cmp        cx,2%@NL@%
        jle        noshift%@NL@%
shiftamt:%@NL@%
        shl        ax,1%@NL@%
        rcl        dx,1%@NL@%
        loop        shiftamt%@NL@%
noshift:%@NL@%
        push        dx%@NL@%
        push        ax%@NL@%
        push        cx%@NL@%
        push        ss%@NL@%
        push        bx%@NL@%
        call        DOSCHGFILEPTR%@NL@%
        or        ax,ax%@NL@%
        pop        ax%@NL@%
        pop        dx%@NL@%
        jz        seek_done%@NL@%
        xor        ax,ax%@NL@%
        xor        dx,dx%@NL@%
seek_done:%@NL@%
cEnd%@NL@%
%@NL@%
%@NL@%
%@NL@%
cProc        DebugFileRead,<PUBLIC,NEAR,PASCAL>%@NL@%
    parmW   fh%@NL@%
    parmD   lpBuf%@NL@%
    parmW   nBytes%@NL@%
cBegin%@NL@%
        push        ax%@NL@%
        mov        ax,sp%@NL@%
        push        fh%@NL@%
        push        SEG_lpBuf%@NL@%
        push        OFF_lpBuf%@NL@%
        push        nBytes%@NL@%
        push        ss%@NL@%
        push        ax%@NL@%
        call        DOSREAD%@NL@%
        or        ax,ax%@NL@%
        pop        ax%@NL@%
        jz        read_done%@NL@%
        xor        ax,ax%@NL@%
read_done:%@NL@%
cEnd%@NL@%
%@NL@%
cProc lstrcat,<PUBLIC>,<SI,DI,DS>%@NL@%
    parmD  szDest%@NL@%
    parmD  szSource%@NL@%
%@NL@%
cBegin        lstrcat%@NL@%
%@NL@%
%@AB@%; first lets get the length of the source string and setup pointer to%@AE@%%@NL@%
%@AB@%; source string%@AE@%%@NL@%
%@NL@%
        les        di,szSource%@NL@%
        mov        cx,-1                %@AB@%; count the bytes negatively%@AE@%%@NL@%
        xor        ax,ax                %@AB@%; Look for a null%@AE@%%@NL@%
%@NL@%
        repne scasb                %@AB@%; find null byte & get source length%@AE@%%@NL@%
        inc        cx                %@AB@%; cx=-count of bytes in source string%@AE@%%@NL@%
                                %@AB@%;    (including null)%@AE@%%@NL@%
        neg        cx                %@AB@%; cx=+count%@AE@%%@NL@%
        mov        bx,cx                %@AB@%; save the count%@AE@%%@NL@%
%@NL@%
        lds        si,szSource        %@AB@%; now setup Source pointer%@AE@%%@NL@%
%@NL@%
%@AB@%; now find the end of destination string.%@AE@%%@NL@%
        les        di,szDest%@NL@%
        xor        ax,ax%@NL@%
        mov        cx,0ffffH%@NL@%
        repne scasb%@NL@%
        dec        di                %@AB@%; di points to dest null terminator%@AE@%%@NL@%
%@NL@%
        mov        cx,bx                %@AB@%; restore count of bytes to copy%@AE@%%@NL@%
%@NL@%
        rep movsb                %@AB@%; concatenate the strings%@AE@%%@NL@%
%@NL@%
cEnd        lstrcat%@NL@%
%@NL@%
sEnd        CODE%@NL@%
end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%STOCK.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\STOCK\STOCK.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***        stock - draw a stock chart%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Author:%@NL@%
%@AB@% *            Benjamin W. Slivka%@NL@%
%@AB@% *%@NL@%
%@AB@% *        History:%@NL@%
%@AB@% *            27-Mar-1989 bens        Initial version.%@NL@%
%@AB@% *            06-Apr-1989 bens        Always repaint on WM_SIZE.%@NL@%
%@AB@% *            26-Apr-1990 bens        Get it limping along%@NL@%
%@AB@% *            03-May-1990 bens        Add file open%@NL@%
%@AB@% *            11-May-1990 bens        Printing works!%@NL@%
%@AB@% *            06-Jun-1990 bens        Finish job property handling%@NL@%
%@AB@% *            07-Jun-1990 bens        Fix bugs in JP stuff, spiff up user interface%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DEV %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPIPRIMITIVES %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%INCL_WINERRORS %@NL@%
%@AI@%#define %@AE@%INCL_WINFRAMEMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%INCL_WINPOINTERS %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"ea.h" %@NL@%
%@AI@%#include %@AE@%"ids.h" %@NL@%
%@AI@%#include %@AE@%"file.h" %@NL@%
%@AI@%#include %@AE@%"limits.h" %@NL@%
%@AI@%#include %@AE@%"mem.h" %@NL@%
%@AI@%#include %@AE@%"print.h" %@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%cchDate    10 %@NL@%
%@AI@%#define %@AE@%cchMax           80 %@NL@%
%@NL@%
%@AI@%#define %@AE@%iH            0            // index of High %@NL@%
%@AI@%#define %@AE@%iL            1            // index of Low %@NL@%
%@AI@%#define %@AE@%iC            2            // index of Close %@NL@%
%@AI@%#define %@AE@%NV            3            // Number of vectors %@NL@%
%@AI@%#define %@AE@%cptMax         1200            // maximum data points %@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%ENABLE_MENU_ITEM(x, y)                                    \ %@NL@%
        WinSendDlgItemMsg((x), FID_MENU, MM_SETITEMATTR,    \%@NL@%
            MPFROM2SHORT((y),TRUE),                            \%@NL@%
            MPFROM2SHORT(MIA_DISABLED,NULL))%@NL@%
%@NL@%
%@AI@%#define %@AE@%DISABLE_MENU_ITEM(x, y)                             \ %@NL@%
        WinSendDlgItemMsg((x), FID_MENU, MM_SETITEMATTR,    \%@NL@%
            MPFROM2SHORT((y),TRUE),                            \%@NL@%
            MPFROM2SHORT(MIA_DISABLED,MIA_DISABLED))%@NL@%
%@NL@%
%@AI@%#define %@AE@%CHECK_MENU_ITEM(x, y)                                    \ %@NL@%
        WinSendDlgItemMsg((x), FID_MENU, MM_SETITEMATTR,    \%@NL@%
            MPFROM2SHORT((y),TRUE),                            \%@NL@%
            MPFROM2SHORT(MIA_CHECKED,MIA_CHECKED))%@NL@%
%@NL@%
%@AI@%#define %@AE@%UNCHECK_MENU_ITEM(x, y)                             \ %@NL@%
        WinSendDlgItemMsg((x), FID_MENU, MM_SETITEMATTR,    \%@NL@%
            MPFROM2SHORT((y),TRUE),                            \%@NL@%
            MPFROM2SHORT(MIA_CHECKED,NULL))%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc(HWND hwnd,USHORT msg,MPARAM mp1,MPARAM mp2);%@NL@%
MRESULT EXPENTRY AboutDlgProc(HWND hwnd,USHORT msg,MPARAM mp1,MPARAM mp2);%@NL@%
MRESULT EXPENTRY PrinterSetupDlgProc(HWND hwnd,USHORT msg,MPARAM mp1,MPARAM mp2);%@NL@%
%@NL@%
%@NL@%
HPRINTER    HPRTFromListBox(HWND hwnd);%@NL@%
BOOL            InteractSaveFile(HWND hwnd);%@NL@%
int cdecl   main(int cArg,char **ppszArg);%@NL@%
VOID            Message(char *psz, HWND hwnd);%@NL@%
VOID            PlotPrice(HPS hps,RECTL rcl);%@NL@%
BOOL            QueryHCI(HDC hdc,HCINFO *phci);%@NL@%
BOOL            PrintChart(HWND hwnd);%@NL@%
BOOL            ReadData(HWND hwnd);%@NL@%
VOID            SaveJobProperties(VOID);%@NL@%
VOID            SetOriginMenu(VOID);%@NL@%
VOID            SetFileMenu(VOID);%@NL@%
VOID            ShowWinError(char *psz);%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        GLOBAL - global data%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
typedef struct {    %@AB@%/* glb */%@AE@%%@NL@%
    char         achAppTitle[CCHMAXPATH]; // Application title%@NL@%
    USHORT         cpt;                // Number of points%@NL@%
    BOOL         fNewJobProp;        // TRUE => job properties changed%@NL@%
    BOOL         fZeroOrigin;        // TRUE => Y origin is 0; else is minimum price%@NL@%
    HAB          hab;%@NL@%
    HWND         hwndFrame;%@NL@%
    HWND         hwndClient;%@NL@%
    USHORT         pMax;                // Maximum price%@NL@%
    USHORT         pMin;                // Minimum price%@NL@%
    char *         pszFile;        // Data file%@NL@%
    HPRINTER         hprt;                // Current printer handle%@NL@%
    HPRINTERLIST hprtlist;        // Handle of printer list%@NL@%
} GLOBAL;%@NL@%
%@NL@%
char            achMisc[CCHMAXPATH];%@NL@%
USHORT            apt[NV][cptMax];%@NL@%
GLOBAL            glb;%@NL@%
HPOINTER    hptrNormal;%@NL@%
HPOINTER    hptrWait;%@NL@%
char            szClientClass[]="Stock";%@NL@%
char            pszJobProp[]="StockJobProp";%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        main - main program%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
int cdecl main(int cArg, char **ppszArg)%@NL@%
{%@NL@%
    ULONG            flFrameFlags= FCF_TITLEBAR            | FCF_SYSMENU  |%@NL@%
                                  FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                  FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                  FCF_MENU;%@NL@%
    HMQ             hmq;%@NL@%
    QMSG            qmsg;%@NL@%
%@NL@%
    glb.hprt = NULL;%@NL@%
    glb.cpt = 0;%@NL@%
    glb.fZeroOrigin = TRUE;            // Use a zero origin%@NL@%
    glb.fNewJobProp = FALSE;            // No new job properties%@NL@%
%@NL@%
    // If at least one argument, take that as data file name%@NL@%
    if (cArg >= 2)%@NL@%
        glb.pszFile = MemStrDup(ppszArg[1]);%@NL@%
    else%@NL@%
        glb.pszFile = NULL;%@NL@%
%@NL@%
    glb.hab = WinInitialize(0);%@NL@%
    hmq = WinCreateMsgQueue(glb.hab,0);%@NL@%
%@NL@%
    hptrWait = WinQuerySysPointer(HWND_DESKTOP,SPTR_WAIT,FALSE);%@NL@%
    hptrNormal = WinQuerySysPointer(HWND_DESKTOP,SPTR_ARROW,FALSE);%@NL@%
%@NL@%
    WinRegisterClass(glb.hab,szClientClass,ClientWndProc,0L,0);%@NL@%
%@NL@%
    glb.hwndFrame = WinCreateStdWindow(HWND_DESKTOP,%@NL@%
                        WS_VISIBLE | FS_ICON | FS_TASKLIST, // Window styles%@NL@%
                        &flFrameFlags,%@NL@%
                        szClientClass,%@NL@%
                        NULL,%@NL@%
                        0L,%@NL@%
                        (HMODULE) NULL,%@NL@%
                        IDR_APP,%@NL@%
                        &glb.hwndClient);%@NL@%
%@NL@%
    if (glb.hwndFrame == 0) {%@NL@%
        Message("Cannot create main window",NULL);%@NL@%
        WinDestroyMsgQueue(hmq);%@NL@%
        WinTerminate(glb.hab);%@NL@%
        return 1;%@NL@%
    }%@NL@%
%@NL@%
    // Get printer list%@NL@%
    glb.hprtlist = PrintCreatePrinterList(glb.hab);%@NL@%
%@NL@%
    // Get application title%@NL@%
    WinQueryWindowText(glb.hwndFrame, sizeof(glb.achAppTitle),glb.achAppTitle);%@NL@%
%@NL@%
    if (glb.pszFile != NULL)%@NL@%
        ReadData(glb.hwndClient);%@NL@%
%@NL@%
    // Get printer, if not already set by ReadData%@NL@%
%@NL@%
    if (glb.hprt == NULL) {                // Need to find it%@NL@%
        if (glb.hprtlist != NULL) {        // Printers exists%@NL@%
            glb.hprt = PrintQueryDefaultPrinter(glb.hprtlist); // Get default%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    // Set up valid menu options%@NL@%
%@NL@%
    SetFileMenu();%@NL@%
    SetOriginMenu();%@NL@%
%@NL@%
    // Message loop%@NL@%
%@NL@%
    while (WinGetMsg(glb.hab,&qmsg,NULL,0,0)) {%@NL@%
        WinDispatchMsg(glb.hab,&qmsg);%@NL@%
    }%@NL@%
%@NL@%
    // Destroy printer list%@NL@%
%@NL@%
    if (glb.hprtlist != NULL)%@NL@%
        PrintDestroyPrinterList(glb.hprtlist);%@NL@%
%@NL@%
    WinDestroyWindow(glb.hwndFrame);%@NL@%
    WinDestroyMsgQueue(hmq);%@NL@%
    WinTerminate(glb.hab);%@NL@%
    return 0;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        ClientWndProc - window proc for client window%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
MRESULT EXPENTRY ClientWndProc(HWND hwnd,USHORT msg,MPARAM mp1,MPARAM mp2)%@NL@%
{%@NL@%
    HPS     hps;%@NL@%
    char *  psz;%@NL@%
    RECTL   rcl;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1)) {%@NL@%
%@NL@%
        case IDM_ABOUT:%@NL@%
            WinDlgBox(HWND_DESKTOP,hwnd,AboutDlgProc,NULL,IDD_ABOUT,NULL);%@NL@%
            return FALSE;%@NL@%
%@NL@%
        case IDM_FILE_CLOSE:%@NL@%
            // Make sure current file is saved%@NL@%
            if (!InteractSaveFile(hwnd)) // User cancelled%@NL@%
                return FALSE;%@NL@%
%@NL@%
            // Empty data%@NL@%
%@NL@%
            glb.cpt = 0;%@NL@%
            if (glb.pszFile != NULL) {%@NL@%
                MemFree(glb.pszFile);%@NL@%
                glb.pszFile = NULL;%@NL@%
            }%@NL@%
            WinInvalidateRect(hwnd,NULL,FALSE); // Force repaint%@NL@%
%@NL@%
%@NL@%
            SetFileMenu();                // Set valid menu options%@NL@%
            return FALSE;%@NL@%
%@NL@%
        case IDM_FILE_OPEN:%@NL@%
            // Make sure current file is saved%@NL@%
            if (!InteractSaveFile(hwnd)) // User cancelled%@NL@%
                    return FALSE;%@NL@%
%@NL@%
            psz = FileOpen(hwnd, "Open", "*.dat");%@NL@%
            if (psz != NULL) {%@NL@%
                if (glb.pszFile != NULL) // Old file data present%@NL@%
                    MemFree(glb.pszFile); // Free old file name%@NL@%
                glb.pszFile = psz;        // Set new file name%@NL@%
                if (ReadData(hwnd))        // If data was read successfully%@NL@%
                    WinInvalidateRect(hwnd,NULL,FALSE); // Force repaint%@NL@%
            }%@NL@%
            return FALSE;%@NL@%
%@NL@%
        case IDM_FILE_PRINT:%@NL@%
%@NL@%
            PrintChart(hwnd);%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_FILE_PRINTER_SETUP:%@NL@%
            WinDlgBox(HWND_DESKTOP,hwnd,PrinterSetupDlgProc,NULL,%@NL@%
                                                 IDD_PRINTER_SETUP,NULL);%@NL@%
            return FALSE;%@NL@%
%@NL@%
        case IDM_FILE_SAVE:%@NL@%
            SaveJobProperties();%@NL@%
            SetFileMenu();%@NL@%
            return FALSE;%@NL@%
%@NL@%
        case IDM_FILE_EXIT:%@NL@%
            WinSendMsg(hwnd,WM_QUIT,NULL,NULL);%@NL@%
            break;%@NL@%
%@NL@%
        case IDM_OPTIONS_ORIGIN:%@NL@%
            glb.fZeroOrigin = !glb.fZeroOrigin; // Flip state%@NL@%
            SetOriginMenu();%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CREATE:%@NL@%
        break;%@NL@%
%@NL@%
    case WM_QUIT:%@NL@%
        if (!InteractSaveFile(hwnd))            // User cancelled%@NL@%
            return FALSE;                    //        Do not quit%@NL@%
        break;                                    // Do standard quit processing%@NL@%
%@NL@%
    case WM_SIZE:%@NL@%
        WinInvalidateRect(hwnd,NULL,FALSE);%@NL@%
        return 0;%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        hps = WinBeginPaint(hwnd,NULL,NULL);%@NL@%
        GpiErase(hps);%@NL@%
        WinQueryWindowRect(hwnd,&rcl);%@NL@%
        PlotPrice(hps,rcl);%@NL@%
        WinEndPaint(hps);%@NL@%
        return 0;%@NL@%
    }%@NL@%
    return WinDefWindowProc(hwnd,msg,mp1,mp2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        InteractSaveFile - If new job properties, let user save them%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hwnd - parent window for message box%@NL@%
%@AB@% *            glb.fNewJobProp%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            returns TRUE, file is saved%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            returns FALSE, user cancelled save%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL InteractSaveFile(HWND hwnd)%@NL@%
{%@NL@%
    static char ach[CCHMAXPATH];%@NL@%
    USHORT        rc;%@NL@%
%@NL@%
    if (!glb.fNewJobProp)                // No job properties to save%@NL@%
        return TRUE;%@NL@%
%@NL@%
    sprintf(ach,"Save printer setup in '%s'?",glb.pszFile);%@NL@%
    rc = WinMessageBox(%@NL@%
            HWND_DESKTOP,                // Parent%@NL@%
            hwnd,                        // Owner%@NL@%
            ach,                        // Message%@NL@%
            szClientClass,                // Caption (use default)%@NL@%
            NULL,                        // Window id%@NL@%
            MB_QUERY | MB_YESNOCANCEL | MB_APPLMODAL // window style%@NL@%
    );%@NL@%
    switch (rc) {%@NL@%
        case MBID_YES:                        // Save job properties%@NL@%
            SaveJobProperties();%@NL@%
            SetFileMenu();%@NL@%
            return TRUE;%@NL@%
%@NL@%
        case MBID_NO:                        // Do not save job properties%@NL@%
            glb.fNewJobProp = FALSE;%@NL@%
            SetFileMenu();%@NL@%
            return TRUE;%@NL@%
%@NL@%
        case MBID_CANCEL:                // Cancel save%@NL@%
            return FALSE;%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrintChart - Draw chart on printer%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hwnd - hwnd for status%@NL@%
%@AB@% *%@NL@%
%@AB@% *            glb.hab  - Anchor block%@NL@%
%@AB@% *            glb.hprt - Printer destination%@NL@%
%@AB@% *            glb.pszFile - File name (for job description)%@NL@%
%@AB@% *%@NL@%
%@AB@% *            Same variables as PlotPrice;%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            returns TRUE%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            returns FALSE%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL PrintChart(HWND hwnd)%@NL@%
{%@NL@%
    LONG            cb;%@NL@%
    USHORT            jobid;%@NL@%
    HDC             hdc=NULL;%@NL@%
    HPS             hps=NULL;%@NL@%
    static HCINFO   hci;%@NL@%
    LONG            rc;%@NL@%
    RECTL            rcl;%@NL@%
    SIZEL            sizl;%@NL@%
%@NL@%
    WinSetPointer(HWND_DESKTOP,hptrWait); // Tell user we are being slow%@NL@%
%@NL@%
    // Create DC%@NL@%
%@NL@%
    hdc = PrintOpenDC(glb.hab,glb.hprt,"PM_Q_STD");%@NL@%
    if (hdc == NULL) {%@NL@%
        ShowWinError("PrintOpenDC failed");%@NL@%
        rc = DEV_ERROR;%@NL@%
        goto Exit;%@NL@%
    }%@NL@%
%@NL@%
    if (!QueryHCI(hdc,&hci)) {%@NL@%
        Message("QueryHCI failed",NULL);%@NL@%
        rc = DEV_ERROR;%@NL@%
        goto Exit;%@NL@%
    }%@NL@%
%@NL@%
    // Create and associate PS%@NL@%
    sizl.cx = 0L;%@NL@%
    sizl.cy = 0L;%@NL@%
    hps = GpiCreatePS(glb.hab,hdc,&sizl,GPIA_ASSOC | PU_PELS | GPIT_NORMAL);%@NL@%
    if (hps == NULL) {%@NL@%
        ShowWinError("GpiCreatePS failed");%@NL@%
        rc = DEV_ERROR;%@NL@%
        goto Exit;%@NL@%
    }%@NL@%
%@NL@%
    // Set dimensions of drawing area%@NL@%
    rcl.xLeft        = 0;%@NL@%
    rcl.yBottom = 0;%@NL@%
    rcl.xRight        = hci.xPels;%@NL@%
    rcl.yTop        = hci.yPels;%@NL@%
%@NL@%
    // Time to draw%@NL@%
    rc = DevEscape(%@NL@%
            hdc,                        // Display context%@NL@%
            DEVESC_STARTDOC,                // Start document%@NL@%
            (LONG)strlen(glb.pszFile),        // Length of print job name%@NL@%
            glb.pszFile,                // Print job name%@NL@%
            0L,                         // Ignored%@NL@%
            0L                                // Ignored%@NL@%
         );%@NL@%
    if (rc != DEV_OK) {%@NL@%
        ShowWinError("STARTDOC failed");%@NL@%
        goto Exit;%@NL@%
    }%@NL@%
%@NL@%
    PlotPrice(hps,rcl);%@NL@%
%@NL@%
    cb = sizeof(jobid);                 // Size of output buffer%@NL@%
    rc = DevEscape(%@NL@%
            hdc,                        // Display context%@NL@%
            DEVESC_ENDDOC,                // End document%@NL@%
            0L,                         // Length of print job name%@NL@%
            0L,                         // Print job name%@NL@%
            &cb,                        // Size of jobid%@NL@%
            (PBYTE)&jobid                // Jobid%@NL@%
         );%@NL@%
    if (rc != DEV_OK)%@NL@%
        ShowWinError("ENDDOC failed");%@NL@%
%@NL@%
    // Free resources%@NL@%
Exit:%@NL@%
    if (hps != NULL) {%@NL@%
        GpiAssociate(hps,NULL);%@NL@%
        GpiDestroyPS(hps);%@NL@%
    }%@NL@%
    if (hdc != NULL)%@NL@%
        DevCloseDC(hdc);%@NL@%
    WinSetPointer(HWND_DESKTOP,hptrNormal); // Tell user we are done%@NL@%
    return (rc == DEV_OK);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        ShowWinError - Show message box with error from Win* API call%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            psz - message text%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            none%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID ShowWinError(char *psz)%@NL@%
{%@NL@%
    PERRINFO            perri;%@NL@%
%@NL@%
    perri = WinGetErrorInfo(glb.hab);%@NL@%
    if (perri == (PERRINFO) NULL)%@NL@%
        return;%@NL@%
%@NL@%
    sprintf(achMisc,"%s; Error = 0x%0x",psz,perri->idError);%@NL@%
    Message(achMisc,NULL);%@NL@%
    WinFreeErrorInfo(perri);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        SetOriginMenu - Set text in origin menu%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            glb.fZeroOrgin - current state of origin plotting%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            Menu item checked/unchecked%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID SetOriginMenu(VOID)%@NL@%
{%@NL@%
    if (glb.fZeroOrigin)%@NL@%
        UNCHECK_MENU_ITEM(glb.hwndFrame,IDM_OPTIONS_ORIGIN);%@NL@%
    else%@NL@%
        CHECK_MENU_ITEM(glb.hwndFrame,IDM_OPTIONS_ORIGIN);%@NL@%
%@NL@%
    WinInvalidateRect(glb.hwndClient,NULL,FALSE); // Force repaint%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        SetFileMenu - Set file menu item states%@NL@%
%@AB@% *%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID SetFileMenu(VOID)%@NL@%
{%@NL@%
    static char ach[CCHMAXPATH];%@NL@%
%@NL@%
    strcpy(ach,glb.achAppTitle);        // Title start with app name%@NL@%
%@NL@%
    if (glb.pszFile == NULL) {                // No file currently open%@NL@%
        DISABLE_MENU_ITEM(glb.hwndFrame,IDM_FILE_CLOSE);%@NL@%
        DISABLE_MENU_ITEM(glb.hwndFrame,IDM_FILE_SAVE);%@NL@%
        DISABLE_MENU_ITEM(glb.hwndFrame,IDM_FILE_PRINT);%@NL@%
        DISABLE_MENU_ITEM(glb.hwndFrame,IDM_FILE_PRINTER_SETUP);%@NL@%
    }%@NL@%
    else {%@NL@%
        ENABLE_MENU_ITEM(glb.hwndFrame,IDM_FILE_CLOSE);%@NL@%
%@NL@%
        if (glb.fNewJobProp)                // Job properties need to be saved%@NL@%
            ENABLE_MENU_ITEM(glb.hwndFrame,IDM_FILE_SAVE);%@NL@%
        else%@NL@%
            DISABLE_MENU_ITEM(glb.hwndFrame,IDM_FILE_SAVE);%@NL@%
%@NL@%
        if (glb.hprt != NULL) {         // A printer exists%@NL@%
            ENABLE_MENU_ITEM(glb.hwndFrame,IDM_FILE_PRINT);%@NL@%
            ENABLE_MENU_ITEM(glb.hwndFrame,IDM_FILE_PRINTER_SETUP);%@NL@%
        }%@NL@%
        else {%@NL@%
            DISABLE_MENU_ITEM(glb.hwndFrame,IDM_FILE_PRINT);%@NL@%
            DISABLE_MENU_ITEM(glb.hwndFrame,IDM_FILE_PRINTER_SETUP);%@NL@%
        }%@NL@%
%@NL@%
        strcat(ach," - ");                // Append file name%@NL@%
        strcat(ach,glb.pszFile);%@NL@%
    }%@NL@%
    WinSetWindowText(glb.hwndFrame,ach); // Set title%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        ReadData - read stock data from file%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hwnd         - Hwnd for status messages%@NL@%
%@AB@% *            glb.pszFile  - File to read%@NL@%
%@AB@% *            glb.hprtlist - Printer list%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns TRUE%@NL@%
%@AB@% *                apt[][]  = Filled in with price data%@NL@%
%@AB@% *                glb.cpt  = Count of points read%@NL@%
%@AB@% *                glb.pMax = Maximum price%@NL@%
%@AB@% *                glb.pMin = Minimum price%@NL@%
%@AB@% *                glb.hprt = May have change, to file job properties%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns FALSE%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL ReadData(HWND hwnd)%@NL@%
{%@NL@%
    static char   ach[CCHMAXPATH];%@NL@%
    static USHORT cb;%@NL@%
    int           cf;%@NL@%
    USHORT          factorSplit;%@NL@%
    USHORT          fracClose;%@NL@%
    USHORT          fracHigh;%@NL@%
    USHORT          fracLow;%@NL@%
    HPRINTER          hprt;%@NL@%
    int           i;%@NL@%
    USHORT          intClose;%@NL@%
    USHORT          intHigh;%@NL@%
    USHORT          intLow;%@NL@%
    int           j;%@NL@%
    char *          pb;%@NL@%
    char *          pch;%@NL@%
    char *          pch1;%@NL@%
    FILE *          pfile;%@NL@%
    ULONG          ulVol;%@NL@%
%@NL@%
    WinSetPointer(HWND_DESKTOP,hptrWait); // Tell user we are being slow%@NL@%
%@NL@%
    glb.cpt = 0;%@NL@%
    glb.fNewJobProp = FALSE;                // Job properties not changed%@NL@%
    SetFileMenu();%@NL@%
%@NL@%
    pfile = fopen(glb.pszFile,"r");%@NL@%
    if (pfile == NULL) {%@NL@%
        WinSetPointer(HWND_DESKTOP,hptrNormal); // Tell user we are done%@NL@%
        sprintf(achMisc,"Could not open \"%s\"",glb.pszFile);%@NL@%
        Message(achMisc,hwnd);%@NL@%
        return FALSE;%@NL@%
    }%@NL@%
%@NL@%
    fgets(ach,cchMax,pfile);   // skip two header lines%@NL@%
    fgets(ach,cchMax,pfile);%@NL@%
    fgets(ach,cchMax,pfile);   // Get first data line%@NL@%
    while (!feof(pfile)) {%@NL@%
        if (glb.cpt > cptMax) {%@NL@%
            WinSetPointer(HWND_DESKTOP,hptrNormal); // Tell user we are done%@NL@%
            sprintf(achMisc,"Too many data points. Max is %d.",cptMax);%@NL@%
            Message(achMisc,hwnd);%@NL@%
// BUGBUG 03-May-1990 bens Should continue with truncated data?%@NL@%
//%@NL@%
// Should make file read a separate function, and do min/max computation%@NL@%
// as long as some data was read.%@NL@%
//%@NL@%
        return FALSE;%@NL@%
        }%@NL@%
%@NL@%
        // Skip date%@NL@%
        pch = strchr(ach,'"')+1;        // pch        -> 04/24/60",....%@NL@%
        pch1 = strchr(pch,'"');         // pch1 ->           ",....%@NL@%
        *pch1 = '\0';                        // Split string at end of date%@NL@%
        pch1 += 2;                        // Skip ",%@NL@%
%@NL@%
        cf = sscanf(pch1," %d.%d, %d.%d, %d.%d, %ld",%@NL@%
              &intHigh,&fracHigh,&intLow,&fracLow,&intClose,&fracClose,&ulVol);%@NL@%
%@NL@%
        if (cf != 7) {%@NL@%
            WinSetPointer(HWND_DESKTOP,hptrNormal); // Tell user we are done%@NL@%
            // Adjust count for two header lines, plus base 0%@NL@%
            sprintf(achMisc,"Line %d is bad: [%s]",glb.cpt+3,ach);%@NL@%
            Message(achMisc,hwnd);%@NL@%
// BUGBUG 03-May-1990 bens What to do now?%@NL@%
//%@NL@%
// On par with previous BUGBUG, we should probably display data up to the%@NL@%
// point where it was bad.%@NL@%
//%@NL@%
// Also, it would be nice to give a hint about the problem.%@NL@%
//%@NL@%
// At a minimum, tell if too many or too few data points.%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
%@NL@%
        // convert to units of 8 points%@NL@%
        intHigh  = (intHigh  << 3) + (fracHigh        / 125);%@NL@%
        intLow         = (intLow   << 3) + (fracLow        / 125);%@NL@%
        intClose = (intClose << 3) + (fracClose / 125);%@NL@%
%@NL@%
        if (stricmp(pch,"SPLIT") == 0) {%@NL@%
            factorSplit = intHigh/8;%@NL@%
            for (i=0; i<(int) glb.cpt; i++)            // Process all saved records%@NL@%
                for (j=0; j<NV; j++)        // Process dollar values%@NL@%
                    apt[j][i] /= factorSplit;%@NL@%
                // dP(iV, j%) *= factorSplit;%@NL@%
        }%@NL@%
        else {%@NL@%
            apt[iH][glb.cpt] = intHigh;%@NL@%
            apt[iL][glb.cpt] = intLow;%@NL@%
            apt[iC][glb.cpt] = intClose;%@NL@%
            glb.cpt++;%@NL@%
        }%@NL@%
        fgets(ach,cchMax,pfile);        // Get next data line%@NL@%
    }%@NL@%
    fclose(pfile);%@NL@%
%@NL@%
    // Find max and min prices%@NL@%
%@NL@%
    // Speed win: prime min/max with real value.%@NL@%
    //        This allows the if..else if below to work reliably.%@NL@%
%@NL@%
    glb.pMax = apt[0][0];%@NL@%
    glb.pMin = apt[0][0];%@NL@%
%@NL@%
    for (i=0; i<(int)glb.cpt; i++) {%@NL@%
        for (j=0; j<NV; j++) {%@NL@%
            if (apt[j][i] > glb.pMax)%@NL@%
                glb.pMax = apt[j][i];%@NL@%
            else if (apt[j][i] < glb.pMin)%@NL@%
                glb.pMin = apt[j][i];%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    // Select printer, based on job properties%@NL@%
%@NL@%
    pb = EAQueryValue(glb.pszFile,pszJobProp,&cb);%@NL@%
    if (pb == NULL) {                        // No job prop, use default printer%@NL@%
        WinSetPointer(HWND_DESKTOP,hptrNormal); // Tell user we are done%@NL@%
        return TRUE;                        //  Done%@NL@%
    }%@NL@%
    if (cb == 0) {                        // Data is not binary%@NL@%
        MemFree(pb);                        // Free buffer%@NL@%
        WinSetPointer(HWND_DESKTOP,hptrNormal); // Tell user we are done%@NL@%
        return TRUE;                        //  Done%@NL@%
    }%@NL@%
%@NL@%
    // Try to match a printer%@NL@%
%@NL@%
    hprt = PrintMatchPrinter(glb.hprtlist,cb,pb);%@NL@%
    if (hprt != NULL)                        // Got a match!%@NL@%
        glb.hprt = hprt;                // Set new printer%@NL@%
%@NL@%
    MemFree(pb);                        // Free buffer%@NL@%
%@NL@%
    SetFileMenu();                        // Update menus and title bar%@NL@%
%@NL@%
    WinSetPointer(HWND_DESKTOP,hptrNormal); // Tell user we are done%@NL@%
    return TRUE;                        //  Done%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PlotPrice - plot stock price%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hps - Presentation space to plot to%@NL@%
%@AB@% *            rcl - Bounding rectangle in hps%@NL@%
%@AB@% *%@NL@%
%@AB@% *            apt[][]  = Filled in with price data%@NL@%
%@AB@% *            glb.cpt  = Count of points read%@NL@%
%@AB@% *            glb.pMax = Maximum price%@NL@%
%@AB@% *            glb.pMin = Minimum price%@NL@%
%@AB@% *            glb.hprt = May have change, to file job properties%@NL@%
%@AB@% *            glb.fZeroOrigin - TRUE => make Y-origin be 0.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            Stock chart plotted%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID PlotPrice(HPS hps,RECTL rcl)%@NL@%
{%@NL@%
    SHORT   cxBar;%@NL@%
    int     i;%@NL@%
    POINTL  ptl;%@NL@%
    SHORT   x;%@NL@%
    float   xFactor;%@NL@%
    SHORT   xMargin = 4;%@NL@%
    SHORT   yC;%@NL@%
    float   yFactor;%@NL@%
    SHORT   yH;%@NL@%
    SHORT   yL;%@NL@%
    SHORT   yMargin = 4;%@NL@%
    SHORT   yOrigin;%@NL@%
%@NL@%
    if (glb.cpt == 0)                        // No points to draw%@NL@%
        return;%@NL@%
%@NL@%
    if (glb.fZeroOrigin)%@NL@%
        yOrigin = 0;%@NL@%
    else%@NL@%
        yOrigin = glb.pMin;%@NL@%
%@NL@%
    yFactor = (float)(rcl.yTop - rcl.yBottom - (LONG)(2*yMargin)) /%@NL@%
              (float)(glb.pMax-yOrigin);%@NL@%
    xFactor = (float)(rcl.xRight - rcl.xLeft - (LONG)(2*xMargin)) /%@NL@%
              (float)(glb.cpt);%@NL@%
%@NL@%
    cxBar = (USHORT)(xFactor/2.0);%@NL@%
    if (cxBar < 1)%@NL@%
        cxBar = 1;%@NL@%
%@NL@%
    WinSetPointer(HWND_DESKTOP,hptrWait); // Tell user we are being slow%@NL@%
%@NL@%
    for (i=0; i<(int)glb.cpt; i++) {%@NL@%
            x = (USHORT)(i*(float)xFactor) + xMargin;%@NL@%
            yH = (USHORT)((float)(apt[iH][i]-yOrigin)*yFactor) + yMargin;%@NL@%
            yL = (USHORT)((float)(apt[iL][i]-yOrigin)*yFactor) + yMargin;%@NL@%
            yC = (USHORT)((float)(apt[iC][i]-yOrigin)*yFactor) + yMargin;%@NL@%
%@NL@%
            // Draw vertical (low to high) bar%@NL@%
%@NL@%
            GpiSetColor(hps,CLR_CYAN);%@NL@%
%@NL@%
            ptl.x = x;%@NL@%
            ptl.y = yL;%@NL@%
            GpiMove(hps,&ptl);%@NL@%
%@NL@%
            ptl.y = yH;%@NL@%
            GpiLine(hps,&ptl);%@NL@%
%@NL@%
            // Draw horizontal (close) bar%@NL@%
%@NL@%
            GpiSetColor(hps,CLR_RED);%@NL@%
%@NL@%
            ptl.x = x;%@NL@%
            ptl.y = yC;%@NL@%
            GpiMove(hps,&ptl);%@NL@%
%@NL@%
            ptl.x += cxBar;%@NL@%
            GpiLine(hps,&ptl);%@NL@%
    }%@NL@%
    WinSetPointer(HWND_DESKTOP,hptrNormal); // Tell user we are done%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        AboutDlgProc - "About..." Dialog Procedure%@NL@%
%@AB@%*%@NL@%
%@AB@%*/%@AE@%%@NL@%
MRESULT EXPENTRY AboutDlgProc(HWND hwnd,USHORT msg,MPARAM mp1,MPARAM mp2)%@NL@%
{%@NL@%
    switch (msg) {%@NL@%
        case WM_COMMAND:%@NL@%
            switch (SHORT1FROMMP(mp1)) {%@NL@%
                case DID_OK:%@NL@%
                    WinDismissDlg(hwnd,TRUE);%@NL@%
                    return FALSE;%@NL@%
            }%@NL@%
            break;%@NL@%
    }%@NL@%
    return WinDefDlgProc(hwnd,msg,mp1,mp2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        PrinterSetupDlgProc - "File Printer Setup..." Dialog Procedure%@NL@%
%@AB@%*%@NL@%
%@AB@%*/%@AE@%%@NL@%
MRESULT EXPENTRY PrinterSetupDlgProc(HWND hwnd,USHORT msg,MPARAM mp1,MPARAM mp2)%@NL@%
{%@NL@%
    static BOOL     fNewJobProp;%@NL@%
    HPRINTER            hprt;%@NL@%
    HWND            hwndLB;%@NL@%
    USHORT            i;%@NL@%
    char *            pszName;%@NL@%
    char *            pszNameDefault;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_INITDLG:%@NL@%
        fNewJobProp = FALSE;%@NL@%
        hwndLB = WinWindowFromID(hwnd, IDL_PRINTER);%@NL@%
        hprt = 0;                        // Enumerate full list of printers%@NL@%
        while ((hprt=PrintQueryNextPrinter(glb.hprtlist,hprt)) != NULL) {%@NL@%
            pszName = (char *)PrintQueryPrinterInfo(hprt,PQPI_NAME);%@NL@%
            // Insert item and store handle%@NL@%
            i = SHORT1FROMMR(WinSendMsg(hwndLB, LM_INSERTITEM,%@NL@%
                           MPFROMSHORT(LIT_SORTASCENDING),MPFROMP(pszName)));%@NL@%
            WinSendMsg(hwndLB,LM_SETITEMHANDLE,%@NL@%
                                          MPFROMSHORT(i),MPFROMP(hprt));%@NL@%
            if (hprt == glb.hprt)        // This is the default printer%@NL@%
                pszNameDefault = pszName; // Save name to set selection%@NL@%
        }%@NL@%
%@NL@%
        // Find default printer and set selection%@NL@%
%@NL@%
        i = SHORT1FROMMR(WinSendMsg(hwndLB,LM_SEARCHSTRING,%@NL@%
                         MPFROM2SHORT(0,LIT_FIRST),MPFROMP(pszNameDefault)));%@NL@%
        WinSendMsg(hwndLB,LM_SELECTITEM,MPFROMSHORT(i),MPFROMSHORT(TRUE));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1)) {%@NL@%
%@NL@%
        case DID_OK:%@NL@%
            hprt = HPRTFromListBox(hwnd); // Get selection%@NL@%
            if (hprt != glb.hprt) {        // Printer destination changed%@NL@%
                glb.hprt = hprt;        // Remember new printer%@NL@%
                fNewJobProp = TRUE;        // Force new job properties%@NL@%
            }%@NL@%
            glb.fNewJobProp = fNewJobProp; // User made change%@NL@%
            SetFileMenu();%@NL@%
            WinDismissDlg(hwnd,TRUE);%@NL@%
            return FALSE;%@NL@%
%@NL@%
        case IDB_SETUP:%@NL@%
            hprt = HPRTFromListBox(hwnd); // Get selection%@NL@%
            if (PrintChangeJobProperties(hprt)) // Properties changed%@NL@%
                fNewJobProp = TRUE;        //  Remember JP changed%@NL@%
            return FALSE;%@NL@%
%@NL@%
        case IDB_RESET:%@NL@%
            hprt = HPRTFromListBox(hwnd); // Get selection%@NL@%
            PrintResetJobProperties(hprt); // Reset job properties%@NL@%
            fNewJobProp = TRUE;         //  Remember JP changed%@NL@%
            return FALSE;%@NL@%
%@NL@%
        case DID_CANCEL:%@NL@%
            WinDismissDlg(hwnd,FALSE);%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
        break;%@NL@%
    }%@NL@%
    return WinDefDlgProc(hwnd,msg,mp1,mp2);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        HPRTFromListBox - Get selected printer%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hwnd - hwnd of Printer Setup dialog%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            hprt of selected printer%@NL@%
%@AB@% */%@AE@%%@NL@%
HPRINTER HPRTFromListBox(HWND hwnd)%@NL@%
{%@NL@%
    HWND    hwndLB;%@NL@%
    USHORT  i;%@NL@%
%@NL@%
    // Get selection%@NL@%
    hwndLB = WinWindowFromID(hwnd, IDL_PRINTER);%@NL@%
    i = SHORT1FROMMR(WinSendDlgItemMsg(hwnd,IDL_PRINTER,LM_QUERYSELECTION,0L,0L));%@NL@%
%@NL@%
    // Get printer handle%@NL@%
%@NL@%
    return (HPRINTER) (ULONG)WinSendMsg(hwndLB,LM_QUERYITEMHANDLE,MPFROMSHORT(i),0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        SaveJobProperties - Save current job properties in EA on file%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            glb.hprt        - printer handle%@NL@%
%@AB@% *            glb.pszFile - file name%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            Job properties saved with file.%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID SaveJobProperties(VOID)%@NL@%
{%@NL@%
    static USHORT   cb;%@NL@%
    char *            pb;%@NL@%
%@NL@%
    if (!glb.fNewJobProp)                // Nothing to save%@NL@%
        return;%@NL@%
%@NL@%
    glb.fNewJobProp = FALSE;                // JP will be saved%@NL@%
%@NL@%
    // Get job properties size%@NL@%
%@NL@%
    WinSetPointer(HWND_DESKTOP,hptrWait); // Tell user we are being slow%@NL@%
%@NL@%
    cb = 0;%@NL@%
    PrintQueryJobProperties(glb.hprt,&cb,pb); // Get size%@NL@%
    if (cb == 0)                        // No job properties to save%@NL@%
        return;                         //  Done%@NL@%
    pb = MemAlloc(cb);                        // Alloc buffer%@NL@%
    if (pb == NULL)                        // Could not get memory%@NL@%
        return;                         //  Done%@NL@%
%@NL@%
    // Get job properties%@NL@%
%@NL@%
    if (!PrintQueryJobProperties(glb.hprt,&cb,pb)) { // failed%@NL@%
        MemFree(pb);                        // Free buffer%@NL@%
        return;                         //  Done%@NL@%
    }%@NL@%
%@NL@%
    // Save new Job Properties with data file%@NL@%
%@NL@%
    EASetValue(glb.pszFile,pszJobProp,cb,pb);%@NL@%
    MemFree(pb);                        // Free buffer%@NL@%
%@NL@%
    WinSetPointer(HWND_DESKTOP,hptrNormal); // Tell user we are done%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        Message - Put up message box%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            psz  - message%@NL@%
%@AB@% *            hwnd - parent window%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit%@NL@%
%@AB@% *            None%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID Message(char *psz, HWND hwnd)%@NL@%
{%@NL@%
    HWND    hwndOwner;%@NL@%
%@NL@%
    if (hwnd == NULL) {%@NL@%
        hwndOwner = glb.hwndClient;%@NL@%
        if (hwndOwner == NULL)%@NL@%
            hwndOwner = HWND_DESKTOP;%@NL@%
    }%@NL@%
    else%@NL@%
        hwndOwner = hwnd;%@NL@%
%@NL@%
    WinMessageBox(%@NL@%
        HWND_DESKTOP,                // parent%@NL@%
        hwndOwner,                // owner%@NL@%
        psz,                        // message%@NL@%
        NULL,                        // caption (use default)%@NL@%
        NULL,                        // window id%@NL@%
        MB_OK | MB_APPLMODAL        // window style%@NL@%
    );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        QueryHCI - Query hardcopy capabilities for current form%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Entry%@NL@%
%@AB@% *            hdc - handle to DC%@NL@%
%@AB@% *            phci - pointer to HCINFO structure%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Success%@NL@%
%@AB@% *            Returns TRUE%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Exit-Failure%@NL@%
%@AB@% *            Returns FALSE%@NL@%
%@AB@% */%@AE@%%@NL@%
BOOL QueryHCI(HDC hdc,HCINFO *phci)%@NL@%
{%@NL@%
    LONG    cForms;%@NL@%
    LONG    i;%@NL@%
    LONG    rc;%@NL@%
%@NL@%
    cForms = DevQueryHardcopyCaps(hdc,0L,0L,phci); // Get form count%@NL@%
    if (cForms == 0)%@NL@%
        return FALSE;                        // No forms!%@NL@%
%@NL@%
    for (i=0; i<cForms; i++) {%@NL@%
        rc = DevQueryHardcopyCaps(hdc,i,1L,phci); // Get info for this form%@NL@%
        if (rc == 1) {                        // Got info%@NL@%
            if (phci->flAttributes & HCAPS_CURRENT) { // Have current form%@NL@%
                return TRUE;                // Return data%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
    return FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%STUBS.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CPGREP\STUBS.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%; stubs.asm - a module of empty stubs to keep the BINDer from%@AE@%%@NL@%
%@AB@%; complaining.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Created by Microsoft Corp. 1986%@AE@%%@NL@%
%@NL@%
.286p%@NL@%
%@NL@%
        public DOSCREATETHREAD%@NL@%
        public DOSSEMCLEAR%@NL@%
        public DOSSEMREQUEST%@NL@%
        public DOSSEMSET%@NL@%
        public DOSSEMWAIT%@NL@%
        public DOSSLEEP%@NL@%
%@NL@%
code        segment byte public 'CODE'%@NL@%
        assume        cs:code%@NL@%
%@NL@%
DOSCREATETHREAD:%@NL@%
DOSSEMCLEAR:%@NL@%
DOSSEMREQUEST:%@NL@%
DOSSEMSET:%@NL@%
DOSSEMWAIT:%@NL@%
DOSSLEEP:%@NL@%
        ret%@NL@%
%@NL@%
code        ends%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SUSPEND.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SUSPEND\SUSPEND.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * Example of DosSuspendThread/DosResumeThread usage.%@NL@%
%@AB@% *%@NL@%
%@AB@% * DosSuspendThread can be used to ensure mutual exclusion when a thread%@NL@%
%@AB@% * knows by number all the other threads which might try to access the%@NL@%
%@AB@% * shared resource.%@NL@%
%@AB@% * %@NL@%
%@AB@% * In this example the main thread can call printf() freely because it%@NL@%
%@AB@% * knows that the only other thread has been suspended, so the main%@NL@%
%@AB@% * thread will not be interrupted, and because it knows that the%@NL@%
%@AB@% * subthread must have been suspended while outside of a critical%@NL@%
%@AB@% * section, and so the main thread will not be interrupting the%@NL@%
%@AB@% * subthread's call to vio.%@NL@%
%@AB@% * %@NL@%
%@AB@% * Any thread may suspend any other thread in its process, including the%@NL@%
%@AB@% * main thread and itself.  If a thread suspends all the threads in a%@NL@%
%@AB@% * process, including itself, then deadlock will result, and the process%@NL@%
%@AB@% * will have to be killed externally.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Note that there are three methods for managing critical sections%@NL@%
%@AB@% * amongst threads in a process:%@NL@%
%@AB@% *%@NL@%
%@AB@% *        1. Semaphores - this is almost always the right solution%@NL@%
%@AB@% *        2. DosEnterCritSec%@NL@%
%@AB@% *        3. DosSuspendThread%@NL@%
%@AB@% *%@NL@%
%@AB@% * compile as: cl -Gs -AL -G2 -Lp suspend.c%@NL@%
%@AB@% *%@NL@%
%@AB@% * Created by Microsoft Corp. 1986%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_SUB %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2def.h> %@NL@%
%@AI@%#include %@AE@%<bse.h> %@NL@%
%@AI@%#include %@AE@%"stdio.h" %@NL@%
%@AI@%#include %@AE@%"malloc.h" %@NL@%
%@AI@%#define %@AE@%STACK_SIZE        1024 %@NL@%
%@NL@%
extern void f_thread(void);%@NL@%
int flag;%@NL@%
%@NL@%
void main()%@NL@%
{%@NL@%
        char *stkptr;%@NL@%
        TID thread_id;%@NL@%
        register int i;%@NL@%
        %@NL@%
        %@AB@%/* obtain pointer to the END of a block of memory */%@AE@%%@NL@%
        stkptr = (char *)malloc(STACK_SIZE) + STACK_SIZE - 1;%@NL@%
        %@NL@%
        %@AB@%/* create another thread */%@AE@%%@NL@%
        DosCreateThread(f_thread, &thread_id, stkptr);%@NL@%
        %@NL@%
        for(i = 0; i < 20; i++) {%@NL@%
                DosSuspendThread(thread_id);        %@AB@%/* suspend the subthread */%@AE@%%@NL@%
        %@NL@%
                printf("the main thread has suspended thread %u\n", thread_id);%@NL@%
                DosSleep(3000L);%@NL@%
        %@NL@%
                %@AB@%/* resume the subthread */%@AE@%%@NL@%
                printf("now resuming the suspended thread\n");%@NL@%
                DosResumeThread(thread_id);%@NL@%
%@NL@%
                DosSleep(3000L);%@NL@%
        }%@NL@%
        DosExit(EXIT_PROCESS, 0);           %@AB@%/* exit all threads */%@AE@%%@NL@%
}%@NL@%
%@NL@%
void f_thread()%@NL@%
{%@NL@%
        while (1) {%@NL@%
                DosEnterCritSec();%@NL@%
                VioWrtTTY("subthread running\r\n", 19, 0);%@NL@%
                DosExitCritSec();%@NL@%
                DosSleep(300L);%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SYMBOL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SPY\SYMBOL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%%@NL@%
%@AB@%Module Name: SYMBOL.C%@NL@%
%@AB@%%@NL@%
%@AB@%This module contains the code for displaying symbols for a specified address.%@NL@%
%@AB@%%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%       INCL_GPILCIDS %@NL@%
%@AI@%#define %@AE@%       INCL_WINDIALOGS %@NL@%
%@AI@%#define %@AE@%       INCL_WINFRAMEMGR %@NL@%
       INCL_WINHEAP                        %@AB@%/* needed for spy.h */%@AE@%%@NL@%
%@AI@%#define %@AE@%       INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%       INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%       INCL_WINMENUS %@NL@%
%@AI@%#define %@AE@%       INCL_WINMESSAGEMGR %@NL@%
       INCL_WINPOINTERS                %@AB@%/* needed for spy.h */%@AE@%%@NL@%
%@AI@%#define %@AE@%       INCL_WINWINDOWMGR %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"spy.h" %@NL@%
%@AI@%#include %@AE@%"spyhook.h" %@NL@%
%@AI@%#include %@AE@%"symbol.h" %@NL@%
%@NL@%
WHOISINFO whoIs;%@NL@%
MAPDEF mapdef;%@NL@%
MAPEND mapend;%@NL@%
SEGDEF segdef;%@NL@%
SYMDEF symdef;%@NL@%
%@NL@%
extern VOID lstrcat(PSZ, PSZ);%@NL@%
extern void OutputString(char [], SHORT);       %@AB@%/* Output string to output devices */%@AE@%%@NL@%
extern  BOOL FValidPointer (CHAR FAR *pVoid, SHORT cbStruct);%@NL@%
extern  BOOL FGuessValidPointer (CHAR FAR *pVoid, SHORT cbStruct);%@NL@%
%@NL@%
%@NL@%
extern HWND     hwndSpyFrame;%@NL@%
extern HAB      hab;%@NL@%
%@NL@%
%@AB@%/* Function prototypes */%@AE@%%@NL@%
HWND HwndFrameFromPID(PID);%@NL@%
VOID GetSymbolInformation(PID, char far *, char *);%@NL@%
VOID NEAR ProcessLNOkButton(HWND);%@NL@%
MRESULT NEAR FormatLNDialog(HWND, PSWP, PRECTL);%@NL@%
VOID NEAR EndLNDialog(HWND);%@NL@%
MRESULT EXPENTRY ListNearDlgProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* hwnd HwndFrameFromPID(pid)%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function attempts to locate a frame window that was%@NL@%
%@AB@%* created by the specified PID. It returns NULL if none are found.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HWND HwndFrameFromPID(pid)%@NL@%
PID             pid;%@NL@%
{%@NL@%
    HENUM       henum;%@NL@%
    HWND        hwnd;%@NL@%
    PID         pidWindow;%@NL@%
    TID         tidWindow;%@NL@%
    char        szClassName[50];    %@AB@%/* Class name of window */%@AE@%%@NL@%
    CLASSINFO   classinfo;          %@AB@%/* Information about class */%@AE@%%@NL@%
%@NL@%
    henum = WinBeginEnumWindows(HWND_DESKTOP);%@NL@%
    if (henum == NULL)%@NL@%
        return (NULL);%@NL@%
%@NL@%
    while ((hwnd = WinGetNextWindow(henum)) != NULL) {%@NL@%
        WinQueryWindowProcess(hwnd, &pidWindow, &tidWindow);%@NL@%
        WinLockWindow(hwnd, FALSE);%@NL@%
        if (pid == pidWindow) {%@NL@%
            %@AB@%/* See if a frame window */%@AE@%%@NL@%
            WinQueryClassName(hwnd, sizeof(szClassName),%@NL@%
                (PSZ)szClassName);%@NL@%
            if (WinQueryClassInfo(hab, (PSZ)szClassName, &classinfo) &&%@NL@%
                    (classinfo.flClassStyle & CS_FRAME))%@NL@%
                break;  %@AB@%/* We have our frame */%@AE@%%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    WinEndEnumWindows(henum);%@NL@%
    return (hwnd);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* int IdentifyCodeSegment(lpSegInfo, pid, selector)%@NL@%
%@AB@%*%@NL@%
%@AB@%*            Identifies the code selector for the specified process.%@NL@%
%@AB@%*          NOTE: The process is currently ignored, but later will somehow%@NL@%
%@AB@%*          return information in the context of the specified process ID.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
int%@NL@%
pascal near IdentifyCodeSegment( pSegInfo, pid, selector )%@NL@%
PSEGINFO   pSegInfo;%@NL@%
PID         pid;%@NL@%
USHORT      selector;%@NL@%
{%@NL@%
    char far *lp;%@NL@%
    char    *np;%@NL@%
    int     n;%@NL@%
    BYTE    c;%@NL@%
    USHORT  segnum;%@NL@%
    USHORT  seg_ptr;%@NL@%
    USHORT  uTemp;%@NL@%
    int     rc;%@NL@%
    PIDINFO pidinfo;%@NL@%
    HWND    hwndPIDFrame;%@NL@%
%@NL@%
    %@AB@%/* If new selector matches the current one, then nothing to do */%@AE@%%@NL@%
    if ((pSegInfo->pid == pid) && (pSegInfo->selector == selector))%@NL@%
        return 0;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Try to identify the code selector.  We will first try in the context%@NL@%
%@AB@%     * of our process.  If this fails, or if we find that the segment is%@NL@%
%@AB@%     * associated with our program and it is not our PID, we will attempt%@NL@%
%@AB@%     * to get the symbol in the specified PID context, with the help of%@NL@%
%@AB@%     * our hooks.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    DosGetPID(&pidinfo);%@NL@%
    rc = IdentifyCodeSelector( selector, (PWHOISINFO)&whoIs );%@NL@%
    if ((pid != pidinfo.pid) && (rc == 0)) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * User asked for a different context, and symbol was found.%@NL@%
%@AB@%         * If the symbol was in our .exe we will ignore what we found,%@NL@%
%@AB@%         * and try again.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        %@AB@%/* First get past the module name */%@AE@%%@NL@%
        np = whoIs.names;%@NL@%
        while (*np++)%@NL@%
            ;%@NL@%
        %@AB@%/* Now go through the pathname */%@AE@%%@NL@%
        while (*np) {%@NL@%
            if (*np++ == '.') {%@NL@%
                if (strcmp(np,"EXE") == 0) {%@NL@%
                    rc = 1;     %@AB@%/* It is in our exe, so set errr condition */%@AE@%%@NL@%
                    break;  %@AB@%/* no need to go on */%@AE@%%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (rc) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * We need to try in other PID context%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((pid == pidinfo.pid) ||%@NL@%
                ((hwndPIDFrame = HwndFrameFromPID(pid)) == NULL))%@NL@%
            return (rc);    %@AB@%/* segment not found or no way to find segment */%@AE@%%@NL@%
%@NL@%
        %@AB@%/* Lets use the hook */%@AE@%%@NL@%
        SpySetLNSymbolPID(pid, selector);%@NL@%
%@NL@%
        %@AB@%/* HACK: Send message to frame known to send another message */%@AE@%%@NL@%
        WinSendMsg(hwndPIDFrame, WM_QUERYTASKFOCUS, 0L, 0L);%@NL@%
%@NL@%
        if (SpyGetLNSymbolSelector(&whoIs) != 0)%@NL@%
            return (1);     %@AB@%/* Still did not find the symbol */%@AE@%%@NL@%
%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* It is a valid code selector, make it the new current selector */%@AE@%%@NL@%
    pSegInfo->selector = selector;%@NL@%
    pSegInfo->pid = pid;%@NL@%
%@NL@%
    %@AB@%/* Is the new selector in the same module? */%@AE@%%@NL@%
    if (pSegInfo->lpSegName && pSegInfo->whoIs.mte == whoIs.mte)%@NL@%
        pSegInfo->whoIs.segNum = whoIs.segNum;     %@AB@%/* Yes, just copy seg# */%@AE@%%@NL@%
    else {%@NL@%
%@NL@%
        %@AB@%/* New module, get segment #, mte handle, module name and pathstring */%@AE@%%@NL@%
        pSegInfo->whoIs    = whoIs;%@NL@%
%@NL@%
        %@AB@%/* Generate separate pointers to module name and pathstring */%@AE@%%@NL@%
        lp = &pSegInfo->whoIs.names[0];%@NL@%
        pSegInfo->lpModName = lp;%@NL@%
        while (*lp++)%@NL@%
            ;%@NL@%
        pSegInfo->lpPathName = lp;%@NL@%
%@NL@%
        %@AB@%/* Change pathstring extension to be .SYM */%@AE@%%@NL@%
        while (*lp)%@NL@%
            if (*lp++ == '.') {%@NL@%
                *lp++ = 'S';%@NL@%
                *lp++ = 'Y';%@NL@%
                *lp++ = 'M';%@NL@%
                }%@NL@%
        lp++;%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * No current segment name or symbol name, so make them point to%@NL@%
%@AB@%         * null string%@NL@%
%@AB@%         */%@AE@%%@NL@%
        *lp = 0;%@NL@%
        pSegInfo->lpSegName = lp;%@NL@%
        pSegInfo->lpSymName = 0L;%@NL@%
%@NL@%
        %@AB@%/* Close any currently open .SYM file and then open the new .SYM file */%@AE@%%@NL@%
        if (pSegInfo->symfh != -1)%@NL@%
            pSegInfo->symfh = DosClose((HFILE)pSegInfo->symfh );%@NL@%
%@NL@%
        if (DosOpen(pSegInfo->lpPathName, (PHFILE)&pSegInfo->symfh,%@NL@%
                (PUSHORT)&uTemp,%@NL@%
                0L, 0, 1, 0x00c0, 0L) == 0) {%@NL@%
%@NL@%
            %@AB@%/* Read in .SYM file header and save segment count and pointer */%@AE@%%@NL@%
%@NL@%
            DebugFileRead( pSegInfo->symfh, (PSZ)&mapdef, sizeof( mapdef ) );%@NL@%
            pSegInfo->segcnt = mapdef.seg_cnt;%@NL@%
            pSegInfo->segptr = mapdef.seg_ptr;%@NL@%
%@NL@%
            %@AB@%/*        Read version of MAPSYM that produced this file.%@NL@%
%@AB@%                If not a version 4 file then ignore the file */%@AE@%%@NL@%
%@NL@%
            DebugFileSeek( pSegInfo->symfh, (long)-sizeof( mapend ), 2 );%@NL@%
            DebugFileRead( pSegInfo->symfh, (PSZ)&mapend, sizeof( mapend ) );%@NL@%
            if (mapend.ver != 4)%@NL@%
                pSegInfo->symfh = DosClose( (HFILE)pSegInfo->symfh );%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
%@AB@%/* Point to segment name buffer and make it a null string for now */%@AE@%%@NL@%
%@NL@%
    lp = pSegInfo->lpSegName;%@NL@%
    *lp = 0;%@NL@%
%@NL@%
%@AB@%/* If we have an open .SYM file, search for segment definition record */%@AE@%%@NL@%
%@NL@%
    if (pSegInfo->symfh != -1 && (SHORT) pSegInfo->whoIs.segNum < pSegInfo->segcnt) {%@NL@%
%@NL@%
    %@AB@%/* Start with first segment definition and read segNum definitions */%@AE@%%@NL@%
%@NL@%
        seg_ptr = pSegInfo->segptr;%@NL@%
        n = pSegInfo->whoIs.segNum;%@NL@%
        while (n--) {%@NL@%
            DebugFileSeek( pSegInfo->symfh, (long)seg_ptr, 4 );%@NL@%
            DebugFileRead( pSegInfo->symfh, (PSZ)&segdef, sizeof( segdef ) );%@NL@%
            seg_ptr = (USHORT)segdef.nxt_seg;%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/* Now read in the segment name string associated with this segment%@NL@%
%@AB@%       and make it a null terminated string */%@AE@%%@NL@%
%@NL@%
        DebugFileRead( pSegInfo->symfh, (PSZ)(lp),%@NL@%
                       (int)((BYTE)segdef.nam_len) );%@NL@%
        lp += segdef.nam_len;%@NL@%
        *lp++ = 0;%@NL@%
%@NL@%
    %@AB@%/* Remember the count of symbols for this segment */%@AE@%%@NL@%
%@NL@%
        pSegInfo->symcnt = segdef.sym_cnt;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Remember the file offset of the symbols for this segment, which is%@NL@%
%@AB@%       immediately after the segment definition record and name we just read */%@AE@%%@NL@%
%@NL@%
        pSegInfo->symFPos = DebugFileSeek( pSegInfo->symfh, 0L, 1 );%@NL@%
        }%@NL@%
    else {%@NL@%
    %@AB@%/* If no .SYM file or segment number too big, then make the segnemt name%@NL@%
%@AB@%       be the hex representation of its number */%@AE@%%@NL@%
%@NL@%
        pSegInfo->symcnt = 0;%@NL@%
%@NL@%
        segnum = pSegInfo->whoIs.segNum;%@NL@%
        n = 4;%@NL@%
        lp += n;%@NL@%
        while (n--) {%@NL@%
            c = (char)(segnum & (USHORT)0xF);%@NL@%
            segnum >>= 4;%@NL@%
            if (c > 9)%@NL@%
                c += 'A' - 10;%@NL@%
            else%@NL@%
                c += '0';%@NL@%
            *--lp = c;%@NL@%
            *lp++ = 0;%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/* Null terminate the segment name string */%@AE@%%@NL@%
%@NL@%
        lp += 4;%@NL@%
        *lp++ = 0;%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/* Initialize the symbol name pointer to point to a null string, immediately%@NL@%
%@AB@%   after the segment name string just created above. */%@AE@%%@NL@%
%@NL@%
    pSegInfo->lpSymName = lp;%@NL@%
    *lp = 0;%@NL@%
%@NL@%
    return 0;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
USHORT%@NL@%
pascal near FindSymbol( pSegInfo, offset )%@NL@%
PSEGINFO pSegInfo;%@NL@%
USHORT offset;%@NL@%
{%@NL@%
    USHORT i;%@NL@%
    long symPos;%@NL@%
    char far *lp;%@NL@%
%@NL@%
%@AB@%/* If no .SYM file then return failure */%@AE@%%@NL@%
%@NL@%
    if (pSegInfo->symfh == -1)%@NL@%
        return 0xFFFF;%@NL@%
%@NL@%
%@AB@%/* No symbol found yet, so make it a null string */%@AE@%%@NL@%
%@NL@%
    lp = pSegInfo->lpSymName;%@NL@%
    *lp = 0;%@NL@%
%@NL@%
%@AB@%/* Now do a linear search of the symbol definitions for this segment, looking%@NL@%
%@AB@%   for the closest match.  The definitions are stored in sorted order */%@AE@%%@NL@%
%@NL@%
    symPos = DebugFileSeek( pSegInfo->symfh, (long)pSegInfo->symFPos, 0 );%@NL@%
    i = (USHORT)pSegInfo->symcnt;%@NL@%
    while (i--) {%@NL@%
        DebugFileRead( pSegInfo->symfh, (PSZ)&symdef, sizeof( symdef ) );%@NL@%
%@NL@%
    %@AB@%/* If this is not our symbol then just remember its offset */%@AE@%%@NL@%
%@NL@%
        if ((USHORT)symdef.sym_val <= offset) {%@NL@%
            symPos = DebugFileSeek( pSegInfo->symfh, 0L, 1 ) -%@NL@%
                     sizeof( symdef );%@NL@%
%@NL@%
        %@AB@%/* If exact match, exit this loop */%@AE@%%@NL@%
%@NL@%
            if ((USHORT)symdef.sym_val == offset)%@NL@%
                break;%@NL@%
            }%@NL@%
        else%@NL@%
        %@AB@%/* If we went past then exit this loop */%@AE@%%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
    %@AB@%/* Still looking, so seek past this symbols name string to next symbol%@NL@%
%@AB@%       definition */%@AE@%%@NL@%
%@NL@%
        DebugFileSeek( pSegInfo->symfh, (long)symdef.nam_len, 1 );%@NL@%
        }%@NL@%
%@NL@%
%@AB@%/* Seek to found symdebol definition and read it in, along with the name */%@AE@%%@NL@%
%@NL@%
    DebugFileSeek( pSegInfo->symfh, (long)symPos, 0 );%@NL@%
    DebugFileRead( pSegInfo->symfh, (PSZ)&symdef,%@NL@%
                   sizeof( symdef ) );%@NL@%
    DebugFileRead( pSegInfo->symfh, (PSZ)lp,%@NL@%
                   (int)((BYTE)symdef.nam_len) );%@NL@%
%@NL@%
%@AB@%/* Make the name a null terminated string */%@AE@%%@NL@%
%@NL@%
    lp += symdef.nam_len;%@NL@%
    *lp++ = 0;%@NL@%
%@NL@%
%@AB@%/* Return the distance of the passed offset from the value of the symbol */%@AE@%%@NL@%
%@NL@%
    return offset - symdef.sym_val;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*************************************************************************%@NL@%
%@AB@% *%@NL@%
%@AB@% * GetSymbolInformation(pid, pvoidInfo, pszInfo)%@NL@%
%@AB@% *%@NL@%
%@AB@% * Purpose: To get information about the supplied address%@NL@%
%@AB@% */%@AE@%%@NL@%
VOID GetSymbolInformation(pid, pvoidInfo, pszInfo)%@NL@%
PID             pid;%@NL@%
char far        *pvoidInfo;%@NL@%
char            *pszInfo;%@NL@%
{%@NL@%
    SEGINFO     seginfo;%@NL@%
    char        szTemp[256];%@NL@%
    USHORT      uOffsetFromSym;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * First try to find the segment in the segment table.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (IdentifyCodeSegment(&seginfo, pid, SELECTOROF(pvoidInfo)) != 0) {%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * It failed to find the segment, ie it was invalid, so%@NL@%
%@AB@%         * Simply return INVALID to caller%@NL@%
%@AB@%         */%@AE@%%@NL@%
        sprintf(pszInfo,"PID:%d %04x:%04x - INVALID", (SHORT)pid,%@NL@%
                SELECTOROF(pvoidInfo), OFFSETOF(pvoidInfo));%@NL@%
        return;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    sprintf(pszInfo,"PID:%d %04x:%04x - %Fs ! ", (SHORT)pid,%@NL@%
            SELECTOROF(pvoidInfo), OFFSETOF(pvoidInfo),%@NL@%
            seginfo.lpModName);%@NL@%
%@NL@%
    if (seginfo.symfh == -1) {%@NL@%
        sprintf(szTemp,"%04x", seginfo.whoIs.segNum);%@NL@%
        strcat(pszInfo, szTemp);%@NL@%
    } else {%@NL@%
        lstrcat((PSZ)pszInfo, seginfo.lpSegName);%@NL@%
    }%@NL@%
%@NL@%
    uOffsetFromSym = FindSymbol(&seginfo, OFFSETOF(pvoidInfo));%@NL@%
    if (uOffsetFromSym != 0xffff) {%@NL@%
        strcat(pszInfo, ":");%@NL@%
%@NL@%
        lstrcat((PSZ)pszInfo, seginfo.lpSymName);%@NL@%
        if (uOffsetFromSym != 0) {%@NL@%
            sprintf(szTemp, "+%x", uOffsetFromSym);%@NL@%
            strcat(pszInfo, szTemp);%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* VOID NEAR ProcessLNOkButton(hwndDlg)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Process the Ok Button for the List Near Dlg proc%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
VOID NEAR ProcessLNOkButton(hwndDlg)%@NL@%
HWND hwndDlg;%@NL@%
{%@NL@%
    char        szTemp[100];%@NL@%
    char far    *pVoid;%@NL@%
    PID         pid;%@NL@%
    SHORT       item;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * For now try using sscanf to convert the string into a%@NL@%
%@AB@%     * pointer.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinQueryDlgItemShort(hwndDlg, DID_PID, &pid, FALSE);%@NL@%
    WinQueryDlgItemText(hwndDlg, DID_ADDR, sizeof(szTemp), szTemp);%@NL@%
    if ((strchr(szTemp,':') != NULL) && (sscanf(szTemp,"%p", &pVoid)) > 0) {%@NL@%
        %@AB@%/* It translated, so try to get info about pointer */%@AE@%%@NL@%
        GetSymbolInformation(pid, pVoid, szTemp);%@NL@%
%@NL@%
        %@AB@%/* For now simply output to output areas */%@AE@%%@NL@%
        item = SHORT1FROMMR(WinSendDlgItemMsg(hwndDlg, DID_SYMLIST,%@NL@%
                LM_INSERTITEM, (MPARAM)LIT_END, (MPARAM)(PSZ)szTemp));%@NL@%
%@NL@%
        WinSendDlgItemMsg(hwndDlg, DID_SYMLIST, LM_SETTOPINDEX,%@NL@%
                (MPARAM)item, 0L);%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now clear the text out of the ADDR field, and set the focus%@NL@%
%@AB@%     * back to the window%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinSetDlgItemText(hwndDlg, DID_ADDR, "");%@NL@%
    WinSetFocus(HWND_DESKTOP, WinWindowFromID(hwndDlg, DID_ADDR));%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* MRESULT NEAR FormatLNDialog(hwndDlg, paswp, prectl)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Process the WM_SIZE message in the List Near Dialog%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT NEAR FormatLNDialog(hwndDlg, paswp, prclClientX)%@NL@%
HWND                hwndDlg;%@NL@%
PSWP                paswp;%@NL@%
PRECTL              prclClientX;%@NL@%
{%@NL@%
    USHORT          cy;%@NL@%
    USHORT          cswp;%@NL@%
    HPS             hps;%@NL@%
    SHORT           dy;%@NL@%
    register HWND   hwndT;%@NL@%
    FONTMETRICS     fm;%@NL@%
    PSWP            pswpT;%@NL@%
    RECTL           rclClient;%@NL@%
    SWP             swpOk;%@NL@%
    SHORT           y;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * First let the default frame processing set up the position of%@NL@%
%@AB@%     * all of the standard controls.  Then we will position the list box%@NL@%
%@AB@%     * and the two entry fields to fill in the remainder of the space.%@NL@%
%@AB@%     */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%PSWPLN(x) (paswp + cswp + x - DID_SYMLIST) %@NL@%
%@NL@%
%@NL@%
    cswp = SHORT1FROMMR(WinDefDlgProc(hwndDlg, WM_FORMATFRAME, (MPARAM)paswp,%@NL@%
            (MPARAM)(PRECTL)&rclClient));%@NL@%
    if (prclClientX != NULL)%@NL@%
        *prclClientX = rclClient;   %@AB@%/* Give caller info */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now Add our controls to the SWP list - Verify that the first one%@NL@%
%@AB@%     * exists. If not, we probably are initializing the dialog, so%@NL@%
%@AB@%     * Simply return what the default Dlg Proc returned.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    hwndT = WinWindowFromID(hwndDlg, DID_OK);%@NL@%
    if (hwndT == NULL)%@NL@%
        return ((MRESULT) cswp);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * We need to get a PS, such that we can find out the size of the%@NL@%
%@AB@%     * font, to adjust our edit fields such that they wont keep moving%@NL@%
%@AB@%     * in.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    hps = WinGetPS(hwndDlg);%@NL@%
    GpiQueryFontMetrics(hps, (LONG)sizeof(fm), &fm);%@NL@%
    WinReleasePS(hps);%@NL@%
%@NL@%
    WinQueryWindowPos(hwndT, &swpOk);%@NL@%
%@NL@%
    pswpT=PSWPLN(DID_SYMLIST);%@NL@%
    WinQueryWindowPos(hwndT = WinWindowFromID(hwndDlg, DID_SYMLIST), pswpT);%@NL@%
    dy = pswpT->y - (swpOk.y + swpOk.cy);%@NL@%
    pswpT->fs = SWP_SIZE;%@NL@%
    pswpT->cx = (SHORT)rclClient.xRight - (SHORT)rclClient.xLeft - pswpT->x;%@NL@%
%@NL@%
    %@AB@%/* First position the top line, just below titlebar */%@AE@%%@NL@%
    pswpT=PSWPLN(DID_PIDLABEL);%@NL@%
    WinQueryWindowPos(hwndT = WinWindowFromID(hwndDlg, DID_PIDLABEL), pswpT);%@NL@%
    pswpT->fs = SWP_MOVE;%@NL@%
    cy = pswpT->cy;%@NL@%
    y = pswpT->y = (SHORT)rclClient.yTop - (SHORT)rclClient.yBottom -%@NL@%
            cy - dy;%@NL@%
%@NL@%
    pswpT=PSWPLN(DID_PID);%@NL@%
    WinQueryWindowPos(hwndT = WinWindowFromID(hwndDlg, DID_PID), pswpT);%@NL@%
    pswpT->fs = SWP_MOVE;%@NL@%
    pswpT->x += (SHORT)fm.lAveCharWidth / 2; %@AB@%/* Take care of margin */%@AE@%%@NL@%
    pswpT->y = y;%@NL@%
%@NL@%
    %@AB@%/* Since Edit control is bigger Setup Start Y for the next row */%@AE@%%@NL@%
    y += (cy - pswpT->cy);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Now position Addr line below PID line */%@AE@%%@NL@%
    pswpT=PSWPLN(DID_ADDRLABEL);%@NL@%
    WinQueryWindowPos(hwndT = WinWindowFromID(hwndDlg, DID_ADDRLABEL), pswpT);%@NL@%
    pswpT->fs = SWP_MOVE;%@NL@%
    y = (pswpT->y = y - pswpT->cy - dy);%@NL@%
%@NL@%
    pswpT=PSWPLN(DID_ADDR);%@NL@%
    WinQueryWindowPos(hwndT = WinWindowFromID(hwndDlg, DID_ADDR), pswpT);%@NL@%
    pswpT->fs = SWP_MOVE;%@NL@%
    pswpT->x += (SHORT)fm.lAveCharWidth / 2; %@AB@%/* Take care of margin */%@AE@%%@NL@%
    pswpT->y = y;%@NL@%
%@NL@%
    %@AB@%/* Now set size of listbox */%@AE@%%@NL@%
    y += (cy - pswpT->cy);%@NL@%
%@NL@%
    pswpT=PSWPLN(DID_SYMLIST);%@NL@%
    pswpT->cy = y - dy - pswpT->y;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Return the count of swps%@NL@%
%@AB@%     */%@AE@%%@NL@%
    return ((MRESULT)(cswp + (DID_PID-DID_SYMLIST+1)));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* VOID NEAR EndLNDialog(hwndDlg)%@NL@%
%@AB@%*%@NL@%
%@AB@%* End processing for the List Near Dialog%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
VOID NEAR EndLNDialog(hwndDlg)%@NL@%
HWND hwndDlg;%@NL@%
{%@NL@%
    %@AB@%/* First Dismiss the dialog and destroy the windows */%@AE@%%@NL@%
    WinDismissDlg(hwndDlg, 0);%@NL@%
    WinDestroyWindow(hwndDlg);%@NL@%
%@NL@%
    %@AB@%/* And re-enable the menu item */%@AE@%%@NL@%
    WinSendMsg(WinWindowFromID(hwndSpyFrame, FID_MENU),%@NL@%
        MM_SETITEMATTR, MPFROM2SHORT(CMD_LISTNEAR, TRUE),%@NL@%
        MPFROM2SHORT(MIA_DISABLED, 0));%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* MRESULT EXPENTRY ListNearDlgProc(hwnd, msg, mp1, mp2)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Will locate the symbol near the specified address.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY ListNearDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND            hwnd;%@NL@%
USHORT          msg;%@NL@%
MPARAM          mp1;%@NL@%
MPARAM          mp2;%@NL@%
{%@NL@%
    PIDINFO     pidinfo;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_INITDLG:%@NL@%
        %@AB@%/* Initialize the dialog items */%@AE@%%@NL@%
        WinSetDlgItemText(hwnd, DID_ADDR, "");%@NL@%
        DosGetPID(&pidinfo);%@NL@%
        WinSetDlgItemShort(hwnd, DID_PID, (USHORT)pidinfo.pid, FALSE);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_SYSCOMMAND:%@NL@%
        if (SHORT1FROMMP(mp1) == SC_CLOSE) {%@NL@%
            %@AB@%/* End processing the dialog */%@AE@%%@NL@%
            EndLNDialog(hwnd);%@NL@%
            break;%@NL@%
        } else%@NL@%
            return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1)) {%@NL@%
        case DID_OK:%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Process The Ok Button, by caling ProcessLNOkButton, which%@NL@%
%@AB@%             * will add the information to the listbox in our dialog.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            ProcessLNOkButton(hwnd);%@NL@%
            break;%@NL@%
%@NL@%
        case DID_CANCEL:%@NL@%
            %@AB@%/* End processing the dialog */%@AE@%%@NL@%
            EndLNDialog(hwnd);%@NL@%
            break;%@NL@%
        }%@NL@%
%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * We want to add our controls into the formating of the frame, so%@NL@%
%@AB@%     * we need to add some room onto the SWP list%@NL@%
%@AB@%     */%@AE@%%@NL@%
    case WM_QUERYFRAMECTLCOUNT:%@NL@%
        return((MRESULT)(SHORT1FROMMR(WinDefDlgProc(hwnd, msg, mp1, mp2)) +%@NL@%
                (SHORT)(DID_PID-DID_SYMLIST+1)));%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Call FormatLNDialog, to format the dialog%@NL@%
%@AB@%     */%@AE@%%@NL@%
    case WM_FORMATFRAME:%@NL@%
        return (FormatLNDialog(hwnd, (PSWP)mp1, (PRECTL)mp2));%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
    }%@NL@%
%@NL@%
    return (0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TED.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\TED\TED.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%   %@NL@%
%@AB@%    TED.C - Tiny Editor: Sample application%@NL@%
%@AB@%%@NL@%
%@AB@%    Created by Microsoft Corporation, IBM Corporation 1989%@NL@%
%@AB@%%@NL@%
%@AB@%-----------------------------------------------------------------------------%@NL@%
%@AB@%%@NL@%
%@AB@%    This module contains the main processing elements of the TED sample%@NL@%
%@AB@%    application.  This application is a very simple editor which utilizies%@NL@%
%@AB@%    an MLE to do all the text interaction with the user.  Full help support%@NL@%
%@AB@%    is built in using Help Manager. The application is organized into the%@NL@%
%@AB@%    following 15 files.%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%        Ted.c     - Contains the main processing loop and all the MLE handler%@NL@%
%@AB@%                    functions.%@NL@%
%@AB@%%@NL@%
%@AB@%        Ted.h     - Contains the #define and function prototypes.%@NL@%
%@AB@%%@NL@%
%@AB@%        Ted.rc    - Contains the Menu entries, the accelerator table and%@NL@%
%@AB@%                    the string resources.%@NL@%
%@AB@%%@NL@%
%@AB@%        Ted.ico   - The icon that appears when Ted is minimized and also%@NL@%
%@AB@%                    in the about box.%@NL@%
%@AB@%%@NL@%
%@AB@%        Ted.def   - Module definition file for Ted.%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%        Tedmem.c  - Contains the memory allocation functions.%@NL@%
%@AB@%%@NL@%
%@AB@%        Tedmem.h  - Contains the #define and the function prototypes for%@NL@%
%@AB@%                    the memory allocation functions.%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%        Tedhelp.c - Contains the help manager support functions.%@NL@%
%@AB@%%@NL@%
%@AB@%        Tedhelp.h - Contains all the ID's for the Help Manager help panels%@NL@%
%@AB@%%@NL@%
%@AB@%        Tedhelp.rc- Contains the Help Manager tables and sub-tables%@NL@%
%@AB@%                    that associate each selectable item with a particular%@NL@%
%@AB@%                    help panel in the Tedhp.itl file.%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%        Tedhp.itl - Contains the Help Manager help panels.%@NL@%
%@AB@%%@NL@%
%@AB@%        Tedhp.h   - Contains the #defines for the help panel id's%@NL@%
%@AB@%%@NL@%
%@AB@%        Teddlg.dlg- Contains the Dialog templates for the Find and%@NL@%
%@AB@%                    about dialog boxes.%@NL@%
%@AB@%%@NL@%
%@AB@%        Teddlg.h  - Contains the #define ID's for the Find and about dialog%@NL@%
%@AB@%                    boxes%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%        MAKEFILE  - The makefile (nmake.exe) for the TED application.%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%    DLL's used:%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%        opendlg.dll - This dll is provided in the toolkit and it contains%@NL@%
%@AB@%                      the open/save as dialog used for choosing files.%@NL@%
%@AB@%                      The directory it resides in must be specified in%@NL@%
%@AB@%                      the LIBPATH.%@NL@%
%@AB@%%@NL@%
%@AB@%    Import libraries used:%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%        opendlg.lib - This contains the functions used to interface%@NL@%
%@AB@%                      to the open/save dialog DLL.%@NL@%
%@AB@%%@NL@%
%@AB@%        opendlg.h   - This contains the functions prototypes etc%@NL@%
%@AB@%                      used to interface to the open/save dialog DLL.%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%    Help Libraries used:%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%        tedhp.hlp   - This is the Help Manager help panel storage file%@NL@%
%@AB@%                      It must be either in the directory specified by%@NL@%
%@AB@%                      the HELP environment variable, in \OS2\HELP, or%@NL@%
%@AB@%                      in the current directory.%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%        Modification History%@NL@%
%@AB@%%@NL@%
%@AB@%            891005    James Bratsanos, Updated comment so help file (.hlp)%@NL@%
%@AB@%                                       can now be in current directory.%@NL@%
%@AB@%%@NL@%
%@AB@%            890911    James Bratsanos, Created%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    Include Files, Macros, Defined Constants%@NL@%
%@AB@%%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_DOS %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
<opendlg.h>    %@AB@%/* Header file for toolkit open/save dialogs */%@AE@%%@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"ted.h" %@NL@%
%@AI@%#include %@AE@%"tedhelp.h" %@NL@%
%@AI@%#include %@AE@%"teddlg.h" %@NL@%
%@AI@%#include %@AE@%"tedmem.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    Variables Used Globally in this module%@NL@%
%@AB@%%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
HWND  hwndFrame   = NULL;   %@AB@%/* The window handle of the frame */%@AE@%%@NL@%
HWND  hwndMenu    = NULL;   %@AB@%/* The window handle of our menu  */%@AE@%%@NL@%
HWND  hwndMLE     = NULL;   %@AB@%/* The window handle of the MLE (Client of Frame*/%@AE@%%@NL@%
HWND  hwndDlgFind = NULL;   %@AB@%/* The window handle of the FIND dialog box */%@AE@%%@NL@%
HAB   hab         = NULL;   %@AB@%/* The anchor block handle for TED */%@AE@%%@NL@%
PFNWP pfnwpold    = NULL;   %@AB@%/* A pointer to the old window procedure of */%@AE@%%@NL@%
                            %@AB@%/* the Client (the MLE window proc )        */%@AE@%%@NL@%
%@NL@%
HMQ   hmq ;                 %@AB@%/* Message queue handle */%@AE@%%@NL@%
%@NL@%
PFNWP pfnwpoldframe = NULL; %@AB@%/* A pointer to the old window procedure of */%@AE@%%@NL@%
                            %@AB@%/* the Frame */%@AE@%%@NL@%
%@NL@%
%@NL@%
struct _TEDINFO {           %@AB@%/* Used to keep track of the file name and  */%@AE@%%@NL@%
                            %@AB@%/* path currently being edited              */%@AE@%%@NL@%
%@NL@%
    UCHAR uchFileName[ CCHMAXPATH ];         %@AB@%/* Just the file name */%@AE@%%@NL@%
    UCHAR uchFullPathName[ CCHMAXPATH];      %@AB@%/* The full path      */%@AE@%%@NL@%
    UCHAR uchPgmName[  CCHMAXPATH ];         %@AB@%/* Program name from title bar */%@AE@%%@NL@%
%@NL@%
};%@NL@%
%@NL@%
struct _TEDINFO tedinfo;%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    main - This is the main procedure of the ted application.  It does%@NL@%
%@AB@%           any initialization that is required goes into the standard%@NL@%
%@AB@%           get / dispatch message loop and, finally does any cleanup%@NL@%
%@AB@%           that is required.%@NL@%
%@AB@%%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID main (VOID)%@NL@%
{%@NL@%
%@NL@%
%@NL@%
    static ULONG flFrameFlags = FCF_STANDARD;%@NL@%
    QMSG         qmsg ;     %@AB@%/* Information used to dispatch msg's */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%        Create the anchor block (HAB) and the message queue for our%@NL@%
%@AB@%        application.%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
    hab = WinInitialize (0) ;%@NL@%
    hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%        Create the frame window and specify that the client is an MLE%@NL@%
%@AB@%        So this way the MLE will handle all the WM_SIZE, WM_PAINT msg%@NL@%
%@AB@%        and we dont have to.%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
    hwndFrame = WinCreateStdWindow (HWND_DESKTOP,%@NL@%
                                         WS_VISIBLE | MLS_WORDWRAP |%@NL@%
                                                 FS_ACCELTABLE,%@NL@%
                                    &flFrameFlags,%@NL@%
                                    WC_MLE ,%@NL@%
                                    NULL,%@NL@%
                                    WS_VISIBLE | MLS_HSCROLL | MLS_VSCROLL |%@NL@%
                                                   MLS_WORDWRAP ,%@NL@%
                                    (HMODULE) NULL,%@NL@%
                                    ID_RESOURCE,%@NL@%
                                    &hwndMLE ) ;%@NL@%
%@NL@%
%@NL@%
    if ( hwndFrame == NULL || hwndMLE == NULL )%@NL@%
    {%@NL@%
        TEDDisplayErrorID( SID_UNABLE_TO_CREATE_FRAME  );%@NL@%
%@NL@%
        TEDCleanupExit();      %@AB@%/* Cleanup and exit , NOTE: never returns!! */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*  Sub class the frame so we get the WM_CONTROL MSG's from the MLE */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
    if ( ( pfnwpoldframe = WinSubclassWindow( hwndFrame, FrameWndProc ))%@NL@%
                                  == (PFNWP) 0 )%@NL@%
    {%@NL@%
        TEDDisplayErrorID( SID_UNABLE_TO_SUB_FRAME );%@NL@%
%@NL@%
        TEDCleanupExit();      %@AB@%/* Cleanup and exit , NOTE: never returns!! */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%        Subclass the client window in order to receive the MSG's from%@NL@%
%@AB@%        our menu.%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
    if ( (pfnwpold = WinSubclassWindow( hwndMLE , ClientWndProc ))%@NL@%
                                       ==   (PFNWP) 0 )%@NL@%
    {%@NL@%
        TEDDisplayErrorID( SID_UNABLE_TO_SUB_CLIENT );%@NL@%
%@NL@%
        TEDCleanupExit();      %@AB@%/* Cleanup and exit , NOTE: never returns!! */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%        Since the MLE sends messages to its owner and WinCreateStdWindow%@NL@%
%@AB@%        does not assign an owner to its client then set the owner of the%@NL@%
%@AB@%        MLE to be the frame (Since we subclassed the frame window%@NL@%
%@AB@%        earlier we now receive the WM_CONTROL (notification messages)%@NL@%
%@AB@%        from the MLE%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
    if ( !WinSetOwner( hwndMLE, hwndFrame ))%@NL@%
    {%@NL@%
        TEDDisplayErrorID( SID_UNABLE_TO_SET_FRAME_OWNER );%@NL@%
%@NL@%
        TEDCleanupExit();      %@AB@%/* Cleanup and exit , NOTE: never returns!! */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
    MLEInit ( hwndMLE );%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*  Save off the id of our menu so we can send it msg's as required. */%@AE@%%@NL@%
%@NL@%
%@NL@%
    hwndMenu = WinWindowFromID(hwndFrame, FID_MENU) ;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*  Set the initial state of the Word Wrap menu item on our menu */%@AE@%%@NL@%
%@NL@%
%@NL@%
    MLESetWrap( hwndMLE, hwndMenu, FALSE );%@NL@%
%@NL@%
    %@AB@%/*****************************************************************%@NL@%
%@AB@%        Init the Help Manager. No need to check for success since TED%@NL@%
%@AB@%        will function fine without help.%@NL@%
%@AB@%    *****************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
    TEDInitHelp( hwndFrame, hab );%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Get the name of the program so we can use it later in the title */%@AE@%%@NL@%
%@NL@%
    WinQueryWindowText( hwndFrame ,%@NL@%
                        sizeof(tedinfo.uchPgmName ),%@NL@%
                        tedinfo.uchPgmName);%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%        Setup the path name portion of our program to be NULL and the%@NL@%
%@AB@%        title to be Untitled%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
    TEDInitFileName();%@NL@%
%@NL@%
%@NL@%
    TEDUpdateTitleBar( hwndFrame, tedinfo.uchPgmName, tedinfo.uchFileName );%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%        Stay in the standard Presentation manager processing loop%@NL@%
%@AB@%        until a WM_QUIT is received. This causes WinGetMsg() to%@NL@%
%@AB@%        return FALSE and thus the loop is exited.%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
    while(WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
    {%@NL@%
        WinDispatchMsg (hab, &qmsg) ;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/********************************************************************%@NL@%
%@AB@%        Do any cleanup the help manager requires. We do not need%@NL@%
%@AB@%        to cleanup the ABOUT dialog since it is modal and is destroyed%@NL@%
%@AB@%        every time the user removes it.%@NL@%
%@AB@%    ********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
    TEDTerminateHelp( hwndFrame );%@NL@%
%@NL@%
%@NL@%
%@NL@%
    TEDCleanupExit();     %@AB@%/* Cleanup and exit , NOTE: never returns!! */%@AE@%%@NL@%
%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/**********************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    TEDInitFileName - This function initalizes the full path of the%@NL@%
%@AB@%                      current file to be NULL and the current file%@NL@%
%@AB@%                      name to be "Untitled". This way the save dialog%@NL@%
%@AB@%                      need only check if the full path is null and%@NL@%
%@AB@%                      thus it will know that no file has been set.%@NL@%
%@AB@%                      As soon as we do a OPEN or SAVE AS then the full%@NL@%
%@AB@%                      path will be set to something other than NULL%@NL@%
%@AB@%                      and thus the file will no longer be considered%@NL@%
%@AB@%                      Untitled.%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%**********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
VOID TEDInitFileName()%@NL@%
{%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Load the string that will signifiy an Untitled file name */%@AE@%%@NL@%
%@NL@%
%@NL@%
    if ( WinLoadString( hab,%@NL@%
                        (HMODULE) NULL,%@NL@%
                        SID_TED_UNTITLED,%@NL@%
                        sizeof( tedinfo.uchFileName),%@NL@%
                        tedinfo.uchFileName )  == (SHORT) 0 )%@NL@%
    {%@NL@%
        MESSAGE("Cannot load untitled string ");%@NL@%
    }%@NL@%
%@NL@%
    tedinfo.uchFullPathName[0] = '\000';   %@AB@%/* Make the path empty */%@AE@%%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/**********************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    FrameWndProc - This window procedure is used to catch%@NL@%
%@AB@%                   notification messages (WM_CONTROL) from the MLE%@NL@%
%@AB@%                   and also Help Manager errors.  This procedure%@NL@%
%@AB@%                   actually is subclassed on the frame and all%@NL@%
%@AB@%                   non processed messages are passed through to the%@NL@%
%@AB@%                   default frame proc.%@NL@%
%@AB@%%@NL@%
%@AB@%**********************************************************************/%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY FrameWndProc( HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
%@NL@%
    MRESULT mresult;    %@AB@%/* Used to return Help Panel ID to Help Manager */%@AE@%%@NL@%
%@NL@%
%@NL@%
    switch( msg )%@NL@%
    {%@NL@%
        case WM_CONTROL:                          %@AB@%/* Control Message      */%@AE@%%@NL@%
%@NL@%
            switch( LOUSHORT( mp1 ) )             %@AB@%/* ID of control        */%@AE@%%@NL@%
            {%@NL@%
                case FID_CLIENT :                 %@AB@%/* Verify its from MLE  */%@AE@%%@NL@%
%@NL@%
%@NL@%
                    switch( HIUSHORT( mp1 ) )     %@AB@%/* Notification Message */%@AE@%%@NL@%
                    {%@NL@%
%@NL@%
                    %@AB@%/******************************************************%@NL@%
%@AB@%                        The MLE will send a MLN_CHANGE message when%@NL@%
%@AB@%                        something in the MLE is modified. This could%@NL@%
%@AB@%                        be used to do smart closing where TED would%@NL@%
%@AB@%                        notify the user if an exit attempt was made%@NL@%
%@AB@%                        when the MLE text had unsaved changes.%@NL@%
%@AB@%                    ******************************************************/%@AE@%%@NL@%
%@NL@%
                        case MLN_CHANGE:%@NL@%
%@NL@%
                        %@AB@%/* Just do the old frame procedure processing */%@AE@%%@NL@%
%@NL@%
                            break;%@NL@%
%@NL@%
                    %@AB@%/******************************************************%@NL@%
%@AB@%                        The MLE will send a MLN_TEXTOVERFLOW message when%@NL@%
%@AB@%                        a key stroke would cause the text in the MLE to%@NL@%
%@AB@%                        exceed the TEXT_LIMIT set%@NL@%
%@AB@%                    ******************************************************/%@AE@%%@NL@%
%@NL@%
                        case MLN_TEXTOVERFLOW:%@NL@%
%@NL@%
                            TEDDisplayErrorID( SID_MLEMSG_TEXTOVERFLOW );%@NL@%
%@NL@%
                            return FALSE; %@AB@%/* Tell MLE to not allow overflow */%@AE@%%@NL@%
%@NL@%
                            break;%@NL@%
%@NL@%
%@NL@%
                    %@AB@%/******************************************************%@NL@%
%@AB@%                        The MLE will send a MLN_OVERFLOW message when%@NL@%
%@AB@%                        an action other that a key stroke would cause%@NL@%
%@AB@%                        the text in the MLE to exceed the allowable%@NL@%
%@AB@%                        amount, or the format rectangle would have%@NL@%
%@AB@%                        been inadequate to contain the text.%@NL@%
%@AB@%%@NL@%
%@AB@%                        NOTE: mp2 is a pointer to a OVERFLOW structure%@NL@%
%@AB@%                              containing detailed information as to%@NL@%
%@AB@%                              what caused the overflow.%@NL@%
%@AB@%                    ******************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
                        case MLN_OVERFLOW:%@NL@%
%@NL@%
                            TEDDisplayErrorID( SID_MLEMSG_MLN_OVERFLOW );%@NL@%
%@NL@%
                            return FALSE; %@AB@%/* Tell MLE to not allow overflow */%@AE@%%@NL@%
%@NL@%
                            break;%@NL@%
%@NL@%
%@NL@%
                        default:%@NL@%
%@NL@%
                        %@AB@%/* Just do the old frame procedure processing */%@AE@%%@NL@%
%@NL@%
                            break;%@NL@%
%@NL@%
                    } %@AB@%/* End switch( HIUSHORT( mp1 )) */%@AE@%%@NL@%
                    break;%@NL@%
%@NL@%
                default :%@NL@%
%@NL@%
                %@AB@%/* Just do the old frame procedure processing */%@AE@%%@NL@%
%@NL@%
                    break;%@NL@%
%@NL@%
%@NL@%
            }  %@AB@%/* End switch( LOUSHORT( mp1 ) ) */%@AE@%%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* Just do the old frame procedure processing */%@AE@%%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
%@NL@%
        default:%@NL@%
%@NL@%
        %@AB@%/********************************************************************%@NL@%
%@AB@%            Process any help messages that come through.%@NL@%
%@AB@%            If TEDProcessHelpMsg() can handle any of the Help messages it%@NL@%
%@AB@%            receives the TRUE is returned and we return whatever was%@NL@%
%@AB@%            passed back. Other wise the code falls through to the default%@NL@%
%@AB@%            window procedure.%@NL@%
%@AB@%        ********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
            if ( TEDProcessHelpMsg( hwnd, msg, mp1, mp2, &mresult ) )%@NL@%
            {%@NL@%
                return( mresult );%@NL@%
            }%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
    }  %@AB@%/* End switch( msg ) */%@AE@%%@NL@%
%@NL@%
%@NL@%
    return( (*pfnwpoldframe) (hwnd, msg, mp1, mp2)) ;%@NL@%
%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/**********************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    ClientWndProc - This procedure is the window proc (subclassed) for%@NL@%
%@AB@%                    the MLE. It handles any of the menu selections made%@NL@%
%@AB@%                    in our menu and passes everything else through to%@NL@%
%@AB@%                    the default window procedure (which is the MLE )%@NL@%
%@AB@%%@NL@%
%@AB@%**********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    CHAR achtmp[50];  %@AB@%/* Used to format the string when the user chooses the */%@AE@%%@NL@%
                      %@AB@%/* Query lines , menu choice to see how many lines     */%@AE@%%@NL@%
                      %@AB@%/* there currently are in the MLE                      */%@AE@%%@NL@%
%@NL@%
    LONG     lFileSize;       %@AB@%/* The amount of text in the MLE */%@AE@%%@NL@%
    HFILE    hf;              %@AB@%/* File handle used for reading/writing */%@AE@%%@NL@%
    USHORT   usAction;        %@AB@%/* Action field of DosOpen call */%@AE@%%@NL@%
%@NL@%
%@NL@%
    switch (msg)%@NL@%
    {%@NL@%
%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
%@NL@%
            switch( LOUSHORT(mp1) )    %@AB@%/* Switch on Menu ID */%@AE@%%@NL@%
            {%@NL@%
%@NL@%
                      case IDM_NEWFILE :%@NL@%
%@NL@%
                %@AB@%/********************************************************%@NL@%
%@AB@%                    If we disable the MLE then it wont try to keep the%@NL@%
%@AB@%                    display current while were deleting its contents.%@NL@%
%@AB@%                    This way the MLE pointer will turn to an hour glass,%@NL@%
%@AB@%                    all its text will be deleted (by selecting all the%@NL@%
%@AB@%                    text in the MLE and deleting it) then the hour glass%@NL@%
%@AB@%                    will be changed back to the system pointer.  This%@NL@%
%@AB@%                    way it appears better to the user since he does not%@NL@%
%@AB@%                    visually see all the text in the mle get selected%@NL@%
%@AB@%                    and then deleted.%@NL@%
%@AB@%                ********************************************************/%@AE@%%@NL@%
%@NL@%
                    MLEDisable( hwndMLE );%@NL@%
%@NL@%
                    MLEDeleteContents( hwndMLE );%@NL@%
%@NL@%
                    MLEEnable( hwndMLE );%@NL@%
%@NL@%
                    TEDInitFileName();%@NL@%
%@NL@%
                    TEDUpdateTitleBar( hwndFrame,%@NL@%
                                       tedinfo.uchPgmName,%@NL@%
                                       tedinfo.uchFileName );%@NL@%
%@NL@%
                    break ;%@NL@%
%@NL@%
                case IDM_OPENFILE :%@NL@%
%@NL@%
%@NL@%
                    MLEOpenFile( hwnd,%@NL@%
                                 tedinfo.uchFileName,%@NL@%
                                 tedinfo.uchFullPathName );%@NL@%
%@NL@%
                    TEDUpdateTitleBar( hwndFrame,%@NL@%
                                       tedinfo.uchPgmName,%@NL@%
                                       tedinfo.uchFileName );%@NL@%
%@NL@%
                    break ;%@NL@%
%@NL@%
                case IDM_SAVE:%@NL@%
%@NL@%
                %@AB@%/************************************************************%@NL@%
%@AB@%                    If uchFullPathName is empty then the file name is%@NL@%
%@AB@%                    Untitled so we cannot do a save (since we have no name)%@NL@%
%@AB@%                    so send a message to ourselves as though the user had%@NL@%
%@AB@%                    clicked on the Save as menu item. If the file name is%@NL@%
%@AB@%                    not Untitled then open the current file and save the%@NL@%
%@AB@%                    contents of the MLE.%@NL@%
%@AB@%                ************************************************************/%@AE@%%@NL@%
%@NL@%
                    if ( tedinfo.uchFullPathName[0] == '\000' )%@NL@%
                    {%@NL@%
%@NL@%
                        return ( WinSendMsg( hwnd,%@NL@%
                                             WM_COMMAND,%@NL@%
                                             MPFROMSHORT( IDM_SAVEAS ),%@NL@%
                                             mp2 ));%@NL@%
%@NL@%
%@NL@%
                    }%@NL@%
                    else%@NL@%
                    {%@NL@%
%@NL@%
%@NL@%
                        if ( DosOpen( tedinfo.uchFullPathName,%@NL@%
                                      &hf,%@NL@%
                                      &usAction,%@NL@%
                                      (ULONG) 0,%@NL@%
                                      (USHORT) 0,%@NL@%
                                      FILE_OPEN,%@NL@%
                                      OPEN_ACCESS_WRITEONLY |%@NL@%
                                        OPEN_SHARE_DENYWRITE,%@NL@%
                                      (ULONG) 0 ) )%@NL@%
                        {%@NL@%
%@NL@%
                            TEDDisplayErrorID( SID_CANT_OPEN_EX_FILE );%@NL@%
%@NL@%
                        }%@NL@%
                        else%@NL@%
                        {%@NL@%
%@NL@%
                            MLESaveToFile( hf );%@NL@%
                            DosClose( hf );%@NL@%
%@NL@%
                        }%@NL@%
%@NL@%
                    }%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_SAVEAS :%@NL@%
%@NL@%
                    MLESaveFile( hwnd,%@NL@%
                                 tedinfo.uchFileName,%@NL@%
                                 tedinfo.uchFullPathName );%@NL@%
%@NL@%
                    TEDUpdateTitleBar( hwndFrame,%@NL@%
                                       tedinfo.uchPgmName,%@NL@%
                                       tedinfo.uchFileName );%@NL@%
%@NL@%
                    break ;%@NL@%
%@NL@%
                case IDM_FIND :%@NL@%
%@NL@%
%@NL@%
%@NL@%
                %@AB@%/**********************************************************%@NL@%
%@AB@%                    If the handle to our Find dialog is not null then the%@NL@%
%@AB@%                    Find dialog is loaded so we need only show the window%@NL@%
%@AB@%                    and then give it the focus. If the handle is NULL then%@NL@%
%@AB@%                    the Find dialog has never been loaded so we need to%@NL@%
%@AB@%                    load it.  We use WinLoadDlg() because the Find dialog%@NL@%
%@AB@%                    is modeless ie the user can switch between the find%@NL@%
%@AB@%                    dialog and the mle without first having to terminate the%@NL@%
%@AB@%                    find dialog%@NL@%
%@AB@%                **********************************************************/%@AE@%%@NL@%
%@NL@%
                    if ( hwndDlgFind != NULL )%@NL@%
                    {%@NL@%
%@NL@%
                        WinShowWindow( hwndDlgFind, TRUE );%@NL@%
                        WinSetFocus( HWND_DESKTOP, hwndDlgFind );%@NL@%
%@NL@%
%@NL@%
                    }%@NL@%
                    else%@NL@%
                    {%@NL@%
%@NL@%
                         if ( (hwndDlgFind = WinLoadDlg(HWND_DESKTOP,%@NL@%
                                                       hwnd,%@NL@%
                                                       FindDlgProc,%@NL@%
                                                       (HMODULE) NULL,%@NL@%
                                                       DLG_FIND,%@NL@%
                                                       NULL )) == NULL )%@NL@%
                        {%@NL@%
%@NL@%
                            TEDDisplayErrorID( SID_DLG_CANT_LOAD_FIND );%@NL@%
%@NL@%
                        }%@NL@%
                    }%@NL@%
                    break ;%@NL@%
%@NL@%
            %@AB@%/***********************************************************%@NL@%
%@AB@%                Since the MLE supports the CUT, COPY PASTE and UNDO we%@NL@%
%@AB@%                need only send the apropriate msg to the MLE and let it%@NL@%
%@AB@%                do all the work%@NL@%
%@AB@%            ***********************************************************/%@AE@%%@NL@%
%@NL@%
                case IDM_CUT          :%@NL@%
%@NL@%
                    WinSendMsg( hwndMLE, MLM_CUT, NULL, NULL );%@NL@%
                    break ;%@NL@%
%@NL@%
                case IDM_COPY          :%@NL@%
%@NL@%
                    WinSendMsg( hwndMLE, MLM_COPY, NULL, NULL );%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_PASTE   :%@NL@%
%@NL@%
                    WinSendMsg( hwndMLE, MLM_PASTE, NULL, NULL ) ;%@NL@%
                    break ;%@NL@%
%@NL@%
                case IDM_UNDO          :%@NL@%
%@NL@%
                    WinSendMsg( hwndMLE, MLM_UNDO, NULL, NULL );%@NL@%
                    break ;%@NL@%
%@NL@%
                case IDM_SELECT_ALL :%@NL@%
%@NL@%
                %@AB@%/**********************************************************%@NL@%
%@AB@%                    In order to Select all the text in the MLE we need to%@NL@%
%@AB@%                    first query the mle as to the amount of text that is%@NL@%
%@AB@%                    currently in it. Then we send a message to the mle%@NL@%
%@AB@%                    to select the text from the beggining of the mle (IPT 0)%@NL@%
%@AB@%                    to the amount of text the mle told us it had in it.%@NL@%
%@AB@%                **********************************************************/%@AE@%%@NL@%
%@NL@%
                    lFileSize= (LONG) WinSendMsg( hwndMLE ,%@NL@%
                                                   MLM_QUERYTEXTLENGTH,%@NL@%
                                                       NULL,%@NL@%
                                                  NULL );%@NL@%
%@NL@%
                    WinSendMsg(hwndMLE,%@NL@%
                               MLM_SETSEL,%@NL@%
                               (MPARAM) 0L,%@NL@%
                               (MPARAM) lFileSize);%@NL@%
%@NL@%
                    break;%@NL@%
%@NL@%
%@NL@%
                case IDM_QUERYLINES:%@NL@%
%@NL@%
                %@AB@%/* achtmp can only hold a message that is 50 bytes long */%@AE@%%@NL@%
%@NL@%
                    sprintf( achtmp, "%ld Lines in Window",%@NL@%
                                           (LONG) WinSendMsg( hwndMLE,%@NL@%
                                                            MLM_QUERYLINECOUNT,%@NL@%
                                                        NULL,%@NL@%
                                                        NULL )) ;%@NL@%
%@NL@%
                     MESSAGE( achtmp );%@NL@%
                    break;%@NL@%
%@NL@%
%@NL@%
                case IDM_SETWRAP :%@NL@%
%@NL@%
                    MLESetWrap( hwndMLE, hwndMenu, TRUE );%@NL@%
                    break ;%@NL@%
%@NL@%
%@NL@%
                case IDM_DISPLAY_HELP:%@NL@%
%@NL@%
                    TEDSendHelpMsg( HM_DISPLAY_HELP );%@NL@%
                    break;%@NL@%
%@NL@%
%@NL@%
                case IDM_EXT_HELP:%@NL@%
%@NL@%
                    TEDSendHelpMsg( HM_EXT_HELP );%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_INDEX_HELP:%@NL@%
%@NL@%
                    TEDSendHelpMsg( HM_HELP_INDEX );%@NL@%
                    break;%@NL@%
%@NL@%
%@NL@%
                case IDM_KEYS_HELP:%@NL@%
%@NL@%
                    TEDSendHelpMsg( HM_KEYS_HELP );%@NL@%
                    break;%@NL@%
%@NL@%
                case IDM_ABOUT   :      %@AB@%/* About TED dialog */%@AE@%%@NL@%
%@NL@%
                    if ( WinDlgBox( HWND_DESKTOP,%@NL@%
                                    hwndMLE,%@NL@%
                                    AboutDlgProc,%@NL@%
                                    (HMODULE) NULL,%@NL@%
                                    DLG_ABOUT,%@NL@%
                                    NULL )  == DID_ERROR )%@NL@%
                    {%@NL@%
%@NL@%
                        TEDDisplayErrorID( SID_DLG_CANT_LOAD_ABOUT );%@NL@%
%@NL@%
                    }%@NL@%
                    break ;%@NL@%
%@NL@%
                default:%@NL@%
%@NL@%
                %@AB@%/* Fall through to old procedure processing */%@AE@%%@NL@%
%@NL@%
                    break;%@NL@%
%@NL@%
%@NL@%
            }  %@AB@%/* End switch ( LOUSHORT( mp1 )) */%@AE@%%@NL@%
%@NL@%
            break ;%@NL@%
%@NL@%
        default:%@NL@%
%@NL@%
        %@AB@%/* Fall through to old procedure processing */%@AE@%%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    }  %@AB@%/* End switch ( msg ) */%@AE@%%@NL@%
%@NL@%
    return( (*pfnwpold) (hwnd, msg, mp1, mp2)) ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/**********************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    AboutDlgProc - This procedure is the dialog procedure for the%@NL@%
%@AB@%                   About box.%@NL@%
%@AB@%%@NL@%
%@AB@%**********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY AboutDlgProc( HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
%@NL@%
%@NL@%
    switch( msg )%@NL@%
    {%@NL@%
%@NL@%
        case WM_INITDLG:%@NL@%
%@NL@%
            TEDInitDlgSysMenu( hwnd );    %@AB@%/* setup the system menu */%@AE@%%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
        case WM_CLOSE:%@NL@%
%@NL@%
            if ( !WinDismissDlg(hwnd, TRUE))%@NL@%
            {%@NL@%
                TEDDisplayErrorID( SID_DLG_FIND_CANT_DISMISS );%@NL@%
%@NL@%
                TEDCleanupExit(); %@AB@%/* Cleanup and exit , NOTE: never returns!! */%@AE@%%@NL@%
            }%@NL@%
%@NL@%
%@NL@%
            return((MRESULT)TRUE);%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
%@NL@%
        case WM_COMMAND:                        %@AB@%/* Process the Buttons  */%@AE@%%@NL@%
%@NL@%
%@NL@%
            switch (LOUSHORT(mp1))%@NL@%
            {%@NL@%
%@NL@%
                case DID_OK:                    %@AB@%/* OK */%@AE@%%@NL@%
%@NL@%
                    if ( !WinDismissDlg( hwnd, TRUE ))%@NL@%
                    {%@NL@%
                        TEDDisplayErrorID( SID_DLG_FIND_CANT_DISMISS );%@NL@%
                    }%@NL@%
%@NL@%
                    return(MRESULT) TRUE;%@NL@%
%@NL@%
                    break;%@NL@%
%@NL@%
                default:%@NL@%
%@NL@%
                    return(MRESULT) TRUE;%@NL@%
                    break;%@NL@%
            }%@NL@%
%@NL@%
        default:%@NL@%
%@NL@%
            return( WinDefDlgProc( hwnd, msg, mp1, mp2 ) );%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
    }%@NL@%
    return (MRESULT) FALSE;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/**********************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    FindDlgProc - This procedure is the dialog procedure for the%@NL@%
%@AB@%                  Find dialog box.  It is modeless so the user%@NL@%
%@AB@%                  is allowed to switch between the Find dialog box%@NL@%
%@AB@%                  and the MLE.%@NL@%
%@AB@%%@NL@%
%@AB@%**********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT EXPENTRY FindDlgProc( HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
{%@NL@%
    UCHAR   auchFindText[MAX_STRING_SIZE];  %@AB@%/* The find text from the     */%@AE@%%@NL@%
                                            %@AB@%/* FIND dialog box            */%@AE@%%@NL@%
%@NL@%
    UCHAR   auchChangeText[MAX_STRING_SIZE];%@AB@%/* The change to text from    */%@AE@%%@NL@%
                                            %@AB@%/* the FIND dialog box        */%@AE@%%@NL@%
%@NL@%
    ULONG   ulSearchFlags;                  %@AB@%/* Search flags passed to MLE */%@AE@%%@NL@%
%@NL@%
%@NL@%
    MLE_SEARCHDATA seMLESearchData;         %@AB@%/* The MLE search structure   */%@AE@%%@NL@%
%@NL@%
%@NL@%
    switch (msg)%@NL@%
    {%@NL@%
%@NL@%
        case WM_INITDLG:%@NL@%
%@NL@%
%@NL@%
        %@AB@%/*******************************************************************%@NL@%
%@AB@%            Send a msg to each of the entry fields which contain the%@NL@%
%@AB@%            FIND and CHANGE TO text in order to limit the size to the%@NL@%
%@AB@%            buffer we have allocated to receive that text.%@NL@%
%@AB@%        *******************************************************************/%@AE@%%@NL@%
%@NL@%
            WinSendMsg( WinWindowFromID( hwnd, DID_FIND_TEXT),%@NL@%
                        EM_SETTEXTLIMIT,%@NL@%
                        MPFROMSHORT( MAX_STRING_SIZE),%@NL@%
                        NULL );%@NL@%
%@NL@%
%@NL@%
            WinSendMsg( WinWindowFromID( hwnd, DID_CHANGE_TEXT),%@NL@%
                        EM_SETTEXTLIMIT,%@NL@%
                        MPFROMSHORT( MAX_STRING_SIZE),%@NL@%
                        NULL );%@NL@%
%@NL@%
%@NL@%
            TEDInitDlgSysMenu( hwnd );%@NL@%
%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
%@NL@%
        case WM_COMMAND:%@NL@%
%@NL@%
%@NL@%
            switch (SHORT1FROMMP(mp1))%@NL@%
            {%@NL@%
%@NL@%
                case DID_FIND_CHANGE_ALL:%@NL@%
%@NL@%
%@NL@%
                %@AB@%/* Get the FIND and CHANGE TO text the user entered */%@AE@%%@NL@%
%@NL@%
                    WinQueryWindowText( WinWindowFromID( hwnd, DID_FIND_TEXT),%@NL@%
                                        MAX_FNAME_LEN,%@NL@%
                                        auchFindText );%@NL@%
%@NL@%
%@NL@%
                    WinQueryWindowText( WinWindowFromID( hwnd, DID_CHANGE_TEXT),%@NL@%
                                        MAX_FNAME_LEN,%@NL@%
                                        auchChangeText );%@NL@%
%@NL@%
%@NL@%
                    ulSearchFlags = MLFSEARCH_CHANGEALL;%@NL@%
%@NL@%
                    if ( WinSendMsg( WinWindowFromID(hwnd,DID_SENSITIVE),%@NL@%
                                     BM_QUERYCHECK,%@NL@%
                                     NULL,%@NL@%
                                     NULL))%@NL@%
                    {%@NL@%
%@NL@%
                        ulSearchFlags |= MLFSEARCH_CASESENSITIVE;%@NL@%
                    }%@NL@%
%@NL@%
%@NL@%
                %@AB@%/* Fill the MLE search structure with the search/change data */%@AE@%%@NL@%
%@NL@%
                    seMLESearchData.cb         = sizeof( seMLESearchData );%@NL@%
%@NL@%
                    seMLESearchData.pchFind    = auchFindText;%@NL@%
                    seMLESearchData.cchFind    = strlen( auchFindText );%@NL@%
%@NL@%
                    seMLESearchData.pchReplace = auchChangeText;%@NL@%
                    seMLESearchData.cchReplace = strlen( auchChangeText );%@NL@%
%@NL@%
                    seMLESearchData.iptStart   =  0; %@AB@%/* Start at cursor IPT  */%@AE@%%@NL@%
                    seMLESearchData.iptStop    = -1; %@AB@%/* Search to end of MLE */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
                    if ( seMLESearchData.cchFind ) %@AB@%/* Non-empty string to    */%@AE@%%@NL@%
                    {                              %@AB@%/* to search for          */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
                        if ( !WinSendMsg( hwndMLE,%@NL@%
                                          MLM_SEARCH,%@NL@%
                                          (MPARAM) ulSearchFlags,%@NL@%
                                          (MPARAM) &seMLESearchData ) )%@NL@%
                        {%@NL@%
%@NL@%
                            TEDDisplayErrorID( SID_CANT_FIND );%@NL@%
%@NL@%
                        }%@NL@%
                        else%@NL@%
                        {%@NL@%
%@NL@%
                            WinSetFocus( HWND_DESKTOP, hwndMLE );%@NL@%
%@NL@%
                        }%@NL@%
%@NL@%
                    }%@NL@%
                    break;%@NL@%
%@NL@%
%@NL@%
%@NL@%
                case DID_FIND:%@NL@%
%@NL@%
%@NL@%
                    WinQueryWindowText( WinWindowFromID( hwnd, DID_FIND_TEXT),%@NL@%
                                        MAX_FNAME_LEN,%@NL@%
                                        auchFindText );%@NL@%
%@NL@%
%@NL@%
                    ulSearchFlags = MLFSEARCH_SELECTMATCH;%@NL@%
%@NL@%
                    if ( WinSendMsg( WinWindowFromID(hwnd,DID_SENSITIVE),%@NL@%
                                     BM_QUERYCHECK,%@NL@%
                                     NULL,%@NL@%
                                     NULL))%@NL@%
                    {%@NL@%
%@NL@%
                        ulSearchFlags |= MLFSEARCH_CASESENSITIVE;%@NL@%
                    }%@NL@%
%@NL@%
%@NL@%
                    seMLESearchData.cb       = sizeof( seMLESearchData );%@NL@%
%@NL@%
                    seMLESearchData.pchFind  = auchFindText;%@NL@%
                    seMLESearchData.cchFind  = strlen( auchFindText );%@NL@%
%@NL@%
%@NL@%
                %@AB@%/*************************************************************%@NL@%
%@AB@%                    The search always starts at the cursor point and%@NL@%
%@AB@%                    continues to the end of the MLE.  It would be better%@NL@%
%@AB@%                    to put a WRAP box in the Find dialog box so the search%@NL@%
%@AB@%                    would wrap around to the beginning if the user so desired.%@NL@%
%@AB@%                    Currently the user has to <ctrl> HOME to get to the top%@NL@%
%@AB@%                    of the MLE before doing a find/Change all once the%@NL@%
%@AB@%                    cursor is at the bottom of the MLE.%@NL@%
%@AB@%                *************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
                    seMLESearchData.iptStart = -1;   %@AB@%/* Start at cursor IPT  */%@AE@%%@NL@%
                    seMLESearchData.iptStop  = -1;   %@AB@%/* Search to end of MLE */%@AE@%%@NL@%
%@NL@%
%@NL@%
                %@AB@%/* Is there some text to search for ? */%@AE@%%@NL@%
%@NL@%
                    if ( seMLESearchData.cchFind )%@NL@%
                    {%@NL@%
%@NL@%
                    %@AB@%/**********************************************************%@NL@%
%@AB@%                        Since a WinSendMsg is done here instead of a WinPost%@NL@%
%@AB@%                        then the search will be synchronous.  The%@NL@%
%@AB@%                        application will wait until the search is complete%@NL@%
%@AB@%                        before continuing.  This is ok in this application%@NL@%
%@AB@%                        since we are limiting the search.  The MLE sends%@NL@%
%@AB@%                        notification messages occasionally when it is searching%@NL@%
%@AB@%                        so the the user can have the option of aborting the%@NL@%
%@AB@%                        search.%@NL@%
%@AB@%                    **********************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
                        if ( !WinSendMsg( hwndMLE,%@NL@%
                                          MLM_SEARCH,%@NL@%
                                          (MPARAM) ulSearchFlags,%@NL@%
                                          (MPARAM) &seMLESearchData ) )%@NL@%
                        {%@NL@%
%@NL@%
                            TEDDisplayErrorID( SID_CANT_FIND );%@NL@%
%@NL@%
                        }%@NL@%
                        else%@NL@%
                        {%@NL@%
%@NL@%
                            WinSetFocus( HWND_DESKTOP, hwndMLE );%@NL@%
%@NL@%
                        }%@NL@%
%@NL@%
                    }%@NL@%
%@NL@%
                    break;%@NL@%
%@NL@%
                 case MBID_CANCEL:   %@AB@%/* modeless so don't no need to dismiss */%@AE@%%@NL@%
%@NL@%
                    WinPostMsg( hwnd, WM_CLOSE, NULL, NULL );%@NL@%
                    break;%@NL@%
%@NL@%
                 default:%@NL@%
%@NL@%
                    return( WinDefDlgProc( hwnd, msg, mp1, mp2 ));%@NL@%
                    break;%@NL@%
%@NL@%
            } %@AB@%/* End switch (SHORT1FROMMP(mp1)) */%@AE@%%@NL@%
            break;%@NL@%
%@NL@%
            return (MRESULT) FALSE;%@NL@%
%@NL@%
        default:%@NL@%
            return( WinDefDlgProc( hwnd, msg, mp1, mp2 ));%@NL@%
            break;%@NL@%
%@NL@%
    } %@AB@%/* End switch ( msg ) */%@AE@%%@NL@%
%@NL@%
    return (MRESULT) FALSE ;%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/**********************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    MLESaveFile - This procedure enables the save file dialog, lets%@NL@%
%@AB@%                  the user choose a file, then saves the contents of%@NL@%
%@AB@%                  the MLE to that file.%@NL@%
%@AB@%%@NL@%
%@AB@%**********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
VOID MLESaveFile( HWND hwnd, PSZ pszFname, PSZ pszFullName )%@NL@%
{%@NL@%
%@NL@%
    BOOL    fSuccess = TRUE;     %@AB@%/* Flag if user want to save               */%@AE@%%@NL@%
    DLF            dlf;                 %@AB@%/* Data structure for save dialog          */%@AE@%%@NL@%
    HFILE   hf;                  %@AB@%/* File handle of file to save MLE in      */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%    Initialize the data structure used by the save as toolkit dialog.%@NL@%
%@AB@%    Call DlgFile which will put up the save as dialog and return back%@NL@%
%@AB@%    a handle to the opened file.%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
    SetupDLF( &dlf,                      %@AB@%/* Pointer to dialog data structure */%@AE@%%@NL@%
              DLG_SAVEDLG | DLG_HELP,    %@AB@%/* Type of dialog to bring up       */%@AE@%%@NL@%
              &hf,                       %@AB@%/* Pointer to file handle           */%@AE@%%@NL@%
              "\\*.DOC",                 %@AB@%/* Mask of files to bring up        */%@AE@%%@NL@%
              "Dialog Error",            %@AB@%/* Msgbox title if Error            */%@AE@%%@NL@%
              "Save as",                 %@AB@%/* Title of Save as dialog window   */%@AE@%%@NL@%
              "No Help Available");      %@AB@%/* Help message                     */%@AE@%%@NL@%
%@NL@%
%@NL@%
    dlf.szFileName[0] = dlf.szOpenFile[0] = '\000' ;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    switch( DlgFile( hwnd, &dlf ))%@NL@%
    {%@NL@%
%@NL@%
        case TDF_ERRMEM:%@NL@%
        case TDF_INVALID:%@NL@%
        case TDF_NOOPEN:%@NL@%
%@NL@%
            fSuccess = FALSE;%@NL@%
            break;%@NL@%
%@NL@%
        case TDF_NOSAVE:%@NL@%
%@NL@%
            fSuccess = FALSE;%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%    If fSuccess is TRUE then the user chose a file and we have the handle%@NL@%
%@AB@%    to it.  So we save the contents of the MLE to that file handle and update%@NL@%
%@AB@%    the file name information.%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
    if ( fSuccess )%@NL@%
    {%@NL@%
%@NL@%
        if ( MLESaveToFile( hf ))%@NL@%
        {%@NL@%
%@NL@%
        %@AB@%/* Copy the file info into the correct place */%@AE@%%@NL@%
%@NL@%
            strcpy( pszFname, dlf.szFileName );%@NL@%
            strcpy( pszFullName, dlf.szOpenFile );%@NL@%
%@NL@%
        }%@NL@%
%@NL@%
        DosClose( hf );%@NL@%
%@NL@%
%@NL@%
    }%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    MLESaveToFile - This procedure takes a passed file handle and writes%@NL@%
%@AB@%                    the contents of the MLE to it.%@NL@%
%@AB@%%@NL@%
%@AB@%          Returns - True if the MLE was written to the file handle%@NL@%
%@AB@%                    succesfully otherwise FALSE is returned.%@NL@%
%@AB@%%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL MLESaveToFile( HFILE hf )%@NL@%
{%@NL@%
%@NL@%
    PCHAR   pvBuff;              %@AB@%/* Pointer to buffer with exported MLE data*/%@AE@%%@NL@%
    IPT            iptFormatedTextSize; %@AB@%/* The number of bytes of FORMATTED data   */%@AE@%%@NL@%
    IPT     iptTextSize;         %@AB@%/* The number of bytes in the MLE          */%@AE@%%@NL@%
                                 %@AB@%/* NOTE!!! not equal to iptFormatedTextSize*/%@AE@%%@NL@%
%@NL@%
    IPT            iptData;             %@AB@%/* Temp used to hold IPT data              */%@AE@%%@NL@%
    USHORT  cbBytesWritten;      %@AB@%/* Number of bytes written from DosWrite   */%@AE@%%@NL@%
    BOOL    bRetVal = TRUE;      %@AB@%/* Default to OK                           */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*************************************************************************%@NL@%
%@AB@%        First we query the MLE to find out how much data is it. The%@NL@%
%@AB@%        reason we ask for it with the QUERYFORMATTEXTLENGTH is because%@NL@%
%@AB@%        the MLE stores the text in a different format than it exports it.%@NL@%
%@AB@%        Mainly because it stores hard returns as one byte (LF) although%@NL@%
%@AB@%        based on the formatting currently enabled it may export the LF as%@NL@%
%@AB@%        a CR/LF in which case asking the MLE how much data it has with the%@NL@%
%@AB@%        QUERYTEXTLENGTH message would yield a number too small.%@NL@%
%@AB@%%@NL@%
%@AB@%        In essence we are asking the MLE :%@NL@%
%@AB@%%@NL@%
%@AB@%             "If the data were exported at this time how many bytes would%@NL@%
%@AB@%              be required to store it??"%@NL@%
%@AB@%    *************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
        iptFormatedTextSize = (IPT) WinSendMsg( hwndMLE,%@NL@%
                                                MLM_QUERYFORMATTEXTLENGTH,%@NL@%
                                                (MPARAM) (IPT) 0L,  %@AB@%/*beg MLE*/%@AE@%%@NL@%
                                                (MPARAM) (IPT) -1 );%@AB@%/*end MLE*/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Now Query MLE to find out how much data there is (IPT format) */%@AE@%%@NL@%
%@NL@%
        iptTextSize = (IPT) WinSendMsg( hwndMLE,%@NL@%
                                        MLM_QUERYTEXTLENGTH,%@NL@%
                                        NULL,%@NL@%
                                        NULL );%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Allocate a buffer based on the formated size */%@AE@%%@NL@%
%@NL@%
    %@AB@%/*********************************************************************%@NL@%
%@AB@%       The "+ (IPT) 1" is due to a bug in the MLE that should have been%@NL@%
%@AB@%       corrected.  This plus one will not effect the sample app once%@NL@%
%@AB@%       the bug is fixed%@NL@%
%@AB@%    *********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
        if ( MyAllocMem( &pvBuff, iptFormatedTextSize + (IPT) 1, 0 ) ) {%@NL@%
%@NL@%
%@NL@%
            TEDDisplayErrorID( SID_CANT_ALLOCATE_MEMORY );%@NL@%
%@NL@%
            bRetVal = FALSE;%@NL@%
%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
%@NL@%
        %@AB@%/* Set up IMPORT/EXPORT transfer location */%@AE@%%@NL@%
%@NL@%
            WinSendMsg( hwndMLE,%@NL@%
                        MLM_SETIMPORTEXPORT,%@NL@%
                        (MPARAM) pvBuff,                 %@AB@%/* Pointer to buff */%@AE@%%@NL@%
                        (MPARAM) iptFormatedTextSize );  %@AB@%/* Size of buff    */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
        %@AB@%/* Now do the Export into the allocated BUFFER */%@AE@%%@NL@%
%@NL@%
%@NL@%
            iptData = 0L;%@NL@%
%@NL@%
            WinSendMsg( hwndMLE,%@NL@%
                        MLM_EXPORT,                %@AB@%/* EXPORT TYPE             */%@AE@%%@NL@%
                        (MPARAM) &iptData,         %@AB@%/* IPT start for EXPORT    */%@AE@%%@NL@%
                        (MPARAM) &iptTextSize ) ;  %@AB@%/* Amount to EXPORT (bytes)*/%@AE@%%@NL@%
%@NL@%
%@NL@%
        %@AB@%/**********************************************************************%@NL@%
%@AB@%            iptTextSize is decremented by the MLE based on how many bytes%@NL@%
%@AB@%            were actually exported.  If this number is not 0 then an incorrect%@NL@%
%@AB@%            amount of data was exported.%@NL@%
%@AB@%        **********************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
            if ( iptTextSize != (IPT) 0L )%@NL@%
            {%@NL@%
                TEDDisplayErrorID( SID_UNABLE_TO_EXPORT );%@NL@%
                bRetVal = FALSE;%@NL@%
            }%@NL@%
%@NL@%
%@NL@%
        %@AB@%/**********************************************************************%@NL@%
%@AB@%            Since we might of been shrinking the size of the file we need to%@NL@%
%@AB@%            reset the size of the file to 0. This way the size of the file%@NL@%
%@AB@%            becomes the number of bytes that we will write to it.%@NL@%
%@AB@%        **********************************************************************/%@AE@%%@NL@%
%@NL@%
            if ( bRetVal && DosNewSize( hf, 0L ) )%@NL@%
            {%@NL@%
                TEDDisplayErrorID( SID_UNABLE_TO_SET_NEWSIZE );%@NL@%
                bRetVal = FALSE;%@NL@%
            }%@NL@%
%@NL@%
%@NL@%
        %@AB@%/**********************************************************************%@NL@%
%@AB@%           Note iptFormatedTextSize is not checked since we limit the%@NL@%
%@AB@%           size of the MLE to something that will fit in a USHORT.%@NL@%
%@AB@%        **********************************************************************/%@AE@%%@NL@%
%@NL@%
              if ( bRetVal && DosWrite( hf,%@NL@%
                                      (PVOID) pvBuff,%@NL@%
                                      (USHORT) iptFormatedTextSize,%@NL@%
                                      &cbBytesWritten ) )%@NL@%
            {%@NL@%
%@NL@%
                TEDDisplayErrorID( SID_DOSWRITE_FAILED );%@NL@%
                bRetVal = FALSE;%@NL@%
%@NL@%
            }%@NL@%
%@NL@%
        %@AB@%/* Free the buffer we used for the transfer */%@AE@%%@NL@%
%@NL@%
            MyFreeMem( pvBuff );%@NL@%
%@NL@%
%@NL@%
               if ( bRetVal && ( iptFormatedTextSize != (IPT) cbBytesWritten ))%@NL@%
            {%@NL@%
                TEDDisplayErrorID( SID_WRONG_BYTE_COUNT );%@NL@%
                bRetVal = FALSE;%@NL@%
            }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
        } %@AB@%/* End if Buffer available */%@AE@%%@NL@%
%@NL@%
    return ( bRetVal );   %@AB@%/* return success flag */%@AE@%%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    MLEOpenFile - This procedure prompts the user for a file name to edit%@NL@%
%@AB@%                  using the open file dialog supplied with the toolkit.%@NL@%
%@AB@%                  If a user chooses a file to open then the file name and%@NL@%
%@AB@%                  fully qualified path are copied into the passed parameters.%@NL@%
%@AB@%%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID MLEOpenFile( HWND hwnd, PSZ pszFname, PSZ pszFullName )%@NL@%
{%@NL@%
%@NL@%
    BOOL       fSuccess = TRUE;  %@AB@%/* Success flag for file chosen by user */%@AE@%%@NL@%
    DLF               dlf;              %@AB@%/* Data structure for Open dialog       */%@AE@%%@NL@%
    HFILE      hf;               %@AB@%/* File handle of file chosen by user   */%@AE@%%@NL@%
    PCHAR      pvBuff;           %@AB@%/* Buffer user to import file into MLE  */%@AE@%%@NL@%
    USHORT     cbBytesRead;      %@AB@%/* Number of bytes read by DosRead      */%@AE@%%@NL@%
    FILESTATUS stsInfo;          %@AB@%/* Information about the file           */%@AE@%%@NL@%
    IPT               iptData;          %@AB@%/* Position in MLE to import file       */%@AE@%%@NL@%
%@NL@%
%@NL@%
    SetupDLF( &dlf,%@NL@%
              DLG_OPENDLG | DLG_HELP,%@NL@%
              &hf,%@NL@%
              "\\*.DOC",%@NL@%
              "Dialog Error",            %@AB@%/* Msgbox title if Error            */%@AE@%%@NL@%
              "Open",%@NL@%
              "No help available");%@NL@%
%@NL@%
%@NL@%
    dlf.szFileName[0] = dlf.szOpenFile[0] = '\0' ;%@NL@%
%@NL@%
%@NL@%
%@NL@%
    switch( DlgFile( hwnd, &dlf ))%@NL@%
    {%@NL@%
%@NL@%
        case TDF_ERRMEM:%@NL@%
        case TDF_INVALID:%@NL@%
%@NL@%
           fSuccess = FALSE;%@NL@%
           break;%@NL@%
%@NL@%
        case TDF_NOOPEN:%@NL@%
%@NL@%
           fSuccess = FALSE;%@NL@%
           break;%@NL@%
%@NL@%
        default:%@NL@%
%@NL@%
           break;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
    if ( fSuccess ) {%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Find out the size of the file */%@AE@%%@NL@%
%@NL@%
        if ( DosQFileInfo( hf,%@NL@%
                           FIL_STANDARD,%@NL@%
                           (PBYTE) &stsInfo,%@NL@%
                           (USHORT) sizeof( FILESTATUS )))%@NL@%
        {%@NL@%
%@NL@%
            TEDDisplayErrorID( SID_DOSQFILEINFO_FAILED );%@NL@%
%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* If file is too large then truncate it */%@AE@%%@NL@%
%@NL@%
        if ( stsInfo.cbFile > (LONG) TXT_LIMIT )%@NL@%
        {%@NL@%
%@NL@%
            TEDDisplayErrorID( SID_FILE_TOO_LARGE );%@NL@%
%@NL@%
            stsInfo.cbFile = (LONG) TXT_LIMIT;%@NL@%
%@NL@%
        }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Allocate a buffer to do the IMPORT */%@AE@%%@NL@%
%@NL@%
        if (  MyAllocMem( (PVOID *) &pvBuff,%@NL@%
                          (LONG) stsInfo.cbFile,%@NL@%
                          0    ))%@NL@%
        {%@NL@%
%@NL@%
            TEDDisplayErrorID( SID_CANT_ALLOCATE_MEMORY );%@NL@%
%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
%@NL@%
%@NL@%
        %@AB@%/*****************************************************************%@NL@%
%@AB@%           stsInfo.cbFile is always truncated to TXT_LIMIT so it will%@NL@%
%@AB@%           always fit in a short.%@NL@%
%@AB@%        *****************************************************************/%@AE@%%@NL@%
%@NL@%
            if ( !DosRead( hf,%@NL@%
                                 (PVOID) pvBuff ,%@NL@%
                           (USHORT) stsInfo.cbFile,%@NL@%
                           &cbBytesRead )) {%@NL@%
%@NL@%
%@NL@%
                MLEDisable( hwndMLE );%@NL@%
%@NL@%
%@NL@%
%@NL@%
            %@AB@%/* Delete whatever is in MLE right now */%@AE@%%@NL@%
%@NL@%
%@NL@%
                MLEDeleteContents( hwndMLE );%@NL@%
%@NL@%
%@NL@%
            %@AB@%/* Reset the undo since a new file was imported into the MLE */%@AE@%%@NL@%
%@NL@%
                WinSendMsg( hwndMLE, MLM_RESETUNDO, NULL, NULL );%@NL@%
%@NL@%
%@NL@%
%@NL@%
            %@AB@%/* Read the data succesfully, now import to MLE */%@AE@%%@NL@%
%@NL@%
                WinSendMsg( hwndMLE,%@NL@%
                            MLM_SETIMPORTEXPORT,%@NL@%
                            (MPARAM) pvBuff,%@NL@%
                            (MPARAM) cbBytesRead );%@NL@%
%@NL@%
                iptData = 0L;%@NL@%
%@NL@%
                   WinSendMsg( hwndMLE,%@NL@%
                            MLM_IMPORT,%@NL@%
                            (MPARAM) &iptData,%@NL@%
                            (MPARAM) cbBytesRead );%@NL@%
%@NL@%
            %@AB@%/****************************************************************%@NL@%
%@AB@%                Here we should check to see if the number of bytes imported%@NL@%
%@AB@%                matches the number of bytes we told the MLE to import.%@NL@%
%@AB@%            *****************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
            %@AB@%/* Release memory */%@AE@%%@NL@%
%@NL@%
                MyFreeMem( pvBuff );%@NL@%
%@NL@%
%@NL@%
            %@AB@%/* Copy the file name info into the correct place */%@AE@%%@NL@%
%@NL@%
                strcpy( pszFname, dlf.szFileName );%@NL@%
                strcpy( pszFullName, dlf.szOpenFile );%@NL@%
%@NL@%
%@NL@%
                MLEEnable( hwndMLE );%@NL@%
%@NL@%
%@NL@%
            }%@NL@%
            else%@NL@%
            {%@NL@%
                TEDDisplayErrorID( SID_DOS_READ_FAILED );%@NL@%
%@NL@%
            }%@NL@%
%@NL@%
        }%@NL@%
%@NL@%
        DosClose( hf );%@NL@%
%@NL@%
    }%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    MLEInit - This procedure initializes certain MLE parameters to a known%@NL@%
%@AB@%              state.%@NL@%
%@AB@%%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
VOID MLEInit( HWND hwnd )%@NL@%
{%@NL@%
%@NL@%
    %@AB@%/*************************************************************************%@NL@%
%@AB@%        Set the text limit of the MLE to TXT_LIMIT. Any attempt to exceed%@NL@%
%@AB@%        this limit will result in a WM_CONTROL message (notification)%@NL@%
%@AB@%        to the MLE.%@NL@%
%@AB@%    *************************************************************************/%@AE@%%@NL@%
%@NL@%
        WinSendMsg( hwnd,%@NL@%
                    MLM_SETTEXTLIMIT,%@NL@%
                    (MPARAM) ( (LONG) TXT_LIMIT),%@NL@%
                    NULL );%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*************************************************************************%@NL@%
%@AB@%        Set the MLE format to MLFIE_CFTEXT which is the Cliboard text format.%@NL@%
%@AB@%        This format uses CR/LF for line delineation on export and recognizes%@NL@%
%@AB@%        either LF, CR/LF, or LF/CR as a line delineation on import.%@NL@%
%@AB@%    *************************************************************************/%@AE@%%@NL@%
%@NL@%
        WinSendMsg( hwnd,%@NL@%
                    MLM_FORMAT,%@NL@%
                    (MPARAM) (USHORT) MLFIE_CFTEXT,%@NL@%
                    NULL );%@NL@%
%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    MLESetWrap - This procedure determines the current set of the WRAP state%@NL@%
%@AB@%                 in the MLE and optionally (fToggle TRUE ) toggles it. In%@NL@%
%@AB@%                 either case the Menu item Word wrap is checked or unchecked%@NL@%
%@AB@%                 in order to display the correct wrap state of the MLE.%@NL@%
%@AB@%%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
VOID MLESetWrap( HWND hwnd, HWND hwndMenuWrap, BOOL fToggle )%@NL@%
{%@NL@%
    BOOL fWrap;         %@AB@%/* The wrap state of the MLE */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* First query the wrap from the MLE */%@AE@%%@NL@%
%@NL@%
    fWrap = (BOOL)SHORT1FROMMR( WinSendMsg( hwnd, MLM_QUERYWRAP, NULL, NULL ));%@NL@%
%@NL@%
%@NL@%
    if ( fToggle )%@NL@%
    {%@NL@%
%@NL@%
        fWrap = !fWrap;%@NL@%
%@NL@%
        if ( !WinSendMsg( hwnd, MLM_SETWRAP, (MPARAM) fWrap, NULL ) )%@NL@%
        {%@NL@%
            TEDDisplayErrorID( SID_CANT_SET_WRAP );%@NL@%
%@NL@%
            return;%@NL@%
        }%@NL@%
%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Show the checked state on the menu item */%@AE@%%@NL@%
%@NL@%
    WinSendMsg(hwndMenuWrap,%@NL@%
               MM_SETITEMATTR,%@NL@%
               MPFROM2SHORT(IDM_SETWRAP, TRUE),%@NL@%
               MPFROM2SHORT(MIA_CHECKED,%@NL@%
               fWrap ? MIA_CHECKED : FALSE) ) ;%@NL@%
%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    MLEEnable - This procedure Enables the MLE so it will take input from the%@NL@%
%@AB@%                user and update itself to correctly track what is in the%@NL@%
%@AB@%                MLE buffer.%@NL@%
%@AB@%%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID MLEEnable( HWND hwnd )%@NL@%
{%@NL@%
    WinSendMsg( hwnd, MLM_ENABLEREFRESH, NULL, NULL );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    MLEDisable - This procedure disables the MLE so it will not take input%@NL@%
%@AB@%                 from the user, change its pointer to the system wait icon%@NL@%
%@AB@%                 and not update itself.%@NL@%
%@AB@%%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID MLEDisable( HWND hwnd )%@NL@%
{%@NL@%
    WinSendMsg( hwnd, MLM_DISABLEREFRESH, NULL, NULL );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    MLEDeleteContents - This procedure deletes all the text in the MLE.%@NL@%
%@AB@%%@NL@%
%@AB@%      Returns - TRUE if succesfull.%@NL@%
%@AB@%%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
BOOL MLEDeleteContents( HWND hwnd )%@NL@%
{%@NL@%
%@NL@%
    IPT iptTextLength;      %@AB@%/* Length of the text currently in the MLE */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
    iptTextLength = (IPT) WinSendMsg( hwnd, MLM_QUERYTEXTLENGTH, NULL, NULL );%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Now delete all the text in the MLE */%@AE@%%@NL@%
%@NL@%
    return (  (IPT) WinSendMsg( hwnd,%@NL@%
                                MLM_DELETE,       %@AB@%/* Delete MSG */%@AE@%%@NL@%
                                (MPARAM) 0,       %@AB@%/* Start IPT location */%@AE@%%@NL@%
                                (MPARAM) iptTextLength ) == iptTextLength );%@NL@%
%@NL@%
%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    TEDDisplayErrorID - This procedure loads the text associated with the%@NL@%
%@AB@%                        passed in resource identifier and displays it to%@NL@%
%@AB@%                        the user in the form of a message box.%@NL@%
%@AB@%%@NL@%
%@AB@%              Returns - TRUE if the user clicked on okay%@NL@%
%@AB@%%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
BOOL TEDDisplayErrorID( USHORT usid )%@NL@%
{%@NL@%
%@NL@%
    UCHAR  uchTempBuff[ MAX_STRING_SIZE ]; %@AB@%/* Temp used to load string into*/%@AE@%%@NL@%
    USHORT usRetVal;                       %@AB@%/* Return val */%@AE@%%@NL@%
%@NL@%
%@NL@%
    if ( WinLoadString( hab, (HMODULE) NULL, usid, sizeof( uchTempBuff ), uchTempBuff ))%@NL@%
    {%@NL@%
%@NL@%
       usRetVal = MESSAGE( uchTempBuff );%@NL@%
%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
%@NL@%
       usRetVal = MESSAGE("Cannot load resource string");%@NL@%
%@NL@%
    }%@NL@%
%@NL@%
    return( usRetVal == MBID_OK );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    TEDInitDlgSysMenu - This procedure takes the system menu from the passed%@NL@%
%@AB@%                        window handle and deletes the :%@NL@%
%@AB@%%@NL@%
%@AB@%                                MINIMIZE%@NL@%
%@AB@%                                MAXIMIZE%@NL@%
%@AB@%                                SIZE%@NL@%
%@AB@%                                RESTORE%@NL@%
%@AB@%                                TASKMANAGER%@NL@%
%@AB@%%@NL@%
%@AB@%                        entries from the system menu.%@NL@%
%@AB@%%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
VOID TEDInitDlgSysMenu( HWND hDlg )%@NL@%
{%@NL@%
    HWND hSysMenu;      %@AB@%/* Window handle of the system menu attached to the */%@AE@%%@NL@%
                        %@AB@%/* passed dialog handle                             */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
    hSysMenu=WinWindowFromID(hDlg, FID_SYSMENU);%@NL@%
%@NL@%
    WinSendMsg(hSysMenu,%@NL@%
               MM_DELETEITEM,%@NL@%
               MPFROM2SHORT(SC_MINIMIZE,TRUE),%@NL@%
               MPFROMSHORT(NULL));%@NL@%
%@NL@%
    WinSendMsg(hSysMenu,%@NL@%
               MM_DELETEITEM,%@NL@%
               MPFROM2SHORT(SC_MAXIMIZE,TRUE),%@NL@%
               MPFROMSHORT(NULL));%@NL@%
%@NL@%
    WinSendMsg(hSysMenu,%@NL@%
               MM_DELETEITEM,%@NL@%
               MPFROM2SHORT(SC_SIZE,TRUE),%@NL@%
               MPFROMSHORT(NULL));%@NL@%
%@NL@%
    WinSendMsg(hSysMenu,%@NL@%
               MM_DELETEITEM,%@NL@%
               MPFROM2SHORT(SC_RESTORE,TRUE),%@NL@%
               MPFROMSHORT(NULL));%@NL@%
%@NL@%
    WinSendMsg(hSysMenu,%@NL@%
               MM_DELETEITEM,%@NL@%
               MPFROM2SHORT(SC_TASKMANAGER,TRUE),%@NL@%
               MPFROMSHORT(NULL));%@NL@%
%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    TEDCleanupExit - This procedure cleans up by determining if valid%@NL@%
%@AB@%                     handles existed and then destroying them.%@NL@%
%@AB@%%@NL@%
%@AB@%                     NOTE!! This procedure calls DosExit and thus never%@NL@%
%@AB@%                            returns.%@NL@%
%@AB@%%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
VOID TEDCleanupExit(VOID)%@NL@%
{%@NL@%
%@NL@%
%@NL@%
%@AB@%/* If the find dialog was ever used then destroy it */%@AE@%%@NL@%
%@NL@%
    if ( hwndDlgFind != (HWND) NULL )%@NL@%
    {%@NL@%
        WinDestroyWindow( hwndDlgFind );%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/*  Standard Presentation Manager Application exit sequence. */%@AE@%%@NL@%
%@NL@%
%@NL@%
    if ( hwndFrame != (HWND) NULL )%@NL@%
    {%@NL@%
        WinDestroyWindow (hwndFrame ) ;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    if ( hmq != (HMQ) NULL )%@NL@%
    {%@NL@%
        WinDestroyMsgQueue (hmq) ;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    if ( hab != (HAB) NULL )%@NL@%
    {%@NL@%
        WinTerminate (hab) ;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    DosExit( EXIT_PROCESS, 0 );%@NL@%
%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    TEDUpdateTitleBar - This function updates the title (FID_TITLEBAR) of the%@NL@%
%@AB@%                        passed in hwnd with the two passed in string.%@NL@%
%@AB@%                        The strings are format as  <STRING> - <STRING>.%@NL@%
%@AB@%                        This is used to display the program name and file%@NL@%
%@AB@%                        currently being edited.%@NL@%
%@AB@%%@NL@%
%@AB@%*****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
VOID TEDUpdateTitleBar( HWND hwnd, PSZ pszPgmName, PSZ pszFileName )%@NL@%
{%@NL@%
%@NL@%
    UCHAR auchTemp [ 2 * CCHMAXPATH ];%@NL@%
    HWND hwndTitle;%@NL@%
%@NL@%
%@NL@%
    hwndTitle = WinWindowFromID( hwnd , FID_TITLEBAR);%@NL@%
%@NL@%
%@NL@%
    sprintf( auchTemp, "%s - %s", pszPgmName, pszFileName );%@NL@%
%@NL@%
    WinSetWindowText(hwndTitle, auchTemp );%@NL@%
%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TEDHELP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\TED\TEDHELP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/**************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    Tedhelp.c%@NL@%
%@AB@%%@NL@%
%@AB@%    Created by Microsoft Corporation, IBM Corporation 1989%@NL@%
%@AB@%%@NL@%
%@AB@%---------------------------------------------------------------------------%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%        This file contains all the helper procedures required to%@NL@%
%@AB@%        include Help Manager in an application. The normal%@NL@%
%@AB@%        procedure is to:%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%            Define the .itl file which has all the help panel%@NL@%
%@AB@%            text in it.%@NL@%
%@AB@%%@NL@%
%@AB@%            Define the Help tables and sub tables.  This maps%@NL@%
%@AB@%            help panel id numbers to menu id numbers so help%@NL@%
%@AB@%            manager knows which contectual help to put up%@NL@%
%@AB@%            when a user requestes it.%@NL@%
%@AB@%%@NL@%
%@AB@%            Create a help instance.%@NL@%
%@AB@%%@NL@%
%@AB@%            Associate a help instance with the current window%@NL@%
%@AB@%            chain.  As long as each new window created is%@NL@%
%@AB@%            part of the window chain (parent or owner) then%@NL@%
%@AB@%            there is no need to associate a help instance with%@NL@%
%@AB@%            each new window.%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%    Modification history%@NL@%
%@AB@%%@NL@%
%@AB@%            091189  -  James Bratsanos, created%@NL@%
%@AB@%%@NL@%
%@AB@%%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Define Constants for additional includes  */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_BASE %@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"ted.h" %@NL@%
%@AI@%#include %@AE@%"tedhelp.h" %@NL@%
%@AI@%#include %@AE@%"tedhp.h" %@NL@%
%@AI@%#include %@AE@%"teddlg.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
HWND hwndHelpInstance = (HWND) NULL;        %@AB@%/* The handle to the the Help */%@AE@%%@NL@%
                                            %@AB@%/* Manager help instance      */%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    TEDTerminateHelp - This procedure disassociates the help instance%@NL@%
%@AB@%                       attached to the passed in window handle, and then%@NL@%
%@AB@%                       destroys it.%@NL@%
%@AB@%%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
VOID APIENTRY TEDTerminateHelp( HWND hwnd )%@NL@%
{%@NL@%
%@NL@%
%@NL@%
    if ( hwndHelpInstance != (HWND) NULL )%@NL@%
    {%@NL@%
%@NL@%
    %@AB@%/* Dissasociate the Help instance */%@AE@%%@NL@%
%@NL@%
        WinAssociateHelpInstance( NULL, hwnd );%@NL@%
%@NL@%
    %@AB@%/* Destroy the HELP instance */%@AE@%%@NL@%
%@NL@%
        WinDestroyHelpInstance( hwndHelpInstance );%@NL@%
    }%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    TEDInitHelp - This procedure opens the defined help library for this%@NL@%
%@AB@%                  application then creates a help instance and associates%@NL@%
%@AB@%                  it with the passed in window handle (which is the frame)%@NL@%
%@AB@%%@NL@%
%@AB@%****************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
USHORT APIENTRY TEDInitHelp( HWND hFrame, HAB hab )%@NL@%
{%@NL@%
    HELPINIT stHMInit;                  %@AB@%/* Help Manager init structure       */%@AE@%%@NL@%
    BOOL     bHelpLibFound=TRUE;        %@AB@%/* Help library found flag           */%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%    If the help tables were arrays instead of resources they would be%@NL@%
%@AB@%    set up as static arrays at this point in the procedure.%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%    The help manager will search for the help library names first in%@NL@%
%@AB@%    the HELP environment variable and then in the current directory.%@NL@%
%@AB@%%@NL@%
%@AB@%    NOTE: To specify multiple library names seperate the names with%@NL@%
%@AB@%          a blank.  Note the library names must include the extension%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    Initialize Help Manager init  structure%@NL@%
%@AB@%%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
    stHMInit.cb                        = sizeof(HELPINIT);%@NL@%
    stHMInit.ulReturnCode              = 0L;%@NL@%
    stHMInit.pszTutorialName           = NULL;%@NL@%
    stHMInit.phtHelpTable              = (PHELPTABLE) (0xffff0000 |%@NL@%
                                                      (LONG) TED_HELP_TABLE );%@NL@%
    stHMInit.hmodHelpTableModule       = (HMODULE) NULL;%@NL@%
    stHMInit.hmodAccelActionBarModule  = (HMODULE) NULL;%@NL@%
    stHMInit.idAccelTable              = 0;%@NL@%
    stHMInit.idActionBar               = 0;%@NL@%
%@NL@%
%@NL@%
    stHMInit.pszHelpWindowTitle        = "Ted Editor Help";%@NL@%
    stHMInit.usShowPanelId             = CMIC_HIDE_PANEL_ID;%@NL@%
    stHMInit.pszHelpLibraryName        = HELP_LIBRARY;%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Create Help Manager Object Window */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/************************************************************************%@NL@%
%@AB@%    NOTE to Windows Programmers: This hwndHelpInstance is simply%@NL@%
%@AB@%                                 a window handle and not an INSTANCE%@NL@%
%@AB@%                                 handle as defined in Windows.%@NL@%
%@AB@%************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
    if ( !( hwndHelpInstance = WinCreateHelpInstance( hab, &stHMInit )) )%@NL@%
    {%@NL@%
%@NL@%
%@NL@%
        if ( stHMInit.ulReturnCode == HMERR_OPEN_LIB_FILE )%@NL@%
        {%@NL@%
%@NL@%
           TEDDisplayErrorID( SID_HERR_NO_LIBRARY );%@NL@%
%@NL@%
        }%@NL@%
        else%@NL@%
        {%@NL@%
%@NL@%
           TEDDisplayErrorID( SID_HELP_CANT_CREATE_INST );%@NL@%
%@NL@%
        }%@NL@%
%@NL@%
        return( FALSE );                %@AB@%/* cleanup handled at exit */%@AE@%%@NL@%
%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@AB@%/*  Associate an instance of the Help Manager with the window chain. */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
    if (!WinAssociateHelpInstance( hwndHelpInstance, hFrame ))%@NL@%
    {%@NL@%
%@NL@%
        TEDDisplayErrorID( SID_HELP_CANT_ASSOC_INST );%@NL@%
        return( FALSE );                  %@AB@%/* cleanup handled at exit */%@AE@%%@NL@%
%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@AB@%/* Check for any other initialization error from Help Manager */%@AE@%%@NL@%
%@NL@%
%@NL@%
    if(stHMInit.ulReturnCode)%@NL@%
    {%@NL@%
%@NL@%
        TEDDisplayErrorID( SID_HELP_HLP_ERROR );%@NL@%
%@NL@%
        return(FALSE );              %@AB@%/* exit if help initialization failed  */%@AE@%%@NL@%
%@NL@%
    }%@NL@%
    else%@NL@%
    {%@NL@%
        return(HELP_OK);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
}                                                       %@AB@%/* return to main */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    TEDSendHelpMsg - This procedure sends a message to the help manager%@NL@%
%@AB@%%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
VOID APIENTRY TEDSendHelpMsg( USHORT usMsg )%@NL@%
{%@NL@%
%@NL@%
    WinSendMsg( hwndHelpInstance, usMsg, NULL, NULL );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    TEDAssociateHelp - This procedure associates a help instance with the%@NL@%
%@AB@%                       passed in window handle.%@NL@%
%@AB@%%@NL@%
%@AB@%                       NOTE: As long as a new window is part of the original%@NL@%
%@AB@%                             window chain , where each succesive window had%@NL@%
%@AB@%                             as its owner a handle that was associated with%@NL@%
%@AB@%                             the help instance the there is no need to associate%@NL@%
%@AB@%                             a help instance with this newly created window%@NL@%
%@AB@%                             since this new window will inherit the instance%@NL@%
%@AB@%                             because it is part of the chain.%@NL@%
%@AB@%%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
VOID APIENTRY TEDAssociateHelp( HWND hwnd)%@NL@%
{%@NL@%
    WinAssociateHelpInstance( hwndHelpInstance, hwnd );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    TEDProcessHelpMsg - This procedure determines if the Help Manager%@NL@%
%@AB@%                        error is something that can be acted on and%@NL@%
%@AB@%                        acts accordingly.%@NL@%
%@AB@%%@NL@%
%@AB@%              Return  - TRUE if it handled the message. False otherwise%@NL@%
%@AB@%%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL APIENTRY TEDProcessHelpMsg(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2,%@NL@%
                        MRESULT *mresult)%@NL@%
{%@NL@%
%@NL@%
    switch( msg )%@NL@%
    {%@NL@%
%@NL@%
    %@AB@%/**************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%        In this case user pressed keys help and HELP manager sent a message%@NL@%
%@AB@%        notifying us. Help Manager expects the help panel id # in the .ITL%@NL@%
%@AB@%        file be returned so it can display that help panel in the help window.%@NL@%
%@AB@%%@NL@%
%@AB@%    **************************************************************************/%@AE@%%@NL@%
%@NL@%
        case HM_QUERY_KEYS_HELP:%@NL@%
%@NL@%
            *mresult=MRFROMSHORT(KEYS_HELP_HP);%@NL@%
            break;%@NL@%
%@NL@%
        case HM_HELPSUBITEM_NOT_FOUND:%@NL@%
        case HM_EXT_HELP_UNDEFINED:%@NL@%
        case HM_ERROR:%@NL@%
%@NL@%
            *mresult = TEDHelpError(hwnd,msg,mp1,mp2);%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
%@NL@%
            return (FALSE);%@NL@%
            break;%@NL@%
%@NL@%
    }%@NL@%
%@NL@%
    return (TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
MRESULT APIENTRY TEDHelpError( HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2 )%@NL@%
{%@NL@%
  USHORT  SubTopicID;%@NL@%
  USHORT  ErrorCode;%@NL@%
%@NL@%
%@NL@%
%@AB@%/*  Process the Help Manager message  */%@AE@%%@NL@%
%@NL@%
    switch (msg)%@NL@%
    {%@NL@%
        case HM_HELPSUBITEM_NOT_FOUND:%@NL@%
%@NL@%
            SubTopicID = HIUSHORT(mp2);%@NL@%
%@NL@%
%@NL@%
            switch (SubTopicID)%@NL@%
            {%@NL@%
                case FID_CLIENT:         %@AB@%/* Edit area has input focus */%@AE@%%@NL@%
             %@AB@%/*************************************************/%@AE@%%@NL@%
             %@AB@%/* Returning false to HM in this case causes the   */%@AE@%%@NL@%
             %@AB@%/* extended help panel GENERAL_HP to display.      */%@AE@%%@NL@%
             %@AB@%/* Doing it this way instead of putting FID_CLIENT */%@AE@%%@NL@%
             %@AB@%/* in SubTbl_MAIN_MENU causes the Extended help    */%@AE@%%@NL@%
             %@AB@%/* item on the help panel's pull down to be        */%@AE@%%@NL@%
             %@AB@%/* grayed out, which is the desired result.        */%@AE@%%@NL@%
             %@AB@%/*************************************************/%@AE@%%@NL@%
                    return((MRESULT)FALSE);%@NL@%
                    break;%@NL@%
%@NL@%
                default:%@NL@%
                    break;%@NL@%
            }%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
        case HM_EXT_HELP_UNDEFINED:%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
        case HM_ERROR:%@NL@%
%@NL@%
            ErrorCode = SHORT1FROMMP(mp1);%@NL@%
%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* Load the correct error message                 */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
            switch (ErrorCode)%@NL@%
            {%@NL@%
                case HMERR_NO_MEMORY:%@NL@%
                case HMERR_ALLOCATE_SEGMENT:%@NL@%
                case HMERR_FREE_MEMORY:%@NL@%
%@NL@%
                    TEDDisplayErrorID( SID_HERR_MEMORY );%@NL@%
                    break;%@NL@%
%@NL@%
                case HMERR_DATABASE_NOT_OPEN:%@NL@%
                case HMERR_OPEN_LIB_FILE:%@NL@%
                case HMERR_READ_LIB_FILE:%@NL@%
                case HMERR_CLOSE_LIB_FILE:%@NL@%
                case HMERR_INVALID_LIB_FILE:%@NL@%
%@NL@%
                    TEDDisplayErrorID( SID_HERR_LIB_ERROR );%@NL@%
                    break;%@NL@%
%@NL@%
                case HMERR_HELPITEM_NOT_FOUND:%@NL@%
                case HMERR_HELPSUBITEM_NOT_FOUND:%@NL@%
%@NL@%
                    return((MRESULT)TRUE);%@NL@%
                    break;%@NL@%
%@NL@%
                default:%@NL@%
%@NL@%
                    TEDDisplayErrorID( SID_HERR_UNKNOWN );%@NL@%
                    break;%@NL@%
%@NL@%
%@NL@%
            }   %@AB@%/* End ErrorCode switch */%@AE@%%@NL@%
%@NL@%
%@NL@%
            break;  %@AB@%/* end - case HM_ERROR: */%@AE@%%@NL@%
%@NL@%
        default:%@NL@%
%@NL@%
            break;%@NL@%
%@NL@%
    }  %@AB@%/* end the big switch */%@AE@%%@NL@%
%@NL@%
%@NL@%
    return((MRESULT)TRUE);%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TEDMEM.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\TED\TEDMEM.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    Tedmem.c%@NL@%
%@AB@%%@NL@%
%@AB@%    Created by Microsoft Corporation, IBM Corporation 1989%@NL@%
%@AB@%%@NL@%
%@AB@%----------------------------------------------------------------------------%@NL@%
%@AB@%%@NL@%
%@AB@%        This file contains the functions nessesary to allocate and free%@NL@%
%@AB@%        memory blocks.  It is implemented to return pointers and thus%@NL@%
%@AB@%        does not tie the application to Selector/Offsets etc.%@NL@%
%@AB@%%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOS %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"tedmem.h" %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    MyAllocMem - This procedure allocates a buffer of a requested length.%@NL@%
%@AB@%%@NL@%
%@AB@%        Return - FALSE if succesful otherwise TRUE%@NL@%
%@AB@%%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
APIRET APIENTRY MyAllocMem( PVOID *ppch,    %@AB@%/* Pointer to memory        */%@AE@%%@NL@%
                            ULONG usBytes,  %@AB@%/* Number of bytes to alloc */%@AE@%%@NL@%
                            ULONG ulDum1  ) %@AB@%/* Dummy                    */%@AE@%%@NL@%
{%@NL@%
%@NL@%
    APIRET apiRetVal;                       %@AB@%/* Return Value (FALSE = success*/%@AE@%%@NL@%
    PCHAR pchTemp;                          %@AB@%/* Temp ptr used to alloc mem   */%@AE@%%@NL@%
%@NL@%
%@NL@%
    if ( (apiRetVal = (APIRET) DosAllocSeg( (USHORT) usBytes,%@NL@%
                                            &SELECTOROF( pchTemp ),%@NL@%
                                            0 ) ) == (APIRET) 0 )%@NL@%
%@NL@%
    {%@NL@%
%@NL@%
    %@AB@%/* Success!! */%@AE@%%@NL@%
%@NL@%
        OFFSETOF( pchTemp ) = 0;            %@AB@%/* Set offset of selector to 0  */%@AE@%%@NL@%
        *ppch = pchTemp;                    %@AB@%/* Set passed in ptr to new mem */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
    return ( apiRetVal );%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************%@NL@%
%@AB@%%@NL@%
%@AB@%    MyFreeMem - This procedure frees a buffer that was previously allocated%@NL@%
%@AB@%                with MyAllocMem.%@NL@%
%@AB@%%@NL@%
%@AB@%       Return - FALSE if succesful otherwise TRUE%@NL@%
%@AB@%%@NL@%
%@AB@%***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
APIRET APIENTRY MyFreeMem( PVOID pvTemp )%@NL@%
{%@NL@%
%@NL@%
    return ( APIRET) DosFreeSeg( SELECTOROF( pvTemp ) );%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TERMINAL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\TERMINAL\TERMINAL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***%@NL@%
%@AB@% *%@NL@%
%@AB@% * TITLE %@NL@%
%@AB@% *%@NL@%
%@AB@% *        terminal.c%@NL@%
%@AB@% *        Created by Microsoft Corporation 1987%@NL@%
%@AB@% *%@NL@%
%@AB@% * DESCRIPTION%@NL@%
%@AB@% *%@NL@%
%@AB@% *         This program emulates an ANSI terminal device. %@NL@%
%@AB@% *%@NL@%
%@AB@% *         The device driver COM.SYS must be installed at IPL  (Initial Program%@NL@%
%@AB@% *         Load) by specifying the following in config.sys:%@NL@%
%@AB@% *                device = COM01.SYS%@NL@%
%@AB@% *%@NL@%
%@AB@% *        To run this program, type the following to the MS OS/2 prompt:%@NL@%
%@AB@% *%@NL@%
%@AB@% *                terminal [filename]%@NL@%
%@AB@% *%@NL@%
%@AB@% *         If a filename is specified, the initialisation of the COM port and%@NL@%
%@AB@% *         the MODEM will be performed as indicated in the file (creation of this%@NL@%
%@AB@% *         file is described in options.c). For more details on setting options%@NL@%
%@AB@% *        pertaining to the COM port and the MODEM, see options.c%@NL@%
%@AB@% *%@NL@%
%@AB@% *        To exit the terminal emulator, type ALT F1.%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOSSIGNALS %@NL@%
%@AI@%#define %@AE@%INCL_SUB %@NL@%
%@AI@%#define %@AE@%INCL_DOSFILEMGR %@NL@%
%@AI@%#define %@AE@%INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%INCL_DOSDEVICES %@NL@%
%@NL@%
%@AI@%#include %@AE@%       <os2def.h> %@NL@%
%@AI@%#include %@AE@%       <bse.h> %@NL@%
%@AI@%#include %@AE@%       <stdio.h> %@NL@%
%@AI@%#include %@AE@%       <malloc.h> %@NL@%
%@AI@%#include %@AE@%       <string.h> %@NL@%
%@AI@%#include %@AE@%        <memory.h> %@NL@%
%@AI@%#include %@AE@%        <conio.h> %@NL@%
%@AI@%#include %@AE@%        "term.h" %@NL@%
%@NL@%
extern void get_options(int, char *[]);   %@AB@%/* get com port and modem options */%@AE@%%@NL@%
extern void get_com_options(structComOptions *); %@AB@%/* get com options */%@AE@%%@NL@%
extern make_modem_conn(void);                  %@AB@%/* make modem connection */%@AE@%%@NL@%
extern modem(void);       %@AB@%/* returns TRUE if modem connection was requested */%@AE@%%@NL@%
extern void discon_modem(void);           %@AB@%/* disconnect modem */%@AE@%%@NL@%
%@NL@%
void init_com_port(void);                  %@AB@%/* initialise com port */%@AE@%%@NL@%
void far read_com_port(void);                  %@AB@%/* routine addr for a thread */%@AE@%%@NL@%
void write_com_port(void);                  %@AB@%/* routine addr for another thread */%@AE@%%@NL@%
void APIENTRY handle_signals(USHORT,USHORT); %@AB@%/* BREAK signals handler */%@AE@%%@NL@%
void close_conn(void);                          %@AB@%/*close modem connection & com port*/%@AE@%%@NL@%
void far xit(void);                        %@AB@%/* exit routine for this program */%@AE@%%@NL@%
%@NL@%
char *ErrMsg[] = {%@NL@%
                "VIOGETCONFIG",%@NL@%
                "KBDSETSTATUS",%@NL@%
                       "OUT OF MEMORY",%@NL@%
                "DOSCREATETHREAD",%@NL@%
                "DOSCLOSE COMPORT",%@NL@%
                "DOSDEVIOCTL SETDCB",%@NL@%
                "DOSREAD",%@NL@%
                "VIOWRTTTY",%@NL@%
                "DOSOPEN: check if COM driver is installed",%@NL@%
                "DOSDEVIOCTL SETBAUD",%@NL@%
                "DOSDEVIOCTL SETLINECHAR",%@NL@%
                "DOSDEVIOCTL GETDCB",%@NL@%
                "KBDCHARIN",%@NL@%
                "DOSWRITE",%@NL@%
                "VIOWRTCHARSTRATT",%@NL@%
                "VIOWRTNCELL",%@NL@%
                "DOSEXITLIST ADD_ADDR",%@NL@%
                "VIOSETCURPOS",%@NL@%
                "VIOGETMODE",%@NL@%
                "DOSDEVIOCTL FLUSH_XMIT_RECV_QUEUE",%@NL@%
                "DOSDEVIOCTL GETCOM",%@NL@%
                "DOSSETSIGHANDLER",%@NL@%
                "DOSDEVIOCTL SETBREAKON",%@NL@%
                "DOSDEVIOCTL SETBREAKOFF",%@NL@%
                       "INVALID SIGNAL",%@NL@%
                       "do_option: invalid option type",%@NL@%
                       "mod_option: invalid option type",%@NL@%
                       "show_option: invalid option type"%@NL@%
};%@NL@%
HFILE                FileHndl = (HFILE) NULL;    %@AB@%/* COM port file handle */%@AE@%%@NL@%
%@NL@%
static char        ExitPgm = FALSE;    %@AB@%/* indicate if program should terminate */%@AE@%%@NL@%
static int        ErrorNumber = -1,   %@AB@%/* used as index to ErrMsg array */%@AE@%%@NL@%
                ReturnCode  = -1;   %@AB@%/* retcode from system/subsystem call */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        main - entry point to TERMINAL program%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine obtains the com port and the modem options from the file%@NL@%
%@AB@% *      (specified in the command line) or directly from the user. It opens and%@NL@%
%@AB@% *        initialises the com port. It sets up the modem connection (if one was%@NL@%
%@AB@% *        requested). It creates a thread which loops continuously waiting to %@NL@%
%@AB@% *        receive data from the com port and writing it out to the display. It %@NL@%
%@AB@% *        loops continuosly waiting for an input from the keyboard and writing %@NL@%
%@AB@% *        it out to the com port. Both the loops terminate when the user presses %@NL@%
%@AB@% *        ALT-F1. It closes the modem connection (if one was made), and the com %@NL@%
%@AB@% *        port and then terminates.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        main(argc, argv)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY        %@NL@%
%@AB@% *                argc - number of command line arguments%@NL@%
%@AB@% *                argv - pointer to an array of pointers (to command line args)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                the program terminates%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
 %@NL@%
main(argc,argv)%@NL@%
int         argc;%@NL@%
char         *argv[];%@NL@%
{%@NL@%
        UCHAR                *Stack1;             %@AB@%/* stack for a thread */%@AE@%%@NL@%
        TID                ThreadID;%@NL@%
        unsigned        RetCode,             %@AB@%/* return code */%@AE@%%@NL@%
                        Result = TRUE;%@NL@%
        USHORT                NumBytes;             %@AB@%/* number of bytes to be written */%@AE@%%@NL@%
        PFNSIGHANDLER        PrevAddress;%@NL@%
        USHORT                PrevAction;%@NL@%
        static KBDINFO OurKbdStatus =%@NL@%
                                   {sizeof(OurKbdStatus),KBD_BITMASK,};%@NL@%
%@NL@%
        %@AB@%/* get COM port and modem options */%@AE@%%@NL@%
        get_options(argc, argv);        %@NL@%
%@NL@%
        %@AB@%/* open and initialise COM port */%@AE@%%@NL@%
        init_com_port();                        %@NL@%
%@NL@%
        %@AB@%/* establish xit() as the exit routine */%@AE@%%@NL@%
        if ((RetCode = DosExitList(EXLST_ADD, (PFNEXITLIST)xit)) != 0)%@NL@%
          error(ERR_DOSEXITLIST, RetCode);%@NL@%
%@NL@%
        %@AB@%/* make modem connection if requested */%@AE@%%@NL@%
        if (modem())%@NL@%
          Result = make_modem_conn();        %@NL@%
%@NL@%
        if (Result) {%@NL@%
          %@AB@%/* allocate memory for separate thread execution */%@AE@%%@NL@%
          if (!(Stack1 = (char *) _nmalloc(STACKSIZE)))%@NL@%
            error(ERR_OUTOFMEMORY, NO_RETCODE);%@NL@%
%@NL@%
          %@AB@%/* create a thread that will execute the read_com_port() */%@AE@%%@NL@%
          Stack1 += STACKSIZE;%@NL@%
          if ((RetCode = DosCreateThread(read_com_port, &ThreadID,%@NL@%
                                         Stack1)) != 0)%@NL@%
            error(ERR_DOSCREATETHREAD, RetCode);%@NL@%
%@NL@%
          %@AB@%/* set the keyboard status */%@AE@%%@NL@%
          if ((RetCode = KbdSetStatus(&OurKbdStatus,%@NL@%
                                      RESERVED)) != 0) %@NL@%
            error(ERR_KBDSETSTATUS, RetCode);%@NL@%
%@NL@%
          %@AB@%/* set signal handler for BREAK signal */%@AE@%%@NL@%
          if ((RetCode = DosSetSigHandler(handle_signals,%@NL@%
                         &PrevAddress,%@NL@%
                         &PrevAction,%@NL@%
                         RECV_CTRL, BREAK)) != 0)%@NL@%
            error(ERR_DOSSETSIGHANDLER, RetCode);%@NL@%
%@NL@%
          %@AB@%/* display "connected" message */%@AE@%%@NL@%
          printf("connected... \n");%@NL@%
%@NL@%
          %@AB@%/* read chars from the keyboard and write to COM port */%@AE@%%@NL@%
          write_com_port();%@NL@%
        }        %@AB@%/* if (Result) */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        init_com_port - open the COM port and initialise line characteristics%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine opens the com port. It sets the com port options %@NL@%
%@AB@% *        BaudRate, DataBits, Parity and the StopBits. It sets the read timeout.%@NL@%
%@AB@% *        It enables the automatic transmit and receive flow control.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        init_com_port()%@NL@%
%@AB@% *                %@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                %@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                FileHndl = handle to com port%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
void init_com_port()%@NL@%
{%@NL@%
        USHORT                ActionTaken; %@AB@%/* action: file existed,created,replaced */%@AE@%%@NL@%
        unsigned        RetCode;%@NL@%
        structLineChar         sLineChar;        %@AB@%/* line characteristics */%@AE@%%@NL@%
        structDCB        sDCB;                %@AB@%/* device control block information */%@AE@%%@NL@%
        structComOptions sComOptions;%@NL@%
%@NL@%
        get_com_options(&sComOptions);%@NL@%
%@NL@%
        %@AB@%/* open the com port */%@AE@%%@NL@%
        if ((RetCode = DosOpen(sComOptions.pPortName, &FileHndl,%@NL@%
                               &ActionTaken, 0L, 0, 0x0001, 0x0042, 0L)) != 0)%@NL@%
          error(ERR_DOSOPEN, RetCode);%@NL@%
%@NL@%
        %@AB@%/* set the baud rate */%@AE@%%@NL@%
        if ((RetCode = DosDevIOCtl(0L, &(sComOptions.iBaudRate),%@NL@%
                                   SETBAUD, SERIAL, FileHndl)) != 0)%@NL@%
          error(ERR_IOCTLSETBAUD, RetCode);%@NL@%
%@NL@%
        %@AB@%/* set Data Bits, Stop Bits, Parity */%@AE@%%@NL@%
        sLineChar.DataBits = sComOptions.chDataBits; %@NL@%
        sLineChar.Parity   = sComOptions.chParity; %@NL@%
        sLineChar.StopBits = sComOptions.chStopBits;%@NL@%
        if ((RetCode = DosDevIOCtl(0L, &sLineChar, SETLINECHAR,%@NL@%
                                   SERIAL, FileHndl)) != 0)%@NL@%
          error(ERR_IOCTLSETLINECHAR, RetCode);%@NL@%
%@NL@%
        %@AB@%/* get device control block info */%@AE@%%@NL@%
        if ((RetCode = DosDevIOCtl(&sDCB, 0L, GETDCB, SERIAL,%@NL@%
                                   FileHndl)) != 0)%@NL@%
          error(ERR_IOCTLGETDCB, RetCode);%@NL@%
%@NL@%
        sDCB.Flags2 |= 0x03;        %@AB@%/* enable auto Xmit and recv flow control */%@AE@%%@NL@%
        sDCB.Flags3 &= 0xf9;        %@AB@%/* clear read timeout flags */%@AE@%%@NL@%
        sDCB.Flags3 |= 0x04;        %@AB@%/* set wait for something read timeout */%@AE@%%@NL@%
        sDCB.ReadTimeOut = READTIMEOUT;        %@AB@%/* set read timout value */%@AE@%%@NL@%
%@NL@%
        %@AB@%/* set device control block info */%@AE@%%@NL@%
        if ((RetCode = DosDevIOCtl(0L, &sDCB, SETDCB, SERIAL,%@NL@%
                                    FileHndl)) != 0)%@NL@%
          error(ERR_IOCTLSETDCB, RetCode);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        write_com_port        - read chars from the keyboard and write to COM port%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine loops continuosly waiting for a keyboard input and%@NL@%
%@AB@% *        writing it out to the com port. The loop terminates when the user%@NL@%
%@AB@% *        presses the ALT-F1.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        write_com_port()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
void write_com_port()%@NL@%
{%@NL@%
        USHORT                NumBytes;        %@AB@%/* number of bytes actually written */%@AE@%%@NL@%
        unsigned        RetCode;%@NL@%
        char                OutBuffer;        %@AB@%/* output buffer */%@AE@%%@NL@%
        KBDKEYINFO        OurKeyData;        %@AB@%/* struc to read a char from kbd */%@AE@%%@NL@%
%@NL@%
%@NL@%
        while (!ExitPgm) {%@NL@%
          %@AB@%/* read input from the keyboard */%@AE@%%@NL@%
          if ((RetCode = KbdCharIn(&OurKeyData,%@NL@%
                                   IOWAIT, RESERVED)) != 0) %@NL@%
            error(ERR_KBDCHARIN, RetCode);%@NL@%
          OutBuffer = OurKeyData.chChar;%@NL@%
          if ((OutBuffer == 0) || (OutBuffer == 0xE0)) {%@NL@%
            OutBuffer = OurKeyData.chScan;%@NL@%
            switch (OutBuffer) {%@NL@%
              case DEL_SCAN  : OutBuffer = DEL_ASCII;%@NL@%
                               break;%@NL@%
              case ALT_F1    : ExitPgm = TRUE;%@NL@%
                               break;%@NL@%
              default        : break;%@NL@%
            };%@NL@%
            if (OutBuffer != ALT_F1) %@NL@%
              %@AB@%/* write the input from the keyboard to the com port */%@AE@%%@NL@%
              if ((RetCode = DosWrite(FileHndl, &OutBuffer, 1,%@NL@%
                                      &NumBytes)) != 0)%@NL@%
                error(ERR_DOSWRITE, RetCode);%@NL@%
          }%@NL@%
          else {%@NL@%
            %@AB@%/* write the input from the keyboard to the com port */%@AE@%%@NL@%
            if ((RetCode = DosWrite(FileHndl, &OutBuffer, 1,%@NL@%
                                    &NumBytes)) != 0)%@NL@%
              error(ERR_DOSWRITE, RetCode);%@NL@%
          };%@NL@%
        };%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***         read_com_port - read chars from com port and display on CRT screen%@NL@%
%@AB@% *%@NL@%
%@AB@% *         This routine is executed by a thread. It loops continuously waiting%@NL@%
%@AB@% *      to receive data from the com port and writing it out to the display.%@NL@%
%@AB@% *        The loop terminates when the user presses ALT-F1.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        read_com_port()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                FileHndl (handle to com port) setup%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
 %@NL@%
void far read_com_port()%@NL@%
{%@NL@%
        USHORT                NumBytes;        %@AB@%/* number of bytes actually read */%@AE@%%@NL@%
        unsigned        RetCode;%@NL@%
        struct CharsInQue {         %@AB@%/*data ret'ned by get num chars in que IOCTL*/%@AE@%%@NL@%
                        unsigned         NumCharsInQue;%@NL@%
                        unsigned        SizeQue;%@NL@%
        } sCharsInQue;%@NL@%
        char                InBuffer[INBUFLENGTH];        %@AB@%/* input buffer  */%@AE@%%@NL@%
%@NL@%
        while (!ExitPgm) {%@NL@%
          %@AB@%/* get number of characters in receive queue */%@AE@%%@NL@%
          if ((RetCode = DosDevIOCtl(&sCharsInQue, 0L, GETNUMCHARS,%@NL@%
                                     SERIAL, FileHndl)) != 0)%@NL@%
            setup_error_msg(ERR_IOCTLSETDCB, RetCode);%@NL@%
%@NL@%
          if (sCharsInQue.NumCharsInQue == 0)%@NL@%
             sCharsInQue.NumCharsInQue++;%@NL@%
%@NL@%
          if ((RetCode = DosRead(FileHndl, InBuffer, sCharsInQue.NumCharsInQue,%@NL@%
                                 &NumBytes)) != 0)%@NL@%
            setup_error_msg(ERR_DOSREAD, RetCode);%@NL@%
        %@NL@%
          if (NumBytes) {%@NL@%
            %@AB@%/* write to the tty display */%@AE@%%@NL@%
            if ((RetCode = VioWrtTTY(InBuffer, NumBytes, RESERVED)) != 0)%@NL@%
              setup_error_msg(ERR_VIOWRTTTY, RetCode);%@NL@%
          }%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        handle_signals  - handle BREAK signal%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine is the handler for the BREAK signal. When the user presses%@NL@%
%@AB@% *        the BREAK key, this routine sends a BREAK on the com line.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        handle_signals(SigArg, SigNumber)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                SigArg - not used%@NL@%
%@AB@% *                SigNumber - signal number being processed%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *            Since this is a signal handler it must be declared FAR.%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
void APIENTRY handle_signals(SigArg, SigNumber)%@NL@%
USHORT        SigArg,%@NL@%
        SigNumber;%@NL@%
{%@NL@%
        unsigned        RetCode,%@NL@%
                        Status;%@NL@%
        char                OutBuffer;%@NL@%
%@NL@%
        switch (SigNumber) {%@NL@%
        case BREAK :%@AB@%/* send BREAK to the com port */%@AE@%%@NL@%
                    if ((RetCode = DosDevIOCtl(&Status, 0L,%@NL@%
                                       SETBREAKON, SERIAL, FileHndl)) != 0)%@NL@%
                      error(ERR_IOCTLSETBREAKON, RetCode);%@NL@%
                    DosSleep(1L);%@NL@%
                    if ((RetCode = DosDevIOCtl(&Status, 0L,%@NL@%
                                       SETBREAKOFF, SERIAL, FileHndl)) != 0)%@NL@%
                      error(ERR_IOCTLSETBREAKOFF, RetCode);%@NL@%
                    break;%@NL@%
        default    :%@NL@%
                    error(ERR_INVALIDSIGNAL, NO_RETCODE);%@NL@%
                    break;%@NL@%
        }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        close_conn - close modem connection and the com port%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine closes the modem connection if one was made and then%@NL@%
%@AB@% *        closes the com port.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        close_conn()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
void close_conn()%@NL@%
{%@NL@%
        int                RetCode;%@NL@%
        static char         CloseMsg[] = "exiting terminal...";%@NL@%
%@NL@%
        %@AB@%/* send closing message to the display */%@AE@%%@NL@%
        if ((RetCode = VioWrtTTY(CloseMsg, sizeof(CloseMsg), RESERVED)) != 0)%@NL@%
          print_err_msg(ErrMsg[ERR_VIOWRTTTY], RetCode);%@NL@%
%@NL@%
        %@AB@%/* if modem connection was made, close it */%@AE@%%@NL@%
        if (modem())%@NL@%
          discon_modem();%@NL@%
%@NL@%
        %@AB@%/* close the com port */%@AE@%%@NL@%
        if ((RetCode = DosClose(FileHndl)) != 0)%@NL@%
          print_err_msg(ErrMsg[ERR_DOSCLOSECOMPORT], RetCode);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***                ERROR HANDLING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        There are two error handling routines:%@NL@%
%@AB@% *                - error() which is invoked from the main thread%@NL@%
%@AB@% *                - setup_err_msg() which is invoked from the thread executing %@NL@%
%@AB@% *                  the read_com_port() routine%@NL@%
%@AB@% *        The two routines perform different functions (described below). This%@NL@%
%@AB@% *        is done so that if an error is encountered "simultaneously" in both %@NL@%
%@AB@% *        the threads, there will be no race condition in error reporting.%@NL@%
%@AB@% *        %@NL@%
%@AB@% *        The following routines are also part of the error handling:%@NL@%
%@AB@% *                - xit() is a DosExitList routine%@NL@%
%@AB@% *                - print_err_msg() does the actual printing of the error message%@NL@%
%@AB@% *        %@NL@%
%@AB@% *        All the routines discussed above are defined below.%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        error%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine is invoked when there is an error. It prints an%@NL@%
%@AB@% *        an error message and calls DosExit.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        error(ErrNum, RetCode)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                ErrNum - error number (used as index to error message array)%@NL@%
%@AB@% *                RetCode - return code from a DOS system/subsystem call%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                global variables ErrorNumber & ReturnCode still contain the%@NL@%
%@AB@% *                initial value of -1. At program termination (via DosExit call)%@NL@%
%@AB@% *                the DosExitList routine xit() is invoked (described below).%@NL@%
%@AB@% *                On return from xit(), this program will terminate.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
error(ErrNum, RetCode)%@NL@%
int  ErrNum;%@NL@%
int  RetCode;%@NL@%
{%@NL@%
        print_err_msg(ErrMsg[ErrNum], RetCode);%@NL@%
        DosExit(EXIT_PROCESS, 1);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        setup_error_msg - setup error message%@NL@%
%@AB@% *%@NL@%
%@AB@% *        Sets up the global ErrorNumber and ReturnCode. It then calls DosExit.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        setup_error_msg(ErrNum, RetCode)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                ErrNum - error number (used as index to error message array)%@NL@%
%@AB@% *                RetCode - return code from a DOS system/subsystem call%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                global variables ErrorNumber & ReturnCode are setup. At %@NL@%
%@AB@% *                program termination (via DosExit call) the DosExitList%@NL@%
%@AB@% *                routine xit() is invoked (described below). xit() will print%@NL@%
%@AB@% *                an error message. On return from xit(), this program will %@NL@%
%@AB@% *                terminate.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
setup_error_msg(ErrNum, RetCode)%@NL@%
int        ErrNum,%@NL@%
        RetCode;%@NL@%
{%@NL@%
        ErrorNumber = ErrNum;%@NL@%
        ReturnCode  = RetCode;%@NL@%
        DosExit(EXIT_PROCESS, 1);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        xit        - exit function executed at program termination%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This is a DosExitList routine. It prints an error message if%@NL@%
%@AB@% *        the global variable ErrorNumber is non-negative.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        xit()%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *                If ErrorNumber is non-negative, an error message is printed.%@NL@%
%@AB@% *                The program will then terminate.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
void far xit(void)%@NL@%
{%@NL@%
        if (ErrorNumber != -1) %@NL@%
          print_err_msg(ErrMsg[ErrorNumber], ReturnCode);%@NL@%
        close_conn();                 %@AB@%/* close modem connection and the com port */%@AE@%%@NL@%
        DosExitList(XFER, 0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***        print_err_msg - print error mesage%@NL@%
%@AB@% *%@NL@%
%@AB@% *        This routine prints an error message and the returncode.%@NL@%
%@AB@% *%@NL@%
%@AB@% *        print_err_msg(Msg, Retcode)%@NL@%
%@AB@% *%@NL@%
%@AB@% *        ENTRY%@NL@%
%@AB@% *                Msg - error message string%@NL@%
%@AB@% *                Retcode - returncode from DOS system/subsystem call%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EXIT%@NL@%
%@AB@% *%@NL@%
%@AB@% *        WARNING%@NL@%
%@AB@% *%@NL@%
%@AB@% *        EFFECTS%@NL@%
%@AB@% *%@NL@%
%@AB@% ***/%@AE@%%@NL@%
%@NL@%
print_err_msg(Msg, RetCode)%@NL@%
char        *Msg;%@NL@%
int        RetCode;%@NL@%
%@NL@%
{%@NL@%
          printf("*** ERROR %s *** ", Msg);%@NL@%
         if (RetCode != -1)%@NL@%
          printf("ReturnCode = %d ", RetCode);%@NL@%
        printf("\n");%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TEST.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\TEST.C%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINCATCHTHROW  %@NL@%
%@AI@%#include %@AE@%"ddemlp.h" %@NL@%
%@AI@%#include %@AE@%"stdio.h" %@NL@%
%@NL@%
int        APIENTRY DebugOutput( PCH );        %@AB@%/* private import */%@AE@%%@NL@%
CATCHBUF catchbuf;%@NL@%
%@NL@%
void DumpItems(PULONG pul, USHORT c);%@NL@%
void err(PSZ psz);%@NL@%
void err2(PSZ psz, ULONG ul);%@NL@%
%@NL@%
typedef struct _ULLI {%@NL@%
    PLITEM next;%@NL@%
    ULONG ul;%@NL@%
} ULLI;%@NL@%
typedef ULLI FAR *PULLI;%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * exported for testing the DLL%@NL@%
%@AB@% */%@AE@%%@NL@%
void EXPENTRY DdeTest()%@NL@%
{%@NL@%
%@AI@%#if %@AE@%0     %@NL@%
    SEL sel;%@NL@%
    USHORT c;%@NL@%
    ULLI SchItem;%@NL@%
    PLST plst;%@NL@%
    PPILE ppile;%@NL@%
    HHEAP hheap;%@NL@%
    PLITEM pli;%@NL@%
    PBYTE pbytes;%@NL@%
%@NL@%
    AssertF(FALSE, "Testing assertion failure");%@NL@%
    %@NL@%
    DebugOutput("\n\rList functions test\n\r");%@NL@%
    SemEnter();%@NL@%
    if (DosAllocSeg(2000, &sel, SEG_NONSHARED))%@NL@%
        err("DosAllocSeg failed");%@NL@%
    if (!(hheap = MyCreateHeap(sel, 0, 0, 0, 0, HEAPFLAGS)))%@NL@%
        err("CreateHeap failed");%@NL@%
    if (!(pbytes = FarAllocMem(hheap, 1000)))%@NL@%
        err("Could not allocate bytes");%@NL@%
    plst = NULL;%@NL@%
    SchItem.ul = 4L;%@NL@%
    SemLeave();%@NL@%
    DebugOutput("\n\rNULL list test....");%@NL@%
    SemEnter();%@NL@%
    DestroyLst(plst);%@NL@%
    FlushLst(plst);%@NL@%
    FindLstItem(plst, CmpULONG, (PLITEM)&SchItem);%@NL@%
    FindLstItem(plst, CmpULONG, NULL);%@NL@%
    FindLstItem(plst, NULL, (PLITEM)&SchItem);%@NL@%
    FindLstItem(plst, NULL, NULL);%@NL@%
    NewLstItem(plst, ILST_NOLINK);%@NL@%
    NewLstItem(plst, ILST_FIRST);%@NL@%
    NewLstItem(plst, ILST_LAST);%@NL@%
    PopLi(plst);%@NL@%
    RemoveLstItem(plst, (PLITEM)&SchItem);%@NL@%
    RemoveLstItem(plst, NULL);%@NL@%
    InsertLstItem(plst, (PLITEM)&SchItem, ILST_FIRST);%@NL@%
    SemLeave();%@NL@%
    DebugOutput("\n\rCreateList...");%@NL@%
    SemEnter();%@NL@%
    plst = CreateLst(hheap, sizeof(ULONG));%@NL@%
    if (!plst) %@NL@%
        err("CreateLst() failed");%@NL@%
    pli = NewLstItem(plst, ILST_FIRST);%@NL@%
    if (!pli)%@NL@%
        err("NewLstItem() failed");%@NL@%
    ((PULLI)pli)->ul = 1L;%@NL@%
    SchItem.ul = 1L;%@NL@%
    if (pli != FindLstItem(plst, CmpULONG, (PLITEM)&SchItem))%@NL@%
        err("FindLstItem() failed");%@NL@%
    if (pli != PopLi(plst)) {%@NL@%
        err("PopLi() failed");%@NL@%
    }%@NL@%
    if (FindLstItem(plst, NULL, NULL)) %@NL@%
        err("unexpected success of FindLstItem()");%@NL@%
    for (SchItem.ul = 1L; SchItem.ul < 100L; SchItem.ul++) {%@NL@%
        if (!(pli = NewLstItem(plst, ILST_FIRST)))%@NL@%
            err("NewLstItem() failed");%@NL@%
        ((PULLI)pli)->ul = SchItem.ul;%@NL@%
        if (!FindLstItem(plst, CmpULONG, (PLITEM)&SchItem))%@NL@%
            err2("Item %ul not found", SchItem.ul);%@NL@%
    }%@NL@%
    SchItem.ul = 25L;%@NL@%
    if (!RemoveLstItem(plst, FindLstItem(plst, CmpULONG, (PLITEM)&SchItem)))%@NL@%
        err2("RemoveLstItem() failed on %ul", SchItem.ul);%@NL@%
    SchItem.ul = 47L;%@NL@%
    if (!RemoveLstItem(plst, FindLstItem(plst, CmpULONG, (PLITEM)&SchItem)))%@NL@%
        err2("RemoveLstItem() failed on %ul", SchItem.ul);%@NL@%
    SchItem.ul = 78L;%@NL@%
    if (!RemoveLstItem(plst, FindLstItem(plst, CmpULONG, (PLITEM)&SchItem)))%@NL@%
        err2("RemoveLstItem() failed on %ul", SchItem.ul);%@NL@%
    for (SchItem.ul = 1L; SchItem.ul < 100L; SchItem.ul++) {%@NL@%
        if (SchItem.ul == 25L || SchItem.ul == 47L || SchItem.ul == 78L) {%@NL@%
            if (FindLstItem(plst, CmpULONG, (PLITEM)&SchItem))%@NL@%
                err2("Unexpected find of %ul", SchItem.ul);%@NL@%
        } else if (!FindLstItem(plst, CmpULONG, (PLITEM)&SchItem))%@NL@%
            err2("Unexpected failure to find %ul", SchItem.ul);%@NL@%
    }%@NL@%
    FlushLst(plst);%@NL@%
    if (PopLi(plst))%@NL@%
        err("Unexpected pass of PopLi()");%@NL@%
    DestroyLst(plst);%@NL@%
    plst = NULL;%@NL@%
    SemLeave();%@NL@%
    DebugOutput("\n\rList test passed.\n\r");%@NL@%
%@NL@%
%@NL@%
    DebugOutput("\n\rNULL Pile test...");%@NL@%
    SemEnter();%@NL@%
    ppile = NULL;%@NL@%
    DestroyPile(ppile);%@NL@%
    FlushPile(ppile);%@NL@%
    if (QPileItemCount(ppile))%@NL@%
        err("Unexpected pass of QPileItemCount()");%@NL@%
    if (CopyPileItems(ppile, pbytes))%@NL@%
        err("Unexpected pass of CopyPileItems()");%@NL@%
    if (FindPileItem(ppile, NULL, NULL, FPI_COUNT))%@NL@%
        err("Wrong count from FindPileItem()");%@NL@%
    if (FindPileItem(ppile, NULL, NULL, FPI_DELETE))%@NL@%
        err("Unexpected pass of FindPileItem()");%@NL@%
    if (AddPileItem(ppile, NULL, NULL))%@NL@%
        err("Unexpected pass of AddPileItem()");%@NL@%
    %@NL@%
    SemLeave();%@NL@%
    DebugOutput("\n\rPile test...");%@NL@%
    SemEnter();%@NL@%
    if (!(ppile = CreatePile(hheap, sizeof(ULONG), 8)))%@NL@%
        err("Unexpected failure of CreatePile()");%@NL@%
    for (SchItem.ul = 1L; SchItem.ul < 100; SchItem.ul++) {%@NL@%
        AddPileItem(ppile, (PBYTE)&SchItem.ul, CmpULONG);%@NL@%
        if (SchItem.ul > 25) %@NL@%
            if (AddPileItem(ppile, (PBYTE)&SchItem.ul, CmpULONG))%@NL@%
                err("Unexpected TRUE(1) return by AddPileItem()");%@NL@%
        if (SchItem.ul > 50) %@NL@%
            if (AddPileItem(ppile, (PBYTE)&SchItem.ul, CmpULONG))%@NL@%
                err("Unexpected TRUE(2) return by AddPileItem()");%@NL@%
        if (SchItem.ul > 75) %@NL@%
            if (AddPileItem(ppile, (PBYTE)&SchItem.ul, CmpULONG))%@NL@%
                err("Unexpected TRUE(3) return by AddPileItem()");%@NL@%
    }%@NL@%
    if (QPileItemCount(ppile) != 99)%@NL@%
        err("Total pile count wrong");%@NL@%
    for (SchItem.ul = 1L; SchItem.ul < 100L; SchItem.ul++) {%@NL@%
        if (1 != (USHORT)FindPileItem(ppile, CmpULONG, (PBYTE)&SchItem.ul, FPI_COUNT))%@NL@%
            err("Wrong count of items found by FindPileItem()");%@NL@%
    }                                                 %@NL@%
    for (SchItem.ul = 26L; SchItem.ul < 100L; SchItem.ul++) {%@NL@%
        AddPileItem(ppile, (PBYTE)&SchItem.ul, NULL);%@NL@%
        if (SchItem.ul > 50) %@NL@%
            if (!AddPileItem(ppile, (PBYTE)&SchItem.ul, NULL))%@NL@%
                err("Unexpected FALSE(2) return by AddPileItem()");%@NL@%
        if (SchItem.ul > 75) %@NL@%
            if (!AddPileItem(ppile, (PBYTE)&SchItem.ul, NULL))%@NL@%
                err("Unexpected FALSE(3) return by AddPileItem()");%@NL@%
    }%@NL@%
    for (SchItem.ul = 1L; SchItem.ul < 26L; SchItem.ul++) {%@NL@%
        c = (USHORT)FindPileItem(ppile, CmpULONG, (PBYTE)&SchItem.ul, FPI_COUNT);%@NL@%
        if (c != 1)%@NL@%
            err("Wrong count of items found by FindPileItem()");%@NL@%
    }                                                 %@NL@%
    for (SchItem.ul = 26L; SchItem.ul < 51L; SchItem.ul++) {%@NL@%
        c = (USHORT)FindPileItem(ppile, CmpULONG, (PBYTE)&SchItem.ul, FPI_COUNT);%@NL@%
        if (c != 2)%@NL@%
            err("Wrong count of items found by FindPileItem()");%@NL@%
    }                                                 %@NL@%
    for (SchItem.ul = 51L; SchItem.ul < 76L; SchItem.ul++) {%@NL@%
        c = (USHORT)FindPileItem(ppile, CmpULONG, (PBYTE)&SchItem.ul, FPI_COUNT);%@NL@%
        if (c != 3)%@NL@%
            err("Wrong count of items found by FindPileItem()");%@NL@%
    }                                                 %@NL@%
    for (SchItem.ul = 76L; SchItem.ul < 100L; SchItem.ul++) {%@NL@%
        c = (USHORT)FindPileItem(ppile, CmpULONG, (PBYTE)&SchItem.ul, FPI_COUNT);%@NL@%
        if (c != 4)%@NL@%
            err("Wrong count of items found by FindPileItem()");%@NL@%
    }%@NL@%
    if ((c = QPileItemCount(ppile)) != 99 + 74 + 49 + 24)%@NL@%
        err("Total pile count wrong");%@NL@%
    CopyPileItems(ppile, pbytes);%@NL@%
    DestroyPile(ppile);%@NL@%
    SemLeave();%@NL@%
    DumpItems((PULONG)pbytes, c);%@NL@%
    MyDestroyHeap(hheap);%@NL@%
%@AI@%#endif %@AE@%    %@NL@%
    return;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
void DumpItems(pul, c)%@NL@%
PULONG pul;%@NL@%
USHORT c;%@NL@%
{%@NL@%
    char sz[100];%@NL@%
    char far *psz;%@NL@%
%@NL@%
    psz = sz;%@NL@%
    while (c--) {%@NL@%
        if ((c % 7) == 0) {%@NL@%
            *psz++ = '\n';%@NL@%
            *psz++ = '\r';%@NL@%
            *psz++ = '\0';%@NL@%
            DebugOutput(sz);%@NL@%
            psz = sz;%@NL@%
        }%@NL@%
        psz = ltoa(*pul, psz, &sz[99]);%@NL@%
        *psz++ = ' ';%@NL@%
        pul++;%@NL@%
    }%@NL@%
    *psz++ = '\n';%@NL@%
    *psz++ = '\r';%@NL@%
    *psz++ = '\0';%@NL@%
    DebugOutput(sz);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
void err(psz)%@NL@%
PSZ psz;%@NL@%
{%@NL@%
    SemLeave();%@NL@%
    DebugOutput(psz);%@NL@%
}%@NL@%
%@NL@%
void err2(psz, ul)%@NL@%
PSZ psz;%@NL@%
ULONG ul;%@NL@%
{%@NL@%
    char sz[80];%@NL@%
%@NL@%
    SemLeave();%@NL@%
    sz[0] = '\000';%@NL@%
    psz = lstrcat(sz, psz, &sz[79]);%@NL@%
    psz = ltoa(ul, psz, &sz[79]);%@NL@%
    DebugOutput(sz);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TESTSUBS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\MONITOR\TESTSUBS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name: TestSubs.C%@NL@%
%@AB@%*%@NL@%
%@AB@%* Collection of useful routines for test applications%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created: 16-Jan-87%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1985, 1986, 1987  Microsoft Corporation%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINHEAP %@NL@%
%@AI@%#define %@AE@%INCL_WINWINDOWMGR %@NL@%
%@AI@%#define %@AE@%INCL_WINRECTANGLES %@NL@%
%@AI@%#define %@AE@%INCL_WINTIMER %@NL@%
%@AI@%#define %@AE@%INCL_WINSYS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"monitor.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************/%@AE@%%@NL@%
%@NL@%
extern HAB hab;%@NL@%
%@NL@%
%@AB@%/* StringWindow structure */%@AE@%%@NL@%
typedef struct {%@NL@%
    int cchLine;%@NL@%
    int cLine;%@NL@%
    char *pchBuffer;%@NL@%
    char *pchBufferMax;%@NL@%
    char *pchBottomLine;%@NL@%
    char *pchOutput;%@NL@%
} STRWND;%@NL@%
%@NL@%
int cyChar;                     %@AB@%/* Height of a line */%@AE@%%@NL@%
int cyDescent;%@NL@%
%@NL@%
USHORT ticks;                     %@AB@%/* Tick count used with StartTime/StopTime */%@AE@%%@NL@%
%@NL@%
HHEAP hhp = NULL;%@NL@%
%@NL@%
%@AB@%/***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* BOOL InitTestSubs( )%@NL@%
%@AB@%*%@NL@%
%@AB@%* This routine MUST be called before using anything in this file.  Registers%@NL@%
%@AB@%* window classes, loads brushes, etc.  Returns TRUE if successful, FALSE%@NL@%
%@AB@%* otherwise.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Warnings: Must be called AFTER the global variable NULL is initialized.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*  19-Jan-87 by neilk  Created%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL InitTestSubs()%@NL@%
{%@NL@%
    cyChar = 14;%@NL@%
    cyDescent = 2;%@NL@%
%@NL@%
    if (!WinRegisterClass(hab, (PCH)"StringWindow", (PFNWP)StrWndProc,%@NL@%
       CS_SYNCPAINT, sizeof(STRWND *)))%@NL@%
        return(FALSE);%@NL@%
%@NL@%
    hhp = WinCreateHeap(0, 0, 0, 0, 0, 0);%@NL@%
%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void%@NL@%
NextLine(%@NL@%
STRWND *psw)%@NL@%
{    %@NL@%
    psw->pchBottomLine += psw->cchLine;%@NL@%
    if (psw->pchBottomLine == psw->pchBufferMax)%@NL@%
        psw->pchBottomLine = psw->pchBuffer;%@NL@%
    psw->pchOutput = psw->pchBottomLine;%@NL@%
    *psw->pchOutput = '\0';%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* VOID DrawString(hwnd, sz)%@NL@%
%@AB@%*%@NL@%
%@AB@%* This routine prints a string in the specified StringWindow class window.%@NL@%
%@AB@%* sz is a near pointer to a zero-terminated string, which can be produced%@NL@%
%@AB@%* with sprintf().%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*  19-Jan-87 by neilk  Created%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID DrawString(hwnd, sz)%@NL@%
HWND hwnd;%@NL@%
char *sz;%@NL@%
{%@NL@%
    register STRWND *psw;%@NL@%
    USHORT cLines = 0;%@NL@%
%@NL@%
    psw = (STRWND *)WinQueryWindowUShort(hwnd, 0);%@NL@%
    NextLine(psw);%@NL@%
    cLines++;%@NL@%
%@NL@%
    while (*sz) {%@NL@%
        switch (*sz) {%@NL@%
        case 0x0a:%@NL@%
            break;%@NL@%
            %@NL@%
        case 0x09:%@NL@%
            *psw->pchOutput++ = ' ';%@NL@%
            *psw->pchOutput++ = ' ';%@NL@%
            *psw->pchOutput++ = ' ';%@NL@%
            *psw->pchOutput++ = ' ';%@NL@%
            break;%@NL@%
            %@NL@%
        case 0x0d:%@NL@%
            *psw->pchOutput++ = '\0';%@NL@%
            NextLine(psw);%@NL@%
            cLines++;%@NL@%
            break;%@NL@%
            %@NL@%
        default:%@NL@%
            *psw->pchOutput++ = *sz;%@NL@%
        }%@NL@%
        sz++;%@NL@%
    }%@NL@%
    WinScrollWindow(hwnd, 0, cyChar * cLines, (PWRECT)NULL, (PWRECT)NULL, (HRGN)NULL,%@NL@%
      (PWRECT)NULL, SW_INVALIDATERGN);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* "StringWindow" window class%@NL@%
%@AB@%*%@NL@%
%@AB@%* Windows of the "StringWindow" window class are simple scrolling text output%@NL@%
%@AB@%* windows that are refreshed properly as windows are rearranged.  A text buffer%@NL@%
%@AB@%* is maintained to store the characters as they are drawn.%@NL@%
%@AB@%*%@NL@%
%@AB@%* When creating a StringWindow window, lpCreateParams is actually a ULONG%@NL@%
%@AB@%* containing the dimensions of the text buffer to be created, if 0L, then%@NL@%
%@AB@%* a 80 by 25 buffer is created.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*  19-Jan-87 by neilk  Created%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
MRESULT FAR PASCAL StrWndProc(hwnd, msg, mp1, mp2)%@NL@%
register HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    register STRWND *psw;%@NL@%
    HPS hps;%@NL@%
    RECTL rclPaint;%@NL@%
%@NL@%
    switch (msg) {%@NL@%
    case WM_CREATE:%@NL@%
        if (mp1     == 0L) {%@NL@%
            mp1     = MAKEULONG(80, 50);%@NL@%
        }%@NL@%
        if (!StrWndCreate(hwnd, SHORT1FROMMP(mp1), SHORT2FROMMP(mp1)))%@NL@%
            return(TRUE);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_DESTROY:%@NL@%
        if ((psw = (STRWND *)WinQueryWindowUShort(hwnd, 0)) != NULL) {%@NL@%
            WinFreeMem(hhp, (BYTE *)psw->pchBuffer, strlen(psw->pchBuffer));%@NL@%
            WinFreeMem(hhp, (BYTE *)psw, sizeof(STRWND));%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        hps = WinBeginPaint(hwnd, (HPS)NULL, &rclPaint);%@NL@%
        PaintStrWnd(hwnd, hps, &rclPaint);%@NL@%
        WinEndPaint(hps);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CALCVALIDRECTS:%@NL@%
%@AI@%#ifdef %@AE@%LATER %@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * We want to bottom right justify the bits.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        (mp2)->yTop = (mp2)->yBottom -%@NL@%
                (mp1)->yBottom;%@NL@%
%@AI@%#endif %@AE@%%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return(WinDefWindowProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
    }%@NL@%
    return(0L);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
BOOL StrWndCreate(hwnd, cchLine, cLine)%@NL@%
HWND hwnd;%@NL@%
int cchLine, cLine;%@NL@%
{%@NL@%
    register char *pch;%@NL@%
    char *pchEnd;%@NL@%
    STRWND *psw;%@NL@%
%@NL@%
    if ((psw = (STRWND *)WinAllocMem(hhp, sizeof(STRWND))) == NULL)%@NL@%
        return(FALSE);%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Allocate buffer for strings%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((pch = (char *)WinAllocMem(hhp, cchLine * cLine)) == NULL) {%@NL@%
        WinFreeMem(hhp, (BYTE *)psw, sizeof(STRWND));%@NL@%
        return(FALSE);%@NL@%
    }%@NL@%
%@NL@%
    psw->cchLine       = cchLine;%@NL@%
    psw->cLine         = cLine;%@NL@%
    psw->pchBuffer     = pch;%@NL@%
    psw->pchBufferMax  = pch + cchLine * cLine;%@NL@%
    psw->pchBottomLine = pch;%@NL@%
    psw->pchOutput     = pch;%@NL@%
    WinSetWindowUShort(hwnd, 0, (USHORT)psw);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Make all the lines empty%@NL@%
%@AB@%     */%@AE@%%@NL@%
    pchEnd = psw->pchBufferMax;%@NL@%
    while (pch != pchEnd) {%@NL@%
        *pch = '\0';%@NL@%
        pch += cchLine;%@NL@%
    }%@NL@%
    return(TRUE);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
VOID PaintStrWnd(hwnd, hps, prcl)%@NL@%
HWND hwnd;%@NL@%
HPS hps;%@NL@%
PRECTL prcl;%@NL@%
{%@NL@%
    register STRWND *psw;%@NL@%
    register char *pch;%@NL@%
    int x;%@NL@%
    int y;%@NL@%
    WRECT rc;%@NL@%
    RECTL rcl;%@NL@%
%@NL@%
    psw = (STRWND *)WinQueryWindowUShort(hwnd, 0);%@NL@%
%@NL@%
    WinQueryWindowRect(hwnd, (PRECTL)&rc);%@NL@%
%@NL@%
    WinFillRect(hps, (PRECTL)&rc, SYSCLR_WINDOW);%@NL@%
%@NL@%
    x = rc.xLeft;%@NL@%
    y = rc.yBottom;%@NL@%
    pch = psw->pchBottomLine;%@NL@%
%@NL@%
    if (prcl != NULL)%@NL@%
        WinIntersectRect(hab, (PRECTL)&rc, (PRECTL)&rc, prcl);%@NL@%
%@NL@%
    do {%@NL@%
        if (y >= rc.yTop)%@NL@%
            break;%@NL@%
        if (y + cyChar >= rc.yBottom) {%@NL@%
            rcl.xLeft = x;%@NL@%
            rcl.yBottom = y + cyDescent;%@NL@%
            rcl.xRight = 1000;%@NL@%
            rcl.yTop = rcl.yBottom + cyChar;%@NL@%
            WinDrawText(hps, -1, (PSZ)pch, (PRECTL)&rcl, SYSCLR_WINDOWTEXT,%@NL@%
                    SYSCLR_WINDOW, 0);%@NL@%
        }%@NL@%
        y += cyChar;%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Back up to previous line%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (pch == psw->pchBuffer)%@NL@%
            pch = psw->pchBufferMax;%@NL@%
        pch -= psw->cchLine;%@NL@%
    } while (pch != psw->pchBottomLine);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* VOID StartTime()%@NL@%
%@AB@%* VOID StopTime(hwndStrWnd, szMsg)%@NL@%
%@AB@%*%@NL@%
%@AB@%* These functions are used to time sections of code.  StartTime() begins the%@NL@%
%@AB@%* timing, and StopTime() stops it, printing out the elapsed time since%@NL@%
%@AB@%* StartTime() was called in the "StringWindow" class window hwndStrWnd, using%@NL@%
%@AB@%* the sprintf() formatting string szMsg.  The elapsed time in milliseconds is%@NL@%
%@AB@%* replaced for a "%d" in szMsg.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:%@NL@%
%@AB@%*  19-Jan-87 by neilk  Created%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID StartTime()%@NL@%
{%@NL@%
    ticks = (USHORT)WinGetCurrentTime(hab);%@NL@%
}%@NL@%
%@NL@%
VOID StopTime(hwndStrWnd, szFmt)%@NL@%
HWND hwndStrWnd;%@NL@%
char *szFmt;%@NL@%
{%@NL@%
    USHORT dt;%@NL@%
    char rgch[80];%@NL@%
%@NL@%
    dt = (USHORT)(WinGetCurrentTime(hab) - ticks);%@NL@%
    sprintf((char *)rgch, szFmt, dt);%@NL@%
    DrawString(hwndStrWnd, rgch);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%THREADS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\COMTALK\THREADS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    threads.c -- Supplementary threads module%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%        INCL_DOSSEMAPHORES %@NL@%
%@AI@%#define %@AE@%               INCL_DOSMEMMGR %@NL@%
%@AI@%#define %@AE@%               INCL_DOSPROCESS %@NL@%
%@AI@%#define %@AE@%               INCL_WINMESSAGEMGR %@NL@%
%@AI@%#define %@AE@%               INCL_WINTRACKRECT %@NL@%
%@AI@%#include %@AE@%       <os2.h> %@NL@%
%@AI@%#include %@AE@%       "global.h" %@NL@%
%@AI@%#include %@AE@%       "avio.h" %@NL@%
%@AI@%#include %@AE@%       "circleq.h" %@NL@%
%@AI@%#include %@AE@%       "comport.h" %@NL@%
%@AI@%#include %@AE@%       "threads.h" %@NL@%
%@AI@%#include %@AE@%       "malloc.h" %@NL@%
%@NL@%
int                rc;%@NL@%
HWND                hWndMaster;%@NL@%
BOOL                fNoUpdate = TRUE;%@NL@%
BOOL                fWrap;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Declare pointers to stacks%@NL@%
%@AB@%*/%@AE@%%@NL@%
PINT                pStackWPT,%@NL@%
                pStackRPT,%@NL@%
                pStackWST;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ...Selectors%@NL@%
%@AB@%*/%@AE@%%@NL@%
SEL                selStackWPT,%@NL@%
                selStackRPT,%@NL@%
                selStackWST;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ...Thread ID numbers%@NL@%
%@AB@%*/%@AE@%%@NL@%
TID                tidWPT,%@NL@%
                tidRPT,%@NL@%
                tidWST;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ...Control booleans, semaphores%@NL@%
%@AB@%*/%@AE@%%@NL@%
BOOL                fBreak,                        %@AB@%/* Break active */%@AE@%%@NL@%
                fAlive;                        %@AB@%/* Should the threads be killed? */%@AE@%%@NL@%
LONG                lSemLock,                %@AB@%/* TypeAhead buffer locks... */%@AE@%%@NL@%
                lSemEmpty,%@NL@%
                lSemFull,%@NL@%
                lSemOverflow;                %@AB@%/* Buffer overflow semaphore */%@AE@%%@NL@%
CHAR                TypeAhead[BUFSIZE];        %@AB@%/* TypeAhead buffer and controls */%@AE@%%@NL@%
int                nBufLoc, nChars;%@NL@%
LineInfo        aliReadAhead[RASIZE];%@NL@%
int                cliReadAhead;%@NL@%
LONG                lSemRALock;%@NL@%
LONG                lSemRAFull;%@NL@%
LONG                lSemRAEmpty;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Messages....%@NL@%
%@AB@%*/%@AE@%%@NL@%
char aszMessage[MBE_NUMMSGS][MAXLINELEN] = {%@NL@%
    "Error opening port",%@NL@%
    "Error writing port",%@NL@%
    "Error reading port",%@NL@%
    "Circular buffer overflowing"%@NL@%
};%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Macros%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%       NOUPDATE                (MRESULT) FALSE %@NL@%
%@AI@%#define %@AE@%       UPDATE                        (MRESULT) TRUE %@NL@%
%@AI@%#define %@AE@%       ThdBufNextLoc(n)        (n = ((n + 1) % BUFSIZE)) %@NL@%
%@AI@%#define %@AE@%       ThdBufLastLoc(n)        (n = (n > 0) ? (n - 1) : (BUFSIZE - 1)) %@NL@%
%@AI@%#define %@AE@%       ThdNextRALoc(n)                (n = ((n + 1) % RASIZE)) %@NL@%
%@AI@%#define %@AE@%MessageBox(s, v)        WinPostMsg(hWndMaster, WM_MSGBOX, s, v) %@NL@%
%@AB@%/*%@NL@%
%@AB@%    Local routines%@NL@%
%@AB@%*/%@AE@%%@NL@%
void far WritePortThread(void);%@NL@%
void far ReadPortThread(void);%@NL@%
void far WriteScreenThread(void);%@NL@%
void Process(Line, Line, int far *);%@NL@%
%@NL@%
int ThdCreate(PFNTHREAD Routine, PBYTE *pStack, SEL *selStack, TID *tidThread) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Initialize the thread%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (rc = DosAllocSeg(sizeof(int) * STACKSIZE, selStack, 0)) return rc;%@NL@%
    *pStack = (PBYTE) MAKEP(*selStack, 0) + STACKSIZE;%@NL@%
    return (rc = DosCreateThread(Routine, tidThread, *pStack));%@NL@%
}%@NL@%
%@NL@%
void ThdInitialize(HWND hWnd, COM Term) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Initialize Booleans, Master Window%@NL@%
%@AB@%*/%@AE@%%@NL@%
    fBreak = FALSE;%@NL@%
    fAlive = TRUE;%@NL@%
    hWndMaster = hWnd;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Initialize TypeAhead buffer%@NL@%
%@AB@%*/%@AE@%%@NL@%
    nBufLoc = -1;%@NL@%
    nChars = 0;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Initialize ReadAhead buffer%@NL@%
%@AB@%*/%@AE@%%@NL@%
    cliReadAhead = 0;%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Spawn off the threads%@NL@%
%@AB@%*/%@AE@%%@NL@%
    rc = ThdCreate(WritePortThread,%@NL@%
                   (PBYTE *) &pStackWPT, &selStackWPT, &tidWPT);%@NL@%
    rc = ThdCreate(ReadPortThread,%@NL@%
                   (PBYTE *) &pStackRPT, &selStackRPT, &tidRPT);%@NL@%
    rc = ThdCreate(WriteScreenThread,%@NL@%
                   (PBYTE *) &pStackWST, &selStackWST, &tidWST);%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Open up the COM port and the circular queue%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (rc = ComInit(Term))        { %@AB@%/* Initialize terminal */%@AE@%%@NL@%
        MessageBox(MBE_OPENPORT, NOUPDATE);%@NL@%
    } %@NL@%
    fWrap = Term.fWrap;%@NL@%
}%@NL@%
%@NL@%
void ThdTerminate(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Kill the threads (maybe time delayed) and clean up.%@NL@%
%@AB@%    Yes, I throw away the return codes.%@NL@%
%@AB@%%@NL@%
%@AB@%    Problem:  The ReadPort thread might not die, because it blocks%@NL@%
%@AB@%    waiting for a character to be read.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (fAlive) {%@NL@%
        fAlive = FALSE;                        %@AB@%/* Kill thread loops                */%@AE@%%@NL@%
        if (fBreak) rc = ComUnbreak();        %@AB@%/* Remove break signal                */%@AE@%%@NL@%
        rc = ComClose();                %@AB@%/* Close the port                 */%@AE@%%@NL@%
        DosSemClear(&lSemEmpty);        %@AB@%/* Make WritePort unblock        */%@AE@%%@NL@%
        DosSemClear(&lSemRAFull);        %@AB@%/* Make ReadPort unblock        */%@AE@%%@NL@%
        DosSemClear(&lSemRAEmpty);        %@AB@%/* Make WriteScreen unblock        */%@AE@%%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
void ThdDoBreak(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Try to send break for a second%@NL@%
%@AB@%*/%@AE@%%@NL@%
    ComBreak();%@NL@%
    DosSleep(1000L);%@NL@%
    ComUnbreak();%@NL@%
}%@NL@%
%@NL@%
int ThdPutChar(char ch) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Perhaps we will enter an entire key packet%@NL@%
%@AB@%    But we can't really block, because we gotta respond.%@NL@%
%@AB@%    Solution:  This time, we time out.%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Manipulate the typeahead buffer (circular queue)%@NL@%
%@AB@%*/%@AE@%%@NL@%
    if (nChars >= BUFSIZE) {                %@AB@%/* Block if buffer full */%@AE@%%@NL@%
        DosSemSet(&lSemFull);%@NL@%
        %@AB@%/*%@NL@%
%@AB@%            Timeout possibility; probably want TIMEOUT < 1 second%@NL@%
%@AB@%        */%@AE@%%@NL@%
        if (rc = DosSemWait(&lSemFull, TIMEOUT)) return rc;%@NL@%
    }%@NL@%
    ThdBufNextLoc(nBufLoc);                %@AB@%/* Increments to next location */%@AE@%%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Be really impatient...%@NL@%
%@AB@%        This protects the queue, but we should never read/write%@NL@%
%@AB@%        the same queue location.  Maybe I'll move it out later.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (rc = DosSemRequest(&lSemLock, TIMEOUT)) { %@AB@%/* Another quick timeout */%@AE@%%@NL@%
        ThdBufLastLoc(nBufLoc);%@NL@%
        return rc;%@NL@%
    }%@NL@%
    TypeAhead[nBufLoc] = ch; %@NL@%
    nChars++;%@NL@%
    DosSemClear(&lSemEmpty);%@NL@%
    DosSemClear(&lSemLock);%@NL@%
    return 0;%@NL@%
}%@NL@%
%@NL@%
void far WritePortThread(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    The routine which writes your WM_CHARS to the port,%@NL@%
%@AB@%    one at a time, nice and easy.  We can even wait all%@NL@%
%@AB@%    day (and will, at the rate a user types....)%@NL@%
%@AB@%%@NL@%
%@AB@%    The typeahead buffer is protected with semaphores,%@NL@%
%@AB@%    although a move is probably an atomic operation;%@NL@%
%@AB@%    also, it should be secure to read the element, without%@NL@%
%@AB@%    having to protect the buffer.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    int MyLoc = -1;%@NL@%
    char ch;%@NL@%
%@NL@%
    while (fAlive) {%@NL@%
        if (nChars < 1) {                %@AB@%/* Wait if the queue is empty */%@AE@%%@NL@%
            DosSemSet(&lSemEmpty);%@NL@%
            DosSemWait(&lSemEmpty, MAXTIMEOUT);%@NL@%
        } else if (!(rc = DosSemRequest(&lSemLock, MAXTIMEOUT))) {%@NL@%
            ThdBufNextLoc(MyLoc);%@NL@%
            ch = TypeAhead[MyLoc];        %@AB@%/* writing to the port is slow, and */%@AE@%%@NL@%
            nChars--;                        %@AB@%/* we want to release the semaphore */%@AE@%%@NL@%
            DosSemClear(&lSemFull);%@NL@%
            DosSemClear(&lSemLock);%@NL@%
            if (rc = ComWrite(TypeAhead[MyLoc])) {%@NL@%
                %@AB@%/* Post the message... */%@AE@%%@NL@%
                MessageBox(MBE_WRITEPORT, NOUPDATE);%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
    DosExit(EXIT_THREAD, 0);%@NL@%
}%@NL@%
%@NL@%
void far ReadPortThread(void) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Read from the port, a line at a time%@NL@%
%@AB@%    The semaphores force private queue access%@NL@%
%@AB@%*/%@AE@%%@NL@%
    int iLine = 0;%@NL@%
%@NL@%
    while (fAlive) {%@NL@%
        if (cliReadAhead < RASIZE) {%@NL@%
            if (ComRead(&aliReadAhead[iLine]))%@NL@%
                MessageBox(MBE_COMREAD, (MPARAM) ComError());%@NL@%
            else if (&aliReadAhead[iLine].cch) {%@NL@%
                DosSemRequest(&lSemRALock, MAXTIMEOUT);%@NL@%
                cliReadAhead++;%@NL@%
                DosSemClear(&lSemRALock);%@NL@%
                DosSemClear(&lSemRAEmpty);%@NL@%
                ThdNextRALoc(iLine);%@NL@%
            }%@NL@%
        } else {%@NL@%
            DosSemSet(&lSemRAFull);%@NL@%
            DosSemWait(&lSemRAFull, TIMEOUT);%@NL@%
        }%@NL@%
    }%@NL@%
    DosExit(EXIT_THREAD, 0);%@NL@%
}%@NL@%
%@NL@%
int ThdPutString(char a[], int n) {%@NL@%
    int i, rc = 0;%@NL@%
%@NL@%
    for (i = 0; i < n; i++)%@NL@%
        if (!rc) rc = ThdPutChar(a[i]);%@NL@%
    return rc;%@NL@%
}%@NL@%
%@NL@%
void Process(Line lCmd, Line lOutput, int far *pi) {%@NL@%
%@AB@%/*%@NL@%
%@AB@%    This routine filters characters from the port, before we%@NL@%
%@AB@%    display them to the screen.%@NL@%
%@AB@%%@NL@%
%@AB@%    To make this a full blown terminal emulator application,%@NL@%
%@AB@%    all that's needed is to trap cursor movement sequences%@NL@%
%@AB@%    here, and then to retrieve the appropriate queue line.%@NL@%
%@AB@%*/%@AE@%%@NL@%
    USHORT usTemp;%@NL@%
    int i;%@NL@%
%@NL@%
    while ((lCmd->szText[*pi] != '\n') && ((*pi) < (int) lCmd->cch)) {%@NL@%
        switch (lCmd->szText[*pi]) {%@NL@%
            case '\b':%@NL@%
                if (lOutput->cch > 0) lOutput->cch--;%@NL@%
                break;%@NL@%
            case '\r':%@NL@%
            case '\0':%@NL@%
                break;%@NL@%
            case '\007':        %@AB@%/* Ctrl G */%@AE@%%@NL@%
                WinAlarm(HWND_DESKTOP, WA_NOTE);%@NL@%
                break;%@NL@%
            case '\t':%@NL@%
                if ((usTemp = (((lOutput->cch >> 3) + 1) << 3)) < MAXLINELEN) {%@NL@%
                    for (i = lOutput->cch; i < (SHORT) usTemp; i++)%@NL@%
                        lOutput->szText[i] = ' ';%@NL@%
                    lOutput->cch = usTemp;%@NL@%
                }%@NL@%
                break;%@NL@%
            default:%@NL@%
                if (fWrap) {%@NL@%
                    if (lOutput->cch >= MAXLINELEN) {%@NL@%
                        lOutput->fComplete = TRUE;%@NL@%
                        lOutput->fDrawn = FALSE;%@NL@%
                        return;%@NL@%
                    } else lOutput->szText[lOutput->cch++] = lCmd->szText[*pi];%@NL@%
                } else {%@NL@%
                    if (lOutput->cch < MAXLINELEN) %@AB@%/* Straight nowrap */%@AE@%%@NL@%
                        lOutput->szText[lOutput->cch++] = lCmd->szText[*pi];%@NL@%
                }%@NL@%
                break;%@NL@%
        }%@NL@%
        (*pi)++;%@NL@%
    }%@NL@%
    %@AB@%/*%@NL@%
%@AB@%        Complete line if it doesn't exhaust the command string, and%@NL@%
%@AB@%        ends with a newline (\n).  If so, increment string length, but%@NL@%
%@AB@%        don't write (potentially) out of the array bounds.%@NL@%
%@AB@%    */%@AE@%%@NL@%
    if (lOutput->fComplete =%@NL@%
                (((*pi) < (int) lCmd->cch) && (lCmd->szText[*pi] == '\n')))%@NL@%
        (*pi)++;%@NL@%
%@NL@%
    lOutput->fDrawn = FALSE;%@NL@%
}%@NL@%
%@NL@%
void ThdReset(void) {%@NL@%
    DosSemClear(&lSemOverflow);%@NL@%
}%@NL@%
%@NL@%
void far WriteScreenThread(void) {%@NL@%
    int                iLine = 0;%@NL@%
    LineInfo        liQueueEntry;%@NL@%
    int                iLinePos = 0;%@NL@%
    BOOL        fMore = FALSE;%@NL@%
%@NL@%
    liQueueEntry.cch = 0;%@NL@%
    while (fAlive) {%@NL@%
        if ((cliReadAhead > 0) || fMore) {%@NL@%
            Process(&aliReadAhead[iLine], &liQueueEntry, &iLinePos);%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                Add the entry to the queue if it's:%@NL@%
%@AB@%                    1) A complete line%@NL@%
%@AB@%                    2) There's nothing more to read%@NL@%
%@AB@%            */%@AE@%%@NL@%
            if (liQueueEntry.fComplete || (cliReadAhead <= 1)) {%@NL@%
                while (!QueInsertLine(&liQueueEntry)) {%@NL@%
                    MessageBox(MBE_QUEUEFULL, UPDATE);%@NL@%
                    DosSemSet(&lSemOverflow);%@NL@%
                    DosSemWait(&lSemOverflow, MAXTIMEOUT);%@NL@%
                }%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                    If complete line is read, reset line pointer%@NL@%
%@AB@%                */%@AE@%%@NL@%
                if (liQueueEntry.fComplete) {%@NL@%
                    liQueueEntry.cch = 0;%@NL@%
                    %@AB@%/*%@NL@%
%@AB@%                        If done moving, move cursor to the right place.%@NL@%
%@AB@%                        (the beginning of the next line), so that the%@NL@%
%@AB@%                        user knows when they've hit <Enter>.%@NL@%
%@AB@%                    */%@AE@%%@NL@%
                    if (cliReadAhead <= 1) {%@NL@%
                        liQueueEntry.fComplete = liQueueEntry.fDrawn = FALSE;%@NL@%
                        while (!QueInsertLine(&liQueueEntry)) {%@NL@%
                            MessageBox(MBE_QUEUEFULL, UPDATE);%@NL@%
                            DosSemSet(&lSemOverflow);%@NL@%
                            DosSemWait(&lSemOverflow, MAXTIMEOUT);%@NL@%
                        }%@NL@%
                    }%@NL@%
                }%@NL@%
            }%@NL@%
            %@AB@%/*%@NL@%
%@AB@%                If there's no more to process, bump the read pointer%@NL@%
%@AB@%                and possibly unblock the Read Port thread%@NL@%
%@AB@%            */%@AE@%%@NL@%
            if (!(fMore = (iLinePos < (SHORT)aliReadAhead[iLine].cch))) {%@NL@%
                ThdNextRALoc(iLine);%@NL@%
                iLinePos = 0;%@NL@%
                DosSemRequest(&lSemRALock, MAXTIMEOUT);%@NL@%
                cliReadAhead--;%@NL@%
                DosSemClear(&lSemRALock);%@NL@%
                DosSemClear(&lSemRAFull);%@NL@%
            }%@NL@%
        } else {%@NL@%
            if (fNoUpdate) {%@NL@%
                fNoUpdate = WinPostMsg(hWndMaster, WM_AVIOUPDATE, NULL, NULL);%@NL@%
            }%@NL@%
            DosSemSet(&lSemRAEmpty);%@NL@%
            DosSemWait(&lSemRAEmpty, TIMEOUT);%@NL@%
        }%@NL@%
    }%@NL@%
    DosExit(EXIT_THREAD, 0);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TOOL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\OPENDLG\TOOL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    TOOL.C -- Contains commonly used routines and globals%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%NO_DOS %@NL@%
%@AI@%#define %@AE@%NO_GPI %@NL@%
%@AI@%#include %@AE@%"tool.h" %@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function returns the character following the current one.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
PSZ  FAR PASCAL NextChar (PSZ lpsz)%@NL@%
    { if (*lpsz) return ++lpsz; else return lpsz; }%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function returns the character previous to the current one.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
PSZ  FAR PASCAL PrevChar (PSZ lpszStart, PSZ lpszCurrent)%@NL@%
    { if (lpszCurrent > lpszStart) return --lpszCurrent; else return lpszStart; }%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function transforms a string to upper case.%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
PSZ  FAR PASCAL Upper (PSZ lpsz) {%@NL@%
    PSZ  lpszPtr = lpsz;%@NL@%
%@NL@%
    while (*lpszPtr) {%@NL@%
        if (*lpszPtr >= 'a' && *lpszPtr <= 'z') *lpszPtr &= ~0x20;%@NL@%
        lpszPtr++;%@NL@%
        }%@NL@%
    return lpsz;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TOOL1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\OPENDLG\TOOL1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    TOOL1.C -- More commonly used library routines%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%"tool.h" %@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* Merges sz[idMes1] and szText1 and displays a message box using%@NL@%
%@AB@%* the wStyle. Use caption title provided by szText2.%@NL@%
%@AB@%* Returns the answer from the message box (MBID_OK, MBID_CANCEL).%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
int EXPENTRY AlertBox (hwnd, idMes, lpszText1, lpszText2, idHelp, wStyle)%@NL@%
HWND  hwnd;%@NL@%
int   idMes;%@NL@%
PSZ  lpszText1;%@NL@%
PSZ  lpszText2;%@NL@%
USHORT idHelp;%@NL@%
USHORT wStyle;%@NL@%
    {%@NL@%
    char szMessage [MAXMESSAGELENGTH];%@NL@%
%@NL@%
    MergeStrings((PSZ)vrgsz[idMes], lpszText1, (PSZ)szMessage);%@NL@%
    if (idHelp != NULL)%@NL@%
        wStyle |= MB_HELP;%@NL@%
    return (WinMessageBox (HWND_DESKTOP, hwnd, (PSZ)szMessage, lpszText2,%@NL@%
                           idHelp, wStyle));%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* Scan szSrc for merge spec. If found, insert string szMerge at that point.%@NL@%
%@AB@%* Then append rest of szSrc NOTE! Merge spec guaranteed to be two chars.%@NL@%
%@AB@%* returns TRUE if it does a merge, false otherwise.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
BOOL EXPENTRY MergeStrings(lpszSrc, lpszMerge, lpszDst)%@NL@%
PSZ   lpszSrc;%@NL@%
PSZ   lpszMerge;%@NL@%
PSZ   lpszDst;%@NL@%
    {%@NL@%
    %@AB@%/* Find merge spec if there is one. */%@AE@%%@NL@%
    while (*(unsigned far *)lpszSrc != *(unsigned *)vrgsz[IDS_MERGE1])%@NL@%
        {%@NL@%
        *lpszDst++ = *lpszSrc;%@NL@%
        %@AB@%/* If we reach end of string before merge spec, just return. */%@AE@%%@NL@%
        if (!*lpszSrc++)%@NL@%
            return FALSE;%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/* If merge spec found, insert sz2 there. (check for null merge string */%@AE@%%@NL@%
    if (lpszMerge)%@NL@%
        {%@NL@%
        while (*lpszMerge)%@NL@%
            *lpszDst++ = *lpszMerge++;%@NL@%
        }%@NL@%
%@NL@%
    %@AB@%/* Jump over merge spec */%@AE@%%@NL@%
    lpszSrc++,lpszSrc++;%@NL@%
%@NL@%
    %@AB@%/* Now append rest of Src String */%@AE@%%@NL@%
    while (*lpszDst++ = *lpszSrc++);%@NL@%
    return TRUE;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* This function invokes either an Open or Save dialog box.%@NL@%
%@AB@%*     (lpdlf->rgbAction == DLG_OPENDLG)  -->  invoke Open dlgBox%@NL@%
%@AB@%*     (lpdlf->rgbAction == DLG_SAVEDLG)  -->  invoke Save dlbBox%@NL@%
%@AB@%*%@NL@%
%@AB@%* Unless DLG_NOSAVE is specified, the file is opened and left open.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Return values are:%@NL@%
%@AB@%*     TDF_INVALID - Library error (internal error),%@NL@%
%@AB@%*     TDF_ERRMEM  - Out of memory error%@NL@%
%@AB@%*     TDF_NOOPEN  - User hits cancel%@NL@%
%@AB@%*   specific to DLG_OPEN:%@NL@%
%@AB@%*     TDF_NEWOPEN - Created new file%@NL@%
%@AB@%*     TDF_OLDOPEN - Opened existing file%@NL@%
%@AB@%*   specific to DLG_SAVE:%@NL@%
%@AB@%*     TDF_NEWSAVE - user wants to save to a new file%@NL@%
%@AB@%*     TDF_OLDSAVE - user wants to save over existing file%@NL@%
%@AB@%*   specific to DLG_NOSAVE:%@NL@%
%@AB@%*     TDF_NEWSAVE - user wants to save to a new file%@NL@%
%@AB@%*     TDF_OLDSAVE - user wants to save over existing file%@NL@%
%@AB@%\****************************************************************************/%@AE@%%@NL@%
%@NL@%
int EXPENTRY DlgFile(hwnd, pdlf)%@NL@%
HWND  hwnd;%@NL@%
PDLF pdlf;%@NL@%
    {%@NL@%
    %@AB@%/* create dialog box */%@AE@%%@NL@%
    if (pdlf->rgbAction & DLG_SAVEDLG)%@NL@%
        return WinDlgBox(HWND_DESKTOP, hwnd, DlgSaveAsWndProc, vhModule,%@NL@%
                         IDD_SAVEAS, (PSZ)pdlf);%@NL@%
    else%@NL@%
        return WinDlgBox(HWND_DESKTOP, hwnd, DlgOpenWndProc, vhModule,%@NL@%
                         IDD_OPEN, (PSZ)pdlf);%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/**************************************************************************\%@NL@%
%@AB@%* This function initializes the DLF structure%@NL@%
%@AB@%\**************************************************************************/%@AE@%%@NL@%
void EXPENTRY SetupDLF(PDLF pdlf, int iAction, PHFILE phFile,%@NL@%
                       PSZ Extension, PSZ AppName, PSZ pszInTitle,%@NL@%
                       PSZ pszInInstructions ) {%@NL@%
    pdlf->pszExt = Extension;%@NL@%
    pdlf->rgbFlags = ATTRDIRLIST;%@NL@%
    pdlf->phFile = phFile;%@NL@%
    pdlf->pszAppName = AppName;%@NL@%
    pdlf->rgbAction = iAction;%@NL@%
    pdlf->pszTitle = pszInTitle;%@NL@%
    pdlf->pszInstructions = pszInInstructions;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TOOLA.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\OPENDLG\TOOLA.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%;/*%@AE@%%@NL@%
%@AB@%; *   File Dialog Library%@AE@%%@NL@%
%@AB@%; *   Created by Microsoft Corporation, 1989%@AE@%%@NL@%
%@AB@%; */%@AE@%%@NL@%
.xlist%@NL@%
include cmacros.inc%@NL@%
.list%@NL@%
%@NL@%
errnz   ?PLM-1          %@AB@%; this module must use Pascal convention%@AE@%%@NL@%
%@NL@%
TRUE   = 1%@NL@%
%@NL@%
externFP        <WinCreateHeap, WinDestroyHeap>%@NL@%
%@NL@%
sBegin DATA%@NL@%
externW vhModule%@NL@%
externD vhheap%@NL@%
globalW __acrtused,0%@NL@%
sEnd    DATA%@NL@%
%@NL@%
sBegin CODE%@NL@%
%@NL@%
assumes cs,CODE%@NL@%
assumes ds,NOTHING%@NL@%
%@NL@%
%@AB@%; The following trick is to avoid any need for a DS where a constant%@AE@%%@NL@%
%@AB@%;   string is needed, any (PSZ)"foo" is replaced by (PSZ)szfoo with%@AE@%%@NL@%
%@AB@%;   szfoo created in the Code Selector. As we can't do that with C,%@AE@%%@NL@%
%@AB@%;   we do it with MASM.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
        PUBLIC        szStarStar%@NL@%
szStarStar  LABEL   BYTE%@NL@%
        DB        '*','.','*',0%@NL@%
        PUBLIC  szDot%@NL@%
szDot   LABEL   BYTE%@NL@%
        DB      '.',0%@NL@%
%@NL@%
%@AB@%;======================================================%@AE@%%@NL@%
%@AB@%; LCopyStruct(pbSrc, pbDst, cb)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc   LCopyStruct, <PUBLIC, NODATA, FAR>, <ds,si,di>%@NL@%
ParmD lpchSrc%@NL@%
ParmD lpchDst%@NL@%
ParmW cb%@NL@%
%@NL@%
cBegin%@NL@%
        mov     cx, cb%@NL@%
        jcxz    lcopydone           %@AB@%; all done if crc   == 0%@AE@%%@NL@%
        lds     si, lpchSrc%@NL@%
        les     di, lpchDst%@NL@%
        cmp     si,di%@NL@%
        jae     lcopyok%@NL@%
        mov     ax,cx%@NL@%
        dec     ax%@NL@%
        add     si,ax%@NL@%
        add     di,ax%@NL@%
        std%@NL@%
        rep     movsb%@NL@%
        cld%@NL@%
        jmp     short lcopydone%@NL@%
lcopyok:%@NL@%
        cld%@NL@%
        rep     movsb%@NL@%
lcopydone:%@NL@%
%@NL@%
cEnd%@NL@%
%@NL@%
%@NL@%
%@AB@%;======================================================%@AE@%%@NL@%
%@AB@%; LFillStruct(pbSrc, pbDst, cb)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc   LFillStruct, <PUBLIC, NODATA, FAR>, <di>%@NL@%
ParmD lpchDst%@NL@%
ParmW cb%@NL@%
ParmB fillByte%@NL@%
%@NL@%
cBegin%@NL@%
        mov     cx, cb%@NL@%
        jcxz    lfilldone           %@AB@%; all done if crc   == 0%@AE@%%@NL@%
        les     di, lpchDst%@NL@%
        cld%@NL@%
        mov     al,fillByte%@NL@%
        rep     stosb%@NL@%
lfilldone:%@NL@%
cEnd%@NL@%
%@AB@%;======================================================%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; lstrlen: Same as strlen except for taking long ptrs%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
cProc   lstrlen,<PUBLIC, NODATA, FAR>%@NL@%
%@AB@%;       parmD   pStr%@AE@%%@NL@%
cBegin  nogen%@NL@%
        mov     bx,sp%@NL@%
        push    di%@NL@%
        les     di,ss:[bx+4]%@NL@%
        cld%@NL@%
        xor     ax,ax                   %@AB@%; get zero in ax%@AE@%%@NL@%
        mov     cx,-1                   %@AB@%; at most 64 k to move%@AE@%%@NL@%
        repnz   scasb                   %@AB@%; look for end%@AE@%%@NL@%
        mov     ax,cx%@NL@%
        neg     ax%@NL@%
        dec     ax%@NL@%
        dec     ax%@NL@%
        pop     di%@NL@%
        ret     4%@NL@%
cEnd    nogen%@NL@%
%@NL@%
%@NL@%
lstrsetup:%@NL@%
        pop     dx%@NL@%
        mov     bx,sp%@NL@%
%@NL@%
        push    ds%@NL@%
        push    si%@NL@%
        push    di%@NL@%
%@NL@%
        lds     si,ss:[bx+4]%@NL@%
        les     di,ss:[bx+8]%@NL@%
        regptr  dssi,ds,si%@NL@%
        regptr  esdi,es,di%@NL@%
        cld%@NL@%
        jmp     dx%@NL@%
%@NL@%
lstrfinish  proc    far%@NL@%
        pop     di%@NL@%
        pop     si%@NL@%
        pop     ds%@NL@%
        ret     8%@NL@%
lstrfinish  endp%@NL@%
%@NL@%
%@NL@%
%@AB@%;======================================================%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;lstrcpy: strcpy with long pointers%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc   lstrcpy,<PUBLIC, NODATA, FAR>%@NL@%
%@AB@%;       parmD   pDst                    ; [bx+8]%@AE@%%@NL@%
%@AB@%;       parmD   pSrc                    ; [bx+4]%@AE@%%@NL@%
%@NL@%
cBegin  nogen%@NL@%
        call    lstrsetup%@NL@%
lcp1:   lodsb%@NL@%
        stosb%@NL@%
        or      al,al%@NL@%
        jnz     lcp1%@NL@%
        mov     ax,di                   %@AB@%; point at last byte copied%@AE@%%@NL@%
        dec     ax%@NL@%
        mov     dx,es                   %@AB@%; and its segment%@AE@%%@NL@%
        jmp     lstrfinish%@NL@%
cEnd    nogen%@NL@%
%@NL@%
%@NL@%
%@AB@%;======================================================%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;lstrcat: Same as strcat except with long ptrs.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc   lstrcat,<PUBLIC, NODATA, FAR>%@NL@%
%@AB@%;   parmD   pDst%@AE@%%@NL@%
%@AB@%;   parmD   pSrc%@AE@%%@NL@%
%@NL@%
cBegin  nogen%@NL@%
        call    lstrsetup%@NL@%
        xor     ax,ax                   %@AB@%; get zero in ax%@AE@%%@NL@%
        mov     cx,-1                   %@AB@%; at most 64 k to look%@AE@%%@NL@%
        repnz   scasb                   %@AB@%; look for end%@AE@%%@NL@%
        dec     di                      %@AB@%; Point at null byte%@AE@%%@NL@%
        jmp     lcp1                    %@AB@%; jump to lstrcpy loop%@AE@%%@NL@%
cEnd    nogen%@NL@%
%@NL@%
        %@AB@%; convert lower case to upper, must preserve es,di,cx%@AE@%%@NL@%
        public  MyUpper%@NL@%
MyUpper:%@NL@%
        cmp     al,'a'%@NL@%
        jb      myu2%@NL@%
        cmp     al,'z'%@NL@%
        jbe     myu1%@NL@%
        ja      myu2%@NL@%
myu1:   sub     al,'a'-'A'%@NL@%
myu2:   ret%@NL@%
%@NL@%
        %@AB@%; convert upper case to lower, must preserve es,di,cx%@AE@%%@NL@%
        public  MyLower%@NL@%
MyLower:%@NL@%
        cmp     al,'A'%@NL@%
        jb      myl2%@NL@%
        cmp     al,'Z'%@NL@%
        jbe     myl1%@NL@%
%@NL@%
        ja      myl2%@NL@%
myl1:   add     al,'a'-'A'%@NL@%
myl2:   ret%@NL@%
%@NL@%
%@AB@%;=========================================%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;lstrcmp:   long ptr lVersion of strcmp%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc   lstrcmp,<PUBLIC, NODATA, FAR>%@NL@%
%@AB@%;       parmD   ps1%@AE@%%@NL@%
%@AB@%;       parmD   ps2%@AE@%%@NL@%
cBegin  nogen%@NL@%
        call    lstrsetup%@NL@%
lcmploop:%@NL@%
        xor     ax,ax                   %@AB@%; AH needs to be zero inside this loop%@AE@%%@NL@%
        cmp     byte ptr [si],al%@NL@%
        je      lsidone                 %@AB@%; si is finished check for di finish%@AE@%%@NL@%
        cmp     es:byte ptr [di],al%@NL@%
        je      ldismall                %@AB@%; di finished before si%@AE@%%@NL@%
        lodsb%@NL@%
        mov     bx,ax%@NL@%
        mov     al,es:[di]%@NL@%
        inc     di%@NL@%
        cmp     ax,bx%@NL@%
        je      lcmploop                %@AB@%; still equal%@AE@%%@NL@%
        mov     al,0                    %@AB@%; preverve flags%@AE@%%@NL@%
        jb      lsismall                %@AB@%; si is less than di%@AE@%%@NL@%
ldismall:%@NL@%
        inc     ax%@NL@%
        jmp     lstrfinish%@NL@%
lsidone:%@NL@%
        cmp     byte ptr es:[di],0%@NL@%
        je      lstrfinish%@NL@%
lsismall:%@NL@%
        dec     ax%@NL@%
        jmp     lstrfinish%@NL@%
cEnd    nogen%@NL@%
sEnd CODE%@NL@%
%@NL@%
%@NL@%
createSeg _INIT,INIT,byte,public,CODE%@NL@%
%@NL@%
sBegin  INIT%@NL@%
externNP    <InitLibrary>%@NL@%
assumes CS,INIT%@NL@%
assumes DS,DATA%@NL@%
%@NL@%
%@AB@%;======================================================%@AE@%%@NL@%
%@AB@%; BOOL FAR PASCAL LibInit ()%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Initializes the library%@AE@%%@NL@%
%@AB@%; int dataSelector       /* DS = automatic data selector */%@AE@%%@NL@%
%@AB@%; int wHeapSize;         /* SI = heap size */%@AE@%%@NL@%
%@AB@%; int hmod;           /* DI = module handle */%@AE@%%@NL@%
%@AB@%;     {%@AE@%%@NL@%
%@AB@%;     vhModule = hmod;%@AE@%%@NL@%
%@AB@%;     if (!(vhheap = WinCreateHeap(dataSelector, wHeapsize, 0, 0, 0, 0)))%@AE@%%@NL@%
%@AB@%;         return FALSE;;%@AE@%%@NL@%
%@AB@%;     return (InitLibrary());%@AE@%%@NL@%
%@AB@%;     }%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; DS already usSet%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
cProc   LibInit,<FAR, PUBLIC>%@NL@%
cBegin  nogen%@NL@%
        mov     [vhModule],di           %@AB@%; Remember module handle%@AE@%%@NL@%
%@NL@%
        sub     ax,ax%@NL@%
        cCall   WinCreateHeap,<ds, si, ax, ax, ax, ax>%@NL@%
        mov     bx, ax%@NL@%
        or      ax, dx%@NL@%
        jz      loaddone                %@AB@%; Heap wasn't created%@AE@%%@NL@%
        mov     word ptr vhheap, bx%@NL@%
        mov     word ptr vhheap + 2, dx%@NL@%
%@NL@%
        cCall   InitLibrary                %@AB@%; continue initialization%@AE@%%@NL@%
        or      ax,ax%@NL@%
        jnz     loaddone                %@AB@%; OK, init done%@AE@%%@NL@%
        cCall   WinDestroyHeap,<vhheap> %@AB@%; Non OK, destroy the heap%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Return non-zero to indicate successful initialization%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
loaddone:%@NL@%
        ret%@NL@%
cEnd%@NL@%
%@NL@%
sEnd    INIT%@NL@%
        END LibInit%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%UTIL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\DDEML\MSNGR\UTIL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/****************************** Module Header ******************************\%@NL@%
%@AB@%* Module Name:  util.c%@NL@%
%@AB@%*%@NL@%
%@AB@%* Utility functions used by msngr app.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created:  1/1/89  sanfords%@NL@%
%@AB@%*%@NL@%
%@AB@%* Copyright (c) 1988, 1989  Microsoft Corporation%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@AI@%#include %@AE@%"msngr.h" %@NL@%
%@NL@%
extern NPUSERLIST gnpUL;%@NL@%
extern HAB hab;%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* Concatonates psz1 and psz2 into pszDest.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  1/1/89  created sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void lstrcat(pszDest, psz1, psz2)%@NL@%
PSZ pszDest, psz1, psz2;%@NL@%
{%@NL@%
    while (*psz1 != '\0') {%@NL@%
        *pszDest++ = *psz1++;%@NL@%
    }%@NL@%
    while (*psz2 != '\0') {%@NL@%
        *pszDest++ = *psz2++;%@NL@%
    }%@NL@%
    *pszDest = '\0';%@NL@%
}%@NL@%
%@NL@%
%@NL@%
void lstrcpy(pszDst, pszSrc)%@NL@%
PSZ pszDst, pszSrc;%@NL@%
{%@NL@%
    lstrcat(pszDst, pszSrc, "");%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Public  Function ****************************\%@NL@%
%@AB@%* Concatonates psz1 and psz2 into pszDest but leaves a '\0' in between.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  1/1/89  created sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void lstrpak(pszDest, psz1, psz2)%@NL@%
PSZ pszDest, psz1, psz2;%@NL@%
{%@NL@%
    while (*psz1 != '\0') {%@NL@%
        *pszDest++ = *psz1++;%@NL@%
    }%@NL@%
    *pszDest++ = '\0';%@NL@%
    while (*psz2 != '\0') {%@NL@%
        *pszDest++ = *psz2++;%@NL@%
    }%@NL@%
    *pszDest = '\0';%@NL@%
}%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%*%@NL@%
%@AB@%* returns string length not counting null terminator.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:  1/1/89  created     sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
int lstrlen(psz)%@NL@%
PSZ psz;%@NL@%
{%@NL@%
    int c = 0;%@NL@%
%@NL@%
    while (*psz != 0) {%@NL@%
        psz++;%@NL@%
        c++;%@NL@%
    }%@NL@%
    return(c);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   These functions handle hConv-hsz relationship control.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      8/23/89 Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void DestroyUser(npUL)%@NL@%
NPUSERLIST npUL;%@NL@%
{%@NL@%
    PNPUSERLIST ppList;%@NL@%
    %@NL@%
    ppList = &gnpUL;%@NL@%
    while (*ppList && *ppList != npUL) {%@NL@%
        ppList = &((*ppList)->next);%@NL@%
    }%@NL@%
    if (!ppList) {%@NL@%
        return;%@NL@%
    }%@NL@%
    DdeFreeHsz((*ppList)->hsz);%@NL@%
    if (WinIsWindow(hab, (*ppList)->hwndLink))%@NL@%
        WinDestroyWindow((*ppList)->hwndLink);%@NL@%
    if ((*ppList)->hConvMsg) {%@NL@%
        DdeDisconnect((*ppList)->hConvMsg);%@NL@%
    }%@NL@%
    freeUserList(ppList);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************** Private Function ****************************\%@NL@%
%@AB@%* DESCRIPTION:%@NL@%
%@AB@%*   These functions handle hConv-hsz relationship control.%@NL@%
%@AB@%*%@NL@%
%@AB@%* History:      1/13/89 Created         sanfords%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
VOID AddUser(%@NL@%
HCONV hConvMsg,%@NL@%
HSZ hsz,%@NL@%
HAPP hApp)%@NL@%
{%@NL@%
    NPUSERLIST pList;%@NL@%
    UCHAR sz[MAX_NAMESTR + 1];%@NL@%
    SHORT lit;%@NL@%
    extern HWND hwndLB;%@NL@%
%@NL@%
    if ((pList = (NPUSERLIST)WinAllocMem(hheap, sizeof(USERLIST))) == 0)%@NL@%
        return;%@NL@%
    pList->hConvMsg = hConvMsg;%@NL@%
    pList->hConvLink = 0;%@NL@%
    pList->hwndLink = NULL;%@NL@%
    pList->hsz = hsz;%@NL@%
    pList->hApp = hApp;%@NL@%
    pList->next = gnpUL;  %@AB@%/* link in front */%@AE@%%@NL@%
    gnpUL = pList;%@NL@%
    DdeGetHszString(hsz, sz, MAX_NAMESTR + 1L);%@NL@%
    lit = (SHORT)WinSendMsg(hwndLB, LM_INSERTITEM,%@NL@%
            MPFROMSHORT(LIT_SORTASCENDING), MPFROMP(sz));%@NL@%
    WinSendMsg(hwndLB, LM_SETITEMHANDLE, (MPARAM)lit, (MPARAM)pList);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
NPUSERLIST FindUser(pList, hsz)%@NL@%
NPUSERLIST pList;%@NL@%
HSZ hsz;%@NL@%
{%@NL@%
    while (pList) {%@NL@%
        if (hsz == pList->hsz)%@NL@%
            return(pList);%@NL@%
        pList = pList->next;%@NL@%
    }%@NL@%
    return(0);%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
void freeUserList(ppList)%@NL@%
PNPUSERLIST ppList;%@NL@%
{%@NL@%
    NPUSERLIST pListT;%@NL@%
%@NL@%
    while (*ppList) {%@NL@%
        pListT = *ppList;%@NL@%
        *ppList = pListT->next;%@NL@%
        WinFreeMem(hheap, (NPBYTE)pListT, sizeof(USERLIST));%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
PVOID FarAllocMem(hheap, cb)%@NL@%
HHEAP hheap;%@NL@%
USHORT cb;%@NL@%
{%@NL@%
    return((PVOID)((PBYTE)WinLockHeap(hheap) + (USHORT)WinAllocMem(hheap, cb)));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
void MyPostError(err)%@NL@%
USHORT err;%@NL@%
{%@NL@%
    switch (err) {%@NL@%
    case DMGERR_SERVER_DIED:%@NL@%
    case DMGERR_NO_CONV_ESTABLISHED:%@NL@%
        break;%@NL@%
    default:%@NL@%
        DdePostError(err);%@NL@%
        break;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%UTILS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\INIEDIT\UTILS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/******************************* Module Header ******************************\%@NL@%
%@AB@%* Module Name: Utils.c%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%* PM OS2.ini Editor%@NL@%
%@AB@%*%@NL@%
%@AB@%* Miscellaneous Utility Functions%@NL@%
%@AB@%*%@NL@%
%@AB@%*%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%LINT_ARGS %@NL@%
%@AI@%#include %@AE@%<stdarg.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WINERRORS %@NL@%
%@AI@%#define %@AE@%INCL_WINMESSAGEMGR %@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"IniEdit.h" %@NL@%
%@NL@%
%@AB@%/******************************** Globals **********************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%/******************************* Externals *********************************/%@AE@%%@NL@%
%@NL@%
extern HAB habIniEdit;%@NL@%
%@NL@%
void ErrMessage( char *szMsg )%@NL@%
{%@NL@%
%@NL@%
    char      szMsgBuf[132];%@NL@%
    ERRORID   ErrorNo;%@NL@%
%@NL@%
    ErrorNo = WinGetLastError( habIniEdit );%@NL@%
%@NL@%
    sprintf( szMsgBuf, "%s; Error: %p", szMsg, ErrorNo );%@NL@%
%@NL@%
    WinMessageBox( HWND_DESKTOP, HWND_DESKTOP, szMsgBuf, "System Print", 0,%@NL@%
         MB_ICONEXCLAMATION );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VECTFONT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VECTFONT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------%@NL@%
%@AB@%   VECTFONT.C -- Vector Font Demo Program%@NL@%
%@AB@%  ----------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "VectFont" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc,%@NL@%
                            CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass,%@NL@%
                                     " - Vector Font Demo", 0L,%@NL@%
                                     (HMODULE) NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1,%@NL@%
                                                       MPARAM mp2)%@NL@%
     {%@NL@%
     static struct {%@NL@%
                   SHORT idCmd ;%@NL@%
                   VOID (*fn) (HPS, LONG, LONG) ;%@NL@%
                   }%@NL@%
                   vectfont [] = {%@NL@%
                                 IDM_NOTHING,     NULL,%@NL@%
                                 IDM_24POINT,     Display_24Point,%@NL@%
                                 IDM_MIRROR,      Display_Mirror,%@NL@%
                                 IDM_STRETCH,     Display_Stretch,%@NL@%
                                 IDM_CHARANGLE,   Display_CharAngle,%@NL@%
                                 IDM_ROTATE,      Display_Rotate,%@NL@%
                                 IDM_CHARSHEAR,   Display_CharShear,%@NL@%
                                 IDM_SHADOW,      Display_Shadow,%@NL@%
                                 IDM_HOLLOW,      Display_Hollow,%@NL@%
                                 IDM_DROPSHADOW,  Display_DropShadow,%@NL@%
                                 IDM_BLOCK,       Display_Block,%@NL@%
                                 IDM_NEON,        Display_Neon,%@NL@%
                                 IDM_FADE,        Display_Fade,%@NL@%
                                 IDM_SPOKES,      Display_Spokes,%@NL@%
                                 IDM_WAVY,        Display_Wavy,%@NL@%
                                 IDM_MODSPOKES,   Display_ModSpokes%@NL@%
                                 } ;%@NL@%
     static HDC    hdc ;%@NL@%
     static HPS    hps ;%@NL@%
     static HWND   hwndMenu ;%@NL@%
     static POINTL ptlClient ;%@NL@%
     static SHORT  sNumRoutines = sizeof vectfont / sizeof vectfont[0],%@NL@%
                   sDisplay = IDM_NOTHING ;%@NL@%
     INT           i ;%@NL@%
     RECTL         rcl ;%@NL@%
     SIZEL         sizl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hdc = WinOpenWindowDC (hwnd) ;%@NL@%
%@NL@%
                                   // Create PS use Twips page units%@NL@%
               sizl.cx = 0 ;%@NL@%
               sizl.cy = 0 ;%@NL@%
               hps = GpiCreatePS (hab, hdc, &sizl,%@NL@%
                                       PU_TWIPS     | GPIF_DEFAULT |%@NL@%
                                       GPIT_MICRO   | GPIA_ASSOC) ;%@NL@%
%@NL@%
                                   // Adjust Page Viewport for points%@NL@%
%@NL@%
               GpiQueryPageViewport (hps, &rcl) ;%@NL@%
               rcl.xRight *= 20 ;%@NL@%
               rcl.yTop   *= 20 ;%@NL@%
               GpiSetPageViewport (hps, &rcl) ;%@NL@%
%@NL@%
               hwndMenu = WinWindowFromID (%@NL@%
                               WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                               FID_MENU) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               ptlClient.x = SHORT1FROMMP (mp2) ;      // client width%@NL@%
               ptlClient.y = SHORT2FROMMP (mp2) ;      // client height%@NL@%
%@NL@%
               GpiConvert (hps, CVTC_DEVICE, CVTC_PAGE, 1L, &ptlClient);%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               for (i = 0 ; i < sNumRoutines ; i++)%@NL@%
                    if (COMMANDMSG(&msg)->cmd == (USHORT) vectfont[i].idCmd)%@NL@%
                         {%@NL@%
                         if ((USHORT) sDisplay == COMMANDMSG(&msg)->cmd)%@NL@%
                              return 0 ;%@NL@%
%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (sDisplay, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_CHECKED, 0)) ;%@NL@%
%@NL@%
                         sDisplay = COMMANDMSG(&msg)->cmd ;%@NL@%
%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (sDisplay, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_CHECKED,%@NL@%
                                                   MIA_CHECKED)) ;%@NL@%
%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
                         }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               WinBeginPaint (hwnd, hps, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
                                   // Display hourglass pointer%@NL@%
%@NL@%
               WinSetPointer (HWND_DESKTOP,%@NL@%
                    WinQuerySysPointer (HWND_DESKTOP,SPTR_WAIT,FALSE));%@NL@%
%@NL@%
               if (!WinQuerySysValue (HWND_DESKTOP, SV_MOUSEPRESENT))%@NL@%
                    WinShowPointer (HWND_DESKTOP, TRUE) ;%@NL@%
%@NL@%
                                   // Execute font routine%@NL@%
%@NL@%
               for (i = 0 ; i < sNumRoutines ; i++)%@NL@%
                    if (sDisplay == vectfont[i].idCmd)%@NL@%
                         {%@NL@%
                         if (vectfont[i].fn != NULL)%@NL@%
                              {%@NL@%
                              GpiSavePS (hps) ;%@NL@%
                              vectfont[i].fn (hps, ptlClient.x,%@NL@%
                                                   ptlClient.y) ;%@NL@%
                              GpiRestorePS (hps, -1L) ;%@NL@%
                              }%@NL@%
                         break ;%@NL@%
                         }%@NL@%
                                        // Display arrow pointer%@NL@%
%@NL@%
               if (!WinQuerySysValue (HWND_DESKTOP, SV_MOUSEPRESENT))%@NL@%
                    WinShowPointer (HWND_DESKTOP, FALSE) ;%@NL@%
%@NL@%
               WinSetPointer (HWND_DESKTOP,%@NL@%
                    WinQuerySysPointer (HWND_DESKTOP,SPTR_ARROW,FALSE));%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               GpiDestroyPS (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF00.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF00.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------%@NL@%
%@AB@%   VF00.C -- Routines for working with vector fonts%@NL@%
%@AB@%  --------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
extern HAB hab ;%@NL@%
%@NL@%
LONG CreateVectorFont (HPS hps, LONG lcid, CHAR *szFacename)%@NL@%
     {%@NL@%
     FATTRS fat ;%@NL@%
%@NL@%
     fat.usRecordLength  = sizeof fat ;%@NL@%
     fat.fsSelection     = 0 ;%@NL@%
     fat.lMatch          = 0 ;%@NL@%
     fat.idRegistry      = 0 ;%@NL@%
     fat.usCodePage      = GpiQueryCp (hps) ;%@NL@%
     fat.lMaxBaselineExt = 0 ;%@NL@%
     fat.lAveCharWidth   = 0 ;%@NL@%
     fat.fsType          = 0 ;%@NL@%
     fat.fsFontUse       = FATTR_FONTUSE_OUTLINE |%@NL@%
                           FATTR_FONTUSE_TRANSFORMABLE ;%@NL@%
%@NL@%
     strcpy (fat.szFacename, szFacename) ;%@NL@%
%@NL@%
     return GpiCreateLogFont (hps, NULL, lcid, &fat) ;%@NL@%
     }%@NL@%
%@NL@%
BOOL ScaleVectorFont (HPS hps, SHORT xPointSize, SHORT yPointSize)%@NL@%
     {%@NL@%
     HDC    hdc ;%@NL@%
     LONG   xDeviceRes, yDeviceRes ;%@NL@%
     POINTL ptlFont ;%@NL@%
     SIZEF  sizfx ;%@NL@%
                         // Get device resolution in pixels per meter%@NL@%
%@NL@%
     hdc = GpiQueryDevice (hps) ;%@NL@%
%@NL@%
     DevQueryCaps (hdc, CAPS_HORIZONTAL_RESOLUTION, 1L, &xDeviceRes) ;%@NL@%
     DevQueryCaps (hdc, CAPS_VERTICAL_RESOLUTION,   1L, &yDeviceRes) ;%@NL@%
%@NL@%
                         // Find desired font size in pixels%@NL@%
%@NL@%
     ptlFont.x = 254L * xPointSize * xDeviceRes / 7200000L ;%@NL@%
     ptlFont.y = 254L * yPointSize * yDeviceRes / 7200000L ;%@NL@%
%@NL@%
                         // Convert to page units%@NL@%
%@NL@%
     GpiConvert (hps, CVTC_DEVICE, CVTC_PAGE, 1L, &ptlFont) ;%@NL@%
%@NL@%
                         // Set the character box%@NL@%
%@NL@%
     sizfx.cx = MAKEFIXED (ptlFont.x, 0) ;%@NL@%
     sizfx.cy = MAKEFIXED (ptlFont.y, 0) ;%@NL@%
%@NL@%
     return GpiSetCharBox (hps, &sizfx) ;%@NL@%
     }%@NL@%
%@NL@%
BOOL ScaleFontToBox (HPS hps, LONG cbText, CHAR *szText, LONG cxBox,%@NL@%
                                                         LONG cyBox)%@NL@%
     {%@NL@%
     POINTL aptl[TXTBOX_COUNT] ;%@NL@%
     SIZEF  sizfx ;%@NL@%
%@NL@%
     GpiQueryCharBox (hps, &sizfx) ;%@NL@%
     GpiQueryTextBox (hps, cbText, szText, TXTBOX_COUNT, aptl) ;%@NL@%
%@NL@%
     sizfx.cx = sizfx.cx /%@NL@%
          (max (aptl[TXTBOX_TOPRIGHT].x, aptl[TXTBOX_BOTTOMRIGHT].x) -%@NL@%
           min (aptl[TXTBOX_TOPLEFT].x,  aptl[TXTBOX_BOTTOMLEFT].x))%@NL@%
          * cxBox ;%@NL@%
%@NL@%
     sizfx.cy = sizfx.cy /%@NL@%
          (max (aptl[TXTBOX_TOPRIGHT].y,    aptl[TXTBOX_TOPLEFT].y) -%@NL@%
           min (aptl[TXTBOX_BOTTOMRIGHT].y, aptl[TXTBOX_BOTTOMLEFT].y))%@NL@%
          * cyBox ;%@NL@%
%@NL@%
     return GpiSetCharBox (hps, &sizfx) ;%@NL@%
     }%@NL@%
%@NL@%
VOID QueryStartPointInTextBox (HPS hps, LONG cbText, CHAR *szText,%@NL@%
                                        POINTL *pptl)%@NL@%
     {%@NL@%
     POINTL aptl[TXTBOX_COUNT] ;%@NL@%
%@NL@%
     GpiQueryTextBox (hps, cbText, szText, TXTBOX_COUNT, aptl) ;%@NL@%
%@NL@%
     pptl->x = max(-aptl[TXTBOX_TOPLEFT].x, -aptl[TXTBOX_BOTTOMLEFT].x);%@NL@%
     pptl->y = max(-aptl[TXTBOX_TOPLEFT].y, -aptl[TXTBOX_BOTTOMLEFT].y);%@NL@%
     }%@NL@%
%@NL@%
VOID ColorClient (HPS hps, LONG cxClient, LONG cyClient, LONG lColor)%@NL@%
     {%@NL@%
     RECTL rcl ;%@NL@%
%@NL@%
     WinSetRect (hab, &rcl, 0, 0, (SHORT) cxClient, (SHORT) cyClient) ;%@NL@%
     WinFillRect (hps, &rcl, lColor) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF01.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF01.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------%@NL@%
%@AB@%   VF01.C -- Display 24-point vector fonts%@NL@%
%@AB@%  -----------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_24Point (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR *szFacename[] = {%@NL@%
                                 "Courier",      "Courier Italic",%@NL@%
                                 "Courier Bold", "Courier Bold Italic",%@NL@%
                                 "Tms Rmn",      "Tms Rmn Italic",%@NL@%
                                 "Tms Rmn Bold", "Tms Rmn Bold Italic",%@NL@%
                                 "Helv",         "Helv Italic",%@NL@%
                                 "Helv Bold",    "Helv Bold Italic"%@NL@%
                                 } ;%@NL@%
     static INT  iNumFonts = sizeof szFacename / sizeof szFacename[0] ;%@NL@%
     FONTMETRICS fm ;%@NL@%
     INT         iFont ;%@NL@%
     POINTL      ptl ;%@NL@%
%@NL@%
     ptl.x = cxClient / 8 ;%@NL@%
     ptl.y = cyClient ;%@NL@%
%@NL@%
     for (iFont = 0 ; iFont < iNumFonts ; iFont++)%@NL@%
          {%@NL@%
                                   // Create font, select it and scale%@NL@%
%@NL@%
          CreateVectorFont (hps, LCID_MYFONT, szFacename[iFont]) ;%@NL@%
          GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
          ScaleVectorFont (hps, 240, 240) ;%@NL@%
%@NL@%
                                   // Get font metrics for scaled font%@NL@%
%@NL@%
          GpiQueryFontMetrics (hps, (LONG) sizeof (FONTMETRICS), &fm) ;%@NL@%
          ptl.y -= fm.lMaxBaselineExt ;%@NL@%
%@NL@%
                                   // Display the font facename%@NL@%
%@NL@%
          GpiCharStringAt (hps, &ptl, (LONG) strlen (szFacename[iFont]),%@NL@%
                           szFacename[iFont]) ;%@NL@%
%@NL@%
          GpiCharString (hps, 10L, " - abcdefg") ;%@NL@%
%@NL@%
          GpiSetCharSet (hps, LCID_DEFAULT) ;     // Clean up%@NL@%
          GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF02.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF02.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------------------%@NL@%
%@AB@%   VF02.C -- Display vector font stretched to client window%@NL@%
%@AB@%  ----------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_Stretch (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = "Hello!" ;%@NL@%
     static LONG cbText = sizeof szText - 1 ;%@NL@%
     POINTL      ptl ;%@NL@%
%@NL@%
                              // Create font, select, and scale%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn Italic") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleFontToBox (hps, cbText, szText, cxClient, cyClient) ;%@NL@%
     QueryStartPointInTextBox (hps, cbText, szText, &ptl) ;%@NL@%
%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Display text%@NL@%
%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;               // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF03.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF03.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------------------------%@NL@%
%@AB@%   VF03.C -- Display four strings in mirror reflections%@NL@%
%@AB@%  ------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_Mirror (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = "Mirror" ;%@NL@%
     static LONG cbText = sizeof szText - 1 ;%@NL@%
     INT         i ;%@NL@%
     POINTL      ptl ;%@NL@%
     SIZEF       sizfx ;%@NL@%
                                   // Create font, select and scale%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn Italic") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleFontToBox (hps, cbText, szText, cxClient / 2, cyClient / 2) ;%@NL@%
%@NL@%
     ptl.x = cxClient / 2 ;        // Center of client window%@NL@%
     ptl.y = cyClient / 2 ;%@NL@%
%@NL@%
     for (i = 0 ; i < 4 ; i++)%@NL@%
          {%@NL@%
          GpiQueryCharBox (hps, &sizfx) ;%@NL@%
%@NL@%
          if (i == 1 || i == 3)%@NL@%
               sizfx.cx *= -1 ;%@NL@%
                                   // Negate char box dimensions%@NL@%
          if (i == 2)%@NL@%
               sizfx.cy *= -1 ;%@NL@%
%@NL@%
          GpiSetCharBox (hps, &sizfx) ;%@NL@%
%@NL@%
          GpiCharStringAt (hps, &ptl, cbText, szText) ;%@NL@%
          }%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;          // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF04.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF04.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------------%@NL@%
%@AB@%   VF04.C -- Display eight character angles%@NL@%
%@AB@%  ------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_CharAngle (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static GRADIENTL agradl[8] = { 100,    0,  100,  100,%@NL@%
                                      0,  100, -100,  100,%@NL@%
                                   -100,    0, -100, -100,%@NL@%
                                      0, -100,  100, -100 } ;%@NL@%
     CHAR             szBuffer[40] ;%@NL@%
     INT              iIndex ;%@NL@%
     POINTL           ptl ;%@NL@%
%@NL@%
                              // Create Helvetica font%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Helv") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleVectorFont (hps, 200, 200) ;%@NL@%
%@NL@%
     ptl.x = cxClient / 2 ;   // Center of client window%@NL@%
     ptl.y = cyClient / 2 ;%@NL@%
%@NL@%
     for (iIndex = 0 ; iIndex < 8 ; iIndex++)%@NL@%
          {%@NL@%
          GpiSetCharAngle (hps, agradl + iIndex) ;     // Char angle%@NL@%
%@NL@%
          GpiCharStringAt (hps, &ptl,%@NL@%
               (LONG) sprintf (szBuffer, " Character Angle (%ld,%ld)",%@NL@%
                               agradl[iIndex].x, agradl[iIndex].y),%@NL@%
               szBuffer) ;%@NL@%
          }%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;               // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF05.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF05.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------%@NL@%
%@AB@%   VF05.C -- Display "Hello, world" in circle%@NL@%
%@AB@%  --------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_Rotate (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = "Hello, world! " ;%@NL@%
     static LONG cbText = sizeof szText - 1L ;%@NL@%
     static LONG alWidthTable[256] ;%@NL@%
     double      ang, angCharWidth, angChar ;%@NL@%
     FONTMETRICS fm ;%@NL@%
     GRADIENTL   gradl ;%@NL@%
     INT         iChar ;%@NL@%
     LONG        lCircum, lRadius, lTotWidth, lCharRadius, cyChar ;%@NL@%
     POINTL      ptl ;%@NL@%
%@NL@%
                         // Create the font and get font metrics%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
%@NL@%
     GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
%@NL@%
                         // Find circle dimensions and scale font%@NL@%
%@NL@%
     lRadius = min (cxClient / 4, cyClient / 4) ;%@NL@%
     lCircum = (LONG) (2 * PI * lRadius) ;%@NL@%
     cyChar  = fm.lMaxBaselineExt * lRadius / fm.lMaxAscender ;%@NL@%
%@NL@%
     ScaleFontToBox (hps, cbText, szText, lCircum, cyChar) ;%@NL@%
%@NL@%
                         // Obtain width table and total width%@NL@%
%@NL@%
     GpiQueryWidthTable (hps, 0L, 256L, alWidthTable) ;%@NL@%
%@NL@%
     for (lTotWidth = 0, iChar = 0 ; iChar < (INT) cbText ; iChar ++)%@NL@%
          lTotWidth += alWidthTable [szText [iChar]] ;%@NL@%
%@NL@%
     ang = PI / 2 ;      // Initial angle for first character%@NL@%
%@NL@%
     for (iChar = 0 ; iChar < (INT) cbText ; iChar++)%@NL@%
          {%@NL@%
                              // Set character angle%@NL@%
%@NL@%
          angCharWidth = 2 * PI * alWidthTable [szText [iChar]] / lTotWidth ;%@NL@%
%@NL@%
          gradl.x = (LONG) (lRadius * cos (ang - angCharWidth / 2 - PI / 2)) ;%@NL@%
          gradl.y = (LONG) (lRadius * sin (ang - angCharWidth / 2 - PI / 2)) ;%@NL@%
%@NL@%
          GpiSetCharAngle (hps, &gradl) ;%@NL@%
%@NL@%
                              // Find position for character and display it%@NL@%
%@NL@%
          angChar = atan2 ((double) alWidthTable [szText [iChar]] / 2,%@NL@%
                           (double) lRadius) ;%@NL@%
%@NL@%
          lCharRadius = (LONG) (lRadius / cos (angChar)) ;%@NL@%
          angChar += ang - angCharWidth / 2 ;%@NL@%
%@NL@%
          ptl.x = (LONG) (cxClient / 2 + lCharRadius * cos (angChar)) ;%@NL@%
          ptl.y = (LONG) (cyClient / 2 + lCharRadius * sin (angChar)) ;%@NL@%
%@NL@%
          GpiCharStringAt (hps, &ptl, 1L, szText + iChar) ;%@NL@%
%@NL@%
          ang -= angCharWidth ;%@NL@%
          }%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;          // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF06.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF06.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------------------%@NL@%
%@AB@%   VF06.C -- Display seven different character shear angles%@NL@%
%@AB@%  ----------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_CharShear (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static POINTL aptlShear[7] = { -100,  41, -100, 100,%@NL@%
                                     -41, 100,    0, 100,%@NL@%
                                      41, 100,  100, 100,%@NL@%
                                     100,  41 } ;%@NL@%
     CHAR          szBuffer[40] ;%@NL@%
     FONTMETRICS   fm ;%@NL@%
     INT           iIndex ;%@NL@%
     POINTL        ptl ;%@NL@%
%@NL@%
                         // Create and scale Helvetica font%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Helv") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleVectorFont (hps, 480, 480) ;%@NL@%
%@NL@%
                         // Get font metrics for scaled font%@NL@%
%@NL@%
     GpiQueryFontMetrics (hps, (LONG) sizeof (FONTMETRICS), &fm) ;%@NL@%
%@NL@%
     ptl.x = cxClient / 8 ;%@NL@%
     ptl.y = cyClient ;%@NL@%
%@NL@%
     for (iIndex = 0 ; iIndex < 7 ; iIndex++)%@NL@%
          {%@NL@%
          GpiSetCharShear (hps, aptlShear + iIndex) ;  // Char shear%@NL@%
%@NL@%
          ptl.y -= fm.lMaxBaselineExt ;%@NL@%
%@NL@%
          GpiCharStringAt (hps, &ptl,%@NL@%
               (LONG) sprintf (szBuffer, "Character Shear (%ld,%ld)",%@NL@%
                         aptlShear[iIndex].x, aptlShear[iIndex].y),%@NL@%
               szBuffer) ;%@NL@%
          }%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;               // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF07.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF07.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------%@NL@%
%@AB@%   VF07.C -- Display characters with sheared shadow%@NL@%
%@AB@%  --------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_Shadow (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = "Shadow" ;%@NL@%
     static LONG cbText = sizeof szText - 1 ;%@NL@%
     POINTL      ptl, ptlShear ;%@NL@%
     SIZEF       sizfx ;%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn Italic") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleFontToBox (hps, cbText, szText, 3 * cxClient / 4, cyClient) ;%@NL@%
     QueryStartPointInTextBox (hps, cbText, szText, &ptl) ;%@NL@%
%@NL@%
     ColorClient (hps, cxClient, cyClient, CLR_BLUE) ;%@NL@%
%@NL@%
     GpiSavePS (hps) ;%@NL@%
%@NL@%
     ptlShear.x = 200 ;                                // Set char shear%@NL@%
     ptlShear.y = 100 ;%@NL@%
     GpiSetCharShear (hps, &ptlShear) ;%@NL@%
%@NL@%
     GpiQueryCharBox (hps, &sizfx) ;%@NL@%
     sizfx.cy += sizfx.cy / 4 ;                        // Set char box%@NL@%
     GpiSetCharBox (hps, &sizfx) ;%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_DARKBLUE) ;%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Display shadow%@NL@%
%@NL@%
     GpiRestorePS (hps, -1L) ;%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_RED) ;%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Display text%@NL@%
%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;               // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF08.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF08.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------%@NL@%
%@AB@%   VF08.C -- Hollow font%@NL@%
%@AB@%  -----------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_Hollow (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = "Hollow" ;%@NL@%
     static LONG cbText = sizeof szText - 1 ;%@NL@%
     POINTL      ptl ;%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn Italic") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleFontToBox (hps, cbText, szText, cxClient, cyClient) ;%@NL@%
     QueryStartPointInTextBox (hps, cbText, szText, &ptl) ;%@NL@%
%@NL@%
     GpiBeginPath (hps, ID_PATH) ;%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Text in path%@NL@%
     GpiEndPath (hps) ;%@NL@%
%@NL@%
     GpiStrokePath (hps, ID_PATH, 0L) ;                // Stroke path%@NL@%
%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;               // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF09.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF09.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------%@NL@%
%@AB@%   VF09.C -- Font with Drop Shadow%@NL@%
%@AB@%  ---------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_DropShadow (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = "Hello!" ;%@NL@%
     static LONG cbText = sizeof szText - 1 ;%@NL@%
     POINTL      ptl ;%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn Italic") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleFontToBox (hps, cbText, szText, cxClient, cyClient) ;%@NL@%
     QueryStartPointInTextBox (hps, cbText, szText, &ptl) ;%@NL@%
%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Shadow%@NL@%
%@NL@%
     ptl.x -= 12 ;       // 1/6 inch%@NL@%
     ptl.y += 12 ;%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_BACKGROUND) ;%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Text string%@NL@%
%@NL@%
     GpiBeginPath (hps, ID_PATH) ;%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Outline%@NL@%
     GpiEndPath (hps) ;%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_NEUTRAL) ;%@NL@%
     GpiStrokePath (hps, ID_PATH, 0L) ;%@NL@%
%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;               // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF10.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF10.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------%@NL@%
%@AB@%   VF10.C -- Solid block font%@NL@%
%@AB@%  ----------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_Block (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = " Block " ;%@NL@%
     static LONG cbText = sizeof szText - 1 ;%@NL@%
     INT         i ;%@NL@%
     POINTL      ptl ;%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn Italic") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleFontToBox (hps, cbText, szText, cxClient, cyClient) ;%@NL@%
     QueryStartPointInTextBox (hps, cbText, szText, &ptl) ;%@NL@%
%@NL@%
     ColorClient (hps, cxClient, cyClient, CLR_WHITE) ;%@NL@%
     GpiSetColor (hps, CLR_DARKGREEN) ;%@NL@%
%@NL@%
     for (i = 0 ; i < 18 ; i++)%@NL@%
          {%@NL@%
          GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Block%@NL@%
%@NL@%
          ptl.x -= 1 ;%@NL@%
          ptl.y -= 1 ;%@NL@%
          }%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_GREEN) ;%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Text string%@NL@%
%@NL@%
     GpiBeginPath (hps, ID_PATH) ;%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Outline%@NL@%
     GpiEndPath (hps) ;%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_DARKGREEN) ;%@NL@%
     GpiStrokePath (hps, ID_PATH, 0L) ;%@NL@%
%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;               // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF11.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF11.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------------------%@NL@%
%@AB@%   VF11.C -- Neon font using geometrically-thick lines%@NL@%
%@AB@%  -----------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_Neon (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = " Neon " ;%@NL@%
     static LONG cbText = sizeof szText - 1 ;%@NL@%
     static LONG lForeColor[] = { CLR_DARKRED, CLR_DARKRED, CLR_RED,%@NL@%
                                  CLR_RED,     CLR_WHITE,   CLR_WHITE };%@NL@%
     static LONG lBackColor[] = { CLR_BLACK,   CLR_DARKRED, CLR_DARKRED,%@NL@%
                                  CLR_RED,     CLR_RED,     CLR_WHITE };%@NL@%
     static LONG lWidth[] = { 34, 28, 22, 16, 10, 4 } ;%@NL@%
%@NL@%
     INT         iIndex ;%@NL@%
     POINTL      ptl ;%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn Italic") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleFontToBox (hps, cbText, szText, cxClient, cyClient) ;%@NL@%
     QueryStartPointInTextBox (hps, cbText, szText, &ptl) ;%@NL@%
%@NL@%
     ColorClient (hps, cxClient, cyClient, CLR_BLACK) ;%@NL@%
%@NL@%
     for (iIndex = 0 ; iIndex < 6 ; iIndex++)%@NL@%
          {%@NL@%
          GpiBeginPath (hps, ID_PATH) ;%@NL@%
          GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Text out%@NL@%
          GpiEndPath (hps) ;%@NL@%
%@NL@%
          GpiSetColor (hps, lForeColor[iIndex]) ;%@NL@%
          GpiSetBackColor (hps, lBackColor[iIndex]) ;%@NL@%
          GpiSetBackMix (hps, BM_OVERPAINT) ;%@NL@%
          GpiSetPattern (hps, PATSYM_HALFTONE) ;%@NL@%
          GpiSetLineWidthGeom (hps, lWidth[iIndex]) ;%@NL@%
%@NL@%
          GpiStrokePath (hps, ID_PATH, 0L) ;           // Stroke path%@NL@%
          }%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;               // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF12.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF12.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------------------------%@NL@%
%@AB@%   VF12.C -- Fading font with various pattern densities%@NL@%
%@AB@%  ------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_Fade (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = "Fade" ;%@NL@%
     static LONG cbText = sizeof szText - 1 ;%@NL@%
     LONG        lPattern ;%@NL@%
     POINTL      ptl ;%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn Italic") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleFontToBox (hps, cbText, szText, cxClient, cyClient) ;%@NL@%
     QueryStartPointInTextBox (hps, cbText, szText, &ptl) ;%@NL@%
%@NL@%
     GpiSetBackMix (hps, BM_OVERPAINT) ;%@NL@%
%@NL@%
     for (lPattern = 8 ; lPattern >= 1 ; lPattern--)%@NL@%
          {%@NL@%
          GpiBeginPath (hps, ID_PATH) ;%@NL@%
          GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Text out%@NL@%
          GpiEndPath (hps) ;%@NL@%
%@NL@%
          GpiSetPattern (hps, lPattern) ;%@NL@%
          GpiFillPath (hps, ID_PATH, FPATH_ALTERNATE) ;     // Fill path%@NL@%
%@NL@%
          ptl.x += 2 ;%@NL@%
          ptl.y -= 2 ;%@NL@%
          }%@NL@%
%@NL@%
     GpiSetPattern (hps, PATSYM_SOLID) ;%@NL@%
     GpiSetBackMix (hps, BM_LEAVEALONE) ;%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;          // Solid%@NL@%
%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;                    // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF13.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF13.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------%@NL@%
%@AB@%   VF13.C -- Clipped Spokes%@NL@%
%@AB@%  --------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_Spokes (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = "WOW" ;%@NL@%
     static LONG cbText = sizeof szText - 1 ;%@NL@%
     static LONG lColors[] = { CLR_BLUE, CLR_GREEN, CLR_CYAN,%@NL@%
                               CLR_RED,  CLR_PINK,  CLR_YELLOW,%@NL@%
                               CLR_WHITE } ;%@NL@%
     double      dMaxRadius ;%@NL@%
     INT         i, iNumColors = sizeof lColors / sizeof lColors[0] ;%@NL@%
     POINTL      ptl ;%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleFontToBox (hps, cbText, szText, cxClient, cyClient) ;%@NL@%
     QueryStartPointInTextBox (hps, cbText, szText, &ptl) ;%@NL@%
%@NL@%
     ColorClient (hps, cxClient, cyClient, CLR_BLACK) ;%@NL@%
%@NL@%
     GpiBeginPath (hps, ID_PATH) ;%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Text string%@NL@%
     GpiEndPath (hps) ;%@NL@%
%@NL@%
     GpiSetClipPath (hps, ID_PATH, SCP_AND | SCP_ALTERNATE) ;%@NL@%
%@NL@%
     dMaxRadius = sqrt (pow (cxClient / 2.0, 2.0) +%@NL@%
                        pow (cyClient / 2.0, 2.0)) ;%@NL@%
                                                       // Draw spokes%@NL@%
     for (i = 0 ; i < 360 ; i++)%@NL@%
          {%@NL@%
          GpiSetColor (hps, lColors[i % iNumColors]) ;%@NL@%
%@NL@%
          ptl.x = cxClient / 2 ;%@NL@%
          ptl.y = cyClient / 2 ;%@NL@%
          GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
          ptl.x += (LONG) (dMaxRadius * cos (i * 6.28 / 360)) ;%@NL@%
          ptl.y += (LONG) (dMaxRadius * sin (i * 6.28 / 360)) ;%@NL@%
          GpiLine (hps, &ptl) ;%@NL@%
          }%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;               // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF14.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF14.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------%@NL@%
%@AB@%   VF14.C -- Clipped wavy spline curves%@NL@%
%@AB@%  --------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_Wavy (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = "Hello!" ;%@NL@%
     static LONG cbText = sizeof szText - 1 ;%@NL@%
     static LONG lColors[] = { CLR_BLUE, CLR_GREEN,  CLR_CYAN, CLR_RED,%@NL@%
                               CLR_PINK, CLR_YELLOW, CLR_WHITE } ;%@NL@%
     INT         i ;%@NL@%
     POINTL      ptl, aptl[8] ;%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn Italic") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleFontToBox (hps, cbText, szText, cxClient, cyClient) ;%@NL@%
     QueryStartPointInTextBox (hps, cbText, szText, &ptl) ;%@NL@%
%@NL@%
     ColorClient (hps, cxClient, cyClient, CLR_BLACK) ;%@NL@%
%@NL@%
     GpiBeginPath (hps, ID_PATH) ;%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Text string%@NL@%
     GpiEndPath (hps) ;%@NL@%
%@NL@%
     GpiSetClipPath (hps, ID_PATH, SCP_AND | SCP_ALTERNATE) ;%@NL@%
%@NL@%
     for (i = 0 ; i < 14 ; i++)%@NL@%
          {%@NL@%
          aptl[0].x = 0 ;%@NL@%
          aptl[0].y = i * cyClient / 14 ;%@NL@%
%@NL@%
          aptl[1].x = cxClient / 3 ;%@NL@%
          aptl[1].y = min (cyClient, 2 * i * cyClient / 14) ;%@NL@%
%@NL@%
          aptl[2].x = 2 * cxClient / 3 ;%@NL@%
          aptl[2].y = max (0L, (2 * i - 14) * cyClient / 14) ;%@NL@%
%@NL@%
          aptl[3].x = cxClient ;%@NL@%
          aptl[3].y = i * cyClient / 14 ;%@NL@%
%@NL@%
          aptl[4].x = cxClient ;%@NL@%
          aptl[4].y = (i + 1) * cyClient / 14 ;%@NL@%
%@NL@%
          aptl[5].x = 2 * cxClient / 3 ;%@NL@%
          aptl[5].y = max (0L, (2 * (i + 1) - 14) * cyClient / 14) ;%@NL@%
%@NL@%
          aptl[6].x = cxClient / 3 ;%@NL@%
          aptl[6].y = min (cyClient, 2 * (i + 1) * cyClient / 14) ;%@NL@%
%@NL@%
          aptl[7].x = 0 ;%@NL@%
          aptl[7].y = (i + 1) * cyClient / 14 ;%@NL@%
%@NL@%
          GpiSetColor (hps, lColors[i % 7]) ;%@NL@%
          GpiBeginArea (hps, BA_BOUNDARY | BA_ALTERNATE) ;%@NL@%
%@NL@%
          GpiMove (hps, aptl) ;                        // Splines%@NL@%
          GpiPolySpline (hps, 3L, aptl + 1) ;%@NL@%
          GpiLine (hps, aptl + 4) ;%@NL@%
          GpiPolySpline (hps, 3L, aptl + 5) ;%@NL@%
          GpiLine (hps, aptl) ;%@NL@%
%@NL@%
          GpiEndArea (hps) ;%@NL@%
          }%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;               // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VF15.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\VECTFONT\VF15.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------%@NL@%
%@AB@%   VF15.C -- Clipped Spokes%@NL@%
%@AB@%  --------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@AI@%#include %@AE@%"vectfont.h" %@NL@%
%@NL@%
VOID Display_ModSpokes (HPS hps, LONG cxClient, LONG cyClient)%@NL@%
     {%@NL@%
     static CHAR szText[] = "WOW" ;%@NL@%
     static LONG cbText = sizeof szText - 1 ;%@NL@%
     static LONG lColors[] = { CLR_BLUE, CLR_GREEN, CLR_CYAN,%@NL@%
                               CLR_RED,  CLR_PINK,  CLR_YELLOW,%@NL@%
                               CLR_WHITE } ;%@NL@%
     double      dMaxRadius ;%@NL@%
     INT         i, iNumColors = sizeof lColors / sizeof lColors[0] ;%@NL@%
     POINTL      ptl ;%@NL@%
%@NL@%
     CreateVectorFont (hps, LCID_MYFONT, "Tms Rmn") ;%@NL@%
     GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
     ScaleFontToBox (hps, cbText, szText, cxClient, cyClient) ;%@NL@%
     QueryStartPointInTextBox (hps, cbText, szText, &ptl) ;%@NL@%
%@NL@%
     ColorClient (hps, cxClient, cyClient, CLR_BLACK) ;%@NL@%
%@NL@%
     GpiBeginPath (hps, ID_PATH) ;%@NL@%
     GpiCharStringAt (hps, &ptl, cbText, szText) ;     // Text string%@NL@%
     GpiEndPath (hps) ;%@NL@%
%@NL@%
     GpiSetLineWidthGeom (hps, 6L) ;                   // 1/12 inch%@NL@%
     GpiModifyPath (hps, ID_PATH, MPATH_STROKE) ;%@NL@%
     GpiSetClipPath (hps, ID_PATH, SCP_AND | SCP_ALTERNATE) ;%@NL@%
%@NL@%
     dMaxRadius = sqrt (pow (cxClient / 2.0, 2.0) +%@NL@%
                        pow (cyClient / 2.0, 2.0)) ;%@NL@%
                                                       // Draw spokes%@NL@%
     for (i = 0 ; i < 360 ; i++)%@NL@%
          {%@NL@%
          GpiSetColor (hps, lColors[i % iNumColors]) ;%@NL@%
%@NL@%
          ptl.x = cxClient / 2 ;%@NL@%
          ptl.y = cyClient / 2 ;%@NL@%
          GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
          ptl.x += (LONG) (dMaxRadius * cos (i * 6.28 / 360)) ;%@NL@%
          ptl.y += (LONG) (dMaxRadius * sin (i * 6.28 / 360)) ;%@NL@%
          GpiLine (hps, &ptl) ;%@NL@%
          }%@NL@%
     GpiSetCharSet (hps, LCID_DEFAULT) ;               // Clean up%@NL@%
     GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WINDOW.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\SPY\WINDOW.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* window.c - Spy Window dialog functions%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%       INCL_WINDIALOGS %@NL@%
       INCL_WINHEAP                        %@AB@%/* needed for spy.h */%@AE@%%@NL@%
%@AI@%#define %@AE@%       INCL_WININPUT %@NL@%
%@AI@%#define %@AE@%       INCL_WINLISTBOXES %@NL@%
%@AI@%#define %@AE@%       INCL_WINMESSAGEMGR %@NL@%
       INCL_WINPOINTERS                %@AB@%/* needed for spy.h */%@AE@%%@NL@%
%@AI@%#define %@AE@%       INCL_WINWINDOWMGR %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"spy.h" %@NL@%
%@AI@%#include %@AE@%"spyhook.h" %@NL@%
%@AI@%#include %@AE@%<time.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@NL@%
%@NL@%
%@AB@%/* Forward Declarations */%@AE@%%@NL@%
void    InitWindowList(HWND, HWND, int);%@NL@%
void    BuildWindowWatchList(void);%@NL@%
void    DisplayWindowInfo(HWND, HWND);%@NL@%
void    SelectWindowFromText(HWND);%@NL@%
SHORT   DumpWindowInfo(HWND, SHORT);%@NL@%
int cdecl    CompareHwnds(const void *, const void *);%@NL@%
MRESULT        EXPENTRY SpyWindowsDlgProc(HWND, USHORT, MPARAM, MPARAM);%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* MRESULT EXPENTRY SpyWindowsDlgProc(hwnd, msg, mp1, mp2)%@NL@%
%@AB@%*%@NL@%
%@AB@%* The Spy Windows Dialog procedure%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
MRESULT EXPENTRY SpyWindowsDlgProc(hwnd, msg, mp1, mp2)%@NL@%
HWND hwnd;%@NL@%
USHORT msg;%@NL@%
MPARAM mp1;%@NL@%
MPARAM mp2;%@NL@%
{%@NL@%
    BOOL        fSelect = TRUE;%@NL@%
    SHORT       cWindows;%@NL@%
    HWND        hwndPoint;%@NL@%
    HWND        hwndItem;   %@AB@%/* from handle of list item */%@AE@%%@NL@%
    USHORT      iItemFocus; %@AB@%/* Index to item that has the focus */%@AE@%%@NL@%
%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_INITDLG:%@NL@%
        %@AB@%/* Initialize the dialog items */%@AE@%%@NL@%
        hwndWindowLB = WinWindowFromID(hwnd, DID_WINDOWLIST);%@NL@%
        InitWindowList(hwnd, HWND_DESKTOP, 0);%@NL@%
        InitWindowList(hwnd, HWND_OBJECT, -10);%@NL@%
        hwndWinDlgDisp = NULL;%@NL@%
        fTrackingListBox = TRUE;%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CHAR:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Handle VK_ENTER and VK_NEWLINE if our Edit control has%@NL@%
%@AB@%         * the focus and it is a keydown%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (!(SHORT1FROMMP(mp1) & KC_KEYUP) &&%@NL@%
                (SHORT1FROMMP(mp1) & KC_VIRTUALKEY) &&%@NL@%
                ( (SHORT2FROMMP(mp2) == VK_ENTER) ||%@NL@%
                  (SHORT2FROMMP(mp2) == VK_NEWLINE) )) {%@NL@%
%@NL@%
%@NL@%
            if (WinQueryFocus(HWND_DESKTOP, FALSE) ==%@NL@%
                    WinWindowFromID(hwnd, DID_WHANDLE)) {%@NL@%
                SelectWindowFromText(hwnd);%@NL@%
                break;%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
        %@AB@%/* Normaly pass to dialog procedure to handle message */%@AE@%%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (SHORT1FROMMP(mp1)) {%@NL@%
        case DID_OK:%@NL@%
            BuildWindowWatchList();%@NL@%
        case DID_CANCEL:%@NL@%
            %@AB@%/* Now dismiss the dialog */%@AE@%%@NL@%
            WinDismissDlg(hwnd, SHORT1FROMMP(mp1));%@NL@%
            break;%@NL@%
        case DID_WUNSELALL:%@NL@%
            fSelect = FALSE;%@NL@%
        case DID_WSELALL:%@NL@%
            cWindows = SHORT1FROMMR( WinSendMsg(hwndWindowLB, LM_QUERYITEMCOUNT,%@NL@%
                0L, 0L));%@NL@%
%@NL@%
            fTrackingListBox = FALSE;%@NL@%
            while (cWindows) {%@NL@%
                %@AB@%/* Loop through all windows, selecting or unselcting all */%@AE@%%@NL@%
                WinSendMsg(hwndWindowLB, LM_SELECTITEM, (MPARAM)--cWindows,%@NL@%
                    (MPARAM)fSelect);%@NL@%
            }%@NL@%
            fTrackingListBox = TRUE;%@NL@%
            break;%@NL@%
%@NL@%
        case DID_WSELMOUSE:%@NL@%
            %@AB@%/* Call function to track mouse, returns window handle */%@AE@%%@NL@%
            hwndPoint = HwndSelWinWithMouse(hwnd, DisplayWindowInfo);%@NL@%
            if (hwndPoint == NULL)%@NL@%
        break;    %@AB@%/* No window to process */%@AE@%%@NL@%
%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Now find the window in the list, Make the item visible%@NL@%
%@AB@%             * and set the item as selected.%@NL@%
%@AB@%             */%@AE@%%@NL@%
            cWindows = SHORT1FROMMR(WinSendMsg(hwndWindowLB, LM_QUERYITEMCOUNT,%@NL@%
                    0L, 0L));%@NL@%
%@NL@%
            while (cWindows) {%@NL@%
                %@AB@%/*%@NL@%
%@AB@%                 * Loop through all windows until we wind the right%@NL@%
%@AB@%                 * one with the correct window handle%@NL@%
%@AB@%                 */%@AE@%%@NL@%
                hwndItem = (HWND)WinSendMsg(hwndWindowLB, LM_QUERYITEMHANDLE,%@NL@%
                        (MPARAM)--cWindows, 0L);%@NL@%
%@NL@%
                if (hwndItem == hwndPoint) {%@NL@%
                    %@AB@%/* found the right item, move it to top */%@AE@%%@NL@%
                    WinSendMsg(hwndWindowLB, LM_SETTOPINDEX, (MPARAM)cWindows, 0L);%@NL@%
                    WinSendMsg(hwndWindowLB, LM_SELECTITEM, (MPARAM)cWindows,%@NL@%
                            (MPARAM)TRUE);%@NL@%
                    break;%@NL@%
                }%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
%@NL@%
    default:%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Default is to see if the listbox has changed its focus%@NL@%
%@AB@%         * item number.  If it has, then we want to display the information%@NL@%
%@AB@%         * about the window that the listbox cursor is over.  There is no%@NL@%
%@AB@%         * legal way to do this, One approach appears to temporary set the%@NL@%
%@AB@%         * listbox to be a single selection listbox, then query its selection%@NL@%
%@AB@%         * and set it back into multiple selection mode.%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (fTrackingListBox && hwndWindowLB != NULL) {%@NL@%
%@NL@%
            WinSetWindowBits(hwndWindowLB, QWL_STYLE, 0L, LS_MULTIPLESEL);%@NL@%
            iItemFocus = SHORT1FROMMR(WinSendMsg(hwndWindowLB, LM_QUERYSELECTION,%@NL@%
                    (MPARAM)LIT_FIRST, 0L));%@NL@%
            WinSetWindowBits(hwndWindowLB, QWL_STYLE, LS_MULTIPLESEL,%@NL@%
                    LS_MULTIPLESEL);%@NL@%
%@NL@%
            if (iItemFocus != iCurItemFocus) {%@NL@%
                iCurItemFocus = iItemFocus;%@NL@%
                if (iItemFocus != (USHORT)-1) {%@NL@%
%@NL@%
                    hwndItem = (HWND)WinSendMsg(hwndWindowLB, LM_QUERYITEMHANDLE,%@NL@%
                            (MPARAM)iItemFocus, 0L);%@NL@%
                    DisplayWindowInfo(hwnd, hwndItem);%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
        return(WinDefDlgProc(hwnd, msg, mp1, mp2));%@NL@%
    }%@NL@%
    return 0L;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* void SelectWindowFromText(hwndDlg)%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Updates the text that is displayed in the message text line%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void SelectWindowFromText(hwndDlg)%@NL@%
HWND    hwndDlg;%@NL@%
{%@NL@%
    char    szTemp[80];%@NL@%
    HWND    hwndSelect;%@NL@%
    SHORT   cItems;%@NL@%
    SHORT   i;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/* First get the edit text from the string */%@AE@%%@NL@%
    WinQueryDlgItemText(hwndDlg, DID_WHANDLE, sizeof(szTemp),%@NL@%
            (PSZ)szTemp);%@NL@%
%@NL@%
    hwndSelect = (HWND)UConvertStringToNum(szTemp);%@NL@%
%@NL@%
    cItems =SHORT1FROMMR(WinSendMsg(hwndWindowLB, LM_QUERYITEMCOUNT,%@NL@%
            0L, 0L));%@NL@%
%@NL@%
    for (i=0; i < cItems; i++) {%@NL@%
        if ((HWND)WinSendMsg(hwndWindowLB, LM_QUERYITEMHANDLE,%@NL@%
                (MPARAM)i, 0L) == hwndSelect)%@NL@%
            break;  %@AB@%/* found it */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    if (i < cItems) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * found the hwnd, bring to top, and select it%@NL@%
%@AB@%         */%@AE@%%@NL@%
        WinSendMsg(hwndWindowLB, LM_SETTOPINDEX,%@NL@%
                MPFROMSHORT(i),  (MPARAM)0L);%@NL@%
%@NL@%
        %@AB@%/* Always set it on */%@AE@%%@NL@%
        WinSendMsg(hwndWindowLB, LM_SELECTITEM,%@NL@%
                MPFROMSHORT(i), MPFROMSHORT(TRUE));%@NL@%
%@NL@%
    } else {%@NL@%
        WinAlarm(HWND_DESKTOP, WA_WARNING);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WHANDLE, (PSZ)"");%@NL@%
    }%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* InitWindowList (hwndDialog, hwnd, level)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Builds the list of windows displayed in the windows dialog%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void InitWindowList(hwndDialog, hwnd, level)%@NL@%
HWND    hwndDialog;%@NL@%
HWND    hwnd;%@NL@%
int     level;%@NL@%
{%@NL@%
    char    szTemp[30];%@NL@%
    char    szId[20];%@NL@%
    HWND    hwndT;%@NL@%
    USHORT  item;%@NL@%
    USHORT  id;%@NL@%
    int     i;%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * We will first add this item to our list of%@NL@%
%@AB@%     * items in the listbox, If the item is in our list of hwnds,%@NL@%
%@AB@%     * set the item selected. To keep from getting into endless loops%@NL@%
%@AB@%     * will not add spywindow client, and descendants.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if (hwnd != hwndSpy) {%@NL@%
        id = (USHORT)WinQueryWindowUShort(hwnd, QWS_ID);%@NL@%
        sprintf(szId, "ID: %x", id);%@NL@%
%@NL@%
        for (i = 0; i < cToName; i++) {%@NL@%
            if (id == rgidtoname[i].id) {%@NL@%
                strcpy (szId, rgidtoname[i].szIdName);%@NL@%
                break;%@NL@%
            }%@NL@%
        }%@NL@%
%@NL@%
        sprintf(szTemp, "%04x(%d) - %s", (USHORT)(ULONG)hwnd, level, szId);%@NL@%
        item = SHORT1FROMMR(WinSendMsg(hwndWindowLB, LM_INSERTITEM,%@NL@%
                (MPARAM)LIT_END, (MPARAM)(PSZ)szTemp));%@NL@%
%@NL@%
        %@AB@%/* Set the item handle to the handle of the window */%@AE@%%@NL@%
        WinSendMsg(hwndWindowLB, LM_SETITEMHANDLE, (MPARAM)item,%@NL@%
                (MPARAM)hwnd);%@NL@%
%@NL@%
        if (SpyFWindowInList(hwnd, TRUE))%@NL@%
            WinSendMsg(hwndWindowLB, LM_SELECTITEM, (MPARAM)item,%@NL@%
                (MPARAM)TRUE);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Then we recurse with all of our children%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((hwndT = WinQueryWindow(hwnd, QW_TOP, FALSE)) != NULL)%@NL@%
            InitWindowList(hwndDialog, hwndT, level+1);%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Then go to our next sibling%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((hwndT = WinQueryWindow(hwnd, QW_NEXT, FALSE)) != NULL)%@NL@%
        InitWindowList(hwndDialog, hwndT, level);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* BuildWindowWatchList()%@NL@%
%@AB@%*%@NL@%
%@AB@%* Updates the list of windows to be watched from the listbox%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void BuildWindowWatchList(void)%@NL@%
{%@NL@%
%@NL@%
    USHORT  itemPrevious;%@NL@%
    USHORT  item;%@NL@%
    HWND    hwnd;%@NL@%
%@NL@%
    SHORT   chwnd;%@NL@%
    HWND    rghwnd[MAXHWNDS];%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Simply loop through asking for the next selected item in the%@NL@%
%@AB@%     * list.  Make sure not to overrun our list.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    itemPrevious = (USHORT)LIT_FIRST;%@NL@%
    chwnd = 0;%@NL@%
%@NL@%
    while ((item = SHORT1FROMMR(WinSendMsg(hwndWindowLB, LM_QUERYSELECTION,%@NL@%
            (MPARAM)itemPrevious, 0L))) != (USHORT)LIT_NONE) {%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Get the items handle, which has the value of the window handle%@NL@%
%@AB@%         */%@AE@%%@NL@%
        hwnd = (HWND)WinSendMsg(hwndWindowLB, LM_QUERYITEMHANDLE,%@NL@%
                (MPARAM)item, 0L);%@NL@%
%@NL@%
        rghwnd[chwnd++] = hwnd;%@NL@%
        if (chwnd >= MAXHWNDS)%@NL@%
            break;  %@AB@%/* Dont overflow array */%@AE@%%@NL@%
        itemPrevious = item;    %@AB@%/* Where to cointinue the search */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    SpySetWindowList (chwnd, rghwnd);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* HWND HwndSelWinWithMouse(HWND hwnd, void (*pfnDisplayInfo)(HWND, HWND))%@NL@%
%@AB@%*%@NL@%
%@AB@%*             This function is used to allow the user to select a window with%@NL@%
%@AB@%*           the mouse.  If fDisplayInfo is TRUE, it will update the%@NL@%
%@AB@%*           information in the dialog box, about the window that the%@NL@%
%@AB@%*           mouse is currently over.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
HWND HwndSelWinWithMouse(hwnd, pfnDisplayInfo)%@NL@%
HWND hwnd;%@NL@%
void (*pfnDisplayInfo)(HWND, HWND);%@NL@%
{%@NL@%
%@NL@%
    QMSG        qmsg;%@NL@%
    HWND        hwndPoint;%@NL@%
    char        szClassName[50];    %@AB@%/* Class name of window */%@AE@%%@NL@%
    CLASSINFO   classinfo;          %@AB@%/* Information about class */%@AE@%%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * First set the capture to the specified window%@NL@%
%@AB@%     */%@AE@%%@NL@%
    WinSetCapture(HWND_DESKTOP, hwnd);%@NL@%
    WinSetPointer (HWND_DESKTOP, hptrSelWin);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Now loop through all of the messages that are sent, until%@NL@%
%@AB@%     * we get our mouse 1 down message.  We will also filter out%@NL@%
%@AB@%     * the WM_MOVE message, else we will dispatch the messages.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    while (WinGetMsg(hab, &qmsg, NULL, 0, 0)) {%@NL@%
        if (qmsg.msg == WM_MOUSEMOVE) {%@NL@%
            if (pfnDisplayInfo != NULL) {%@NL@%
                hwndPoint = WinWindowFromPoint(HWND_DESKTOP,%@NL@%
                    &qmsg.ptl, TRUE, FALSE);%@NL@%
                (*pfnDisplayInfo)(hwnd, hwndPoint);%@NL@%
            }%@NL@%
        }%@NL@%
        else if (qmsg.msg == WM_BUTTON1DOWN)%@NL@%
            break;%@NL@%
        else%@NL@%
            WinDispatchMsg(hab, &qmsg);%@NL@%
    }%@NL@%
%@NL@%
    WinSetPointer (HWND_DESKTOP, hptrArrow);%@NL@%
    WinSetCapture(HWND_DESKTOP, NULL);%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Map the point to the window,  If the CTRL-Key is down,%@NL@%
%@AB@%     * we will go up through the parent chain until we get to%@NL@%
%@AB@%     * a frame window or desktop.  Dont let hwndSpy through!!!%@NL@%
%@AB@%     */%@AE@%%@NL@%
    hwndPoint = WinWindowFromPoint(HWND_DESKTOP,%@NL@%
        &qmsg.ptl, TRUE, FALSE);%@NL@%
    if (WinGetKeyState(HWND_DESKTOP, VK_CTRL) & 0x8000) {%@NL@%
        %@AB@%/* Asked for frame window */%@AE@%%@NL@%
        for (;;) {%@NL@%
            if (hwndPoint == NULL)%@NL@%
                return (NULL);         %@AB@%/* No frames available */%@AE@%%@NL@%
            %@AB@%/* See if frame class */%@AE@%%@NL@%
            WinQueryClassName(hwndPoint, sizeof(szClassName),%@NL@%
                (PSZ)szClassName);%@NL@%
            if (WinQueryClassInfo(hab, (PSZ)szClassName, &classinfo) &&%@NL@%
                    (classinfo.flClassStyle & CS_FRAME))%@NL@%
                break;  %@AB@%/* We have our frame */%@AE@%%@NL@%
%@NL@%
            %@AB@%/* Not frame, go back to parent */%@AE@%%@NL@%
            hwndPoint = WinQueryWindow(hwndPoint, QW_PARENT, FALSE);%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (pfnDisplayInfo != NULL)%@NL@%
        (*pfnDisplayInfo)(hwnd, hwndPoint);%@NL@%
%@NL@%
    if (WinIsChild(hwndPoint, hwndSpy))%@NL@%
        return (NULL);    %@AB@%/* Dont want to get in endless loops */%@AE@%%@NL@%
%@NL@%
    return (hwndPoint);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* DisplayWindowInfo(HWND hwndDialog, HWND hwnd)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Displays the information about the selected window in the dialog%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void DisplayWindowInfo(hwndDlg, hwnd)%@NL@%
HWND            hwndDlg;%@NL@%
HWND            hwnd;%@NL@%
{%@NL@%
    HWND        hwndT;%@NL@%
    HWND        hwndParent;%@NL@%
    char        szTemp[50];%@NL@%
    char        szTemp2[10];%@NL@%
    CLASSINFO   classinfo;%@NL@%
    RECTL       rcl;%@NL@%
    USHORT      id;%@NL@%
    ULONG       ul;%@NL@%
    USHORT      us1;%@NL@%
    USHORT      us2;%@NL@%
    USHORT      us3;%@NL@%
    USHORT      us4;%@NL@%
    PID         pidWindow;%@NL@%
    TID         tidWindow;%@NL@%
%@NL@%
%@NL@%
    if (hwnd != hwndWinDlgDisp)%@NL@%
    {%@NL@%
        hwndWinDlgDisp = hwnd;%@NL@%
%@NL@%
        %@AB@%/* This could be table driven */%@AE@%%@NL@%
        sprintf(szTemp, "0x%04x", (SHORT)(ULONG) hwnd);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WHANDLE, (PSZ)szTemp);%@NL@%
%@NL@%
        WinQueryClassName(hwnd, sizeof(szTemp), (PSZ)szTemp);%@NL@%
        if (!WinQueryClassInfo(hab, (PSZ)szTemp, &classinfo)) {%@NL@%
            classinfo.flClassStyle = -1;    %@AB@%/* Let know error conditon */%@AE@%%@NL@%
            classinfo.cbWindowData = 0;     %@AB@%/* Make sure we dont dump */%@AE@%%@NL@%
        }%@NL@%
%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WCLASS, (PSZ)szTemp);%@NL@%
%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * Warning, we only query the text if the window is not an object%@NL@%
%@AB@%         * window.  If it is an object window, the message queue may not%@NL@%
%@AB@%         * be processing messages, which could hang us%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if (WinIsChild(hwnd, HWND_OBJECT))%@NL@%
            szTemp[0] = '\0';   %@AB@%/* No text available */%@AE@%%@NL@%
        else%@NL@%
            WinQueryWindowText(hwnd, sizeof(szTemp), (PSZ)szTemp);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WTEXT, (PSZ)szTemp);%@NL@%
%@NL@%
        hwndParent = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
        sprintf(szTemp, "0x%04x", (SHORT)(LONG)hwndParent);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WPARENT, (PSZ)szTemp);%@NL@%
%@NL@%
        hwndT = WinQueryWindow(hwnd, QW_TOP, FALSE);%@NL@%
        sprintf(szTemp, "0x%04x", (SHORT)(LONG) hwndT);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WCHILD, (PSZ)szTemp);%@NL@%
%@NL@%
        hwndT = WinQueryWindow(hwnd, QW_OWNER, FALSE);%@NL@%
        sprintf(szTemp, "0x%04x", (SHORT)(LONG) hwndT);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WOWNER, (PSZ)szTemp);%@NL@%
%@NL@%
        WinQueryWindowRect(hwnd, &rcl);%@NL@%
        WinMapWindowPoints(hwnd, hwndParent, (PPOINTL)&rcl, 2);%@NL@%
        sprintf(szTemp, "(%d, %d), (%d, %d)", (SHORT)rcl.xLeft,%@NL@%
            (SHORT)rcl.yBottom, (SHORT)rcl.xRight, (SHORT)rcl.yTop);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WRECT, (PSZ)szTemp);%@NL@%
%@NL@%
        id = (USHORT)WinQueryWindowUShort(hwnd, QWS_ID);%@NL@%
        sprintf(szTemp, "0x%04x", id);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WID, (PSZ)szTemp);%@NL@%
%@NL@%
        ul = (ULONG)WinQueryWindowULong(hwnd, QWL_STYLE);%@NL@%
        sprintf(szTemp, "0x%08lx", ul);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WSTYLE, (PSZ)szTemp);%@NL@%
%@NL@%
        sprintf(szTemp, "0x%08lx", classinfo.flClassStyle);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WCSTYLE, (PSZ)szTemp);%@NL@%
%@NL@%
        ul = (ULONG)WinQueryWindowULong(hwnd, QWP_PFNWP);%@NL@%
        sprintf(szTemp, "%p", ul);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WPFNWP, (PSZ)szTemp);%@NL@%
%@NL@%
        ul = (ULONG)WinQueryWindowULong(hwnd, QWL_HMQ);%@NL@%
        sprintf(szTemp, "0x%04x", (SHORT)ul);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WHMQ, (PSZ)szTemp);%@NL@%
%@NL@%
        WinQueryWindowProcess(hwnd, &pidWindow, &tidWindow);%@NL@%
        sprintf(szTemp, "%d", (SHORT)pidWindow);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WPID, (PSZ)szTemp);%@NL@%
        sprintf(szTemp, "%d", (SHORT)tidWindow);%@NL@%
        WinSetDlgItemText(hwndDlg, DID_WTID, (PSZ)szTemp);%@NL@%
%@NL@%
        %@AB@%/*%@NL@%
%@AB@%         * We have four General purpose lines left, used only for%@NL@%
%@AB@%         * frames now%@NL@%
%@AB@%         */%@AE@%%@NL@%
        if ((classinfo.flClassStyle & CS_FRAME) &&%@NL@%
                    (classinfo.cbWindowData > QWL_HWNDFOCUSSAVE)) {%@NL@%
            ul = (ULONG)WinQueryWindowULong(hwnd, QWL_HWNDFOCUSSAVE);%@NL@%
            sprintf(szTemp, "Frame Focus: %p",ul);%@NL@%
            WinSetDlgItemText(hwndDlg, DID_WOLINE1, (PSZ)szTemp);%@NL@%
%@NL@%
            us1 = (USHORT)WinQueryWindowUShort(hwnd, QWS_FLAGS);%@NL@%
            us2 = (USHORT)WinQueryWindowUShort(hwnd, QWS_RESULT);%@NL@%
            sprintf(szTemp, "Flags: 0x%04x Rslt: 0x%04x", us1, us2);%@NL@%
            WinSetDlgItemText(hwndDlg, DID_WOLINE2, (PSZ)szTemp);%@NL@%
%@NL@%
            us1 = (USHORT)WinQueryWindowUShort(hwnd, QWS_XRESTORE);%@NL@%
            us2 = (USHORT)WinQueryWindowUShort(hwnd, QWS_YRESTORE);%@NL@%
            us3 = (USHORT)WinQueryWindowUShort(hwnd, QWS_CXRESTORE);%@NL@%
            us4 = (USHORT)WinQueryWindowUShort(hwnd, QWS_CYRESTORE);%@NL@%
            sprintf(szTemp, "Restore: (%d, %d, %d, %d)",us1, us2, us3, us4);%@NL@%
            WinSetDlgItemText(hwndDlg, DID_WOLINE3, (PSZ)szTemp);%@NL@%
%@NL@%
            us1 = (USHORT)WinQueryWindowUShort(hwnd, QWS_XMINIMIZE);%@NL@%
            us2 = (USHORT)WinQueryWindowUShort(hwnd, QWS_YMINIMIZE);%@NL@%
            sprintf(szTemp, "Minimize: (%d, %d)",us1, us2);%@NL@%
            WinSetDlgItemText(hwndDlg, DID_WOLINE4, (PSZ)szTemp);%@NL@%
        } else {%@NL@%
            %@AB@%/*%@NL@%
%@AB@%             * Nothing special to output for this window type, so lets%@NL@%
%@AB@%             * dump the window extra words.%@NL@%
%@AB@%             * Note: This code is sh.ty%@NL@%
%@AB@%             */%@AE@%%@NL@%
            us1 = 0;    %@AB@%/* Word offset */%@AE@%%@NL@%
            for (id=DID_WOLINE1; id <= DID_WOLINE4; id++) {%@NL@%
                szTemp[0] = '\0';%@NL@%
                for (us2 = 0; us2 < 4; us2++) {%@NL@%
                    if (us1 >= classinfo.cbWindowData)%@NL@%
                        break;%@NL@%
                    us3 = (USHORT)WinQueryWindowUShort(hwnd, us1);%@NL@%
                    sprintf(szTemp2, "%04x ", us3);%@NL@%
                    strcat(szTemp, szTemp2);%@NL@%
                    us1 += 2;   %@AB@%/* Setup for next word */%@AE@%%@NL@%
                }%@NL@%
%@NL@%
                %@AB@%/* output this line */%@AE@%%@NL@%
                WinSetDlgItemText(hwndDlg, id, (PSZ)szTemp);%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* DumpOneWindowInfo()%@NL@%
%@AB@%*%@NL@%
%@AB@%* Dump the information about one window to the current outputs%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void    DumpOneWindowInfo()%@NL@%
{%@NL@%
    HWND        hwndPoint;%@NL@%
    HWND        hwndT;%@NL@%
    SHORT       wLevel;%@NL@%
%@NL@%
    hwndPoint = HwndSelWinWithMouse(hwndSpy, NULL);%@NL@%
    if (hwndPoint == NULL)%@NL@%
        return;    %@AB@%/* No window selected */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Now see what level the window is at */%@AE@%%@NL@%
    wLevel = 0;%@NL@%
    hwndT = hwndPoint;%@NL@%
    while (hwndT != NULL) {%@NL@%
        wLevel++;%@NL@%
        hwndT = WinQueryWindow(hwndT, QW_PARENT, FALSE);%@NL@%
    };%@NL@%
%@NL@%
%@NL@%
    DumpWindowInfo(hwndPoint, wLevel);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* DumpAllWIndowsInfo (HWND hwnd, WORD wLevel)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Dumps the complet window list out to the current output units.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
SHORT DumpAllWindowsInfo(hwnd, wLevel)%@NL@%
HWND    hwnd;%@NL@%
SHORT   wLevel;%@NL@%
{%@NL@%
    HWND    hwndT;%@NL@%
    SPWD    *pspwdT;%@NL@%
    SHORT   cWindowBytes;%@NL@%
%@NL@%
    pspwdT = pspwd + wDumpCount;%@NL@%
%@NL@%
    cWindowBytes = DumpWindowInfo(hwnd, wLevel);%@NL@%
%@NL@%
    pspwdT->hwnd = hwnd;%@NL@%
    pspwdT->index = wDumpCount;%@NL@%
%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Then we recurse with all of our children%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((hwndT = WinQueryWindow(hwnd, QW_TOP, FALSE)) != NULL)%@NL@%
        cWindowBytes += DumpAllWindowsInfo(hwndT, wLevel+1);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Then go to our next sibling%@NL@%
%@AB@%     */%@AE@%%@NL@%
    if ((hwndT = WinQueryWindow(hwnd, QW_NEXT, FALSE)) != NULL)%@NL@%
        cWindowBytes += DumpAllWindowsInfo(hwndT, wLevel);%@NL@%
%@NL@%
    return (cWindowBytes);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* DumpWindowIndex (void)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Dump a sorted list of Hwnds and index into other list%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
void    DumpWindowIndex(cBytes)%@NL@%
SHORT   cBytes;%@NL@%
{%@NL@%
    SHORT   cch;%@NL@%
    char    szTemp[20];%@NL@%
    char    szOutput[100];%@NL@%
    SPWD    *pspwdT;%@NL@%
    SHORT   i;%@NL@%
%@NL@%
    %@AB@%/* Sort the hwnds first */%@AE@%%@NL@%
    qsort((void *)pspwd, wDumpCount, sizeof(SPWD), CompareHwnds);%@NL@%
    pspwdT = pspwd;%@NL@%
%@NL@%
    strcpy (szOutput, "Index of Window Handles");%@NL@%
    cch = strlen(szOutput);%@NL@%
    for (i=0; i< wDumpCount; i++) {%@NL@%
        if ((i & 3) == 0) {%@NL@%
            %@AB@%/* 4 per row */%@AE@%%@NL@%
            OutputString(szOutput, cch);%@NL@%
            szOutput[0] = '\0';%@NL@%
            cch = 0;%@NL@%
        }%@NL@%
%@NL@%
        cch += sprintf(szTemp, "%3d-%04x ",%@NL@%
                pspwdT->index,    (USHORT)(ULONG) pspwdT->hwnd);%@NL@%
        strcat (szOutput, szTemp);%@NL@%
        pspwdT++;%@NL@%
    }%@NL@%
%@NL@%
    OutputString(szOutput, cch);%@NL@%
%@NL@%
    cch = sprintf(szOutput, "Number of Windows: %d, Approx heap size: %d",%@NL@%
            wDumpCount, cBytes);%@NL@%
    OutputString(szOutput, cch);%@NL@%
%@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/****************************************************************************\%@NL@%
%@AB@%* int  CompareHwnds(SPWD *pspwd1, SPWD *pspwd2)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Compares two window handles%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
int  cdecl CompareHwnds(pspwd1, pspwd2)%@NL@%
const void    *pspwd1;%@NL@%
const void    *pspwd2;%@NL@%
{%@NL@%
    return (((SPWD *)pspwd1)->hwnd < ((SPWD *)pspwd2)->hwnd)? -1 : 1;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* DumpWindowInfo(HWND hwnd, SHORT wLevel)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Displays the information about the selected window in the dialog%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
SHORT DumpWindowInfo(hwnd, wLevel)%@NL@%
HWND        hwnd;%@NL@%
SHORT       wLevel;%@NL@%
{%@NL@%
    HWND    hwndParent;%@NL@%
    HWND    hwndChild;%@NL@%
    HWND    hwndOwner;%@NL@%
%@NL@%
    char    szTemp[100];%@NL@%
    char    szTemp2[20];%@NL@%
    SHORT   cch;%@NL@%
    char    szClass[30];%@NL@%
    RECTL   rcl;%@NL@%
    USHORT  id;%@NL@%
    ULONG   ulStyle;%@NL@%
    ULONG   ulPFNWP;%@NL@%
    ULONG   ulHMQ;%@NL@%
    SHORT   wOffsetClassData;%@NL@%
    SHORT   wWindowWord;%@NL@%
    PID     pidWindow;%@NL@%
    TID     tidWindow;%@NL@%
%@NL@%
    CLASSINFO   classinfo;%@NL@%
%@NL@%
    hwndParent = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
    hwndChild = WinQueryWindow(hwnd, QW_TOP, FALSE);%@NL@%
    hwndOwner = WinQueryWindow(hwnd, QW_OWNER, FALSE);%@NL@%
    id = (USHORT)WinQueryWindowUShort(hwnd, QWS_ID);%@NL@%
    ulHMQ = (ULONG)WinQueryWindowULong(hwnd, QWL_HMQ);%@NL@%
    WinQueryWindowRect(hwnd, &rcl);%@NL@%
    WinMapWindowPoints(hwnd, hwndParent, (PPOINTL)&rcl, 2);%@NL@%
%@NL@%
    cch = sprintf(szTemp,%@NL@%
        "%d-H:%04x(%d) P:%04x C:%04x O:%04x ID:%04x MQ:%04x (%d, %d) (%d, %d)",%@NL@%
        ++wDumpCount, (SHORT)(LONG)hwnd, wLevel, (SHORT)(LONG)hwndParent,%@NL@%
        (SHORT)(LONG)hwndChild, (SHORT)(LONG)hwndOwner, id, (SHORT)ulHMQ,%@NL@%
        (SHORT)rcl.xLeft, (SHORT)rcl.yBottom,%@NL@%
        (SHORT)rcl.xRight, (SHORT)rcl.yTop);%@NL@%
%@NL@%
    OutputString(szTemp, cch);%@NL@%
%@NL@%
    ulStyle = (ULONG)WinQueryWindowULong(hwnd, QWL_STYLE);%@NL@%
    ulPFNWP = (ULONG)WinQueryWindowULong(hwnd, QWP_PFNWP);%@NL@%
    WinQueryClassName(hwnd, sizeof(szClass), (PSZ)szClass);%@NL@%
    if (!WinQueryClassInfo(hab, (PSZ)szClass, &classinfo)) {%@NL@%
        classinfo.flClassStyle = -1;    %@AB@%/* Let know error conditon */%@AE@%%@NL@%
        classinfo.cbWindowData = 0;     %@AB@%/* Make sure we dont dump */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    WinQueryWindowProcess(hwnd, &pidWindow, &tidWindow);%@NL@%
%@NL@%
    cch = sprintf(szTemp,%@NL@%
        "          St:%08lx  PID:%d  TID:%d  Pfn:%p  Cl:%s",%@NL@%
        ulStyle, pidWindow, tidWindow, ulPFNWP, szClass);%@NL@%
    OutputString(szTemp, cch);%@NL@%
%@NL@%
    %@AB@%/*%@NL@%
%@AB@%     * Dump the window extra words out also.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    strcpy (szTemp, "          ");%@NL@%
    id = 8;%@NL@%
    for (wOffsetClassData = 0; wOffsetClassData < (SHORT) classinfo.cbWindowData;%@NL@%
            wOffsetClassData += 2) {%@NL@%
%@NL@%
        wWindowWord = (USHORT)WinQueryWindowUShort(hwnd, wOffsetClassData);%@NL@%
        sprintf(szTemp2, "%04x ", wWindowWord);%@NL@%
        strcat(szTemp, szTemp2);%@NL@%
        if (--id == 0) {%@NL@%
            %@AB@%/* line full is full */%@AE@%%@NL@%
            OutputString(szTemp, strlen(szTemp));%@NL@%
            szTemp[10] = '\0';%@NL@%
            id = 8;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    if (id != 8)%@NL@%
        OutputString(szTemp, strlen(szTemp));%@NL@%
%@NL@%
    %@AB@%/* Return the number of bytes associated with the window */%@AE@%%@NL@%
    return ((SIZEOFWND + classinfo.cbWindowData + 3) & 0xfffc);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* SelOrDeselWithMouse(BOOL fSelect)%@NL@%
%@AB@%*%@NL@%
%@AB@%* Fastway to add/or remove window from watch list%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
void SelOrDeselWithMouse(fSelect)%@NL@%
BOOL    fSelect;%@NL@%
{%@NL@%
    HWND    rghwnd[MAXHWNDS];%@NL@%
    HWND    hwndPoint;%@NL@%
    SHORT    chwnd;%@NL@%
    BOOL    fWinCurInList;%@NL@%
    SHORT    i;%@NL@%
%@NL@%
    %@AB@%/* First get the window of interest */%@AE@%%@NL@%
    hwndPoint = HwndSelWinWithMouse(hwndSpy, NULL);%@NL@%
    if (hwndPoint == NULL)%@NL@%
        return;    %@AB@%/* No window selected */%@AE@%%@NL@%
    fWinCurInList = SpyFWindowInList(hwndPoint, TRUE);%@NL@%
%@NL@%
    if ((fWinCurInList && fSelect)%@NL@%
            || (!fWinCurInList && !fSelect))%@NL@%
        return;        %@AB@%/* Alredy right state */%@AE@%%@NL@%
%@NL@%
    chwnd = SpyGetWindowList(MAXHWNDS, (HWND FAR *)rghwnd);%@NL@%
%@NL@%
    if (fSelect) {%@NL@%
        %@AB@%/* Add window to end of list */%@AE@%%@NL@%
        rghwnd[chwnd++] = hwndPoint;%@NL@%
    } else {%@NL@%
        %@AB@%/* find it in the list, and delete it out */%@AE@%%@NL@%
        for (i=0; rghwnd[i] != hwndPoint; i++)%@NL@%
            ;%@NL@%
%@NL@%
        %@AB@%/* Now copy rest of them down */%@AE@%%@NL@%
        chwnd--;    %@AB@%/* One less item */%@AE@%%@NL@%
        for (;i < chwnd; i++ ) {%@NL@%
            rghwnd[i] = rghwnd[i+1];%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* Now call to update the list */%@AE@%%@NL@%
    SpySetWindowList(chwnd, (HWND FAR *)rghwnd);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WMCHAR.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\WMCHAR\WMCHAR.C%@AE@%%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* wmchar.c -- Displays WM_CHAR messages%@NL@%
%@AB@%*%@NL@%
%@AB@%* Created by Microsoft Corporation, 1989%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPILCIDS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%"wmchar.h" %@NL@%
%@NL@%
%@NL@%
%@AI@%#define %@AE@%max2(a, b)  ((a) > (b) ? (a) : (b)) %@NL@%
%@AI@%#define %@AE@%min2(a, b)  ((a) < (b) ? (a) : (b)) %@NL@%
%@NL@%
%@NL@%
%@AB@%/* display dependent values */%@AE@%%@NL@%
SHORT gcyChar;%@NL@%
SHORT gcxAveChar;%@NL@%
SHORT gcxMaxChar;%@NL@%
SHORT gcxMargin;%@NL@%
%@NL@%
%@AB@%/* program globals */%@AE@%%@NL@%
USHORT gcMessages = 0;      %@AB@%/* also the "number" of the most recent message */%@AE@%%@NL@%
CHAR gszNull[] = "  --";    %@AB@%/* denotes an empty field */%@AE@%%@NL@%
BOOL gfKeyUps = FALSE;%@NL@%
%@NL@%
%@NL@%
%@AB@%/* char messages are stored in a circular buffer */%@AE@%%@NL@%
typedef struct _CHMSG {     %@AB@%/* cm */%@AE@%%@NL@%
    USHORT usKC;%@NL@%
    UCHAR uchRep;%@NL@%
    UCHAR uchScan;%@NL@%
    USHORT ch;%@NL@%
    USHORT usVK;%@NL@%
} CHMSG;%@NL@%
%@NL@%
%@AI@%#define %@AE@%CBUFFERELTS 20 %@NL@%
%@NL@%
CHMSG gacm[CBUFFERELTS];%@NL@%
SHORT gicmStart = 0;%@NL@%
%@NL@%
%@NL@%
%@AB@%/* display field attributes are stored in an array */%@AE@%%@NL@%
typedef struct _MSGFIELD {  %@AB@%/* mf */%@AE@%%@NL@%
    BOOL fDisplay;          %@AB@%/* TRUE if field is currently being displayed */%@AE@%%@NL@%
    SHORT cxWidth;          %@AB@%/* field width, initially chars, then pixels */%@AE@%%@NL@%
    CHAR *szHeading;        %@AB@%/* field heading */%@AE@%%@NL@%
} MSGFIELD;%@NL@%
%@NL@%
%@AI@%#define %@AE@%INUMBER         0 %@NL@%
%@AI@%#define %@AE@%IVIRTUALKEY     1 %@NL@%
%@AI@%#define %@AE@%ICHAR           2 %@NL@%
%@AI@%#define %@AE@%ISCANCODE       3 %@NL@%
%@AI@%#define %@AE@%IREPEAT         4 %@NL@%
%@AI@%#define %@AE@%IFLAGS          5 %@NL@%
%@NL@%
MSGFIELD gamf[CDISPLAYFIELDS] = {%@NL@%
    TRUE,   7, " #",%@NL@%
    TRUE,  15, "VK_ Value",%@NL@%
    TRUE,  14, "Char",%@NL@%
    FALSE, 10, "Scan",%@NL@%
    FALSE, 8,  "Rep",%@NL@%
    TRUE,  0,  "KC_ Flags"      %@AB@%/* variable width, so it's last */%@AE@%%@NL@%
};%@NL@%
%@NL@%
SHORT gcxMargin = 3;%@NL@%
%@NL@%
%@NL@%
%@AB@%/* char flag strings */%@AE@%%@NL@%
CHAR *gachFlags[] = {%@NL@%
    "char",%@NL@%
    "virtualkey",%@NL@%
    "scancode",%@NL@%
    "shift",%@NL@%
    "ctrl",%@NL@%
    "alt",%@NL@%
    "keyup",%@NL@%
    "prevdown",%@NL@%
    "lonekey",%@NL@%
    "deadkey",%@NL@%
    "composite",%@NL@%
    "invalidcomp",%@NL@%
    "toggle",%@NL@%
    "invalidchar",%@NL@%
    "dbcsrsrvd1",%@NL@%
    "dbcsrsrvd2"%@NL@%
};%@NL@%
%@NL@%
%@AB@%/* virtual key strings */%@AE@%%@NL@%
CHAR *gachVK[] = {%@NL@%
    gszNull,%@NL@%
    "button1",%@NL@%
    "button2",%@NL@%
    "button3",%@NL@%
    "break",%@NL@%
    "backspace",%@NL@%
    "tab",%@NL@%
    "backtab",%@NL@%
    "newline",%@NL@%
    "shift",%@NL@%
    "ctrl",%@NL@%
    "alt",%@NL@%
    "altgraf",%@NL@%
    "pause",%@NL@%
    "capslock",%@NL@%
    "esc",%@NL@%
    "space",%@NL@%
    "pageup",%@NL@%
    "pagedown",%@NL@%
    "end",%@NL@%
    "home",%@NL@%
    "left",%@NL@%
    "up",%@NL@%
    "right",%@NL@%
    "down",%@NL@%
    "printscrn",%@NL@%
    "insert",%@NL@%
    "delete",%@NL@%
    "scrllock",%@NL@%
    "numlock",%@NL@%
    "enter",%@NL@%
    "sysrq",%@NL@%
    "f1",%@NL@%
    "f2",%@NL@%
    "f3",%@NL@%
    "f4",%@NL@%
    "f5",%@NL@%
    "f6",%@NL@%
    "f7",%@NL@%
    "f8",%@NL@%
    "f9",%@NL@%
    "f10",%@NL@%
    "f11",%@NL@%
    "f12",%@NL@%
    "f13",%@NL@%
    "f14",%@NL@%
    "f15",%@NL@%
    "f16",%@NL@%
    "f17",%@NL@%
    "f18",%@NL@%
    "f19",%@NL@%
    "f20",%@NL@%
    "f21",%@NL@%
    "f22",%@NL@%
    "f23",%@NL@%
    "f24"%@NL@%
};%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* DrawText%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function displays a text string.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   hps:        presentation space%@NL@%
%@AB@%*   cx, cy:     point to begin drawing%@NL@%
%@AB@%*   sz:         string to draw%@NL@%
%@AB@%*   iColor:     text color%@NL@%
%@AB@%*   fExtent:    whether to calc extent or not%@NL@%
%@AB@%*%@NL@%
%@AB@%* Returns:%@NL@%
%@AB@%*   x position of end of painted string if fExtent == TRUE%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
SHORT DrawText(%@NL@%
    HPS hps,%@NL@%
    SHORT cx,%@NL@%
    SHORT cy,%@NL@%
    CHAR *sz,%@NL@%
    LONG iColor,%@NL@%
    BOOL fExtent)%@NL@%
{%@NL@%
    RECTL rcl;%@NL@%
    SHORT cch;%@NL@%
%@NL@%
    cch = strlen(sz);%@NL@%
%@NL@%
    rcl.xLeft = cx;%@NL@%
    rcl.xRight = cx + cch * gcxMaxChar;     %@AB@%/* hack */%@AE@%%@NL@%
    rcl.yBottom = cy;%@NL@%
    rcl.yTop = cy + gcyChar;%@NL@%
%@NL@%
    WinDrawText(hps, cch, (PCH)sz, (PRECTL)&rcl, iColor, SYSCLR_WINDOW, 0);%@NL@%
%@NL@%
    if (fExtent) {%@NL@%
        WinDrawText(hps, cch, (PCH)sz, (PRECTL)&rcl, iColor,%@NL@%
                    SYSCLR_WINDOW, DT_QUERYEXTENT);%@NL@%
        return (SHORT)rcl.xRight;%@NL@%
    }%@NL@%
%@NL@%
    return 0;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* FormatHexChar%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function formats an unsigned hex number into a string.  It is needed%@NL@%
%@AB@%* to get around shortcomings of sprintf().%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   uch:    number to format%@NL@%
%@AB@%*   sz:     string to get number%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID FormatHexChar(%@NL@%
    USHORT uch,%@NL@%
    CHAR *sz)%@NL@%
{%@NL@%
    sprintf(sz, "0x%2x", uch);%@NL@%
%@NL@%
    %@AB@%/* patch up hex byte display */%@AE@%%@NL@%
    if (strlen(sz) > 4) {%@NL@%
        %@AB@%/* remove sign extension of byte */%@AE@%%@NL@%
        sz[2] = sz[4];%@NL@%
        sz[3] = sz[5];%@NL@%
        sz[4] = 0;%@NL@%
    } else if (sz[2] == ' ') {%@NL@%
        %@AB@%/* fill in blank with 0 */%@AE@%%@NL@%
        sz[2] = '0';%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* DrawMessage%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function draws a single message line.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   hps:        presentation space%@NL@%
%@AB@%*   iMessage:   message number to display%@NL@%
%@AB@%*   pcm:        pointer to message structure%@NL@%
%@AB@%*   cy:         y position of message%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID DrawMessage(%@NL@%
    HPS hps,%@NL@%
    SHORT iMessage,%@NL@%
    CHMSG *pcm,%@NL@%
    SHORT cy)%@NL@%
{%@NL@%
    CHAR sz[16];%@NL@%
    USHORT fsFlags;%@NL@%
    SHORT i;%@NL@%
    SHORT cx;%@NL@%
%@NL@%
    cx = gcxMargin;%@NL@%
%@NL@%
    if (gamf[INUMBER].fDisplay) {%@NL@%
        %@AB@%/* draw message number */%@AE@%%@NL@%
        sprintf(sz, "%u.", iMessage);%@NL@%
        DrawText(hps, cx, cy, sz, SYSCLR_WINDOWTEXT, FALSE);%@NL@%
        cx += gamf[INUMBER].cxWidth;%@NL@%
    }%@NL@%
%@NL@%
    if (gamf[IVIRTUALKEY].fDisplay) {%@NL@%
        %@AB@%/* draw virtual key code */%@AE@%%@NL@%
        DrawText(hps, cx, cy, gachVK[pcm->usVK], SYSCLR_WINDOWTEXT,%@NL@%
                 FALSE);%@NL@%
        cx += gamf[IVIRTUALKEY].cxWidth;%@NL@%
    }%@NL@%
%@NL@%
    if (gamf[ICHAR].fDisplay) {%@NL@%
        %@AB@%/* draw character */%@AE@%%@NL@%
        if ((CHAR)pcm->ch) {%@NL@%
            FormatHexChar(pcm->ch, sz);%@NL@%
            DrawText(hps, cx, cy, sz, SYSCLR_WINDOWTEXT, FALSE);%@NL@%
            sprintf(sz, "'%c'", (CHAR)pcm->ch);%@NL@%
            DrawText(hps, cx + 7 * gcxAveChar, cy, sz, SYSCLR_WINDOWTEXT,%@NL@%
                     FALSE);%@NL@%
        } else {%@NL@%
            DrawText(hps, cx, cy, gszNull, SYSCLR_WINDOWTEXT, FALSE);%@NL@%
        }%@NL@%
        cx += gamf[ICHAR].cxWidth;%@NL@%
    }%@NL@%
%@NL@%
    if (gamf[ISCANCODE].fDisplay) {%@NL@%
        if (pcm->uchScan) {%@NL@%
            FormatHexChar(pcm->uchScan, sz);%@NL@%
            DrawText(hps, cx, cy, sz, SYSCLR_WINDOWTEXT, FALSE);%@NL@%
        } else {%@NL@%
            DrawText(hps, cx, cy, gszNull, SYSCLR_WINDOWTEXT, FALSE);%@NL@%
        }%@NL@%
        cx += gamf[ISCANCODE].cxWidth;%@NL@%
    }%@NL@%
%@NL@%
    if (gamf[IREPEAT].fDisplay) {%@NL@%
        sprintf(sz, "%u", pcm->uchRep);%@NL@%
        DrawText(hps, cx, cy, sz, SYSCLR_WINDOWTEXT, FALSE);%@NL@%
        cx += gamf[IREPEAT].cxWidth;%@NL@%
    }%@NL@%
%@NL@%
    if (gamf[IFLAGS].fDisplay) {%@NL@%
        %@AB@%/* draw KC_ flags */%@AE@%%@NL@%
        fsFlags = pcm->usKC;%@NL@%
        for (i = 0; i < 16; i++) {%@NL@%
            if (fsFlags & 1) {%@NL@%
                switch (i) {%@NL@%
                case 0:%@NL@%
                    if (gamf[ICHAR].fDisplay)%@NL@%
                        goto DF_PRINTIT;%@NL@%
                    break;%@NL@%
                case 1:%@NL@%
                    if (gamf[IVIRTUALKEY].fDisplay)%@NL@%
                        goto DF_PRINTIT;%@NL@%
                    break;%@NL@%
                case 2:%@NL@%
                    if (gamf[ISCANCODE].fDisplay)%@NL@%
                        goto DF_PRINTIT;%@NL@%
                    break;%@NL@%
                default:%@NL@%
DF_PRINTIT:%@NL@%
                    cx = DrawText(hps, cx, cy, gachFlags[i], SYSCLR_WINDOWTEXT, TRUE);%@NL@%
                    cx += gcxAveChar;%@NL@%
                }%@NL@%
            }%@NL@%
            fsFlags >>= 1;%@NL@%
        }%@NL@%
        cx += gamf[IFLAGS].cxWidth;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* PaintClient%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function paints a client window.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   hwnd:   window handle%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID PaintClient(%@NL@%
    HWND hwnd)%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    RECTL rcl;%@NL@%
    SHORT iMessage;%@NL@%
    SHORT yBottom;%@NL@%
    SHORT cx;%@NL@%
    SHORT i;%@NL@%
%@NL@%
    hps = WinBeginPaint(hwnd, (HPS)NULL, (PRECTL)&rcl);%@NL@%
%@NL@%
    %@AB@%/* clear invalidated region */%@AE@%%@NL@%
    WinFillRect(hps, (PRECTL)&rcl, SYSCLR_WINDOW);%@NL@%
%@NL@%
    %@AB@%/* get y position to start drawing */%@AE@%%@NL@%
    WinQueryWindowRect(hwnd, (PRECTL)&rcl);%@NL@%
    yBottom = (SHORT)(rcl.yTop - gcyChar - gcyChar / 2);%@NL@%
%@NL@%
    %@AB@%/* draw headings */%@AE@%%@NL@%
    cx = gcxMargin;%@NL@%
    for (i = 0; i < CDISPLAYFIELDS; i++) {%@NL@%
        if (gamf[i].fDisplay) {%@NL@%
            DrawText(hps, cx, yBottom, gamf[i].szHeading,%@NL@%
                    SYSCLR_WINDOWSTATICTEXT, FALSE);%@NL@%
            cx += gamf[i].cxWidth;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* draw each entry */%@AE@%%@NL@%
    i = gicmStart;%@NL@%
    iMessage = gcMessages;%@NL@%
    yBottom -= (gcyChar + gcyChar / 2);%@NL@%
    do {%@NL@%
        if (!iMessage || yBottom < -gcyChar)%@NL@%
            break;%@NL@%
%@NL@%
        DrawMessage(hps, iMessage, &gacm[i], yBottom);%@NL@%
%@NL@%
        i = (i + 1) % CBUFFERELTS;%@NL@%
        iMessage--;%@NL@%
        yBottom -= gcyChar;%@NL@%
%@NL@%
    } while (i != gicmStart);%@NL@%
%@NL@%
    WinEndPaint(hps);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* NewMessage%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function adds a new WM_CHAR message to the list.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   hwnd:       window handle%@NL@%
%@AB@%*   mp1, mp2:%@NL@%
%@AB@%*   usKC:        key flags%@NL@%
%@AB@%*   usVK:        virtual key code%@NL@%
%@AB@%*   ch:         char;%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID NewMessage(%@NL@%
    HWND hwnd,%@NL@%
    MPARAM mp1,%@NL@%
    MPARAM mp2)%@NL@%
{%@NL@%
    RECTL rclScroll, rclUpdate;%@NL@%
    HPS hps;%@NL@%
%@NL@%
    %@AB@%/* overwrite oldest entry */%@AE@%%@NL@%
    if (gicmStart)%@NL@%
        gicmStart--;%@NL@%
    else%@NL@%
        gicmStart = CBUFFERELTS - 1;%@NL@%
%@NL@%
    gacm[gicmStart].usKC = SHORT1FROMMP(mp1);%@NL@%
    gacm[gicmStart].uchRep = CHAR3FROMMP(mp1);%@NL@%
    gacm[gicmStart].uchScan = CHAR4FROMMP(mp1);%@NL@%
    gacm[gicmStart].ch = SHORT1FROMMP(mp2);%@NL@%
    gacm[gicmStart].usVK = SHORT2FROMMP(mp2);%@NL@%
%@NL@%
    gcMessages++;%@NL@%
%@NL@%
    %@AB@%/* scroll and update intelligently */%@AE@%%@NL@%
    WinQueryWindowRect(hwnd, (PRECTL)&rclScroll);%@NL@%
    rclScroll.yTop -= 2 * gcyChar;%@NL@%
    rclScroll.yBottom = max2(0L, rclScroll.yTop - (LONG)(CBUFFERELTS * gcyChar));%@NL@%
%@NL@%
    WinScrollWindow(hwnd, 0, -gcyChar, (PRECTL)&rclScroll, (PRECTL)&rclScroll,%@NL@%
                    NULL, &rclUpdate, 0);%@NL@%
%@NL@%
    hps = WinGetPS(hwnd);%@NL@%
    WinFillRect(hps, (PRECTL)&rclUpdate, SYSCLR_WINDOW);%@NL@%
    DrawMessage( hps%@NL@%
               , gcMessages%@NL@%
               , &gacm[gicmStart]%@NL@%
               , (SHORT)rclScroll.yTop - gcyChar );%@NL@%
    WinReleasePS(hps);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* CheckMenuItem%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function sets the check state of a menu item.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   hwnd:   frame window%@NL@%
%@AB@%*   id:     menu id%@NL@%
%@AB@%*   fCheck: check state%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID CheckMenuItem(%@NL@%
    HWND hwndFrame,%@NL@%
    SHORT id,%@NL@%
    BOOL fCheck)%@NL@%
{%@NL@%
    HWND hwndMenu;%@NL@%
%@NL@%
    %@AB@%/* toggle menu checkmark */%@AE@%%@NL@%
    hwndMenu = WinWindowFromID(hwndFrame, FID_MENU);%@NL@%
    WinSendMsg(hwndMenu, MM_SETITEMATTR, MPFROM2SHORT(id, TRUE),%@NL@%
               MPFROM2SHORT(MIA_CHECKED, fCheck ? MIA_CHECKED : 0));%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* MenuCommand%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function processes WM_COMMAND messages.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   hwnd:   client window handle%@NL@%
%@AB@%*   id:     command identifier%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID MenuCommand(%@NL@%
    HWND hwnd,%@NL@%
    SHORT id)%@NL@%
{%@NL@%
    BOOL *pfDisplay;%@NL@%
    HWND hwndFrame;%@NL@%
%@NL@%
    if (id == IDM_CLEAR) {%@NL@%
%@NL@%
        %@AB@%/* clear current messages */%@AE@%%@NL@%
        gcMessages = 0;%@NL@%
        WinInvalidateRect(hwnd, NULL, FALSE);%@NL@%
%@NL@%
    } else if (id == IDM_KEYUPS) {%@NL@%
%@NL@%
        %@AB@%/* toggle logging keyups */%@AE@%%@NL@%
        gfKeyUps = !gfKeyUps;%@NL@%
        hwndFrame = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
        CheckMenuItem(hwndFrame, IDM_KEYUPS, gfKeyUps);%@NL@%
%@NL@%
    } else if (id >= IDM_DISPLAYFIRST && id <= IDM_DISPLAYLAST) {%@NL@%
%@NL@%
        %@AB@%/* toggle display field */%@AE@%%@NL@%
        pfDisplay = &(gamf[id - IDM_DISPLAYFIRST].fDisplay);%@NL@%
        *pfDisplay = !*pfDisplay;%@NL@%
        hwndFrame = WinQueryWindow(hwnd, QW_PARENT, FALSE);%@NL@%
        CheckMenuItem(hwndFrame, id, *pfDisplay);%@NL@%
%@NL@%
        %@AB@%/* repaint in new format */%@AE@%%@NL@%
        WinInvalidateRect(hwnd, NULL, FALSE);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* MainWndProc%@NL@%
%@AB@%*%@NL@%
%@AB@%* This is the window procedure for the main client window.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY MainWndProc(%@NL@%
    HWND hwnd,%@NL@%
    USHORT msg,%@NL@%
    MPARAM mp1,%@NL@%
    MPARAM mp2)%@NL@%
{%@NL@%
    switch (msg) {%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        PaintClient(hwnd);%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        MenuCommand(hwnd, SHORT1FROMMP(mp1));%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CHAR:%@NL@%
        if (gfKeyUps || !(KC_KEYUP & SHORT1FROMMP(mp1))) {%@NL@%
%@NL@%
            %@AB@%/* add new message to list */%@AE@%%@NL@%
            NewMessage(hwnd, mp1, mp2);%@NL@%
        }%@NL@%
        break;%@NL@%
%@NL@%
    default:%@NL@%
        return WinDefWindowProc(hwnd, msg, mp1, mp2);%@NL@%
    }%@NL@%
%@NL@%
    return (MRESULT)0;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* CheckMenus%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function sets menu check marks according to their current internal%@NL@%
%@AB@%* state.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   hwndFrame:  main app window handle%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID CheckMenus(%@NL@%
    HWND hwndFrame)%@NL@%
{%@NL@%
    SHORT id;%@NL@%
%@NL@%
    CheckMenuItem(hwndFrame, IDM_KEYUPS, gfKeyUps);%@NL@%
%@NL@%
    for (id = IDM_DISPLAYFIRST; id <= IDM_DISPLAYLAST; id++) {%@NL@%
        CheckMenuItem(hwndFrame, id, gamf[id - IDM_DISPLAYFIRST].fDisplay);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* RegisterSwitchEntry%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function registers the app with the switch list.%@NL@%
%@AB@%*%@NL@%
%@AB@%* Parameters:%@NL@%
%@AB@%*   hwndFrame:  main app window handle%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID RegisterSwitchEntry(%@NL@%
    HWND hwndFrame)%@NL@%
{%@NL@%
    PID pid;%@NL@%
    TID tid;%@NL@%
    SWCNTRL swc;%@NL@%
%@NL@%
    WinQueryWindowProcess(hwndFrame, (PPID)&pid, (PTID)&tid);%@NL@%
    WinQueryWindowText(hwndFrame, MAXNAMEL, (PSZ)swc.szSwtitle);%@NL@%
    swc.hwnd = hwndFrame;%@NL@%
    swc.hwndIcon = (ULONG)NULL;%@NL@%
    swc.hprog = (HPROGRAM)NULL;%@NL@%
    swc.idProcess = pid;%@NL@%
    swc.idSession = NULL;%@NL@%
    swc.uchVisibility = SWL_VISIBLE;%@NL@%
    swc.fbJump = SWL_JUMPABLE;%@NL@%
    WinAddSwitchEntry((PSWCNTRL)&swc);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* GetDisplayValues%@NL@%
%@AB@%*%@NL@%
%@AB@%* This function sets display dependent global variables.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID GetDisplayValues(VOID)%@NL@%
{%@NL@%
    HPS hps;%@NL@%
    FONTMETRICS fm;%@NL@%
    SHORT i;%@NL@%
%@NL@%
    hps = WinGetPS(HWND_DESKTOP);%@NL@%
    GpiQueryFontMetrics(hps, (ULONG)sizeof(FONTMETRICS), (PFONTMETRICS)&fm);%@NL@%
    WinReleasePS(hps);%@NL@%
%@NL@%
    gcyChar = (SHORT)(fm.lMaxBaselineExt + fm.lExternalLeading);%@NL@%
    gcxAveChar = (SHORT)fm.lAveCharWidth;%@NL@%
    gcxMaxChar = (SHORT)fm.lMaxCharInc;%@NL@%
%@NL@%
    %@AB@%/* adjust display widths for this font */%@AE@%%@NL@%
    gcxMargin *= gcxAveChar;%@NL@%
    for (i = 0; i < CDISPLAYFIELDS; i++) {%@NL@%
        gamf[i].cxWidth *= gcxAveChar;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%/***************************************************************************\%@NL@%
%@AB@%* main%@NL@%
%@AB@%*%@NL@%
%@AB@%* This is the main procedure for the app.%@NL@%
%@AB@%\***************************************************************************/%@AE@%%@NL@%
%@NL@%
VOID cdecl main(VOID)%@NL@%
{%@NL@%
    HAB hab;%@NL@%
    HMQ hmq;%@NL@%
    QMSG qmsg;%@NL@%
    ULONG ulCreate;%@NL@%
    HWND hwndFrame;%@NL@%
    HWND hwndClient;%@NL@%
    static CHAR szApp[] = "Char Messages";%@NL@%
%@NL@%
    %@AB@%/* init app */%@AE@%%@NL@%
    hab = WinInitialize(0);%@NL@%
    hmq = WinCreateMsgQueue(hab, 0);%@NL@%
    GetDisplayValues();%@NL@%
%@NL@%
    %@AB@%/* create main window */%@AE@%%@NL@%
    WinRegisterClass(hab, szApp, MainWndProc, 0L, 0);%@NL@%
    ulCreate = FCF_TITLEBAR | FCF_SYSMENU | FCF_MINMAX | FCF_SIZEBORDER |%@NL@%
               FCF_MENU | FCF_SHELLPOSITION;%@NL@%
    hwndFrame = WinCreateStdWindow(HWND_DESKTOP, WS_VISIBLE, &ulCreate,%@NL@%
                                    szApp, szApp, 0L, (HMODULE) NULL, ID_RESOURCES,%@NL@%
                                    &hwndClient);%@NL@%
%@NL@%
    %@AB@%/* register with switch list */%@AE@%%@NL@%
    RegisterSwitchEntry(hwndFrame);%@NL@%
%@NL@%
    %@AB@%/* initialize menu */%@AE@%%@NL@%
    CheckMenus(hwndFrame);%@NL@%
%@NL@%
    %@AB@%/* message loop */%@AE@%%@NL@%
    while (WinGetMsg(hab, &qmsg, NULL, 0, 0))%@NL@%
        WinDispatchMsg(hab, &qmsg);%@NL@%
%@NL@%
    %@AB@%/* clean up */%@AE@%%@NL@%
    WinDestroyWindow(hwndFrame);%@NL@%
    WinDestroyMsgQueue(hmq);%@NL@%
    WinTerminate(hab);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WNDPROC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\CLOCK\WNDPROC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    wndproc.c -- Window Procedure for Clock Client Window%@NL@%
%@AB@%    Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"clock.h" %@NL@%
%@AI@%#include %@AE@%"res.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClkAboutDlgProc ( HWND , USHORT , MPARAM , MPARAM ) ;%@NL@%
MRESULT EXPENTRY ClkTicksDlgProc ( HWND , USHORT , MPARAM , MPARAM ) ;%@NL@%
MRESULT EXPENTRY ClkColorsDlgProc ( HWND , USHORT , MPARAM , MPARAM ) ;%@NL@%
%@NL@%
extern HAB hab ;%@NL@%
extern HWND hwndFrame ;%@NL@%
extern BOOL fStartAsIcon ;%@NL@%
extern VOID ClkDrawFace( HPS );%@NL@%
extern VOID ClkDrawHand( HPS, SHORT, SHORT );%@NL@%
%@NL@%
VOID ClkPaint ( HWND ) ;%@NL@%
VOID ClkCreate ( HWND ) ;%@NL@%
VOID ClkSize ( HWND ) ;%@NL@%
VOID ClkTimer ( VOID ) ;%@NL@%
VOID ClkCommand ( HWND , MPARAM ) ;%@NL@%
%@NL@%
VOID ClkHideFrameControls ( HWND ) ;%@NL@%
VOID ClkShowFrameControls ( HWND ) ;%@NL@%
%@NL@%
SWP swp ;%@NL@%
HPS hps ;%@NL@%
HDC hdc ;%@NL@%
RECTL rclPage ;%@NL@%
DATETIME dt ;%@NL@%
BOOL f ;%@NL@%
BOOL fIconic , fShowSecondHand ;%@NL@%
BOOL fControlsHidden = FALSE ;%@NL@%
SIZEL sizl = { 200 , 200 } ;%@NL@%
ULONG cxRes , cyRes ;%@NL@%
%@NL@%
HWND hwndTitleBar , hwndSysMenu , hwndMinMax , hwndMenu ;%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkWndProc() -- Window Procedure for Clock Client Window%@NL@%
%@AB@%    Returns:  MRESULT (Message Result)%@NL@%
%@AB@%*/%@AE@%%@NL@%
MRESULT EXPENTRY ClkWndProc ( HWND hwnd , USHORT usMsg ,%@NL@%
                                MPARAM mp1 , MPARAM mp2 )%@NL@%
{%@NL@%
%@NL@%
    switch ( usMsg ) {%@NL@%
%@NL@%
        case WM_TIMER :%@NL@%
            ClkTimer ( ) ;%@NL@%
            return NULL ;%@NL@%
%@NL@%
        case WM_PAINT :%@NL@%
            ClkPaint ( hwnd ) ;%@NL@%
            return NULL ;%@NL@%
%@NL@%
         case WM_SIZE :%@NL@%
            ClkSize ( hwnd ) ;%@NL@%
            return NULL ;%@NL@%
%@NL@%
        case WM_COMMAND :%@NL@%
            ClkCommand ( hwnd , mp1 ) ;%@NL@%
            return NULL ;%@NL@%
%@NL@%
        case WM_BUTTON1DOWN :%@NL@%
            return WinSendMsg ( hwndFrame , WM_TRACKFRAME ,%@NL@%
                    ( MPARAM ) ( LOUSHORT ( mp2 ) | TF_MOVE ) , NULL ) ;%@NL@%
%@NL@%
        case WM_CHAR:%@NL@%
            if ( fControlsHidden )%@NL@%
                ClkShowFrameControls ( hwndFrame ) ;%@NL@%
            return NULL ;%@NL@%
%@NL@%
        case WM_BUTTON1DBLCLK :%@NL@%
            if ( fControlsHidden )%@NL@%
                ClkShowFrameControls ( hwndFrame ) ;%@NL@%
            else%@NL@%
                ClkHideFrameControls ( hwndFrame ) ;%@NL@%
            return NULL ;%@NL@%
%@NL@%
        case WM_CREATE :%@NL@%
            ClkCreate ( hwnd ) ;%@NL@%
            return NULL ;%@NL@%
%@NL@%
        default :%@NL@%
            %@AB@%/* let default window procedure handle it. */%@AE@%%@NL@%
            return ( WinDefWindowProc ( hwnd , usMsg , mp1 , mp2 ) ) ;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkCreate() -- Initialize newly created client window%@NL@%
%@AB@%*/%@AE@%%@NL@%
VOID ClkCreate ( HWND hwnd )%@NL@%
{%@NL@%
    LONG cxScreen , cyScreen ;        %@AB@%/* screen dimensions */%@AE@%%@NL@%
    LONG xLeft , yBottom ;        %@AB@%/* frame window location */%@AE@%%@NL@%
    LONG cxWidth , cyHeight ;        %@AB@%/* frame window size */%@AE@%%@NL@%
    HWND hwndFrame , hwndMenu ;%@NL@%
%@NL@%
    %@AB@%/* we are called before the global hwndFrame is valid */%@AE@%%@NL@%
    hwndFrame = WinQueryWindow ( hwnd , QW_PARENT , FALSE ) ;%@NL@%
%@NL@%
    %@AB@%/* load our menus */%@AE@%%@NL@%
    hwndMenu = WinLoadMenu ( hwndFrame , (HMODULE) NULL , ID_RESOURCE ) ;%@NL@%
%@NL@%
    %@AB@%/* open a device context and create a presentation space */%@AE@%%@NL@%
    hdc = WinOpenWindowDC ( hwnd ) ;%@NL@%
    hps = GpiCreatePS ( hab , hdc , & sizl ,%@NL@%
                        PU_ARBITRARY | GPIT_MICRO | GPIA_ASSOC ) ;%@NL@%
%@NL@%
    %@AB@%/* determine screen dimensions */%@AE@%%@NL@%
    cxScreen = WinQuerySysValue (HWND_DESKTOP , SV_CXSCREEN ) ;%@NL@%
    cyScreen = WinQuerySysValue (HWND_DESKTOP , SV_CYSCREEN ) ;%@NL@%
%@NL@%
    %@AB@%/* calculate an initial window position and size */%@AE@%%@NL@%
    xLeft = cxScreen / 8 ;%@NL@%
    yBottom = cyScreen / 2 ;%@NL@%
    cxWidth = cxScreen / 3 ;%@NL@%
    cyHeight = cyScreen / 2 ;%@NL@%
%@NL@%
    %@AB@%/* get the device resolutions so we can make the face appear circular */%@AE@%%@NL@%
    DevQueryCaps ( hdc , CAPS_VERTICAL_RESOLUTION , 1L , & cyRes ) ;%@NL@%
    DevQueryCaps ( hdc , CAPS_HORIZONTAL_RESOLUTION , 1L , & cxRes ) ;%@NL@%
%@NL@%
    %@AB@%/* position the window and make it visible */%@AE@%%@NL@%
    WinSetWindowPos ( hwndFrame , HWND_TOP ,%@NL@%
                      (SHORT) xLeft , (SHORT) yBottom ,%@NL@%
                      (SHORT) cxWidth , (SHORT) cyHeight ,%@NL@%
                      SWP_SIZE | SWP_MOVE | SWP_ACTIVATE ) ;%@NL@%
%@NL@%
    %@AB@%/* have we been asked to start as an icon? */%@AE@%%@NL@%
    if ( fStartAsIcon )%@NL@%
        WinSetWindowPos ( hwndFrame , NULL , 0 , 0 , 0 , 0 , SWP_MINIMIZE ) ;%@NL@%
%@NL@%
    WinShowWindow ( hwndFrame , TRUE ) ;%@NL@%
%@NL@%
    %@AB@%/* get the time in a format for dislaying */%@AE@%%@NL@%
    DosGetDateTime ( & dt ) ;%@NL@%
    dt . hours = (UCHAR)(( dt . hours * 5 ) % 60 + dt . minutes / 12 );%@NL@%
%@NL@%
    %@AB@%/* start a timer */%@AE@%%@NL@%
    WinStartTimer ( hab , hwnd , ID_RESOURCE , 1000 ) ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkSize() -- Window Sizing Processing%@NL@%
%@AB@%%@NL@%
%@AB@%    When the window has been sized, we calculate a page%@NL@%
%@AB@%    rectangle which:  (a) fills the window rectangle in%@NL@%
%@AB@%    either the x or y dimension, (b) appears square, and%@NL@%
%@AB@%    (c) is centered in the window rectangle.%@NL@%
%@AB@%*/%@AE@%%@NL@%
VOID ClkSize ( HWND hwnd )%@NL@%
{%@NL@%
    HWND hwndFrame ;%@NL@%
    RECTL rclWindow ;%@NL@%
    ULONG cxWidth , cyHeight ;%@NL@%
    ULONG cxSquare , cySquare , cxEdge , cyEdge ;%@NL@%
%@NL@%
    %@AB@%/* get the width and height of the window rectangle */%@AE@%%@NL@%
    WinQueryWindowRect ( hwnd , & rclWindow ) ;%@NL@%
    cxWidth = rclWindow . xRight - rclWindow . xLeft ;%@NL@%
    cyHeight = rclWindow . yTop - rclWindow . yBottom ;%@NL@%
%@NL@%
    %@AB@%/* assume the size of the page rectangle is constrained in the y dimension,%@NL@%
%@AB@%     * compute the x size which would make the rectangle appear square, then%@NL@%
%@AB@%     * check the assumption and do the reverse calculation if necessary */%@AE@%%@NL@%
%@NL@%
    cySquare = cyHeight ;%@NL@%
    cxSquare = ( cyHeight * cxRes ) / cyRes ;%@NL@%
    if ( cxWidth < cxSquare ) {%@NL@%
        cxSquare = cxWidth ;%@NL@%
        cySquare = ( cxWidth * cyRes ) / cxRes ;%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* fill in the page rectangle and set the page viewport */%@AE@%%@NL@%
    cxEdge = ( cxWidth - cxSquare ) / 2 ;%@NL@%
    cyEdge = ( cyHeight - cySquare ) / 2 ;%@NL@%
    rclPage . xLeft = cxEdge ;%@NL@%
    rclPage . xRight = cxWidth - cxEdge ;%@NL@%
    rclPage . yBottom = cyEdge ;%@NL@%
    rclPage . yTop = cyHeight - cyEdge ;%@NL@%
    f = GpiSetPageViewport ( hps , & rclPage ) ;%@NL@%
%@NL@%
    %@AB@%/* are we iconic? */%@AE@%%@NL@%
    hwndFrame = WinQueryWindow ( hwnd , QW_PARENT , FALSE ) ;%@NL@%
    f = WinQueryWindowPos ( hwndFrame , & swp ) ;%@NL@%
    fIconic = swp . fs & SWP_MINIMIZE ;%@NL@%
    fShowSecondHand = ! fIconic ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkTimer() -- Handles timer events%@NL@%
%@AB@%*/%@AE@%%@NL@%
VOID ClkTimer ( VOID )%@NL@%
{%@NL@%
    DATETIME dtNew ;%@NL@%
%@NL@%
    %@AB@%/* get the new time */%@AE@%%@NL@%
    DosGetDateTime ( & dtNew ) ;%@NL@%
%@NL@%
    %@AB@%/* adjust the hour hand */%@AE@%%@NL@%
    dtNew . hours =(UCHAR)( ( dtNew . hours * 5 ) % 60 + dtNew . minutes / 12 );%@NL@%
%@NL@%
    %@AB@%/* if we must move the hour and minute hands, redraw it all */%@AE@%%@NL@%
    if ( dtNew . minutes != dt . minutes ) {%@NL@%
%@NL@%
        ClkDrawFace ( hps ) ;%@NL@%
        ClkDrawHand ( hps , HT_HOUR , dtNew . hours ) ;%@NL@%
        ClkDrawHand ( hps , HT_MINUTE , dtNew . minutes ) ;%@NL@%
%@NL@%
        if ( fShowSecondHand ) {%@NL@%
            GpiSetMix ( hps , FM_INVERT ) ;%@NL@%
            ClkDrawHand ( hps , HT_SECOND , dtNew . seconds ) ;%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
    %@AB@%/* otherwise just undraw the old second hand and draw the new */%@AE@%%@NL@%
    else if ( fShowSecondHand ) {%@NL@%
        GpiSetMix ( hps , FM_INVERT ) ;%@NL@%
        ClkDrawHand ( hps , HT_SECOND , dt . seconds ) ;%@NL@%
        ClkDrawHand ( hps , HT_SECOND , dtNew . seconds ) ;%@NL@%
    }%@NL@%
%@NL@%
    dt = dtNew ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkCommand() -- Handle WM_COMMAND events%@NL@%
%@AB@%*/%@AE@%%@NL@%
VOID ClkCommand ( HWND hwnd , MPARAM mp1 )%@NL@%
{%@NL@%
    switch ( SHORT1FROMMP ( mp1 ) ) {%@NL@%
%@NL@%
        case IDM_ABOUT :%@NL@%
            WinDlgBox ( HWND_DESKTOP , hwnd , ClkAboutDlgProc , (HMODULE) NULL ,%@NL@%
                        IDD_ABOUT , NULL ) ;%@NL@%
            break ;%@NL@%
%@NL@%
        case IDM_TICKS :%@NL@%
            WinDlgBox ( HWND_DESKTOP , hwnd , ClkTicksDlgProc , (HMODULE) NULL ,%@NL@%
                        IDD_TICKS , NULL ) ;%@NL@%
            break ;%@NL@%
%@NL@%
        case IDM_COLORS :%@NL@%
            WinDlgBox ( HWND_DESKTOP , hwnd , ClkColorsDlgProc , (HMODULE) NULL ,%@NL@%
                        IDD_COLORS , NULL ) ;%@NL@%
            break ;%@NL@%
%@NL@%
        case IDM_HIDECONTROLS :%@NL@%
            ClkHideFrameControls ( hwndFrame ) ;%@NL@%
            break ;%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkHideFrameControls() -- Hide the title bar and associated controls%@NL@%
%@AB@%*/%@AE@%%@NL@%
VOID ClkHideFrameControls ( HWND hwndFrame )%@NL@%
{%@NL@%
%@NL@%
    hwndTitleBar = WinWindowFromID ( hwndFrame , FID_TITLEBAR ) ;%@NL@%
    hwndSysMenu = WinWindowFromID ( hwndFrame , FID_SYSMENU ) ;%@NL@%
    hwndMinMax = WinWindowFromID ( hwndFrame , FID_MINMAX ) ;%@NL@%
    hwndMenu = WinWindowFromID ( hwndFrame , FID_MENU ) ;%@NL@%
%@NL@%
    WinSetParent ( hwndTitleBar , HWND_OBJECT , FALSE ) ;%@NL@%
    WinSetParent ( hwndSysMenu , HWND_OBJECT , FALSE ) ;%@NL@%
    WinSetParent ( hwndMinMax , HWND_OBJECT , FALSE ) ;%@NL@%
    WinSetParent ( hwndMenu , HWND_OBJECT , FALSE ) ;%@NL@%
%@NL@%
    WinSendMsg ( hwndFrame , WM_UPDATEFRAME ,%@NL@%
        ( MPARAM ) ( FCF_TITLEBAR | FCF_SYSMENU | FCF_MINMAX | FCF_MENU ) ,%@NL@%
        NULL ) ;%@NL@%
%@NL@%
    fControlsHidden = TRUE ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    ClkShowFrameControls() -- Show the title bar and associated controls%@NL@%
%@AB@%*/%@AE@%%@NL@%
VOID ClkShowFrameControls ( HWND hwndFrame )%@NL@%
{%@NL@%
%@NL@%
    WinSetParent ( hwndTitleBar , hwndFrame , FALSE ) ;%@NL@%
    WinSetParent ( hwndSysMenu , hwndFrame , FALSE ) ;%@NL@%
    WinSetParent ( hwndMinMax , hwndFrame , FALSE ) ;%@NL@%
    WinSetParent ( hwndMenu , hwndFrame , FALSE ) ;%@NL@%
%@NL@%
    WinSendMsg ( hwndFrame , WM_UPDATEFRAME ,%@NL@%
        ( MPARAM ) ( FCF_TITLEBAR | FCF_SYSMENU | FCF_MINMAX | FCF_MENU ) ,%@NL@%
        NULL ) ;%@NL@%
    WinInvalidateRect ( hwndFrame , NULL , TRUE ) ;%@NL@%
%@NL@%
    fControlsHidden = FALSE ;%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WNDPROC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\OS2SDK\OS2SDK12\BIO\WNDPROC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/* wndproc.c -- Window handling routines%@NL@%
%@AB@%   Created by Microsoft Corporation, 1989%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#include %@AE@%"bio.h" %@NL@%
%@AI@%#include %@AE@%<time.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AB@%/* Read-only global variables */%@AE@%%@NL@%
extern HAB      hAB;%@NL@%
extern HWND     hwndApp;%@NL@%
extern HWND     hwndAppFrame, hwndKidFrame;%@NL@%
extern char     szAppName[];%@NL@%
extern PFNWP OldFrameWndProc;%@NL@%
%@NL@%
%@AB@%/* Write-once Global variables */%@AE@%%@NL@%
LONG Color[] = {CLR_RED, CLR_GREEN, CLR_BLUE};%@NL@%
FONTMETRICS     tmFontInfo;%@NL@%
SHORT                cxLegendField;%@NL@%
SHORT                cxDateField;%@NL@%
%@AB@%/* parameter used when creating a device context for a memory device        */%@AE@%%@NL@%
PSZ         dcdatablk[9] = {(PSZ)0%@NL@%
                           ,(PSZ)"DISPLAY"%@NL@%
                           ,(PSZ)0%@NL@%
                           ,(PSZ)0%@NL@%
                           ,(PSZ)0%@NL@%
                           ,(PSZ)0%@NL@%
                           ,(PSZ)0%@NL@%
                           ,(PSZ)0%@NL@%
                           ,(PSZ)0%@NL@%
                           };%@NL@%
%@NL@%
%@AB@%/* Read-Write global variables */%@AE@%%@NL@%
double          Born;%@NL@%
long            Day, SelectDay;%@NL@%
BOOL            bKid = TRUE;%@NL@%
BOOL            bBorn = TRUE;%@NL@%
RECTL           rclClient;%@NL@%
int             LinesPerPage;%@NL@%
void                BioGetDate(HWND);%@NL@%
%@NL@%
%@AB@%/*  BioWndProc() - Parent WndProc message processing routine.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Purpose:%@NL@%
%@AB@%*       WndProc callback function to handle all messages for parent window.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Arguments:%@NL@%
%@AB@%*       hWnd          - Handle of Window owning message%@NL@%
%@AB@%*       message       - Message itself%@NL@%
%@AB@%*       mp1           - Extra message-dependent info%@NL@%
%@AB@%*       mp2           - Extra message-dependent info%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (modified):%@NL@%
%@AB@%*       Born          - Birthdate in julian days.  Read from WIN.INI.%@NL@%
%@AB@%*        SelectDay     - Current day being tracked, day is highlighted.%@NL@%
%@AB@%*                        Value is days from birthdate.%@NL@%
%@AB@%*                        Initialized to current day in WM_CREATE processing.%@NL@%
%@AB@%*       daylight      - Defined by environment string TZ.  If no such string,%@NL@%
%@AB@%*       timezone        default TZ=PST8PDT used.  If daylight field is%@NL@%
%@AB@%*                       used, daylight time correction will occur.  See%@NL@%
%@AB@%*                       documentation of tzset() C run-time function.%@NL@%
%@AB@%*       Day           - Day number from date born which is top line being%@NL@%
%@AB@%*                       displayed.  Initially three days before SelectDay.%@NL@%
%@AB@%*       bKid          - Boolean indicating whether legend is visible.%@NL@%
%@AB@%*       bBorn         - Boolean indicating whether valid birtdate entered or%@NL@%
%@AB@%*                       defined in WIN.INI.  Nothing graphed until valid.%@NL@%
%@AB@%*        rclClient     - Size of client area defined by WM_SIZE message%@NL@%
%@AB@%*       LinesPerPage  - Number of system font lines on client area, defined%@NL@%
%@AB@%*                       by WM_SIZE message handling%@NL@%
%@AB@%*       Color[]       - Set of colored pens used to identify cycles.%@NL@%
%@AB@%*       tmFontInfo    - Text Metric structure defined during WM_CREATE %@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (referenced):%@NL@%
%@AB@%*       hAB           - Handle to the Anchor Block%@NL@%
%@AB@%*       hwndAppFrame  - Window handle of parent window's frame%@NL@%
%@AB@%*       hwndKidFrame  - Handle to child window used for showing/moving legend.%@NL@%
%@AB@%*        szAppName[]   - RC file program name (Biorhythm).%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Description:%@NL@%
%@AB@%*       Handle all messages for the parent window.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Limits:%@NL@%
%@AB@%*       N/A%@NL@%
%@AB@%*%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@NL@%
MRESULT CALLBACK BioWndProc( hWnd, message, mp1, mp2 )%@NL@%
HWND   hWnd;%@NL@%
USHORT message;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
    int         iDay, i;%@NL@%
    HPS         hPS;%@NL@%
    HPS         hMemPS;%@NL@%
    RECTL       rc;%@NL@%
    POINTL        ptlTextBox[5];%@NL@%
    SIZEL        pgsi;%@NL@%
    HDC                hdcMem;%@NL@%
    HBITMAP        hbm;%@NL@%
    BITMAPINFOHEADER bmih;%@NL@%
    POINTL        ptlPoints[3];%@NL@%
%@NL@%
    switch( message )%@NL@%
    {%@NL@%
%@NL@%
    case WM_CREATE:%@NL@%
        BioGetDate(hWnd);%@NL@%
%@NL@%
        %@AB@%/* Put date of the day three lines down on display */%@AE@%%@NL@%
        Day = SelectDay - 3;%@NL@%
%@NL@%
        %@AB@%/* Initially set elevator */%@AE@%%@NL@%
        iDay = (int)(Day/365);%@NL@%
        WinSendMsg( WinWindowFromID( WinQueryWindow(hWnd,QW_PARENT,FALSE),%@NL@%
                                     FID_VERTSCROLL),%@NL@%
                    SBM_SETPOS, (MPARAM)MAKEULONG(iDay, 0), 0L );%@NL@%
%@NL@%
        %@AB@%/* Get System font text metrics */%@AE@%%@NL@%
        hPS = WinGetPS( hWnd );%@NL@%
        GpiQueryFontMetrics( hPS, (LONG)sizeof tmFontInfo, &tmFontInfo );%@NL@%
        %@AB@%/* Get sizes of long strings to be used as yard sticks for sizing%@NL@%
%@AB@%           windows and objects.  This is necessary because of new system%@NL@%
%@AB@%           proportional fonts. */%@AE@%%@NL@%
        GpiQueryTextBox( hPS, 10L, "Emotional ", TXTBOX_COUNT, ptlTextBox );%@NL@%
        cxLegendField = (SHORT)ptlTextBox[TXTBOX_CONCAT].x;%@NL@%
        GpiQueryTextBox( hPS, 10L, "W 99-99-99", TXTBOX_COUNT, ptlTextBox );%@NL@%
        cxDateField = (SHORT)ptlTextBox[TXTBOX_CONCAT].x;%@NL@%
        WinReleasePS( hPS );%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CLOSE:%@NL@%
        WinPostMsg( hWnd, WM_QUIT, 0L, 0L );%@NL@%
        break;%@NL@%
%@NL@%
    case WM_COMMAND:%@NL@%
        switch (LOUSHORT(mp1)) {%@NL@%
            case IDM_DATES:%@NL@%
                if (WinDlgBox( HWND_DESKTOP, hWnd, (PFNWP)BioDlg, (HMODULE) NULL, IDD_DATE, NULL )) {%@NL@%
                   WinInvalidateRect( hWnd, NULL, FALSE );%@NL@%
                   iDay = (int)(Day/365);%@NL@%
                   WinSendMsg( WinWindowFromID( hwndAppFrame, FID_VERTSCROLL),%@NL@%
                               SBM_SETPOS, (MPARAM)MAKEULONG(iDay, 0), 0L );%@NL@%
                }%@NL@%
                break;%@NL@%
%@NL@%
            case IDM_LEGEND:%@NL@%
                if (bKid = !bKid) {%@NL@%
                   WinSendMsg( WinWindowFromID( hwndAppFrame, FID_MENU),%@NL@%
                               MM_SETITEMATTR,%@NL@%
                               (MPARAM)MAKEULONG( IDM_LEGEND, TRUE ),%@NL@%
                               (MPARAM)MAKEULONG( MIA_CHECKED, MIA_CHECKED) );%@NL@%
                   WinShowWindow( hwndKidFrame, TRUE );%@NL@%
                } else {%@NL@%
                   WinSendMsg( WinWindowFromID( hwndAppFrame, FID_MENU),%@NL@%
                               MM_SETITEMATTR,%@NL@%
                               (MPARAM)MAKEULONG( IDM_LEGEND, TRUE ),%@NL@%
                               (MPARAM)MAKEULONG( MIA_CHECKED, 0) );%@NL@%
                   WinShowWindow( hwndKidFrame, FALSE );%@NL@%
                }%@NL@%
                break;%@NL@%
%@NL@%
            case IDM_COPY:%@NL@%
                %@AB@%/* Get access to clipboard. */%@AE@%%@NL@%
                WinOpenClipbrd( hAB );%@NL@%
                %@AB@%/* Wipe the slate clean. */%@AE@%%@NL@%
                WinEmptyClipbrd( hAB );%@NL@%
%@NL@%
                %@AB@%/* Bitmap header for bitmap the size of the window. */%@AE@%%@NL@%
                pgsi.cx = rclClient.xRight;%@NL@%
                pgsi.cy = rclClient.yTop;%@NL@%
                bmih.cbFix = 12;%@NL@%
                bmih.cx = (USHORT)pgsi.cx;%@NL@%
                bmih.cy = (USHORT)pgsi.cy;%@NL@%
                bmih.cPlanes = 1;%@NL@%
                bmih.cBitCount = 24;%@NL@%
%@NL@%
                %@AB@%/* Get a memory dc. */%@AE@%%@NL@%
                hdcMem = DevOpenDC( hAB%@NL@%
                              , OD_MEMORY%@NL@%
                              , (PSZ)"*"%@NL@%
                              , 8L%@NL@%
                              , (PDEVOPENDATA)dcdatablk%@NL@%
                              , (HDC)NULL%@NL@%
                              );%@NL@%
%@NL@%
                %@AB@%/* Get a memory PS that will be used to manipulate image */%@AE@%%@NL@%
                hMemPS = GpiCreatePS( hAB%@NL@%
                                , hdcMem%@NL@%
                                , (PSIZEL)&pgsi%@NL@%
                                , (LONG)PU_PELS | GPIT_MICRO | GPIA_ASSOC%@NL@%
                                );%@NL@%
%@NL@%
                %@AB@%/* Create a bitmap to hold image */%@AE@%%@NL@%
                hbm = GpiCreateBitmap(hMemPS, &bmih, 0L, (PBYTE)NULL, (PBITMAPINFO)NULL);%@NL@%
                %@AB@%/* Select bitmap into PS */%@AE@%%@NL@%
                GpiSetBitmap( hMemPS, hbm );%@NL@%
                %@AB@%/* BitBlt window client area into memory bitmap */%@AE@%%@NL@%
                ptlPoints[0].x = 0;%@NL@%
                ptlPoints[0].y = 0;%@NL@%
                ptlPoints[1].x = pgsi.cx;%@NL@%
                ptlPoints[1].y = pgsi.cy;%@NL@%
                ptlPoints[2].x = 0;%@NL@%
                ptlPoints[2].y = 0;%@NL@%
                hPS = WinGetPS( hWnd );%@NL@%
                GpiBitBlt(hMemPS, hPS, 3L, ptlPoints, ROP_SRCCOPY, BBO_OR);%@NL@%
                WinReleasePS( hPS );%@NL@%
%@NL@%
                %@AB@%/* Put bitmap into the clipboard. */%@AE@%%@NL@%
                WinSetClipbrdData( hAB, (ULONG)hbm, CF_BITMAP, CFI_HANDLE );%@NL@%
%@NL@%
                %@AB@%/* Tidy up */%@AE@%%@NL@%
                WinCloseClipbrd( hAB );%@NL@%
                GpiSetBitmap( hMemPS, NULL );%@NL@%
                GpiDestroyPS( hMemPS );%@NL@%
                DevCloseDC( hdcMem );%@NL@%
                break;%@NL@%
%@NL@%
            case IDM_ABOUT:%@NL@%
                WinDlgBox( HWND_DESKTOP, hWnd, (PFNWP)About, (HMODULE) NULL,%@NL@%
                           IDD_ABOUT, NULL );%@NL@%
                break;%@NL@%
%@NL@%
            default:%@NL@%
                break;%@NL@%
            }%@NL@%
            break;%@NL@%
%@NL@%
    case WM_SIZE:%@NL@%
        WinQueryWindowRect( hWnd, &rclClient );%@NL@%
        LinesPerPage = (int)(rclClient.yTop / tmFontInfo.lMaxBaselineExt);%@NL@%
        WinSetWindowPos( hwndKidFrame, NULL, 10, 10, 0, 0, SWP_MOVE );%@NL@%
        break;%@NL@%
%@NL@%
    case WM_CHAR:%@NL@%
        %@AB@%/* Convert keyboard to scroll bar messages to support scrolling,%@NL@%
%@AB@%           paging, etc. with keyboard interface. */%@AE@%%@NL@%
        if ( (ULONG)mp1 & KC_KEYUP )%@NL@%
            return WinDefWindowProc( hWnd, message, mp1, mp2 );%@NL@%
        switch (HIUSHORT( mp2 )) {%@NL@%
            case VK_UP:%@NL@%
                mp2 = (MPARAM)MAKEULONG( 0, SB_LINEUP );%@NL@%
                break;%@NL@%
            case VK_DOWN:%@NL@%
                mp2 = (MPARAM)MAKEULONG( 0, SB_LINEDOWN );%@NL@%
                break;%@NL@%
            case VK_PAGEUP:%@NL@%
                mp2 = (MPARAM)MAKEULONG( 0, SB_PAGEUP );%@NL@%
                break;%@NL@%
            case VK_PAGEDOWN:%@NL@%
                mp2 = (MPARAM)MAKEULONG( 0, SB_PAGEDOWN );%@NL@%
                break;%@NL@%
            default:%@NL@%
                return WinDefWindowProc( hWnd, message, mp1, mp2 );%@NL@%
                break;%@NL@%
        }%@NL@%
        return WinSendMsg( hWnd, WM_VSCROLL, mp1, mp2 );%@NL@%
        break;%@NL@%
%@NL@%
    case WM_VSCROLL:%@NL@%
        %@AB@%/* Don't allow any processing until valid birth date entered */%@AE@%%@NL@%
        if (!bBorn) break;%@NL@%
%@NL@%
        %@AB@%/* Setup for scroll window - full width of client area is scrolled */%@AE@%%@NL@%
        WinCopyRect( hAB, &rc, &rclClient );%@NL@%
        switch (HIUSHORT(mp2)) {%@NL@%
          case SB_LINEUP:%@NL@%
            %@AB@%/* Update top day of display */%@AE@%%@NL@%
            Day--;%@NL@%
            rc.yTop = rclClient.yTop - tmFontInfo.lMaxBaselineExt;%@NL@%
            rc.yBottom = rclClient.yTop - (LinesPerPage-1) * tmFontInfo.lMaxBaselineExt + 1;%@NL@%
            WinScrollWindow( hWnd, 0, (SHORT)-tmFontInfo.lMaxBaselineExt, &rc,%@NL@%
                             NULL, NULL, NULL, SW_INVALIDATERGN );%@NL@%
            break;%@NL@%
          case SB_LINEDOWN:%@NL@%
            %@AB@%/* Update top day of display */%@AE@%%@NL@%
            Day++;%@NL@%
            rc.yTop = rclClient.yTop - 2*tmFontInfo.lMaxBaselineExt;%@NL@%
            rc.yBottom = rclClient.yTop - (LinesPerPage) * tmFontInfo.lMaxBaselineExt + 1;%@NL@%
            WinScrollWindow( hWnd, 0, (SHORT)tmFontInfo.lMaxBaselineExt, &rc,%@NL@%
                             NULL, NULL, NULL, SW_INVALIDATERGN );%@NL@%
            break;%@NL@%
          case SB_PAGEUP:%@NL@%
            Day -= (LinesPerPage-1);%@NL@%
            break;%@NL@%
          case SB_PAGEDOWN:%@NL@%
            Day += (LinesPerPage-1);%@NL@%
            break;%@NL@%
          case SB_SLIDERPOSITION:%@NL@%
            %@AB@%/* Set to birthday of each year because 100 year scale maps to%@NL@%
%@AB@%               default 100 position scroll bar */%@AE@%%@NL@%
            Day = (long)(LOUSHORT(mp2) * 365.25);%@NL@%
            break;%@NL@%
        default:%@NL@%
            return 0L;%@NL@%
      }%@NL@%
      %@AB@%/* Update scroll bar elevator */%@AE@%%@NL@%
      iDay = (int)(Day/365);%@NL@%
      WinSendMsg( WinWindowFromID( hwndAppFrame, FID_VERTSCROLL),%@NL@%
                  SBM_SETPOS, (MPARAM)MAKEULONG(iDay, 0), 0L );%@NL@%
      %@AB@%/* All but LINEUP/DOWN need full repaint of client area */%@AE@%%@NL@%
      if ((HIUSHORT(mp2) != SB_LINEUP) && (HIUSHORT(mp2) != SB_LINEDOWN ))%@NL@%
         WinInvalidateRect( hWnd, NULL, FALSE );%@NL@%
      WinUpdateWindow( hWnd );%@NL@%
      break;%@NL@%
%@NL@%
    case WM_PAINT:%@NL@%
        APPPaint( hWnd );%@NL@%
        break;%@NL@%
%@NL@%
    case WM_BUTTON1DOWN:%@NL@%
        %@AB@%/* Don't allow any processing until valid birthdate entered */%@AE@%%@NL@%
        if (!bBorn) break;%@NL@%
%@NL@%
        %@AB@%/* Unhighlight previously selected line and highlight new line */%@AE@%%@NL@%
        WinCopyRect( hAB, &rc, &rclClient );%@NL@%
        hPS = WinGetPS( hWnd );%@NL@%
        for(i=0; i<2; i++) {%@NL@%
          %@AB@%/* Make sure line is visible before (un)highlighting */%@AE@%%@NL@%
          if ((SelectDay >= Day) && (SelectDay - Day < LinesPerPage-1)) {%@NL@%
             rc.yTop = rclClient.yTop - (int)(SelectDay - Day + 1) * tmFontInfo.lMaxBaselineExt;%@NL@%
             rc.yBottom = rc.yTop - tmFontInfo.lMaxBaselineExt + 1;%@NL@%
             WinInvertRect( hPS, &rc );%@NL@%
          }%@NL@%
          %@AB@%/* New line to highlight */%@AE@%%@NL@%
          SelectDay = Day + (rclClient.yTop - HIUSHORT(mp1)) / %@NL@%
                      tmFontInfo.lMaxBaselineExt - 1;%@NL@%
        }%@NL@%
        WinReleasePS( hPS );%@NL@%
        break;%@NL@%
%@NL@%
    %@AB@%/* Draw highlight on selected day */%@AE@%%@NL@%
    if ((SelectDay >= Day) && (SelectDay - Day < LinesPerPage - 1)) {%@NL@%
        rc.xRight = rclClient.xRight;%@NL@%
        rc.xLeft = rclClient.xLeft;%@NL@%
    }%@NL@%
    default:%@NL@%
        return WinDefWindowProc( hWnd, message, mp1, mp2 );%@NL@%
        break;%@NL@%
    }%@NL@%
    return( 0L );%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*  KidWndProc() - Child WndProc handling legend display.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Purpose:%@NL@%
%@AB@%*       WndProc callback function to handle all messages for legend child.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Arguments:%@NL@%
%@AB@%*       hWnd          - Handle of Window owning message%@NL@%
%@AB@%*       message       - Message itself%@NL@%
%@AB@%*       mp1           - Extra message-dependent info%@NL@%
%@AB@%*       mp2           - Extra message-dependent info%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (referenced):%@NL@%
%@AB@%*       hwndApp       - Window handle of parent window's client area%@NL@%
%@AB@%*       tmFontInfo    - Text Metric structure defined during WM_CREATE %@NL@%
%@AB@%*       Color[]       - Set of colored pens used to identify cycles.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Description:%@NL@%
%@AB@%*       Display legend information relating graph line styles to each%@NL@%
%@AB@%*       cyle: physical, emotional and intellectual.  Notifies parent%@NL@%
%@AB@%*       to hide child if child window is instructed to close by user.%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AB@%/* Read-only global variables */%@AE@%%@NL@%
extern HWND     hwndApp;%@NL@%
%@NL@%
MRESULT CALLBACK KidWndProc( hWnd, message, mp1, mp2 )%@NL@%
HWND    hWnd;%@NL@%
USHORT  message;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
    HPS         hPS;%@NL@%
    RECTL       rc;%@NL@%
    POINTL      ptl;%@NL@%
    int         i;%@NL@%
%@NL@%
    switch( message )%@NL@%
    {%@NL@%
    case WM_CHAR:%@NL@%
        %@AB@%/* Convert keyboard to scroll bar messages to support scrolling,%@NL@%
%@AB@%           paging, etc. with keyboard interface. */%@AE@%%@NL@%
        WinSendMsg( hwndApp, message, mp1, mp2 );%@NL@%
        break;%@NL@%
%@NL@%
        case WM_PAINT:%@NL@%
            hPS = WinBeginPaint( hWnd, NULL, NULL );%@NL@%
%@NL@%
            %@AB@%/* Erase client area */%@AE@%%@NL@%
            WinQueryWindowRect( hWnd, &rc );%@NL@%
            WinFillRect( hPS, &rc, CLR_PALEGRAY );%@NL@%
%@NL@%
            ptl.x = 0;%@NL@%
            ptl.y = tmFontInfo.lMaxDescender;%@NL@%
            GpiCharStringAt( hPS, &ptl, 8L, (PCH)"Physical" );%@NL@%
            ptl.y += tmFontInfo.lMaxBaselineExt;%@NL@%
            GpiCharStringAt( hPS, &ptl, 9L, (PCH)"Emotional" );%@NL@%
            ptl.y += tmFontInfo.lMaxBaselineExt;%@NL@%
            GpiCharStringAt( hPS, &ptl, 9L, (PCH)"Intellect" );%@NL@%
%@NL@%
            for (i=0; i<3; i++ ) {%@NL@%
                GpiSetColor( hPS, Color[i] );%@NL@%
                ptl.x = cxLegendField;%@NL@%
                ptl.y = i * tmFontInfo.lMaxBaselineExt +%@NL@%
                        tmFontInfo.lMaxBaselineExt/2;%@NL@%
                GpiMove( hPS, &ptl );%@NL@%
                ptl.x = rc.xRight - tmFontInfo.lAveCharWidth;%@NL@%
                GpiLine( hPS, &ptl );%@NL@%
            }%@NL@%
%@NL@%
            WinEndPaint( hPS );%@NL@%
            break;%@NL@%
%@NL@%
        case WM_BUTTON1UP:%@NL@%
            %@AB@%/* Quick way to make Legend window disappear using mouse. */%@AE@%%@NL@%
            WinPostMsg( hwndApp, WM_COMMAND, (MPARAM)MAKEULONG(IDM_LEGEND, 0), 0L );%@NL@%
            break;%@NL@%
%@NL@%
        case WM_TRANSLATEACCEL:%@NL@%
            %@AB@%/* Change window handle.  Child window's frame will block%@NL@%
%@AB@%               ALT handling, so bypass frame.  Return window handle%@NL@%
%@AB@%               of main window's client area.  Now the ALT key message%@NL@%
%@AB@%               handling will be passed on up the chain of windows to%@NL@%
%@AB@%               the main window's frame for proper ALT key message%@NL@%
%@AB@%               handling.  The main window's menu bar will highlight%@NL@%
%@AB@%               even if the child window has the focus. */%@AE@%%@NL@%
            return WinDefWindowProc( hwndApp, message, mp1, mp2 );%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return WinDefWindowProc( hWnd, message, mp1, mp2 );%@NL@%
            break;%@NL@%
    }%@NL@%
    return( 0L );%@NL@%
}%@NL@%
%@AB@%/*%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AB@%/*  FrameWndProc() - Subclass routine for frame.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Purpose:%@NL@%
%@AB@%*        Handle WM_QUERYTRACKINFO message so that a minimum horizontal and%@NL@%
%@AB@%*        vertical window size can be controlled.  This minimum size keeps%@NL@%
%@AB@%*        the tabulated data from overlapping and leaves at least 4 rows%@NL@%
%@AB@%*        of data visible.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Arguments:%@NL@%
%@AB@%*       hWnd          - Handle of Window owning message%@NL@%
%@AB@%*       message       - Message itself%@NL@%
%@AB@%*       mp1           - Extra message-dependent info%@NL@%
%@AB@%*       mp2           - Extra message-dependent info%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Globals (referenced):%@NL@%
%@AB@%*        OldFrameWndProc - Original Frame Window procedure.%@NL@%
%@AB@%*%@NL@%
%@AB@%*   Limits:%@NL@%
%@AB@%*       N/A%@NL@%
%@AB@%*%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
MRESULT CALLBACK FrameWndProc( hWnd, message, mp1, mp2 )%@NL@%
HWND    hWnd;%@NL@%
USHORT  message;%@NL@%
MPARAM  mp1;%@NL@%
MPARAM  mp2;%@NL@%
{%@NL@%
    switch( message )%@NL@%
    {%@NL@%
        case WM_QUERYTRACKINFO:%@NL@%
            (*OldFrameWndProc)( hWnd, message, mp1, mp2 );%@NL@%
            %@AB@%/* Limit vertical and horizontal minimum size.  Must take into%@NL@%
%@AB@%               account menu, title, border and font widths and heights for%@NL@%
%@AB@%               device independence. */%@AE@%%@NL@%
            ((PTRACKINFO)mp2)->ptlMinTrackSize.x = cxDateField * 2 + cxDateField/2;%@NL@%
            ((PTRACKINFO)mp2)->ptlMinTrackSize.y =%@NL@%
                tmFontInfo.lMaxBaselineExt * 5 +%@NL@%
                WinQuerySysValue( HWND_DESKTOP, SV_CYMENU ) +%@NL@%
                WinQuerySysValue( HWND_DESKTOP, SV_CYTITLEBAR ) +%@NL@%
                WinQuerySysValue( HWND_DESKTOP, SV_CYSIZEBORDER ) * 2 +%@NL@%
                WinQuerySysValue( HWND_DESKTOP, SV_CYBORDER ) * 2;%@NL@%
            return (MRESULT) TRUE;%@NL@%
            break;%@NL@%
%@NL@%
        default:%@NL@%
            return (*OldFrameWndProc)( hWnd, message, mp1, mp2 );%@NL@%
            break;%@NL@%
    }%@NL@%
    return( 0L );%@NL@%
}%@NL@%
%@NL@%
void BioGetDate(HWND hWnd) {%@NL@%
    int         year, month;%@NL@%
    double      day;%@NL@%
%@NL@%
    %@AB@%/* Read in birth date from OS2.INI.  Error value is 12-31-1899,%@NL@%
%@AB@%       which is out of range for valid entries. */%@AE@%%@NL@%
    year = WinQueryProfileInt( hAB, szAppName, "Year", 1899 );%@NL@%
    month = WinQueryProfileInt( hAB, szAppName, "Month", 12 );%@NL@%
    day = (double)WinQueryProfileInt( hAB, szAppName, "Day", 31 );%@NL@%
%@NL@%
    %@AB@%/* Compute date of birth in julian days */%@AE@%%@NL@%
    Born = julian( year, month, day );%@NL@%
%@NL@%
    %@AB@%/* Get time zone environment information */%@AE@%%@NL@%
    tzset();%@NL@%
    %@AB@%/*%@NL@%
%@AB@%            System clock starts 1-1-1970.  Get julian date then and how many%@NL@%
%@AB@%            days have elapsed since, so that number of days since birth date%@NL@%
%@AB@%            can be determined%@NL@%
%@AB@%    */%@AE@%%@NL@%
    SelectDay  = (long)(julian( 1970, 1, 1.0 ) +%@NL@%
       (double)((time(NULL) - timezone + (long)daylight*3600)/86400) -%@NL@%
       Born );%@NL@%
%@NL@%
    %@AB@%/* If no valid OS2.INI info then automatically bring up dialog box */%@AE@%%@NL@%
    if (year < 1900) {%@NL@%
       bBorn = FALSE;%@NL@%
       WinPostMsg( hWnd, WM_COMMAND, (MPARAM)MAKEULONG(IDM_DATES, 0), 0L );%@NL@%
    }%@NL@%
}%@NL@%
%@1@%%@AH@%Advanced OS/2 Sample Code%@EH@%%@AE@%
%@NL@%
%@NL@%
%@2@%%@AH@%ARGC.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH09\ARGC.ASM%@AE@%%@NL@%
%@NL@%
        title        ARGC -- Return Argument Count%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; ARGC.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Return count of command line arguments.  Treats blanks and%@AE@%%@NL@%
%@AB@%; tabs as whitespace.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm argc.asm;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    N/A%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Returns:        AX    = argument count (always >= 1)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Uses:         nothing (other registers preserved)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
tab     equ     09h             %@AB@%; ASCII tab%@AE@%%@NL@%
blank   equ     20h             %@AB@%; ASCII space character%@AE@%%@NL@%
%@NL@%
        extrn   DosGetEnv:far%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT%@NL@%
%@NL@%
        public  argc            %@AB@%; make ARGC available to Linker%@AE@%%@NL@%
%@NL@%
                                %@AB@%; local variables%@AE@%%@NL@%
envseg  equ     [bp-2]          %@AB@%; environment segment%@AE@%%@NL@%
cmdoffs equ     [bp-4]          %@AB@%; command line offset%@AE@%%@NL@%
%@NL@%
argc    proc    near%@NL@%
%@NL@%
        enter   4,0             %@AB@%; make room for local variables%@AE@%%@NL@%
%@NL@%
        push        es                %@AB@%; save original ES, BX, and CX%@AE@%%@NL@%
        push    bx%@NL@%
        push    cx%@NL@%
%@NL@%
        push    ss              %@AB@%; get selector for environment%@AE@%%@NL@%
        lea     ax,envseg       %@AB@%; and offset of command line%@AE@%%@NL@%
        push    ax%@NL@%
        push    ss%@NL@%
        lea     ax,cmdoffs%@NL@%
        push    ax%@NL@%
        call    DosGetEnv       %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; check operation status%@AE@%%@NL@%
        mov     ax,1            %@AB@%; force argc >= 1%@AE@%%@NL@%
        jnz     argc3           %@AB@%; inexplicable failure%@AE@%%@NL@%
%@NL@%
        mov     es,envseg       %@AB@%; set ES:BX = command line%@AE@%%@NL@%
        mov     bx,cmdoffs%@NL@%
%@NL@%
argc0:  inc     bx              %@AB@%; ignore useless first field%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        jne     argc0%@NL@%
%@NL@%
argc1:  mov     cx,-1           %@AB@%; set flag = outside argument%@AE@%%@NL@%
%@NL@%
argc2:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argc3           %@AB@%; exit if null byte%@AE@%%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argc1           %@AB@%; outside argument if ASCII blank%@AE@%%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        je      argc1           %@AB@%; outside argument if ASCII tab%@AE@%%@NL@%
%@NL@%
                                %@AB@%; otherwise not blank or tab,%@AE@%%@NL@%
        jcxz    argc2           %@AB@%; jump if already inside argument%@AE@%%@NL@%
%@NL@%
        inc     ax              %@AB@%; else found argument, count it%@AE@%%@NL@%
        not     cx              %@AB@%; set flag = inside argument%@AE@%%@NL@%
        jmp     argc2           %@AB@%; and look at next character%@AE@%%@NL@%
%@NL@%
argc3:  pop     cx              %@AB@%; restore original BX, CX, ES%@AE@%%@NL@%
        pop     bx%@NL@%
        pop     es%@NL@%
        leave                   %@AB@%; discard local variables%@AE@%%@NL@%
        ret                     %@AB@%; return AX = argument count%@AE@%%@NL@%
%@NL@%
argc    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ARGC.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH03\ARGC.ASM%@AE@%%@NL@%
%@NL@%
        title        ARGC -- Return Argument Count%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; ARGC.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Return count of command line arguments.  Treats blanks and%@AE@%%@NL@%
%@AB@%; tabs as whitespace.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm argc.asm;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    N/A%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Returns:        AX    = argument count (always >= 1)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Uses:         nothing (other registers preserved)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
tab     equ     09h             %@AB@%; ASCII tab%@AE@%%@NL@%
blank   equ     20h             %@AB@%; ASCII space character%@AE@%%@NL@%
%@NL@%
        extrn   DosGetEnv:far%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT%@NL@%
%@NL@%
        public  argc            %@AB@%; make ARGC available to Linker%@AE@%%@NL@%
%@NL@%
                                %@AB@%; local variables%@AE@%%@NL@%
envseg  equ     [bp-2]          %@AB@%; environment segment%@AE@%%@NL@%
cmdoffs equ     [bp-4]          %@AB@%; command line offset%@AE@%%@NL@%
%@NL@%
argc    proc    near%@NL@%
%@NL@%
        enter   4,0             %@AB@%; make room for local variables%@AE@%%@NL@%
%@NL@%
        push        es                %@AB@%; save original ES, BX, and CX%@AE@%%@NL@%
        push    bx%@NL@%
        push    cx%@NL@%
%@NL@%
        push    ss              %@AB@%; get selector for environment%@AE@%%@NL@%
        lea     ax,envseg       %@AB@%; and offset of command line%@AE@%%@NL@%
        push    ax%@NL@%
        push    ss%@NL@%
        lea     ax,cmdoffs%@NL@%
        push    ax%@NL@%
        call    DosGetEnv       %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; check operation status%@AE@%%@NL@%
        mov     ax,1            %@AB@%; force argc >= 1%@AE@%%@NL@%
        jnz     argc3           %@AB@%; inexplicable failure%@AE@%%@NL@%
%@NL@%
        mov     es,envseg       %@AB@%; set ES:BX = command line%@AE@%%@NL@%
        mov     bx,cmdoffs%@NL@%
%@NL@%
argc0:  inc     bx              %@AB@%; ignore useless first field%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        jne     argc0%@NL@%
%@NL@%
argc1:  mov     cx,-1           %@AB@%; set flag = outside argument%@AE@%%@NL@%
%@NL@%
argc2:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argc3           %@AB@%; exit if null byte%@AE@%%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argc1           %@AB@%; outside argument if ASCII blank%@AE@%%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        je      argc1           %@AB@%; outside argument if ASCII tab%@AE@%%@NL@%
%@NL@%
                                %@AB@%; otherwise not blank or tab,%@AE@%%@NL@%
        jcxz    argc2           %@AB@%; jump if already inside argument%@AE@%%@NL@%
%@NL@%
        inc     ax              %@AB@%; else found argument, count it%@AE@%%@NL@%
        not     cx              %@AB@%; set flag = inside argument%@AE@%%@NL@%
        jmp     argc2           %@AB@%; and look at next character%@AE@%%@NL@%
%@NL@%
argc3:  pop     cx              %@AB@%; restore original BX, CX, ES%@AE@%%@NL@%
        pop     bx%@NL@%
        pop     es%@NL@%
        leave                   %@AB@%; discard local variables%@AE@%%@NL@%
        ret                     %@AB@%; return AX = argument count%@AE@%%@NL@%
%@NL@%
argc    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ARGC.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH08\ARGC.ASM%@AE@%%@NL@%
%@NL@%
        title        ARGC -- Return Argument Count%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; ARGC.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Return count of command line arguments.  Treats blanks and%@AE@%%@NL@%
%@AB@%; tabs as whitespace.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm argc.asm;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    N/A%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Returns:        AX    = argument count (always >= 1)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Uses:         nothing (other registers preserved)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
tab     equ     09h             %@AB@%; ASCII tab%@AE@%%@NL@%
blank   equ     20h             %@AB@%; ASCII space character%@AE@%%@NL@%
%@NL@%
        extrn   DosGetEnv:far%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT%@NL@%
%@NL@%
        public  argc            %@AB@%; make ARGC available to Linker%@AE@%%@NL@%
%@NL@%
                                %@AB@%; local variables%@AE@%%@NL@%
envseg  equ     [bp-2]          %@AB@%; environment segment%@AE@%%@NL@%
cmdoffs equ     [bp-4]          %@AB@%; command line offset%@AE@%%@NL@%
%@NL@%
argc    proc    near%@NL@%
%@NL@%
        enter   4,0             %@AB@%; make room for local variables%@AE@%%@NL@%
%@NL@%
        push        es                %@AB@%; save original ES, BX, and CX%@AE@%%@NL@%
        push    bx%@NL@%
        push    cx%@NL@%
%@NL@%
        push    ss              %@AB@%; get selector for environment%@AE@%%@NL@%
        lea     ax,envseg       %@AB@%; and offset of command line%@AE@%%@NL@%
        push    ax%@NL@%
        push    ss%@NL@%
        lea     ax,cmdoffs%@NL@%
        push    ax%@NL@%
        call    DosGetEnv       %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; check operation status%@AE@%%@NL@%
        mov     ax,1            %@AB@%; force argc >= 1%@AE@%%@NL@%
        jnz     argc3           %@AB@%; inexplicable failure%@AE@%%@NL@%
%@NL@%
        mov     es,envseg       %@AB@%; set ES:BX = command line%@AE@%%@NL@%
        mov     bx,cmdoffs%@NL@%
%@NL@%
argc0:  inc     bx              %@AB@%; ignore useless first field%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        jne     argc0%@NL@%
%@NL@%
argc1:  mov     cx,-1           %@AB@%; set flag = outside argument%@AE@%%@NL@%
%@NL@%
argc2:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argc3           %@AB@%; exit if null byte%@AE@%%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argc1           %@AB@%; outside argument if ASCII blank%@AE@%%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        je      argc1           %@AB@%; outside argument if ASCII tab%@AE@%%@NL@%
%@NL@%
                                %@AB@%; otherwise not blank or tab,%@AE@%%@NL@%
        jcxz    argc2           %@AB@%; jump if already inside argument%@AE@%%@NL@%
%@NL@%
        inc     ax              %@AB@%; else found argument, count it%@AE@%%@NL@%
        not     cx              %@AB@%; set flag = inside argument%@AE@%%@NL@%
        jmp     argc2           %@AB@%; and look at next character%@AE@%%@NL@%
%@NL@%
argc3:  pop     cx              %@AB@%; restore original BX, CX, ES%@AE@%%@NL@%
        pop     bx%@NL@%
        pop     es%@NL@%
        leave                   %@AB@%; discard local variables%@AE@%%@NL@%
        ret                     %@AB@%; return AX = argument count%@AE@%%@NL@%
%@NL@%
argc    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ARGV.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH08\ARGV.ASM%@AE@%%@NL@%
%@NL@%
        title        ARGV -- Return Argument Pointer%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; ARGV.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Return address and length of specified command line argument%@AE@%%@NL@%
%@AB@%; or fully qualified program name.  Treats blanks and tabs as%@AE@%%@NL@%
%@AB@%; whitespace.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm argv.asm;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    AX    = argument number (0 based)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Returns:      ES:BX = argument address%@AE@%%@NL@%
%@AB@%;                AX    = argument length (0 = no argument)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Uses:         nothing (other registers preserved)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Note:  If called with AX=0 (argv[0]), returns ES:BX%@AE@%%@NL@%
%@AB@%; pointing to fully qualified program name in environment%@AE@%%@NL@%
%@AB@%; block and AX=length.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
tab     equ     09h             %@AB@%; ASCII tab%@AE@%%@NL@%
blank   equ     20h             %@AB@%; ASCII space character%@AE@%%@NL@%
%@NL@%
        extrn   DosGetEnv:far%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT%@NL@%
%@NL@%
        public  argv            %@AB@%; make ARGV available to Linker%@AE@%%@NL@%
%@NL@%
                                %@AB@%; local variables...%@AE@%%@NL@%
envseg  equ     [bp-2]          %@AB@%; environment segment%@AE@%%@NL@%
cmdoffs equ     [bp-4]          %@AB@%; command line offset%@AE@%%@NL@%
%@NL@%
argv    proc    near%@NL@%
%@NL@%
        enter   4,0             %@AB@%; make room for local variables%@AE@%%@NL@%
        push    cx              %@AB@%; save original CX and DI%@AE@%%@NL@%
        push    di%@NL@%
%@NL@%
        push    ax              %@AB@%; save argument number%@AE@%%@NL@%
%@NL@%
        push    ss              %@AB@%; get selector for environment%@AE@%%@NL@%
        lea     ax,envseg       %@AB@%; and offset of command line%@AE@%%@NL@%
        push    ax%@NL@%
        push    ss%@NL@%
        lea     ax,cmdoffs%@NL@%
        push    ax%@NL@%
        call    DosGetEnv       %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; test operation status%@AE@%%@NL@%
        pop     ax              %@AB@%; restore argument number%@AE@%%@NL@%
        jnz     argv7           %@AB@%; jump if DosGetEnv failed%@AE@%%@NL@%
%@NL@%
        mov     es,envseg       %@AB@%; set ES:BX = command line%@AE@%%@NL@%
        mov     bx,cmdoffs%@NL@%
%@NL@%
        or        ax,ax                %@AB@%; is requested argument = 0?%@AE@%%@NL@%
        jz      argv8           %@AB@%; yes, jump to get program name%@AE@%%@NL@%
%@NL@%
argv0:  inc     bx              %@AB@%; scan off first field%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        jne     argv0%@NL@%
%@NL@%
        xor     ah,ah           %@AB@%; initialize argument counter%@AE@%%@NL@%
%@NL@%
argv1:  mov     cx,-1           %@AB@%; set flag = outside argument%@AE@%%@NL@%
%@NL@%
argv2:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argv7           %@AB@%; exit if null byte%@AE@%%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argv1           %@AB@%; outside argument if ASCII blank%@AE@%%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        je      argv1           %@AB@%; outside argument if ASCII tab%@AE@%%@NL@%
%@NL@%
                                %@AB@%; if not blank or tab...%@AE@%%@NL@%
        jcxz    argv2           %@AB@%; jump if already inside argument%@AE@%%@NL@%
%@NL@%
        inc     ah              %@AB@%; else count arguments found%@AE@%%@NL@%
        cmp     ah,al           %@AB@%; is this the one we're looking for?%@AE@%%@NL@%
        je      argv4           %@AB@%; yes, go find its length%@AE@%%@NL@%
        not     cx              %@AB@%; no, set flag = inside argument%@AE@%%@NL@%
        jmp     argv2           %@AB@%; and look at next character%@AE@%%@NL@%
%@NL@%
argv4:                          %@AB@%; found desired argument, now%@AE@%%@NL@%
                                %@AB@%; determine its length...%@AE@%%@NL@%
        mov        ax,bx                %@AB@%; save parameterr starting address%@AE@%%@NL@%
%@NL@%
argv5:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argv6           %@AB@%; found end if null byte%@AE@%%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argv6           %@AB@%; found end if ASCII blank%@AE@%%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        jne     argv5           %@AB@%; found end if ASCII tab%@AE@%%@NL@%
%@NL@%
argv6:  xchg    bx,ax           %@AB@%; set ES:BX = argument address%@AE@%%@NL@%
        sub     ax,bx           %@AB@%; and AX = argument length%@AE@%%@NL@%
        jmp     argvx           %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
argv7:  xor     ax,ax           %@AB@%; set AX = 0, argument not found%@AE@%%@NL@%
        jmp     argvx           %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
argv8:                          %@AB@%; special handling for argv=0%@AE@%%@NL@%
        xor     di,di           %@AB@%; find the program name by%@AE@%%@NL@%
        xor     al,al           %@AB@%; first skipping over all the%@AE@%%@NL@%
        mov     cx,-1           %@AB@%; environment variables...%@AE@%%@NL@%
        cld%@NL@%
argv9:  repne scasb             %@AB@%; scan for double null (can't use%@AE@%%@NL@%
        scasb                        %@AB@%; SCASW since might be odd address)%@AE@%%@NL@%
        jne     argv9           %@AB@%; loop if it was a single null%@AE@%%@NL@%
        mov     bx,di           %@AB@%; save program name address%@AE@%%@NL@%
        mov     cx,-1           %@AB@%; now find its length...%@AE@%%@NL@%
        repne scasb             %@AB@%; scan for another null byte%@AE@%%@NL@%
        not     cx              %@AB@%; convert CX to length%@AE@%%@NL@%
        dec     cx%@NL@%
        mov     ax,cx           %@AB@%; return length in AX%@AE@%%@NL@%
%@NL@%
argvx:                          %@AB@%; common exit point%@AE@%%@NL@%
        pop     di              %@AB@%; restore original CX and DI%@AE@%%@NL@%
        pop     cx%@NL@%
        leave                   %@AB@%; discard stack frame%@AE@%%@NL@%
        ret                     %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
argv    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ARGV.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH09\ARGV.ASM%@AE@%%@NL@%
%@NL@%
        title        ARGV -- Return Argument Pointer%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; ARGV.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Return address and length of specified command line argument%@AE@%%@NL@%
%@AB@%; or fully qualified program name.  Treats blanks and tabs as%@AE@%%@NL@%
%@AB@%; whitespace.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm argv.asm;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    AX    = argument number (0 based)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Returns:      ES:BX = argument address%@AE@%%@NL@%
%@AB@%;                AX    = argument length (0 = no argument)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Uses:         nothing (other registers preserved)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Note:  If called with AX=0 (argv[0]), returns ES:BX%@AE@%%@NL@%
%@AB@%; pointing to fully qualified program name in environment%@AE@%%@NL@%
%@AB@%; block and AX=length.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
tab     equ     09h             %@AB@%; ASCII tab%@AE@%%@NL@%
blank   equ     20h             %@AB@%; ASCII space character%@AE@%%@NL@%
%@NL@%
        extrn   DosGetEnv:far%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT%@NL@%
%@NL@%
        public  argv            %@AB@%; make ARGV available to Linker%@AE@%%@NL@%
%@NL@%
                                %@AB@%; local variables...%@AE@%%@NL@%
envseg  equ     [bp-2]          %@AB@%; environment segment%@AE@%%@NL@%
cmdoffs equ     [bp-4]          %@AB@%; command line offset%@AE@%%@NL@%
%@NL@%
argv    proc    near%@NL@%
%@NL@%
        enter   4,0             %@AB@%; make room for local variables%@AE@%%@NL@%
        push    cx              %@AB@%; save original CX and DI%@AE@%%@NL@%
        push    di%@NL@%
%@NL@%
        push    ax              %@AB@%; save argument number%@AE@%%@NL@%
%@NL@%
        push    ss              %@AB@%; get selector for environment%@AE@%%@NL@%
        lea     ax,envseg       %@AB@%; and offset of command line%@AE@%%@NL@%
        push    ax%@NL@%
        push    ss%@NL@%
        lea     ax,cmdoffs%@NL@%
        push    ax%@NL@%
        call    DosGetEnv       %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; test operation status%@AE@%%@NL@%
        pop     ax              %@AB@%; restore argument number%@AE@%%@NL@%
        jnz     argv7           %@AB@%; jump if DosGetEnv failed%@AE@%%@NL@%
%@NL@%
        mov     es,envseg       %@AB@%; set ES:BX = command line%@AE@%%@NL@%
        mov     bx,cmdoffs%@NL@%
%@NL@%
        or        ax,ax                %@AB@%; is requested argument = 0?%@AE@%%@NL@%
        jz      argv8           %@AB@%; yes, jump to get program name%@AE@%%@NL@%
%@NL@%
argv0:  inc     bx              %@AB@%; scan off first field%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        jne     argv0%@NL@%
%@NL@%
        xor     ah,ah           %@AB@%; initialize argument counter%@AE@%%@NL@%
%@NL@%
argv1:  mov     cx,-1           %@AB@%; set flag = outside argument%@AE@%%@NL@%
%@NL@%
argv2:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argv7           %@AB@%; exit if null byte%@AE@%%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argv1           %@AB@%; outside argument if ASCII blank%@AE@%%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        je      argv1           %@AB@%; outside argument if ASCII tab%@AE@%%@NL@%
%@NL@%
                                %@AB@%; if not blank or tab...%@AE@%%@NL@%
        jcxz    argv2           %@AB@%; jump if already inside argument%@AE@%%@NL@%
%@NL@%
        inc     ah              %@AB@%; else count arguments found%@AE@%%@NL@%
        cmp     ah,al           %@AB@%; is this the one we're looking for?%@AE@%%@NL@%
        je      argv4           %@AB@%; yes, go find its length%@AE@%%@NL@%
        not     cx              %@AB@%; no, set flag = inside argument%@AE@%%@NL@%
        jmp     argv2           %@AB@%; and look at next character%@AE@%%@NL@%
%@NL@%
argv4:                          %@AB@%; found desired argument, now%@AE@%%@NL@%
                                %@AB@%; determine its length...%@AE@%%@NL@%
        mov        ax,bx                %@AB@%; save parameterr starting address%@AE@%%@NL@%
%@NL@%
argv5:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argv6           %@AB@%; found end if null byte%@AE@%%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argv6           %@AB@%; found end if ASCII blank%@AE@%%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        jne     argv5           %@AB@%; found end if ASCII tab%@AE@%%@NL@%
%@NL@%
argv6:  xchg    bx,ax           %@AB@%; set ES:BX = argument address%@AE@%%@NL@%
        sub     ax,bx           %@AB@%; and AX = argument length%@AE@%%@NL@%
        jmp     argvx           %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
argv7:  xor     ax,ax           %@AB@%; set AX = 0, argument not found%@AE@%%@NL@%
        jmp     argvx           %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
argv8:                          %@AB@%; special handling for argv=0%@AE@%%@NL@%
        xor     di,di           %@AB@%; find the program name by%@AE@%%@NL@%
        xor     al,al           %@AB@%; first skipping over all the%@AE@%%@NL@%
        mov     cx,-1           %@AB@%; environment variables...%@AE@%%@NL@%
        cld%@NL@%
argv9:  repne scasb             %@AB@%; scan for double null (can't use%@AE@%%@NL@%
        scasb                        %@AB@%; SCASW since might be odd address)%@AE@%%@NL@%
        jne     argv9           %@AB@%; loop if it was a single null%@AE@%%@NL@%
        mov     bx,di           %@AB@%; save program name address%@AE@%%@NL@%
        mov     cx,-1           %@AB@%; now find its length...%@AE@%%@NL@%
        repne scasb             %@AB@%; scan for another null byte%@AE@%%@NL@%
        not     cx              %@AB@%; convert CX to length%@AE@%%@NL@%
        dec     cx%@NL@%
        mov     ax,cx           %@AB@%; return length in AX%@AE@%%@NL@%
%@NL@%
argvx:                          %@AB@%; common exit point%@AE@%%@NL@%
        pop     di              %@AB@%; restore original CX and DI%@AE@%%@NL@%
        pop     cx%@NL@%
        leave                   %@AB@%; discard stack frame%@AE@%%@NL@%
        ret                     %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
argv    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ARGV.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH03\ARGV.ASM%@AE@%%@NL@%
%@NL@%
        title        ARGV -- Return Argument Pointer%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; ARGV.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Return address and length of specified command line argument%@AE@%%@NL@%
%@AB@%; or fully qualified program name.  Treats blanks and tabs as%@AE@%%@NL@%
%@AB@%; whitespace.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm argv.asm;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    AX    = argument number (0 based)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Returns:      ES:BX = argument address%@AE@%%@NL@%
%@AB@%;                AX    = argument length (0 = no argument)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Uses:         nothing (other registers preserved)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Note:  If called with AX=0 (argv[0]), returns ES:BX%@AE@%%@NL@%
%@AB@%; pointing to fully qualified program name in environment%@AE@%%@NL@%
%@AB@%; block and AX=length.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
tab     equ     09h             %@AB@%; ASCII tab%@AE@%%@NL@%
blank   equ     20h             %@AB@%; ASCII space character%@AE@%%@NL@%
%@NL@%
        extrn   DosGetEnv:far%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT%@NL@%
%@NL@%
        public  argv            %@AB@%; make ARGV available to Linker%@AE@%%@NL@%
%@NL@%
                                %@AB@%; local variables...%@AE@%%@NL@%
envseg  equ     [bp-2]          %@AB@%; environment segment%@AE@%%@NL@%
cmdoffs equ     [bp-4]          %@AB@%; command line offset%@AE@%%@NL@%
%@NL@%
argv    proc    near%@NL@%
%@NL@%
        enter   4,0             %@AB@%; make room for local variables%@AE@%%@NL@%
        push    cx              %@AB@%; save original CX and DI%@AE@%%@NL@%
        push    di%@NL@%
%@NL@%
        push    ax              %@AB@%; save argument number%@AE@%%@NL@%
%@NL@%
        push    ss              %@AB@%; get selector for environment%@AE@%%@NL@%
        lea     ax,envseg       %@AB@%; and offset of command line%@AE@%%@NL@%
        push    ax%@NL@%
        push    ss%@NL@%
        lea     ax,cmdoffs%@NL@%
        push    ax%@NL@%
        call    DosGetEnv       %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; test operation status%@AE@%%@NL@%
        pop     ax              %@AB@%; restore argument number%@AE@%%@NL@%
        jnz     argv7           %@AB@%; jump if DosGetEnv failed%@AE@%%@NL@%
%@NL@%
        mov     es,envseg       %@AB@%; set ES:BX = command line%@AE@%%@NL@%
        mov     bx,cmdoffs%@NL@%
%@NL@%
        or        ax,ax                %@AB@%; is requested argument = 0?%@AE@%%@NL@%
        jz      argv8           %@AB@%; yes, jump to get program name%@AE@%%@NL@%
%@NL@%
argv0:  inc     bx              %@AB@%; scan off first field%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        jne     argv0%@NL@%
%@NL@%
        xor     ah,ah           %@AB@%; initialize argument counter%@AE@%%@NL@%
%@NL@%
argv1:  mov     cx,-1           %@AB@%; set flag = outside argument%@AE@%%@NL@%
%@NL@%
argv2:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argv7           %@AB@%; exit if null byte%@AE@%%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argv1           %@AB@%; outside argument if ASCII blank%@AE@%%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        je      argv1           %@AB@%; outside argument if ASCII tab%@AE@%%@NL@%
%@NL@%
                                %@AB@%; if not blank or tab...%@AE@%%@NL@%
        jcxz    argv2           %@AB@%; jump if already inside argument%@AE@%%@NL@%
%@NL@%
        inc     ah              %@AB@%; else count arguments found%@AE@%%@NL@%
        cmp     ah,al           %@AB@%; is this the one we're looking for?%@AE@%%@NL@%
        je      argv4           %@AB@%; yes, go find its length%@AE@%%@NL@%
        not     cx              %@AB@%; no, set flag = inside argument%@AE@%%@NL@%
        jmp     argv2           %@AB@%; and look at next character%@AE@%%@NL@%
%@NL@%
argv4:                          %@AB@%; found desired argument, now%@AE@%%@NL@%
                                %@AB@%; determine its length...%@AE@%%@NL@%
        mov        ax,bx                %@AB@%; save parameterr starting address%@AE@%%@NL@%
%@NL@%
argv5:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argv6           %@AB@%; found end if null byte%@AE@%%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argv6           %@AB@%; found end if ASCII blank%@AE@%%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        jne     argv5           %@AB@%; found end if ASCII tab%@AE@%%@NL@%
%@NL@%
argv6:  xchg    bx,ax           %@AB@%; set ES:BX = argument address%@AE@%%@NL@%
        sub     ax,bx           %@AB@%; and AX = argument length%@AE@%%@NL@%
        jmp     argvx           %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
argv7:  xor     ax,ax           %@AB@%; set AX = 0, argument not found%@AE@%%@NL@%
        jmp     argvx           %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
argv8:                          %@AB@%; special handling for argv=0%@AE@%%@NL@%
        xor     di,di           %@AB@%; find the program name by%@AE@%%@NL@%
        xor     al,al           %@AB@%; first skipping over all the%@AE@%%@NL@%
        mov     cx,-1           %@AB@%; environment variables...%@AE@%%@NL@%
        cld%@NL@%
argv9:  repne scasb             %@AB@%; scan for double null (can't use%@AE@%%@NL@%
        scasb                        %@AB@%; SCASW since might be odd address)%@AE@%%@NL@%
        jne     argv9           %@AB@%; loop if it was a single null%@AE@%%@NL@%
        mov     bx,di           %@AB@%; save program name address%@AE@%%@NL@%
        mov     cx,-1           %@AB@%; now find its length...%@AE@%%@NL@%
        repne scasb             %@AB@%; scan for another null byte%@AE@%%@NL@%
        not     cx              %@AB@%; convert CX to length%@AE@%%@NL@%
        dec     cx%@NL@%
        mov     ax,cx           %@AB@%; return length in AX%@AE@%%@NL@%
%@NL@%
argvx:                          %@AB@%; common exit point%@AE@%%@NL@%
        pop     di              %@AB@%; restore original CX and DI%@AE@%%@NL@%
        pop     cx%@NL@%
        leave                   %@AB@%; discard stack frame%@AE@%%@NL@%
        ret                     %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
argv    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ASMHELP.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH19\ASMHELP.ASM%@AE@%%@NL@%
%@NL@%
        title        ASMHELP -- Sample MASM DLL%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; ASMHELP.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Source code for the MASM dynlink library ASMHELP.DLL.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm asmhelp.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link asmhelp,asmhelp.dll,,os2,asmhelp%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Exports two routines for use by MASM programs:%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; ARGC  Returns count of command line arguments.%@AE@%%@NL@%
%@AB@%;       Treats blanks and tabs as whitespace.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       Calling sequence:%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       push    seg argcnt      ; receives argument count%@AE@%%@NL@%
%@AB@%;       push    offset argcnt%@AE@%%@NL@%
%@AB@%;       call    ARGC%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; ARGV  Returns address and length of specified%@AE@%%@NL@%
%@AB@%;       command line argument.  If called for%@AE@%%@NL@%
%@AB@%;       argument 0, returns address and length%@AE@%%@NL@%
%@AB@%;        of fully qualified pathname of program.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       Calling sequence:%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       push    argno           ; argument number%@AE@%%@NL@%
%@AB@%;       push    seg argptr      ; receives argument address%@AE@%%@NL@%
%@AB@%;       push    offset argptr%@AE@%%@NL@%
%@AB@%;       push    seg arglen      ; receives argument length%@AE@%%@NL@%
%@AB@%;       push    offset arglen%@AE@%%@NL@%
%@AB@%;       call    ARGV%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
tab     equ     09h             %@AB@%; ASCII tab%@AE@%%@NL@%
blank   equ     20h             %@AB@%; ASCII space character%@AE@%%@NL@%
%@NL@%
        extrn   DosGetEnv:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
envseg  dw      ?               %@AB@%; environment selector%@AE@%%@NL@%
cmdoffs dw      ?               %@AB@%; command tail offset%@AE@%%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
                                %@AB@%; parameter for argc%@AE@%%@NL@%
argcnt  equ     [bp+6]          %@AB@%; receives argument count%@AE@%%@NL@%
%@NL@%
        public  argc%@NL@%
argc    proc    far             %@AB@%; count command line arguments%@AE@%%@NL@%
%@NL@%
        push    bp              %@AB@%; make arguments addressable%@AE@%%@NL@%
        mov     bp,sp%@NL@%
%@NL@%
        push    ds              %@AB@%; save registers%@AE@%%@NL@%
        push    es%@NL@%
        push    bx%@NL@%
        push    cx%@NL@%
%@NL@%
        mov     ax,seg DGROUP   %@AB@%; point to instance data%@AE@%%@NL@%
        mov     ds,ax%@NL@%
%@NL@%
        mov     es,envseg       %@AB@%; set ES:BX = command line%@AE@%%@NL@%
        mov     bx,cmdoffs%@NL@%
%@NL@%
        mov     ax,1            %@AB@%; initialize argument count%@AE@%%@NL@%
%@NL@%
argc0:  inc     bx              %@AB@%; ignore useless first field%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        jne     argc0%@NL@%
%@NL@%
argc1:  mov     cx,-1           %@AB@%; set flag = outside argument%@AE@%%@NL@%
%@NL@%
argc2:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argc3           %@AB@%; exit if null byte%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argc1           %@AB@%; outside argument if ASCII blank%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        je      argc1           %@AB@%; outside argument if ASCII tab%@AE@%%@NL@%
%@NL@%
                                %@AB@%; otherwise not blank or tab,%@AE@%%@NL@%
        jcxz    argc2           %@AB@%; jump if already inside argument%@AE@%%@NL@%
%@NL@%
        inc     ax              %@AB@%; else found argument, count it%@AE@%%@NL@%
        not     cx              %@AB@%; set flag = inside argument%@AE@%%@NL@%
        jmp     argc2           %@AB@%; and look at next character%@AE@%%@NL@%
%@NL@%
argc3:                          %@AB@%; store result into%@AE@%%@NL@%
                                %@AB@%; caller's variable...%@AE@%%@NL@%
%@NL@%
        les     bx,argcnt       %@AB@%; get address of variable%@AE@%%@NL@%
        mov     es:[bx],ax      %@AB@%; store argument count%@AE@%%@NL@%
%@NL@%
        pop     cx              %@AB@%; restore registers%@AE@%%@NL@%
        pop     bx%@NL@%
        pop     es%@NL@%
        pop     ds%@NL@%
        pop     bp%@NL@%
%@NL@%
        xor     ax,ax           %@AB@%; signal success%@AE@%%@NL@%
%@NL@%
        ret     4               %@AB@%; return to caller%@AE@%%@NL@%
                                %@AB@%; and discard parameters%@AE@%%@NL@%
argc    endp%@NL@%
%@NL@%
%@NL@%
%@NL@%
                                %@AB@%; parameters for argv...%@AE@%%@NL@%
argno   equ     [bp+14]         %@AB@%; argument number%@AE@%%@NL@%
argptr  equ     [bp+10]         %@AB@%; receives argument pointer%@AE@%%@NL@%
arglen  equ     [bp+6]          %@AB@%; receives argument length%@AE@%%@NL@%
%@NL@%
        public  argv%@NL@%
argv        proc        far                %@AB@%; get address and length of%@AE@%%@NL@%
                                %@AB@%; command tail argument%@AE@%%@NL@%
%@NL@%
        push    bp              %@AB@%; make arguments addressable%@AE@%%@NL@%
        mov     bp,sp%@NL@%
%@NL@%
        push    ds              %@AB@%; save registers%@AE@%%@NL@%
        push    es%@NL@%
        push    bx%@NL@%
        push    cx%@NL@%
        push    di%@NL@%
%@NL@%
        mov     ax,seg DGROUP   %@AB@%; point to instance data%@AE@%%@NL@%
        mov     ds,ax%@NL@%
%@NL@%
        mov     es,envseg       %@AB@%; set ES:BX = command line%@AE@%%@NL@%
        mov     bx,cmdoffs%@NL@%
%@NL@%
        mov     ax,argno        %@AB@%; get argument number%@AE@%%@NL@%
        or      ax,ax           %@AB@%; requesting argument 0?%@AE@%%@NL@%
        jz      argv8           %@AB@%; yes, get program name%@AE@%%@NL@%
%@NL@%
argv1:  inc     bx              %@AB@%; scan off first field%@AE@%%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        jne     argv1%@NL@%
%@NL@%
        xor     ah,ah           %@AB@%; initialize argument counter%@AE@%%@NL@%
%@NL@%
argv2:  mov     cx,-1           %@AB@%; set flag = outside argument%@AE@%%@NL@%
%@NL@%
argv3:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argv7           %@AB@%; exit if null byte%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argv2           %@AB@%; outside argument if ASCII blank%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        je      argv2           %@AB@%; outside argument if ASCII tab%@AE@%%@NL@%
%@NL@%
                                %@AB@%; if not blank or tab...%@AE@%%@NL@%
        jcxz    argv3           %@AB@%; jump if inside argument%@AE@%%@NL@%
%@NL@%
        inc     ah              %@AB@%; else count arguments found%@AE@%%@NL@%
        cmp     ah,al           %@AB@%; is this the one?%@AE@%%@NL@%
        je      argv4           %@AB@%; yes, go find its length%@AE@%%@NL@%
%@NL@%
        not     cx              %@AB@%; no, set flag = inside argument%@AE@%%@NL@%
        jmp     argv3           %@AB@%; and look at next character%@AE@%%@NL@%
%@NL@%
argv4:                          %@AB@%; found desired argument, now%@AE@%%@NL@%
                                %@AB@%; determine its length...%@AE@%%@NL@%
        mov     ax,bx           %@AB@%; save param. starting address%@AE@%%@NL@%
%@NL@%
argv5:  inc     bx              %@AB@%; point to next character%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr es:[bx],0%@NL@%
        je      argv6           %@AB@%; found end if null byte%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr es:[bx],blank%@NL@%
        je      argv6           %@AB@%; found end if ASCII blank%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr es:[bx],tab%@NL@%
        jne     argv5           %@AB@%; found end if ASCII tab%@AE@%%@NL@%
%@NL@%
argv6:  xchg    bx,ax           %@AB@%; set ES:BX = argument address%@AE@%%@NL@%
        sub     ax,bx           %@AB@%; and AX = argument length%@AE@%%@NL@%
        jmp     argv10          %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
argv7:  mov     ax,1            %@AB@%; set AX != 0 indicating%@AE@%%@NL@%
                                %@AB@%; error, argument not found%@AE@%%@NL@%
        jmp     argv11          %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
argv8:                                %@AB@%; special handling for argv = 0%@AE@%%@NL@%
        xor     di,di           %@AB@%; find the program name by%@AE@%%@NL@%
        xor     al,al           %@AB@%; first skipping over all the%@AE@%%@NL@%
        mov     cx,-1           %@AB@%; environment variables...%@AE@%%@NL@%
        cld%@NL@%
%@NL@%
argv9:        repne scasb                %@AB@%; scan for double null (can't use SCASW%@AE@%%@NL@%
        scasb                        %@AB@%; because it might be odd address)%@AE@%%@NL@%
        jne     argv9           %@AB@%; loop if it was a single null%@AE@%%@NL@%
%@NL@%
        mov     bx,di           %@AB@%; save program name address%@AE@%%@NL@%
        mov     cx,-1           %@AB@%; now find its length...%@AE@%%@NL@%
        repne scasb             %@AB@%; scan for another null byte%@AE@%%@NL@%
%@NL@%
        not     cx              %@AB@%; convert CX to length%@AE@%%@NL@%
        dec     cx%@NL@%
        mov     ax,cx           %@AB@%; return length in AX%@AE@%%@NL@%
%@NL@%
argv10:                         %@AB@%; at this point AX = length,%@AE@%%@NL@%
                                %@AB@%; ES:BX points to argument%@AE@%%@NL@%
%@NL@%
        lds     di,argptr       %@AB@%; address of 1st variable%@AE@%%@NL@%
        mov     ds:[di],bx      %@AB@%; store argument pointer%@AE@%%@NL@%
        mov     ds:[di+2],es%@NL@%
%@NL@%
        lds        di,arglen        %@AB@%; address of second variable%@AE@%%@NL@%
        mov     ds:[di],ax      %@AB@%; store argument length%@AE@%%@NL@%
%@NL@%
        xor        ax,ax                %@AB@%; AX = 0 to signal success%@AE@%%@NL@%
%@NL@%
argv11:                         %@AB@%; common exit point%@AE@%%@NL@%
%@NL@%
        pop     di              %@AB@%; restore registers%@AE@%%@NL@%
        pop     cx%@NL@%
        pop     bx%@NL@%
        pop     es%@NL@%
        pop     ds%@NL@%
        pop     bp%@NL@%
%@NL@%
        ret     10              %@AB@%; return to caller%@AE@%%@NL@%
                                %@AB@%; and discard parameters%@AE@%%@NL@%
argv    endp%@NL@%
%@NL@%
%@NL@%
init    proc    far             %@AB@%; DLL instance initialization%@AE@%%@NL@%
%@NL@%
                                %@AB@%; get environment selector%@AE@%%@NL@%
                                %@AB@%; and offset of command tail%@AE@%%@NL@%
                                %@AB@%; for this process...%@AE@%%@NL@%
%@NL@%
        push    seg DGROUP      %@AB@%; receives environment selector%@AE@%%@NL@%
        push    offset DGROUP:envseg%@NL@%
        push    seg DGROUP      %@AB@%; receives command tail offset%@AE@%%@NL@%
        push    offset DGROUP:cmdoffs%@NL@%
        call    DosGetEnv       %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; call successful?%@AE@%%@NL@%
        jnz     init1           %@AB@%; no, initialization error%@AE@%%@NL@%
%@NL@%
        mov     ax,1            %@AB@%; initialization OK,%@AE@%%@NL@%
        ret                     %@AB@%; return AX = 1 for success%@AE@%%@NL@%
%@NL@%
init1:  xor     ax,ax           %@AB@%; initialization failed,%@AE@%%@NL@%
        ret                     %@AB@%; return AX = 0 for error%@AE@%%@NL@%
%@NL@%
init    endp%@NL@%
%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     init            %@AB@%; initialization entry point%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BEEPER.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH12\BEEPER.ASM%@AE@%%@NL@%
%@NL@%
        title   BEEPER -- simple multithreaded application%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%; BEEPER.ASM  --- A simple multithreaded application which%@AE@%%@NL@%
%@AB@%;                 creates a second thread to issue beeps%@AE@%%@NL@%
%@AB@%;                 at one-second intervals, while the first%@AE@%%@NL@%
%@AB@%;                 thread waits for a any keypress.%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM BEEPER;%@AE@%%@NL@%
%@AB@%;               LINK BEEPER,,,OS2,BEEPER;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        BEEPER%@AE@%%@NL@%
%@NL@%
stdin   equ     0                       %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1                       %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII line feed%@AE@%%@NL@%
%@NL@%
stksiz  equ     4096                    %@AB@%; stack size for 2nd thread%@AE@%%@NL@%
%@NL@%
        extrn   DosAllocSeg:far         %@AB@%; references to OS/2 API%@AE@%%@NL@%
        extrn   DosBeep:far%@NL@%
        extrn   DosCreateThread:far%@NL@%
        extrn   DosExecPgm:far%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosSleep:far%@NL@%
        extrn   DosWrite:far%@NL@%
        extrn   KbdCharIn:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
cdata   db      10 dup (0)              %@AB@%; receives character data%@AE@%%@NL@%
wlen    dw      ?                       %@AB@%; receives bytes written%@AE@%%@NL@%
selector dw     ?                       %@AB@%; receives segment selector%@AE@%%@NL@%
beepID  dw      ?                       %@AB@%; receives thread ID%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf%@NL@%
        db      'Press any key to end program...'%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf%@NL@%
        db      'Unexpected OS/2 Error'%@NL@%
        db      cr,lf%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far                     %@AB@%; entry point for primary thread%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; allocate stack for 2nd thread...%@AE@%%@NL@%
        push    stksiz                  %@AB@%; size of new segment%@AE@%%@NL@%
        push    ds                      %@AB@%; receives selector%@AE@%%@NL@%
        push    offset DGROUP:selector%@NL@%
        push    0                       %@AB@%; 0=not sharable%@AE@%%@NL@%
        call    DosAllocSeg             %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; allocation successful?%@AE@%%@NL@%
        jnz     error                   %@AB@%; jump if failed%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; start new beeper thread...%@AE@%%@NL@%
        push    cs                      %@AB@%; thread entry point%@AE@%%@NL@%
        push    offset _TEXT:Beeper%@NL@%
        push    ds                      %@AB@%; receives Thread ID%@AE@%%@NL@%
        push    offset DGROUP:beepID%@NL@%
        push    selector                %@AB@%; stack for new thread%@AE@%%@NL@%
        push    stksiz%@NL@%
        call    DosCreateThread         %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; new thread created?%@AE@%%@NL@%
        jnz     error                   %@AB@%; jump if failed%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display message,%@AE@%%@NL@%
                                        %@AB@%; 'Press any key to end program'...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of message%@AE@%%@NL@%
        push    offset msg1%@NL@%
        push    msg1_len                %@AB@%; length of message%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; now wait for key...%@AE@%%@NL@%
        push    ds                      %@AB@%; receives data packet%@AE@%%@NL@%
        push    offset DGROUP:cdata%@NL@%
        push    0                       %@AB@%; 0=wait for char.%@AE@%%@NL@%
        push    0                       %@AB@%; keyboard handle%@AE@%%@NL@%
        call    KbdCharIn               %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; final exit to OS/2...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0                       %@AB@%; exit code=0 (success)%@AE@%%@NL@%
        call    DosExit                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
error:                                  %@AB@%; display error message...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset msg1%@NL@%
        push    msg1_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1                       %@AB@%; return error code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
%@NL@%
beeper  proc    far                     %@AB@%; thread entry point%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; sound a tone...%@AE@%%@NL@%
        push    440                     %@AB@%; 440 Hz%@AE@%%@NL@%
        push    100                     %@AB@%; 100 milliseconds%@AE@%%@NL@%
        call    DosBeep                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    0                       %@AB@%; now suspend thread%@AE@%%@NL@%
        push    1000                    %@AB@%; for 1 second...%@AE@%%@NL@%
        call    DosSleep                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp     beeper                  %@AB@%; do it again...%@AE@%%@NL@%
%@NL@%
beeper  endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CDLL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH19\CDLL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%        CDLL.C%@NL@%
%@AB@%%@NL@%
%@AB@%        C source code for the dynlink library CDLL.LIB.  Requires%@NL@%
%@AB@%        the module CINIT.ASM.%@NL@%
%@AB@%%@NL@%
%@AB@%        Compile with:  C> cl /c /Asnu /Gs cdll.c%@NL@%
%@AB@%        Assemble CINIT.ASM with:  C> masm /Mx cinit.asm;%@NL@%
%@AB@%        Link with:  C> link /NOI /NOD cdll+cinit,cdll.dll,,os2,cdll%@NL@%
%@AB@%        Create CDLL.LIB with:  C> implib cdll.lib cdll.def%@NL@%
%@AB@%%@NL@%
%@AB@%        Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
int _acrtused = 0;            %@AB@%/* don't link startup */%@AE@%%@NL@%
%@NL@%
STDOUT 1            %@AB@%/* standard output handle */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%API unsigned extern far pascal  %@NL@%
%@NL@%
API DosWrite(unsigned, void far *, unsigned, unsigned far *);%@NL@%
%@NL@%
static char funcmsg[] = "\nCDLL.MYFUNC is executing\n";%@NL@%
static char initmsg[] = "\nCDLL.C_INIT is executing\n";%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    MYFUNC is exported for use by appliation programs;%@NL@%
%@AB@%    it displays a message and returns the sum of 2 numbers.%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
int far pascal MYFUNC(int a, int b)%@NL@%
{%@NL@%
    unsigned wlen;          %@AB@%/* receives length written */%@AE@%%@NL@%
%@NL@%
                            %@AB@%/* display message that%@NL@%
%@AB@%                               MYFUNC is executing */%@AE@%%@NL@%
    DosWrite(STDOUT,funcmsg,sizeof(funcmsg)-1,&wlen);%@NL@%
    %@NL@%
    return(a+b);            %@AB@%/* return function result */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    C_INIT is called from the entry point in CINIT.ASM when%@NL@%
%@AB@%    a client process dynamically links to the library.%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
int far pascal C_INIT(void)%@NL@%
{%@NL@%
    unsigned wlen;          %@AB@%/* receives length written */%@AE@%%@NL@%
%@NL@%
                            %@AB@%/* display message that%@NL@%
%@AB@%                               C_INIT is executing */%@AE@%%@NL@%
    DosWrite(STDOUT,initmsg,sizeof(initmsg)-1,&wlen);%@NL@%
%@NL@%
    return(1);              %@AB@%/* return success code */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CINIT.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH19\CINIT.ASM%@AE@%%@NL@%
%@NL@%
        extrn   C_INIT:far%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT%@NL@%
%@NL@%
%@NL@%
INIT    proc    far             %@AB@%; initialization routine%@AE@%%@NL@%
%@NL@%
        call    C_INIT          %@AB@%; call C routine to%@AE@%%@NL@%
                                %@AB@%; do the actual work%@AE@%%@NL@%
%@NL@%
        ret                     %@AB@%; back to caller with%@AE@%%@NL@%
                                %@AB@%; AX = status code%@AE@%%@NL@%
                                %@AB@%; ("value" from C_INIT)%@AE@%%@NL@%
INIT    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     INIT%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CLEAN.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH16\CLEAN.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    CLEAN.C     Filter to turn document files into %@NL@%
%@AB@%                normal text files.%@NL@%
%@AB@%%@NL@%
%@AB@%    Copyright 1988 Ray Duncan%@NL@%
%@AB@%%@NL@%
%@AB@%    Compile:    C>CL CLEAN.C%@NL@%
%@AB@%%@NL@%
%@AB@%    Usage:      C>CLEAN  <infile >outfile%@NL@%
%@AB@%%@NL@%
%@AB@%    All text characters are passed through with high bit stripped%@NL@%
%@AB@%    off.  Form feeds, carriage returns, and line feeds are passed%@NL@%
%@AB@%    through.  Tabs are expanded to spaces.  All other control codes%@NL@%
%@AB@%    are discarded.%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
TAB_WIDTH   8               %@AB@%/* width of a tab stop */%@AE@%%@NL@%
%@NL@%
TAB     '\x09'              %@AB@%/* ASCII tab character */%@AE@%%@NL@%
LF      '\x0A'              %@AB@%/* ASCII line feed */%@AE@%%@NL@%
FF      '\x0C'              %@AB@%/* ASCII form feed */%@AE@%%@NL@%
CR      '\x0D'              %@AB@%/* ASCII carriage return */%@AE@%%@NL@%
BLANK   '\x20'              %@AB@%/* ASCII space code */%@AE@%%@NL@%
EOFMK   '\x1A'              %@AB@%/* Ctrl-Z end of file */%@AE@%%@NL@%
%@NL@%
%@NL@%
main(int argc, char *argv[])%@NL@%
{   %@NL@%
    char c;                         %@AB@%/* char. from stdin */%@AE@%%@NL@%
    int col = 0;                    %@AB@%/* column counter */%@AE@%%@NL@%
%@NL@%
    while((c = getchar()) != EOF)   %@AB@%/* read input character */%@AE@%%@NL@%
    {   %@NL@%
        c &= 0x07F;                 %@AB@%/* strip high bit */%@AE@%%@NL@%
%@NL@%
        switch(c)                   %@AB@%/* decode character */%@AE@%%@NL@%
        {   %@NL@%
            case LF:                %@AB@%/* if line feed or */%@AE@%%@NL@%
            case CR:                %@AB@%/* carriage return, */%@AE@%%@NL@%
                col=0;              %@AB@%/* reset column count */%@AE@%%@NL@%
%@NL@%
            case FF:                %@AB@%/* if form feed, carriage */%@AE@%%@NL@%
                wchar(c);           %@AB@%/* return, or line feed */%@AE@%%@NL@%
                break;              %@AB@%/* pass character through */%@AE@%%@NL@%
%@NL@%
            case TAB:               %@AB@%/* if tab expand to spaces */%@AE@%%@NL@%
                do wchar(BLANK);%@NL@%
                while((++col % TAB_WIDTH) != 0);%@NL@%
                break;%@NL@%
%@NL@%
            default:                %@AB@%/* discard other control */%@AE@%%@NL@%
                if(c >= BLANK)      %@AB@%/* characters, pass text */%@AE@%%@NL@%
                {                   %@AB@%/* characters through */%@AE@%%@NL@%
                    wchar(c);%@NL@%
                    col++;          %@AB@%/* bump column counter */%@AE@%%@NL@%
                }%@NL@%
                break;%@NL@%
        }%@NL@%
    }%@NL@%
    wchar(EOFMK);                   %@AB@%/* write end-of-file mark */%@AE@%%@NL@%
    exit(0);                    %@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Write a character to the standard output.  If%@NL@%
%@AB@%    write fails, display error message and terminate.%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
wchar(char c)%@NL@%
{   %@NL@%
    if((putchar(c) == EOF) && (c != EOFMK))%@NL@%
    {   %@NL@%
        fputs("clean: disk full",stderr);%@NL@%
        exit(1);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CLOCK.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH15\CLOCK.ASM%@AE@%%@NL@%
%@NL@%
        title   CLOCK - asynchronous periodic timer example%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; CLOCK.ASM --- Example of an asynchronous periodic%@AE@%%@NL@%
%@AB@%; timer.  Displays the current time at one-second%@AE@%%@NL@%
%@AB@%; intervals in the upper-right corner of the screen.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM CLOCK;%@AE@%%@NL@%
%@AB@%;               LINK CLOCK,,,OS2,CLOCK%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        CLOCK%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Terminate program with Ctrl-C or Ctrl-Break%@AE@%%@NL@%
%@NL@%
stdin   equ     0%@NL@%
stdout  equ     1%@NL@%
stderr  equ     2%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII line feed%@AE@%%@NL@%
escape  equ     01bh                    %@AB@%; ASCII escape code%@AE@%%@NL@%
%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosCreateSem:far%@NL@%
        extrn   DosGetInfoSeg:far%@NL@%
        extrn   DosSemWait:far%@NL@%
        extrn   DosSemSet:far%@NL@%
        extrn   DosTimerStart:far%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
jerr    macro   target                  %@AB@%;; Macro to test return code%@AE@%%@NL@%
        local   zero                    %@AB@%;; in AX and jump if non-zero%@AE@%%@NL@%
        or      ax,ax                   %@AB@%;; Uses JMP16 to avoid%@AE@%%@NL@%
        jz      zero                    %@AB@%;; branch out of range errors%@AE@%%@NL@%
        jmp     target%@NL@%
zero:%@NL@%
        endm%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
sname   db      '\SEM\CLOCK.SEM',0      %@AB@%; name of semaphore%@AE@%%@NL@%
shandle dd      ?                       %@AB@%; handle of semaphore%@AE@%%@NL@%
semflag dw      0                       %@AB@%; <>0 if creator of semaphore%@AE@%%@NL@%
%@NL@%
thandle dw      ?                       %@AB@%; handle of periodic timer%@AE@%%@NL@%
%@NL@%
wlen    dw      ?                       %@AB@%; receives actual length written%@AE@%%@NL@%
%@NL@%
ten     db      10                      %@AB@%; used by b2a conversion routine%@AE@%%@NL@%
%@NL@%
ginfseg dw      ?                       %@AB@%; global information segment%@AE@%%@NL@%
linfseg dw      ?                       %@AB@%; local information segment%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf,'Unexpected OS/2 Error',cr,lf%@NL@%
msg1_length equ $-msg1%@NL@%
%@NL@%
msg2    db      escape,'[s'             %@AB@%; save cursor position%@AE@%%@NL@%
        db      escape,'[0%@AB@%;70H'         ; move to 0,70%@AE@%%@NL@%
msg2a   db      '00:'                   %@AB@%; hours%@AE@%%@NL@%
msg2b   db      '00:'                   %@AB@%; minutes%@AE@%%@NL@%
msg2c   db      '00'                    %@AB@%; seconds%@AE@%%@NL@%
        db      escape,'[u'             %@AB@%; restore cursor position%@AE@%%@NL@%
msg2_length equ $-msg2%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far%@NL@%
%@NL@%
                                        %@AB@%; get selectors for info segments%@AE@%%@NL@%
        push    ds                      %@AB@%; receives global selector%@AE@%%@NL@%
        push    offset DGROUP:ginfseg%@NL@%
        push    ds                      %@AB@%; receives local selector%@AE@%%@NL@%
        push    offset DGROUP:linfseg%@NL@%
        call    DosGetInfoSeg           %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main2                   %@AB@%; jump if couldn't get selectors%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; create system semaphore...%@AE@%%@NL@%
        push    1                       %@AB@%; exclusive ownership not needed%@AE@%%@NL@%
        push    ds                      %@AB@%; variable to receive semaphore handle%@AE@%%@NL@%
        push    offset DGROUP:shandle%@NL@%
        push    ds                      %@AB@%; address of semaphore name%@AE@%%@NL@%
        push    offset DGROUP:sname%@NL@%
        call    DosCreateSem            %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main2                   %@AB@%; jump if sem already exists%@AE@%%@NL@%
%@NL@%
        push    0                       %@AB@%; now create periodic timer...%@AE@%%@NL@%
        push    1000                    %@AB@%; double word for 1000 msec.%@AE@%%@NL@%
        push    word ptr shandle+2      %@AB@%; handle of our system semaphore%@AE@%%@NL@%
        push    word ptr shandle%@NL@%
        push    ds                      %@AB@%; variable to receive timer handle%@AE@%%@NL@%
        push    offset DGROUP:thandle%@NL@%
        call    DosTimerStart           %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main2                   %@AB@%; jump if timer create failed%@AE@%%@NL@%
%@NL@%
main1:                                  %@AB@%; display time at 1-sec intervals%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; first set our semaphore...%@AE@%%@NL@%
        push    word ptr shandle+2      %@AB@%; system semaphore handle%@AE@%%@NL@%
        push    word ptr shandle%@NL@%
        call    DosSemSet               %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main2                   %@AB@%; terminate if set failed%@AE@%%@NL@%
%@NL@%
        call    display                 %@AB@%; display current time%@AE@%%@NL@%
%@NL@%
        push    word ptr shandle+2      %@AB@%; wait for 1 second timer%@AE@%%@NL@%
        push    word ptr shandle        %@AB@%; to be triggered%@AE@%%@NL@%
        push    -1                      %@AB@%; timeout = -1 = wait indefinitely%@AE@%%@NL@%
        push    -1%@NL@%
        call    DosSemWait              %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; did wait fail?%@AE@%%@NL@%
        jz      main1                   %@AB@%; no, loop to display again%@AE@%%@NL@%
%@NL@%
main2:                                  %@AB@%; display error message...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset msg1%@NL@%
        push    msg1_length             %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives actual length written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1                       %@AB@%; return error code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; final exit to OS/2%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
%@NL@%
display proc    near                    %@AB@%; display current time%@AE@%%@NL@%
%@NL@%
        mov     es,ginfseg              %@AB@%; get selector for global%@AE@%%@NL@%
                                        %@AB@%; read-only information segment%@AE@%%@NL@%
%@NL@%
        mov     al,byte ptr es:[8]      %@AB@%; convert hours to ASCII%@AE@%%@NL@%
        cbw%@NL@%
        div     ten%@NL@%
        add     ax,'00'%@NL@%
        mov     word ptr msg2a,ax%@NL@%
%@NL@%
        mov     al,byte ptr es:[9]      %@AB@%; convert minutes to ASCII%@AE@%%@NL@%
        cbw%@NL@%
        div     ten%@NL@%
        add     ax,'00'%@NL@%
        mov     word ptr msg2b,ax%@NL@%
%@NL@%
        mov     al,byte ptr es:[0ah]    %@AB@%; convert seconds to ASCII%@AE@%%@NL@%
        cbw%@NL@%
        div     ten%@NL@%
        add     ax,'00'%@NL@%
        mov     word ptr msg2c,ax%@NL@%
%@NL@%
                                        %@AB@%; display time...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of message%@AE@%%@NL@%
        push    offset msg2%@NL@%
        push    msg2_length             %@AB@%; length of message%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
display endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DASD.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH10\DASD.ASM%@AE@%%@NL@%
%@NL@%
        title   DASD --- direct disk access demo%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%; DASD.EXE  --- Demonstrates direct disk access under OS/2.%@AE@%%@NL@%
%@AB@%;               Reads the boot sector for the current drive%@AE@%%@NL@%
%@AB@%;               into a buffer, then writes it into a file%@AE@%%@NL@%
%@AB@%;               named \BOOT.BIN on the same drive.%@AE@%%@NL@%
%@AB@%;               The lock operation will fail if any files%@AE@%%@NL@%
%@AB@%;               are open on the current drive (you can't%@AE@%%@NL@%
%@AB@%;               use it on the boot drive, for example).%@AE@%%@NL@%
%@AB@%; Copyright (C) Ray Duncan October 1988%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM DASD;%@AE@%%@NL@%
%@AB@%;               LINK DASD,,,OS2,DASD;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        DASD%@AE@%%@NL@%
%@NL@%
stdin   equ     0                       %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1                       %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII line feed%@AE@%%@NL@%
%@NL@%
secsize equ     512                     %@AB@%; physical sector size%@AE@%%@NL@%
%@NL@%
        extrn   DosChgFilePtr:far       %@AB@%; references to OS/2 API%@AE@%%@NL@%
        extrn   DosClose:far%@NL@%
        extrn   DosDevIOCtl:far%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosOpen:far%@NL@%
        extrn   DosQCurDisk:far%@NL@%
        extrn   DosRead:far%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
dname   db      'X:',0                  %@AB@%; logical drive identifier%@AE@%%@NL@%
dhandle dw      ?                       %@AB@%; receives drive handle%@AE@%%@NL@%
daction dw      ?                       %@AB@%; receives DosOpen action%@AE@%%@NL@%
%@NL@%
drive   dw      0                       %@AB@%; receives drive ID%@AE@%%@NL@%
drvmap  dd      0                       %@AB@%; receives drive bitmap%@AE@%%@NL@%
%@NL@%
fname   db      '\BOOT.BIN',0           %@AB@%; file to receive boot sector%@AE@%%@NL@%
rlen    dw      ?                       %@AB@%; actual bytes read%@AE@%%@NL@%
wlen    dw      ?                       %@AB@%; actual bytes written%@AE@%%@NL@%
%@NL@%
bootsec db      secsize dup (?)         %@AB@%; boot sector read here%@AE@%%@NL@%
%@NL@%
parblk  db      0                       %@AB@%; DosDevIOCtl dummy parameter%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf%@NL@%
        db      'DosQCurDisk failed.'%@NL@%
        db      cr,lf%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf%@NL@%
        db      'Can''t open drive '%@NL@%
msg2a   db      'X:'%@NL@%
        db      cr,lf%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
msg3    db      cr,lf%@NL@%
        db      'Can''t lock drive '%@NL@%
msg3a   db      'X:'%@NL@%
        db      cr,lf%@NL@%
msg3_len equ $-msg3%@NL@%
%@NL@%
msg4    db      cr,lf%@NL@%
        db      'Read of boot sector failed.'%@NL@%
        db      cr,lf%@NL@%
msg4_len equ $-msg4%@NL@%
%@NL@%
msg5    db      cr,lf%@NL@%
        db      'Can''t create file BOOT.BIN'%@NL@%
        db      cr,lf%@NL@%
msg5_len equ $-msg5%@NL@%
%@NL@%
msg6    db      cr,lf%@NL@%
        db      'Can''t write file BOOT.BIN'%@NL@%
        db      cr,lf%@NL@%
msg6_len equ $-msg6%@NL@%
%@NL@%
msg7    db      cr,lf%@NL@%
        db      'Boot sector from drive '%@NL@%
msg7a   db      'X: written into file '%@NL@%
msg7b   db      'X:BOOT.BIN.'%@NL@%
        db      cr,lf%@NL@%
msg7_len equ $-msg7%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far%@NL@%
%@NL@%
                                        %@AB@%; get current drive...%@AE@%%@NL@%
        push    ds                      %@AB@%; receives drive code%@AE@%%@NL@%
        push    offset DGROUP:drive%@NL@%
        push    ds                      %@AB@%; receives bitmap for%@AE@%%@NL@%
        push    offset DGROUP:drvmap    %@AB@%; available drives%@AE@%%@NL@%
        call    DosQCurDisk             %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; did function succeed?%@AE@%%@NL@%
        jz      main1                   %@AB@%; yes, proceed%@AE@%%@NL@%
%@NL@%
        mov     dx,offset DGROUP:msg1   %@AB@%; no, display error message%@AE@%%@NL@%
        mov     cx,msg1_len             %@AB@%; and exit%@AE@%%@NL@%
        jmp     error%@NL@%
%@NL@%
main1:  mov     ax,drive                %@AB@%; convert drive code to%@AE@%%@NL@%
        add     al,'A'-1                %@AB@%; ASCII letter and store%@AE@%%@NL@%
        mov     dname,al                %@AB@%; into drive name string%@AE@%%@NL@%
        mov     msg2a,al                %@AB@%; and error messages%@AE@%%@NL@%
        mov     msg3a,al%@NL@%
        mov     msg7a,al%@NL@%
        mov     msg7b,al%@NL@%
                                        %@AB@%; open current drive for%@AE@%%@NL@%
                                        %@AB@%; direct access ...%@AE@%%@NL@%
        push    ds                      %@AB@%; address of drive name%@AE@%%@NL@%
        push    offset DGROUP:dname%@NL@%
        push    ds                      %@AB@%; receives drive handle%@AE@%%@NL@%
        push    offset DGROUP:dhandle%@NL@%
        push    ds                      %@AB@%; receives DosOpen action%@AE@%%@NL@%
        push    offset DGROUP:daction%@NL@%
        push    0                       %@AB@%; file allocation (N/A)%@AE@%%@NL@%
        push    0%@NL@%
        push    0                       %@AB@%; file attribute (N/A)%@AE@%%@NL@%
        push    01h                     %@AB@%; action: open if exists,%@AE@%%@NL@%
                                        %@AB@%;         fail if doesn't%@AE@%%@NL@%
        push    8012h                   %@AB@%; mode: DASD, read/write,%@AE@%%@NL@%
                                        %@AB@%;       deny all%@AE@%%@NL@%
        push    0                       %@AB@%; reserved DWORD 0%@AE@%%@NL@%
        push    0%@NL@%
        call    DosOpen                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; was open successful?%@AE@%%@NL@%
        jz      main2                   %@AB@%; yes, proceed%@AE@%%@NL@%
%@NL@%
        mov     dx,offset DGROUP:msg2   %@AB@%; no, display error message%@AE@%%@NL@%
        mov     cx,msg2_len             %@AB@%; and exit%@AE@%%@NL@%
        jmp     error%@NL@%
%@NL@%
main2:                                  %@AB@%; lock logical drive...%@AE@%%@NL@%
        push    0                       %@AB@%; data buffer address%@AE@%%@NL@%
        push    0                       %@AB@%; (not needed)%@AE@%%@NL@%
        push    ds                      %@AB@%; parameter buffer address%@AE@%%@NL@%
        push    offset DGROUP:parblk%@NL@%
        push    0                       %@AB@%; function%@AE@%%@NL@%
        push    8                       %@AB@%; category%@AE@%%@NL@%
        push    dhandle                 %@AB@%; drive handle%@AE@%%@NL@%
        call    DosDevIOCtl             %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; was lock successful?%@AE@%%@NL@%
        jz      main3                   %@AB@%; yes, proceed%@AE@%%@NL@%
%@NL@%
        mov     dx,offset DGROUP:msg3   %@AB@%; no, display error message%@AE@%%@NL@%
        mov     cx,msg3_len             %@AB@%; and exit%@AE@%%@NL@%
        jmp     error%@NL@%
%@NL@%
main3:                                  %@AB@%; now read boot sector...%@AE@%%@NL@%
        push    dhandle                 %@AB@%; drive handle%@AE@%%@NL@%
        push    ds                      %@AB@%; buffer address%@AE@%%@NL@%
        push    offset DGROUP:bootsec%@NL@%
        push    secsize                 %@AB@%; buffer length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives actual length%@AE@%%@NL@%
        push    offset DGROUP:rlen%@NL@%
        call    DosRead                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; read successful?%@AE@%%@NL@%
        jnz     main4                   %@AB@%; no, read failed%@AE@%%@NL@%
%@NL@%
        cmp     rlen,secsize            %@AB@%; actual = expected size?%@AE@%%@NL@%
        je      main5                   %@AB@%; yes, proceed%@AE@%%@NL@%
%@NL@%
main4:                                  %@AB@%; read failed...%@AE@%%@NL@%
        mov     dx,offset DGROUP:msg4   %@AB@%; display error message%@AE@%%@NL@%
        mov     cx,msg4_len             %@AB@%; and exit%@AE@%%@NL@%
        jmp     error%@NL@%
%@NL@%
main5:                                  %@AB@%; unlock logical drive...%@AE@%%@NL@%
        push    0                       %@AB@%; data buffer address%@AE@%%@NL@%
        push    0                       %@AB@%; (not needed)%@AE@%%@NL@%
        push    ds                      %@AB@%; parameter buffer address%@AE@%%@NL@%
        push    offset DGROUP:parblk%@NL@%
        push    1                       %@AB@%; function%@AE@%%@NL@%
        push    8                       %@AB@%; category%@AE@%%@NL@%
        push    dhandle                 %@AB@%; drive handle%@AE@%%@NL@%
        call    DosDevIOCtl             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; close logical drive...%@AE@%%@NL@%
        push    dhandle                 %@AB@%; drive handle%@AE@%%@NL@%
        call    DosClose                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; now open file BOOT.BIN...%@AE@%%@NL@%
        push    ds                      %@AB@%; address of filename%@AE@%%@NL@%
        push    offset DGROUP:fname%@NL@%
        push    ds                      %@AB@%; receives file handle%@AE@%%@NL@%
        push    offset DGROUP:dhandle%@NL@%
        push    ds                      %@AB@%; receives DosOpen action%@AE@%%@NL@%
        push    offset DGROUP:daction%@NL@%
        push    0                       %@AB@%; file allocation (N/A)%@AE@%%@NL@%
        push    0%@NL@%
        push    0                       %@AB@%; file attribute (N/A)%@AE@%%@NL@%
        push    12h                     %@AB@%; action: create or replace%@AE@%%@NL@%
        push    11h                     %@AB@%; mode: write-only, deny all%@AE@%%@NL@%
        push    0                       %@AB@%; reserved DWORD 0%@AE@%%@NL@%
        push    0%@NL@%
        call    DosOpen                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; was open successful?%@AE@%%@NL@%
        jz      main6                   %@AB@%; yes, proceed%@AE@%%@NL@%
%@NL@%
        mov     dx,offset DGROUP:msg5   %@AB@%; display error message%@AE@%%@NL@%
        mov     cx,msg5_len             %@AB@%; and exit%@AE@%%@NL@%
        jmp     error%@NL@%
%@NL@%
main6:                                  %@AB@%; write sector into BOOT.BIN%@AE@%%@NL@%
        push    dhandle                 %@AB@%; file handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of data%@AE@%%@NL@%
        push    offset DGROUP:bootsec%@NL@%
        push    secsize                 %@AB@%; length of data%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; did write succeed?%@AE@%%@NL@%
        jnz     main7                   %@AB@%; no, display error msg.%@AE@%%@NL@%
        cmp     wlen,secsize            %@AB@%; was write complete?%@AE@%%@NL@%
        je      main8                   %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
main7:                                  %@AB@%; write failed...%@AE@%%@NL@%
        mov     dx,offset DGROUP:msg6   %@AB@%; display error message%@AE@%%@NL@%
        mov     cx,msg6_len             %@AB@%; and exit%@AE@%%@NL@%
        jmp     error%@NL@%
%@NL@%
main8:  push    dhandle                 %@AB@%; close the file%@AE@%%@NL@%
        call    DosClose                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display success message...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg7%@NL@%
        push    msg7_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0                       %@AB@%; return success code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
error:                                  %@AB@%; display error message...%@AE@%%@NL@%
        push    stderr                  %@AB@%; standard error handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    dx%@NL@%
        push    cx                      %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1                       %@AB@%; return error code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DUMBTERM.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH12\DUMBTERM.ASM%@AE@%%@NL@%
%@NL@%
        title        DUMBTERM -- OS/2 Terminal Program%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; DUMBTERM.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; A simple multithreaded OS/2 terminal program that exchanges%@AE@%%@NL@%
%@AB@%; characters between the console and the serial port.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Communication parameters for COM1 are set at 2400 baud,%@AE@%%@NL@%
%@AB@%; 8 data bits, no parity, and 1 stop bit.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm dumbterm.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link dumbterm,,,os2,dumbterm%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage is:  C> dumbterm%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Press Alt-X to terminate the program.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
cr      equ     0dh             %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf        equ        0ah                %@AB@%; ASCII linefeed%@AE@%%@NL@%
%@NL@%
kwait   equ     0               %@AB@%; KbdCharIn parameters%@AE@%%@NL@%
knowait equ     1%@NL@%
%@NL@%
stksize equ     2048            %@AB@%; stack size for threads%@AE@%%@NL@%
%@NL@%
exitkey equ     2dh             %@AB@%; Alt-X key is exit signal%@AE@%%@NL@%
%@NL@%
                                %@AB@%; COM port configuration%@AE@%%@NL@%
com1        equ        1                %@AB@%; nonzero if using COM1%@AE@%%@NL@%
com2        equ        0                %@AB@%; nonzero if using COM2%@AE@%%@NL@%
com3        equ        0                %@AB@%; nonzero if using COM3%@AE@%%@NL@%
baud    equ     2400            %@AB@%; baud rate for COM port%@AE@%%@NL@%
parity        equ        0                %@AB@%; 0=N, 1=O, 2=E, 3=M, 4=S%@AE@%%@NL@%
databit equ     8               %@AB@%; 5-8%@AE@%%@NL@%
stopbit equ        0                %@AB@%; 0=1, 1=1.5, 2=2%@AE@%%@NL@%
%@NL@%
        extrn   DosAllocSeg:far %@AB@%; OS/2 API functions%@AE@%%@NL@%
        extrn   DosClose:far%@NL@%
        extrn   DosCreateThread:far%@NL@%
        extrn   DosDevIOCtl:far%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosOpen:far%@NL@%
        extrn   DosRead:far%@NL@%
        extrn   DosSemClear:far%@NL@%
        extrn   DosSemSet:far%@NL@%
        extrn   DosSemWait:far%@NL@%
        extrn   DosSuspendThread:far%@NL@%
        extrn   DosWrite:far%@NL@%
        extrn   KbdCharIn:far%@NL@%
        extrn   KbdGetStatus:far%@NL@%
        extrn   KbdSetStatus:far%@NL@%
        extrn   VioWrtTTY:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
cname   label   byte            %@AB@%; COM port logical name%@AE@%%@NL@%
        if      com1%@NL@%
        db      'COM1',0        %@AB@%; COM1 device%@AE@%%@NL@%
        endif%@NL@%
        if      com2%@NL@%
        db      'COM2',0        %@AB@%; COM2 device%@AE@%%@NL@%
        endif%@NL@%
        if      com3%@NL@%
        db      'COM3',0        %@AB@%; COM3 device%@AE@%%@NL@%
        endif%@NL@%
%@NL@%
f41info dw      baud            %@AB@%; baud rate%@AE@%%@NL@%
%@NL@%
f42info db      databit         %@AB@%; data bits%@AE@%%@NL@%
        db      parity          %@AB@%; parity%@AE@%%@NL@%
        db      stopbit         %@AB@%; stop bits%@AE@%%@NL@%
%@NL@%
kbdinfo db      0               %@AB@%; character code%@AE@%%@NL@%
        db      0               %@AB@%; scan code%@AE@%%@NL@%
        db      0               %@AB@%; status flags%@AE@%%@NL@%
        db      0               %@AB@%; reserved%@AE@%%@NL@%
        dw      0               %@AB@%; shift state%@AE@%%@NL@%
        dd        0                %@AB@%; timestamp%@AE@%%@NL@%
%@NL@%
kbdstat dw      10              %@AB@%; length of structure%@AE@%%@NL@%
        dw      0               %@AB@%; keyboard state flags%@AE@%%@NL@%
        db      0,0             %@AB@%; logical end-of-line%@AE@%%@NL@%
        dw      0               %@AB@%; interim character flags%@AE@%%@NL@%
        dw      0               %@AB@%; shift state%@AE@%%@NL@%
%@NL@%
exitsem dd      0               %@AB@%; exit semaphore%@AE@%%@NL@%
%@NL@%
chandle dw      0               %@AB@%; receives COM device handle%@AE@%%@NL@%
action  dw      0               %@AB@%; receives DosOpen action%@AE@%%@NL@%
sel     dw      0               %@AB@%; receives selector%@AE@%%@NL@%
rlen    dw      0               %@AB@%; receives bytes read count%@AE@%%@NL@%
wlen    dw      0               %@AB@%; receives bytes written count%@AE@%%@NL@%
cinID   dw      0               %@AB@%; COM input thread ID%@AE@%%@NL@%
coutID  dw      0               %@AB@%; COM output thread ID%@AE@%%@NL@%
inchar        db        0                %@AB@%; input character from COM port%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf%@NL@%
        db      "Can't open COM device."%@NL@%
        db      cr,lf%@NL@%
msg1_len equ    $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf%@NL@%
        db      "Can't set baud rate."%@NL@%
        db      cr,lf%@NL@%
msg2_len equ    $-msg2%@NL@%
%@NL@%
msg3    db      cr,lf%@NL@%
        db      "Can't configure COM port."%@NL@%
        db      cr,lf%@NL@%
msg3_len equ    $-msg3%@NL@%
%@NL@%
msg4    db      cr,lf%@NL@%
        db      "Memory allocation failure."%@NL@%
        db      cr,lf%@NL@%
msg4_len equ    $-msg4%@NL@%
%@NL@%
msg5    db      cr,lf%@NL@%
        db      "Can't create COM input thread."%@NL@%
        db      cr,lf%@NL@%
msg5_len equ    $-msg5%@NL@%
%@NL@%
msg6    db      cr,lf%@NL@%
        db      "Can't create COM output thread."%@NL@%
        db      cr,lf%@NL@%
msg6_len equ    $-msg6%@NL@%
%@NL@%
msg7    db      cr,lf%@NL@%
        db      "Communicating..."%@NL@%
        db      cr,lf%@NL@%
msg7_len equ    $-msg7%@NL@%
%@NL@%
msg8    db      cr,lf%@NL@%
        db      "Terminating..."%@NL@%
        db      cr,lf%@NL@%
msg8_len equ    $-msg8%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far             %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; open COM port...%@AE@%%@NL@%
        push    ds              %@AB@%; device name address%@AE@%%@NL@%
        push    offset DGROUP:cname%@NL@%
        push    ds              %@AB@%; receives device handle%@AE@%%@NL@%
        push    offset DGROUP:chandle%@NL@%
        push    ds              %@AB@%; receives action%@AE@%%@NL@%
        push    offset DGROUP:action%@NL@%
        push    0               %@AB@%; initial allocation (N/A)%@AE@%%@NL@%
        push    0%@NL@%
        push    0               %@AB@%; attribute (N/A)%@AE@%%@NL@%
        push    1               %@AB@%; open flag: fail if device%@AE@%%@NL@%
                                %@AB@%;            does not exist%@AE@%%@NL@%
        push    12h             %@AB@%; open mode: read/write,%@AE@%%@NL@%
                                %@AB@%;             deny-all%@AE@%%@NL@%
        push    0               %@AB@%; DWORD reserved%@AE@%%@NL@%
        push    0%@NL@%
        call    DosOpen         %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; was function successful?%@AE@%%@NL@%
        jz      main1           %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
        mov     cx,msg1_len     %@AB@%; no, display error message%@AE@%%@NL@%
        mov     dx,offset DGROUP:msg1%@NL@%
        jmp     main9           %@AB@%; and exit%@AE@%%@NL@%
%@NL@%
main1:                          %@AB@%; set baud rate...%@AE@%%@NL@%
        push    0               %@AB@%; data buffer address%@AE@%%@NL@%
        push    0%@NL@%
        push    ds              %@AB@%; parameter buffer address%@AE@%%@NL@%
        push    offset DGROUP:f41info%@NL@%
        push    41h             %@AB@%; function number%@AE@%%@NL@%
        push    1               %@AB@%; category number%@AE@%%@NL@%
        push    chandle         %@AB@%; COM device handle%@AE@%%@NL@%
        call    DosDevIOCtl     %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; was function successful?%@AE@%%@NL@%
        jz      main2           %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
        mov     cx,msg2_len     %@AB@%; no, display error message%@AE@%%@NL@%
        mov     dx,offset DGROUP:msg2%@NL@%
        jmp     main9           %@AB@%; and exit%@AE@%%@NL@%
%@NL@%
main2:                          %@AB@%; configure parity, stop bits,%@AE@%%@NL@%
                                %@AB@%; and character length...%@AE@%%@NL@%
        push    0               %@AB@%; data buffer address%@AE@%%@NL@%
        push    0%@NL@%
        push    ds              %@AB@%; parameter buffer address%@AE@%%@NL@%
        push    offset DGROUP:f42info%@NL@%
        push    42h             %@AB@%; function number%@AE@%%@NL@%
        push    1               %@AB@%; category number%@AE@%%@NL@%
        push    chandle         %@AB@%; COM device handle%@AE@%%@NL@%
        call    DosDevIOCtl     %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; was function successful?%@AE@%%@NL@%
        jz      main3           %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
        mov     cx,msg3_len     %@AB@%; no, display error message%@AE@%%@NL@%
        mov     dx,offset DGROUP:msg3%@NL@%
        jmp     main9           %@AB@%; and exit%@AE@%%@NL@%
%@NL@%
main3:                          %@AB@%; put keyboard in binary mode%@AE@%%@NL@%
                                %@AB@%; with echo off...%@AE@%%@NL@%
%@NL@%
                                %@AB@%; get keyboard state%@AE@%%@NL@%
        push    ds              %@AB@%; address of info structure%@AE@%%@NL@%
        push    offset DGROUP:kbdstat%@NL@%
        push    0               %@AB@%; default keyboard handle%@AE@%%@NL@%
        call    KbdGetStatus    %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; set binary mode, no echo%@AE@%%@NL@%
        and     word ptr kbdstat+2,0fff0h%@NL@%
        or      word ptr kbdstat+2,6%@NL@%
%@NL@%
                                %@AB@%; set keyboard state%@AE@%%@NL@%
        push    ds              %@AB@%; address of info structure%@AE@%%@NL@%
        push    offset DGROUP:kbdstat%@NL@%
        push    0               %@AB@%; default keyboard handle%@AE@%%@NL@%
        call    KbdSetStatus    %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    ds              %@AB@%; set exit semaphore%@AE@%%@NL@%
        push    offset DGROUP:exitsem%@NL@%
        call    DosSemSet       %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; allocate thread stack%@AE@%%@NL@%
        push    stksize         %@AB@%; stack size in bytes%@AE@%%@NL@%
        push    ds              %@AB@%; receives new selector%@AE@%%@NL@%
        push    offset DGROUP:sel%@NL@%
        push    0               %@AB@%; not sharable/discardable%@AE@%%@NL@%
        call    DosAllocSeg     %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; was function successful?%@AE@%%@NL@%
        jz      main4           %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
        mov     cx,msg4_len     %@AB@%; no, display error message%@AE@%%@NL@%
        mov     dx,offset DGROUP:msg4%@NL@%
        jmp     main9           %@AB@%; and exit%@AE@%%@NL@%
%@NL@%
main4:                          %@AB@%; create COM input thread%@AE@%%@NL@%
        push    cs              %@AB@%; thread entry point%@AE@%%@NL@%
        push    offset _TEXT:comin%@NL@%
        push    ds              %@AB@%; receives thread ID%@AE@%%@NL@%
        push    offset DGROUP:cinID%@NL@%
        push    sel             %@AB@%; address of stack base%@AE@%%@NL@%
        push    stksize%@NL@%
        call    DosCreateThread %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; was function successful?%@AE@%%@NL@%
        jz      main5           %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
        mov     cx,msg5_len     %@AB@%; no, display error message%@AE@%%@NL@%
        mov     dx,offset DGROUP:msg5%@NL@%
        jmp     main9           %@AB@%; and exit%@AE@%%@NL@%
%@NL@%
main5:                          %@AB@%; allocate thread stack%@AE@%%@NL@%
        push    stksize         %@AB@%; stack size in bytes%@AE@%%@NL@%
        push    ds              %@AB@%; receives new selector%@AE@%%@NL@%
        push    offset DGROUP:sel%@NL@%
        push    0               %@AB@%; not sharable/discardable%@AE@%%@NL@%
        call    DosAllocSeg     %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; was function successful?%@AE@%%@NL@%
        jz      main6           %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
        mov     cx,msg4_len     %@AB@%; no, display error message%@AE@%%@NL@%
        mov     dx,offset DGROUP:msg4%@NL@%
        jmp     main9           %@AB@%; and exit%@AE@%%@NL@%
%@NL@%
main6:                          %@AB@%; create COM output thread%@AE@%%@NL@%
        push    cs              %@AB@%; thread entry point%@AE@%%@NL@%
        push    offset _TEXT:comout%@NL@%
        push    ds              %@AB@%; receives thread ID%@AE@%%@NL@%
        push    offset DGROUP:coutID%@NL@%
        push    sel             %@AB@%; address of stack base%@AE@%%@NL@%
        push    stksize%@NL@%
        call    DosCreateThread %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; was function successful?%@AE@%%@NL@%
        jz      main7           %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
        mov     cx,msg6_len     %@AB@%; no, display error message%@AE@%%@NL@%
        mov     dx,offset DGROUP:msg6%@NL@%
        jmp     main9           %@AB@%; and exit%@AE@%%@NL@%
%@NL@%
main7:                          %@AB@%; display "Communicating..."%@AE@%%@NL@%
        push    ds              %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg7%@NL@%
        push    msg7_len        %@AB@%; message length%@AE@%%@NL@%
        push    0               %@AB@%; default video handle%@AE@%%@NL@%
        call    VioWrtTTY       %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; wait for exit signal%@AE@%%@NL@%
        push    ds              %@AB@%; semaphore handle%@AE@%%@NL@%
        push    offset DGROUP:exitsem%@NL@%
        push    -1              %@AB@%; wait indefinitely%@AE@%%@NL@%
        push    -1%@NL@%
        call    DosSemWait      %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; suspend COM input thread%@AE@%%@NL@%
        push    cinID           %@AB@%; thread ID%@AE@%%@NL@%
        call    DosSuspendThread %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; suspend COM output thread%@AE@%%@NL@%
        push    coutID          %@AB@%; thread ID%@AE@%%@NL@%
        call    DosSuspendThread %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main8:                                %@AB@%; display "Terminating"...%@AE@%%@NL@%
        push    ds              %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg8%@NL@%
        push    msg8_len        %@AB@%; message length%@AE@%%@NL@%
        push    0               %@AB@%; default video handle%@AE@%%@NL@%
        call    VioWrtTTY       %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; final exit to OS/2...%@AE@%%@NL@%
        push    1               %@AB@%; terminate all threads%@AE@%%@NL@%
        push        0                %@AB@%; return code = 0 (success)%@AE@%%@NL@%
        call    DosExit         %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main9:                          %@AB@%; display error message...%@AE@%%@NL@%
                                %@AB@%; DS:DX = msg, CX = length%@AE@%%@NL@%
        push    ds              %@AB@%; address of message%@AE@%%@NL@%
        push    dx%@NL@%
        push    cx              %@AB@%; length of message%@AE@%%@NL@%
        push    0               %@AB@%; default video handle%@AE@%%@NL@%
        call    VioWrtTTY       %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; final exit to OS/2...%@AE@%%@NL@%
        push    1               %@AB@%; terminate all threads%@AE@%%@NL@%
        push        1                %@AB@%; return code = 1 (error)%@AE@%%@NL@%
        call    DosExit         %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; COM input thread: Reads characters one at a time%@AE@%%@NL@%
%@AB@%; from the COM port, and writes them to the display.%@AE@%%@NL@%
%@NL@%
comin   proc    far%@NL@%
%@NL@%
                                %@AB@%; read character from COM...%@AE@%%@NL@%
        push    chandle         %@AB@%; COM device handle%@AE@%%@NL@%
        push    ds              %@AB@%; receives COM data%@AE@%%@NL@%
        push    offset DGROUP:inchar%@NL@%
        push    1               %@AB@%; length to read%@AE@%%@NL@%
        push    ds              %@AB@%; receives read count%@AE@%%@NL@%
        push    offset DGROUP:rlen%@NL@%
        call    DosRead         %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; send character to display...%@AE@%%@NL@%
        push    ds              %@AB@%; address of character%@AE@%%@NL@%
        push    offset DGROUP:inchar%@NL@%
        push    1               %@AB@%; length to write%@AE@%%@NL@%
        push    0               %@AB@%; default video handle%@AE@%%@NL@%
        call    VioWrtTTY       %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp        comin                %@AB@%; wait for next character%@AE@%%@NL@%
%@NL@%
comin   endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; COM output thread: Reads characters from the keyboard%@AE@%%@NL@%
%@AB@%; in raw mode and sends them to the COM port.  If the%@AE@%%@NL@%
%@AB@%; exit key is detected, the main thread is signaled to%@AE@%%@NL@%
%@AB@%; clean up and terminate the process.%@AE@%%@NL@%
%@NL@%
comout  proc    far%@NL@%
%@NL@%
                                %@AB@%; read keyboard character...%@AE@%%@NL@%
        push    ds              %@AB@%; receives keyboard data%@AE@%%@NL@%
        push    offset DGROUP:kbdinfo%@NL@%
        push    kwait           %@AB@%; wait if necessary%@AE@%%@NL@%
        push    0               %@AB@%; default keyboard handle%@AE@%%@NL@%
        call    KbdCharIn       %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov     cx,1            %@AB@%; assume writing one byte%@AE@%%@NL@%
%@NL@%
        cmp     kbdinfo,0       %@AB@%; check for extended key%@AE@%%@NL@%
        jz      comout1         %@AB@%; jump, extended key%@AE@%%@NL@%
        cmp     kbdinfo,0e0h%@NL@%
        jnz     comout2         %@AB@%; jump, not extended key%@AE@%%@NL@%
%@NL@%
comout1:                        %@AB@%; extended key detected%@AE@%%@NL@%
        mov     cx,2            %@AB@%; must write 2 bytes%@AE@%%@NL@%
%@NL@%
                                %@AB@%; check for exit key%@AE@%%@NL@%
        cmp     kbdinfo+1,exitkey%@NL@%
        jnz     comout2         %@AB@%; not exit key, jump%@AE@%%@NL@%
%@NL@%
                                %@AB@%; clear exit semaphore...%@AE@%%@NL@%
        push    ds              %@AB@%; semaphore address%@AE@%%@NL@%
        push    offset DGROUP:exitsem%@NL@%
        call    DosSemClear     %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jmp     comout          %@AB@%; discard exit key%@AE@%%@NL@%
%@NL@%
comout2:                        %@AB@%; send character to COM port...%@AE@%%@NL@%
        push    chandle         %@AB@%; COM device handle%@AE@%%@NL@%
        push    ds              %@AB@%; address of character%@AE@%%@NL@%
        push    offset DGROUP:kbdinfo%@NL@%
        push    cx              %@AB@%; length to write%@AE@%%@NL@%
        push    ds              %@AB@%; receives write count%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp     comout          %@AB@%; wait for next key%@AE@%%@NL@%
%@NL@%
comout  endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DUMBTERM.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH12\DUMBTERM.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%        DUMBTERM.C%@NL@%
%@AB@%%@NL@%
%@AB@%        A simple multithreaded OS/2 terminal program that exchanges%@NL@%
%@AB@%        characters between the console and the serial port.%@NL@%
%@AB@%%@NL@%
%@AB@%        Communication parameters for COM1 are set at 2400 baud,%@NL@%
%@AB@%        8 data bits, no parity, and 1 stop bit.%@NL@%
%@AB@%%@NL@%
%@AB@%        Compile with:  C> cl /F 2000 dumbterm.c%@NL@%
%@AB@%%@NL@%
%@AB@%        Usage is:  C> dumbterm%@NL@%
%@AB@%%@NL@%
%@AB@%        Press Alt-X to terminate the program.%@NL@%
%@AB@%%@NL@%
%@AB@%        Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
WAIT   0                        %@AB@%/* parameters for KbdCharIn */%@AE@%%@NL@%
%@AI@%#define %@AE@%NOWAIT 1 %@NL@%
%@NL@%
EXITKEY  0x2d                   %@AB@%/* Exit key = Alt-X */%@AE@%%@NL@%
%@NL@%
STKSIZE 2048                    %@AB@%/* stack size for threads */%@AE@%%@NL@%
%@NL@%
COMPORT "COM1"                  %@AB@%/* COM port configuration */%@AE@%%@NL@%
BAUD    2400                    %@AB@%/* 110, 150 ... 19200 */%@AE@%%@NL@%
PARITY        0                        %@AB@%/* 0 = N, 1 = O, 2 = E, 3 = M, 4 = S */%@AE@%%@NL@%
DATABIT 8                       %@AB@%/* 5-8 allowed */%@AE@%%@NL@%
STOPBIT 0                        %@AB@%/* 0 = 1, 1 = 1.5, 2 = 2 */%@AE@%%@NL@%
%@NL@%
API unsigned extern far pascal        %@AB@%/* OS/2 API prototypes */%@AE@%%@NL@%
%@NL@%
API DosClose(unsigned); %@NL@%
API DosCreateThread(void (far *)(), unsigned far *, void far *);%@NL@%
API DosDevIOCtl(void far *, void far *, unsigned, unsigned, unsigned);%@NL@%
API DosExit(unsigned, unsigned);%@NL@%
API DosOpen(char far *, unsigned far *, unsigned far *, unsigned long,%@NL@%
            unsigned, unsigned, unsigned, unsigned long);           %@NL@%
API DosRead(unsigned, void far *, int, unsigned far *);%@NL@%
API DosSemClear(unsigned long far *);%@NL@%
API DosSemSet(unsigned long far *);%@NL@%
API DosSemWait(unsigned long far *, unsigned long);%@NL@%
API DosSuspendThread(unsigned);%@NL@%
API DosWrite(unsigned, void far *, int, unsigned far *);%@NL@%
API KbdCharIn(void far *, unsigned, unsigned);%@NL@%
API KbdGetStatus(void far *, unsigned);%@NL@%
API KbdSetStatus(void far *, unsigned);%@NL@%
API VioWrtTTY(char far *, int, unsigned);%@NL@%
%@NL@%
void far comin(void);                   %@AB@%/* local function prototypes */%@AE@%%@NL@%
void far comout(void);%@NL@%
void errexit(char *);%@NL@%
%@NL@%
struct _F41Info {                       %@AB@%/* DosDevIOCTl info structure */%@AE@%%@NL@%
    int BaudRate;                       %@AB@%/* 110, 150 ... 19200 */%@AE@%%@NL@%
    } F41Info;%@NL@%
%@NL@%
struct _F42Info {                       %@AB@%/* DosDevIOCtl info structure */%@AE@%%@NL@%
    char DataBits;                      %@AB@%/* character length 5-8 bits */%@AE@%%@NL@%
    char Parity;                        %@AB@%/* 0=N, 1=O, 2=E, 3=Mark, 4=Space */%@AE@%%@NL@%
    char StopBits;                      %@AB@%/* 0=1, 1=1.5, 2=2 stop bits */%@AE@%%@NL@%
    } F42Info;%@NL@%
%@NL@%
struct _KbdInfo {                       %@AB@%/* KbdCharIn info structure */%@AE@%%@NL@%
    char CharCode;                      %@AB@%/* ASCII character code */%@AE@%%@NL@%
    char ScanCode;                      %@AB@%/* keyboard scan code */%@AE@%%@NL@%
    char Status;                        %@AB@%/* misc. status flags */%@AE@%%@NL@%
    char Reserved1;                     %@AB@%/* reserved byte */%@AE@%%@NL@%
    unsigned ShiftState;                %@AB@%/* keyboard shift state */%@AE@%%@NL@%
    long TimeStamp;                     %@AB@%/* character timestamp */%@AE@%%@NL@%
    } KbdInfo;%@NL@%
%@NL@%
struct _KbdStatus {                     %@AB@%/* KbdGetStatus info structure */%@AE@%%@NL@%
    int Length;                         %@AB@%/* length of structure */%@AE@%%@NL@%
    unsigned Mask;                      %@AB@%/* keyboard state flags */%@AE@%%@NL@%
    char TurnAround[2];                 %@AB@%/* logical end-of-line */%@AE@%%@NL@%
    unsigned Interim;                   %@AB@%/* interim character flags */%@AE@%%@NL@%
    unsigned ShiftState;                %@AB@%/* keyboard shift state */%@AE@%%@NL@%
    } KbdStatus;%@NL@%
%@NL@%
unsigned chandle;                       %@AB@%/* handle for COM port */%@AE@%%@NL@%
unsigned long exitsem;                  %@AB@%/* Alt-X exit semaphore */%@AE@%%@NL@%
%@NL@%
main()%@NL@%
{%@NL@%
    unsigned action;                    %@AB@%/* result of DosOpen */%@AE@%%@NL@%
    unsigned openflag = 0x01;           %@AB@%/* fail if device not found */%@AE@%%@NL@%
    unsigned openmode = 0x12;           %@AB@%/* read/write, deny all */%@AE@%%@NL@%
    unsigned cominID;                   %@AB@%/* COM input thread ID */%@AE@%%@NL@%
    unsigned comoutID;                  %@AB@%/* COM output thread ID */%@AE@%%@NL@%
    char cominstk[STKSIZE];             %@AB@%/* COM input thread stack */%@AE@%%@NL@%
    char comoutstk[STKSIZE];            %@AB@%/* COM output thread stack */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* open COM port */%@AE@%%@NL@%
    if(DosOpen(COMPORT, &chandle, &action, 0L, 0, openflag, openmode, 0L))%@NL@%
        errexit("\nCan't open COM device.\n");%@NL@%
%@NL@%
    F41Info.BaudRate = BAUD;            %@AB@%/* configure COM port */%@AE@%%@NL@%
    F42Info.DataBits = DATABIT;         %@AB@%/* using DosDevIOCtl */%@AE@%%@NL@%
    F42Info.Parity = PARITY;            %@AB@%/* Category 1 functions */%@AE@%%@NL@%
    F42Info.StopBits = STOPBIT;    %@NL@%
    if(DosDevIOCtl(NULL, &F41Info, 0x41, 1, chandle))%@NL@%
        errexit("\nCan't set baud rate.\n");%@NL@%
    if(DosDevIOCtl(NULL, &F42Info, 0x42, 1, chandle))%@NL@%
        errexit("\nCan't configure COM port.\n");%@NL@%
%@NL@%
    KbdStatus.Length = 10;              %@AB@%/* force keyboard */%@AE@%%@NL@%
    KbdGetStatus(&KbdStatus, 0);        %@AB@%/* into binary mode */%@AE@%%@NL@%
    KbdStatus.Mask &= 0xfff0;           %@AB@%/* with echo off */%@AE@%%@NL@%
    KbdStatus.Mask |= 0x06;%@NL@%
    KbdSetStatus(&KbdStatus, 0);    %@NL@%
%@NL@%
    exitsem = 0L;                       %@AB@%/* initialize and */%@AE@%%@NL@%
    DosSemSet(&exitsem);                %@AB@%/* set exit semaphore */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* create COM input thread */%@AE@%%@NL@%
    if(DosCreateThread(comin, &cominID, cominstk+STKSIZE))%@NL@%
        errexit("\nCan't create COM input thread.\n");%@NL@%
%@NL@%
                                        %@AB@%/* create COM output thread */%@AE@%%@NL@%
    if(DosCreateThread(comout, &comoutID, comoutstk+STKSIZE))%@NL@%
        errexit("\nCan't create COM output thread.\n");%@NL@%
%@NL@%
    puts("\nCommunicating...");         %@AB@%/* sign-on message */%@AE@%%@NL@%
    %@NL@%
    DosSemWait(&exitsem, -1L);          %@AB@%/* wait for exit signal */%@AE@%%@NL@%
%@NL@%
    DosSuspendThread(cominID);          %@AB@%/* freeze COM input and */%@AE@%%@NL@%
    DosSuspendThread(comoutID);         %@AB@%/* output threads */%@AE@%%@NL@%
%@NL@%
    puts("\nTerminating...");           %@AB@%/* sign-off message */%@AE@%%@NL@%
%@NL@%
    DosExit(1, 0);                      %@AB@%/* terminate all threads */%@AE@%%@NL@%
                                        %@AB@%/* return code = 0 */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    The 'comin' thread reads characters one at a time from the%@NL@%
%@AB@%    COM port and sends them to the display.%@NL@%
%@AB@%*/%@AE@%%@NL@%
void far comin(void)%@NL@%
{%@NL@%
    unsigned rlen;                      %@AB@%/* scratch variable */%@AE@%%@NL@%
    char inchar;                        %@AB@%/* character input buffer */%@AE@%%@NL@%
%@NL@%
    while(1)                            %@NL@%
    {                                        %@AB@%/* read character from COM */%@AE@%%@NL@%
        DosRead(chandle, &inchar, 1, &rlen);%@NL@%
        VioWrtTTY(&inchar, 1, 0);        %@AB@%/* send character to display */%@AE@%%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    The 'comout' thread reads characters one at a time from the%@NL@%
%@AB@%    keyboard and sends them to the COM port.  If the exit key is%@NL@%
%@AB@%    detected, the main thread is signaled to clean up and exit.%@NL@%
%@AB@%*/%@AE@%%@NL@%
void far comout(void)%@NL@%
{%@NL@%
    unsigned wlen;                      %@AB@%/* scratch variable */%@AE@%%@NL@%
%@NL@%
    while(1)%@NL@%
    {%@NL@%
        KbdCharIn(&KbdInfo, WAIT, 0);   %@AB@%/* read keyboard */%@AE@%%@NL@%
        wlen = 1;                        %@AB@%/* assume 1-byte character */%@AE@%%@NL@%
        %@NL@%
                                        %@AB@%/* extended character? */%@AE@%%@NL@%
        if((KbdInfo.CharCode == 0) || (KbdInfo.CharCode == 0xe0))%@NL@%
        {%@NL@%
            wlen = 2;                   %@AB@%/* yes, set length = 2 */%@AE@%%@NL@%
            %@NL@%
            if(KbdInfo.ScanCode == EXITKEY)%@NL@%
            {                           %@AB@%/* if exit key detected */%@AE@%%@NL@%
                DosSemClear(&exitsem);  %@AB@%/* signal thread 1 to exit */%@AE@%%@NL@%
                wlen = 0;               %@AB@%/* and discard character */%@AE@%%@NL@%
            }%@NL@%
        }                               %@NL@%
                                        %@AB@%/* write COM port */%@AE@%%@NL@%
        DosWrite(chandle, &KbdInfo.CharCode, wlen, &wlen); %@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Common error exit routine; displays error message%@NL@%
%@AB@%    and terminates process.%@NL@%
%@AB@%*/%@AE@%%@NL@%
void errexit(char *msg)%@NL@%
{%@NL@%
    VioWrtTTY(msg, strlen(msg), 0);     %@AB@%/* display error message */%@AE@%%@NL@%
    DosExit(1, 1);                      %@AB@%/* terminate, exit code = 1 */%@AE@%%@NL@%
}                                       %@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DUMP.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH08\DUMP.ASM%@AE@%%@NL@%
%@NL@%
        title        DUMP -- Display File Contents%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; DUMP.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Displays the binary contents of a file in hex and ASCII on the%@AE@%%@NL@%
%@AB@%; standard output device.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm dump.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link dump,,,os2,dump%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage is:  C> dump pathname.ext  [>destination]%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII line feed%@AE@%%@NL@%
blank   equ     20h                     %@AB@%; ASCII space code%@AE@%%@NL@%
%@NL@%
blksize equ     16                      %@AB@%; size of input file records%@AE@%%@NL@%
%@NL@%
stdout  equ     1                       %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
        extrn   DosOpen:far%@NL@%
        extrn   DosRead:far%@NL@%
        extrn   DosWrite:far%@NL@%
        extrn   DosClose:far%@NL@%
        extrn   DosExit:far%@NL@%
%@NL@%
        extrn   argc:near               %@AB@%; returns argument count%@AE@%%@NL@%
        extrn   argv:near               %@AB@%; returns argument pointer%@AE@%%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
fname   db      64 dup (0)              %@AB@%; name of input file%@AE@%%@NL@%
%@NL@%
fhandle dw      0                       %@AB@%; input file handle%@AE@%%@NL@%
%@NL@%
faction dw      0                       %@AB@%; action from DosOpen%@AE@%%@NL@%
%@NL@%
fptr    dw      0                       %@AB@%; relative file address%@AE@%%@NL@%
%@NL@%
rlen    dw      0                       %@AB@%; actual number of bytes%@AE@%%@NL@%
                                        %@AB@%; read by DosRead%@AE@%%@NL@%
%@NL@%
wlen    dw      0                       %@AB@%; actual number of bytes%@AE@%%@NL@%
                                        %@AB@%; written by DosWrite%@AE@%%@NL@%
%@NL@%
output  db      'nnnn',blank,blank      %@AB@%; output format area%@AE@%%@NL@%
outputa db      16 dup ('nn',blank)%@NL@%
        db      blank%@NL@%
outputb db      16 dup (blank),cr,lf%@NL@%
output_len equ $-output%@NL@%
%@NL@%
hdg     db      cr,lf%@NL@%
        db      7 dup (blank)%@NL@%
        db      '0  1  2  3  4  5  6  7  '%@NL@%
        db      '8  9  A  B  C  D  E  F',cr,lf%@NL@%
hdg_len equ $-hdg%@NL@%
%@NL@%
fbuff   db      blksize dup (?)         %@AB@%; data from file%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf%@NL@%
        db      'dump: file not found'%@NL@%
        db      cr,lf%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf%@NL@%
        db        'dump: missing filename'%@NL@%
        db      cr,lf%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
msg3    db      cr,lf%@NL@%
        db      'dump: empty file'%@NL@%
        db      cr,lf%@NL@%
msg3_len equ $-msg3%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
dump    proc    far                     %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; make DGROUP addressable%@AE@%%@NL@%
        pop     es                      %@AB@%; via ES%@AE@%%@NL@%
%@NL@%
        call    argc                    %@AB@%; is filename present%@AE@%%@NL@%
        cmp     ax,2                    %@AB@%; in command tail?%@AE@%%@NL@%
        je      dump1                   %@AB@%; yes, proceed%@AE@%%@NL@%
%@NL@%
        mov     dx,offset msg2          %@AB@%; missing or illegal filespec,%@AE@%%@NL@%
        mov     cx,msg2_len%@NL@%
        jmp     dump9                   %@AB@%; display error message and exit%@AE@%%@NL@%
%@NL@%
dump1:                                  %@AB@%; copy filename from command%@AE@%%@NL@%
                                        %@AB@%; tail to local buffer%@AE@%%@NL@%
%@NL@%
        mov     ax,1                    %@AB@%; get pointer to command tail%@AE@%%@NL@%
        call    argv                    %@AB@%; argument in ES:BX%@AE@%%@NL@%
        mov     cx,ax                   %@AB@%; CX = filename length%@AE@%%@NL@%
        mov     di,offset fname         %@AB@%; DS:DI = local buffer%@AE@%%@NL@%
%@NL@%
dump2:  mov     al,es:[bx]              %@AB@%; copy filename byte by byte%@AE@%%@NL@%
        mov     [di],al%@NL@%
        inc     bx%@NL@%
        inc     di%@NL@%
        loop    dump2%@NL@%
%@NL@%
        push    ds                      %@AB@%; restore ES = DGROUP%@AE@%%@NL@%
        pop     es%@NL@%
%@NL@%
dump4:                                  %@AB@%; try to open file...%@AE@%%@NL@%
        push    ds                      %@AB@%; address of filename%@AE@%%@NL@%
        push    offset fname%@NL@%
        push    ds                      %@AB@%; receives file handle%@AE@%%@NL@%
        push    offset fhandle%@NL@%
        push    ds%@NL@%
        push    offset faction          %@AB@%; receives DosOpen action%@AE@%%@NL@%
        push    0                       %@AB@%; file size (ignored)%@AE@%%@NL@%
        push    0%@NL@%
        push    0                       %@AB@%; file attribute (ignored)%@AE@%%@NL@%
        push        1                        %@AB@%; OpenFlag:%@AE@%%@NL@%
                                        %@AB@%; fail if file doesn't exist%@AE@%%@NL@%
        push    40h                     %@AB@%; OpenMode: deny-none,%@AE@%%@NL@%
                                        %@AB@%; deny-none, access = read-only%@AE@%%@NL@%
        push    0                       %@AB@%; reserved DWORD 0%@AE@%%@NL@%
        push    0%@NL@%
        call    DosOpen                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; was open successful?%@AE@%%@NL@%
        jz      dump5                   %@AB@%; yes, proceed%@AE@%%@NL@%
%@NL@%
        mov     dx,offset msg1          %@AB@%; open failed, display%@AE@%%@NL@%
        mov     cx,msg1_len             %@AB@%; error message and exit%@AE@%%@NL@%
        jmp     dump9%@NL@%
%@NL@%
dump5:  call    rdblk                   %@AB@%; initialize file buffer%@AE@%%@NL@%
        cmp     rlen,0                  %@AB@%; anything read?%@AE@%%@NL@%
        jne     dump6                   %@AB@%; jump, got some data%@AE@%%@NL@%
        cmp        fptr,0                        %@AB@%; no data, was this first read?%@AE@%%@NL@%
        jne     dump8                   %@AB@%; no, end of file reached%@AE@%%@NL@%
%@NL@%
        mov        dx,offset msg3                %@AB@%; empty file, print error%@AE@%%@NL@%
        mov     cx,msg3_len             %@AB@%; message and exit%@AE@%%@NL@%
        jmp     dump9%@NL@%
%@NL@%
dump6:  test    fptr,07fh               %@AB@%; time for a heading?%@AE@%%@NL@%
        jnz     dump7                   %@AB@%; no, jump%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; write heading...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of heading%@AE@%%@NL@%
        push    offset hdg%@NL@%
        push    hdg_len                 %@AB@%; length of heading%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite%@NL@%
%@NL@%
dump7:  call    cnvblk                  %@AB@%; convert one block of%@AE@%%@NL@%
                                        %@AB@%; binary data to ASCII%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; write formatted output...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of output%@AE@%%@NL@%
        push    offset output%@NL@%
        push    output_len              %@AB@%; length of output%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite%@NL@%
%@NL@%
        jmp     dump5                   %@AB@%; get more data%@AE@%%@NL@%
%@NL@%
dump8:                                  %@AB@%; end of file reached...%@AE@%%@NL@%
        push    fhandle                 %@AB@%; close input file%@AE@%%@NL@%
        call    DosClose                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; final exit to OS/2...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push        0                        %@AB@%; return code = 0 (success)%@AE@%%@NL@%
        call    DosExit                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
dump9:                                  %@AB@%; print error message on%@AE@%%@NL@%
                                        %@AB@%; standard error device%@AE@%%@NL@%
        push    stderr%@NL@%
        push    ds                      %@AB@%; address of message%@AE@%%@NL@%
        push    dx%@NL@%
        push    cx                      %@AB@%; length of message%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; final exit to OS/2...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push        1                        %@AB@%; return code = 1 (error)%@AE@%%@NL@%
        call    DosExit                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
dump    endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; RDBLK:        Read block of data from input file%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    nothing%@AE@%%@NL@%
%@AB@%; Returns:        AX = error code (0 = no error)%@AE@%%@NL@%
%@AB@%; Uses:         nothing%@AE@%%@NL@%
%@NL@%
rdblk   proc    near%@NL@%
%@NL@%
        push    fhandle                 %@AB@%; input file handle%@AE@%%@NL@%
        push    ds                      %@AB@%; buffer address%@AE@%%@NL@%
        push    offset fbuff%@NL@%
        push    blksize                 %@AB@%; buffer length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes read%@AE@%%@NL@%
        push    offset rlen%@NL@%
        call    DosRead                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
rdblk   endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; CNVBLK:        Format one binary record for output%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    nothing%@AE@%%@NL@%
%@AB@%; Returns:      nothing%@AE@%%@NL@%
%@AB@%; Uses:         AX, BX, CX, DX, DI%@AE@%%@NL@%
%@NL@%
cnvblk  proc    near%@NL@%
%@NL@%
        mov     di,offset output        %@AB@%; clear output format%@AE@%%@NL@%
        mov     cx,output_len-2         %@AB@%; area to blanks%@AE@%%@NL@%
        mov     al,blank%@NL@%
        rep stosb%@NL@%
%@NL@%
        mov     di,offset output        %@AB@%; convert current file%@AE@%%@NL@%
        mov     ax,fptr                 %@AB@%; offset to ASCII%@AE@%%@NL@%
        call    wtoa%@NL@%
%@NL@%
        xor     bx,bx                   %@AB@%; point to start of data%@AE@%%@NL@%
%@NL@%
cb1:    mov     al,[fbuff+bx]           %@AB@%; get next byte of data%@AE@%%@NL@%
                                        %@AB@%; from input file%@AE@%%@NL@%
%@NL@%
        lea        di,[bx+outputb]         %@AB@%; calculate output address%@AE@%%@NL@%
                                        %@AB@%; for ASCII equivalent%@AE@%%@NL@%
        mov     byte ptr [di],'.'       %@AB@%; if control character,%@AE@%%@NL@%
        cmp     al,blank                %@AB@%; substitute a period%@AE@%%@NL@%
        jb        cb2                        %@AB@%; jump, not alphanumeric%@AE@%%@NL@%
        cmp     al,7eh%@NL@%
        ja        cb2                        %@AB@%; jump, not alphanumeric%@AE@%%@NL@%
        mov        [di],al                 %@AB@%; store ASCII character%@AE@%%@NL@%
%@NL@%
cb2:                                    %@AB@%; now convert byte to hex%@AE@%%@NL@%
        mov     di,bx                   %@AB@%; calculate output address%@AE@%%@NL@%
        imul        di,di,3                 %@AB@%; (position*3) + base address%@AE@%%@NL@%
        add     di,offset outputa%@NL@%
        call    btoa                    %@AB@%; convert data byte to hex%@AE@%%@NL@%
%@NL@%
        inc     bx                      %@AB@%; advance through record%@AE@%%@NL@%
        cmp     bx,rlen                 %@AB@%; entire buffer converted?%@AE@%%@NL@%
        jne     cb1                     %@AB@%; no, get another byte%@AE@%%@NL@%
%@NL@%
        add     fptr,blksize            %@AB@%; update file offset%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
cnvblk  endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; WTOA:         Convert word to hex ASCII%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    AX    = data to convert%@AE@%%@NL@%
%@AB@%;               ES:DI = storage address%@AE@%%@NL@%
%@AB@%; Returns:      nothing%@AE@%%@NL@%
%@AB@%; Uses:         AX, CL, DI%@AE@%%@NL@%
%@NL@%
wtoa    proc    near%@NL@%
%@NL@%
        push    ax                      %@AB@%; save original value%@AE@%%@NL@%
        mov     al,ah%@NL@%
        call    btoa                    %@AB@%; convert upper byte%@AE@%%@NL@%
%@NL@%
        pop     ax                      %@AB@%; restore original value%@AE@%%@NL@%
        call    btoa                    %@AB@%; convert lower byte%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
wtoa    endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; BTOA:         Convert byte to hex ASCII%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    AL    = data to convert%@AE@%%@NL@%
%@AB@%;               ES:DI = storage address%@AE@%%@NL@%
%@AB@%; Returns:      nothing%@AE@%%@NL@%
%@AB@%; Uses:         AX, CL, DI%@AE@%%@NL@%
%@NL@%
btoa    proc    near%@NL@%
%@NL@%
        sub     ah,ah                   %@AB@%; clear upper byte%@AE@%%@NL@%
%@NL@%
        mov     cl,16                   %@AB@%; divide by 16%@AE@%%@NL@%
        div     cl%@NL@%
%@NL@%
        call    ascii                   %@AB@%; convert quotient%@AE@%%@NL@%
        stosb                           %@AB@%; store ASCII character%@AE@%%@NL@%
%@NL@%
        mov     al,ah%@NL@%
        call    ascii                   %@AB@%; convert remainder%@AE@%%@NL@%
        stosb                           %@AB@%; store ASCII character%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
btoa    endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; ASCII:        Convert nibble to hex ASCII%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    AL    = data to convert in low 4 bits%@AE@%%@NL@%
%@AB@%; Returns:      AL    = ASCII character%@AE@%%@NL@%
%@AB@%; Uses:         nothing%@AE@%%@NL@%
%@NL@%
ascii   proc    near%@NL@%
%@NL@%
        add     al,'0'                  %@AB@%; add base ASCII value%@AE@%%@NL@%
        cmp     al,'9'                  %@AB@%; is it in range 0-9?%@AE@%%@NL@%
        jle     ascii2                  %@AB@%; jump if it is%@AE@%%@NL@%
%@NL@%
        add     al,'A'-'9'-1            %@AB@%; no, adjust for range A-F%@AE@%%@NL@%
%@NL@%
ascii2: ret                                %@AB@%; return ASCII character in AL%@AE@%%@NL@%
%@NL@%
ascii   endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     dump%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DUMP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH08\DUMP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%        DUMP.C%@NL@%
%@AB@%%@NL@%
%@AB@%        Displays the binary contents of a file in hex and ASCII on%@NL@%
%@AB@%        the standard output device.  Demonstrates direct calls to%@NL@%
%@AB@%        OS/2 API from a C program.%@NL@%
%@AB@%%@NL@%
%@AB@%        Compile with:  C> cl dump.c%@NL@%
%@AB@%%@NL@%
%@AB@%        Usage is:  C> dump pathname.ext [>destination]%@NL@%
%@AB@%%@NL@%
%@AB@%        Copyright (C) 1987 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
RECSIZE 16                  %@AB@%/* size of file records */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%API unsigned extern far pascal  %@NL@%
%@NL@%
API DosClose(unsigned);             %@AB@%/* function prototypes */%@AE@%%@NL@%
%@NL@%
API DosOpen(char far *, unsigned far *, unsigned far *, unsigned long,%@NL@%
            unsigned, unsigned, unsigned, unsigned long);           %@NL@%
%@NL@%
API DosRead(unsigned, void far *, unsigned, unsigned far *);%@NL@%
%@NL@%
main(int argc, char *argv[])%@NL@%
{   %@NL@%
    char file_buf[RECSIZE];         %@AB@%/* data block from file */%@AE@%%@NL@%
    unsigned long foffset = 0L;     %@AB@%/* file offset in bytes */%@AE@%%@NL@%
    unsigned handle;                %@AB@%/* DosOpen variable */%@AE@%%@NL@%
    unsigned action, length;        %@AB@%/* DosRead variables */%@AE@%%@NL@%
    unsigned flag = 0x01;           %@AB@%/* fail if file not found */%@AE@%%@NL@%
    unsigned mode = 0x40;           %@AB@%/* read only, deny none */%@AE@%%@NL@%
%@NL@%
    if(argc < 2)                    %@AB@%/* check command tail */%@AE@%%@NL@%
    {   %@NL@%
        fprintf(stderr, "\ndump: missing file name\n");%@NL@%
        exit(1);%@NL@%
    }%@NL@%
                                    %@AB@%/* open file or exit */%@AE@%%@NL@%
    if(DosOpen(argv[1], &handle, &action, 0L, 0, flag, mode, 0L)) %@NL@%
    {   %@NL@%
        fprintf(stderr, "\ndump: can't find file %s\n", argv[1]);%@NL@%
        exit(1);%@NL@%
    }  %@NL@%
                                    %@AB@%/* read and dump records */%@AE@%%@NL@%
    while((DosRead(handle, file_buf, RECSIZE, &length) == 0) %@NL@%
           && (length != 0))%@NL@%
    {   %@NL@%
        dump_rec(file_buf, foffset, length);%@NL@%
        foffset += RECSIZE;%@NL@%
    }%@NL@%
    printf("\n");                   %@AB@%/* extra blank line */%@AE@%%@NL@%
    DosClose(handle);               %@AB@%/* close the input file */%@AE@%%@NL@%
    exit(0);                        %@AB@%/* return success code */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Display record (16 bytes) in hex and ASCII on standard output.%@NL@%
%@AB@%*/%@AE@%%@NL@%
dump_rec(char *buffer, long foffset, int length)%@NL@%
{   %@NL@%
    int i;                          %@AB@%/* index to current record */%@AE@%%@NL@%
%@NL@%
    if(foffset % 128 == 0)          %@AB@%/* maybe print heading */%@AE@%%@NL@%
        printf("\n\n       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F");%@NL@%
        %@NL@%
    printf("\n%04lX ", foffset);    %@AB@%/* file offset */%@AE@%%@NL@%
%@NL@%
    for(i = 0; i < length; i++)     %@AB@%/* print hex equiv. of each byte */%@AE@%%@NL@%
        printf(" %02X", (unsigned char) buffer[i]);%@NL@%
%@NL@%
    if(length != 16)                %@AB@%/* space over if last rec. */%@AE@%%@NL@%
        for(i=0; i<(16-length); i++) printf("   ");%@NL@%
%@NL@%
    printf("  ");%@NL@%
    for(i = 0; i < length; i++)     %@AB@%/* print ASCII equiv. of bytes */%@AE@%%@NL@%
    {   %@NL@%
        if(buffer[i] < 32 || buffer[i] > 126) putchar('.');%@NL@%
        else putchar(buffer[i]);%@NL@%
    }%@NL@%
} %@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EXEC1.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH12\EXEC1.ASM%@AE@%%@NL@%
%@NL@%
        title   EXEC1.ASM Demo of synchronous child process%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; EXEC1.ASM   Demonstrates use of DosExecPgm to run%@AE@%%@NL@%
%@AB@%;             CHKDSK as a synchronous child process.%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM EXEC1;%@AE@%%@NL@%
%@AB@%;               LINK EXEC1,,,OS2,EXEC1%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        EXEC1%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Note:         File CHKDSK.COM must be available in PATH.%@AE@%%@NL@%
%@NL@%
stdin   equ     0                       %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1                       %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII line feed%@AE@%%@NL@%
%@NL@%
        extrn   DosExecPgm:far          %@AB@%; reference to OS/2 API%@AE@%%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
objbuff db      64 dup (0)      %@AB@%; receives name of dynamic link%@AE@%%@NL@%
objbuff_len equ $-objbuff       %@AB@%; causing DosExecPgm failure%@AE@%%@NL@%
%@NL@%
                                %@AB@%; argument strings for child%@AE@%%@NL@%
argblk  db      'chkdsk',0      %@AB@%; simple filename of child%@AE@%%@NL@%
        db      ' *.*',0        %@AB@%; simulated command tail%@AE@%%@NL@%
        db      0               %@AB@%; extra null byte terminates block%@AE@%%@NL@%
%@NL@%
                                %@AB@%; receives return codes from child...%@AE@%%@NL@%
retcode dw      0               %@AB@%; termination code for child%@AE@%%@NL@%
        dw      0               %@AB@%; result code from child's DosExit%@AE@%%@NL@%
%@NL@%
pname   db      'chkdsk.com',0  %@AB@%; pathname of child program%@AE@%%@NL@%
%@NL@%
wlen    dw      ?%@NL@%
%@NL@%
msg1    db      cr,lf,'Unexpected OS/2 Error',cr,lf%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf,'Exec function successful',cr,lf%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far%@NL@%
%@NL@%
                                        %@AB@%; run CHKDSK as a syn-%@AE@%%@NL@%
                                        %@AB@%; chronous child process...%@AE@%%@NL@%
        push    ds                      %@AB@%; receives module/entry%@AE@%%@NL@%
        push    offset DGROUP:objbuff   %@AB@%; point if dynlink fails%@AE@%%@NL@%
        push    objbuff_len             %@AB@%; length of object buffer%@AE@%%@NL@%
        push    0                       %@AB@%; 0=execute synchronously%@AE@%%@NL@%
        push    ds                      %@AB@%; address of argument block%@AE@%%@NL@%
        push    offset DGROUP:argblk%@NL@%
        push    0                       %@AB@%; address of environment%@AE@%%@NL@%
        push    0                       %@AB@%; (0 = inherit parent's)%@AE@%%@NL@%
        push    ds                      %@AB@%; receives child's exit%@AE@%%@NL@%
        push    offset DGROUP:retcode   %@AB@%; and termination codes%@AE@%%@NL@%
        push    ds                      %@AB@%; name of child program%@AE@%%@NL@%
        push    offset DGROUP:pname%@NL@%
        call    DosExecPgm              %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; did child process run?%@AE@%%@NL@%
        jnz     error                   %@AB@%; jump if function failed%@AE@%%@NL@%
%@NL@%
exit:                                   %@AB@%; display success message...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset msg2%@NL@%
        push    msg2_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0                       %@AB@%; return success code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
error:                                  %@AB@%; display error message...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset msg1%@NL@%
        push    msg1_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1                       %@AB@%; return error code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EXEC2.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH12\EXEC2.ASM%@AE@%%@NL@%
%@NL@%
        title   EXEC2.ASM Demo of asynchronous child process%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; EXEC2.ASM   Demonstrates use of DosExecPgm and DosCwait to%@AE@%%@NL@%
%@AB@%;             run CHKDSK as an asynchronous child process.%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM EXEC2;%@AE@%%@NL@%
%@AB@%;               LINK EXEC2,,,OS2,EXEC2%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        EXEC2%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Note:         File CHKDSK.COM must be available in PATH.%@AE@%%@NL@%
%@NL@%
stdin   equ     0                       %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1                       %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII line feed%@AE@%%@NL@%
%@NL@%
        extrn   DosCwait:far            %@AB@%; reference to OS/2 API%@AE@%%@NL@%
        extrn   DosExecPgm:far%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
objbuff db      64 dup (0)      %@AB@%; receives name of dynamic link%@AE@%%@NL@%
objbuff_len equ $-objbuff       %@AB@%; causing DosExecPgm failure%@AE@%%@NL@%
%@NL@%
                                %@AB@%; argument strings for child%@AE@%%@NL@%
argblk  db      'chkdsk',0      %@AB@%; simple filename of child%@AE@%%@NL@%
        db      ' *.*',0        %@AB@%; simulated command tail%@AE@%%@NL@%
        db      0               %@AB@%; extra null byte terminates block%@AE@%%@NL@%
%@NL@%
                                %@AB@%; receives DosExecPgm info%@AE@%%@NL@%
cinfo   dw      0               %@AB@%; PID of child process%@AE@%%@NL@%
        dw      0               %@AB@%; not used%@AE@%%@NL@%
%@NL@%
                                %@AB@%; receives DosCwait info%@AE@%%@NL@%
retcode dw      0               %@AB@%; termination code for child%@AE@%%@NL@%
        dw      0               %@AB@%; result code from child's DosExit%@AE@%%@NL@%
%@NL@%
pname   db      'chkdsk.com',0  %@AB@%; pathname of child program%@AE@%%@NL@%
%@NL@%
wlen    dw      ?%@NL@%
%@NL@%
msg1    db      cr,lf,'Unexpected OS/2 Error',cr,lf%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf,'Exec function successful',cr,lf%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far%@NL@%
%@NL@%
                                        %@AB@%; run CHKDSK as an asyn-%@AE@%%@NL@%
                                        %@AB@%; chronous child process...%@AE@%%@NL@%
        push    ds                      %@AB@%; receives module/entry%@AE@%%@NL@%
        push    offset DGROUP:objbuff   %@AB@%; point if dynlink fails%@AE@%%@NL@%
        push    objbuff_len             %@AB@%; length of object buffer%@AE@%%@NL@%
        push    2                       %@AB@%; 2 = execute asynchronously%@AE@%%@NL@%
        push    ds                      %@AB@%; address of argument block%@AE@%%@NL@%
        push    offset DGROUP:argblk%@NL@%
        push    0                       %@AB@%; address of environment%@AE@%%@NL@%
        push    0                       %@AB@%; (0 = inherit parent's)%@AE@%%@NL@%
        push    ds                      %@AB@%; receives child's PID%@AE@%%@NL@%
        push    offset DGROUP:cinfo%@NL@%
        push    ds                      %@AB@%; name of child program%@AE@%%@NL@%
        push    offset DGROUP:pname%@NL@%
        call    DosExecPgm              %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; did child process run?%@AE@%%@NL@%
        jnz     error                   %@AB@%; jump if function failed%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; we could do other%@AE@%%@NL@%
                                        %@AB@%; other processing here...%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; now resynchronize with%@AE@%%@NL@%
                                        %@AB@%; child process...%@AE@%%@NL@%
        push    0                       %@AB@%; 0=immediate child only%@AE@%%@NL@%
        push    0                       %@AB@%; 0=wait till child ends%@AE@%%@NL@%
        push    ds                      %@AB@%; receives termination info%@AE@%%@NL@%
        push    offset DGROUP:retcode%@NL@%
        push    ds                      %@AB@%; receives PID (N/A here)%@AE@%%@NL@%
        push    offset DGROUP:cinfo+2%@NL@%
        push    cinfo                   %@AB@%; PID of process to wait for%@AE@%%@NL@%
        call    DosCwait                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
exit:                                   %@AB@%; display success message...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset msg2%@NL@%
        push    msg2_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0                       %@AB@%; return success code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
error:                                  %@AB@%; display error message...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset msg1%@NL@%
        push    msg1_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1                       %@AB@%; return error code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EXEC3.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH12\EXEC3.ASM%@AE@%%@NL@%
%@NL@%
        title   EXEC3.ASM Demo of DosStartSession%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; EXEC3.ASM  Demonstration of DosStartSession, runs CMD.EXE%@AE@%%@NL@%
%@AB@%;            in a new background session to display a directory,%@AE@%%@NL@%
%@AB@%;            then waits for a keypress before exiting.%@AE@%%@NL@%
%@AB@%;            You can use the Task Manager to switch to the%@AE@%%@NL@%
%@AB@%;            new session and end that session by entering EXIT.%@AE@%%@NL@%
%@AB@%;            Child session will also be terminated unilaterally%@AE@%%@NL@%
%@AB@%;            when you press a key to terminate this process.%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM EXEC3;%@AE@%%@NL@%
%@AB@%;               LINK EXEC3,,,OS2,EXEC3%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        EXEC3%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Note:         File CMD.EXE must be available in PATH.%@AE@%%@NL@%
%@NL@%
stdin   equ     0                       %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1                       %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII line feed%@AE@%%@NL@%
%@NL@%
        extrn   DosExit:far             %@AB@%; references to OS/2 API%@AE@%%@NL@%
        extrn   DosStartSession:far%@NL@%
        extrn   DosWrite:far%@NL@%
        extrn   KbdCharIn:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
argstr  db      ' /k dir/w',0           %@AB@%; argument string for child%@AE@%%@NL@%
pname   db      'cmd.exe',0             %@AB@%; pathname for child%@AE@%%@NL@%
stitle  db      'Child Command Processor',0%@NL@%
%@NL@%
childID dw      0                       %@AB@%; child process ID%@AE@%%@NL@%
sesID   dw      0                       %@AB@%; child session ID%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; session data...%@AE@%%@NL@%
sinfo   dw      24                      %@AB@%; length of structure%@AE@%%@NL@%
        dw      1                       %@AB@%; 0=unrelated, 1=related%@AE@%%@NL@%
        dw      1                       %@AB@%; 0=foreground, 1=background%@AE@%%@NL@%
        dw      0                       %@AB@%; 0=nontraceable, 1=traceable%@AE@%%@NL@%
        dd      stitle                  %@AB@%; session title%@AE@%%@NL@%
        dd      pname                   %@AB@%; program pathname%@AE@%%@NL@%
        dd      argstr                  %@AB@%; argument strings%@AE@%%@NL@%
        dd      0                       %@AB@%; termination queue (not used)%@AE@%%@NL@%
%@NL@%
kbdinfo db      10 dup (0)              %@AB@%; character input data%@AE@%%@NL@%
wlen    dw      ?                       %@AB@%; receives actual bytes written%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf,'Unexpected OS/2 Error',cr,lf%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf,'Press any key to terminate parent...',0%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far%@NL@%
%@NL@%
                                        %@AB@%; run CMD.EXE in a new%@AE@%%@NL@%
                                        %@AB@%; session as a child process%@AE@%%@NL@%
        push    ds                      %@AB@%; address of session data%@AE@%%@NL@%
        push    offset DGROUP:sinfo%@NL@%
        push    ds                      %@AB@%; receives new session ID%@AE@%%@NL@%
        push    offset DGROUP:sesID%@NL@%
        push    ds                      %@AB@%; receives child process ID%@AE@%%@NL@%
        push    offset DGROUP:childID%@NL@%
        call    DosStartSession         %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; did call succeed?%@AE@%%@NL@%
        jnz     error                   %@AB@%; jump if function failed%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display message,%@AE@%%@NL@%
                                        %@AB@%; 'Press any key'...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of message%@AE@%%@NL@%
        push    offset msg2%@NL@%
        push    msg2_len                %@AB@%; length of message%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; now wait for key...%@AE@%%@NL@%
        push    ds                      %@AB@%; receives keyboard data%@AE@%%@NL@%
        push    offset DGROUP:kbdinfo%@NL@%
        push    0                       %@AB@%; 0=wait for character%@AE@%%@NL@%
        push    0                       %@AB@%; keyboard handle%@AE@%%@NL@%
        call    KbdCharIn               %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
exit:                                   %@AB@%; final exit to OS/2...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0                       %@AB@%; return success code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
error:                                  %@AB@%; display error message%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset msg1%@NL@%
        push    msg1_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1                       %@AB@%; return error code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EXECSORT.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH16\EXECSORT.ASM%@AE@%%@NL@%
%@NL@%
        title          EXECSORT -- Run SORT.EXE as Child%@NL@%
        page      55,132%@NL@%
        .286%@NL@%
        .sall%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; EXECSORT.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Demonstration of use of DosExecPgm to run the OS/2 filter SORT.EXE%@AE@%%@NL@%
%@AB@%; as a child process, redirecting its input to MYFILE.DAT and its%@AE@%%@NL@%
%@AB@%; output to MYFILE.SRT.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm execsort.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link execsort,,,os2,execsort%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage is:  C> execsort%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
stdin   equ     0               %@AB@%; standard input device%@AE@%%@NL@%
stdout  equ     1               %@AB@%; standard output device%@AE@%%@NL@%
stderr  equ     2               %@AB@%; standard error device%@AE@%%@NL@%
%@NL@%
cr      equ     0dh             %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah             %@AB@%; ASCII linefeed%@AE@%%@NL@%
%@NL@%
        extrn   DosClose:far%@NL@%
        extrn   DosDupHandle:far%@NL@%
        extrn   DosExecPgm:far%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosOpen:far%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
jerr        macro        target                %@AB@%;; Macro to test AX%@AE@%%@NL@%
        local        zero                %@AB@%;; and jump if AX nonzero%@AE@%%@NL@%
        or      ax,ax%@NL@%
        jz        zero                %@AB@%;; Uses JMP DISP16 to avoid%@AE@%%@NL@%
        jmp        target                %@AB@%;; branch out of range errors%@AE@%%@NL@%
zero:%@NL@%
        endm%@NL@%
%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
iname   db      'MYFILE.DAT',0  %@AB@%; name of input file%@AE@%%@NL@%
oname   db      'MYFILE.SRT',0  %@AB@%; name of output file%@AE@%%@NL@%
%@NL@%
ihandle dw      ?               %@AB@%; handle for input file%@AE@%%@NL@%
ohandle dw      ?               %@AB@%; handle for output file%@AE@%%@NL@%
%@NL@%
action  dw      ?               %@AB@%; receives DosOpen action%@AE@%%@NL@%
%@NL@%
oldin   dw      -1              %@AB@%; dup of old stdin handle%@AE@%%@NL@%
oldout  dw      -1              %@AB@%; dup of old stdout handle%@AE@%%@NL@%
%@NL@%
newin   dw      stdin           %@AB@%; forced to track ihandle%@AE@%%@NL@%
newout  dw      stdout          %@AB@%; forced to track ohandle%@AE@%%@NL@%
%@NL@%
pname   db      'SORT.EXE',0    %@AB@%; pathname of SORT filter%@AE@%%@NL@%
%@NL@%
objbuff db      64              %@AB@%; receives failing dynlink%@AE@%%@NL@%
objbuff_len equ $-objbuff%@NL@%
%@NL@%
pcodes  dw      0,0             %@AB@%; PID, exit code of child%@AE@%%@NL@%
%@NL@%
msg     db      cr,lf,'SORT was executed as child.',cr,lf%@NL@%
msg_len equ $-msg%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far             %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; prepare stdin and stdout%@AE@%%@NL@%
                                %@AB@%; handles for child SORT...%@AE@%%@NL@%
%@NL@%
                                %@AB@%; dup handle for stdin...%@AE@%%@NL@%
        push    stdin           %@AB@%; standard input handle%@AE@%%@NL@%
        push    ds              %@AB@%; receives new handle%@AE@%%@NL@%
        push    offset DGROUP:oldin%@NL@%
        call    DosDupHandle    %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
                                %@AB@%; dup handle for stdout...%@AE@%%@NL@%
        push    stdout          %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds              %@AB@%; receives new handle%@AE@%%@NL@%
        push    offset DGROUP:oldout%@NL@%
        call    DosDupHandle    %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
                                %@AB@%; open input file...%@AE@%%@NL@%
        push    ds              %@AB@%; address of filename%@AE@%%@NL@%
        push    offset DGROUP:iname%@NL@%
        push    ds              %@AB@%; receives file handle%@AE@%%@NL@%
        push    offset DGROUP:ihandle%@NL@%
        push    ds              %@AB@%; receives DosOpen action%@AE@%%@NL@%
        push    offset DGROUP:action%@NL@%
        push        0                %@AB@%; file size (not used)%@AE@%%@NL@%
        push    0%@NL@%
        push    0               %@AB@%; attribute (not used)%@AE@%%@NL@%
        push    1               %@AB@%; action: open if exists%@AE@%%@NL@%
                                %@AB@%;         fail if doesn't%@AE@%%@NL@%
        push    40h             %@AB@%; access: read-only%@AE@%%@NL@%
        push    0               %@AB@%; reserved DWORD 0%@AE@%%@NL@%
        push    0%@NL@%
        call    DosOpen         %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
                                %@AB@%; create output file...%@AE@%%@NL@%
        push    ds              %@AB@%; address of filename%@AE@%%@NL@%
        push    offset DGROUP:oname%@NL@%
        push    ds              %@AB@%; receives file handle%@AE@%%@NL@%
        push    offset DGROUP:ohandle%@NL@%
        push    ds              %@AB@%; receives DOSOPEN action%@AE@%%@NL@%
        push    offset DGROUP:action%@NL@%
        push        0                %@AB@%; initial file size%@AE@%%@NL@%
        push    0%@NL@%
        push    0               %@AB@%; attribute = normal%@AE@%%@NL@%
        push    12h             %@AB@%; action: create/replace%@AE@%%@NL@%
        push    41h             %@AB@%; access: write-only%@AE@%%@NL@%
        push    0               %@AB@%; reserved DWORD 0%@AE@%%@NL@%
        push    0%@NL@%
        call    DosOpen         %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
                                %@AB@%; make stdin track%@AE@%%@NL@%
                                %@AB@%; input file handle...%@AE@%%@NL@%
        push    ihandle         %@AB@%; handle from DOSOPEN%@AE@%%@NL@%
        push    ds              %@AB@%; standard input handle%@AE@%%@NL@%
        push    offset DGROUP:newin%@NL@%
        call    DosDupHandle    %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
                                %@AB@%; make stdout track%@AE@%%@NL@%
                                %@AB@%; output file handle...%@AE@%%@NL@%
        push    ohandle         %@AB@%; handle from DOSOPEN%@AE@%%@NL@%
        push    ds              %@AB@%; standard output handle%@AE@%%@NL@%
        push    offset DGROUP:newout%@NL@%
        call    DosDupHandle    %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
                                %@AB@%; run SORT.EXE as child...%@AE@%%@NL@%
        push    ds              %@AB@%; receives failing dynlink%@AE@%%@NL@%
        push    offset DGROUP:objbuff%@NL@%
        push    objbuff_len     %@AB@%; length of buffer%@AE@%%@NL@%
        push    0               %@AB@%; 0 = synchronous execution%@AE@%%@NL@%
        push    0               %@AB@%; argument strings ptr%@AE@%%@NL@%
        push    0%@NL@%
        push    0               %@AB@%; environment pointer%@AE@%%@NL@%
        push    0%@NL@%
        push    ds              %@AB@%; receives PID, exit code%@AE@%%@NL@%
        push    offset DGROUP:pcodes%@NL@%
        push    ds              %@AB@%; child program pathname%@AE@%%@NL@%
        push    offset DGROUP:pname%@NL@%
        call    DosExecPgm      %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
                                %@AB@%; restore stdin handle%@AE@%%@NL@%
                                %@AB@%; to original meaning...%@AE@%%@NL@%
        push    oldin           %@AB@%; dup of original stdin%@AE@%%@NL@%
        push    ds              %@AB@%; standard input handle%@AE@%%@NL@%
        push    offset DGROUP:newin%@NL@%
        call    DosDupHandle    %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
                                %@AB@%; restore stdout handle%@AE@%%@NL@%
                                %@AB@%; to original meaning...%@AE@%%@NL@%
        push    oldout          %@AB@%; dup of original stdout%@AE@%%@NL@%
        push    ds              %@AB@%; standard output handle%@AE@%%@NL@%
        push    offset DGROUP:newout%@NL@%
        call    DosDupHandle    %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
        push    oldin           %@AB@%; close dup of stdin%@AE@%%@NL@%
        call    DosClose        %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
        push    oldout          %@AB@%; close dup of stdout%@AE@%%@NL@%
        call    DosClose        %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
        push    ihandle         %@AB@%; close input file%@AE@%%@NL@%
        call    DosClose        %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
        push    ohandle         %@AB@%; close output file%@AE@%%@NL@%
        call    DosClose        %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
                                %@AB@%; display success message...%@AE@%%@NL@%
        push    stdout          %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds              %@AB@%; address of message%@AE@%%@NL@%
        push    offset DGROUP:msg%@NL@%
        push    msg_len         %@AB@%; length of message%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:action%@NL@%
        call    DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main1           %@AB@%; exit if error%@AE@%%@NL@%
%@NL@%
                                %@AB@%; exit point if no errors%@AE@%%@NL@%
        push    1               %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0               %@AB@%; exit code = 0 (success)%@AE@%%@NL@%
        call    DosExit         %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main1:                          %@AB@%; exit point if error%@AE@%%@NL@%
        push    1               %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1               %@AB@%; exit code = 1 (error)%@AE@%%@NL@%
        call    DosExit%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main            %@AB@%; defines entry point%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FIND.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH16\FIND.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%        FIND.C%@NL@%
%@AB@%%@NL@%
%@AB@%        Searches text stream for a string.%@NL@%
%@AB@%%@NL@%
%@AB@%        Compile with:  C> cl find.c%@NL@%
%@AB@%%@NL@%
%@AB@%        Usage is:  C> find "pattern" [<source] [>destination]%@NL@%
%@AB@%%@NL@%
%@AB@%        Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
TAB     '\x09'                  %@AB@%/* ASCII tab (^I) */%@AE@%%@NL@%
BLANK   '\x20'                  %@AB@%/* ASCII space */%@AE@%%@NL@%
TAB_WIDTH 8                     %@AB@%/* columns per tab stop */%@AE@%%@NL@%
%@AI@%#define %@AE@%BUF_SIZE  256 %@NL@%
%@NL@%
static char input[BUF_SIZE];            %@AB@%/* input line buffer */%@AE@%%@NL@%
static char output[BUF_SIZE];           %@AB@%/* output line buffer */%@AE@%%@NL@%
static char pattern[BUF_SIZE];          %@AB@%/* search pattern buffer */%@AE@%%@NL@%
%@NL@%
void writeline(int, char *);            %@AB@%/* function prototype */%@AE@%%@NL@%
%@NL@%
main(int argc, char *argv[])%@NL@%
{   %@NL@%
    int line = 0;                       %@AB@%/* initialize line variable */%@AE@%%@NL@%
%@NL@%
    if(argc < 2)                        %@AB@%/* search pattern supplied? */%@AE@%%@NL@%
    {   %@NL@%
        puts("find: missing pattern");  %@AB@%/* abort if no search pattern */%@AE@%%@NL@%
        exit(1);%@NL@%
    }%@NL@%
%@NL@%
    strcpy(pattern,argv[1]);            %@AB@%/* save copy of search pattern */%@AE@%%@NL@%
    strupr(pattern);                    %@AB@%/* fold it to uppercase */%@AE@%%@NL@%
%@NL@%
    while(gets(input) != NULL)          %@AB@%/* read a line from input */%@AE@%%@NL@%
    {   %@NL@%
        line++;                         %@AB@%/* count lines */%@AE@%%@NL@%
%@NL@%
        strcpy(output, input);          %@AB@%/* save copy of input string */%@AE@%%@NL@%
        strupr(input);                  %@AB@%/* fold input to uppercase */%@AE@%%@NL@%
%@NL@%
        if(strstr(input, pattern))      %@AB@%/* if line contains pattern */%@AE@%%@NL@%
            writeline(line, output);    %@AB@%/* write it to standard output */%@AE@%%@NL@%
    }%@NL@%
    exit(0);                            %@AB@%/* terminate at end of file */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    WRITELINE: Write line number and text to standard output,%@NL@%
%@AB@%    expanding any tab characters to stops defined by TAB_WIDTH.%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
void writeline(int line, char *p)%@NL@%
{   %@NL@%
    int i = 0;                          %@AB@%/* index to input line */%@AE@%%@NL@%
    int col = 0;                        %@AB@%/* output column counter */%@AE@%%@NL@%
%@NL@%
    printf("\n%4d: ", line);            %@AB@%/* write line number */%@AE@%%@NL@%
%@NL@%
    while(p[i] != NULL)                 %@AB@%/* while not end of line */%@AE@%%@NL@%
    {   %@NL@%
        if(p[i] == TAB)                 %@AB@%/* if tab, expand it */%@AE@%%@NL@%
        {   %@NL@%
            do putchar(BLANK);%@NL@%
            while((++col % TAB_WIDTH) != 0);%@NL@%
        }%@NL@%
        else                            %@AB@%/* otherwise leave it alone */%@AE@%%@NL@%
        {       %@NL@%
            putchar(p[i]);              %@AB@%/* send character */%@AE@%%@NL@%
            col++;                      %@AB@%/* count columns */%@AE@%%@NL@%
        }%@NL@%
        i++;                            %@AB@%/* advance through input */%@AE@%%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%GETENV.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH03\GETENV.ASM%@AE@%%@NL@%
%@NL@%
        title   GETENV get environment string%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%; GETENV --- Return address and length of variable%@AE@%%@NL@%
%@AB@%;            portion of environment string (OS/2 version).%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    DS:SI = ASCIIZ env. variable name%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Returns:      ES:DI = address of env. variable%@AE@%%@NL@%
%@AB@%;               AX    = length (0 = not found)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Uses:         nothing%@AE@%%@NL@%
%@NL@%
        extrn   DosGetEnv:far   %@AB@%; OS/2 API function%@AE@%%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT%@NL@%
                                %@AB@%; local variables...%@AE@%%@NL@%
envseg  equ     [bp-2]          %@AB@%; environment segment%@AE@%%@NL@%
cmdoffs equ     [bp-4]          %@AB@%; command line offset%@AE@%%@NL@%
%@NL@%
        public  getenv          %@AB@%; make visible to Linker%@AE@%%@NL@%
%@NL@%
getenv  proc    near%@NL@%
%@NL@%
        enter   4,0             %@AB@%; allocate local variables%@AE@%%@NL@%
        push    cx              %@AB@%; save registers%@AE@%%@NL@%
        push    si%@NL@%
%@NL@%
        push    ss              %@AB@%; get selector for environment%@AE@%%@NL@%
        lea     ax,envseg       %@AB@%; and offset of command line%@AE@%%@NL@%
        push    ax%@NL@%
        push    ss%@NL@%
        lea     ax,cmdoffs%@NL@%
        push    ax%@NL@%
        call    DosGetEnv       %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; did function succeed?%@AE@%%@NL@%
        jz      get1            %@AB@%; jump if successful%@AE@%%@NL@%
%@NL@%
        xor     ax,ax           %@AB@%; DosGetEnv failed,%@AE@%%@NL@%
        jmp     get5            %@AB@%; return AX = 0%@AE@%%@NL@%
%@NL@%
get1:   mov     es,envseg       %@AB@%; set ES:BX = command line%@AE@%%@NL@%
        mov     cx,8000h        %@AB@%; assume max env. = 32 KB%@AE@%%@NL@%
        xor     di,di           %@AB@%; initial env. offset%@AE@%%@NL@%
        xor     ax,ax           %@AB@%; default length result%@AE@%%@NL@%
%@NL@%
get2:                           %@AB@%; check for end of environment%@AE@%%@NL@%
        cmp     byte ptr es:[di],0%@NL@%
        je      get5            %@AB@%; end reached, return AX = 0%@AE@%%@NL@%
%@NL@%
        pop     si              %@AB@%; initialize address of target%@AE@%%@NL@%
        push    si              %@AB@%; variable to be found%@AE@%%@NL@%
%@NL@%
        repe cmpsb              %@AB@%; compare target and env. strings%@AE@%%@NL@%
        cmp     byte ptr [si-1],0%@NL@%
        jne     get3            %@AB@%; jump if incomplete match%@AE@%%@NL@%
        cmp     byte ptr es:[di-1],'='%@NL@%
        je      get4            %@AB@%; jump if match was complete%@AE@%%@NL@%
%@NL@%
get3:                           %@AB@%; match was incomplete%@AE@%%@NL@%
        repne scasb             %@AB@%; scan for end of env. string%@AE@%%@NL@%
        jmp     get2            %@AB@%; and try again to match%@AE@%%@NL@%
%@NL@%
get4:   push    di              %@AB@%; save address after = sign%@AE@%%@NL@%
        repne scasb             %@AB@%; look for end of this string%@AE@%%@NL@%
        pop     ax              %@AB@%; get back starting address%@AE@%%@NL@%
        xchg    di,ax           %@AB@%; find string length%@AE@%%@NL@%
        sub     ax,di%@NL@%
        dec     ax              %@AB@%; don't include null byte%@AE@%%@NL@%
%@NL@%
get5:                           %@AB@%; common exit point%@AE@%%@NL@%
        pop     si              %@AB@%; restore registers%@AE@%%@NL@%
        pop     cx%@NL@%
        leave                   %@AB@%; discard local variables%@AE@%%@NL@%
        ret                     %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
getenv  endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%GETENV2.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH03\GETENV2.ASM%@AE@%%@NL@%
%@NL@%
        title   GETENV get environment string%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%; GETENV --- Return address and length of variable%@AE@%%@NL@%
%@AB@%;            portion of environment string (OS/2 version).%@AE@%%@NL@%
%@AB@%;            This version uses OS/2 API function DosScanEnv.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    DS:SI = ASCIIZ env. variable name%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Returns:      ES:DI = address of env. variable%@AE@%%@NL@%
%@AB@%;               AX    = length (0 = not found)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Uses:         nothing%@AE@%%@NL@%
%@NL@%
        extrn   DosScanEnv:far  %@AB@%; OS/2 API function%@AE@%%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT%@NL@%
                                %@AB@%; local variables...%@AE@%%@NL@%
valptr  equ     [bp-4]          %@AB@%; receives pointer to%@AE@%%@NL@%
                                %@AB@%; env. value string%@AE@%%@NL@%
%@NL@%
        public  getenv          %@AB@%; make visible to Linker%@AE@%%@NL@%
%@NL@%
getenv  proc    near%@NL@%
%@NL@%
        enter   4,0             %@AB@%; allocate local variable%@AE@%%@NL@%
        push    cx              %@AB@%; save register%@AE@%%@NL@%
%@NL@%
                                %@AB@%; call OS/2 to search%@AE@%%@NL@%
                                %@AB@%; environment block...%@AE@%%@NL@%
        push    ds              %@AB@%; address of name string%@AE@%%@NL@%
        push    si%@NL@%
        push    ss              %@AB@%; address to receive%@AE@%%@NL@%
        lea     ax,valptr       %@AB@%; pointer to value string%@AE@%%@NL@%
        push    ax%@NL@%
        call    DosScanEnv      %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; env. variable found?%@AE@%%@NL@%
        jz      get1            %@AB@%; jump if it exists%@AE@%%@NL@%
%@NL@%
        xor     ax,ax           %@AB@%; else return length=0%@AE@%%@NL@%
        jmp     get2%@NL@%
%@NL@%
get1:                           %@AB@%; load value string addr.%@AE@%%@NL@%
        les     di,dword ptr valptr%@NL@%
%@NL@%
        mov     cx,-1           %@AB@%; find length of string%@AE@%%@NL@%
        cld                     %@AB@%; by scanning for null%@AE@%%@NL@%
        xor     al,al%@NL@%
        repnz scasb%@NL@%
        not     cx%@NL@%
        dec     cx              %@AB@%; and let AX = length,%@AE@%%@NL@%
        mov     ax,cx           %@AB@%; ES:DI = address%@AE@%%@NL@%
        mov     di,word ptr valptr%@NL@%
%@NL@%
get2:                           %@AB@%; common exit point%@AE@%%@NL@%
        pop     cx              %@AB@%; restore registers%@AE@%%@NL@%
        leave                   %@AB@%; discard local variables%@AE@%%@NL@%
        ret                     %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
getenv  endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%HELLO.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH03\HELLO.ASM%@AE@%%@NL@%
%@NL@%
        title   HELLO -- Display Message on stdout%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; HELLO.EXE%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; A simple OS/2 assembly language program.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1986 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
stdin   equ     0          %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1          %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2          %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
        extrn   DosWrite:far%@NL@%
        extrn   DosExit:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
msg     db      0dh,0ah,"Hello World!",0dh,0ah%@NL@%
msg_len equ     $-msg%@NL@%
%@NL@%
wlen    dw      ?          %@AB@%; receives bytes written%@AE@%%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
print   proc    far%@NL@%
%@NL@%
        push    stdout     %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds         %@AB@%; address of data%@AE@%%@NL@%
        push    offset DGROUP:msg%@NL@%
        push    msg_len    %@AB@%; length of data%@AE@%%@NL@%
        push    ds         %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite   %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or        ax,ax      %@AB@%; was write successful?%@AE@%%@NL@%
        jnz        error      %@AB@%; jump if function failed%@AE@%%@NL@%
%@NL@%
        push    1          %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0          %@AB@%; return success code%@AE@%%@NL@%
        call    DosExit    %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
error:  push    1          %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1          %@AB@%; return error code%@AE@%%@NL@%
        call    DosExit    %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
print   endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     print%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LC.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH16\LC.ASM%@AE@%%@NL@%
%@NL@%
        title     LC.ASM --- lowercasing filter%@NL@%
        page      55,132%@NL@%
        .286%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; LC.ASM        Filter to translate upper case%@AE@%%@NL@%
%@AB@%;               chararacters to lower case.%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM LC;%@AE@%%@NL@%
%@AB@%;               LINK LC,,,OS2,LC;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        LC [<source] [>destination]%@AE@%%@NL@%
%@NL@%
stdin   equ     0                       %@AB@%; standard input device%@AE@%%@NL@%
stdout  equ     1                       %@AB@%; standard output device%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error device%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII linefeed%@AE@%%@NL@%
%@NL@%
bufsize equ     256                     %@AB@%; max amount to read or write%@AE@%%@NL@%
%@NL@%
        extrn   DosExit:far             %@AB@%; references to OS/2 API%@AE@%%@NL@%
        extrn   DosRead:far%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
input   db      bufsize dup (?)         %@AB@%; storage for input line%@AE@%%@NL@%
output  db      bufsize dup (?)         %@AB@%; storage for output line%@AE@%%@NL@%
%@NL@%
rlen    dw      ?                       %@AB@%; receives bytes read%@AE@%%@NL@%
wlen    dw      ?                       %@AB@%; receives bytes written%@AE@%%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far                     %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
        mov     ax,ds                   %@AB@%; make DGROUP addressable%@AE@%%@NL@%
        mov     es,ax                   %@AB@%; via ES register too%@AE@%%@NL@%
%@NL@%
main1:                                  %@AB@%; read line from standard input%@AE@%%@NL@%
        push    stdin                   %@AB@%; standard input handle%@AE@%%@NL@%
        push    ds                      %@AB@%; buffer address%@AE@%%@NL@%
        push    offset DGROUP:input%@NL@%
        push    bufsize                 %@AB@%; buffer length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes read%@AE@%%@NL@%
        push    offset DGROUP:rlen%@NL@%
        call    DosRead                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov     ax,rlen                 %@AB@%; get length of input%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; any characters read?%@AE@%%@NL@%
        jz      main2                   %@AB@%; jump if end of stream%@AE@%%@NL@%
%@NL@%
        call    translate               %@AB@%; translate line if necessary%@AE@%%@NL@%
%@NL@%
        or      ax,ax                   %@AB@%; anything to output?%@AE@%%@NL@%
        jz      main1                   %@AB@%; no, go read another line%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; write line to standard output%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; buffer address%@AE@%%@NL@%
        push    offset DGROUP:output%@NL@%
        push    ax                      %@AB@%; buffer length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp     main1                   %@AB@%; go read another line%@AE@%%@NL@%
%@NL@%
main2:                                  %@AB@%; end of stream reached%@AE@%%@NL@%
        push    1                       %@AB@%; 1 = end all threads%@AE@%%@NL@%
        push    0                       %@AB@%; 0 = exit code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; final exit to OS/2%@AE@%%@NL@%
%@NL@%
main    endp                            %@AB@%; end of main procedure%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%; Copy input buffer to output buffer, translating%@AE@%%@NL@%
%@AB@%; any upper case characters to lower case.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    AX = length of data in 'input' buffer.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Return:       AX = length to write to standard output.%@AE@%%@NL@%
%@NL@%
translate proc  near%@NL@%
%@NL@%
        push    ax                      %@AB@%; save original length%@AE@%%@NL@%
%@NL@%
        mov     si,offset DGROUP:input  %@AB@%; address of original line%@AE@%%@NL@%
        mov     di,offset DGROUP:output %@AB@%; address for converted line%@AE@%%@NL@%
        mov     cx,ax                   %@AB@%; length to convert%@AE@%%@NL@%
        jcxz    trans3                  %@AB@%; exit if empty line%@AE@%%@NL@%
%@NL@%
trans1:                                 %@AB@%; convert char. by char...%@AE@%%@NL@%
        lodsb                           %@AB@%; get input character%@AE@%%@NL@%
        cmp     al,'A'                  %@AB@%; if not A-Z, leave it alone%@AE@%%@NL@%
        jb      trans2%@NL@%
        cmp     al,'Z'%@NL@%
        ja      trans2%@NL@%
%@NL@%
        add     al,'a'-'A'              %@AB@%; it's A-Z, convert it%@AE@%%@NL@%
%@NL@%
trans2: stosb                           %@AB@%; put into output buffer%@AE@%%@NL@%
%@NL@%
        loop    trans1                  %@AB@%; loop until all characters%@AE@%%@NL@%
                                        %@AB@%; have been transferred%@AE@%%@NL@%
%@NL@%
trans3: pop     ax                      %@AB@%; get back line length%@AE@%%@NL@%
        ret                             %@AB@%; and return it in AX%@AE@%%@NL@%
%@NL@%
translate endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH16\LC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    LC.C    Filter to translate uppercase {A-Z} %@NL@%
%@AB@%            to lowercase {a-z} characters.%@NL@%
%@AB@%    Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%%@NL@%
%@AB@%    Compile:    CL lc.c%@NL@%
%@AB@%%@NL@%
%@AB@%    Usage:      LC  [<source]  [>destination]%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
STDIN   0                   %@AB@%/* standard input handle */%@AE@%%@NL@%
STDOUT  1                   %@AB@%/* standard output handle */%@AE@%%@NL@%
BUFSIZE 256                 %@AB@%/* I/O buffer size */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%API unsigned extern far pascal  %@NL@%
%@NL@%
API DosRead(unsigned, void far *, unsigned, unsigned far *);%@NL@%
API DosWrite(unsigned, void far *, unsigned, unsigned far *);%@NL@%
%@NL@%
static char input[BUFSIZE];         %@AB@%/* buffer for input line */%@AE@%%@NL@%
static char output[BUFSIZE];        %@AB@%/* buffer for output line */%@AE@%%@NL@%
%@NL@%
main(int argc,char argv)%@NL@%
{       %@NL@%
    int rlen,wlen;                  %@AB@%/* scratch variables */%@AE@%%@NL@%
%@NL@%
    while(1)                        %@AB@%/* do until end of file */%@AE@%%@NL@%
    {                               %@AB@%/* get line from standard input */%@AE@%%@NL@%
        DosRead(STDIN,input,BUFSIZE,&rlen);%@NL@%
        %@NL@%
        if(rlen == 0) exit(0);      %@AB@%/* exit if end of stream */%@AE@%%@NL@%
%@NL@%
                                    %@AB@%/* write translated line%@NL@%
%@AB@%                                       to standard output */%@AE@%%@NL@%
        DosWrite(STDOUT,output,translate(rlen),&wlen);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Translate upper case characters to lower%@NL@%
%@AB@%    case characters, leaving resulting text%@NL@%
%@AB@%    in output buffer and returning its length.%@NL@%
%@AB@%*/%@AE@%%@NL@%
int translate(int length)%@NL@%
{       %@NL@%
    int i;                          %@AB@%/* scratch variable */%@AE@%%@NL@%
%@NL@%
    memcpy(output,input,length);    %@AB@%/* copy input to output */%@AE@%%@NL@%
%@NL@%
    for(i = 0; i < length; i++)     %@AB@%/* lowercase the output */%@AE@%%@NL@%
    {       %@NL@%
        if(output[i] >= 'A' && output[i] <= 'Z') %@NL@%
            output[i] += 'a'-'A';%@NL@%
    }%@NL@%
    return(length);                 %@AB@%/* and return its length */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MOUDEMO.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH05\MOUDEMO.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    MOUDEMO.C   Simple demo of the OS/2 mouse API.%@NL@%
%@AB@%    Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%%@NL@%
%@AB@%    Compile with:  C> cl moudemo.c%@NL@%
%@AB@%%@NL@%
%@AB@%    Usage is:  C> moudemo%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%API unsigned extern far pascal %@NL@%
%@NL@%
API MouReadEventQue(void far *, unsigned far *, unsigned);%@NL@%
API MouOpen(void far *, unsigned far *);%@NL@%
API MouClose(unsigned);%@NL@%
API MouDrawPtr(unsigned);%@NL@%
API VioScrollUp(unsigned, unsigned, unsigned, unsigned, %@NL@%
                unsigned, char far *, unsigned);%@NL@%
API VioWrtCharStr(void far *, unsigned, unsigned, unsigned, unsigned);%@NL@%
%@NL@%
struct _MouEventInfo {  unsigned Flags;%@NL@%
                        unsigned long Timestamp;%@NL@%
                        unsigned Row;%@NL@%
                        unsigned Col;%@NL@%
                     }  MouEvent ;%@NL@%
%@NL@%
main(int argc, char *argv[])%@NL@%
{%@NL@%
    char OutStr[40];                    %@AB@%/* for output formatting */%@AE@%%@NL@%
    %@NL@%
    unsigned Cell = 0x0720;             %@AB@%/* ASCII space and%@NL@%
%@AB@%                                           normal attribute */%@AE@%%@NL@%
%@NL@%
    unsigned MouHandle;                 %@AB@%/* mouse logical handle */%@AE@%%@NL@%
    unsigned Status;                    %@AB@%/* returned from API */%@AE@%%@NL@%
    int WaitOption = 1;                 %@AB@%/* 1 = block for event,%@NL@%
%@AB@%                                           0 = do not block */%@AE@%%@NL@%
%@NL@%
    Status = MouOpen(0L, &MouHandle);   %@AB@%/* open mouse device */%@AE@%%@NL@%
%@NL@%
    if(Status)                          %@AB@%/* exit if no mouse */%@AE@%%@NL@%
    {   %@NL@%
        printf("\nMouOpen failed.\n");%@NL@%
        exit(1);%@NL@%
    }%@NL@%
                                        %@AB@%/* clear the screen */%@AE@%%@NL@%
    VioScrollUp(0, 0, -1, -1, -1, &(char)Cell, 0);%@NL@%
%@NL@%
    puts("Press Both Mouse Buttons To Exit");%@NL@%
%@NL@%
    MouDrawPtr(MouHandle);              %@AB@%/* display mouse cursor */%@AE@%%@NL@%
%@NL@%
    do                                  %@NL@%
    {                                   %@AB@%/* format mouse position */%@AE@%%@NL@%
        sprintf(OutStr, "X=%2d Y=%2d", MouEvent.Col, MouEvent.Row);%@NL@%
%@NL@%
                                        %@AB@%/* display mouse position */%@AE@%%@NL@%
        VioWrtCharStr(OutStr, strlen(OutStr), 0, 0, 0);%@NL@%
%@NL@%
                                        %@AB@%/* wait for a mouse event */%@AE@%%@NL@%
        MouReadEventQue(&MouEvent, &WaitOption, MouHandle);%@NL@%
        %@NL@%
                                        %@AB@%/* exit if both buttons down */%@AE@%%@NL@%
    } while((MouEvent.Flags & 0x14) != 0x14) ;%@NL@%
%@NL@%
    MouClose(MouHandle);                %@AB@%/* release mouse handle */%@AE@%%@NL@%
%@NL@%
    puts("Have a Mice Day!");           %@AB@%/* hail & farewell */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PORTIO.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH14\C\PORTIO.ASM%@AE@%%@NL@%
%@NL@%
        title        PORTIO --  Read/Write I/O Ports%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; PORTIO.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; General purpose port read/write routines for C or MASM programs.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm portio.asm;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; When this module is linked into a program, the following lines%@AE@%%@NL@%
%@AB@%; must be present in the program's module definition (DEF) file:%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; SEGMENTS%@AE@%%@NL@%
%@AB@%;   IO_TEXT IOPL%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; EXPORTS%@AE@%%@NL@%
%@AB@%;   RPORT 1%@AE@%%@NL@%
%@AB@%;   WPORT 2%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; The SEGMENTS and EXPORTS directives are recognized by the Linker%@AE@%%@NL@%
%@AB@%; and cause information to be built into the EXE file header for%@AE@%%@NL@%
%@AB@%; the OS/2 program loader.  The loader is signalled to give I/O%@AE@%%@NL@%
%@AB@%; privilege to code executing in the segment IO_TEXT, and to build%@AE@%%@NL@%
%@AB@%; call gates for the routines 'RPORT' and 'WPORT'.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
IO_TEXT segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:IO_TEXT%@NL@%
%@NL@%
%@NL@%
%@AB@%; RPORT: Read 8-bit data from I/O port.  Port address%@AE@%%@NL@%
%@AB@%; is passed on stack; data is returned in register AX%@AE@%%@NL@%
%@AB@%; with AH zeroed.  Other registers are unchanged.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; C syntax:     unsigned port, data;%@AE@%%@NL@%
%@AB@%;               data = rport(port);%@AE@%%@NL@%
%@NL@%
        public  rport%@NL@%
rport   proc    far%@NL@%
%@NL@%
        push    bp              %@AB@%; save registers and%@AE@%%@NL@%
        mov     bp,sp           %@AB@%; set up stack frame%@AE@%%@NL@%
        push    dx%@NL@%
%@NL@%
        mov     dx,[bp+6]       %@AB@%; get port number%@AE@%%@NL@%
        in      al,dx           %@AB@%; read the port%@AE@%%@NL@%
        xor     ah,ah           %@AB@%; clear upper 8 bits%@AE@%%@NL@%
%@NL@%
        pop     dx              %@AB@%; restore registers%@AE@%%@NL@%
        pop     bp%@NL@%
%@NL@%
        ret     2               %@AB@%; discard parameters,%@AE@%%@NL@%
                                %@AB@%; return port data in AX%@AE@%%@NL@%
rport   endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; WPORT: Write 8-bit data to I/O port.        Port address and%@AE@%%@NL@%
%@AB@%; data are passed on stack.  All registers are unchanged.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; C syntax:     unsigned port, data;%@AE@%%@NL@%
%@AB@%;               wport(port, data);%@AE@%%@NL@%
%@NL@%
        public  wport%@NL@%
wport   proc    far%@NL@%
%@NL@%
        push    bp              %@AB@%; save registers and%@AE@%%@NL@%
        mov     bp,sp           %@AB@%; set up stack frame%@AE@%%@NL@%
        push    ax%@NL@%
        push    dx%@NL@%
%@NL@%
        mov     ax,[bp+6]       %@AB@%; get data to write%@AE@%%@NL@%
        mov     dx,[bp+8]       %@AB@%; get port number%@AE@%%@NL@%
        out     dx,al           %@AB@%; write the port%@AE@%%@NL@%
%@NL@%
        pop     dx              %@AB@%; restore registers%@AE@%%@NL@%
        pop     ax%@NL@%
        pop     bp%@NL@%
%@NL@%
        ret     4               %@AB@%; discard parameters,%@AE@%%@NL@%
                                %@AB@%; return nothing%@AE@%%@NL@%
wport   endp%@NL@%
%@NL@%
IO_TEXT ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PORTIO.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH14\MASM\PORTIO.ASM%@AE@%%@NL@%
%@NL@%
        title        PORTIO --  Read/Write I/O Ports%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; PORTIO.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; General-purpose port read/write routines for C or MASM programs.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm portio.asm;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; When this module is linked into a program, the following lines%@AE@%%@NL@%
%@AB@%; must be present in the program's module definition (DEF) file:%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; SEGMENTS%@AE@%%@NL@%
%@AB@%;   IO_TEXT IOPL%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; EXPORTS%@AE@%%@NL@%
%@AB@%;   RPORT 1%@AE@%%@NL@%
%@AB@%;   WPORT 2%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; The SEGMENTS and EXPORTS directives are recognized by the Linker%@AE@%%@NL@%
%@AB@%; and cause information to be built into the EXE file header for%@AE@%%@NL@%
%@AB@%; the OS/2 program loader.  The loader is signalled to give I/O%@AE@%%@NL@%
%@AB@%; privilege to code executing in the segment IO_TEXT, and to build%@AE@%%@NL@%
%@AB@%; call gates for the routines 'rport' and 'wport'.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
IO_TEXT segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:IO_TEXT%@NL@%
%@NL@%
%@NL@%
%@AB@%; RPORT: Read 8-bit data from I/O port.  Port address%@AE@%%@NL@%
%@AB@%; is passed on stack; data is returned in register AX%@AE@%%@NL@%
%@AB@%; with AH zeroed.  Other registers are unchanged.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; C syntax:     unsigned port, data;%@AE@%%@NL@%
%@AB@%;               data = rport(port);%@AE@%%@NL@%
%@NL@%
        public  rport%@NL@%
rport   proc    far%@NL@%
%@NL@%
        push    bp              %@AB@%; save registers and%@AE@%%@NL@%
        mov     bp,sp           %@AB@%; set up stack frame%@AE@%%@NL@%
        push    dx%@NL@%
%@NL@%
        mov     dx,[bp+6]       %@AB@%; get port number%@AE@%%@NL@%
        in      al,dx           %@AB@%; read the port%@AE@%%@NL@%
        xor     ah,ah           %@AB@%; clear upper 8 bits%@AE@%%@NL@%
%@NL@%
        pop     dx              %@AB@%; restore registers%@AE@%%@NL@%
        pop     bp%@NL@%
%@NL@%
        ret     2               %@AB@%; discard parameters,%@AE@%%@NL@%
                                %@AB@%; return port data in AX%@AE@%%@NL@%
rport   endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; WPORT: Write 8-bit data to I/O port.        Port address and%@AE@%%@NL@%
%@AB@%; data are passed on stack.  All registers are unchanged.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; C syntax:     unsigned port, data;%@AE@%%@NL@%
%@AB@%;               wport(port, data);%@AE@%%@NL@%
%@NL@%
        public  wport%@NL@%
wport   proc    far%@NL@%
%@NL@%
        push    bp              %@AB@%; save registers and%@AE@%%@NL@%
        mov     bp,sp           %@AB@%; set up stack frame%@AE@%%@NL@%
        push    ax%@NL@%
        push    dx%@NL@%
%@NL@%
        mov     ax,[bp+6]       %@AB@%; get data to write%@AE@%%@NL@%
        mov     dx,[bp+8]       %@AB@%; get port number%@AE@%%@NL@%
        out     dx,al           %@AB@%; write the port%@AE@%%@NL@%
%@NL@%
        pop     dx              %@AB@%; restore registers%@AE@%%@NL@%
        pop     ax%@NL@%
        pop     bp%@NL@%
%@NL@%
        ret     4               %@AB@%; discard parameters,%@AE@%%@NL@%
                                %@AB@%; return nothing%@AE@%%@NL@%
wport   endp%@NL@%
%@NL@%
IO_TEXT ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PORTS.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH14\MASM\PORTS.ASM%@AE@%%@NL@%
%@NL@%
        title   PORTS -- IOPL Demo Program%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; PORTS.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; An OS/2 IOPL demonstration program with that reads and displays the%@AE@%%@NL@%
%@AB@%; first 256 I/O ports.        Requires the separate module PORTIO.ASM.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm ports.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link ports+portio,ports,,os2,ports%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage is:  C> ports%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf        equ        0ah                        %@AB@%; ASCII linefeed%@AE@%%@NL@%
blank   equ     20h                     %@AB@%; ASCII space code%@AE@%%@NL@%
%@NL@%
stdout  equ     1                       %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
bport   equ     0                       %@AB@%; first port to display%@AE@%%@NL@%
eport   equ     255                     %@AB@%; last port to display%@AE@%%@NL@%
request equ     0                       %@AB@%; request port access%@AE@%%@NL@%
release equ     1                       %@AB@%; release port access%@AE@%%@NL@%
%@NL@%
        extrn   DosPortAccess:far       %@AB@%; kernel API functions%@AE@%%@NL@%
        extrn   DosWrite:far%@NL@%
        extrn   DosExit:far%@NL@%
%@NL@%
        extrn   rport:far               %@AB@%; PORTIO.ASM functions%@AE@%%@NL@%
        extrn   wport:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
wlen    dw      0                       %@AB@%; actual number of bytes%@AE@%%@NL@%
                                        %@AB@%; written by DosWrite%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf                   %@AB@%; error message%@AE@%%@NL@%
        db      'DosPortAccess failed.'%@NL@%
        db      cr,lf%@NL@%
msg1_len equ    $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf                   %@AB@%; heading%@AE@%%@NL@%
        db      '        0  1  2  3  4  5  6'%@NL@%
        db      '  7  8  9  A  B  C  D  E  F'%@NL@%
msg2_len equ    $-msg2%@NL@%
%@NL@%
msg3    db      cr,lf                   %@AB@%; display port number%@AE@%%@NL@%
msg3a   db      'NNNN  '%@NL@%
msg3_len equ    $-msg3%@NL@%
%@NL@%
msg4    db      ' '                     %@AB@%; display port data%@AE@%%@NL@%
msg4a   db      'NN'%@NL@%
msg4_len equ    $-msg4%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far                     %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; make DGROUP addressable%@AE@%%@NL@%
        pop     es                      %@AB@%; with ES too%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; request port access...%@AE@%%@NL@%
        push    0                       %@AB@%; reserved%@AE@%%@NL@%
        push    request                 %@AB@%; request/release%@AE@%%@NL@%
        push    bport                   %@AB@%; first port number%@AE@%%@NL@%
        push    eport                   %@AB@%; last port number%@AE@%%@NL@%
        call    DosPortAccess           %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; call successful?%@AE@%%@NL@%
        jz      main1                   %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display error message...%@AE@%%@NL@%
        push    stderr                  %@AB@%; standard error handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg1%@NL@%
        push    msg1_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; now terminate process...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push        1                        %@AB@%; return code = 1 (error)%@AE@%%@NL@%
        call    DosExit                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main1:                                  %@AB@%; print heading...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of heading%@AE@%%@NL@%
        push    offset DGROUP:msg2%@NL@%
        push    msg2_len                %@AB@%; length of heading%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov     dx,bport                %@AB@%; initialize port number%@AE@%%@NL@%
%@NL@%
main2:  test    dx,0fh                  %@AB@%; new line needed?%@AE@%%@NL@%
        jnz     main3                   %@AB@%; no, jump%@AE@%%@NL@%
%@NL@%
        mov     ax,dx                   %@AB@%; convert port number%@AE@%%@NL@%
        mov     di,offset DGROUP:msg3a  %@AB@%; to ASCII for display%@AE@%%@NL@%
        call    wtoa%@NL@%
%@NL@%
                                        %@AB@%; display port number...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg3%@NL@%
        push    msg3_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main3:  push    dx                      %@AB@%; call 'rport' to read port%@AE@%%@NL@%
        call    rport                   %@AB@%; returns AX = data%@AE@%%@NL@%
%@NL@%
        mov     di,offset msg4a         %@AB@%; convert port data%@AE@%%@NL@%
        call    btoa                    %@AB@%; to ASCII for display%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display port data...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg4%@NL@%
        push    msg4_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        inc     dx                      %@AB@%; increment port number%@AE@%%@NL@%
        cmp     dx,eport                %@AB@%; done with all ports?%@AE@%%@NL@%
        jbe     main2                   %@AB@%; not yet, read another%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; release port access...%@AE@%%@NL@%
        push    0                       %@AB@%; reserved%@AE@%%@NL@%
        push    release                 %@AB@%; request/release%@AE@%%@NL@%
        push    bport                   %@AB@%; first port number%@AE@%%@NL@%
        push    eport                   %@AB@%; last port number%@AE@%%@NL@%
        call    DosPortAccess           %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; final exit to OS/2...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push        0                        %@AB@%; return code = 0 (success)%@AE@%%@NL@%
        call    DosExit                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
%@AB@%; WTOA:         Convert word to hex ASCII%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    AX    = data to convert%@AE@%%@NL@%
%@AB@%;               ES:DI = storage address%@AE@%%@NL@%
%@AB@%; Returns:      nothing%@AE@%%@NL@%
%@AB@%; Uses:         AX, CL, DI%@AE@%%@NL@%
%@NL@%
wtoa    proc    near%@NL@%
%@NL@%
        push    ax                      %@AB@%; save original value%@AE@%%@NL@%
        mov     al,ah%@NL@%
        call    btoa                    %@AB@%; convert upper byte%@AE@%%@NL@%
%@NL@%
        pop     ax                      %@AB@%; restore original value%@AE@%%@NL@%
        call    btoa                    %@AB@%; convert lower byte%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
wtoa    endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; BTOA:         Convert byte to hex ASCII%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    AL    = data to convert%@AE@%%@NL@%
%@AB@%;               ES:DI = storage address%@AE@%%@NL@%
%@AB@%; Returns:      nothing%@AE@%%@NL@%
%@AB@%; Uses:         AX, CL, DI%@AE@%%@NL@%
%@NL@%
btoa    proc    near%@NL@%
%@NL@%
        sub     ah,ah                   %@AB@%; clear upper byte%@AE@%%@NL@%
%@NL@%
        mov     cl,16                   %@AB@%; divide by 16%@AE@%%@NL@%
        div     cl%@NL@%
%@NL@%
        call    ascii                   %@AB@%; convert quotient%@AE@%%@NL@%
        stosb                           %@AB@%; store ASCII character%@AE@%%@NL@%
%@NL@%
        mov     al,ah%@NL@%
        call    ascii                   %@AB@%; convert remainder%@AE@%%@NL@%
        stosb                           %@AB@%; store ASCII character%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
btoa    endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; ASCII:        Convert nibble to hex ASCII%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    AL    = data to convert in low 4 bits%@AE@%%@NL@%
%@AB@%; Returns:      AL    = ASCII character%@AE@%%@NL@%
%@AB@%; Uses:         nothing%@AE@%%@NL@%
%@NL@%
ascii   proc    near%@NL@%
%@NL@%
        add     al,'0'                  %@AB@%; add base ASCII value%@AE@%%@NL@%
        cmp     al,'9'                  %@AB@%; is it in range 0-9?%@AE@%%@NL@%
        jle     ascii2                  %@AB@%; jump if it is%@AE@%%@NL@%
%@NL@%
        add     al,'A'-'9'-1            %@AB@%; no, adjust for range A-F%@AE@%%@NL@%
%@NL@%
ascii2: ret                                %@AB@%; return ASCII character in AL%@AE@%%@NL@%
%@NL@%
ascii   endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main                    %@AB@%; defines entry point%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PORTS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH14\C\PORTS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%        PORTS.C%@NL@%
%@AB@%%@NL@%
%@AB@%        An OS/2 IOPL demonstration program that reads and displays the%@NL@%
%@AB@%        first 256 I/O ports.  Requires the separate module PORTIO.ASM.%@NL@%
%@AB@%%@NL@%
%@AB@%        Compile with:  C> cl /c ports.c%@NL@%
%@AB@%        Link with:  C> link ports+portio,ports,,os2,ports%@NL@%
%@AB@%%@NL@%
%@AB@%        Usage is:  C> ports%@NL@%
%@AB@%%@NL@%
%@AB@%        Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%API extern far pascal %@NL@%
%@NL@%
unsigned API rport(unsigned);           %@AB@%/* function prototypes */%@AE@%%@NL@%
void     API wport(unsigned, unsigned);%@NL@%
void     API DosSleep(unsigned long);%@NL@%
unsigned API DosPortAccess(unsigned, unsigned, unsigned, unsigned);%@NL@%
%@NL@%
                                %@AB@%/* parameters for DosPortAccess */%@AE@%%@NL@%
REQUEST 0                       %@AB@%/* request port */%@AE@%%@NL@%
RELEASE 1                       %@AB@%/* release port */%@AE@%%@NL@%
BPORT   0                       %@AB@%/* beginning port */%@AE@%%@NL@%
EPORT   255                     %@AB@%/* ending port */%@AE@%%@NL@%
%@NL@%
main(int argc, char *argv[])%@NL@%
{%@NL@%
    int i;                              %@AB@%/* scratch variable */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* request port access */%@AE@%%@NL@%
    if(DosPortAccess(0, REQUEST, BPORT, EPORT))%@NL@%
    {   %@NL@%
        printf("\nDosPortAccess failed.\n");%@NL@%
        exit(1);%@NL@%
    }%@NL@%
%@NL@%
    printf("\n      ");                 %@AB@%/* print title line */%@AE@%%@NL@%
    for(i=0; i<16; i++) printf(" %2X", i);%@NL@%
%@NL@%
    for(i=BPORT; i<=EPORT; i++)         %@AB@%/* loop through all ports */%@AE@%%@NL@%
    {%@NL@%
        if((i & 0x0f)==0)%@NL@%
        {%@NL@%
            printf("\n%04X  ", i);      %@AB@%/* new line needed */%@AE@%%@NL@%
        }%@NL@%
%@NL@%
        printf(" %02X", rport(i));        %@AB@%/* read and display port */%@AE@%%@NL@%
    }%@NL@%
                                        %@AB@%/* release port access */%@AE@%%@NL@%
    DosPortAccess(0, RELEASE, BPORT, EPORT);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PROTO.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH16\PROTO.ASM%@AE@%%@NL@%
%@NL@%
        title          PROTO -- Filter Template%@NL@%
        page      55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; PROTO.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; MASM filter template for OS/2.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm proto.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link proto,,,os2;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage is:  C> proto <source >destination%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
stdin   equ     0               %@AB@%; standard input device%@AE@%%@NL@%
stdout  equ     1               %@AB@%; standard output device%@AE@%%@NL@%
stderr  equ     2               %@AB@%; standard error device%@AE@%%@NL@%
%@NL@%
cr      equ     0dh             %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah             %@AB@%; ASCII linefeed%@AE@%%@NL@%
%@NL@%
bufsize equ     256             %@AB@%; I/O buffer size%@AE@%%@NL@%
%@NL@%
        extrn   DosRead:far%@NL@%
        extrn   DosWrite:far%@NL@%
        extrn   DosExit:far%@NL@%
%@NL@%
%@NL@%
DGROUP  group   _DATA           %@AB@%; 'automatic data group'%@AE@%%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
input   db      bufsize dup (?) %@AB@%; storage for input line%@AE@%%@NL@%
output  db      bufsize dup (?) %@AB@%; storage for output line%@AE@%%@NL@%
%@NL@%
rlen    dw      ?               %@AB@%; receives bytes read%@AE@%%@NL@%
wlen    dw      ?               %@AB@%; receives bytes written%@AE@%%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far             %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
        push    ds              %@AB@%; make DGROUP addressable%@AE@%%@NL@%
        pop     es              %@AB@%; via ES register too%@AE@%%@NL@%
        assume  es:DGROUP%@NL@%
%@NL@%
        cld                     %@AB@%; safety first%@AE@%%@NL@%
%@NL@%
main1:                          %@AB@%; read line from standard input...%@AE@%%@NL@%
        push    stdin           %@AB@%; standard input handle%@AE@%%@NL@%
        push    ds              %@AB@%; buffer address%@AE@%%@NL@%
        push    offset DGROUP:input%@NL@%
        push    bufsize         %@AB@%; buffer length%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes read%@AE@%%@NL@%
        push    offset DGROUP:rlen%@NL@%
        call    DosRead         %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; was read successful?%@AE@%%@NL@%
        jnz     main3           %@AB@%; exit if any error%@AE@%%@NL@%
%@NL@%
        mov     ax,rlen         %@AB@%; get length of input%@AE@%%@NL@%
        or      ax,ax           %@AB@%; any characters read?%@AE@%%@NL@%
        jz      main2           %@AB@%; jump if end of stream%@AE@%%@NL@%
%@NL@%
        call    translate       %@AB@%; translate line if necessary%@AE@%%@NL@%
%@NL@%
        or      ax,ax           %@AB@%; anything to output?%@AE@%%@NL@%
        jz      main1           %@AB@%; no, go read another line%@AE@%%@NL@%
%@NL@%
                                %@AB@%; write line to standard output...%@AE@%%@NL@%
        push    stdout          %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds              %@AB@%; buffer address%@AE@%%@NL@%
        push    offset DGROUP:output%@NL@%
        push    ax              %@AB@%; buffer length%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; write successful?%@AE@%%@NL@%
        jnz     main3           %@AB@%; exit if any error%@AE@%%@NL@%
%@NL@%
        jmp     main1           %@AB@%; go read another line%@AE@%%@NL@%
%@NL@%
main2:                          %@AB@%; end of stream reached%@AE@%%@NL@%
        push    1               %@AB@%; 1 = end all threads%@AE@%%@NL@%
        push    0               %@AB@%; 0 = exit code%@AE@%%@NL@%
        call    DosExit         %@AB@%; final exit to OS/2%@AE@%%@NL@%
%@NL@%
main3:                          %@AB@%; error encountered%@AE@%%@NL@%
        push    1               %@AB@%; 1 = end all threads%@AE@%%@NL@%
        push    1               %@AB@%; 1 = exit code%@AE@%%@NL@%
        call    DosExit         %@AB@%; final exit to OS/2%@AE@%%@NL@%
%@NL@%
main    endp                    %@AB@%; end of main procedure%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%; Perform any necessary translation on line stored in%@AE@%%@NL@%
%@AB@%; 'input' buffer, leaving result in 'output' buffer.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:        AX = length of data in 'input' buffer%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Return:        AX = length to write to standard output%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Action of template routine is just to copy the line.%@AE@%%@NL@%
%@NL@%
translate proc  near%@NL@%
%@NL@%
                                %@AB@%; copy input to output...%@AE@%%@NL@%
        mov     si,offset DGROUP:input%@NL@%
        mov     di,offset DGROUP:output%@NL@%
        mov     cx,ax%@NL@%
        rep movsb%@NL@%
        ret                     %@AB@%; return AX = length unchanged%@AE@%%@NL@%
%@NL@%
translate endp%@NL@%
%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main            %@AB@%; program entry point%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PROTO.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH16\PROTO.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%        PROTO.C%@NL@%
%@AB@%%@NL@%
%@AB@%        A filter template for OS/2.%@NL@%
%@AB@%%@NL@%
%@AB@%        Compile with:  C> cl proto.c%@NL@%
%@AB@%%@NL@%
%@AB@%        Usage is:  C> proto <source >destination%@NL@%
%@AB@%%@NL@%
%@AB@%        Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
STDIN   0                   %@AB@%/* standard input handle */%@AE@%%@NL@%
STDOUT  1                   %@AB@%/* standard output handle */%@AE@%%@NL@%
BUFSIZE 256                 %@AB@%/* I/O buffer size */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%API unsigned extern far pascal  %@NL@%
%@NL@%
API DosRead(unsigned, void far *, unsigned, unsigned far *);%@NL@%
API DosWrite(unsigned, void far *, unsigned, unsigned far *);%@NL@%
%@NL@%
static char input[BUFSIZE];         %@AB@%/* buffer for input line */%@AE@%%@NL@%
static char output[BUFSIZE];        %@AB@%/* buffer for output line */%@AE@%%@NL@%
%@NL@%
main(int argc,char *argv[])%@NL@%
{       %@NL@%
    int rlen, wlen;                 %@AB@%/* scratch variables */%@AE@%%@NL@%
%@NL@%
    while(1)                        %@AB@%/* do until end of file */%@AE@%%@NL@%
    {       %@NL@%
                                    %@AB@%/* get line from standard%@NL@%
%@AB@%                                       input stream */%@AE@%%@NL@%
        if(DosRead(STDIN, input, BUFSIZE, &rlen)) %@NL@%
            exit(1);                    %@AB@%/* exit if read error */%@AE@%%@NL@%
%@NL@%
        if(rlen == 0) exit(0);      %@AB@%/* exit if end of stream */%@AE@%%@NL@%
%@NL@%
                                    %@AB@%/* write translated line to%@NL@%
%@AB@%                                       standard output stream */%@AE@%%@NL@%
        if(DosWrite(STDOUT, output, translate(rlen), &wlen)) %@NL@%
            exit(1);                %@AB@%/* exit if write error */%@AE@%%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Perform any necessary translation on input line, %@NL@%
%@AB@%    leaving the resulting text in output buffer.  %@NL@%
%@AB@%    Returns length of translated line (may be zero).%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
int translate(int length)%@NL@%
{       %@NL@%
    memcpy(output,input,length);    %@AB@%/* template action is */%@AE@%%@NL@%
                                    %@AB@%/* to copy input line */%@AE@%%@NL@%
    return(length);                 %@AB@%/* and return its length */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%QFN.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH09\QFN.ASM%@AE@%%@NL@%
%@NL@%
        title   QFN.ASM --- qualify file name%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%; QFN.ASM -- Qualify File Name (OS/2 Version)%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    DS:SI = filename address%@AE@%%@NL@%
%@AB@%;               AX    = length%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Returns:      Carry = clear if filename OK%@AE@%%@NL@%
%@AB@%;               DS:SI = qualified filename%@AE@%%@NL@%
%@AB@%;               AX    = length%@AE@%%@NL@%
%@AB@%;               or%@AE@%%@NL@%
%@AB@%;               Carry = set if bad filename%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;               Registers other than DS:SI%@AE@%%@NL@%
%@AB@%;               and AX are preserved.%@AE@%%@NL@%
%@NL@%
        extrn   DosChDir:far    %@AB@%; OS/2 API functions%@AE@%%@NL@%
        extrn   DosQCurDisk:far%@NL@%
        extrn   DosQCurDir:far%@NL@%
        extrn   DosSelectDisk:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
cdrive  dw      0               %@AB@%; current drive%@AE@%%@NL@%
cpath   db      '\',64 dup (0)  %@AB@%; current directory%@AE@%%@NL@%
cpsiz   dw      $-cpath-1%@NL@%
drvmap  dd      ?               %@AB@%; valid drive bitmap%@AE@%%@NL@%
ndrive  dw      0               %@AB@%; new drive%@AE@%%@NL@%
%@NL@%
tbuff   db      64 dup (0)      %@AB@%; target directory%@AE@%%@NL@%
%@NL@%
qbuff   db      'X:\'           %@AB@%; qualified pathname%@AE@%%@NL@%
        db      64 dup (0)%@NL@%
qbsiz   dw      $-qbuff-3%@NL@%
%@NL@%
fname   dw      ?               %@AB@%; filename address%@AE@%%@NL@%
flen    dw      ?               %@AB@%; filename length%@AE@%%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
        public  qfn             %@AB@%; make visible to Linker%@AE@%%@NL@%
%@NL@%
qfn     proc    near            %@AB@%; qualify file name%@AE@%%@NL@%
%@NL@%
        push    bx              %@AB@%; save registers%@AE@%%@NL@%
        push    cx%@NL@%
        push    dx%@NL@%
        push    di%@NL@%
        push    es%@NL@%
%@NL@%
        mov     flen,ax         %@AB@%; save length and%@AE@%%@NL@%
        mov     fname,si        %@AB@%; address of filename%@AE@%%@NL@%
%@NL@%
        mov     ax,ds           %@AB@%; make DGROUP addressable%@AE@%%@NL@%
        mov     es,ax           %@AB@%; with ES register%@AE@%%@NL@%
%@NL@%
                                %@AB@%; save current drive...%@AE@%%@NL@%
        push    ds              %@AB@%; receives drive ID%@AE@%%@NL@%
        push    offset DGROUP:cdrive%@NL@%
        push    ds              %@AB@%; receives valid drive bitmap%@AE@%%@NL@%
        push    offset DGROUP:drvmap%@NL@%
        call    DosQCurDisk     %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; save current directory...%@AE@%%@NL@%
        push    0               %@AB@%; drive ID = current%@AE@%%@NL@%
        push    ds              %@AB@%; receives directory path%@AE@%%@NL@%
        push    offset DGROUP:cpath+1%@NL@%
        push    ds              %@AB@%; contains buffer length%@AE@%%@NL@%
        push    offset DGROUP:cpsiz%@NL@%
        call    DosQCurDir      %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; did caller specify drive?%@AE@%%@NL@%
        mov     di,fname        %@AB@%; get address of name%@AE@%%@NL@%
        mov     cx,flen         %@AB@%; get length of name%@AE@%%@NL@%
%@NL@%
        cmp     cx,2            %@AB@%; if drive, length must%@AE@%%@NL@%
                                %@AB@%; be >= 2 chars.%@AE@%%@NL@%
        jl      qfn2            %@AB@%; too short, no drive%@AE@%%@NL@%
%@NL@%
                                %@AB@%; check for drive delimiter%@AE@%%@NL@%
        cmp     byte ptr [di+1],':'%@NL@%
        jne     qfn2            %@AB@%; no delimiter, jump%@AE@%%@NL@%
%@NL@%
        mov     al,[di]         %@AB@%; get ASCII drive code%@AE@%%@NL@%
        or      al,20h          %@AB@%; fold to lower case%@AE@%%@NL@%
        sub     al,'a'-1        %@AB@%; convert it to binary%@AE@%%@NL@%
        xor     ah,ah%@NL@%
%@NL@%
                                %@AB@%; now select new drive%@AE@%%@NL@%
        push    ax              %@AB@%; binary drive ID%@AE@%%@NL@%
        call    DosSelectDisk   %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; was drive valid?%@AE@%%@NL@%
        jz      qfn1            %@AB@%; jump, drive was OK%@AE@%%@NL@%
        jmp     qfn8            %@AB@%; exit, drive not valid%@AE@%%@NL@%
%@NL@%
qfn1:   add     di,2            %@AB@%; bump pointer past drive%@AE@%%@NL@%
        sub     cx,2            %@AB@%; and decrement length%@AE@%%@NL@%
%@NL@%
qfn2:                           %@AB@%; get current directory%@AE@%%@NL@%
                                %@AB@%; again for new drive...%@AE@%%@NL@%
        push    0               %@AB@%; drive ID = current%@AE@%%@NL@%
        push    ds              %@AB@%; receives directory path%@AE@%%@NL@%
        push    offset DGROUP:cpath+1%@NL@%
        push    ds              %@AB@%; contains buffer length%@AE@%%@NL@%
        push    offset DGROUP:cpsiz%@NL@%
        call    DosQCurDir      %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; scan off path if any%@AE@%%@NL@%
        push    di              %@AB@%; save start of path%@AE@%%@NL@%
        mov     al,'\'          %@AB@%; path delimiter%@AE@%%@NL@%
%@NL@%
qfn3:   mov     fname,di        %@AB@%; save path pointer%@AE@%%@NL@%
        mov     flen,cx         %@AB@%; save path length%@AE@%%@NL@%
        jcxz    qfn4            %@AB@%; jump if none left%@AE@%%@NL@%
%@NL@%
        repne scasb             %@AB@%; any '\' left in path?%@AE@%%@NL@%
        je      qfn3            %@AB@%; loop if '\' found%@AE@%%@NL@%
%@NL@%
qfn4:   pop     si              %@AB@%; recover starting address%@AE@%%@NL@%
                                %@AB@%; of path portion%@AE@%%@NL@%
%@NL@%
                                %@AB@%; copy path to local buffer%@AE@%%@NL@%
                                %@AB@%; and make it ASCIIZ...%@AE@%%@NL@%
        mov     di,offset DGROUP:tbuff%@NL@%
        mov     cx,fname        %@AB@%; calculate path length%@AE@%%@NL@%
        sub     cx,si%@NL@%
        jz      qfn6            %@AB@%; jump, no path at all%@AE@%%@NL@%
        cmp     cx,1            %@AB@%; root directory?%@AE@%%@NL@%
        je      qfn5            %@AB@%; jump if root%@AE@%%@NL@%
        dec     cx              %@AB@%; else discard last '\'%@AE@%%@NL@%
%@NL@%
qfn5:   rep movsb               %@AB@%; transfer path and%@AE@%%@NL@%
        xor     al,al           %@AB@%; append null byte%@AE@%%@NL@%
        stosb%@NL@%
%@NL@%
                                %@AB@%; select target directory...%@AE@%%@NL@%
        push    ds              %@AB@%; directory path address%@AE@%%@NL@%
        push    offset DGROUP:tbuff%@NL@%
        push    0               %@AB@%; DWORD reserved%@AE@%%@NL@%
        push    0%@NL@%
        call    DosChDir        %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; directory valid?%@AE@%%@NL@%
        jnz     qfn8            %@AB@%; jump, no such directory%@AE@%%@NL@%
%@NL@%
qfn6:                           %@AB@%; build up full pathname...%@AE@%%@NL@%
                                %@AB@%; get current drive%@AE@%%@NL@%
        push    ds              %@AB@%; receives drive ID%@AE@%%@NL@%
        push    offset DGROUP:ndrive%@NL@%
        push    ds              %@AB@%; receives valid drive bitmap%@AE@%%@NL@%
        push    offset DGROUP:drvmap%@NL@%
        call    DosQCurDisk     %@AB@%; transfer to OS/2%@AE@%%@NL@%
        mov     ax,ndrive       %@AB@%; convert binary drive code%@AE@%%@NL@%
        add     ax,'a'-1        %@AB@%; to ASCII drive identifier%@AE@%%@NL@%
        mov     qbuff,al%@NL@%
%@NL@%
                                %@AB@%; get current directory%@AE@%%@NL@%
        push    0               %@AB@%; drive ID = current%@AE@%%@NL@%
        push    ds              %@AB@%; receives directory path%@AE@%%@NL@%
        push    offset DGROUP:qbuff+3%@NL@%
        push    ds              %@AB@%; contains buffer length%@AE@%%@NL@%
        push    offset DGROUP:qbsiz%@NL@%
        call    DosQCurDir      %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax           %@AB@%; operation successful?%@AE@%%@NL@%
        jnz     qfn8            %@AB@%; no, return error%@AE@%%@NL@%
%@NL@%
                                %@AB@%; point to path component%@AE@%%@NL@%
        mov     di,offset DGROUP:qbuff+3%@NL@%
        cmp     byte ptr [di],0 %@AB@%; is current directory%@AE@%%@NL@%
                                %@AB@%; the root directory?%@AE@%%@NL@%
        je      qfn7            %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
        xor     al,al           %@AB@%; scan for null byte at%@AE@%%@NL@%
        mov     cx,-1           %@AB@%; end of path name%@AE@%%@NL@%
        repne scasb             %@AB@%; and append backslash%@AE@%%@NL@%
        mov     byte ptr [di-1],'\'%@NL@%
%@NL@%
qfn7:                           %@AB@%; now append filename%@AE@%%@NL@%
                                %@AB@%; to drive and path...%@AE@%%@NL@%
        mov     si,fname        %@AB@%; filename address%@AE@%%@NL@%
        cmp     byte ptr [si],'.'%@NL@%
        je      qfn8            %@AB@%; exit if directory alias%@AE@%%@NL@%
        mov     cx,flen         %@AB@%; filename length%@AE@%%@NL@%
        rep movsb               %@AB@%; copy it%@AE@%%@NL@%
%@NL@%
                                %@AB@%; set DS:SI = address%@AE@%%@NL@%
        mov     si,offset DGROUP:qbuff%@NL@%
        mov     ax,di           %@AB@%; and AX = length of%@AE@%%@NL@%
        sub     ax,si           %@AB@%; fully qualified filename%@AE@%%@NL@%
%@NL@%
        call    makelc          %@AB@%; fold filename to lower%@AE@%%@NL@%
                                %@AB@%; case to make it pretty%@AE@%%@NL@%
%@NL@%
        clc                     %@AB@%; set Carry = false to%@AE@%%@NL@%
                                %@AB@%; indicate success and%@AE@%%@NL@%
        jmp     qfn9            %@AB@%; go to common exit point%@AE@%%@NL@%
%@NL@%
qfn8:                           %@AB@%; come here if any%@AE@%%@NL@%
                                %@AB@%; error detected...%@AE@%%@NL@%
        stc                     %@AB@%; set Carry = true to%@AE@%%@NL@%
                                %@AB@%; indicate error%@AE@%%@NL@%
%@NL@%
qfn9:   pushf                   %@AB@%; save Carry flag%@AE@%%@NL@%
        push    ax              %@AB@%; save final length%@AE@%%@NL@%
%@NL@%
                                %@AB@%; restore original directory%@AE@%%@NL@%
        push    ds              %@AB@%; address of directory path%@AE@%%@NL@%
        push    offset DGROUP:cpath%@NL@%
        push    0               %@AB@%; DWORD reserved%@AE@%%@NL@%
        push    0%@NL@%
        call    DosChDir        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; restore original drive%@AE@%%@NL@%
        push    cdrive          %@AB@%; binary drive ID%@AE@%%@NL@%
        call    DosSelectDisk%@NL@%
%@NL@%
        pop     ax              %@AB@%; restore length%@AE@%%@NL@%
        popf                    %@AB@%; and Carry flag%@AE@%%@NL@%
%@NL@%
        pop     es              %@AB@%; restore other affected%@AE@%%@NL@%
        pop     di              %@AB@%; registers%@AE@%%@NL@%
        pop     dx%@NL@%
        pop     cx%@NL@%
        pop     bx%@NL@%
        ret                     %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
qfn     endp%@NL@%
%@NL@%
%@NL@%
makelc  proc    near            %@AB@%; string -> lower case%@AE@%%@NL@%
                                %@AB@%; DS:SI = address%@AE@%%@NL@%
                                %@AB@%; AX = length%@AE@%%@NL@%
%@NL@%
        push    bx              %@AB@%; save BX contents%@AE@%%@NL@%
        xor     bx,bx           %@AB@%; BX will be pointer%@AE@%%@NL@%
%@NL@%
mlc1:                           %@AB@%; change A-Z to a-z%@AE@%%@NL@%
        cmp     byte ptr [bx+si],'A'%@NL@%
        jb      mlc2%@NL@%
        cmp     byte ptr [bx+si],'Z'%@NL@%
        ja      mlc2%@NL@%
        or      byte ptr [bx+si],20h%@NL@%
%@NL@%
mlc2:   inc     bx              %@AB@%; advance through string%@AE@%%@NL@%
        cmp     bx,ax           %@AB@%; done with string yet?%@AE@%%@NL@%
        jne     mlc1            %@AB@%; no, check next char.%@AE@%%@NL@%
%@NL@%
        pop     bx              %@AB@%; restore BX and%@AE@%%@NL@%
        ret                     %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
makelc  endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%QFN.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH09\QFN.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    QFN.C   Qualify Filename, OS/2 version%@NL@%
%@AB@%    Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
API unsigned extern far pascal  %@AB@%/* OS/2 API functions */%@AE@%%@NL@%
%@NL@%
API DosChDir(char far *, unsigned long);%@NL@%
API DosQCurDisk(int far *, unsigned long far *);%@NL@%
API DosQCurDir(int, void far *, int far *);%@NL@%
API DosSelectDisk(int);%@NL@%
%@NL@%
static char qbuff[80];                  %@AB@%/* receives qualified filename */%@AE@%%@NL@%
%@NL@%
char *qfn(char *p)%@NL@%
{   %@NL@%
    char tbuff[80];                     %@AB@%/* target directory */%@AE@%%@NL@%
    char cpath[80];                     %@AB@%/* current path at entry */%@AE@%%@NL@%
    int cdrive;                         %@AB@%/* current drive at entry */%@AE@%%@NL@%
    int cpsiz = sizeof(cpath);          %@AB@%/* size of path buffer */%@AE@%%@NL@%
    int qbsiz = sizeof(qbuff);          %@AB@%/* size of qual. name buffer */%@AE@%%@NL@%
    unsigned long drvmap;               %@AB@%/* bitmap for valid drives */%@AE@%%@NL@%
    char *q;                            %@AB@%/* scratch pointer */%@AE@%%@NL@%
    int i;                              %@AB@%/* scratch variable */%@AE@%%@NL@%
%@NL@%
    DosQCurDisk(&cdrive, &drvmap);      %@AB@%/* get current drive */%@AE@%%@NL@%
%@NL@%
    DosQCurDir(0, &cpath[1], &cpsiz);   %@AB@%/* get current directory */%@AE@%%@NL@%
    cpath[0] = '\\';                    %@AB@%/* and prepend backslash */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* any drive specified? */%@AE@%%@NL@%
    if((strlen(p) >= 2) && (p[1] == ':'))%@NL@%
    {   %@NL@%
        i = (p[0] | 0x20)-'a'+1;        %@AB@%/* get binary drive code */%@AE@%%@NL@%
%@NL@%
        if(DosSelectDisk(i))            %@AB@%/* switch to new drive */%@AE@%%@NL@%
            goto errexit;               %@AB@%/* return if bad drive */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* get current directory again */%@AE@%%@NL@%
        DosQCurDir(0, &cpath[1], &cpsiz);%@NL@%
%@NL@%
        p += 2;                         %@AB@%/* bump ptr past drive */%@AE@%%@NL@%
    }   %@NL@%
%@NL@%
    strcpy(tbuff, p);                   %@AB@%/* copy target pathname%@NL@%
%@AB@%                                           to local buffer */%@AE@%%@NL@%
%@NL@%
    q = strrchr(tbuff, '\\');           %@AB@%/* look for last backslash */%@AE@%%@NL@%
%@NL@%
    if (q != NULL)                      %@AB@%/* any path specified? */%@AE@%%@NL@%
    {   %@NL@%
        *q = 0;                         %@AB@%/* yes, make path ASCIIZ */%@AE@%%@NL@%
%@NL@%
        if(q == tbuff)                  %@AB@%/* select directory */%@AE@%%@NL@%
        {   %@NL@%
            if(DosChDir("\\", 0L))      %@AB@%/* target is root */%@AE@%%@NL@%
                goto errexit;%@NL@%
        }%@NL@%
        else %@NL@%
        {   %@NL@%
            if(DosChDir(tbuff, 0L))     %@AB@%/* target is not root */%@AE@%%@NL@%
            goto errexit;%@NL@%
        }%@NL@%
        q += 1;                         %@AB@%/* point to filename */%@AE@%%@NL@%
    }%@NL@%
    else q = tbuff;                     %@AB@%/* if no path specified,%@NL@%
%@AB@%                                           point to filename */%@AE@%%@NL@%
%@NL@%
    if(q[0] == '.') goto errexit;       %@AB@%/* filename may not be%@NL@%
%@AB@%                                           directory alias */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* drive and/or path are selected, build qualified filename */%@AE@%%@NL@%
%@NL@%
    DosQCurDisk(&i, &drvmap);           %@AB@%/* get target drive */%@AE@%%@NL@%
    qbuff[0] = i+'a'-1;                 %@AB@%/* and convert to ASCII */%@AE@%%@NL@%
%@NL@%
    qbuff[1] = ':';                     %@AB@%/* add drive delimiter */%@AE@%%@NL@%
    qbuff[2] = '\\';                    %@AB@%/* and root backslash */%@AE@%%@NL@%
%@NL@%
    DosQCurDir(0, &qbuff[3], &qbsiz);   %@AB@%/* get target directory */%@AE@%%@NL@%
    %@NL@%
    i = strlen(qbuff);                  %@AB@%/* length of drive+path */%@AE@%%@NL@%
%@NL@%
    if(i != 3) qbuff[i++] = '\\';       %@AB@%/* if not root, add%@NL@%
%@AB@%                                           trailing backslash */%@AE@%%@NL@%
%@NL@%
    strcpy(qbuff+i, q);                 %@AB@%/* copy in filename */%@AE@%%@NL@%
%@NL@%
    DosChDir(cpath, 0L);                %@AB@%/* restore original path */%@AE@%%@NL@%
    DosSelectDisk(cdrive);              %@AB@%/* restore original drive */%@AE@%%@NL@%
%@NL@%
    return(strlwr(qbuff));              %@AB@%/* fold pathname to lower%@NL@%
%@AB@%                                           case, return pointer */%@AE@%%@NL@%
%@NL@%
errexit:                                %@AB@%/* common error exit point */%@AE@%%@NL@%
    DosChDir(cpath, 0L);                %@AB@%/* restore original path */%@AE@%%@NL@%
    DosSelectDisk(cdrive);              %@AB@%/* restore original drive */%@AE@%%@NL@%
    return(NULL);                       %@AB@%/* return null pointer */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SCHEX.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH09\SCHEX.ASM%@AE@%%@NL@%
%@NL@%
        title   SCHEX Example directory search program%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%; SCH-EX.ASM   Example of OS/2 directory search.%@AE@%%@NL@%
%@AB@%;              Finds and displays names of all files%@AE@%%@NL@%
%@AB@%;              in current directory with extension .ASM.%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM SCHEX;%@AE@%%@NL@%
%@AB@%;               LINK SCHEX,,,OS2,SCHEX%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        SCHEX%@AE@%%@NL@%
%@NL@%
stdin   equ     0                       %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1                       %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII line feed%@AE@%%@NL@%
%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosFindClose:far%@NL@%
        extrn   DosFindFirst:far%@NL@%
        extrn   DosFindNext:far%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
fname   db      '*.ASM',0               %@AB@%; target name for search%@AE@%%@NL@%
%@NL@%
sbuf    db      64 dup (?)              %@AB@%; receives search results%@AE@%%@NL@%
sbuf_len equ $-sbuf                     %@AB@%; length of result buffer%@AE@%%@NL@%
%@NL@%
dirhan  dw      ?                       %@AB@%; receives search handle%@AE@%%@NL@%
schcnt  dw      ?                       %@AB@%; receives match count%@AE@%%@NL@%
wlen    dw      ?                       %@AB@%; receives bytes written%@AE@%%@NL@%
counter dw      0                       %@AB@%; number of files matched%@AE@%%@NL@%
%@NL@%
newline db      cr,lf                   %@AB@%; carriage return-linefeed%@AE@%%@NL@%
newline_len equ $-newline%@NL@%
%@NL@%
msg1    db      cr,lf%@NL@%
        db      'No matching files.'%@NL@%
        db      cr,lf%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far                     %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
        mov     dirhan,-1               %@AB@%; request new search handle%@AE@%%@NL@%
        mov     schcnt,1                %@AB@%; set max match count%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; search for first match...%@AE@%%@NL@%
        push    ds                      %@AB@%; search target filename%@AE@%%@NL@%
        push    offset DGROUP:fname%@NL@%
        push    ds                      %@AB@%; receives search handle%@AE@%%@NL@%
        push    offset DGROUP:dirhan%@NL@%
        push    0                       %@AB@%; attribute=normal files%@AE@%%@NL@%
        push    ds                      %@AB@%; result buffer address%@AE@%%@NL@%
        push    offset DGROUP:sbuf%@NL@%
        push    sbuf_len                %@AB@%; result buffer length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives match count%@AE@%%@NL@%
        push    offset DGROUP:schcnt%@NL@%
        push    0                       %@AB@%; reserved DWORD 0%@AE@%%@NL@%
        push    0%@NL@%
        call    DosFindFirst            %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        or      ax,ax                   %@AB@%; any files found?%@AE@%%@NL@%
        jnz     main2                   %@AB@%; no, exit%@AE@%%@NL@%
%@NL@%
        cmp     schcnt,1                %@AB@%; confirm match was found%@AE@%%@NL@%
        jne     main2                   %@AB@%; no, exit%@AE@%%@NL@%
%@NL@%
main1:                                  %@AB@%; match was found...%@AE@%%@NL@%
        inc     counter                 %@AB@%; count matching files%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display one filename...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; file name address%@AE@%%@NL@%
        push    offset DGROUP:sbuf+17h%@NL@%
        mov     al,byte ptr sbuf+16h    %@AB@%; file name length%@AE@%%@NL@%
        xor     ah,ah%@NL@%
        push    ax%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; send new-line sequence%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; new-line sequence address%@AE@%%@NL@%
        push    offset DGROUP:newline%@NL@%
        push    newline_len             %@AB@%; new-line sequence length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; search for next file...%@AE@%%@NL@%
        push    dirhan                  %@AB@%; search handle%@AE@%%@NL@%
        push    ds                      %@AB@%; result buffer address%@AE@%%@NL@%
        push    offset DGROUP:sbuf%@NL@%
        push    sbuf_len                %@AB@%; result buffer length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives match count%@AE@%%@NL@%
        push    offset schcnt%@NL@%
        call    DosFindNext             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        or      ax,ax                   %@AB@%; any more files?%@AE@%%@NL@%
        jnz     main2                   %@AB@%; no, exit%@AE@%%@NL@%
%@NL@%
        cmp     schcnt,1                %@AB@%; confirm match was found%@AE@%%@NL@%
        je      main1                   %@AB@%; yes, proceed%@AE@%%@NL@%
%@NL@%
main2:  push    dirhan                  %@AB@%; release search handle...%@AE@%%@NL@%
        call    DosFindClose            %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        cmp     counter,0               %@AB@%; any files found?%@AE@%%@NL@%
        jne     main3                   %@AB@%; yes%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; no, display 'no matches'%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg1%@NL@%
        push    msg1_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main3:  push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0                       %@AB@%; return success code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SHOWARGS.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH19\SHOWARGS.ASM%@AE@%%@NL@%
%@NL@%
        title          SHOWARGS -- ASMHELP.DLL Demo%@NL@%
        page      55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; SHOWARGS.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Demonstrates parsing of command line by calls to ASMHELP.DLL.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm showargs.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link showargs,,,os2,showargs%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage is:  C> showargs [argument(s)]%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
stdin   equ     0               %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1               %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2               %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
cr      equ     0dh             %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf        equ        0ah                %@AB@%; ASCII linefeed%@AE@%%@NL@%
blank   equ     020h            %@AB@%; ASCII blank%@AE@%%@NL@%
tab     equ     09h             %@AB@%; ASCII tab%@AE@%%@NL@%
%@NL@%
                                %@AB@%; references to ASMHELP.DLL%@AE@%%@NL@%
        extrn   ARGC:far        %@AB@%; returns argument count%@AE@%%@NL@%
        extrn   ARGV:far        %@AB@%; returns pointer to argument%@AE@%%@NL@%
%@NL@%
        extrn   DosWrite:far    %@AB@%; references to OS/2%@AE@%%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosGetEnv:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
argno   dw      0               %@AB@%; receives argument count%@AE@%%@NL@%
argptr  dw      0,0             %@AB@%; receives argument pointer%@AE@%%@NL@%
arglen  dw      0               %@AB@%; receives argument length%@AE@%%@NL@%
%@NL@%
curarg        dw        0                %@AB@%; current command line argument%@AE@%%@NL@%
%@NL@%
wlen    dw      0               %@AB@%; bytes actually written%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf%@NL@%
        db      'The command line contains '%@NL@%
msg1a   db      'xx arguments'%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf%@NL@%
        db      'Argument '%@NL@%
msg2a   db      'xx is:  '%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far             %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; get number of command%@AE@%%@NL@%
                                %@AB@%;  line arguments...%@AE@%%@NL@%
%@NL@%
        push    ds              %@AB@%; receives argument count%@AE@%%@NL@%
        push    offset DGROUP:argno%@NL@%
        call    argc            %@AB@%; call ASMHELP.DLL%@AE@%%@NL@%
%@NL@%
        mov     ax,argno        %@AB@%; convert count to ASCII%@AE@%%@NL@%
        mov     bx,offset msg1a %@AB@%; for output%@AE@%%@NL@%
        call    b2dec%@NL@%
%@NL@%
                                %@AB@%; now display number%@AE@%%@NL@%
                                %@AB@%; of arguments...%@AE@%%@NL@%
%@NL@%
        push    stdout          %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds              %@AB@%; address of message%@AE@%%@NL@%
        push    offset DGROUP:msg1%@NL@%
        push    msg1_len        %@AB@%; length of message%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main1:                          %@AB@%; display next argument...%@AE@%%@NL@%
%@NL@%
        mov     ax,curarg       %@AB@%; are we all done?%@AE@%%@NL@%
        cmp     ax,argno%@NL@%
        je      main2           %@AB@%; yes, exit%@AE@%%@NL@%
%@NL@%
        mov     bx,offset msg2a %@AB@%; no, convert argument number%@AE@%%@NL@%
        call    b2dec%@NL@%
%@NL@%
                                %@AB@%; display argument number...%@AE@%%@NL@%
        push    stdout          %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds              %@AB@%; address of message%@AE@%%@NL@%
        push    offset DGROUP:msg2%@NL@%
        push    msg2_len        %@AB@%; length of message%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; get argument pointer...%@AE@%%@NL@%
        push    curarg          %@AB@%; argument number%@AE@%%@NL@%
        push    ds              %@AB@%; receives pointer%@AE@%%@NL@%
        push    offset DGROUP:argptr%@NL@%
        push    ds              %@AB@%; receives length%@AE@%%@NL@%
        push    offset DGROUP:arglen%@NL@%
        call    argv            %@AB@%; call ASMHELP.DLL%@AE@%%@NL@%
%@NL@%
                                %@AB@%; display the argument...%@AE@%%@NL@%
        push    stdout          %@AB@%; standard output handle%@AE@%%@NL@%
        push    argptr+2        %@AB@%; pointer to argument%@AE@%%@NL@%
        push    argptr%@NL@%
        push    arglen          %@AB@%; length of argument%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        inc     word ptr curarg %@AB@%; go to next argument%@AE@%%@NL@%
        jmp     main1%@NL@%
%@NL@%
main2:                          %@AB@%; common exit point%@AE@%%@NL@%
        push    1               %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0               %@AB@%; return code = zero%@AE@%%@NL@%
        call    DosExit         %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
%@NL@%
b2dec   proc    near            %@AB@%; convert binary value 0-99%@AE@%%@NL@%
                                %@AB@%;  to two decimal ASCII%@AE@%%@NL@%
                                %@AB@%; call with%@AE@%%@NL@%
                                %@AB@%; AL = binary data%@AE@%%@NL@%
                                %@AB@%; BX = address for 2 chars.%@AE@%%@NL@%
%@NL@%
        aam                     %@AB@%; divide AL by 10, leaving%@AE@%%@NL@%
                                %@AB@%; AH = quotient, AL = remainder%@AE@%%@NL@%
        add     ax,'00'         %@AB@%; convert to ASCII%@AE@%%@NL@%
        mov        [bx],ah         %@AB@%; store tens digit%@AE@%%@NL@%
        mov        [bx+1],al        %@AB@%; store ones digit%@AE@%%@NL@%
        ret                     %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
b2dec   endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main            %@AB@%; defines entry point%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SHOWARGS.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH03\SHOWARGS.ASM%@AE@%%@NL@%
%@NL@%
        title     SHOWARGS -- ARGC and ARGV demo%@NL@%
        page      55,132%@NL@%
        .286%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; SHOWARGS.ASM --- demonstrate command line parsing with%@AE@%%@NL@%
%@AB@%;                  ARGC.ASM and ARGV.ASM (OS/2 version)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
stdin   equ     0               %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1               %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2               %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
cr      equ     0dh             %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah             %@AB@%; ASCII line feed%@AE@%%@NL@%
blank   equ     020h            %@AB@%; ASCII blank%@AE@%%@NL@%
tab     equ     09h             %@AB@%; ASCII tab%@AE@%%@NL@%
%@NL@%
        extrn   argc:near       %@AB@%; returns argument count%@AE@%%@NL@%
        extrn   argv:near       %@AB@%; returns argument pointer%@AE@%%@NL@%
%@NL@%
                                %@AB@%; OS/2 API functions%@AE@%%@NL@%
        extrn   DosWrite:far    %@AB@%; write file or device%@AE@%%@NL@%
        extrn   DosExit:far     %@AB@%; terminate process%@AE@%%@NL@%
%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
curarg  dw      0               %@AB@%; current command line argument%@AE@%%@NL@%
totargs dw      0               %@AB@%; total command line arguments%@AE@%%@NL@%
%@NL@%
wlen    dw      ?               %@AB@%; bytes actually written%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf%@NL@%
        db      'The command line contains '%@NL@%
msg1a   db      'xx arguments'%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf%@NL@%
        db      'Argument '%@NL@%
msg2a   db      'xx is:  '%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far             %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
        call    argc            %@AB@%; get and save number of%@AE@%%@NL@%
        mov     totargs,ax      %@AB@%; command line arguments%@AE@%%@NL@%
%@NL@%
        mov     bx,offset msg1a %@AB@%; convert argument count%@AE@%%@NL@%
        call    b2dec           %@AB@%; to ASCII for output%@AE@%%@NL@%
%@NL@%
                                %@AB@%; display argument count%@AE@%%@NL@%
        push    stdout          %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds              %@AB@%; address of message%@AE@%%@NL@%
        push    offset DGROUP:msg1%@NL@%
        push    msg1_len        %@AB@%; length of message%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main1:  mov     ax,curarg       %@AB@%; display next argument%@AE@%%@NL@%
        cmp     ax,totargs      %@AB@%; are we all done?%@AE@%%@NL@%
        je      main2           %@AB@%; yes, exit%@AE@%%@NL@%
%@NL@%
        mov     bx,offset msg2a %@AB@%; no, convert argument%@AE@%%@NL@%
        call    b2dec           %@AB@%; number to ASCII%@AE@%%@NL@%
%@NL@%
                                %@AB@%; display argument number%@AE@%%@NL@%
        push    stdout          %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds              %@AB@%; address of message%@AE@%%@NL@%
        push    offset DGROUP:msg2%@NL@%
        push    msg2_len        %@AB@%; length of message%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov     ax,curarg       %@AB@%; now get actual argument%@AE@%%@NL@%
        call    argv            %@AB@%; ES:BX=addr,AX=length%@AE@%%@NL@%
%@NL@%
        push    stdout          %@AB@%; standard output handle%@AE@%%@NL@%
        push    es              %@AB@%; command argument address%@AE@%%@NL@%
        push    bx%@NL@%
        push    ax              %@AB@%; command argument length%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        inc     word ptr curarg %@AB@%; go to next argument%@AE@%%@NL@%
        jmp     main1%@NL@%
%@NL@%
main2:  push    1               %@AB@%; terminate process%@AE@%%@NL@%
        push    0               %@AB@%; return code = zero%@AE@%%@NL@%
        call    DosExit         %@AB@%; final exit to OS/2%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
%@NL@%
b2dec   proc    near            %@AB@%; convert binary 0-99%@AE@%%@NL@%
                                %@AB@%; to decimal ASCII%@AE@%%@NL@%
                                %@AB@%; call with%@AE@%%@NL@%
                                %@AB@%; AL = binary data%@AE@%%@NL@%
                                %@AB@%; BX = addr. for 2 chars.%@AE@%%@NL@%
%@NL@%
        aam                     %@AB@%; divide AL by 10, leaving%@AE@%%@NL@%
                                %@AB@%; AH=quotient, AL=remainder%@AE@%%@NL@%
        add     ax,'00'         %@AB@%; convert to ASCII%@AE@%%@NL@%
        mov     [bx],ah         %@AB@%; store ten's digit%@AE@%%@NL@%
        mov     [bx+1],al       %@AB@%; store one's digit%@AE@%%@NL@%
        ret                     %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
b2dec   endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main            %@AB@%; defines entry point%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SHOWCOM.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH07\SHOWCOM.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    SHOWCOM.C --- Simple program to display current COM1 %@NL@%
%@AB@%                  setup using the DosDevIOCtl calls.%@NL@%
%@AB@%    Copyright (C) 1987 Ray Duncan%@NL@%
%@AB@%%@NL@%
%@AB@%    Build:  C>CL showcom.c%@NL@%
%@AB@%    Usage:  C>SHOWCOM%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
COMPORT "COM1"              %@AB@%/* COM device name */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%API unsigned extern far pascal %@NL@%
%@NL@%
API DosClose(unsigned); %@NL@%
API DosDevIOCtl(void far *, void far *, unsigned, unsigned, unsigned);%@NL@%
API DosOpen(char far *, unsigned far *, unsigned far *, unsigned long,%@NL@%
            unsigned, unsigned, unsigned, unsigned long);           %@NL@%
%@NL@%
struct F61Struc {%@NL@%
    int BaudRate;                   %@AB@%/* 110, 150, 300, ... 19200 */%@AE@%%@NL@%
    } F61Info ;%@NL@%
%@NL@%
struct F62Struc {%@NL@%
    unsigned char DataBits;         %@AB@%/* possible values 5-8 */%@AE@%%@NL@%
    unsigned char Parity;           %@AB@%/* 0=N 1=O 2=E 3=Mark 4=Space */%@AE@%%@NL@%
    unsigned char StopBits;         %@AB@%/* 0=1 bit, 1=1.5 bits, 2=2 bits */%@AE@%%@NL@%
    unsigned char Break;            %@AB@%/* 0=not xmitting break */%@AE@%%@NL@%
    } F62Info;%@NL@%
%@NL@%
struct F64Struc {%@NL@%
    unsigned char ComPortStatus;    %@AB@%/* bit  meaning         */%@AE@%%@NL@%
    } F64Info;                      %@AB@%/*  0   Tx waiting for CTS ON%@NL@%
%@AB@%                                        1   Tx waiting for DSR ON%@NL@%
%@AB@%                                        2   Tx waiting for DCD ON%@NL@%
%@AB@%                                        3   Tx waiting, XOFF rcvd%@NL@%
%@AB@%                                        4   Tx waiting, XOFF sent%@NL@%
%@AB@%                                        5   Tx waiting, break xmit%@NL@%
%@AB@%                                        6   Char waiting to xmit%@NL@%
%@AB@%                                        7   Rcv waiting for DSR on  */%@AE@%%@NL@%
%@NL@%
struct F65Struc {%@NL@%
    unsigned char XmitDataStatus;   %@AB@%/* bit  meaning         */%@AE@%%@NL@%
    } F65Info;                      %@AB@%/*  0   write in prog or queued%@NL@%
%@AB@%                                        1   data in xmit queue%@NL@%
%@AB@%                                        2   char xmit in progress%@NL@%
%@AB@%                                        3   char waiting for xmit%@NL@%
%@AB@%                                        4   waiting to send XON%@NL@%
%@AB@%                                        5   waiting to send XOFF%@NL@%
%@AB@%                                        6-7 undefined       */%@AE@%%@NL@%
%@NL@%
struct F66Struc {%@NL@%
    unsigned char OutputSignals;    %@AB@%/* bit  meaning         */%@AE@%%@NL@%
    } F66Info;                      %@AB@%/*  0   DTR (data terminal ready)%@NL@%
%@AB@%                                        1   RTS (request to send)%@NL@%
%@AB@%                                        2-7 undefined       */%@AE@%%@NL@%
%@NL@%
struct F67Struc {%@NL@%
    unsigned char InputSignals;     %@AB@%/* bit  meaning         */%@AE@%%@NL@%
    } F67Info;                      %@AB@%/* 0-3  undefined%@NL@%
%@AB@%                                        4   CTS (clear to send)%@NL@%
%@AB@%                                        5   DSR (data set ready)    */%@AE@%%@NL@%
%@NL@%
struct F68Struc {%@NL@%
    unsigned CharsQueued;           %@AB@%/* chars received and waiting */%@AE@%%@NL@%
    unsigned QueueSize;             %@AB@%/* size of receive char. queue */%@AE@%%@NL@%
    } F68Info;%@NL@%
%@NL@%
struct F69Struc {%@NL@%
    unsigned CharsQueued;           %@AB@%/* chars waiting for xmit */%@AE@%%@NL@%
    unsigned QueueSize;             %@AB@%/* size of transmit char. queue */%@AE@%%@NL@%
    } F69Info;%@NL@%
%@NL@%
struct F6dStruc {%@NL@%
    unsigned ComError;              %@AB@%/* bit  meaning         */%@AE@%%@NL@%
    } F6dInfo;                      %@AB@%/*  0   receive queue overrun%@NL@%
%@AB@%                                        1   receive hardware overrun%@NL@%
%@AB@%                                        2   parity error detected%@NL@%
%@AB@%                                        3   framing error detected%@NL@%
%@AB@%                                        4-15 undefined      */%@AE@%%@NL@%
%@NL@%
struct F72Struc {%@NL@%
    unsigned EventWord;             %@AB@%/* bit  meaning         */%@AE@%%@NL@%
    } F72Info;                      %@AB@%/*  0   set when char read%@NL@%
%@AB@%                                            placed in receive queue%@NL@%
%@AB@%                                        1   undefined%@NL@%
%@AB@%                                        2   set when last char in%@NL@%
%@AB@%                                            transmit queue is sent%@NL@%
%@AB@%                                        3   change in CTS state%@NL@%
%@AB@%                                        4   change in DSR state%@NL@%
%@AB@%                                        5   change in DCD state%@NL@%
%@AB@%                                        6   break detected%@NL@%
%@AB@%                                        7   parity or framing error%@NL@%
%@AB@%                                        8   trailing edge of ring%@NL@%
%@AB@%                                            indicator detected%@NL@%
%@AB@%                                        9-15 undefined      */%@AE@%%@NL@%
%@NL@%
static char *ParityNames[] = { "None", "Odd", "Even", "Mark", "Space" };%@NL@%
static char *StopNames[]   = { "1", "1.5", "2" };%@NL@%
%@NL@%
main (int argc,char *argv[])%@NL@%
{%@NL@%
    int action, handle, status;     %@AB@%/* scratch variables */%@AE@%%@NL@%
    int openflag = 0x01;                        %@AB@%/* DosOpen fail if device not found */%@AE@%%@NL@%
    int openmode = 0x42;            %@AB@%/* DosOpen read/write, deny none */%@AE@%%@NL@%
%@NL@%
                                    %@AB@%/* open device or exit */%@AE@%%@NL@%
    if(DosOpen(COMPORT, &handle, &action, 0L, 0, openflag, openmode, 0L))%@NL@%
    {   %@NL@%
        fprintf(stderr, "\nCan't open %s device\n", COMPORT);%@NL@%
        exit(1);%@NL@%
    }                               %@AB@%/* got device OK */%@AE@%%@NL@%
    printf("\n%s device opened, handle = %d\n", COMPORT, handle);%@NL@%
%@NL@%
                                    %@AB@%/* now display device info */%@AE@%%@NL@%
    status = DosDevIOCtl(&F61Info, NULL, 0x61, 1, handle);%@NL@%
    if(! status) printf("\nBaud rate:          %d", F61Info.BaudRate);%@NL@%
%@NL@%
    status = DosDevIOCtl(&F62Info, NULL, 0x62, 1, handle);%@NL@%
    if(! status)%@NL@%
    {   %@NL@%
        printf("\nData Bits:          %d", F62Info.DataBits);%@NL@%
        printf("\nParity:             %s", ParityNames[F62Info.Parity]);%@NL@%
        printf("\nStop Bits:          %s", StopNames[F62Info.StopBits]);%@NL@%
    }%@NL@%
%@NL@%
    status = DosDevIOCtl(&F64Info, NULL, 0x64, 1, handle);%@NL@%
    if(! status) printf("\nCom Port Status:    %.2xh", F64Info.ComPortStatus);%@NL@%
%@NL@%
    status = DosDevIOCtl(&F65Info, NULL, 0x65, 1, handle);%@NL@%
    if(! status) printf("\nTransmit Status:    %.2xh", F65Info.XmitDataStatus);%@NL@%
%@NL@%
    status = DosDevIOCtl(&F66Info, NULL, 0x66, 1, handle);%@NL@%
    if(! status) printf("\nOutput Signals:     %.2xh", F66Info.OutputSignals);%@NL@%
%@NL@%
    status = DosDevIOCtl(&F67Info, NULL, 0x67, 1, handle);%@NL@%
    if(! status) printf("\nInput Signals:      %.2xh", F67Info.InputSignals);%@NL@%
%@NL@%
    status = DosDevIOCtl(&F68Info, NULL, 0x68, 1, handle);%@NL@%
    if(! status) %@NL@%
    {   %@NL@%
        printf("\nRcv Chars Queued:   %d", F68Info.CharsQueued);%@NL@%
        printf("\nRcv Queue Size:     %d", F68Info.QueueSize);%@NL@%
    }%@NL@%
%@NL@%
    status = DosDevIOCtl(&F69Info, NULL, 0x69, 1, handle);%@NL@%
    if(! status) %@NL@%
    {   %@NL@%
        printf("\nXmit Chars Queued:  %d", F69Info.CharsQueued);%@NL@%
        printf("\nXmit Queue Size:    %d", F69Info.QueueSize);%@NL@%
    }%@NL@%
%@NL@%
    status = DosDevIOCtl(&F6dInfo, NULL, 0x6d, 1, handle);%@NL@%
    if(! status) printf("\nCom Error Info:     %.4xh", F6dInfo.ComError);%@NL@%
%@NL@%
    status = DosDevIOCtl(&F72Info, NULL, 0x72, 1, handle);%@NL@%
    if(! status) printf("\nEvent Word:         %.4xh", F72Info.EventWord);%@NL@%
%@NL@%
    status = DosClose(handle);      %@AB@%/* an unnecessary nicety */%@AE@%%@NL@%
    if(! status) printf("\n\n%s device closed\n", COMPORT);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SHOWENV.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH03\SHOWENV.ASM%@AE@%%@NL@%
%@NL@%
        title        SHOWENV -- demo of GETENV subroutine%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%; SHOWENV.ASM - Demonstrates use of GETENV routine (OS/2 version).%@AE@%%@NL@%
%@AB@%;                Prompts user for the name of an environment%@AE@%%@NL@%
%@AB@%;                variable, then displays the associated string.%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM SHOWENV;%@AE@%%@NL@%
%@AB@%;                MASM GETENV;%@AE@%%@NL@%
%@AB@%;                LINK SHOWENV+GETENV,,,OS2,SHOWENV%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        SHOWENV%@AE@%%@NL@%
%@NL@%
stdin        equ        0                %@AB@%; standard input handle%@AE@%%@NL@%
stdout        equ        1                %@AB@%; standard output handle%@AE@%%@NL@%
%@NL@%
cr        equ        0dh               %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf        equ        0ah               %@AB@%; ASCII line feed%@AE@%%@NL@%
%@NL@%
        extrn        DosExit:far        %@AB@%; OS/2 API functions%@AE@%%@NL@%
        extrn        DosRead:far%@NL@%
        extrn        DosWrite:far%@NL@%
%@NL@%
        extrn        getenv:near        %@AB@%; returns address of env. string%@AE@%%@NL@%
%@NL@%
DGROUP        group        _DATA%@NL@%
%@NL@%
_DATA        segment        word public 'DATA'%@NL@%
%@NL@%
msg1        db        cr,lf,lf,'Enter name:    '%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2        db        cr,lf,   'The value is:  '%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
msg3        db        'not found!'%@NL@%
msg3_len equ $-msg3%@NL@%
%@NL@%
inbuf        db        64 dup (0)        %@AB@%; keyboard input buffer%@AE@%%@NL@%
inbuf_len equ $-inbuf%@NL@%
%@NL@%
rlen        dw        ?                %@AB@%; receives actual number%@AE@%%@NL@%
                                %@AB@%; of bytes read%@AE@%%@NL@%
%@NL@%
wlen        dw        ?                %@AB@%; receives actual number%@AE@%%@NL@%
                                %@AB@%; of bytes written%@AE@%%@NL@%
%@NL@%
_DATA        ends%@NL@%
%@NL@%
%@NL@%
_TEXT        segment        word public 'CODE'%@NL@%
%@NL@%
        assume        cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main        proc        far               %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; get env. variable,%@AE@%%@NL@%
                                %@AB@%; display cue to user...%@AE@%%@NL@%
        push        stdout                %@AB@%; standard output handle%@AE@%%@NL@%
        push        ds                %@AB@%; address of message%@AE@%%@NL@%
        push        offset DGROUP:msg1%@NL@%
        push        msg1_len        %@AB@%; length of message%@AE@%%@NL@%
        push        ds                %@AB@%; receives bytes written%@AE@%%@NL@%
        push        offset DGROUP:wlen%@NL@%
        call        DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; get name of environment%@AE@%%@NL@%
                                %@AB@%; variable from user...%@AE@%%@NL@%
        push        stdin                %@AB@%; standard input handle%@AE@%%@NL@%
        push        ds                %@AB@%; address of input buffer%@AE@%%@NL@%
        push        offset DGROUP:inbuf%@NL@%
        push        inbuf_len        %@AB@%; length of input buffer%@AE@%%@NL@%
        push        ds                %@AB@%; receives actual length%@AE@%%@NL@%
        push        offset DGROUP:rlen%@NL@%
        call        DosRead                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov        ax,rlen                %@AB@%; get length of input%@AE@%%@NL@%
        sub        ax,2                %@AB@%; remove cr-lf characters%@AE@%%@NL@%
        or        ax,ax                %@AB@%; anything entered?%@AE@%%@NL@%
        jz        main2                %@AB@%; no, exit%@AE@%%@NL@%
%@NL@%
        mov        bx,ax                %@AB@%; append null to string%@AE@%%@NL@%
        mov        byte ptr [bx+inbuf],0%@NL@%
%@NL@%
                                %@AB@%; display "The value is:"%@AE@%%@NL@%
        push        stdout                %@AB@%; standard output handle%@AE@%%@NL@%
        push        ds                %@AB@%; address of message%@AE@%%@NL@%
        push        offset DGROUP:msg2%@NL@%
        push        msg2_len        %@AB@%; length of message%@AE@%%@NL@%
        push        ds                %@AB@%; receives bytes written%@AE@%%@NL@%
        push        offset DGROUP:wlen%@NL@%
        call        DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov        si,offset inbuf        %@AB@%; address of ASCIIZ string%@AE@%%@NL@%
        call        strupr                %@AB@%; fold to upper case%@AE@%%@NL@%
        call        getenv                %@AB@%; then search environment%@AE@%%@NL@%
%@NL@%
        or        ax,ax                %@AB@%; find anything?%@AE@%%@NL@%
        jz        main1                %@AB@%; no, display error message%@AE@%%@NL@%
%@NL@%
                                %@AB@%; yes, display value of%@AE@%%@NL@%
                                %@AB@%; environment string%@AE@%%@NL@%
        push        stdout                %@AB@%; standard output handle%@AE@%%@NL@%
        push        es                %@AB@%; address of string%@AE@%%@NL@%
        push        di%@NL@%
        push        ax                %@AB@%; length of string%@AE@%%@NL@%
        push        ds                %@AB@%; receives bytes written%@AE@%%@NL@%
        push        offset DGROUP:wlen%@NL@%
        call        DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp        main                %@AB@%; go ask for another%@AE@%%@NL@%
%@NL@%
main1:                                %@AB@%; env. variable not found%@AE@%%@NL@%
        push        stdout                %@AB@%; standard output handle%@AE@%%@NL@%
        push        ds                %@AB@%; address of error message%@AE@%%@NL@%
        push        offset DGROUP:msg3%@NL@%
        push        msg3_len        %@AB@%; length of message%@AE@%%@NL@%
        push        ds                %@AB@%; receives bytes written%@AE@%%@NL@%
        push        offset DGROUP:wlen%@NL@%
        call        DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp        main                %@AB@%; go look for another%@AE@%%@NL@%
%@NL@%
main2:                                %@AB@%; final exit to OS/2%@AE@%%@NL@%
        push        1                %@AB@%; terminate all threads%@AE@%%@NL@%
        push        0                %@AB@%; return code = 0%@AE@%%@NL@%
        call        DosExit                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main        endp%@NL@%
%@NL@%
%@NL@%
strupr        proc        near                %@AB@%; convert ASCII string to%@AE@%%@NL@%
                                %@AB@%;  upper case%@AE@%%@NL@%
                                %@AB@%; call with DS:SI = string%@AE@%%@NL@%
        push        si                %@AB@%; save string address%@AE@%%@NL@%
%@NL@%
strup1:        lodsb                        %@AB@%; next character%@AE@%%@NL@%
        or        al,al                %@AB@%; found end (null byte) ?%@AE@%%@NL@%
        jz        strup2                %@AB@%; yes, jump%@AE@%%@NL@%
        cmp        al,'a'                %@AB@%; test if in range 'a'-'z'%@AE@%%@NL@%
        jb        strup1                %@AB@%; skip it if not >= a%@AE@%%@NL@%
        cmp        al,'z'%@NL@%
        ja        strup1                %@AB@%; skip it if not <= z%@AE@%%@NL@%
                                %@AB@%; change char to lower case%@AE@%%@NL@%
        sub        byte ptr [si-1],'a'-'A'%@NL@%
        jmp        strup1                %@AB@%; get another char%@AE@%%@NL@%
%@NL@%
strup2:        pop        si                %@AB@%; restore original string%@AE@%%@NL@%
        ret                        %@AB@%; address and return%@AE@%%@NL@%
%@NL@%
strupr        endp%@NL@%
%@NL@%
_TEXT        ends%@NL@%
%@NL@%
        end        main%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SIGNAL.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH13\SIGNAL.ASM%@AE@%%@NL@%
%@NL@%
        title   SIGNAL.ASM Example signal handle%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; SIGNAL.ASM  Example signal handler for OS/2.%@AE@%%@NL@%
%@AB@%;             Registers a signal handler then goes to%@AE@%%@NL@%
%@AB@%;             sleep for 10 seconds.  During the sleep%@AE@%%@NL@%
%@AB@%;             you can enter ^C and the signal handler%@AE@%%@NL@%
%@AB@%;             will display a message.%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM SIGNAL;%@AE@%%@NL@%
%@AB@%;               LINK SIGNAL,,,OS2,SIGNAL%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        SIGNAL%@AE@%%@NL@%
%@NL@%
stdin   equ     0                       %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1                       %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII line feed%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; OS/2 signal codes%@AE@%%@NL@%
SIGINTR         equ     1               %@AB@%; Ctrl-C%@AE@%%@NL@%
SIGBROKENPIPE   equ     2               %@AB@%; broken pipe%@AE@%%@NL@%
SIGTERM         equ     3               %@AB@%; program terminated%@AE@%%@NL@%
SIGBREAK        equ     4               %@AB@%; Ctrl-Break%@AE@%%@NL@%
FlagA           equ     5               %@AB@%; Event flag A%@AE@%%@NL@%
FlagB           equ     6               %@AB@%; Event flag B%@AE@%%@NL@%
FlagC           equ     7               %@AB@%; Event flag C%@AE@%%@NL@%
%@NL@%
        extrn   DosExit:far             %@AB@%; references to OS/2 API%@AE@%%@NL@%
        extrn   DosFlagProcess:far%@NL@%
        extrn   DosHoldSignal:far%@NL@%
        extrn   DosSetSigHandler:far%@NL@%
        extrn   DosSleep:far%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
msg1    db      cr,lf,'Signal detected!',cr,lf%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf%@NL@%
        db      'Signal handler installed.'%@NL@%
        db      cr,lf%@NL@%
        db      'Press Ctrl-C to demonstrate handler...'%@NL@%
        db      cr,lf%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
wlen    dw      ?                       %@AB@%; receives bytes written%@AE@%%@NL@%
%@NL@%
prvact  dw      ?                       %@AB@%; receives previous signal action%@AE@%%@NL@%
prvhdlr dd      ?                       %@AB@%; receives previous handler address%@AE@%%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far                     %@AB@%; OS/2 entry point%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; register signal handler...%@AE@%%@NL@%
        push    cs                      %@AB@%; address of handler%@AE@%%@NL@%
        push    offset _TEXT:handler%@NL@%
        push    ds                      %@AB@%; receives previous handler address%@AE@%%@NL@%
        push    offset DGROUP:prvhdlr%@NL@%
        push    ds                      %@AB@%; receives previous action%@AE@%%@NL@%
        push    offset DGROUP:prvact%@NL@%
        push    2                       %@AB@%; action = 2, call handler%@AE@%%@NL@%
        push    SIGINTR                 %@AB@%; signal of interest= ^C%@AE@%%@NL@%
        call    DosSetSigHandler        %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; was set successful?%@AE@%%@NL@%
        jnz     error                   %@AB@%; jump if set failed.%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display message 'Press Ctrl-C%@AE@%%@NL@%
                                        %@AB@%; to demonstrate handler'%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg2%@NL@%
        push    msg2_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov     cx,10                   %@AB@%; delay for 10 seconds...%@AE@%%@NL@%
%@NL@%
main1:  push    0                       %@AB@%; delay for 1 second%@AE@%%@NL@%
        push    1000%@NL@%
        call    DosSleep%@NL@%
%@NL@%
        loop    main1%@NL@%
%@NL@%
exit:   push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0                       %@AB@%; return success code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
error:  push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1                       %@AB@%; return error code%@AE@%%@NL@%
        call    DosExit%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
%@NL@%
handler proc    far                     %@AB@%; this is the signal handler%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display message showing%@AE@%%@NL@%
                                        %@AB@%; handler is active...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of data to write%@AE@%%@NL@%
        push    offset DGROUP:msg1%@NL@%
        push    msg1_len                %@AB@%; length of data%@AE@%%@NL@%
        push    ds                      %@AB@%; receives length written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; now reset signal...%@AE@%%@NL@%
        push    cs                      %@AB@%; addr of handler%@AE@%%@NL@%
        push    offset _TEXT:handler%@NL@%
        push    ds                      %@AB@%; receives addr previous handler%@AE@%%@NL@%
        push    offset DGROUP:prvhdlr%@NL@%
        push    ds                      %@AB@%; receives previous action%@AE@%%@NL@%
        push    offset DGROUP:prvact%@NL@%
        push    4                       %@AB@%; action = 4; reset signal%@AE@%%@NL@%
        push    SIGINTR                 %@AB@%; signal of interest= ^C%@AE@%%@NL@%
        call    DosSetSigHandler        %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; handler set successfully?%@AE@%%@NL@%
        jnz     error                   %@AB@%; jump if set failed%@AE@%%@NL@%
%@NL@%
        ret     4                       %@AB@%; return from handler, clear stack%@AE@%%@NL@%
%@NL@%
handler endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SIGNAL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH13\SIGNAL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    SIGNAL.C  Example signal handler in Microsoft C.%@NL@%
%@AB@%              Registers a signal handler then goes to%@NL@%
%@AB@%              sleep for 10 seconds.  During the sleep%@NL@%
%@AB@%              you can enter ^C and the signal handler%@NL@%
%@AB@%              will display a message.%@NL@%
%@AB@%%@NL@%
%@AB@%    Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%%@NL@%
%@AB@%    Compile:    CL SIGNAL.C%@NL@%
%@AB@%%@NL@%
%@AB@%    Usage:      SIGNAL%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
SIGINTR 1                       %@AB@%/* Ctrl-C signal number */%@AE@%%@NL@%
%@NL@%
void far pascal handler(unsigned, int); %@AB@%/* function prototypes */%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%API unsigned extern far pascal %@NL@%
%@NL@%
API DosSetSigHandler(void (pascal far *)(unsigned, int), %@NL@%
                     unsigned long far *, unsigned far *, int, int);%@NL@%
API DosSleep(unsigned long);%@NL@%
%@NL@%
main()%@NL@%
{%@NL@%
    unsigned long prevhandler;          %@AB@%/* previous handler address */%@AE@%%@NL@%
    unsigned prevaction;                %@AB@%/* previous handler action */%@AE@%%@NL@%
    int i;                              %@AB@%/* scratch variable */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* register Ctrl-C handler */%@AE@%%@NL@%
    DosSetSigHandler(handler, &prevhandler, &prevaction, 2, SIGINTR);%@NL@%
%@NL@%
    fprintf(stderr,"\nSignal handler registered.");%@NL@%
    fprintf(stderr,"\nEnter Ctrl-C to demonstrate handler.\n");%@NL@%
%@NL@%
    for(i=0; i<10; i++)                 %@AB@%/* sleep for 10 seconds */%@AE@%%@NL@%
        DosSleep(1000L);    %@NL@%
}%@NL@%
%@NL@%
void far pascal handler(unsigned sigarg, int signum)%@NL@%
{%@NL@%
    unsigned long dummy1;               %@AB@%/* scratch variables */%@AE@%%@NL@%
    unsigned dummy2;%@NL@%
%@NL@%
                                        %@AB@%/* reset signal */%@AE@%%@NL@%
    DosSetSigHandler(handler, &dummy1, &dummy2, 4, SIGINTR);%@NL@%
%@NL@%
                                        %@AB@%/* show something happened */%@AE@%%@NL@%
    fprintf(stderr,"\nSignal Received!\n");%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SNAP.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH18\SNAP.ASM%@AE@%%@NL@%
%@NL@%
        title   SNAP -- Sample OS/2 Device Monitor%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; SNAP.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; A sample OS/2 device monitor that captures the current display into%@AE@%%@NL@%
%@AB@%; the file SNAPxx.IMG, where xx is the session number.  SNAP works in%@AE@%%@NL@%
%@AB@%; character mode only and may not be used in a PM window.  The%@AE@%%@NL@%
%@AB@%; following keys are defined as defaults:%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Alt-F10   hot key to capture a screen%@AE@%%@NL@%
%@AB@%; Ctrl-F10  hot key to deinstall SNAP.EXE%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm snap.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link snap,,,os2,snap%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage is:  C> snap%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII character codes%@AE@%%@NL@%
lf      equ     0ah%@NL@%
%@NL@%
                                        %@AB@%; hot key definitions:%@AE@%%@NL@%
snapkey equ     71h                     %@AB@%; snapshot   Alt-F10%@AE@%%@NL@%
exitkey equ     67h                     %@AB@%; exit       Ctrl-F10%@AE@%%@NL@%
%@NL@%
stksize equ     2048                    %@AB@%; stack size for threads%@AE@%%@NL@%
%@NL@%
        extrn   DosAllocSeg:far%@NL@%
        extrn   DosBeep:far%@NL@%
        extrn   DosBufReset:far%@NL@%
        extrn   DosClose:far%@NL@%
        extrn   DosCloseSem:far%@NL@%
        extrn   DosCreateSem:far%@NL@%
        extrn   DosCreateThread:far%@NL@%
        extrn   DosExecPgm:far%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosGetInfoSeg:far%@NL@%
        extrn   DosOpenSem:far%@NL@%
        extrn   DosMonClose:far%@NL@%
        extrn   DosMonOpen:far%@NL@%
        extrn   DosMonRead:far%@NL@%
        extrn   DosMonReg:far%@NL@%
        extrn   DosMonWrite:far%@NL@%
        extrn   DosOpen:far%@NL@%
        extrn   DosSemClear:far%@NL@%
        extrn   DosSemSet:far%@NL@%
        extrn   DosSemWait:far%@NL@%
        extrn   DosSetPrty:far%@NL@%
        extrn   DosSleep:far%@NL@%
        extrn   DosSuspendThread:far%@NL@%
        extrn   DosWrite:far%@NL@%
        extrn   VioEndPopUp:far%@NL@%
        extrn   VioGetMode:far%@NL@%
        extrn   VioPopUp:far%@NL@%
        extrn   VioReadCharStr:far%@NL@%
        extrn   VioWrtCharStr:far%@NL@%
%@NL@%
jerr    macro   p1,p2,p3                %@AB@%;; Macro to test return code%@AE@%%@NL@%
        local        zero                        %@AB@%;; in AX and jump if nonzero%@AE@%%@NL@%
        or      ax,ax                   %@AB@%;; Uses JMP DISP16 to avoid%@AE@%%@NL@%
        jz      zero                    %@AB@%;; branch out of range errors%@AE@%%@NL@%
        mov     dx,offset DGROUP:p2     %@AB@%;; p2 = message address%@AE@%%@NL@%
        mov     cx,p3                   %@AB@%;; p3 = message length%@AE@%%@NL@%
        jmp     p1                      %@AB@%;; routine p1 displays message%@AE@%%@NL@%
zero:%@NL@%
        endm%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
exitsem dd      0                       %@AB@%; semaphore for final exit%@AE@%%@NL@%
snapsem dd      0                       %@AB@%; semaphore for 'snap' thread%@AE@%%@NL@%
%@NL@%
sname   db      '\SEM\SNAP'             %@AB@%; system semaphore name%@AE@%%@NL@%
sname1  db      'nn.LCK',0%@NL@%
shandle dd      0                       %@AB@%; system semaphore handle%@AE@%%@NL@%
%@NL@%
pflags  dw      0                       %@AB@%; VioPopUp flags%@AE@%%@NL@%
%@NL@%
wlen    dw      ?                       %@AB@%; receives length written%@AE@%%@NL@%
action  dw      ?                       %@AB@%; receives DosOpen action%@AE@%%@NL@%
%@NL@%
watchID dw      ?                       %@AB@%; keyboard thread ID%@AE@%%@NL@%
snapID  dw      ?                       %@AB@%; snapshot thread ID%@AE@%%@NL@%
%@NL@%
sel     dw      ?                       %@AB@%; selector from DosAllocSeg%@AE@%%@NL@%
%@NL@%
kname   db      'KBD$',0                %@AB@%; keyboard device name%@AE@%%@NL@%
khandle dw      0                       %@AB@%; keyboard monitor handle%@AE@%%@NL@%
%@NL@%
fname   db      '\SNAP'                 %@AB@%; name of snapshot file%@AE@%%@NL@%
fname1  db      'nn.IMG',0%@NL@%
fhandle dw      0                       %@AB@%; handle for snapshot file%@AE@%%@NL@%
%@NL@%
scrbuf  db      80 dup (0)              %@AB@%; receives screen data%@AE@%%@NL@%
slen    dw      $-scrbuf                %@AB@%; length of screen buffer%@AE@%%@NL@%
%@NL@%
newline db      cr,lf                   %@AB@%; carriage return-linefeed%@AE@%%@NL@%
nl_len  equ     $-newline%@NL@%
%@NL@%
gseg        dw        ?                        %@AB@%; global info segment selector%@AE@%%@NL@%
lseg        dw        ?                        %@AB@%; local info segment selector%@AE@%%@NL@%
%@NL@%
obuff        db        64 dup (0)                %@AB@%; receives name of dynlink%@AE@%%@NL@%
obuff_len equ   $-obuff                 %@AB@%; causing DosExecPgm to fail%@AE@%%@NL@%
%@NL@%
kbdin   dw      128,64 dup (0)          %@AB@%; input and output buffers%@AE@%%@NL@%
kbdout  dw      128,64 dup (0)          %@AB@%; for keyboard monitor%@AE@%%@NL@%
%@NL@%
kbdpkt  db      128 dup (0)             %@AB@%; keyboard data packet%@AE@%%@NL@%
kpktlen dw      ?                       %@AB@%; length of buffer/packet%@AE@%%@NL@%
%@NL@%
pname   db      'SNAP.EXE',0            %@AB@%; child process name%@AE@%%@NL@%
retcode dd      0                       %@AB@%; child process info%@AE@%%@NL@%
%@NL@%
vioinfo label   byte                    %@AB@%; receives display mode%@AE@%%@NL@%
        dw      8                       %@AB@%; length of structure%@AE@%%@NL@%
        db      0                       %@AB@%; display mode type%@AE@%%@NL@%
        db      0                       %@AB@%; colors%@AE@%%@NL@%
cols    dw      0                       %@AB@%; number of columns%@AE@%%@NL@%
rows    dw      0                       %@AB@%; number of rows%@AE@%%@NL@%
%@NL@%
msg1    db      'SNAP utility installed!'%@NL@%
msg1_len equ    $-msg1%@NL@%
%@NL@%
msg2    db      'Alt-F10 to capture screen into file SNAP.IMG,'%@NL@%
msg2_len equ    $-msg2%@NL@%
%@NL@%
msg3    db      'Ctrl-F10 to shut down SNAP.'%@NL@%
msg3_len equ    $-msg3%@NL@%
%@NL@%
msg4    db      'SNAP utility deactivated.'%@NL@%
msg4_len equ    $-msg4%@NL@%
%@NL@%
msg5    db      'Error detected during SNAP installation:'%@NL@%
msg5_len equ    $-msg5%@NL@%
%@NL@%
msg6    db      'Can''t create SNAP system semaphore.'%@NL@%
msg6_len equ    $-msg6%@NL@%
%@NL@%
msg7    db      'Can''t start child copy of SNAP.'%@NL@%
msg7_len equ    $-msg7%@NL@%
%@NL@%
msg8    db      'SNAP is already loaded.'%@NL@%
msg8_len equ    $-msg8%@NL@%
%@NL@%
msg9    db      'Can''t open KBD$ monitor connection.'%@NL@%
msg9_len equ    $-msg9%@NL@%
%@NL@%
msg10   db      'Can''t register as KBD$ monitor.'%@NL@%
msg10_len equ   $-msg10%@NL@%
%@NL@%
msg11   db      'Can''t allocate thread stack.'%@NL@%
msg11_len equ   $-msg11%@NL@%
%@NL@%
msg12   db      'Can''t create keyboard thread.'%@NL@%
msg12_len equ   $-msg12%@NL@%
%@NL@%
msg13   db      'Can''t create snapshot thread.'%@NL@%
msg13_len equ   $-msg13%@NL@%
%@NL@%
msg14   db      'Can''t create snapshot file.'%@NL@%
msg14_len equ   $-msg14%@NL@%
%@NL@%
divider db      79 dup ('-'),cr,lf%@NL@%
divider_len equ $-divider%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    far                     %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; get info segment selectors%@AE@%%@NL@%
        push        ds                        %@AB@%; receives global info selector%@AE@%%@NL@%
        push    offset DGROUP:gseg%@NL@%
        push        ds                        %@AB@%; receives local info selector%@AE@%%@NL@%
        push    offset DGROUP:lseg%@NL@%
        call    DosGetInfoSeg           %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; build system semaphore%@AE@%%@NL@%
                                        %@AB@%; and snapshot file names%@AE@%%@NL@%
        mov     es,gseg                 %@AB@%; get foreground screen group%@AE@%%@NL@%
        mov     al,es:[0018h]%@NL@%
        aam                             %@AB@%; convert to ASCII%@AE@%%@NL@%
        add     ax,'00'%@NL@%
        xchg    ah,al%@NL@%
        mov     word ptr fname1,ax      %@AB@%; store into filename%@AE@%%@NL@%
        mov     word ptr sname1,ax      %@AB@%; store into semaphore name%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; does SNAPxx.LCK exist?%@AE@%%@NL@%
        push    ds                      %@AB@%; receives semaphore handle%@AE@%%@NL@%
        push    offset DGROUP:shandle%@NL@%
        push    ds%@NL@%
        push    offset DGROUP:sname     %@AB@%; semaphore name%@AE@%%@NL@%
        call    DosOpenSem              %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; was open successful?%@AE@%%@NL@%
        jz      main1                   %@AB@%; jump, we're child SNAP%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; we're the parent SNAP,%@AE@%%@NL@%
                                        %@AB@%; create system semaphore%@AE@%%@NL@%
        push        1                        %@AB@%; make it nonexclusive%@AE@%%@NL@%
        push    ds                      %@AB@%; receives semaphore handle%@AE@%%@NL@%
        push    offset DGROUP:shandle%@NL@%
        push    ds                      %@AB@%; system semaphore name%@AE@%%@NL@%
        push    offset DGROUP:sname%@NL@%
        call    DosCreateSem            %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    error,msg6,msg6_len     %@AB@%; jump if create failed%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; set the semaphore...%@AE@%%@NL@%
        push    word ptr shandle+2      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    word ptr shandle%@NL@%
        call    DosSemSet               %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; launch child SNAP...%@AE@%%@NL@%
        push    ds                      %@AB@%; object name buffer%@AE@%%@NL@%
        push    offset DGROUP:obuff     %@AB@%; receives failed dynlink%@AE@%%@NL@%
        push    obuff_len               %@AB@%; length of buffer%@AE@%%@NL@%
        push    4                       %@AB@%; child detached%@AE@%%@NL@%
        push    0                       %@AB@%; NULL argument pointer%@AE@%%@NL@%
        push    0%@NL@%
        push    0                       %@AB@%; NULL environment pointer%@AE@%%@NL@%
        push    0%@NL@%
        push    ds                      %@AB@%; receives child info%@AE@%%@NL@%
        push    offset DGROUP:retcode%@NL@%
        push    ds                      %@AB@%; pathname for child%@AE@%%@NL@%
        push    offset DGROUP:pname%@NL@%
        call    DosExecPgm              %@AB@%; request launch of child%@AE@%%@NL@%
        jerr    error,msg7,msg7_len     %@AB@%; jump if launch failed%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; wait for child to load%@AE@%%@NL@%
        push    word ptr shandle+2      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    word ptr shandle%@NL@%
        push    -1                      %@AB@%; timeout = indefinite%@AE@%%@NL@%
        push    -1%@NL@%
        call    DosSemWait              %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; close the semaphore...%@AE@%%@NL@%
        push    word ptr shandle+2      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    word ptr shandle%@NL@%
        call    DosCloseSem             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp     main3                   %@AB@%; now exit%@AE@%%@NL@%
%@NL@%
main1:                                  %@AB@%; come here if child SNAP...%@AE@%%@NL@%
                                        %@AB@%; check if already resident%@AE@%%@NL@%
        push    word ptr shandle+2      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    word ptr shandle%@NL@%
        push    0                       %@AB@%; timeout = 0%@AE@%%@NL@%
        push    0%@NL@%
        call    DosSemWait              %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; is semaphore clear?%@AE@%%@NL@%
        jnz     main2                   %@AB@%; no, proceed%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; yes, don't load again%@AE@%%@NL@%
        mov     dx,offset DGROUP:msg8   %@AB@%; address of warning message%@AE@%%@NL@%
        mov     cx,msg8_len             %@AB@%; length of message%@AE@%%@NL@%
        jmp     error                   %@AB@%; display message and exit%@AE@%%@NL@%
%@NL@%
main2:                                  %@AB@%; initialize semaphores...%@AE@%%@NL@%
        push    ds                      %@AB@%; address of exit semaphore%@AE@%%@NL@%
        push    offset DGROUP:exitsem%@NL@%
        call    DosSemSet               %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; address of snapshot semaphore%@AE@%%@NL@%
        push    offset DGROUP:snapsem%@NL@%
        call    DosSemSet               %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; open monitor connection ...%@AE@%%@NL@%
        push    ds                      %@AB@%; address of device name%@AE@%%@NL@%
        push    offset DGROUP:kname%@NL@%
        push    ds                      %@AB@%; receives monitor handle%@AE@%%@NL@%
        push    offset DGROUP:khandle%@NL@%
        call    DosMonOpen              %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    error,msg9,msg9_len     %@AB@%; jump if open failed%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; register as keyboard monitor%@AE@%%@NL@%
        push    khandle                 %@AB@%; handle from DosMonOpen%@AE@%%@NL@%
        push    ds                      %@AB@%; monitor input buffer address%@AE@%%@NL@%
        push    offset DGROUP:kbdin%@NL@%
        push    ds                      %@AB@%; monitor output buffer address%@AE@%%@NL@%
        push    offset DGROUP:kbdout%@NL@%
        push    1                       %@AB@%; position = front of list%@AE@%%@NL@%
        mov     es,gseg                 %@AB@%; foreground session number%@AE@%%@NL@%
        mov     al,byte ptr es:[0018h]  %@AB@%; from global info segment%@AE@%%@NL@%
        xor     ah,ah%@NL@%
        push    ax%@NL@%
        call    DosMonReg               %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    error,msg10,msg10_len   %@AB@%; jump if register failed%@AE@%%@NL@%
%@NL@%
        push    stksize                 %@AB@%; allocate stack for WATCH thread%@AE@%%@NL@%
        push    ds                      %@AB@%; variable to receive selector%@AE@%%@NL@%
        push    offset DGROUP:sel%@NL@%
        push        0                        %@AB@%; not shareable%@AE@%%@NL@%
        call    DosAllocSeg             %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    error,msg11,msg11_len   %@AB@%; jump, can't allocate stack%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; create keyboard thread%@AE@%%@NL@%
        push    cs                      %@AB@%; initial execution address%@AE@%%@NL@%
        push    offset _TEXT:watch%@NL@%
        push    ds                      %@AB@%; receives thread ID%@AE@%%@NL@%
        push    offset DGROUP:watchID%@NL@%
        push    sel                     %@AB@%; address of thread's stack%@AE@%%@NL@%
        push    stksize%@NL@%
        call    DosCreateThread         %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    error,msg12,msg12_len   %@AB@%; jump, can't create thread%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; promote keyboard thread%@AE@%%@NL@%
        push    2                       %@AB@%; scope = single thread%@AE@%%@NL@%
        push    3                       %@AB@%; class = time critical%@AE@%%@NL@%
        push    0                       %@AB@%; delta = 0%@AE@%%@NL@%
        push    watchID                 %@AB@%; thread ID%@AE@%%@NL@%
        call    DosSetPrty              %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    stksize                 %@AB@%; allocate stack for SNAP thread%@AE@%%@NL@%
        push    ds                      %@AB@%; variable to receive selector%@AE@%%@NL@%
        push    offset DGROUP:sel%@NL@%
        push        0                        %@AB@%; not shareable%@AE@%%@NL@%
        call    DosAllocSeg             %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    error,msg11,msg11_len   %@AB@%; jump, can't allocate stack%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; create snapshot thread%@AE@%%@NL@%
        push    cs                      %@AB@%; initial execution address%@AE@%%@NL@%
        push    offset _TEXT:snap%@NL@%
        push    ds                      %@AB@%; receives thread ID%@AE@%%@NL@%
        push    offset DGROUP:snapID%@NL@%
        push    sel                     %@AB@%; address of thread's stack%@AE@%%@NL@%
        push    stksize%@NL@%
        call    DosCreateThread         %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    error,msg13,msg13_len   %@AB@%; jump, can't create thread%@AE@%%@NL@%
%@NL@%
        call    signon                  %@AB@%; announce installation%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; tell parent we are running%@AE@%%@NL@%
        push    word ptr shandle+2      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    word ptr shandle%@NL@%
        call    DosSemClear             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; block on exit semaphore...%@AE@%%@NL@%
        push    ds                      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    offset DGROUP:exitsem%@NL@%
        push    -1                      %@AB@%; timeout = indefinite%@AE@%%@NL@%
        push    -1%@NL@%
        call    DosSemWait              %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    watchID                 %@AB@%; suspend keyboard thread%@AE@%%@NL@%
        call    DosSuspendThread        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    snapID                  %@AB@%; suspend snapshot thread%@AE@%%@NL@%
        call    DosSuspendThread        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; close monitor connection%@AE@%%@NL@%
        push    khandle                 %@AB@%; monitor handle%@AE@%%@NL@%
        call    DosMonClose             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; close system semaphore%@AE@%%@NL@%
        push    word ptr shandle+2      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    word ptr shandle%@NL@%
        call    DosCloseSem             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; close snapshot file%@AE@%%@NL@%
        push    fhandle                 %@AB@%; file handle%@AE@%%@NL@%
        call    DosClose                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        call        signoff                 %@AB@%; announce deinstallation%@AE@%%@NL@%
%@NL@%
main3:  push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0                       %@AB@%; return success code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; final exit to OS/2%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
%@NL@%
error   proc    near                    %@AB@%; fatal error encountered%@AE@%%@NL@%
                                        %@AB@%; DS:DX = message, CX = length%@AE@%%@NL@%
%@NL@%
        test    khandle,-1              %@AB@%; monitor active?%@AE@%%@NL@%
        jz      error1                  %@AB@%; no, jump%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; yes, shut it down%@AE@%%@NL@%
        push    khandle                 %@AB@%; monitor handle%@AE@%%@NL@%
        call    DosMonClose             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
error1: mov     ax,word ptr shandle     %@AB@%; system semaphore open?%@AE@%%@NL@%
        or      ax,word ptr shandle+2%@NL@%
        jz      error2                  %@AB@%; no, jump%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; clear semaphore, in case%@AE@%%@NL@%
                                        %@AB@%; we're the child SNAP%@AE@%%@NL@%
        push    word ptr shandle+2      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    word ptr shandle%@NL@%
        call    DosSemClear             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; close the semaphore%@AE@%%@NL@%
        push    word ptr shandle+2      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    word ptr shandle%@NL@%
        call    DosCloseSem             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
error2: mov     ax,1                    %@AB@%; get popup window%@AE@%%@NL@%
        call    popup%@NL@%
%@NL@%
                                        %@AB@%; display title...%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg5%@NL@%
        push    msg5_len                %@AB@%; message length%@AE@%%@NL@%
        push    10                      %@AB@%; Y%@AE@%%@NL@%
        push    (80-msg5_len)/2         %@AB@%; X (center it)%@AE@%%@NL@%
        push        0                        %@AB@%; Vio handle%@AE@%%@NL@%
        call    VioWrtCharStr           %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display error message...%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    dx%@NL@%
        push    cx                      %@AB@%; message length%@AE@%%@NL@%
        push    12                      %@AB@%; Y%@AE@%%@NL@%
        mov     ax,80                   %@AB@%; X (center it)%@AE@%%@NL@%
        sub     ax,cx%@NL@%
        shr     ax,1%@NL@%
        push    ax%@NL@%
        push        0                        %@AB@%; Vio handle%@AE@%%@NL@%
        call    VioWrtCharStr           %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push        0                        %@AB@%; pause for 3 seconds%@AE@%%@NL@%
        push        3000%@NL@%
        call    DosSleep                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        call    unpop                   %@AB@%; release popup window%@AE@%%@NL@%
%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1                       %@AB@%; return error code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; exit program%@AE@%%@NL@%
%@NL@%
error   endp%@NL@%
%@NL@%
%@NL@%
watch   proc    far                     %@AB@%; keyboard thread, monitors%@AE@%%@NL@%
                                        %@AB@%; for snapshot or exit hot keys%@AE@%%@NL@%
%@NL@%
        mov     kpktlen,kpktlen-kbdpkt  %@AB@%; max buffer length for read%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; get keyboard data packet...%@AE@%%@NL@%
        push    ds                      %@AB@%; monitor input buffer address%@AE@%%@NL@%
        push    offset DGROUP:kbdin%@NL@%
        push    0                       %@AB@%; wait until data available%@AE@%%@NL@%
        push    ds%@NL@%
        push    offset DGROUP:kbdpkt    %@AB@%; receives keyboard data packet%@AE@%%@NL@%
        push    ds%@NL@%
        push    offset DGROUP:kpktlen   %@AB@%; contains/receives length%@AE@%%@NL@%
        call    DosMonRead              %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        cmp     kbdpkt+2,0              %@AB@%; is this extended code?%@AE@%%@NL@%
        jnz     watch1                  %@AB@%; no, pass it on%@AE@%%@NL@%
%@NL@%
        cmp        kbdpkt+3,exitkey        %@AB@%; is it exit hot key?%@AE@%%@NL@%
        jz      watch2                  %@AB@%; jump if exit key%@AE@%%@NL@%
%@NL@%
        cmp        kbdpkt+3,snapkey        %@AB@%; is it snapshot hot key?%@AE@%%@NL@%
        jnz     watch1                  %@AB@%; no, jump%@AE@%%@NL@%
%@NL@%
        cmp     word ptr kbdpkt+12,0    %@AB@%; is it break packet?%@AE@%%@NL@%
        jnz     watch                   %@AB@%; yes, ignore it%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; snapshot hot key detected%@AE@%%@NL@%
                                        %@AB@%; clear snapshot semaphore...%@AE@%%@NL@%
        push    ds                      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    offset DGROUP:snapsem%@NL@%
        call    DosSemClear             %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jmp        watch                        %@AB@%; discard this hot key%@AE@%%@NL@%
%@NL@%
watch1:                                 %@AB@%; not hot key, pass character%@AE@%%@NL@%
        push    ds                      %@AB@%; monitor output buffer address%@AE@%%@NL@%
        push    offset DGROUP:kbdout%@NL@%
        push    ds                      %@AB@%; keyboard data packet address%@AE@%%@NL@%
        push    offset DGROUP:kbdpkt%@NL@%
        push    kpktlen                 %@AB@%; length of data packet%@AE@%%@NL@%
        call    DosMonWrite             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp     watch                   %@AB@%; get another packet%@AE@%%@NL@%
%@NL@%
watch2:                                 %@AB@%; exit hot key detected...%@AE@%%@NL@%
        cmp     word ptr kbdpkt+12,0    %@AB@%; is it break packet?%@AE@%%@NL@%
        jnz     watch                   %@AB@%; yes, ignore it%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; clear exit semaphore...%@AE@%%@NL@%
        push    ds                      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    offset DGROUP:exitsem%@NL@%
        call    DosSemClear             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp     watch                   %@AB@%; let thread 1 shut down%@AE@%%@NL@%
%@NL@%
watch   endp%@NL@%
%@NL@%
%@NL@%
snap    proc    far                     %@AB@%; This thread blocks on the%@AE@%%@NL@%
                                        %@AB@%; snapshot semaphore, then%@AE@%%@NL@%
                                        %@AB@%; dumps the screen contents%@AE@%%@NL@%
                                        %@AB@%; to the file SNAPxx.IMG.%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; open/create snapshot file%@AE@%%@NL@%
        push    ds                      %@AB@%; address of filename%@AE@%%@NL@%
        push    offset DGROUP:fname%@NL@%
        push    ds                      %@AB@%; variable to receive file handle%@AE@%%@NL@%
        push    offset DGROUP:fhandle%@NL@%
        push    ds                      %@AB@%; variable to receive action taken%@AE@%%@NL@%
        push    offset DGROUP:action%@NL@%
        push    0                       %@AB@%; initial file size%@AE@%%@NL@%
        push    0%@NL@%
        push    0                       %@AB@%; normal file attribute%@AE@%%@NL@%
        push    12h                     %@AB@%; create or replace file%@AE@%%@NL@%
        push    21h                     %@AB@%; write access, deny write%@AE@%%@NL@%
        push    0                       %@AB@%; DWORD reserved%@AE@%%@NL@%
        push    0%@NL@%
        call    DosOpen                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    error,msg14,msg14_len   %@AB@%; jump if can't create%@AE@%%@NL@%
%@NL@%
snap1:                                  %@AB@%; write divider line%@AE@%%@NL@%
        push    fhandle                 %@AB@%; file handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of divider string%@AE@%%@NL@%
        push    offset DGROUP:divider%@NL@%
        push    divider_len             %@AB@%; length of string%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; force disk update...%@AE@%%@NL@%
        push    fhandle                 %@AB@%; file handle%@AE@%%@NL@%
        call    DosBufReset             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; wait on snapshot semaphore%@AE@%%@NL@%
        push    ds                      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    offset DGROUP:snapsem%@NL@%
        push    -1                      %@AB@%; timeout = indefinite%@AE@%%@NL@%
        push    -1%@NL@%
        call    DosSemWait              %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov        ax,3                        %@AB@%; pop-up in transparent mode%@AE@%%@NL@%
        call    popup                   %@AB@%; to read screen contents%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; get screen dimensions...%@AE@%%@NL@%
        push    ds                      %@AB@%; receives video mode info%@AE@%%@NL@%
        push    offset DGROUP:vioinfo%@NL@%
        push        0                        %@AB@%; Vio handle%@AE@%%@NL@%
        call    VioGetMode              %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov     bx,0                    %@AB@%; BX := initial screen row%@AE@%%@NL@%
%@NL@%
snap2:                                  %@AB@%; read line from screen...%@AE@%%@NL@%
        mov     ax,cols                 %@AB@%; width to read%@AE@%%@NL@%
        mov     slen,ax%@NL@%
        push    ds                      %@AB@%; address of screen buffer%@AE@%%@NL@%
        push    offset DGROUP:scrbuf%@NL@%
        push    ds                      %@AB@%; contains/receives length%@AE@%%@NL@%
        push    offset DGROUP:slen%@NL@%
        push    bx                      %@AB@%; screen row%@AE@%%@NL@%
        push    0                       %@AB@%; screen column%@AE@%%@NL@%
        push        0                        %@AB@%; Vio handle%@AE@%%@NL@%
        call    VioReadCharStr          %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; scan backwards from end%@AE@%%@NL@%
        pop     es                      %@AB@%; of line to find last%@AE@%%@NL@%
        mov        cx,slen                 %@AB@%; nonblank character%@AE@%%@NL@%
        mov     di,offset DGROUP:scrbuf%@NL@%
        add     di,slen%@NL@%
        dec     di%@NL@%
        mov     al,20h%@NL@%
        std%@NL@%
        repe scasb%@NL@%
        cld%@NL@%
        jz      snap3                   %@AB@%; if Z = True, line was empty%@AE@%%@NL@%
        inc     cx                      %@AB@%; otherwise correct the length%@AE@%%@NL@%
%@NL@%
snap3:                                  %@AB@%; write line to file...%@AE@%%@NL@%
        push    fhandle                 %@AB@%; file handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of data%@AE@%%@NL@%
        push    offset DGROUP:scrbuf%@NL@%
        push    cx                      %@AB@%; clipped line length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; write newline (CR-LF)%@AE@%%@NL@%
        push    fhandle                 %@AB@%; file handle%@AE@%%@NL@%
        push    ds%@NL@%
        push        offset DGROUP:newline        %@AB@%; address of newline%@AE@%%@NL@%
        push        nl_len                        %@AB@%; length of newline%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        inc     bx                      %@AB@%; bump screen row counter%@AE@%%@NL@%
        cmp     bx,rows                 %@AB@%; whole screen done yet?%@AE@%%@NL@%
        jne     snap2                   %@AB@%; no, write another%@AE@%%@NL@%
%@NL@%
        push    440                     %@AB@%; reward user with some%@AE@%%@NL@%
        push    200                     %@AB@%; audible feedback%@AE@%%@NL@%
        call    DosBeep                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        call    unpop                   %@AB@%; release the screen%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; done with screen capture,%@AE@%%@NL@%
                                        %@AB@%; reset snapshot semaphore%@AE@%%@NL@%
        push    ds                      %@AB@%; semaphore handle%@AE@%%@NL@%
        push    offset DGROUP:snapsem%@NL@%
        call    DosSemSet               %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp     snap1                   %@AB@%; go wait on semaphore%@AE@%%@NL@%
%@NL@%
snap    endp%@NL@%
%@NL@%
%@NL@%
signon  proc    near                    %@AB@%; announce installation,%@AE@%%@NL@%
                                        %@AB@%; display help message%@AE@%%@NL@%
%@NL@%
        mov     ax,1                    %@AB@%; put up popup window%@AE@%%@NL@%
        call        popup                        %@AB@%; mode = wait, nontransparent%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg1%@NL@%
        push    msg1_len                %@AB@%; message length%@AE@%%@NL@%
        push    10                      %@AB@%; Y%@AE@%%@NL@%
        push    (80-msg1_len)/2         %@AB@%; X (center it)%@AE@%%@NL@%
        push        0                        %@AB@%; Vio handle%@AE@%%@NL@%
        call    VioWrtCharStr           %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg2%@NL@%
        push    msg2_len                %@AB@%; message length%@AE@%%@NL@%
        push    13                      %@AB@%; Y%@AE@%%@NL@%
        push    (80-msg2_len)/2         %@AB@%; X (center it)%@AE@%%@NL@%
        push        0                        %@AB@%; Vio handle%@AE@%%@NL@%
        call    VioWrtCharStr           %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg3%@NL@%
        push    msg3_len                %@AB@%; message length%@AE@%%@NL@%
        push    15                      %@AB@%; Y%@AE@%%@NL@%
        push    (80-msg3_len)/2         %@AB@%; X (center it)%@AE@%%@NL@%
        push        0                        %@AB@%; Vio handle%@AE@%%@NL@%
        call    VioWrtCharStr           %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push        0                        %@AB@%; pause for 4 seconds%@AE@%%@NL@%
        push        4000                        %@AB@%; so user can read message%@AE@%%@NL@%
        call    DosSleep                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        call    unpop                   %@AB@%; take down popup window%@AE@%%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
signon  endp%@NL@%
%@NL@%
%@NL@%
signoff proc        near                        %@AB@%; announce deinstallation%@AE@%%@NL@%
%@NL@%
        mov     ax,1                    %@AB@%; put up popup window%@AE@%%@NL@%
        call        popup                        %@AB@%; mode = wait, nontransparent%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg4%@NL@%
        push    msg4_len                %@AB@%; message length%@AE@%%@NL@%
        push    12                      %@AB@%; Y%@AE@%%@NL@%
        push    (80-msg4_len)/2         %@AB@%; X (center it)%@AE@%%@NL@%
        push    0                       %@AB@%; VIO handle%@AE@%%@NL@%
        call    VioWrtCharStr%@NL@%
%@NL@%
        push        0                        %@AB@%; pause for 2 seconds%@AE@%%@NL@%
        push        2000                        %@AB@%; so user can read message%@AE@%%@NL@%
        call    DosSleep                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        call    unpop                   %@AB@%; take down popup window%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
signoff endp%@NL@%
%@NL@%
%@NL@%
popup   proc    near                    %@AB@%; put up popup window%@AE@%%@NL@%
                                        %@AB@%; AX = VioPopUp flags%@AE@%%@NL@%
                                        %@AB@%; bit 0 = 0 no wait%@AE@%%@NL@%
                                        %@AB@%;          1 wait for pop-up%@AE@%%@NL@%
                                        %@AB@%; bit 1 = 0 nontransparent%@AE@%%@NL@%
                                        %@AB@%;         1 transparent%@AE@%%@NL@%
%@NL@%
        mov        pflags,ax                %@AB@%; set pop-up mode%@AE@%%@NL@%
%@NL@%
        push        ds                        %@AB@%; address of popup flags%@AE@%%@NL@%
        push    offset DGROUP:pflags%@NL@%
        push        0                        %@AB@%; Vio handle%@AE@%%@NL@%
        call    VioPopUp                %@AB@%; transfer to OS/2%@AE@%%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
popup   endp%@NL@%
%@NL@%
%@NL@%
unpop   proc    near                    %@AB@%; take down popup window%@AE@%%@NL@%
%@NL@%
        push        0                        %@AB@%; Vio handle%@AE@%%@NL@%
        call    VioEndPopUp             %@AB@%; transfer to OS/2%@AE@%%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
unpop   endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SNAP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH18\SNAP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%        SNAP.C  %@NL@%
%@AB@%%@NL@%
%@AB@%        A sample OS/2 device monitor that captures the current %@NL@%
%@AB@%        display into the file SNAPxx.IMG, where xx is the %@NL@%
%@AB@%        session number.  SNAP works in character mode only and%@NL@%
%@AB@%        and may not be used in a PM window.  The following keys%@NL@%
%@AB@%        are defined as defaults:%@NL@%
%@AB@%%@NL@%
%@AB@%        Alt-F10   hot key to capture a screen%@NL@%
%@AB@%        Ctrl-F10  hot key to deinstall SNAP.EXE%@NL@%
%@AB@%%@NL@%
%@AB@%        Compile with:  C> cl /F 2000 snap.c%@NL@%
%@AB@%%@NL@%
%@AB@%        Usage is:  C> snap%@NL@%
%@AB@%%@NL@%
%@AB@%        Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
                                        %@AB@%/* hot key definitions */%@AE@%%@NL@%
SNAPKEY  0x71                   %@AB@%/* Alt-F10 to capture screen */%@AE@%%@NL@%
EXITKEY  0x67                   %@AB@%/* Ctrl-F10 to exit */%@AE@%%@NL@%
%@NL@%
STKSIZE  2048                   %@AB@%/* stack size for threads */%@AE@%%@NL@%
%@NL@%
WAIT     0                      %@AB@%/* parameters for DosMonRead */%@AE@%%@NL@%
NOWAIT   1                      %@AB@%/* and DosMonWrite */%@AE@%%@NL@%
%@NL@%
API unsigned extern far pascal  %@AB@%/* API function prototypes */%@AE@%%@NL@%
%@NL@%
API DosBeep(unsigned, unsigned);%@NL@%
API DosBufReset(unsigned);%@NL@%
API DosClose(unsigned); %@NL@%
API DosCloseSem(unsigned long far *);%@NL@%
API DosCreateThread(void (far *)(), unsigned far *, void far *);%@NL@%
API DosCreateSem(unsigned, unsigned long far *, char far *);%@NL@%
API DosExecPgm(char far *, int, int, char far *, char far *, %@NL@%
               int far *, char far *);%@NL@%
API DosExit(unsigned, unsigned);%@NL@%
API DosGetInfoSeg(unsigned far *, unsigned far *);%@NL@%
API DosMonClose(unsigned);%@NL@%
API DosMonOpen(char far *, unsigned far *);%@NL@%
API DosMonRead(void far *, unsigned, char far *, int far *);%@NL@%
API DosMonReg(unsigned, void far *, void far *, int, unsigned);%@NL@%
API DosMonWrite(void far *, char far *, int);%@NL@%
API DosOpen(char far *, unsigned far *, unsigned far *, unsigned long,%@NL@%
            unsigned, unsigned, unsigned, unsigned long);           %@NL@%
API DosOpenSem(unsigned long far *, char far *);%@NL@%
API DosSemClear(unsigned long far *);%@NL@%
API DosSemSet(unsigned long far *);%@NL@%
API DosSemWait(unsigned long far *, unsigned long);%@NL@%
API DosSetPrty(int, int, int, int);%@NL@%
API DosSleep(unsigned long);%@NL@%
API DosSuspendThread(unsigned);%@NL@%
API DosWrite(unsigned, void far *, int, unsigned far *);%@NL@%
API VioEndPopUp(unsigned);%@NL@%
API VioGetMode(void far *, unsigned);%@NL@%
API VioPopUp(unsigned far *, unsigned);%@NL@%
API VioReadCharStr(char far *, int far *, int, int, unsigned);%@NL@%
API VioWrtCharStr(char far *, int, int, int, unsigned);%@NL@%
%@NL@%
void signon(void);                      %@AB@%/* local function prototypes */%@AE@%%@NL@%
void signoff(void);%@NL@%
void popup(unsigned);%@NL@%
void unpop(void);%@NL@%
void far snap(void);%@NL@%
void far watch(void);%@NL@%
void errexit(char *);%@NL@%
%@NL@%
                                        %@AB@%/* RAM semaphores */%@AE@%%@NL@%
unsigned long exitsem = 0;                %@AB@%/* exit hot key semaphore */%@AE@%%@NL@%
unsigned long snapsem = 0;              %@AB@%/* screen snapshot semaphore */%@AE@%%@NL@%
%@NL@%
char sname[20];                         %@AB@%/* system semaphore name */%@AE@%%@NL@%
unsigned long shandle = 0;              %@AB@%/* system semaphore handle */%@AE@%%@NL@%
%@NL@%
char fname[20];                         %@AB@%/* snapshot filename */%@AE@%%@NL@%
unsigned fhandle = 0;                   %@AB@%/* snapshot file handle */%@AE@%%@NL@%
%@NL@%
char kname[] = "KBD$";                  %@AB@%/* keyboard device name */%@AE@%%@NL@%
unsigned khandle = 0;                   %@AB@%/* keyboard monitor handle */%@AE@%%@NL@%
%@NL@%
struct _monbuf {                        %@AB@%/* monitor input and */%@AE@%%@NL@%
    int len;                            %@AB@%/* output buffers */%@AE@%%@NL@%
    char buf[128];%@NL@%
    } kbdin  = { sizeof(kbdin.buf)  } , %@NL@%
      kbdout = { sizeof(kbdout.buf) } ;%@NL@%
%@NL@%
struct _vioinfo {                       %@AB@%/* display mode info */%@AE@%%@NL@%
    int len;%@NL@%
    char type;%@NL@%
    char colors;%@NL@%
    int cols;%@NL@%
    int rows;%@NL@%
    } vioinfo;%@NL@%
%@NL@%
char msg1[] = "SNAP utility installed!";%@NL@%
char msg2[] = "Alt-F10 to capture screen image into file SNAP.IMG,";%@NL@%
char msg3[] = "Ctrl-F10 to shut down SNAP.";%@NL@%
char msg4[] = "SNAP utility deactivated.";%@NL@%
char msg5[] = "Error detected during SNAP installation:";%@NL@%
%@NL@%
main()%@NL@%
{%@NL@%
    char obuff[80];                     %@AB@%/* object name buffer */%@AE@%%@NL@%
    int retcode[2];                     %@AB@%/* receives child info */%@AE@%%@NL@%
%@NL@%
    unsigned gseg, lseg;                %@AB@%/* receives selectors */%@AE@%%@NL@%
    char far *ginfo;                        %@AB@%/* global info segment pointer */%@AE@%%@NL@%
%@NL@%
    unsigned snapID, watchID;           %@AB@%/* receives thread IDs */%@AE@%%@NL@%
    char snapstk[STKSIZE];              %@AB@%/* snapshot thread stack */%@AE@%%@NL@%
    char watchstk[STKSIZE];             %@AB@%/* keyboard thread stack */%@AE@%%@NL@%
%@NL@%
    DosGetInfoSeg(&gseg, &lseg);        %@AB@%/* get info segment selectors */%@AE@%%@NL@%
    (long) ginfo = (long) gseg << 16;   %@AB@%/* make far pointer */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* build semaphore and file names */%@AE@%%@NL@%
    sprintf(sname, "\\SEM\\SNAP%02d.LCK", ginfo[0x18]);%@NL@%
    sprintf(fname, "\\SNAP%02d.IMG",      ginfo[0x18]);%@NL@%
%@NL@%
    if(DosOpenSem(&shandle, sname))     %@AB@%/* does \SEM\SNAPxx.LCK exist? */%@AE@%%@NL@%
    {%@NL@%
                                        %@AB@%/* no, we're parent SNAP */%@AE@%%@NL@%
                                        %@AB@%/* create system semaphore */%@AE@%%@NL@%
        if(DosCreateSem(1, &shandle, sname))%@NL@%
            errexit("Can't create SNAP system semaphore.");%@NL@%
        DosSemSet((unsigned long far *) shandle);%@NL@%
%@NL@%
                                        %@AB@%/* start detached child SNAP */%@AE@%%@NL@%
        if(DosExecPgm(obuff, sizeof(obuff), 4, NULL, NULL, retcode, "snap.exe"))%@NL@%
            errexit("Can't start child copy of SNAP.");%@NL@%
%@NL@%
                                        %@AB@%/* wait for child to load */%@AE@%%@NL@%
        DosSemWait((unsigned long far *) shandle, -1L);%@NL@%
        DosCloseSem((unsigned long far *) shandle);%@NL@%
    }%@NL@%
    else                                %@AB@%/* if SNAPxx.LCK exists, */%@AE@%%@NL@%
    {                                   %@AB@%/* we're the child SNAP */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* abort if already resident */%@AE@%%@NL@%
        if(! DosSemWait((unsigned long far *) shandle, 0L))%@NL@%
            errexit("SNAP is already loaded.");%@NL@%
%@NL@%
        DosSemSet(&exitsem);            %@AB@%/* initialize exit and */%@AE@%%@NL@%
        DosSemSet(&snapsem);            %@AB@%/* snapshot semaphores */%@AE@%%@NL@%
    %@NL@%
        if(DosMonOpen(kname, &khandle)) %@AB@%/* open monitor connection */%@AE@%%@NL@%
            errexit("Can't open KBD$ monitor connection.");%@NL@%
%@NL@%
                                        %@AB@%/* register at head of chain */%@AE@%%@NL@%
        if(DosMonReg(khandle, &kbdin, &kbdout, 1, ginfo[0x18]))%@NL@%
            errexit("Can't register as KBD$ monitor.");%@NL@%
%@NL@%
                                        %@AB@%/* create keyboard thread */%@AE@%%@NL@%
        if(DosCreateThread(watch, &watchID, watchstk+STKSIZE))%@NL@%
            errexit("Can't create keyboard thread.");%@NL@%
%@NL@%
        DosSetPrty(2, 3, 0, watchID);   %@AB@%/* promote keyboard thread */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* create snapshot thread */%@AE@%%@NL@%
        if(DosCreateThread(snap, &snapID, snapstk+STKSIZE))%@NL@%
            errexit("Can't create snapshot thread.");%@NL@%
%@NL@%
        signon();                       %@AB@%/* announce installation */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* tell parent we're running */%@AE@%%@NL@%
        DosSemClear((unsigned long far *) shandle);%@NL@%
%@NL@%
        DosSemWait(&exitsem, -1L);        %@AB@%/* wait for exit hot key */%@AE@%%@NL@%
%@NL@%
        DosSuspendThread(snapID);       %@AB@%/* suspend snapshot thread */%@AE@%%@NL@%
        DosSuspendThread(watchID);      %@AB@%/* suspend keyboard thread */%@AE@%%@NL@%
        DosMonClose(khandle);           %@AB@%/* close monitor connection */%@AE@%%@NL@%
                                        %@AB@%/* close system semaphore */%@AE@%%@NL@%
        DosCloseSem((unsigned long far *) shandle);%@NL@%
        DosClose(fhandle);              %@AB@%/* close snapshot file */%@AE@%%@NL@%
%@NL@%
        signoff();                        %@AB@%/* announce deinstallation */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    DosExit(1, 0);                      %@AB@%/* final exit */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    The 'watch' thread is responsible for monitoring the keyboard%@NL@%
%@AB@%    data stream.  It clears the 'snapsem' semaphore when the %@NL@%
%@AB@%    screen capture hot key is detected and clears the 'exitsem'%@NL@%
%@AB@%    semaphore when the deinstall hot key is detected.%@NL@%
%@AB@%*/%@AE@%%@NL@%
void far watch(void)%@NL@%
{%@NL@%
    char kbdpkt[128];                   %@AB@%/* monitor data packet */%@AE@%%@NL@%
    int kbdpktlen;                      %@AB@%/* data packet length */%@AE@%%@NL@%
%@NL@%
    while(1)%@NL@%
    {%@NL@%
        kbdpktlen = sizeof(kbdpkt);     %@AB@%/* set buffer length */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* read monitor data */%@AE@%%@NL@%
        DosMonRead(&kbdin, WAIT, kbdpkt, &kbdpktlen);%@NL@%
%@NL@%
                                        %@AB@%/* check for hot keys */%@AE@%%@NL@%
                                        %@AB@%/* ignore key breaks */%@AE@%%@NL@%
        if((kbdpkt[2] == 0) && (kbdpkt[3] == EXITKEY))%@NL@%
        {                                %@AB@%/* exit hot key detected */%@AE@%%@NL@%
            if(kbdpkt[12] == 0) DosSemClear(&exitsem);%@NL@%
        }%@NL@%
        else if((kbdpkt[2] == 0) && (kbdpkt[3] == SNAPKEY))%@NL@%
        {                                %@AB@%/* snapshot hot key detected */%@AE@%%@NL@%
            if(kbdpkt[12] == 0) DosSemClear(&snapsem);%@NL@%
        }                                %@AB@%/* not hot key, pass it through */%@AE@%%@NL@%
        else DosMonWrite(&kbdout, kbdpkt, kbdpktlen);%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    The 'snap' thread blocks on the 'snapsem' semaphore until it%@NL@%
%@AB@%    is cleared by the 'watch' thread, then captures the current%@NL@%
%@AB@%    screen contents into the snapshot file.%@NL@%
%@AB@%*/%@AE@%%@NL@%
void far snap(void)%@NL@%
{%@NL@%
    int i;                              %@AB@%/* scratch variable */%@AE@%%@NL@%
    unsigned action;                    %@AB@%/* receives DosOpen action */%@AE@%%@NL@%
    unsigned wlen;                      %@AB@%/* receives DosWrite length */%@AE@%%@NL@%
    char divider[81];                   %@AB@%/* snapshot divider line */%@AE@%%@NL@%
    char scrbuf[80];                    %@AB@%/* receives screen data */%@AE@%%@NL@%
    int slen;                           %@AB@%/* contains buffer size */%@AE@%%@NL@%
%@NL@%
    memset(divider, '-', 79);           %@AB@%/* initialize divider line */%@AE@%%@NL@%
    divider[79] = 0x0d;%@NL@%
    divider[80] = 0x0a;%@NL@%
%@NL@%
                                        %@AB@%/* create/replace snapshot file */%@AE@%%@NL@%
    if(DosOpen(fname, &fhandle, &action, 0L, 0, 0x12, 0x21, 0L))%@NL@%
        errexit("Can't create snapshot file.");%@NL@%
%@NL@%
    while(1)%@NL@%
    {                                   %@AB@%/* write divider line */%@AE@%%@NL@%
        DosWrite(fhandle, divider, sizeof(divider), &wlen);%@NL@%
        DosBufReset(fhandle);           %@AB@%/* force file update */%@AE@%%@NL@%
%@NL@%
        DosSemWait(&snapsem, -1L);        %@AB@%/* wait for hot key */%@AE@%%@NL@%
%@NL@%
        popup(3);                        %@AB@%/* pop-up in transparent mode */%@AE@%%@NL@%
        vioinfo.len = sizeof(vioinfo);  %@AB@%/* get screen dimensions */%@AE@%%@NL@%
        VioGetMode(&vioinfo, 0);%@NL@%
%@NL@%
        for(i = 0; i < vioinfo.rows; i++)%@NL@%
        {%@NL@%
            slen = vioinfo.cols;        %@AB@%/* read line from screen */%@AE@%%@NL@%
            VioReadCharStr(scrbuf, &slen, i, 0, 0);%@NL@%
%@NL@%
                                        %@AB@%/* discard trailing spaces */%@AE@%%@NL@%
            while((slen > 0) && (scrbuf[slen-1] == 0x20)) slen--;%@NL@%
%@NL@%
                                        %@AB@%/* write line to file */%@AE@%%@NL@%
            DosWrite(fhandle, scrbuf, slen, &wlen); %@NL@%
            DosWrite(fhandle, "\x0d\x0a", 2, &wlen);%@NL@%
        }%@NL@%
%@NL@%
        DosBeep(440, 200);              %@AB@%/* reward the user */%@AE@%%@NL@%
        unpop();                        %@AB@%/* release screen */%@AE@%%@NL@%
        DosSemSet(&snapsem);            %@AB@%/* reset snapshot semaphore */%@AE@%%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Display the installation and help messages in popup window.%@NL@%
%@AB@%*/%@AE@%%@NL@%
void signon(void)%@NL@%
{%@NL@%
    popup(1);                           %@AB@%/* acquire popup screen */%@AE@%%@NL@%
    VioWrtCharStr(msg1, sizeof(msg1), 10, ((80-sizeof(msg1))/2), 0);%@NL@%
    VioWrtCharStr(msg2, sizeof(msg2), 13, ((80-sizeof(msg2))/2), 0);%@NL@%
    VioWrtCharStr(msg3, sizeof(msg3), 15, ((80-sizeof(msg3))/2), 0);%@NL@%
    DosSleep(4000L);                        %@AB@%/* pause for 4 seconds */%@AE@%%@NL@%
    unpop();                            %@AB@%/* release popup screen */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Display exit message in popup window.%@NL@%
%@AB@%*/%@AE@%%@NL@%
void signoff(void)                      %@NL@%
{%@NL@%
    popup(1);                           %@AB@%/* acquire popup screen */%@AE@%%@NL@%
    VioWrtCharStr(msg4, sizeof(msg4), 12, ((80-sizeof(msg4))/2), 0);%@NL@%
    DosSleep(2000L);                        %@AB@%/* pause for 2 seconds */%@AE@%%@NL@%
    unpop();                            %@AB@%/* release popup screen */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Get popup screen, using wait/no-wait and%@NL@%
%@AB@%    transparent/nontransparent flags supplied by caller.%@NL@%
%@AB@%*/%@AE@%%@NL@%
void popup(unsigned pflags)%@NL@%
{%@NL@%
    VioPopUp(&pflags, 0);   %@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Take down popup screen.%@NL@%
%@AB@%*/%@AE@%%@NL@%
void unpop(void)%@NL@%
{%@NL@%
    VioEndPopUp(0);%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Common error exit routine.  Display error message on popup%@NL@%
%@AB@%    screen and terminate process.%@NL@%
%@AB@%*/%@AE@%%@NL@%
void errexit(char *errmsg)%@NL@%
{%@NL@%
    if(khandle != 0)                    %@AB@%/* close monitor handle */%@AE@%%@NL@%
        DosMonClose(khandle);           %@AB@%/* if monitor active */%@AE@%%@NL@%
%@NL@%
    if(shandle != 0)                    %@AB@%/* clear and close the */%@AE@%%@NL@%
    {                                   %@AB@%/* SNAPxx.LCK semaphore */%@AE@%%@NL@%
        DosSemClear((unsigned long far *) shandle);%@NL@%
        DosCloseSem((unsigned long far *) shandle);%@NL@%
    }%@NL@%
%@NL@%
    popup(1);                           %@AB@%/* get popup screen and */%@AE@%%@NL@%
                                        %@AB@%/* display error message */%@AE@%%@NL@%
    VioWrtCharStr(msg5, sizeof(msg5), 10, ((80-sizeof(msg5))/2), 0);%@NL@%
    VioWrtCharStr(errmsg, strlen(errmsg), 12, ((80-strlen(errmsg))/2), 0);%@NL@%
    DosSleep(3000L);                        %@AB@%/* let user read message */%@AE@%%@NL@%
    unpop();                            %@AB@%/* release popup screen */%@AE@%%@NL@%
    DosExit(1, 1);                        %@AB@%/* terminate, exitcode = 1 */%@AE@%%@NL@%
}                                       %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%STAMPER.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH18\STAMPER.ASM%@AE@%%@NL@%
%@NL@%
        title   STAMPER: a simple keyboard monitor%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
        .sall%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; STAMPER.EXE: a simple OS/2 monitor that inserts%@AE@%%@NL@%
%@AB@%; a date or time stamp into the keyboard data stream.%@AE@%%@NL@%
%@AB@%; Copyright (C) 1987 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Alt-D  is the hot-key for a date-stamp.%@AE@%%@NL@%
%@AB@%; Alt-T  is the hot-key for a time-stamp.%@AE@%%@NL@%
%@AB@%; Alt-X  causes the STAMPER.EXE monitor to exit.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; In order to keep this example program simple, it%@AE@%%@NL@%
%@AB@%; contains minimal error handling and does not check%@AE@%%@NL@%
%@AB@%; for previously loaded copies of itself in the same%@AE@%%@NL@%
%@AB@%; screen group etc.  For a more complete example, see%@AE@%%@NL@%
%@AB@%; the SNAP.ASM or SNAP.C program.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build with:   C>MASM STAMPER;%@AE@%%@NL@%
%@AB@%;               C>LINK STAMPER,,,OS2,STAMPER;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        C>DETACH STAMPER%@AE@%%@NL@%
%@NL@%
stdin   equ     0                       %@AB@%; standard device handles%@AE@%%@NL@%
stdout  equ     1%@NL@%
stderr  equ     2%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII line feed%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; Hot-key definitions:%@AE@%%@NL@%
datekey equ     20h                     %@AB@%; Alt-D = insert date%@AE@%%@NL@%
timekey equ     14h                     %@AB@%; Alt-T = insert time%@AE@%%@NL@%
exitkey equ     2dh                     %@AB@%; Alt-X = exit program%@AE@%%@NL@%
%@NL@%
        extrn   DosExit:far             %@AB@%; references to OS/2 API%@AE@%%@NL@%
        extrn   DosGetInfoSeg:far%@NL@%
        extrn   DosMonClose:far%@NL@%
        extrn   DosMonOpen:far%@NL@%
        extrn   DosMonRead:far%@NL@%
        extrn   DosMonReg:far%@NL@%
        extrn   DosMonWrite:far%@NL@%
        extrn   DosSetPrty:far%@NL@%
        extrn   DosSleep:far%@NL@%
        extrn   DosWrite:far%@NL@%
        extrn   VioEndPopUp:far%@NL@%
        extrn   VioGetAnsi:far%@NL@%
        extrn   VioPopUp:far%@NL@%
        extrn   VioWrtCharStr:far%@NL@%
%@NL@%
jerr    macro   target                  %@AB@%;; Macro to test return code%@AE@%%@NL@%
        local   zero                    %@AB@%;; in AX and jump if non-zero.%@AE@%%@NL@%
        or      ax,ax                   %@AB@%;; Uses JMP DISP16 to avoid%@AE@%%@NL@%
        jz      zero                    %@AB@%;; branch out of range errors%@AE@%%@NL@%
        jmp     target%@NL@%
zero:%@NL@%
        endm%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
kname   db      'KBD$',0                %@AB@%; device name of keyboard%@AE@%%@NL@%
khandle dw      0                       %@AB@%; handle from DosMonOpen%@AE@%%@NL@%
%@NL@%
gseg    dw      ?                       %@AB@%; global information segment%@AE@%%@NL@%
lseg    dw      ?                       %@AB@%; local information segment%@AE@%%@NL@%
scrgrp  dw      ?                       %@AB@%; foreground screen group%@AE@%%@NL@%
ansi    dw      ?                       %@AB@%; receives ANSI state%@AE@%%@NL@%
popflag dw      1                       %@AB@%; wait for PopUp window%@AE@%%@NL@%
wlen    dw      ?                       %@AB@%; receives length written%@AE@%%@NL@%
%@NL@%
dstr    db      'mm/dd/yy',0            %@AB@%; strings used by time and%@AE@%%@NL@%
tstr    db      'hh:mm',0               %@AB@%; date formatting routines%@AE@%%@NL@%
%@NL@%
monin   dw      128,64 dup (0)          %@AB@%; buffers for monitor%@AE@%%@NL@%
monout  dw      128,64 dup (0)%@NL@%
%@NL@%
packet  db      128 dup (0)             %@AB@%; buffer for kbd data packet%@AE@%%@NL@%
pktlen  dw      ?                       %@AB@%; contains max buffer length;%@AE@%%@NL@%
                                        %@AB@%; receives actual data length%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf,'Start STAMPER with DETACH!',cr,lf%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      'STAMPER utility installed'%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
msg3    db      'Alt-D to insert date stamp,'%@NL@%
msg3_len equ $-msg3%@NL@%
%@NL@%
msg4    db      'Alt-T to insert time stamp,'%@NL@%
msg4_len equ $-msg4%@NL@%
%@NL@%
msg5    db      'Alt-X to shut down STAMPER.'%@NL@%
msg5_len equ $-msg5%@NL@%
%@NL@%
msg6    db      'STAMPER utility deactivated.'%@NL@%
msg6_len equ $-msg6%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP,ss:DGROUP%@NL@%
%@NL@%
main    proc    far                     %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; get info segment selectors...%@AE@%%@NL@%
        push    ds                      %@AB@%; receives global selector%@AE@%%@NL@%
        push    offset DGROUP:gseg%@NL@%
        push    ds                      %@AB@%; receives local selector%@AE@%%@NL@%
        push    offset DGROUP:lseg%@NL@%
        call    DosGetInfoSeg           %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main6                   %@AB@%; give up if can't get selectors%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; make sure we are detached...%@AE@%%@NL@%
        push    ds                      %@AB@%; receives ANSI state flag%@AE@%%@NL@%
        push    offset DGROUP:ansi%@NL@%
        push    0                       %@AB@%; VIO handle%@AE@%%@NL@%
        call    VioGetAnsi%@NL@%
        or      ax,ax                   %@AB@%; call should fail, otherwise%@AE@%%@NL@%
        jnz     main1                   %@AB@%; we are not detached.%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; not detached, display error%@AE@%%@NL@%
                                        %@AB@%; message and exit...%@AE@%%@NL@%
        push    stderr                  %@AB@%; handle for standard error%@AE@%%@NL@%
        push    ds                      %@AB@%; address of message%@AE@%%@NL@%
        push    offset DGROUP:msg1%@NL@%
        push    msg1_len                %@AB@%; length of message%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jmp     main6                   %@AB@%; go exit with error code%@AE@%%@NL@%
%@NL@%
main1:  mov     es,gseg                 %@AB@%; get foreground screen group%@AE@%%@NL@%
        mov     al,byte ptr es:[0018h]  %@AB@%; from global info segment%@AE@%%@NL@%
        cbw%@NL@%
        mov     scrgrp,ax               %@AB@%; and save it%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; open monitor connection...%@AE@%%@NL@%
        push    ds                      %@AB@%; address of device name KBD$%@AE@%%@NL@%
        push    offset DGROUP:kname%@NL@%
        push    ds                      %@AB@%; receives monitor handle%@AE@%%@NL@%
        push    offset DGROUP:khandle%@NL@%
        call    DosMonOpen              %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main6                   %@AB@%; give up if can't open it%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; register as keyboard monitor...%@AE@%%@NL@%
        push    khandle                 %@AB@%; handle from DosMonOpen%@AE@%%@NL@%
        push    ds                      %@AB@%; addr of monitor input buffer%@AE@%%@NL@%
        push    offset DGROUP:monin%@NL@%
        push    ds                      %@AB@%; addr of monitor output buffer%@AE@%%@NL@%
        push    offset DGROUP:monout%@NL@%
        push    1                       %@AB@%; request front of list%@AE@%%@NL@%
        push    scrgrp                  %@AB@%; index = screen group%@AE@%%@NL@%
        call    DosMonReg               %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jerr    main6                   %@AB@%; give up if can't register%@AE@%%@NL@%
%@NL@%
        call    signon                  %@AB@%; else announce our presence%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; promote main thread to time-%@AE@%%@NL@%
                                        %@AB@%; critical priority...%@AE@%%@NL@%
        push    2                       %@AB@%; scope = single thread this process%@AE@%%@NL@%
        push    3                       %@AB@%; class = time-critical%@AE@%%@NL@%
        push    0                       %@AB@%; level = 0 within class%@AE@%%@NL@%
        push    1                       %@AB@%; thread ID%@AE@%%@NL@%
        call    DosSetPrty              %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main2:                                  %@AB@%; monitor the keyboard character%@AE@%%@NL@%
                                        %@AB@%; stream; when hot key detected,%@AE@%%@NL@%
                                        %@AB@%; insert the appropriate date or%@AE@%%@NL@%
                                        %@AB@%; time stamp, or exit.%@AE@%%@NL@%
%@NL@%
        mov     pktlen,pktlen-packet    %@AB@%; set max buffer length for read%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; get next keyboard data packet%@AE@%%@NL@%
        push    ds                      %@AB@%; address of monitor input buffer%@AE@%%@NL@%
        push    offset DGROUP:monin%@NL@%
        push    0                       %@AB@%; wait until data available%@AE@%%@NL@%
        push    ds%@NL@%
        push    offset DGROUP:packet    %@AB@%; buffer for keyboard data packet%@AE@%%@NL@%
        push    ds%@NL@%
        push    offset DGROUP:pktlen    %@AB@%; receives length of data packet%@AE@%%@NL@%
        call    DosMonRead              %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr packet+2,0     %@AB@%; is this extended code?%@AE@%%@NL@%
        jnz     main4                   %@AB@%; no, just pass it on%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr packet+3,exitkey%@NL@%
        jz      main5                   %@AB@%; jump if exit hot-key%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr packet+3,timekey%@NL@%
        jnz     main3                   %@AB@%; jump if not time hot-key%@AE@%%@NL@%
%@NL@%
        cmp     word ptr packet+12,0    %@AB@%; discard break packets%@AE@%%@NL@%
        jnz     main2%@NL@%
%@NL@%
        call    time                    %@AB@%; insert the time stamp%@AE@%%@NL@%
%@NL@%
        jmp     main2                   %@AB@%; discard this key%@AE@%%@NL@%
%@NL@%
main3:                                  %@AB@%; is it datestamp hot-key?%@AE@%%@NL@%
        cmp     byte ptr packet+3,datekey%@NL@%
        jnz     main4                   %@AB@%; no, jump%@AE@%%@NL@%
%@NL@%
        cmp     word ptr packet+12,0    %@AB@%; discard break packets%@AE@%%@NL@%
        jnz     main2%@NL@%
%@NL@%
        call    date                    %@AB@%; insert the date stamp%@AE@%%@NL@%
%@NL@%
        jmp     main2                   %@AB@%; discard this key%@AE@%%@NL@%
%@NL@%
main4:                                  %@AB@%; Not hot-key, pass packet on.%@AE@%%@NL@%
        push    ds                      %@AB@%; address of monitor output buffer%@AE@%%@NL@%
        push    offset DGROUP:monout%@NL@%
        push    ds                      %@AB@%; address of keyboard data packet%@AE@%%@NL@%
        push    offset DGROUP:packet%@NL@%
        push    pktlen                  %@AB@%; length of data packet%@AE@%%@NL@%
        call    DosMonWrite             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp     main2                   %@AB@%; wait for another packet%@AE@%%@NL@%
%@NL@%
main5:                                  %@AB@%; hotkey for de-install detected%@AE@%%@NL@%
%@NL@%
        cmp     word ptr packet+12,0    %@AB@%; make sure it's Break packet%@AE@%%@NL@%
        jz      main2                   %@AB@%; if not just discard it%@AE@%%@NL@%
%@NL@%
        push    khandle                 %@AB@%; close the monitor connection%@AE@%%@NL@%
        call    DosMonClose             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        call    signoff                 %@AB@%; announce STAMPER exit%@AE@%%@NL@%
%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0                       %@AB@%; return success code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; final exit to OS/2%@AE@%%@NL@%
%@NL@%
main6:                                  %@AB@%; common error exit point...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1                       %@AB@%; return error code%@AE@%%@NL@%
        call    DosExit                 %@AB@%; final exit to OS/2%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
%@NL@%
date    proc    near                    %@AB@%; format and insert date stamp%@AE@%%@NL@%
%@NL@%
        mov     es,gseg                 %@AB@%; get selector for global%@AE@%%@NL@%
                                        %@AB@%; read-only information segment%@AE@%%@NL@%
%@NL@%
        mov     al,byte ptr es:[11h]    %@AB@%; convert month to ASCII%@AE@%%@NL@%
        aam%@NL@%
        add     ax,'00'%@NL@%
        xchg    al,ah%@NL@%
        mov     word ptr dstr,ax%@NL@%
%@NL@%
        mov     al,byte ptr es:[10h]    %@AB@%; convert day to ASCII%@AE@%%@NL@%
        aam%@NL@%
        add     ax,'00'%@NL@%
        xchg    al,ah%@NL@%
        mov     word ptr dstr+3,ax%@NL@%
%@NL@%
        mov     ax,word ptr es:[12h]    %@AB@%; convert year to ASCII%@AE@%%@NL@%
        sub     ax,1900%@NL@%
        aam%@NL@%
        add     ax,'00'%@NL@%
        xchg    al,ah%@NL@%
        mov     word ptr dstr+6,ax%@NL@%
%@NL@%
        mov     si,offset DGROUP:dstr   %@AB@%; insert date stamp string%@AE@%%@NL@%
        call    stuff                   %@AB@%; into keyboard data stream%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
date    endp%@NL@%
%@NL@%
%@NL@%
time    proc    near                    %@AB@%; format and insert time stamp%@AE@%%@NL@%
%@NL@%
        mov     es,gseg                 %@AB@%; get selector for global%@AE@%%@NL@%
                                        %@AB@%; read-only information segment%@AE@%%@NL@%
%@NL@%
        mov     al,byte ptr es:[8]      %@AB@%; convert hours to ASCII%@AE@%%@NL@%
        aam%@NL@%
        add     ax,'00'%@NL@%
        xchg    al,ah%@NL@%
        mov     word ptr tstr,ax%@NL@%
%@NL@%
        mov     al,byte ptr es:[9]      %@AB@%; convert minutes to ASCII%@AE@%%@NL@%
        aam%@NL@%
        add     ax,'00'%@NL@%
        xchg    al,ah%@NL@%
        mov     word ptr tstr+3,ax%@NL@%
%@NL@%
        mov     si,offset DGROUP:tstr   %@AB@%; insert time stamp string%@AE@%%@NL@%
        call    stuff                   %@AB@%; into keyboard data stream%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
time    endp%@NL@%
%@NL@%
%@NL@%
stuff   proc    near                    %@AB@%; insert string into keyboard%@AE@%%@NL@%
                                        %@AB@%; data stream.  Call with%@AE@%%@NL@%
                                        %@AB@%; SI = ASCIIZ string (null%@AE@%%@NL@%
                                        %@AB@%;      is discarded)%@AE@%%@NL@%
                                        %@AB@%; AL, SI destroyed.%@AE@%%@NL@%
%@NL@%
stuff1: lodsb                           %@AB@%; get next character%@AE@%%@NL@%
        or      al,al                   %@AB@%; is it null?%@AE@%%@NL@%
        jnz     stuff2                  %@AB@%; no, use it%@AE@%%@NL@%
        ret                             %@AB@%; yes, exit%@AE@%%@NL@%
%@NL@%
stuff2: mov     packet+2,al             %@AB@%; place ASCII code into packet%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; now send this character%@AE@%%@NL@%
                                        %@AB@%; to the keyboard driver...%@AE@%%@NL@%
        push    ds                      %@AB@%; monitor output buffer address%@AE@%%@NL@%
        push    offset DGROUP:monout%@NL@%
        push    ds                      %@AB@%; keyboard data packet address%@AE@%%@NL@%
        push    offset DGROUP:packet%@NL@%
        push    pktlen                  %@AB@%; data packet length%@AE@%%@NL@%
        call    DosMonWrite             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp     stuff1                  %@AB@%; do another character%@AE@%%@NL@%
%@NL@%
stuff   endp%@NL@%
%@NL@%
%@NL@%
signon  proc    near                    %@AB@%; use pop-up window to%@AE@%%@NL@%
                                        %@AB@%; display help message%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; put up PopUp window%@AE@%%@NL@%
        push    offset DGROUP:popflag   %@AB@%; (wait until available)%@AE@%%@NL@%
        push    0                       %@AB@%; VIO handle%@AE@%%@NL@%
        call    VioPopUp                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov     dx,offset DGROUP:msg2   %@AB@%; message address%@AE@%%@NL@%
        mov     cx,msg2_len             %@AB@%; length%@AE@%%@NL@%
        mov     ax,9                    %@AB@%; Y coordinate%@AE@%%@NL@%
        call    center                  %@AB@%; display it%@AE@%%@NL@%
%@NL@%
        mov     dx,offset DGROUP:msg3   %@AB@%; message address%@AE@%%@NL@%
        mov     cx,msg3_len             %@AB@%; length%@AE@%%@NL@%
        mov     ax,13                   %@AB@%; Y coordinate%@AE@%%@NL@%
        call    center                  %@AB@%; display it%@AE@%%@NL@%
%@NL@%
        mov     dx,offset DGROUP:msg4   %@AB@%; message address%@AE@%%@NL@%
        mov     cx,msg4_len             %@AB@%; length%@AE@%%@NL@%
        mov     ax,15                   %@AB@%; Y coordinate%@AE@%%@NL@%
        call    center                  %@AB@%; display it%@AE@%%@NL@%
%@NL@%
        mov     dx,offset DGROUP:msg5   %@AB@%; message address%@AE@%%@NL@%
        mov     cx,msg5_len             %@AB@%; length%@AE@%%@NL@%
        mov     ax,17                   %@AB@%; Y coordinate%@AE@%%@NL@%
        call    center                  %@AB@%; display it%@AE@%%@NL@%
%@NL@%
        push    0                       %@AB@%; pause for 3 seconds%@AE@%%@NL@%
        push    3000                    %@AB@%; (user must be quick reader!)%@AE@%%@NL@%
        call    DosSleep                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    0                       %@AB@%; take down PopUp window%@AE@%%@NL@%
        call    VioEndPopUp             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
signon  endp%@NL@%
%@NL@%
%@NL@%
signoff proc    near                    %@AB@%; use pop-up window to%@AE@%%@NL@%
                                        %@AB@%; announce exit%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; put up PopUp window%@AE@%%@NL@%
        push    offset DGROUP:popflag   %@AB@%; (wait until available)%@AE@%%@NL@%
        push    0                       %@AB@%; VIO handle%@AE@%%@NL@%
        call    VioPopUp                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov     dx,offset DGROUP:msg6   %@AB@%; address of signoff message%@AE@%%@NL@%
        mov     cx,msg6_len             %@AB@%; length%@AE@%%@NL@%
        mov     ax,12                   %@AB@%; Y coordinate%@AE@%%@NL@%
        call    center                  %@AB@%; display it%@AE@%%@NL@%
%@NL@%
        push    0                       %@AB@%; pause for 1 second so%@AE@%%@NL@%
        push    1000                    %@AB@%; user can read message%@AE@%%@NL@%
        call    DosSleep                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        push    0                       %@AB@%; take down PopUp window%@AE@%%@NL@%
        call    VioEndPopUp             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
signoff endp%@NL@%
%@NL@%
%@NL@%
center  proc    near                    %@AB@%; center a message on screen%@AE@%%@NL@%
                                        %@AB@%; call DX = msg offset,%@AE@%%@NL@%
                                        %@AB@%; CX = length, AX = Y coordinate%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; address of message%@AE@%%@NL@%
        push    dx%@NL@%
        push    cx                      %@AB@%; length of message%@AE@%%@NL@%
        push    ax                      %@AB@%; Y%@AE@%%@NL@%
        sub     cx,80                   %@AB@%; X=((80-length)/2)%@AE@%%@NL@%
        neg     cx                      %@AB@%; to center message%@AE@%%@NL@%
        shr     cx,1%@NL@%
        push    cx%@NL@%
        push    0                       %@AB@%; VIO handle%@AE@%%@NL@%
        call    VioWrtCharStr           %@AB@%; transfer to OS/2%@AE@%%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
center  endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TEMPLATE.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH17\TEMPLATE.ASM%@AE@%%@NL@%
%@NL@%
        title        TEMPLATE -- Sample Device Driver%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; TEMPLATE.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; A sample OS/2 character device driver.  The driver command code%@AE@%%@NL@%
%@AB@%; routines are stubs only and have no effect but to return a%@AE@%%@NL@%
%@AB@%; nonerror "done" status.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm template.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link template,template.sys,,os2,template%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; To install the driver, add "DEVICE=TEMPLATE.SYS" to CONFIG.SYS%@AE@%%@NL@%
%@AB@%; and reboot.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
maxcmd  equ     26              %@AB@%; maximum allowed command code%@AE@%%@NL@%
%@NL@%
stdin   equ     0               %@AB@%; standard device handles%@AE@%%@NL@%
stdout  equ     1%@NL@%
stderr  equ     2%@NL@%
%@NL@%
cr      equ     0dh             %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf        equ        0ah                %@AB@%; ASCII linefeed%@AE@%%@NL@%
%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
                                %@AB@%; device driver header...%@AE@%%@NL@%
header  dd      -1              %@AB@%; link to next device driver%@AE@%%@NL@%
        dw      8880h           %@AB@%; device attribute word%@AE@%%@NL@%
        dw      Strat           %@AB@%; Strategy entry point%@AE@%%@NL@%
        dw        0                %@AB@%; IDC entry point%@AE@%%@NL@%
        db      'TEMPLATE'      %@AB@%; logical device name%@AE@%%@NL@%
        db        8 dup (0)        %@AB@%; reserved%@AE@%%@NL@%
%@NL@%
devhlp  dd      ?               %@AB@%; DevHlp entry point%@AE@%%@NL@%
%@NL@%
wlen    dw      ?               %@AB@%; receives DosWrite length%@AE@%%@NL@%
%@NL@%
                                %@AB@%; Strategy routine dispatch table%@AE@%%@NL@%
                                %@AB@%; for request packet command code...%@AE@%%@NL@%
dispch  dw      Init            %@AB@%; 0  = initialize driver%@AE@%%@NL@%
        dw      MediaChk        %@AB@%; 1  = media check%@AE@%%@NL@%
        dw      BuildBPB        %@AB@%; 2  = build BIOS parameter block%@AE@%%@NL@%
        dw      Error           %@AB@%; 3  = not used%@AE@%%@NL@%
        dw      Read            %@AB@%; 4  = read from device%@AE@%%@NL@%
        dw        NdRead                %@AB@%; 5  = nondestructive read%@AE@%%@NL@%
        dw      InpStat         %@AB@%; 6  = return input status%@AE@%%@NL@%
        dw      InpFlush        %@AB@%; 7  = flush device input buffers%@AE@%%@NL@%
        dw      Write           %@AB@%; 8  = write to device%@AE@%%@NL@%
        dw      WriteVfy        %@AB@%; 9  = write with verify%@AE@%%@NL@%
        dw      OutStat         %@AB@%; 10 = return output status%@AE@%%@NL@%
        dw      OutFlush        %@AB@%; 11 = flush output buffers%@AE@%%@NL@%
        dw      Error           %@AB@%; 12 = not used%@AE@%%@NL@%
        dw      DevOpen         %@AB@%; 13 = device open%@AE@%%@NL@%
        dw      DevClose        %@AB@%; 14 = device close%@AE@%%@NL@%
        dw        RemMedia        %@AB@%; 15 = removable media%@AE@%%@NL@%
        dw      GenIOCTL        %@AB@%; 16 = generic IOCTL%@AE@%%@NL@%
        dw      ResetMed        %@AB@%; 17 = reset media%@AE@%%@NL@%
        dw      GetLogDrv       %@AB@%; 18 = get logical drive%@AE@%%@NL@%
        dw      SetLogDrv       %@AB@%; 19 = set logical drive%@AE@%%@NL@%
        dw      DeInstall       %@AB@%; 20 = de-install%@AE@%%@NL@%
        dw      Error           %@AB@%; 21 = not used%@AE@%%@NL@%
        dw      PartFD          %@AB@%; 22 = partitionable fixed disks%@AE@%%@NL@%
        dw      FDMap           %@AB@%; 23 = get fixed disk unit map%@AE@%%@NL@%
        dw      Error           %@AB@%; 24 = not used%@AE@%%@NL@%
        dw      Error           %@AB@%; 25 = not used%@AE@%%@NL@%
        dw      Error           %@AB@%; 26 = not used%@AE@%%@NL@%
%@NL@%
ident   db      cr,lf,lf%@NL@%
        db        'TEMPLATE Sample OS/2 Device Driver'%@NL@%
        db      cr,lf%@NL@%
ident_len equ $-ident%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP,es:NOTHING%@NL@%
%@NL@%
Strat   proc    far             %@AB@%; Strategy entry point%@AE@%%@NL@%
                                %@AB@%; ES:BX = request packet address%@AE@%%@NL@%
%@NL@%
        mov     di,es:[bx+2]    %@AB@%; get command code from packet%@AE@%%@NL@%
        and     di,0ffh%@NL@%
        cmp     di,maxcmd       %@AB@%; supported by this driver?%@AE@%%@NL@%
        jle     Strat1          %@AB@%; jump if command code OK%@AE@%%@NL@%
%@NL@%
        call    Error           %@AB@%; bad command code%@AE@%%@NL@%
        jmp     Strat2%@NL@%
%@NL@%
Strat1: add     di,di           %@AB@%; branch to command code routine%@AE@%%@NL@%
        call    word ptr [di+dispch]%@NL@%
%@NL@%
Strat2: mov     es:[bx+3],ax    %@AB@%; status into request packet%@AE@%%@NL@%
        ret                     %@AB@%; back to OS/2 kernel%@AE@%%@NL@%
%@NL@%
Strat   endp%@NL@%
%@NL@%
%@NL@%
Intr    proc  far               %@AB@%; driver Interrupt handler%@AE@%%@NL@%
%@NL@%
        clc                     %@AB@%; signal we owned interrupt%@AE@%%@NL@%
        ret                     %@AB@%; return from interrupt%@AE@%%@NL@%
%@NL@%
Intr    endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; Command code routines are called by the Strategy routine%@AE@%%@NL@%
%@AB@%; via the Dispatch table with ES:BX pointing to the request%@AE@%%@NL@%
%@AB@%; header.  Each routine should return ES:BX unchanged%@AE@%%@NL@%
%@AB@%; and AX = status to be placed in request packet:%@AE@%%@NL@%
%@AB@%; 0100H if 'done' and no error%@AE@%%@NL@%
%@AB@%; 0000H if thread should block pending interrupt%@AE@%%@NL@%
%@AB@%; 81xxH if 'done' and error detected (xx=error code)%@AE@%%@NL@%
%@NL@%
MediaChk proc   near            %@AB@%; function 1 = media check%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
MediaChk endp%@NL@%
%@NL@%
%@NL@%
BuildBPB proc   near            %@AB@%; function 2 = build BPB%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
BuildBPB endp%@NL@%
%@NL@%
%@NL@%
Read    proc    near            %@AB@%; function 4 = read%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
Read    endp%@NL@%
%@NL@%
%@NL@%
NdRead        proc        near                %@AB@%; function 5 = nondestructive read%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
NdRead  endp%@NL@%
%@NL@%
%@NL@%
InpStat proc    near            %@AB@%; function 6 = input status%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
InpStat endp%@NL@%
%@NL@%
%@NL@%
InpFlush proc   near            %@AB@%; function 7 = flush input buffers%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
InpFlush endp%@NL@%
%@NL@%
%@NL@%
Write   proc    near            %@AB@%; function 8 = write%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
Write   endp%@NL@%
%@NL@%
%@NL@%
WriteVfy proc   near            %@AB@%; function 9 = write with verify%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
WriteVfy endp%@NL@%
%@NL@%
%@NL@%
OutStat proc    near            %@AB@%; function 10 = output status%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
OutStat endp%@NL@%
%@NL@%
%@NL@%
OutFlush proc   near            %@AB@%; function 11 = flush output buffers%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
OutFlush endp%@NL@%
%@NL@%
%@NL@%
DevOpen proc    near            %@AB@%; function 13 = device open%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
DevOpen endp%@NL@%
%@NL@%
%@NL@%
DevClose proc   near            %@AB@%; function 14 = device close%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
DevClose endp%@NL@%
%@NL@%
%@NL@%
RemMedia proc   near            %@AB@%; function 15 = removable media%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
RemMedia endp%@NL@%
%@NL@%
%@NL@%
GenIOCTL proc   near            %@AB@%; function 16 = generic IOCTL%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
GenIOCTL endp%@NL@%
%@NL@%
%@NL@%
ResetMed proc   near            %@AB@%; function 17 = reset media%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
ResetMed endp%@NL@%
%@NL@%
%@NL@%
GetLogDrv proc  near            %@AB@%; function 18 = get logical drive%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
GetLogDrv endp%@NL@%
%@NL@%
%@NL@%
SetLogDrv proc  near            %@AB@%; function 19 = set logical drive%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
SetLogDrv endp%@NL@%
%@NL@%
%@NL@%
DeInstall proc        near                %@AB@%; function 20 = deinstall driver%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
DeInstall endp%@NL@%
%@NL@%
%@NL@%
PartFD  proc    near            %@AB@%; function 22 = partitionable%@AE@%%@NL@%
                                %@AB@%;               fixed disk%@AE@%%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
PartFD  endp%@NL@%
%@NL@%
%@NL@%
FDMap   proc    near            %@AB@%; function 23 = get fixed disk%@AE@%%@NL@%
                                %@AB@%;               logical unit map%@AE@%%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
FDMap   endp%@NL@%
%@NL@%
%@NL@%
Error   proc    near            %@AB@%; bad command code%@AE@%%@NL@%
%@NL@%
        mov     ax,8103h        %@AB@%; error bit + 'done' status%@AE@%%@NL@%
                                %@AB@%; + "Unknown Command" code%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
Error   endp%@NL@%
%@NL@%
%@NL@%
Init    proc    near            %@AB@%; function 0 = initialize%@AE@%%@NL@%
%@NL@%
        mov     ax,es:[bx+14]   %@AB@%; get DevHlp entry point%@AE@%%@NL@%
        mov     word ptr devhlp,ax%@NL@%
        mov     ax,es:[bx+16]%@NL@%
        mov     word ptr devhlp+2,ax%@NL@%
%@NL@%
                                %@AB@%; set offsets to end of code%@AE@%%@NL@%
                                %@AB@%; and data segments%@AE@%%@NL@%
        mov     word ptr es:[bx+14],offset _TEXT:Init%@NL@%
        mov     word ptr es:[bx+16],offset DGROUP:ident%@NL@%
%@NL@%
                                %@AB@%; display sign-on message...%@AE@%%@NL@%
        push    stdout          %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds              %@AB@%; address of message%@AE@%%@NL@%
        push    offset DGROUP:ident%@NL@%
        push    ident_len       %@AB@%; length of message%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
Init    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TESTCDLL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH19\TESTCDLL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%        TESTCDLL.C%@NL@%
%@AB@%%@NL@%
%@AB@%        A simple test program for the CDLL.DLL dynlink library.%@NL@%
%@AB@%%@NL@%
%@AB@%        Compile with:  C> cl testcdll.c /link cdll.lib%@NL@%
%@AB@%%@NL@%
%@AB@%        Usage is:  C> testcdll%@NL@%
%@AB@%%@NL@%
%@AB@%        Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
int extern far pascal MYFUNC(int, int);%@NL@%
%@NL@%
main()%@NL@%
{%@NL@%
    int x;          %@AB@%/* temporary storage */%@AE@%%@NL@%
%@NL@%
    printf("\nCalling CDLL.MYFUNC\n");%@NL@%
%@NL@%
    x = MYFUNC(1, 2);%@NL@%
%@NL@%
    printf("\nMYFUNC(1, 2) = %d\n", x);%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TINYCMD.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH12\TINYCMD.ASM%@AE@%%@NL@%
%@NL@%
        title        TINYCMD -- Simple Command Interpreter%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; TINYCMD.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; A simple command interpreter for OS/2.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm tinycmd.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link tinycmd,,,os2,tinycmd%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage is:  C> tinycmd%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf        equ        0ah                        %@AB@%; ASCII linefeed%@AE@%%@NL@%
tab     equ     09h                     %@AB@%; ASCII tab%@AE@%%@NL@%
blank   equ     20h                     %@AB@%; ASCII blank code%@AE@%%@NL@%
escape  equ     01bh                    %@AB@%; ASCII escape code%@AE@%%@NL@%
%@NL@%
inpsize equ     80                      %@AB@%; maximum input length%@AE@%%@NL@%
%@NL@%
        extrn   DosExecPgm:far          %@AB@%; OS/2 API functions%@AE@%%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosGetVersion:far%@NL@%
        extrn   KbdStringIn:far%@NL@%
        extrn   VioWrtTTY:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
%@AB@%; Intrinsic commands table: Each entry is an ASCIIZ string%@AE@%%@NL@%
%@AB@%; followed by the offset of the corresponding procedure.%@AE@%%@NL@%
%@NL@%
commands label  byte%@NL@%
        db        'CLS',0                 %@AB@%; clear screen command%@AE@%%@NL@%
        dw      cls_cmd%@NL@%
        db      'VER',0                 %@AB@%; display OS/2 version%@AE@%%@NL@%
        dw      ver_cmd%@NL@%
        db      'EXIT',0                %@AB@%; exit from TINYCMD%@AE@%%@NL@%
        dw      exit_cmd%@NL@%
        db      0                       %@AB@%; end of table%@AE@%%@NL@%
%@NL@%
input   db      (inpsize+2) dup (0)     %@AB@%; keyboard input buffer%@AE@%%@NL@%
ibinfo  dw      inpsize,0               %@AB@%; input buffer info%@AE@%%@NL@%
%@NL@%
pbuff   db      (inpsize+2) dup (0)     %@AB@%; program name moved here%@AE@%%@NL@%
%@NL@%
cinfo   dw      0                       %@AB@%; child termination type%@AE@%%@NL@%
        dw      0                       %@AB@%; child return code%@AE@%%@NL@%
%@NL@%
prompt  db      cr,lf,'>> '             %@AB@%; TINYCMD's user prompt%@AE@%%@NL@%
pr_len  equ     $-prompt%@NL@%
%@NL@%
delims  db      0,blank,tab,'%@AB@%;,='       ; delimiters for first%@AE@%%@NL@%
de_len  equ     $-delims                %@AB@%; command line token%@AE@%%@NL@%
%@NL@%
pext    db      '.EXE',0                %@AB@%; program file extension%@AE@%%@NL@%
pe_len equ      $-pext%@NL@%
%@NL@%
wlen    dw      0                       %@AB@%; receives bytes written%@AE@%%@NL@%
verinfo db      0,0                     %@AB@%; receives OS/2 version%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf,lf                %@AB@%; error message%@AE@%%@NL@%
        db      'Bad command or filename'%@NL@%
        db      cr,lf%@NL@%
msg1_len equ    $-msg1%@NL@%
%@NL@%
msg2    db      escape,'[2J'            %@AB@%; ANSI escape sequence%@AE@%%@NL@%
msg2_len equ    $-msg2                  %@AB@%; to clear the screen%@AE@%%@NL@%
%@NL@%
msg3    db      cr,lf,lf                %@AB@%; version number message%@AE@%%@NL@%
        db      'OS/2 version '%@NL@%
msg3a   db      'nn.'%@NL@%
msg3b   db      'nn'%@NL@%
        db      cr,lf%@NL@%
msg3_len equ    $-msg3%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP,es:DGROUP%@NL@%
%@NL@%
main    proc    far                     %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; make DGROUP addressable%@AE@%%@NL@%
        pop     es                      %@AB@%;  with ES too%@AE@%%@NL@%
        cld                             %@AB@%; clear direction flag%@AE@%%@NL@%
%@NL@%
main1:                                  %@AB@%; main interpreter loop%@AE@%%@NL@%
        call    gcmd                    %@AB@%; get command from user%@AE@%%@NL@%
%@NL@%
        call    intrinsic               %@AB@%; check if intrinsic function%@AE@%%@NL@%
        jnc     main1                   %@AB@%; yes, it was processed%@AE@%%@NL@%
%@NL@%
        call        extrinsic                %@AB@%; no, run EXE file, then%@AE@%%@NL@%
        jmp     main1                   %@AB@%; get another command%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
%@AB@%; Try to match first command token against COMMANDS table.%@AE@%%@NL@%
%@AB@%; If match, run the routine, return Carry = False.%@AE@%%@NL@%
%@AB@%; If no match, return Carry = True.%@AE@%%@NL@%
%@NL@%
intrinsic proc  near%@NL@%
%@NL@%
                                        %@AB@%; point to command table%@AE@%%@NL@%
        mov     si,offset DGROUP:commands%@NL@%
%@NL@%
intr1:                                  %@AB@%; try next table entry...%@AE@%%@NL@%
        cmp     byte ptr [si],0         %@AB@%; end of entire table?%@AE@%%@NL@%
        je      intr6                   %@AB@%; jump if table exhausted%@AE@%%@NL@%
%@NL@%
        mov     di,offset DGROUP:input  %@AB@%; point to user's command%@AE@%%@NL@%
%@NL@%
intr2:  mov     al,[si]                 %@AB@%; next character from table%@AE@%%@NL@%
%@NL@%
        or      al,al                   %@AB@%; end of table entry?%@AE@%%@NL@%
        jz      intr3                   %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
        cmp     al,[di]                 %@AB@%; compare to input character%@AE@%%@NL@%
        jnz     intr4                   %@AB@%; jump, found mismatch%@AE@%%@NL@%
%@NL@%
        inc     si                      %@AB@%; advance string pointers%@AE@%%@NL@%
        inc     di%@NL@%
        jmp     intr2%@NL@%
%@NL@%
intr3:  cmp     byte ptr [di],0         %@AB@%; user's entry same length?%@AE@%%@NL@%
        jne     intr5                   %@AB@%; no, not a match%@AE@%%@NL@%
%@NL@%
        call    word ptr [si+1]         %@AB@%; run the command routine%@AE@%%@NL@%
%@NL@%
        clc                             %@AB@%; return Carry = False%@AE@%%@NL@%
        ret                             %@AB@%; as success signal%@AE@%%@NL@%
%@NL@%
intr4:  lodsb                           %@AB@%; look for end of this%@AE@%%@NL@%
        or      al,al                   %@AB@%; command string (null byte)%@AE@%%@NL@%
        jnz     intr4                   %@AB@%; not end yet, loop%@AE@%%@NL@%
%@NL@%
intr5:  add     si,2                    %@AB@%; skip over routine address%@AE@%%@NL@%
        jmp     intr1                   %@AB@%; try to match next command%@AE@%%@NL@%
%@NL@%
intr6:  stc                             %@AB@%; command not matched, exit%@AE@%%@NL@%
        ret                             %@AB@%; with Carry = True%@AE@%%@NL@%
%@NL@%
intrinsic endp%@NL@%
%@NL@%
%@AB@%; Append .EXE to first token and attempt to execute program,%@AE@%%@NL@%
%@AB@%; passing address of argument strings block and null pointer%@AE@%%@NL@%
%@AB@%; for environment (child process inherits TINYCMD's environment).%@AE@%%@NL@%
%@NL@%
extrinsic proc  near%@NL@%
%@NL@%
        mov     si,offset DGROUP:input  %@AB@%; copy first token of%@AE@%%@NL@%
        mov     di,offset DGROUP:pbuff  %@AB@%; user command to pbuff%@AE@%%@NL@%
%@NL@%
extr1:  lodsb                           %@AB@%; get next character%@AE@%%@NL@%
        or      al,al                   %@AB@%; found null?%@AE@%%@NL@%
        jz      extr2                   %@AB@%; yes, end of token%@AE@%%@NL@%
        stosb                           %@AB@%; no, copy character%@AE@%%@NL@%
        jmp     extr1                   %@AB@%; and get next char.%@AE@%%@NL@%
%@NL@%
extr2:  mov     si,offset DGROUP:pext   %@AB@%; append .EXE extension%@AE@%%@NL@%
        mov     cx,pe_len               %@AB@%; to token, forming%@AE@%%@NL@%
        rep movsb                       %@AB@%; program filename%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; try and run program...%@AE@%%@NL@%
        push    0                       %@AB@%; object name buffer%@AE@%%@NL@%
        push    0%@NL@%
        push    0                       %@AB@%; object name buffer length%@AE@%%@NL@%
        push        0                        %@AB@%; asynchronous execution mode%@AE@%%@NL@%
        push        ds                        %@AB@%; address of argument strings%@AE@%%@NL@%
        push    offset DGROUP:input%@NL@%
        push    0                       %@AB@%; environment pointer%@AE@%%@NL@%
        push    0%@NL@%
        push    ds                      %@AB@%; receives termination info%@AE@%%@NL@%
        push    offset DGROUP:cinfo%@NL@%
        push    ds                      %@AB@%; address of program name%@AE@%%@NL@%
        push    offset DGROUP:pbuff%@NL@%
        call    DosExecPgm              %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; was function successful?%@AE@%%@NL@%
        jz      extr3                   %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; no, display error message...%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg1%@NL@%
        push    msg1_len                %@AB@%; message length%@AE@%%@NL@%
        push    0                       %@AB@%; default video handle%@AE@%%@NL@%
        call    VioWrtTTY               %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
extr3:  ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
extrinsic endp%@NL@%
%@NL@%
%@AB@%; Get input from user, convert it to argument strings block%@AE@%%@NL@%
%@AB@%; by breaking out first token with null and appending double%@AE@%%@NL@%
%@AB@%; null to entire line, and convert first token to uppercase.%@AE@%%@NL@%
%@NL@%
gcmd    proc    near                    %@AB@%; prompt user, get command%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display TINYCMD prompt...%@AE@%%@NL@%
        push    ds                      %@AB@%; address of prompt%@AE@%%@NL@%
        push    offset DGROUP:prompt%@NL@%
        push    pr_len                  %@AB@%; length of prompt%@AE@%%@NL@%
        push    0                       %@AB@%; default video handle%@AE@%%@NL@%
        call    VioWrtTTY%@NL@%
%@NL@%
        mov     ibinfo+2,0              %@AB@%; disable buffer editing%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; get entry from user...%@AE@%%@NL@%
        push    ds                      %@AB@%; address of input buffer%@AE@%%@NL@%
        push    offset DGROUP:input%@NL@%
        push    ds                      %@AB@%; input buffer info%@AE@%%@NL@%
        push    offset DGROUP:ibinfo%@NL@%
        push    0                       %@AB@%; 0 = wait for input%@AE@%%@NL@%
        push    0                       %@AB@%; default keyboard handle%@AE@%%@NL@%
        call    KbdStringIn%@NL@%
%@NL@%
        mov     cx,inpsize              %@AB@%; look for carriage return%@AE@%%@NL@%
        mov     al,cr                   %@AB@%; if any...%@AE@%%@NL@%
        mov     di,offset DGROUP:input%@NL@%
        repnz scasb%@NL@%
        jnz     gcmd1%@NL@%
        dec     di%@NL@%
gcmd1:        mov        word ptr [di],0         %@AB@%; and replace with 2 nulls%@AE@%%@NL@%
        mov     si,offset DGROUP:input  %@AB@%; break out first token...%@AE@%%@NL@%
%@NL@%
gcmd2:  lodsb                           %@AB@%; compare next character%@AE@%%@NL@%
        mov     di,offset DGROUP:delims %@AB@%; to delimiter table%@AE@%%@NL@%
        mov     cx,de_len%@NL@%
        repnz scasb%@NL@%
        jnz     gcmd2                   %@AB@%; jump, no match%@AE@%%@NL@%
        mov     byte ptr [si-1],0       %@AB@%; replace delimiter with 0%@AE@%%@NL@%
%@NL@%
        mov        si,offset DGROUP:input        %@AB@%; fold token to uppercase%@AE@%%@NL@%
%@NL@%
gcmd3:  cmp     byte ptr [si],0         %@AB@%; end of token?%@AE@%%@NL@%
        jz      gcmd5                   %@AB@%; found end, jump%@AE@%%@NL@%
        cmp     byte ptr [si],'a'%@NL@%
        jb      gcmd4                   %@AB@%; jump if not 'a-z'%@AE@%%@NL@%
        cmp     byte ptr [si],'z'%@NL@%
        ja      gcmd4                   %@AB@%; jump if not 'a-z'%@AE@%%@NL@%
        sub        byte ptr [si],'a'-'A'        %@AB@%; convert to uppercase%@AE@%%@NL@%
%@NL@%
gcmd4:  inc     si                      %@AB@%; go to next character%@AE@%%@NL@%
        jmp     gcmd3%@NL@%
%@NL@%
gcmd5:  ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
gcmd    endp%@NL@%
%@NL@%
%@NL@%
cls_cmd proc    near                    %@AB@%; intrinsic CLS command%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; send ANSI escape sequence%@AE@%%@NL@%
                                        %@AB@%; to clear the screen...%@AE@%%@NL@%
        push    ds                      %@AB@%; escape sequence address%@AE@%%@NL@%
        push    offset DGROUP:msg2%@NL@%
        push    msg2_len                %@AB@%; escape sequence length%@AE@%%@NL@%
        push    0                       %@AB@%; default video handle%@AE@%%@NL@%
        call    VioWrtTTY               %@AB@%; transfer to OS/2%@AE@%%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
cls_cmd endp%@NL@%
%@NL@%
%@NL@%
ver_cmd proc    near                    %@AB@%; intrinsic VER command%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; get OS/2 version number...%@AE@%%@NL@%
        push    ds                      %@AB@%; receives version info%@AE@%%@NL@%
        push    offset DGROUP:verinfo%@NL@%
        call    DosGetVersion           %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; format the version...%@AE@%%@NL@%
        mov     al,verinfo              %@AB@%; convert minor version%@AE@%%@NL@%
        aam                             %@AB@%; number to ASCII%@AE@%%@NL@%
        add     ax,'00'%@NL@%
        xchg    al,ah%@NL@%
        mov     word ptr msg3b,ax       %@AB@%; store ASCII characters%@AE@%%@NL@%
%@NL@%
        mov     al,verinfo+1            %@AB@%; convert major version%@AE@%%@NL@%
        aam                             %@AB@%; number to ASCII%@AE@%%@NL@%
        add     ax,'00'%@NL@%
        xchg    al,ah%@NL@%
        mov     word ptr msg3a,ax       %@AB@%; store ASCII characters%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display version number...%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg3%@NL@%
        push    msg3_len                %@AB@%; message length%@AE@%%@NL@%
        push    0                       %@AB@%; default video handle%@AE@%%@NL@%
        call    VioWrtTTY               %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
ver_cmd endp%@NL@%
%@NL@%
%@NL@%
exit_cmd proc   near                    %@AB@%; intrinsic EXIT Command%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; final exit to OS/2...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0                       %@AB@%; return code = 0%@AE@%%@NL@%
        call    DosExit                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
exit_cmd endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main                    %@AB@%; defines entry point%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TINYCMD.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH12\TINYCMD.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%        TINYCMD.C%@NL@%
%@AB@%%@NL@%
%@AB@%        A simple command interpreter for OS/2.%@NL@%
%@AB@%%@NL@%
%@AB@%        Compile with:  C> cl tinycmd.c%@NL@%
%@AB@%%@NL@%
%@AB@%        Usage is:  C> tinycmd%@NL@%
%@AB@%%@NL@%
%@AB@%        Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%<memory.h> %@NL@%
                                        %@AB@%/* macro to return number of%@NL@%
%@AB@%                                           elements in a structure */%@AE@%%@NL@%
%@AI@%#define %@AE@%DIM(x) (sizeof(x) / sizeof(x[0])) %@NL@%
%@NL@%
INPSIZE 80                      %@AB@%/* maximum input length */%@AE@%%@NL@%
%@NL@%
API unsigned extern far pascal        %@AB@%/* OS/2 API prototypes */%@AE@%%@NL@%
%@NL@%
API DosExecPgm(char far *, int, int, char far *, char far *, %@NL@%
               int far *, char far *);%@NL@%
API DosGetVersion(char far *);%@NL@%
%@NL@%
unsigned intrinsic(char *);             %@AB@%/* local function prototypes */%@AE@%%@NL@%
void extrinsic(char *);%@NL@%
void cls_cmd(void);%@NL@%
void ver_cmd(void);%@NL@%
void exit_cmd(void);%@NL@%
%@NL@%
struct _commands {                      %@AB@%/* intrinsic commands table */%@AE@%%@NL@%
    char *name;                         %@AB@%/* command name */%@AE@%%@NL@%
    int  (*fxn)();                      %@AB@%/* command function */%@AE@%%@NL@%
    } %@NL@%
      commands[] = { "CLS",   cls_cmd,  %@AB@%/* built-in commands */%@AE@%%@NL@%
                     "VER",   ver_cmd,%@NL@%
                     "EXIT",  exit_cmd, };%@NL@%
%@NL@%
main(int argc, char *argv[])%@NL@%
{   %@NL@%
    char input[INPSIZE];                %@AB@%/* keyboard input buffer */%@AE@%%@NL@%
%@NL@%
    while(1)                            %@AB@%/* main interpreter loop */%@AE@%%@NL@%
    {   %@NL@%
        printf("\n>> ");                %@AB@%/* display prompt */%@AE@%%@NL@%
        memset(input, 0, INPSIZE);      %@AB@%/* initialize input buffer */%@AE@%%@NL@%
        gets(input);                    %@AB@%/* get keyboard entry */%@AE@%%@NL@%
        strtok(input, " ;,=\t");        %@AB@%/* break out first token */%@AE@%%@NL@%
        strupr(input);                        %@AB@%/* and fold to uppercase */%@AE@%%@NL@%
%@NL@%
        if(! intrinsic(input))          %@AB@%/* if intrinsic command,%@NL@%
%@AB@%                                           run its function */%@AE@%%@NL@%
            extrinsic(input);                %@AB@%/* else assume EXE file */%@AE@%%@NL@%
    }%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Try to match first token of command line with intrinsic%@NL@%
%@AB@%    command table.  If a match is found, run the associated %@NL@%
%@AB@%    routine and return true; otherwise, return false.%@NL@%
%@AB@%*/%@AE@%%@NL@%
unsigned intrinsic(char *input)%@NL@%
{   %@NL@%
    int i;                              %@AB@%/* scratch variable */%@AE@%%@NL@%
%@NL@%
    for(i=0; i < DIM(commands); i++)    %@AB@%/* search command table */%@AE@%%@NL@%
    {   %@NL@%
        if(! strcmp(commands[i].name, input))%@NL@%
        { %@NL@%
            (*commands[i].fxn)();       %@AB@%/* if match, run routine */%@AE@%%@NL@%
            return(1);                  %@AB@%/* and return true */%@AE@%%@NL@%
        }%@NL@%
    }%@NL@%
    return(0);                          %@AB@%/* no match, return false */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Append .EXE to first token and attempt to execute program, %@NL@%
%@AB@%    passing address of argument strings block and null pointer %@NL@%
%@AB@%    for environment (child process inherits TINYCMD's environment).%@NL@%
%@AB@%*/%@AE@%%@NL@%
void extrinsic(char *input)%@NL@%
{   %@NL@%
    char pbuff[INPSIZE];                %@AB@%/* buffer for program name */%@AE@%%@NL@%
    unsigned status;                    %@AB@%/* value from DosExecPgm */%@AE@%%@NL@%
    int cinfo[2];                       %@AB@%/* child process info */%@AE@%%@NL@%
%@NL@%
    strcpy(pbuff, input);               %@AB@%/* copy first command token%@NL@%
%@AB@%                                           to local buffer */%@AE@%%@NL@%
    strcat(pbuff, ".EXE");              %@AB@%/* append .EXE to token */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* try to execute program */%@AE@%%@NL@%
    if(DosExecPgm(NULL,                 %@AB@%/* object name buffer pointer */%@AE@%%@NL@%
                  0,                        %@AB@%/* object name buffer length */%@AE@%%@NL@%
                  0,                    %@AB@%/* synchronous exec. mode */%@AE@%%@NL@%
                  input,                %@AB@%/* argument strings */%@AE@%%@NL@%
                  NULL,                 %@AB@%/* use parent's environment */%@AE@%%@NL@%
                  cinfo,                %@AB@%/* receives termination info */%@AE@%%@NL@%
                  pbuff))                %@AB@%/* program name pointer */%@AE@%%@NL@%
%@NL@%
        printf("\nBad command or filename\n");%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    These are the subroutines for the intrinsic commands.%@NL@%
%@AB@%*/%@AE@%%@NL@%
void cls_cmd(void)                      %@AB@%/* CLS command */%@AE@%%@NL@%
{   %@NL@%
    printf("\033[2J");                  %@AB@%/* ANSI escape sequence */%@AE@%%@NL@%
}                                       %@AB@%/* to clear screen */%@AE@%%@NL@%
%@NL@%
void ver_cmd(void)                      %@AB@%/* VER command */%@AE@%%@NL@%
{   %@NL@%
    char verinfo[2];                    %@AB@%/* receives version info */%@AE@%%@NL@%
%@NL@%
    DosGetVersion(verinfo);                %@AB@%/* get and display version */%@AE@%%@NL@%
    printf("\nOS/2 version %d.%02d\n", verinfo[0], verinfo[1]);%@NL@%
}%@NL@%
%@NL@%
void exit_cmd(void)                     %@AB@%/* EXIT command */%@AE@%%@NL@%
{   %@NL@%
    exit(0);                            %@AB@%/* terminate TINYCMD */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TINYDISK.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH17\TINYDISK.ASM%@AE@%%@NL@%
%@NL@%
        title        TINYDISK -- RAM Disk Device Driver%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; TINYDISK.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; A sample OS/2 block device driver that installs a 64 KB RAM disk.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm tinydisk.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link tinydisk,tinydisk.sys,,os2,tinydisk%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; To install the driver, add "DEVICE=TINYDISK.SYS" to CONFIG.SYS%@AE@%%@NL@%
%@AB@%; and reboot.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
maxcmd  equ     26              %@AB@%; maximum allowed command code%@AE@%%@NL@%
%@NL@%
secsize equ     512             %@AB@%; bytes/sector, IBM compatible media%@AE@%%@NL@%
%@NL@%
stdin   equ     0               %@AB@%; standard device handles%@AE@%%@NL@%
stdout  equ     1%@NL@%
stderr  equ     2%@NL@%
%@NL@%
cr      equ     0dh             %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf        equ        0ah                %@AB@%; ASCII linefeed%@AE@%%@NL@%
%@NL@%
PhysToVirt   equ 15h            %@AB@%; DevHlp services%@AE@%%@NL@%
UnPhysToVirt equ 32h%@NL@%
VerifyAccess equ 27h%@NL@%
AllocPhys    equ 18h%@NL@%
%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
                                %@AB@%; device driver header...%@AE@%%@NL@%
header  dd      -1              %@AB@%; link to next device driver%@AE@%%@NL@%
        dw      0080h           %@AB@%; device attribute word%@AE@%%@NL@%
                                %@AB@%; bits 7-9 = driver level%@AE@%%@NL@%
        dw      Strat           %@AB@%; Strategy entry point%@AE@%%@NL@%
        dw        0                %@AB@%; reserved%@AE@%%@NL@%
        db      0               %@AB@%; units (set by OS/2)%@AE@%%@NL@%
        db        15 dup (0)        %@AB@%; reserved%@AE@%%@NL@%
%@NL@%
devhlp  dd      ?               %@AB@%; DevHlp entry point%@AE@%%@NL@%
%@NL@%
wlen    dw      ?               %@AB@%; receives DosWrite length%@AE@%%@NL@%
%@NL@%
dbase   dd      ?               %@AB@%; 32-bit physical address,%@AE@%%@NL@%
                                %@AB@%; base of RAM disk storage%@AE@%%@NL@%
%@NL@%
xfrsec  dw      0               %@AB@%; current sector for transfer%@AE@%%@NL@%
xfrcnt  dw      0               %@AB@%; sectors successfully transferred%@AE@%%@NL@%
xfrreq  dw      0               %@AB@%; number of sectors requested%@AE@%%@NL@%
xfraddr dd      0               %@AB@%; working address for transfer%@AE@%%@NL@%
%@NL@%
array   dw      bpb             %@AB@%; array of pointers to BPB%@AE@%%@NL@%
                                %@AB@%; for each supported unit%@AE@%%@NL@%
%@NL@%
bootrec equ     $               %@AB@%; logical sector 0 boot record%@AE@%%@NL@%
        jmp     $               %@AB@%; JMP at start of boot sector,%@AE@%%@NL@%
        nop                        %@AB@%; this field must be 3 bytes%@AE@%%@NL@%
        db        'IBM 10.1'        %@AB@%; OEM identity field%@AE@%%@NL@%
                                %@AB@%; ---BIOS Parameter Block-----%@AE@%%@NL@%
bpb     dw      secsize         %@AB@%; 00H bytes per sector%@AE@%%@NL@%
        db      1               %@AB@%; 02H sectors per cluster%@AE@%%@NL@%
        dw      1               %@AB@%; 03H reserved sectors%@AE@%%@NL@%
        db      1               %@AB@%; 05H number of FATs%@AE@%%@NL@%
        dw      64              %@AB@%; 06H root directory entries%@AE@%%@NL@%
        dw      128             %@AB@%; 08H total sectors%@AE@%%@NL@%
        db      0f8h            %@AB@%; 0AH media descriptor%@AE@%%@NL@%
        dw      1               %@AB@%; 0BH sectors per FAT%@AE@%%@NL@%
        dw      1               %@AB@%; 0DH sectors per track%@AE@%%@NL@%
        dw      1               %@AB@%; 0FH number of heads%@AE@%%@NL@%
        dd      0               %@AB@%; 11H hidden sectors%@AE@%%@NL@%
        dd      0               %@AB@%; 15H large total sectors (if%@AE@%%@NL@%
                                %@AB@%;     word at offset 08H = 0)%@AE@%%@NL@%
        db      6 dup (0)       %@AB@%; 19H reserved%@AE@%%@NL@%
                                %@AB@%; ---End of BPB, 31 bytes-----%@AE@%%@NL@%
bootrec_len equ $-bootrec       %@AB@%; length of boot sector data%@AE@%%@NL@%
                                %@AB@%; additional words needed by%@AE@%%@NL@%
                                %@AB@%; Generic IOCTL Cat 8 Function 63H%@AE@%%@NL@%
                                %@AB@%; Get Device Parameters call%@AE@%%@NL@%
        dw      0               %@AB@%; number of cylinders%@AE@%%@NL@%
        db      7               %@AB@%; device type = unknown%@AE@%%@NL@%
        dw      1               %@AB@%; device attribute word%@AE@%%@NL@%
gdprec_len equ $-bpb            %@AB@%; length of Generic IOCTL buffer%@AE@%%@NL@%
%@NL@%
                                %@AB@%; Strategy routine dispatch table%@AE@%%@NL@%
                                %@AB@%; for request packet command code...%@AE@%%@NL@%
dispch  dw      Init            %@AB@%; 0  = initialize driver%@AE@%%@NL@%
        dw      MediaChk        %@AB@%; 1  = media check on block device%@AE@%%@NL@%
        dw      BuildBPB        %@AB@%; 2  = build BIOS parameter block%@AE@%%@NL@%
        dw      Error           %@AB@%; 3  = reserved%@AE@%%@NL@%
        dw      Read            %@AB@%; 4  = read (input) from device%@AE@%%@NL@%
        dw        Error                %@AB@%; 5  = nondestructive read%@AE@%%@NL@%
        dw      Error           %@AB@%; 6  = return input status%@AE@%%@NL@%
        dw      Error           %@AB@%; 7  = flush device input buffers%@AE@%%@NL@%
        dw      Write           %@AB@%; 8  = write (output) to device%@AE@%%@NL@%
        dw      Write           %@AB@%; 9  = write with verify%@AE@%%@NL@%
        dw      Error           %@AB@%; 10 = return output status%@AE@%%@NL@%
        dw      Error           %@AB@%; 11 = flush output buffers%@AE@%%@NL@%
        dw      Error           %@AB@%; 12 = reserved%@AE@%%@NL@%
        dw      Error           %@AB@%; 13 = device open%@AE@%%@NL@%
        dw      Error           %@AB@%; 14 = device close%@AE@%%@NL@%
        dw        Error                %@AB@%; 15 = removable media%@AE@%%@NL@%
        dw      GenIOCTL        %@AB@%; 16 = generic IOCTL%@AE@%%@NL@%
        dw      Error           %@AB@%; 17 = reset media%@AE@%%@NL@%
        dw      GSLogDrv        %@AB@%; 18 = get logical drive%@AE@%%@NL@%
        dw      GSLogDrv        %@AB@%; 19 = set logical drive%@AE@%%@NL@%
        dw        Error                %@AB@%; 20 = deinstall%@AE@%%@NL@%
        dw      Error           %@AB@%; 21 = reserved%@AE@%%@NL@%
        dw      Error           %@AB@%; 22 = partitionable fixed disks%@AE@%%@NL@%
        dw      Error           %@AB@%; 23 = get fixed disk unit map%@AE@%%@NL@%
        dw      Error           %@AB@%; 24 = reserved%@AE@%%@NL@%
        dw      Error           %@AB@%; 25 = reserved%@AE@%%@NL@%
        dw      Error           %@AB@%; 26 = reserved%@AE@%%@NL@%
%@NL@%
                                %@AB@%; start of data discarded%@AE@%%@NL@%
                                %@AB@%; after initialization%@AE@%%@NL@%
%@NL@%
ident        db        cr,lf,lf        %@AB@%; successful installation message...%@AE@%%@NL@%
        db        'TINYDISK 64 KB RAM disk for OS/2'%@NL@%
        db      cr,lf%@NL@%
        db        'RAM disk will be drive '%@NL@%
drive   db      'X:'%@NL@%
        db      cr,lf%@NL@%
ident_len equ $-ident%@NL@%
%@NL@%
abort   db      cr,lf           %@AB@%; aborted installation message%@AE@%%@NL@%
        db        'TINYDISK installation aborted'%@NL@%
        db      cr,lf%@NL@%
abort_len equ $-abort%@NL@%
%@NL@%
volname db        'TINYDISK   '        %@AB@%; volume label for RAM disk%@AE@%%@NL@%
        db      08h             %@AB@%; attribute byte%@AE@%%@NL@%
        db      10 dup (0)      %@AB@%; reserved area%@AE@%%@NL@%
        dw      0               %@AB@%; time = 00:00%@AE@%%@NL@%
        dw      1021h           %@AB@%; date = January 1, 1988%@AE@%%@NL@%
        db      6 dup (0)       %@AB@%; reserved area%@AE@%%@NL@%
volname_len equ $-volname%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP,es:NOTHING%@NL@%
%@NL@%
Strat   proc    far             %@AB@%; Strategy entry point%@AE@%%@NL@%
                                %@AB@%; ES:BX = request packet%@AE@%%@NL@%
%@NL@%
        mov     di,es:[bx+2]    %@AB@%; get command code from packet%@AE@%%@NL@%
        and     di,0ffh%@NL@%
        cmp     di,maxcmd       %@AB@%; supported by this driver?%@AE@%%@NL@%
        jle     Strat1          %@AB@%; jump if command code OK%@AE@%%@NL@%
%@NL@%
        call    Error           %@AB@%; bad command code%@AE@%%@NL@%
        jmp     Strat2%@NL@%
%@NL@%
Strat1: add     di,di           %@AB@%; go to command code routine%@AE@%%@NL@%
        call    word ptr [di+dispch]%@NL@%
%@NL@%
Strat2:                         %@AB@%; return with AX = status%@AE@%%@NL@%
        mov     es:[bx+3],ax    %@AB@%; put status in request packet%@AE@%%@NL@%
        ret                     %@AB@%; return to OS/2 kernel%@AE@%%@NL@%
%@NL@%
Strat   endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; Command code routines are called by the Strategy routine%@AE@%%@NL@%
%@AB@%; via the Dispatch table with ES:BX pointing to the request%@AE@%%@NL@%
%@AB@%; header.  Each routine should return ES:BX unchanged,%@AE@%%@NL@%
%@AB@%; and AX = status to be placed in request packet:%@AE@%%@NL@%
%@AB@%; 0100H if 'done' and no error%@AE@%%@NL@%
%@AB@%; 0000H if thread should block pending interrupt%@AE@%%@NL@%
%@AB@%; 81xxH if 'done' and error detected (xx = error code)%@AE@%%@NL@%
%@NL@%
%@NL@%
MediaChk proc   near            %@AB@%; function 1 = media check%@AE@%%@NL@%
%@NL@%
                                %@AB@%; return 'not changed' code%@AE@%%@NL@%
        mov     byte ptr es:[bx+0eh],1%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
MediaChk endp%@NL@%
%@NL@%
%@NL@%
BuildBPB proc   near            %@AB@%; function 2 = build BPB%@AE@%%@NL@%
%@NL@%
                                %@AB@%; put BPB address into%@AE@%%@NL@%
                                %@AB@%; request packet%@AE@%%@NL@%
        mov     word ptr es:[bx+12h],offset DGROUP:bpb%@NL@%
        mov     word ptr es:[bx+14h],ds%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
BuildBPB endp%@NL@%
%@NL@%
%@NL@%
Read    proc    near            %@AB@%; function 4 = read%@AE@%%@NL@%
%@NL@%
        push    es              %@AB@%; save request packet address%@AE@%%@NL@%
        push    bx%@NL@%
%@NL@%
        call    setup           %@AB@%; set up transfer variables%@AE@%%@NL@%
%@NL@%
Read1:  mov     ax,xfrcnt       %@AB@%; done with all sectors yet?%@AE@%%@NL@%
        cmp     ax,xfrreq%@NL@%
        je      read2           %@AB@%; jump if transfer completed%@AE@%%@NL@%
%@NL@%
        mov     ax,ds           %@AB@%; set ES = DGROUP%@AE@%%@NL@%
        mov     es,ax%@NL@%
%@NL@%
        mov     ax,xfrsec       %@AB@%; get sector number%@AE@%%@NL@%
        call    MapDS           %@AB@%; and map it to DS:SI%@AE@%%@NL@%
                                %@AB@%; (may force mode switch)%@AE@%%@NL@%
%@NL@%
        push    es              %@AB@%; save DGROUP selector%@AE@%%@NL@%
%@NL@%
                                %@AB@%; convert destination physical%@AE@%%@NL@%
                                %@AB@%; address to virtual address...%@AE@%%@NL@%
        mov     bx,word ptr es:xfraddr%@NL@%
        mov     ax,word ptr es:xfraddr+2%@NL@%
        mov     cx,secsize      %@AB@%; segment length%@AE@%%@NL@%
        mov     dh,1            %@AB@%; leave result in ES:DI%@AE@%%@NL@%
        mov     dl,PhysToVirt   %@AB@%; function number%@AE@%%@NL@%
        call    es:devhlp       %@AB@%; transfer to kernel%@AE@%%@NL@%
%@NL@%
        mov     cx,secsize      %@AB@%; transfer logical sector from%@AE@%%@NL@%
        cld                        %@AB@%; RAM disk to requestor%@AE@%%@NL@%
        rep movsb%@NL@%
%@NL@%
        pop     ds              %@AB@%; restore DGROUP addressing%@AE@%%@NL@%
%@NL@%
        sti                        %@AB@%; PhysToVirt may mask interrupts%@AE@%%@NL@%
%@NL@%
        inc     xfrsec          %@AB@%; advance sector number%@AE@%%@NL@%
%@NL@%
                                %@AB@%; advance transfer address%@AE@%%@NL@%
        add     word ptr xfraddr,secsize%@NL@%
        adc     word ptr xfraddr+2,0%@NL@%
%@NL@%
        inc     xfrcnt          %@AB@%; count sectors transferred%@AE@%%@NL@%
        jmp     read1%@NL@%
%@NL@%
Read2:                          %@AB@%; all sectors transferred%@AE@%%@NL@%
%@NL@%
        mov     dl,UnPhysToVirt %@AB@%; function number%@AE@%%@NL@%
        call    devhlp          %@AB@%; transfer to kernel%@AE@%%@NL@%
%@NL@%
        pop     bx              %@AB@%; restore request packet address%@AE@%%@NL@%
        pop     es%@NL@%
%@NL@%
        mov     ax,xfrcnt       %@AB@%; put actual transfer count%@AE@%%@NL@%
        mov     es:[bx+12h],ax  %@AB@%; into request packet%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
Read    endp%@NL@%
%@NL@%
%@NL@%
Write   proc    near            %@AB@%; functions 8,9 = write%@AE@%%@NL@%
%@NL@%
        push    es              %@AB@%; save request packet address%@AE@%%@NL@%
        push    bx%@NL@%
%@NL@%
        call    setup           %@AB@%; set up transfer variables%@AE@%%@NL@%
%@NL@%
Write1: mov     ax,xfrcnt       %@AB@%; done with all sectors yet?%@AE@%%@NL@%
        cmp     ax,xfrreq%@NL@%
        je      write2          %@AB@%; jump if transfer completed%@AE@%%@NL@%
%@NL@%
        mov     ax,xfrsec       %@AB@%; get sector number%@AE@%%@NL@%
        call    MapES           %@AB@%; map it to ES:DI%@AE@%%@NL@%
                                %@AB@%; (may force mode switch)%@AE@%%@NL@%
%@NL@%
        push    ds              %@AB@%; save DGROUP selector%@AE@%%@NL@%
%@NL@%
                                %@AB@%; convert source physical%@AE@%%@NL@%
                                %@AB@%; address to virtual address...%@AE@%%@NL@%
        mov     bx,word ptr xfraddr%@NL@%
        mov     ax,word ptr xfraddr+2%@NL@%
        mov     cx,secsize      %@AB@%; segment length%@AE@%%@NL@%
        mov     dh,0            %@AB@%; leave result in DS:SI%@AE@%%@NL@%
        mov     dl,PhysToVirt   %@AB@%; function number%@AE@%%@NL@%
        call    devhlp          %@AB@%; transfer to kernel%@AE@%%@NL@%
%@NL@%
        mov     cx,secsize      %@AB@%; transfer logical sector from%@AE@%%@NL@%
        cld                        %@AB@%; requestor to RAM disk%@AE@%%@NL@%
        rep movsb%@NL@%
%@NL@%
        pop     ds              %@AB@%; restore DGROUP addressing%@AE@%%@NL@%
        sti                     %@AB@%; PhysToVirt might have masked%@AE@%%@NL@%
        inc     xfrsec          %@AB@%; advance sector number%@AE@%%@NL@%
%@NL@%
                                %@AB@%; advance transfer address%@AE@%%@NL@%
        add     word ptr xfraddr,secsize%@NL@%
        adc     word ptr xfraddr+2,0%@NL@%
%@NL@%
        inc     xfrcnt          %@AB@%; count sectors transferred%@AE@%%@NL@%
        jmp     write1%@NL@%
%@NL@%
Write2:                         %@AB@%; all sectors transferred%@AE@%%@NL@%
%@NL@%
        mov     dl,UnPhysToVirt %@AB@%; function number%@AE@%%@NL@%
        call    devhlp          %@AB@%; transfer to kernel%@AE@%%@NL@%
%@NL@%
        pop     bx              %@AB@%; restore request packet address%@AE@%%@NL@%
        pop     es%@NL@%
%@NL@%
        mov     ax,xfrcnt       %@AB@%; put actual transfer count%@AE@%%@NL@%
        mov     es:[bx+12h],ax  %@AB@%; into request packet%@AE@%%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
Write   endp%@NL@%
%@NL@%
%@NL@%
GenIOCTL proc   near            %@AB@%; function 16 = generic IOCTL%@AE@%%@NL@%
%@NL@%
        push    es              %@AB@%; save request packet address%@AE@%%@NL@%
        push    bx%@NL@%
%@NL@%
        mov     ax,8103h        %@AB@%; assume unknown command%@AE@%%@NL@%
%@NL@%
                                %@AB@%; Get Device Parameters call?%@AE@%%@NL@%
        cmp     byte ptr es:[bx+0dh],8%@NL@%
        jne        Gen9                %@AB@%; no, set 'done' + 'error'%@AE@%%@NL@%
        cmp     byte ptr es:[bx+0eh],63h%@NL@%
        jne        Gen9                %@AB@%; no, set 'done' + 'error'%@AE@%%@NL@%
%@NL@%
                                %@AB@%; verify user's access%@AE@%%@NL@%
        mov     ax,es:[bx+15h]  %@AB@%; selector%@AE@%%@NL@%
        mov     di,es:[bx+13h]  %@AB@%; offset%@AE@%%@NL@%
        mov     cx,gdprec_len   %@AB@%; length to be written%@AE@%%@NL@%
        mov     dh,1            %@AB@%; need read/write access%@AE@%%@NL@%
        mov     dl,VerifyAccess %@AB@%; function number%@AE@%%@NL@%
        call    devhlp          %@AB@%; transfer to kernel%@AE@%%@NL@%
%@NL@%
        mov     ax,810ch        %@AB@%; if no access, exit with%@AE@%%@NL@%
        jc        Gen9                %@AB@%; 'done' + general failure%@AE@%%@NL@%
%@NL@%
                                %@AB@%; get destination address%@AE@%%@NL@%
        les     di,dword ptr es:[bx+13h]%@NL@%
                                %@AB@%; copy device info to caller%@AE@%%@NL@%
        mov     si,offset DGROUP:bpb%@NL@%
        mov     cx,gdprec_len   %@AB@%; length of parameter block%@AE@%%@NL@%
        cld%@NL@%
        rep movsb%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; set 'done' status%@AE@%%@NL@%
%@NL@%
Gen9:   pop     bx              %@AB@%; restore request packet address%@AE@%%@NL@%
        pop     es%@NL@%
        ret                     %@AB@%; and return with status%@AE@%%@NL@%
%@NL@%
GenIOCTL endp%@NL@%
%@NL@%
%@NL@%
GSLogDrv proc   near            %@AB@%; function 18, 19 = get%@AE@%%@NL@%
                                %@AB@%; or set logical drive%@AE@%%@NL@%
%@NL@%
                                %@AB@%; return code indicating there%@AE@%%@NL@%
                                %@AB@%; are no logical drive aliases%@AE@%%@NL@%
        mov     byte ptr es:[bx+1],0%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
GSLogDrv endp%@NL@%
%@NL@%
%@NL@%
Error   proc    near            %@AB@%; bad command code%@AE@%%@NL@%
%@NL@%
        mov     ax,8103h        %@AB@%; error bit + 'done' status%@AE@%%@NL@%
        ret                     %@AB@%; + "Unknown Command" code%@AE@%%@NL@%
%@NL@%
Error   endp%@NL@%
%@NL@%
%@NL@%
MapES   proc    near            %@AB@%; map sector number to%@AE@%%@NL@%
                                %@AB@%; virtual memory address%@AE@%%@NL@%
                                %@AB@%; call with AX = logical sector%@AE@%%@NL@%
                                %@AB@%; return ES:DI = memory address%@AE@%%@NL@%
                                %@AB@%;        and Carry clear%@AE@%%@NL@%
                                %@AB@%; or     Carry set if error%@AE@%%@NL@%
%@NL@%
        mov     di,secsize      %@AB@%; bytes per sector%@AE@%%@NL@%
        mul     di              %@AB@%; * logical sector number%@AE@%%@NL@%
        xchg    ax,dx           %@AB@%; AX:BX := 32-bit physical%@AE@%%@NL@%
        mov     bx,dx           %@AB@%; sector address%@AE@%%@NL@%
        add     bx,word ptr dbase%@NL@%
        adc     ax,word ptr dbase+2%@NL@%
%@NL@%
        mov     cx,secsize%@NL@%
        mov     dh,1            %@AB@%; result to ES:DI%@AE@%%@NL@%
        mov     dl,PhysToVirt   %@AB@%; function number%@AE@%%@NL@%
        call    devhlp          %@AB@%; transfer to kernel%@AE@%%@NL@%
%@NL@%
        ret                     %@AB@%; return ES:DI = sector address%@AE@%%@NL@%
%@NL@%
MapES   endp%@NL@%
%@NL@%
%@NL@%
MapDS   proc    near            %@AB@%; map sector number to%@AE@%%@NL@%
                                %@AB@%; virtual memory address%@AE@%%@NL@%
                                %@AB@%; call with AX = logical sector%@AE@%%@NL@%
                                %@AB@%; return DS:SI = memory address%@AE@%%@NL@%
                                %@AB@%;        and Carry clear%@AE@%%@NL@%
                                %@AB@%; or     Carry set if error%@AE@%%@NL@%
%@NL@%
        mov     si,secsize      %@AB@%; bytes per sector%@AE@%%@NL@%
        mul     si              %@AB@%; * logical sector number%@AE@%%@NL@%
        xchg    ax,dx           %@AB@%; AX:BX := 32-bit physical%@AE@%%@NL@%
        mov     bx,dx           %@AB@%; sector address%@AE@%%@NL@%
        add     bx,word ptr dbase%@NL@%
        adc     ax,word ptr dbase+2%@NL@%
%@NL@%
        mov     cx,secsize%@NL@%
        mov     dh,0            %@AB@%; result to DS:SI%@AE@%%@NL@%
        mov     dl,PhysToVirt   %@AB@%; function number%@AE@%%@NL@%
        call    devhlp          %@AB@%; transfer to kernel%@AE@%%@NL@%
%@NL@%
        ret                     %@AB@%; return DS:SI = sector address%@AE@%%@NL@%
%@NL@%
MapDS   endp%@NL@%
%@NL@%
%@NL@%
Setup   proc    near            %@AB@%; set up for read/write%@AE@%%@NL@%
                                %@AB@%; ES:BX = request packet%@AE@%%@NL@%
                                %@AB@%; extracts address, start, count%@AE@%%@NL@%
%@NL@%
        mov     ax,es:[bx+14h]  %@AB@%; starting sector number%@AE@%%@NL@%
        mov     xfrsec,ax%@NL@%
%@NL@%
        mov     ax,es:[bx+12h]  %@AB@%; sectors requested%@AE@%%@NL@%
        mov     xfrreq,ax%@NL@%
%@NL@%
        mov     ax,es:[bx+0eh]  %@AB@%; requestor's buffer address%@AE@%%@NL@%
        mov     word ptr xfraddr,ax%@NL@%
        mov     ax,es:[bx+10h]%@NL@%
        mov     word ptr xfraddr+2,ax%@NL@%
%@NL@%
        mov     xfrcnt,0        %@AB@%; initialize sectors%@AE@%%@NL@%
                                %@AB@%; transferred counter%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
Setup   endp%@NL@%
%@NL@%
                                %@AB@%; start of code discarded%@AE@%%@NL@%
                                %@AB@%; after initialization%@AE@%%@NL@%
%@NL@%
Init    proc    near            %@AB@%; function 0 = initialize%@AE@%%@NL@%
%@NL@%
        mov     ax,es:[bx+0eh]  %@AB@%; get DevHlp entry point%@AE@%%@NL@%
        mov     word ptr devhlp,ax%@NL@%
        mov     ax,es:[bx+10h]%@NL@%
        mov     word ptr devhlp+2,ax%@NL@%
%@NL@%
        mov     al,es:[bx+16h]  %@AB@%; unit code for this drive%@AE@%%@NL@%
        add     al,'A'          %@AB@%; convert to ASCII and place%@AE@%%@NL@%
        mov        drive,al        %@AB@%; in output string%@AE@%%@NL@%
%@NL@%
                                %@AB@%; display sign-on message...%@AE@%%@NL@%
        push    stdout          %@AB@%; handle for standard output%@AE@%%@NL@%
        push    ds              %@AB@%; address of message%@AE@%%@NL@%
        push    offset DGROUP:ident%@NL@%
        push    ident_len       %@AB@%; length of message%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite%@NL@%
%@NL@%
                                %@AB@%; set offsets to end of code%@AE@%%@NL@%
                                %@AB@%; and data segments%@AE@%%@NL@%
        mov     word ptr es:[bx+0eh],offset _TEXT:Init%@NL@%
        mov     word ptr es:[bx+10h],offset DGROUP:ident%@NL@%
%@NL@%
                                %@AB@%; logical units supported%@AE@%%@NL@%
        mov     byte ptr es:[bx+0dh],1%@NL@%
%@NL@%
                                %@AB@%; pointer to BPB array%@AE@%%@NL@%
        mov     word ptr es:[bx+12h],offset DGROUP:array%@NL@%
        mov     word ptr es:[bx+14h],ds%@NL@%
%@NL@%
        push    es              %@AB@%; save request packet address%@AE@%%@NL@%
        push    bx%@NL@%
%@NL@%
                                %@AB@%; allocate RAM disk storage%@AE@%%@NL@%
        mov     bx,0            %@AB@%; AX:BX = size of allocated%@AE@%%@NL@%
        mov     ax,1            %@AB@%; block in bytes%@AE@%%@NL@%
        mov     dh,0            %@AB@%; request block above 1 MB%@AE@%%@NL@%
        mov     dl,AllocPhys    %@AB@%; function number%@AE@%%@NL@%
        call    devhlp          %@AB@%; transfer to kernel%@AE@%%@NL@%
        jc      Init9           %@AB@%; jump if allocation failed%@AE@%%@NL@%
%@NL@%
                                %@AB@%; save physical address%@AE@%%@NL@%
                                %@AB@%; of allocated block%@AE@%%@NL@%
        mov     word ptr dbase,bx%@NL@%
        mov     word ptr dbase+2,ax%@NL@%
%@NL@%
        call        format                %@AB@%; format the RAM disk%@AE@%%@NL@%
        jc      Init9           %@AB@%; jump if format failed%@AE@%%@NL@%
%@NL@%
        pop     bx              %@AB@%; restore request packet address%@AE@%%@NL@%
        pop     es%@NL@%
%@NL@%
        mov     ax,0100h        %@AB@%; return 'done' status%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
Init9:                          %@AB@%; abort driver installation%@AE@%%@NL@%
%@NL@%
        pop     bx              %@AB@%; restore request packet address%@AE@%%@NL@%
        pop     es%@NL@%
%@NL@%
                                %@AB@%; display installation aborted...%@AE@%%@NL@%
        push    stdout          %@AB@%; handle for standard output%@AE@%%@NL@%
        push    ds              %@AB@%; address of message%@AE@%%@NL@%
        push    offset DGROUP:abort%@NL@%
        push    abort_len       %@AB@%; length of message%@AE@%%@NL@%
        push    ds              %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; set zero units%@AE@%%@NL@%
        mov     byte ptr es:[bx+0dh],0%@NL@%
%@NL@%
                                %@AB@%; set lengths of code and%@AE@%%@NL@%
                                %@AB@%; data segments%@AE@%%@NL@%
        mov     word ptr es:[bx+0eh],0%@NL@%
        mov     word ptr es:[bx+10h],0%@NL@%
%@NL@%
        mov     ax,810ch        %@AB@%; return error + done +%@AE@%%@NL@%
                                %@AB@%; general failure%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
Init    endp%@NL@%
%@NL@%
%@NL@%
Format        proc        near                %@AB@%; format the RAM disk area%@AE@%%@NL@%
%@NL@%
                                %@AB@%; calculate length of%@AE@%%@NL@%
                                %@AB@%; RAM disk control areas%@AE@%%@NL@%
        mov     al,byte ptr bpb+5%@NL@%
        cbw                     %@AB@%; number of FATs%@AE@%%@NL@%
        mov     cx,bpb+0bh      %@AB@%; * sectors per FAT%@AE@%%@NL@%
        mul     cx%@NL@%
        mov        cx,bpb+6        %@AB@%; entries in root directory%@AE@%%@NL@%
        shr        cx,4                %@AB@%; divided by 16 for sectors%@AE@%%@NL@%
        add     ax,cx           %@AB@%; (FAT + dir sectors%@AE@%%@NL@%
        add     ax,bpb+3        %@AB@%; + reserved sectors)%@AE@%%@NL@%
        mov     cx,secsize      %@AB@%; * bytes/sector%@AE@%%@NL@%
        mul     cx              %@AB@%; = total length%@AE@%%@NL@%
        mov     cx,ax%@NL@%
%@NL@%
                                %@AB@%; convert RAM disk base to%@AE@%%@NL@%
                                %@AB@%; virtual address%@AE@%%@NL@%
        mov     bx,word ptr dbase%@NL@%
        mov     ax,word ptr dbase+2%@NL@%
        mov     dh,1            %@AB@%; leave result in ES:DI%@AE@%%@NL@%
        mov     dl,PhysToVirt   %@AB@%; function number%@AE@%%@NL@%
        call    devhlp          %@AB@%; transfer to kernel%@AE@%%@NL@%
        jc      Format9         %@AB@%; jump if error%@AE@%%@NL@%
%@NL@%
        xor     ax,ax           %@AB@%; now zero control areas%@AE@%%@NL@%
        cld                     %@AB@%; (assume CX still = length)%@AE@%%@NL@%
        rep stosb%@NL@%
%@NL@%
        mov     ax,0            %@AB@%; get address of logical%@AE@%%@NL@%
        call    MapES           %@AB@%; sector zero%@AE@%%@NL@%
        jc      Format9         %@AB@%; jump if error%@AE@%%@NL@%
        mov     si,offset DGROUP:bootrec%@NL@%
        mov     cx,bootrec_len  %@AB@%; copy boot record%@AE@%%@NL@%
        rep movsb               %@AB@%; to logical sector zero%@AE@%%@NL@%
%@NL@%
        mov     ax,word ptr bpb+3%@NL@%
        call    MapES           %@AB@%; get address of FAT sector%@AE@%%@NL@%
        jc      Format9         %@AB@%; jump if error%@AE@%%@NL@%
        mov     al,byte ptr bpb+0ah%@NL@%
        mov     es:[di],al      %@AB@%; media ID byte into FAT%@AE@%%@NL@%
        mov     word ptr es:[di+1],-1%@NL@%
%@NL@%
        mov     ax,word ptr bpb+3%@NL@%
        add     ax,word ptr bpb+0bh%@NL@%
        call    MapES           %@AB@%; get address of directory%@AE@%%@NL@%
        jc      Format9         %@AB@%; jump if error%@AE@%%@NL@%
        mov     si,offset DGROUP:volname%@NL@%
        mov     cx,volname_len%@NL@%
        rep movsb               %@AB@%; copy volume label to it%@AE@%%@NL@%
%@NL@%
        mov     dl,UnPhysToVirt %@AB@%; function number%@AE@%%@NL@%
        call    devhlp          %@AB@%; transfer to kernel%@AE@%%@NL@%
%@NL@%
        clc                     %@AB@%; signal format successful%@AE@%%@NL@%
%@NL@%
Format9:                        %@AB@%; return with Carry = 0%@AE@%%@NL@%
        ret                     %@AB@%; if success, 1 if error%@AE@%%@NL@%
%@NL@%
Format  endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TOUCH.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH15\TOUCH.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    TOUCH.C     Force time and date stamps on file(s)%@NL@%
%@AB@%%@NL@%
%@AB@%    Compile:    C> CL touch.c%@NL@%
%@AB@%%@NL@%
%@AB@%    Usage:      C> TOUCH pathname [ pathname... ]%@NL@%
%@AB@%%@NL@%
%@AB@%    Pathnames may include wildcard characters%@NL@%
%@AB@%%@NL@%
%@AB@%    Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%API unsigned extern far pascal %@NL@%
%@NL@%
API DosClose(unsigned);                 %@AB@%/* OS/2 function prototypes */%@AE@%%@NL@%
API DosFindClose(unsigned);         %@NL@%
API DosFindFirst(char far *, unsigned far *, unsigned, char far *, %@NL@%
                 unsigned, int far *, unsigned long);%@NL@%
API DosFindNext(unsigned, char far *, unsigned, unsigned far *);%@NL@%
API DosGetDateTime(void far *);%@NL@%
API DosOpen(char far *, unsigned far *, unsigned far *, unsigned long,%@NL@%
            unsigned, unsigned, unsigned, unsigned long);           %@NL@%
API DosSetFileInfo(unsigned, int, void far *, int);%@NL@%
%@NL@%
READ_ONLY 0x01                  %@AB@%/* file attribute bits */%@AE@%%@NL@%
%@AI@%#define %@AE@%HIDDEN    0x02 %@NL@%
%@AI@%#define %@AE@%SYSTEM    0x04 %@NL@%
%@AI@%#define %@AE@%DIRECTORY 0x10 %@NL@%
%@AI@%#define %@AE@%ARCHIVE   0x20 %@NL@%
%@NL@%
ATTR      0                     %@AB@%/* attributes to use%@NL@%
%@AB@%                                           during file search */%@AE@%%@NL@%
%@NL@%
struct _finfo {                         %@AB@%/* used by DosSetFileInfo */%@AE@%%@NL@%
                    unsigned cdate;%@NL@%
                    unsigned ctime;%@NL@%
                    unsigned adate;%@NL@%
                    unsigned atime;%@NL@%
                    unsigned wdate;%@NL@%
                    unsigned wtime; %@NL@%
              }     finfo;%@NL@%
%@NL@%
struct _dinfo {                         %@AB@%/* used by DosGetDateTime */%@AE@%%@NL@%
                    char hour;%@NL@%
                    char min;%@NL@%
                    char sec;%@NL@%
                    char csec;%@NL@%
                    char day;%@NL@%
                    char mon;%@NL@%
                    int  year;%@NL@%
                    int  zone;%@NL@%
                    char dow;       %@NL@%
              }     dinfo;              %@NL@%
%@NL@%
%@NL@%
main(int argc, char *argv[])%@NL@%
{%@NL@%
    int i;%@NL@%
%@NL@%
    if(argc < 2)%@NL@%
    {%@NL@%
        printf("\ntouch: missing filename\n");%@NL@%
        exit(1);%@NL@%
    }%@NL@%
%@NL@%
    DosGetDateTime(&dinfo);             %@AB@%/* get current date&time */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* set up date & time of%@NL@%
%@AB@%                                           last write in directory %@NL@%
%@AB@%                                           format for DosSetFileInfo */%@AE@%%@NL@%
    finfo.wdate = ((dinfo.year-1980)<<9) + (dinfo.mon<<5) + dinfo.day;%@NL@%
    finfo.wtime = (dinfo.hour<<11) + (dinfo.min<<5);%@NL@%
%@NL@%
                                        %@AB@%/* file creation and last%@NL@%
%@AB@%                                           access fields useless %@NL@%
%@AB@%                                           in FAT file systems */%@AE@%%@NL@%
    finfo.cdate = finfo.ctime = finfo.adate = finfo.atime = 0;%@NL@%
%@NL@%
    for(i = 1; i < argc; i++)           %@AB@%/* process all pathnames */%@AE@%%@NL@%
        findfiles(argv[i]);             %@AB@%/* in the command line */%@AE@%%@NL@%
%@NL@%
    puts("");                           %@AB@%/* final blank line */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Search for all files matching a command line argument%@NL@%
%@AB@%*/%@AE@%%@NL@%
findfiles(char *cname)%@NL@%
{%@NL@%
    char resbuf[36];                    %@AB@%/* receives search results */%@AE@%%@NL@%
    unsigned status;                    %@AB@%/* receives function status */%@AE@%%@NL@%
    unsigned handle = -1;               %@AB@%/* directory search handle */%@AE@%%@NL@%
    unsigned attr = 0;                  %@AB@%/* attribute for search */%@AE@%%@NL@%
    int matches = 1;                    %@AB@%/* no. of matches requested/found */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* is there any match? */%@AE@%%@NL@%
    if(DosFindFirst(cname, &handle, ATTR, resbuf, 36, &matches, 0L) == 0)%@NL@%
    {%@NL@%
        stampfile(cname, &resbuf[23]);  %@AB@%/* initial match found */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* any additional matches? */%@AE@%%@NL@%
        while(DosFindNext(handle, resbuf, 36, &matches) == 0)%@NL@%
            stampfile(cname, &resbuf[23]);%@NL@%
    }%@NL@%
    else printf("\nno matches:  %s", strlwr(cname));%@NL@%
    DosFindClose(handle);               %@AB@%/* release search handle */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    Set the time and date stamp on a file%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
stampfile(char *cname, char *sname)%@NL@%
{%@NL@%
    unsigned status, handle, action;    %@AB@%/* scratch variables */%@AE@%%@NL@%
    char *p;                            %@AB@%/* scratch pointer */%@AE@%%@NL@%
    char qbuff[80];                     %@AB@%/* qualified filename */%@AE@%%@NL@%
%@NL@%
    memset(qbuff,0,80);                 %@AB@%/* initialize buffer */%@AE@%%@NL@%
%@NL@%
    p = strrchr(cname, '\\');           %@AB@%/* look for backslash */%@AE@%%@NL@%
%@NL@%
    if(p != NULL)                       %@AB@%/* any path present? */%@AE@%%@NL@%
        memcpy(qbuff,cname,p-cname+1);  %@AB@%/* yes, copy it */%@AE@%%@NL@%
    else                                %@AB@%/* no, is drive present? */%@AE@%%@NL@%
        if((strlen(cname) >= 2) && (cname[1] == ':'))%@NL@%
        {%@NL@%
            qbuff[0] = cname[0];        %@AB@%/* yes, copy drive */%@AE@%%@NL@%
            qbuff[1] = cname[1];%@NL@%
        }%@NL@%
    strcat(qbuff,sname);                %@AB@%/* add filename from search%@NL@%
%@AB@%                                           to drive +/or path */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* try to open the file */%@AE@%%@NL@%
    if(DosOpen(qbuff, &handle, &action, 0L, 0, 1, 0x22, 0L))%@NL@%
        printf("\ncan't open:  %s", strlwr(qbuff));%@NL@%
    else%@NL@%
    {                                   %@AB@%/* set new time & date stamp */%@AE@%%@NL@%
        if(DosSetFileInfo(handle, 1, &finfo, sizeof(finfo)))%@NL@%
            printf("\ncan't touch: %s", strlwr(qbuff));%@NL@%
        else                            %@AB@%/* audit touched files */%@AE@%%@NL@%
            printf("\ntouched:     %s", strlwr(qbuff));%@NL@%
%@NL@%
        DosClose(handle);               %@AB@%/* release file handle */%@AE@%%@NL@%
    }       %@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TRYQFN.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH09\TRYQFN.ASM%@AE@%%@NL@%
%@NL@%
        title   TRYQFN -- QFN demo%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%; TRYQFN.ASM --- Interactive demo of QFN routine (OS/2 version)%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM TRYQFN;%@AE@%%@NL@%
%@AB@%;                MASM QFN;%@AE@%%@NL@%
%@AB@%;                LINK TRYQFN+QFN,,,OS2,TRYQFN.DEF;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        TRYQFN%@AE@%%@NL@%
%@NL@%
cr      equ     0dh             %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah             %@AB@%; ASCII line feed%@AE@%%@NL@%
%@NL@%
stdin   equ     0               %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1               %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2               %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
        extrn        DosRead:far        %@AB@%; OS/2 API functions%@AE@%%@NL@%
        extrn        DosWrite:far%@NL@%
        extrn        DosExit:far%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
ibuff   db      80 dup (0)      %@AB@%; input buffer%@AE@%%@NL@%
ibuff_len equ        $-ibuff%@NL@%
%@NL@%
rlen        dw        0                %@AB@%; length from DosRead%@AE@%%@NL@%
wlen        dw        0                %@AB@%; length from DosWrite%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf,lf%@NL@%
        db      'Enter filename:        '%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf%@NL@%
        db      'The full pathname is:  '%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
msg3    db      cr,lf%@NL@%
        db      'Bad filename!'%@NL@%
msg3_len equ $-msg3%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        extrn   qfn:near%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
main    proc    near%@NL@%
%@NL@%
        push        ds                %@AB@%; set ES = DGROUP too%@AE@%%@NL@%
        pop        es%@NL@%
%@NL@%
main1:                          %@AB@%; display prompt...%@AE@%%@NL@%
        push        stdout                %@AB@%; standard output handle%@AE@%%@NL@%
        push        ds                %@AB@%; address of message%@AE@%%@NL@%
        push        offset DGROUP:msg1%@NL@%
        push        msg1_len        %@AB@%; length of message%@AE@%%@NL@%
        push        ds                %@AB@%; receives bytes written%@AE@%%@NL@%
        push        offset DGROUP:wlen%@NL@%
        call        DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; get a filename...%@AE@%%@NL@%
        push        stdin                %@AB@%; standard input handle%@AE@%%@NL@%
        push        ds                %@AB@%; input buffer address%@AE@%%@NL@%
        push        offset DGROUP:ibuff%@NL@%
        push        ibuff_len        %@AB@%; length of input buffer%@AE@%%@NL@%
        push        ds                %@AB@%; receives actual length%@AE@%%@NL@%
        push        offset DGROUP:rlen%@NL@%
        call        DosRead                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov        ax,rlen                %@AB@%; anything entered?%@AE@%%@NL@%
        cmp     ax,2                %@AB@%; anything entered?%@AE@%%@NL@%
        je      main3           %@AB@%; empty line, exit%@AE@%%@NL@%
%@NL@%
                                %@AB@%; call QFN routine to%@AE@%%@NL@%
                                %@AB@%; validate and qualify%@AE@%%@NL@%
                                %@AB@%; the filename...%@AE@%%@NL@%
%@NL@%
        sub     ax,2                 %@AB@%; AX=length (remove CR-LF)%@AE@%%@NL@%
                                %@AB@%; DS:SI = addr of filename%@AE@%%@NL@%
        mov     si,offset DGROUP:ibuff%@NL@%
        call    qfn             %@AB@%; go qualify filename%@AE@%%@NL@%
        jc      main2           %@AB@%; jump if bad filename%@AE@%%@NL@%
        mov        cx,ax                %@AB@%; save length%@AE@%%@NL@%
%@NL@%
                                %@AB@%; first display title...%@AE@%%@NL@%
        push        stdout                %@AB@%; standard output handle%@AE@%%@NL@%
        push        ds                %@AB@%; message address%@AE@%%@NL@%
        push        offset DGROUP:msg2%@NL@%
        push        msg2_len             %@AB@%; message length%@AE@%%@NL@%
        push        ds                %@AB@%; receives bytes written%@AE@%%@NL@%
        push        offset DGROUP:wlen%@NL@%
        call        DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                %@AB@%; display qualified filename%@AE@%%@NL@%
        push        stdout                %@AB@%; standard output handle%@AE@%%@NL@%
        push        ds                %@AB@%; address of filename%@AE@%%@NL@%
        push        si%@NL@%
        push        cx                %@AB@%; length of filename%@AE@%%@NL@%
        push        ds                %@AB@%; receives bytes written%@AE@%%@NL@%
        push        offset DGROUP:wlen%@NL@%
        call        DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp     main1           %@AB@%; get another filename%@AE@%%@NL@%
%@NL@%
main2:                          %@AB@%; display error message...%@AE@%%@NL@%
        push        stdout                %@AB@%; standard output handle%@AE@%%@NL@%
        push        ds                %@AB@%; message address%@AE@%%@NL@%
        push        offset DGROUP:msg3%@NL@%
        push        msg3_len        %@AB@%; message length%@AE@%%@NL@%
        push        ds                %@AB@%; receives bytes written%@AE@%%@NL@%
        push        offset DGROUP:wlen%@NL@%
        call        DosWrite        %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        jmp     main1           %@AB@%; get another filename%@AE@%%@NL@%
%@NL@%
main3:  push        1                %@AB@%; terminate with%@AE@%%@NL@%
        push        0                %@AB@%; return code = 0%@AE@%%@NL@%
        call        DosExit                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
main    endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     main%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TRYQFN.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH09\TRYQFN.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    TRYQFN.C    Interactive demo of use of QFN.C%@NL@%
%@AB@%                module to qualify filenames.%@NL@%
%@AB@%    Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%%@NL@%
%@AB@%    Build:  CL TRYQFN.C QFN.C%@NL@%
%@AB@%%@NL@%
%@AB@%    Usage:  TRYQFN%@NL@%
%@AB@%%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
extern char *qfn(char *);%@NL@%
%@NL@%
main(int argc, char *argv[])%@NL@%
{%@NL@%
    char buffer[80];                %@AB@%/* buffer for user input */%@AE@%%@NL@%
%@NL@%
    char *p;                        %@AB@%/* receives ptr from qfn */%@AE@%%@NL@%
%@NL@%
    while(1)                        %@AB@%/* do until empty line */%@AE@%%@NL@%
    {%@NL@%
                                    %@AB@%/* prompt user for filename */%@AE@%%@NL@%
        printf("\nEnter filename:        ");%@NL@%
%@NL@%
        gets(buffer);               %@AB@%/* read in filename */%@AE@%%@NL@%
%@NL@%
        if(buffer[0] == 0) break;   %@AB@%/* exit if no entry */%@AE@%%@NL@%
%@NL@%
        p = qfn(buffer);            %@AB@%/* else qualify filename */%@AE@%%@NL@%
%@NL@%
        if(p != NULL)               %@AB@%/* display filename or%@NL@%
%@AB@%                                       error message */%@AE@%%@NL@%
%@NL@%
            printf("\nThe full pathname is:  %s\n",p);%@NL@%
%@NL@%
        else printf("\nBad filename!\n");%@NL@%
  } %@NL@%
%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%VOLNAME.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH09\VOLNAME.ASM%@AE@%%@NL@%
%@NL@%
        title   VOLNAME - displays volume label%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; VOLNAME.ASM --- displays volume label for current drive,%@AE@%%@NL@%
%@AB@%;                 demonstrates use of DosQFSInfo.%@AE@%%@NL@%
%@AB@%; Copyright (C) October 1986 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Build:        MASM VOLNAME;%@AE@%%@NL@%
%@AB@%;               LINK VOLNAME,,,OS2,VOLNAME;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage:        VOLNAME%@AE@%%@NL@%
%@NL@%
stdin   equ     0                       %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1                       %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf      equ     0ah                     %@AB@%; ASCII line feed%@AE@%%@NL@%
%@NL@%
        extrn   DosExit:far             %@AB@%; references to OS/2 API%@AE@%%@NL@%
        extrn   DosQCurDisk:far%@NL@%
        extrn   DosQFSInfo:far%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
_vlinfo struc                           %@AB@%; volume label structure%@AE@%%@NL@%
date    dw      ?                       %@AB@%; date of creation%@AE@%%@NL@%
time    dw      ?                       %@AB@%; time of creation%@AE@%%@NL@%
count   db      ?                       %@AB@%; length of volume label%@AE@%%@NL@%
vname   db      13 dup (?)              %@AB@%; volume label text%@AE@%%@NL@%
_vlinfo ends%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
wlen    dw      ?                       %@AB@%; receives bytes written%@AE@%%@NL@%
%@NL@%
vlinf   _vlinfo <>                      %@AB@%; volume label info%@AE@%%@NL@%
vlinf_len equ $-vlinf%@NL@%
%@NL@%
drive   dw      0                       %@AB@%; receives drive ID%@AE@%%@NL@%
drvmap  dd      0                       %@AB@%; receives drive bitmap%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf,'Volume in drive '%@NL@%
msg1a   db      'X has no label.',cr,lf%@NL@%
msg1_length equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf%@NL@%
msg2_length equ $-msg2%@NL@%
%@NL@%
msg3    db      cr,lf,'Volume in drive '%@NL@%
msg3a   db      'X is '%@NL@%
msg3_length equ $-msg3%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
volname proc    far                     %@AB@%; entry point from OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; get current drive...%@AE@%%@NL@%
        push    ds                      %@AB@%; receives drive code%@AE@%%@NL@%
        push    offset DGROUP:drive%@NL@%
        push    ds                      %@AB@%; receives bitmap for%@AE@%%@NL@%
        push    offset DGROUP:drvmap    %@AB@%; available drives%@AE@%%@NL@%
        call    DosQCurDisk             %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; did function succeed?%@AE@%%@NL@%
        jz      vol1                    %@AB@%; yes, proceed%@AE@%%@NL@%
        jmp     vol5                    %@AB@%; exit if function failed%@AE@%%@NL@%
%@NL@%
vol1:   mov     al,'A'-1                %@AB@%; convert drive code to%@AE@%%@NL@%
        add     ax,drive                %@AB@%; ASCII letter and store%@AE@%%@NL@%
        mov     msg3a,al                %@AB@%; for output%@AE@%%@NL@%
        mov     msg1a,al%@NL@%
%@NL@%
                                        %@AB@%; get volume label...%@AE@%%@NL@%
        push    0                       %@AB@%; drive = default%@AE@%%@NL@%
        push    2                       %@AB@%; file info level 2%@AE@%%@NL@%
        push    ds                      %@AB@%; buffer receives volume%@AE@%%@NL@%
        push    offset DGROUP:vlinf     %@AB@%; date, time, and name%@AE@%%@NL@%
        push    vlinf_len               %@AB@%; size of buffer%@AE@%%@NL@%
        call    DosQFSInfo              %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; call successful?%@AE@%%@NL@%
        jnz     vol2                    %@AB@%; jump, got volume label%@AE@%%@NL@%
%@NL@%
        cmp     vlinf.count,0           %@AB@%; null string?%@AE@%%@NL@%
        jne     vol3                    %@AB@%; no, go display label%@AE@%%@NL@%
%@NL@%
vol2:                                   %@AB@%; volume has no label...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg1%@NL@%
        push    msg1_length             %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives actual bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
        jmp     vol4                    %@AB@%; now eixt%@AE@%%@NL@%
%@NL@%
vol3:                                   %@AB@%; display initial message...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg3%@NL@%
        push    msg3_length             %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives actual bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; display actual volume label...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; label address%@AE@%%@NL@%
        push    offset DGROUP:vlinf.vname%@NL@%
        mov     al,vlinf.count          %@AB@%; label length%@AE@%%@NL@%
        xor     ah,ah%@NL@%
        push    ax%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; output CR-LF sequence...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of CR-LF%@AE@%%@NL@%
        push    offset DGROUP:msg2%@NL@%
        push    msg2_length             %@AB@%; length of CR-LF%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
vol4:                                   %@AB@%; success exit point...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    0                       %@AB@%; return code=0 (success)%@AE@%%@NL@%
        call    DosExit                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
vol5:                                   %@AB@%; error exit point...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1                       %@AB@%; return code=1 (error)%@AE@%%@NL@%
        call    DosExit                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
volname endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     volname%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WHEREIS.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH09\WHEREIS.ASM%@AE@%%@NL@%
%@NL@%
        title        WHEREIS -- File Finder Utility%@NL@%
        page    55,132%@NL@%
        .286%@NL@%
%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; WHEREIS.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; A file finder utility that searches the current drive, starting%@AE@%%@NL@%
%@AB@%; with the root directory (\), for the specified pathname.%@AE@%%@NL@%
%@AB@%; Wildcard characters can be included.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; This program requires the modules ARGV.ASM and ARGC.ASM.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Assemble with:  C> masm whereis.asm;%@AE@%%@NL@%
%@AB@%; Link with:  C> link whereis+argv+argc,,,os2,whereis%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Usage is:  C> whereis pathname%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Copyright (C) 1988 Ray Duncan%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
stdin   equ     0                       %@AB@%; standard input handle%@AE@%%@NL@%
stdout  equ     1                       %@AB@%; standard output handle%@AE@%%@NL@%
stderr  equ     2                       %@AB@%; standard error handle%@AE@%%@NL@%
%@NL@%
cr      equ     0dh                     %@AB@%; ASCII carriage return%@AE@%%@NL@%
lf        equ        0ah                        %@AB@%; ASCII linefeed%@AE@%%@NL@%
%@NL@%
        extrn   DosChDir:far%@NL@%
        extrn   DosExit:far%@NL@%
        extrn   DosFindClose:far%@NL@%
        extrn   DosFindFirst:far%@NL@%
        extrn   DosFindNext:far%@NL@%
        extrn   DosQCurDir:far%@NL@%
        extrn   DosQCurDisk:far%@NL@%
        extrn   DosSelectDisk:far%@NL@%
        extrn   DosWrite:far%@NL@%
%@NL@%
_srec        struc                                %@AB@%; search result structure...%@AE@%%@NL@%
cdate   dw      ?                       %@AB@%; date of creation%@AE@%%@NL@%
ctime   dw      ?                       %@AB@%; time of creation%@AE@%%@NL@%
adate   dw      ?                       %@AB@%; date of last access%@AE@%%@NL@%
atime   dw      ?                       %@AB@%; time of last access%@AE@%%@NL@%
wdate   dw      ?                       %@AB@%; date of last write%@AE@%%@NL@%
wtime   dw      ?                       %@AB@%; time of last write%@AE@%%@NL@%
fsize   dd      ?                       %@AB@%; file size%@AE@%%@NL@%
falloc  dd      ?                       %@AB@%; file allocation%@AE@%%@NL@%
fattr   dw      ?                       %@AB@%; file attribute%@AE@%%@NL@%
fcount  db      ?                       %@AB@%; filename count byte%@AE@%%@NL@%
fname   db      13 dup (?)              %@AB@%; ASCIIZ filename%@AE@%%@NL@%
_srec   ends%@NL@%
%@NL@%
%@NL@%
DGROUP  group   _DATA%@NL@%
%@NL@%
_DATA   segment word public 'DATA'%@NL@%
%@NL@%
root    db      '\',0                   %@AB@%; name of root directory%@AE@%%@NL@%
%@NL@%
parent  db      '..',0                  %@AB@%; alias for parent directory%@AE@%%@NL@%
%@NL@%
wild    db      '*.*',0                 %@AB@%; matches all files%@AE@%%@NL@%
%@NL@%
sname   db      64 dup (0)              %@AB@%; filename for search%@AE@%%@NL@%
%@NL@%
drvno   dw      0                       %@AB@%; current drive%@AE@%%@NL@%
drvmap  dd      0                       %@AB@%; logical drive bitmap%@AE@%%@NL@%
%@NL@%
dname   db      'X:\'                   %@AB@%; current drive ID%@AE@%%@NL@%
dbuf    db      80 dup (?)              %@AB@%; current directory%@AE@%%@NL@%
dbuf_len dw     ?                       %@AB@%; length of buffer%@AE@%%@NL@%
%@NL@%
sbuf    _srec   <>                      %@AB@%; receives search results%@AE@%%@NL@%
sbuf_len equ $-sbuf%@NL@%
%@NL@%
count   dw      0                       %@AB@%; total files matched%@AE@%%@NL@%
wlen    dw      ?                       %@AB@%; receives bytes written%@AE@%%@NL@%
shandle dw      -1                      %@AB@%; directory search handle%@AE@%%@NL@%
scount        dw        1                        %@AB@%; number of files to return%@AE@%%@NL@%
%@NL@%
msg1    db      cr,lf%@NL@%
        db      'whereis: no files found'%@NL@%
        db      cr,lf%@NL@%
msg1_len equ $-msg1%@NL@%
%@NL@%
msg2    db      cr,lf%@NL@%
msg2_len equ $-msg2%@NL@%
%@NL@%
msg3    db      cr,lf%@NL@%
        db        'whereis: missing filename'%@NL@%
        db      cr,lf%@NL@%
msg3_len equ $-msg3%@NL@%
%@NL@%
msg4    db      cr,lf%@NL@%
        db      'whereis: bad drive'%@NL@%
        db      cr,lf%@NL@%
msg4_len equ $-msg4%@NL@%
%@NL@%
_DATA   ends%@NL@%
%@NL@%
%@NL@%
_TEXT   segment word public 'CODE'%@NL@%
%@NL@%
        assume  cs:_TEXT,ds:DGROUP%@NL@%
%@NL@%
        extrn   argv:near%@NL@%
        extrn   argc:near%@NL@%
%@NL@%
whereis proc    far%@NL@%
%@NL@%
        call    argc                    %@AB@%; filename present in%@AE@%%@NL@%
        cmp     ax,2                    %@AB@%; command tail?%@AE@%%@NL@%
        jae     where1                  %@AB@%; jump, filename present%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; no filename, exit...%@AE@%%@NL@%
        mov     dx,offset DGROUP:msg3   %@AB@%; error message address%@AE@%%@NL@%
        mov     cx,msg3_len             %@AB@%; message length%@AE@%%@NL@%
        jmp     where6                  %@AB@%; go terminate%@AE@%%@NL@%
%@NL@%
where1:                                 %@AB@%; get current drive...%@AE@%%@NL@%
        push    ds                      %@AB@%; receives drive code%@AE@%%@NL@%
        push    offset DGROUP:drvno%@NL@%
        push    ds                      %@AB@%; receives drive bitmap%@AE@%%@NL@%
        push    offset DGROUP:drvmap%@NL@%
        call    DosQCurDisk             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov     ax,1                    %@AB@%; get address and length%@AE@%%@NL@%
        call    argv                    %@AB@%; of filename parameter%@AE@%%@NL@%
                                        %@AB@%; returns ES:BX = address%@AE@%%@NL@%
                                        %@AB@%;         AX    = length%@AE@%%@NL@%
        mov     cx,ax                   %@AB@%; save length in CX%@AE@%%@NL@%
%@NL@%
        cmp     ax,2                    %@AB@%; parameter length > 2?%@AE@%%@NL@%
        jle     where3                  %@AB@%; no, jump%@AE@%%@NL@%
        cmp     byte ptr es:[bx+1],':'  %@AB@%; drive delimiter present?%@AE@%%@NL@%
        jne     where3                  %@AB@%; no, jump%@AE@%%@NL@%
%@NL@%
        mov     al,es:[bx]              %@AB@%; get ASCII drive code%@AE@%%@NL@%
        or        al,20h                        %@AB@%; fold to lowercase%@AE@%%@NL@%
        xor     ah,ah%@NL@%
        sub     ax,'a'-1                %@AB@%; convert drive code to%@AE@%%@NL@%
        mov     drvno,ax                %@AB@%; binary and save it%@AE@%%@NL@%
        cmp        ax,1                        %@AB@%; make sure drive valid%@AE@%%@NL@%
        jb      where2                  %@AB@%; jump, bad drive%@AE@%%@NL@%
        cmp     ax,26%@NL@%
        ja      where2                  %@AB@%; jump, bad drive%@AE@%%@NL@%
%@NL@%
        add     bx,2                    %@AB@%; advance command tail%@AE@%%@NL@%
        sub     cx,2                    %@AB@%; pointer past drive code%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; set drive for search...%@AE@%%@NL@%
        push    ax                      %@AB@%; drive code%@AE@%%@NL@%
        call    DosSelectDisk           %@AB@%; transfer to OS/2%@AE@%%@NL@%
        or      ax,ax                   %@AB@%; drive OK?%@AE@%%@NL@%
        jz      where3                  %@AB@%; jump, drive was valid%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; bad drive, exit...%@AE@%%@NL@%
where2: mov     dx,offset DGROUP:msg4   %@AB@%; error message address%@AE@%%@NL@%
        mov     cx,msg4_len             %@AB@%; message length%@AE@%%@NL@%
        jmp     where6%@NL@%
%@NL@%
where3: mov     di,offset DGROUP:sname  %@AB@%; DS:DI = local buffer%@AE@%%@NL@%
%@NL@%
where4: mov     al,es:[bx]              %@AB@%; copy filename to local%@AE@%%@NL@%
        mov     [di],al                 %@AB@%; buffer byte by byte...%@AE@%%@NL@%
        inc     di%@NL@%
        inc     bx%@NL@%
        loop    where4%@NL@%
%@NL@%
        mov     byte ptr [di],0         %@AB@%; append null byte%@AE@%%@NL@%
%@NL@%
        push    ds                      %@AB@%; make DGROUP addressable%@AE@%%@NL@%
        pop     es                      %@AB@%; with ES%@AE@%%@NL@%
        assume  es:DGROUP%@NL@%
%@NL@%
        mov     dx,offset DGROUP:root   %@AB@%; start searching with%@AE@%%@NL@%
        call    schdir                  %@AB@%; the root directory%@AE@%%@NL@%
%@NL@%
        cmp     count,0                 %@AB@%; any matching files found?%@AE@%%@NL@%
        jne     where5                  %@AB@%; yes, exit silently%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; no, display 'no files'...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; message address%@AE@%%@NL@%
        push    offset DGROUP:msg1%@NL@%
        push    msg1_len                %@AB@%; message length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
where5:                                 %@AB@%; final exit to OS/2...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push        0                        %@AB@%; return code = 0 (success)%@AE@%%@NL@%
        call    DosExit                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
where6:                                 %@AB@%; common error exit...%@AE@%%@NL@%
                                        %@AB@%; DS:DX = msg, CX = length%@AE@%%@NL@%
        push    stderr                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of message%@AE@%%@NL@%
        push    dx%@NL@%
        push    cx                      %@AB@%; length of message%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; final exit to OS/2...%@AE@%%@NL@%
        push    1                       %@AB@%; terminate all threads%@AE@%%@NL@%
        push    1                       %@AB@%; exit code = 1 (error)%@AE@%%@NL@%
        call    DosExit                 %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
whereis endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; SCHDIR:       search a directory for matching%@AE@%%@NL@%
%@AB@%;               files and any other directories%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    DS:DX = ASCIIZ directory name%@AE@%%@NL@%
%@AB@%; Returns:      nothing%@AE@%%@NL@%
%@AB@%; Uses:         all registers%@AE@%%@NL@%
%@NL@%
schdir  proc    near%@NL@%
%@NL@%
        push    shandle                 %@AB@%; save old search handle%@AE@%%@NL@%
        mov     shandle,-1              %@AB@%; initialize search handle%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; set search directory...%@AE@%%@NL@%
        push    ds                      %@AB@%; directory name address%@AE@%%@NL@%
        push    dx%@NL@%
        push    0                       %@AB@%; reserved DWORD 0%@AE@%%@NL@%
        push    0%@NL@%
        call    DosChDir                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        call    schfile                 %@AB@%; search current directory%@AE@%%@NL@%
                                        %@AB@%; for matching files%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; search for directories%@AE@%%@NL@%
        mov     scount,1                %@AB@%; max matches to return%@AE@%%@NL@%
        push    ds                      %@AB@%; target name address%@AE@%%@NL@%
        push    offset DGROUP:wild%@NL@%
        push    ds                      %@AB@%; receives search handle%@AE@%%@NL@%
        push    offset DGROUP:shandle%@NL@%
        push        10h                        %@AB@%; normal + dir attribute%@AE@%%@NL@%
        push    ds                      %@AB@%; result buffer address%@AE@%%@NL@%
        push    offset DGROUP:sbuf%@NL@%
        push    sbuf_len                %@AB@%; result buffer length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives match count%@AE@%%@NL@%
        push    offset DGROUP:scount%@NL@%
        push    0                       %@AB@%; reserved DWORD 0%@AE@%%@NL@%
        push    0%@NL@%
        call    DosFindFirst            %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        or      ax,ax                   %@AB@%; find anything?%@AE@%%@NL@%
        jnz     schdir3                 %@AB@%; no, jump%@AE@%%@NL@%
%@NL@%
schdir1:                                %@AB@%; found some match...%@AE@%%@NL@%
        test    sbuf.fattr,10h          %@AB@%; is it a directory?%@AE@%%@NL@%
        jz      schdir2                 %@AB@%; no, skip it%@AE@%%@NL@%
%@NL@%
        cmp     sbuf.fname,'.'          %@AB@%; is it . or .. entry?%@AE@%%@NL@%
        je      schdir2                 %@AB@%; yes, skip it%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; no, new directory found%@AE@%%@NL@%
        mov     dx,offset DGROUP:sbuf.fname%@NL@%
        call    schdir                  %@AB@%; call self to search it%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; restore old directory...%@AE@%%@NL@%
        push    ds                      %@AB@%; address of '..' alias%@AE@%%@NL@%
        push    offset DGROUP:parent%@NL@%
        push    0                       %@AB@%; reserved DWORD 0%@AE@%%@NL@%
        push    0%@NL@%
        call    DosChDir                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
schdir2:                                %@AB@%; found at least one match,%@AE@%%@NL@%
                                        %@AB@%; look for next match...%@AE@%%@NL@%
        mov     scount,1                %@AB@%; max matches to return%@AE@%%@NL@%
        push    shandle                 %@AB@%; handle from DosFindFirst%@AE@%%@NL@%
        push    ds                      %@AB@%; result buffer address%@AE@%%@NL@%
        push    offset DGROUP:sbuf%@NL@%
        push    sbuf_len                %@AB@%; result buffer length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives match count%@AE@%%@NL@%
        push    offset DGROUP:scount%@NL@%
        call    DosFindNext             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        or      ax,ax                   %@AB@%; any matches found?%@AE@%%@NL@%
        jz      schdir1                 %@AB@%; yes, go process it%@AE@%%@NL@%
%@NL@%
schdir3:                                %@AB@%; end of search...%@AE@%%@NL@%
        push    shandle                 %@AB@%; close search handle%@AE@%%@NL@%
        call    DosFindClose            %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        pop     shandle                 %@AB@%; restore previous handle%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
schdir  endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; SCHFILE:      search current directory for%@AE@%%@NL@%
%@AB@%;               files matching string in 'sname'%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    nothing%@AE@%%@NL@%
%@AB@%; Returns:      nothing%@AE@%%@NL@%
%@AB@%; Uses:         all registers%@AE@%%@NL@%
%@NL@%
schfile proc    near%@NL@%
%@NL@%
        push    shandle                 %@AB@%; save previous handle%@AE@%%@NL@%
        mov     shandle,-1              %@AB@%; initialize search handle%@AE@%%@NL@%
%@NL@%
        mov     scount,1                %@AB@%; max matches to return%@AE@%%@NL@%
        push    ds                      %@AB@%; name to match%@AE@%%@NL@%
        push    offset DGROUP:sname%@NL@%
        push    ds                      %@AB@%; receives search handle%@AE@%%@NL@%
        push    offset DGROUP:shandle%@NL@%
        push    0h                      %@AB@%; attribute=normal files%@AE@%%@NL@%
        push    ds                      %@AB@%; result buffer address%@AE@%%@NL@%
        push    offset DGROUP:sbuf%@NL@%
        push    sbuf_len                %@AB@%; result buffer length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives match count%@AE@%%@NL@%
        push    offset DGROUP:scount%@NL@%
        push    0                       %@AB@%; reserved DWORD 0%@AE@%%@NL@%
        push    0%@NL@%
        call    DosFindFirst            %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        or      ax,ax                   %@AB@%; any matches found?%@AE@%%@NL@%
        jnz     schfile3                %@AB@%; no, terminate search%@AE@%%@NL@%
%@NL@%
schfile1:                               %@AB@%; found matching file...%@AE@%%@NL@%
        call    pfile                   %@AB@%; display its name%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; look for next match...%@AE@%%@NL@%
        push    shandle                 %@AB@%; handle from DosFindFirst%@AE@%%@NL@%
        push    ds                      %@AB@%; result buffer address%@AE@%%@NL@%
        push    offset DGROUP:sbuf%@NL@%
        push    sbuf_len                %@AB@%; result buffer length%@AE@%%@NL@%
        push    ds                      %@AB@%; receives match count%@AE@%%@NL@%
        push    offset DGROUP:scount%@NL@%
        call    DosFindNext             %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        or      ax,ax                   %@AB@%; any more matches?%@AE@%%@NL@%
        jz      schfile1                %@AB@%; yes, go display filename%@AE@%%@NL@%
%@NL@%
schfile3:                               %@AB@%; end of search...%@AE@%%@NL@%
        push    shandle                 %@AB@%; close search handle%@AE@%%@NL@%
        call    DosFindClose            %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        pop     shandle                 %@AB@%; restore previous handle%@AE@%%@NL@%
        ret                             %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
schfile endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; PFILE:        display current drive and directory,%@AE@%%@NL@%
%@AB@%;               followed by filename from 'sbuf.fname'%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    nothing%@AE@%%@NL@%
%@AB@%; Returns:      nothing%@AE@%%@NL@%
%@AB@%; Uses:         all registers%@AE@%%@NL@%
%@NL@%
pfile   proc    near%@NL@%
%@NL@%
        inc     count                   %@AB@%; count matched files%@AE@%%@NL@%
%@NL@%
        call    pdir                    %@AB@%; display drive:path%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; fold name to lower case%@AE@%%@NL@%
        mov     bx,offset DGROUP:sbuf.fname%@NL@%
        call    makelc%@NL@%
%@NL@%
                                        %@AB@%; display filename...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; filename address%@AE@%%@NL@%
        push    offset DGROUP:sbuf.fname%@NL@%
        mov     al,sbuf.fcount          %@AB@%; filename length%@AE@%%@NL@%
        xor     ah,ah%@NL@%
        push    ax%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; send newline sequence...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of newline%@AE@%%@NL@%
        push    offset DGROUP:msg2%@NL@%
        push    msg2_len                %@AB@%; length of newline%@AE@%%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; return to caller%@AE@%%@NL@%
%@NL@%
pfile   endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; PDIR:         display current drive and directory%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    nothing%@AE@%%@NL@%
%@AB@%; Returns:      nothing%@AE@%%@NL@%
%@AB@%; Uses:         AX, BX, CX, DI, ES%@AE@%%@NL@%
%@NL@%
pdir    proc    near%@NL@%
%@NL@%
        mov     ax,drvno                %@AB@%; convert binary drive%@AE@%%@NL@%
        add     al,'A'-1                %@AB@%; code to ASCII drive%@AE@%%@NL@%
        mov     dname,al                %@AB@%; and store it for output%@AE@%%@NL@%
%@NL@%
        mov     dbuf_len,dbuf_len-dbuf  %@AB@%; initialize length of%@AE@%%@NL@%
                                        %@AB@%; directory buffer%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; get current directory...%@AE@%%@NL@%
        push    0                       %@AB@%; drive 0 = default%@AE@%%@NL@%
        push    ds                      %@AB@%; receives ASCIIZ path%@AE@%%@NL@%
        push    offset DGROUP:dbuf%@NL@%
        push    ds                      %@AB@%; contains buffer length%@AE@%%@NL@%
        push    offset DGROUP:dbuf_len%@NL@%
        call    DosQCurDir              %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        mov     di,offset DGROUP:dbuf   %@AB@%; address of path%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr [di],0         %@AB@%; is path = root?%@AE@%%@NL@%
        je      pdir1                   %@AB@%; yes, jump%@AE@%%@NL@%
%@NL@%
        mov     cx,dbuf_len-dbuf        %@AB@%; no, scan for null%@AE@%%@NL@%
        xor     al,al                   %@AB@%; byte at end of path...%@AE@%%@NL@%
        repne scasb%@NL@%
%@NL@%
        mov     byte ptr [di-1],'\'     %@AB@%; append a backslash%@AE@%%@NL@%
%@NL@%
pdir1:  mov     bx,offset DGROUP:dname  %@AB@%; fold everything to%@AE@%%@NL@%
        call        makelc                        %@AB@%; lowercase%@AE@%%@NL@%
%@NL@%
                                        %@AB@%; now display drive:path...%@AE@%%@NL@%
        push    stdout                  %@AB@%; standard output handle%@AE@%%@NL@%
        push    ds                      %@AB@%; address of pathname%@AE@%%@NL@%
        push    offset DGROUP:dname%@NL@%
        sub        di,offset DGROUP:dname        %@AB@%; length of drive and path%@AE@%%@NL@%
        push    di%@NL@%
        push    ds                      %@AB@%; receives bytes written%@AE@%%@NL@%
        push    offset DGROUP:wlen%@NL@%
        call    DosWrite                %@AB@%; transfer to OS/2%@AE@%%@NL@%
%@NL@%
        ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
pdir    endp%@NL@%
%@NL@%
%@NL@%
%@AB@%; MAKELC:        convert ASCIIZ string to lowercase%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Call with:    DS:BX = string address%@AE@%%@NL@%
%@AB@%; Returns:      nothing%@AE@%%@NL@%
%@AB@%; Uses:         BX%@AE@%%@NL@%
%@NL@%
makelc  proc    near%@NL@%
%@NL@%
make1:  cmp     byte ptr [bx],0         %@AB@%; end of string?%@AE@%%@NL@%
        je      make3                   %@AB@%; jump if end%@AE@%%@NL@%
%@NL@%
        cmp     byte ptr [bx],'A'       %@AB@%; check next character%@AE@%%@NL@%
        jb        make2                        %@AB@%; jump, not uppercase%@AE@%%@NL@%
        cmp     byte ptr [bx],'Z'%@NL@%
        ja        make2                        %@AB@%; jump, not uppercase%@AE@%%@NL@%
%@NL@%
        or        byte ptr [bx],20h        %@AB@%; fold to lowercase%@AE@%%@NL@%
%@NL@%
make2:  inc     bx                      %@AB@%; advance through string%@AE@%%@NL@%
        jmp     make1%@NL@%
%@NL@%
make3:  ret                             %@AB@%; back to caller%@AE@%%@NL@%
%@NL@%
makelc  endp%@NL@%
%@NL@%
_TEXT   ends%@NL@%
%@NL@%
        end     whereis%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WHEREIS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\ADVOS2\CH09\WHEREIS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%        WHEREIS.C%@NL@%
%@AB@%%@NL@%
%@AB@%        A file finder utility that searches the current drive, starting%@NL@%
%@AB@%        with the root directory (\), for the specified pathname.%@NL@%
%@AB@%        Wildcard characters can be included.%@NL@%
%@AB@%%@NL@%
%@AB@%        Compile with:  C> cl whereis.c%@NL@%
%@AB@%%@NL@%
%@AB@%        Usage is:  C> whereis pathname%@NL@%
%@AB@%%@NL@%
%@AB@%        Copyright (C) 1988 Ray Duncan%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%API unsigned extern far pascal %@NL@%
%@NL@%
API DosChDir(char far *, unsigned long);%@NL@%
API DosFindClose(unsigned);%@NL@%
API DosFindFirst(char far *, unsigned far *, unsigned, void far *,%@NL@%
                 int, int far *, unsigned long);%@NL@%
API DosFindNext(unsigned, void far *, int, int far *);%@NL@%
API DosQCurDisk(int far *, unsigned long far *);%@NL@%
API DosQCurDir(int, void far *, int far *);%@NL@%
API DosSelectDisk(int);%@NL@%
API DosWrite(unsigned, void far *, unsigned, unsigned far *);%@NL@%
%@NL@%
NORM      0x00                  %@AB@%/* file attribute bits */%@AE@%%@NL@%
%@AI@%#define %@AE@%RD_ONLY   0x01 %@NL@%
%@AI@%#define %@AE@%HIDDEN    0x02 %@NL@%
%@AI@%#define %@AE@%SYSTEM    0x04 %@NL@%
%@AI@%#define %@AE@%DIR       0x10 %@NL@%
%@AI@%#define %@AE@%ARCHIVE   0x20 %@NL@%
%@NL@%
struct _srec {                          %@AB@%/* used by DosFindFirst */%@AE@%%@NL@%
                    unsigned cdate;     %@AB@%/* and DosFindNext */%@AE@%%@NL@%
                    unsigned ctime;%@NL@%
                    unsigned adate;%@NL@%
                    unsigned atime;%@NL@%
                    unsigned wdate;%@NL@%
                    unsigned wtime; %@NL@%
                    long fsize;%@NL@%
                    long falloc;%@NL@%
                    unsigned fattr;%@NL@%
                    char fcount;%@NL@%
                    char fname[13];%@NL@%
             } %@NL@%
                sbuf;                   %@AB@%/* receives search results */%@AE@%%@NL@%
%@NL@%
int drvno;                              %@AB@%/* current drive */%@AE@%%@NL@%
int count = 0;                          %@AB@%/* total files matched */%@AE@%%@NL@%
char sname[80];                         %@AB@%/* target pathname */%@AE@%%@NL@%
%@NL@%
%@NL@%
main(int argc, char *argv[])%@NL@%
{%@NL@%
    unsigned long drvmap;               %@AB@%/* logical drive map */%@AE@%%@NL@%
%@NL@%
    if(argc < 2)                        %@AB@%/* exit if no parameters */%@AE@%%@NL@%
    {%@NL@%
        printf("\nwhereis: missing filename\n");%@NL@%
        exit(1);%@NL@%
    }%@NL@%
%@NL@%
    DosQCurDisk(&drvno, &drvmap);       %@AB@%/* get current drive */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* any drive specified? */%@AE@%%@NL@%
    if(((strlen(argv[1])) >= 2) && ((argv[1])[1] == ':'))%@NL@%
    {%@NL@%
                                        %@AB@%/* get binary drive code */%@AE@%%@NL@%
        drvno = ((argv[1]) [0] | 0x20) - ('a'-1);%@NL@%
%@NL@%
        if(DosSelectDisk(drvno))        %@AB@%/* select drive or exit */%@AE@%%@NL@%
        {%@NL@%
            printf("\nwhereis: bad drive\n");%@NL@%
            exit(1);%@NL@%
        }%@NL@%
%@NL@%
        argv[1] += 2;                   %@AB@%/* advance past drive */%@AE@%%@NL@%
    }%@NL@%
%@NL@%
    strcpy(sname,argv[1]);              %@AB@%/* save search target */%@AE@%%@NL@%
%@NL@%
    schdir("\\");                       %@AB@%/* start search with root */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* advise if no matches */%@AE@%%@NL@%
    if(count == 0) printf("\nwhereis: no files\n");%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    SCHDIR: search directory for matching files and%@NL@%
%@AB@%            any other directories%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
schdir(char *dirname)%@NL@%
{%@NL@%
    unsigned shan = -1;                 %@AB@%/* search handle */%@AE@%%@NL@%
    int scnt = 1;                       %@AB@%/* max search matches */%@AE@%%@NL@%
%@NL@%
    DosChDir(dirname, 0L);              %@AB@%/* select new directory */%@AE@%%@NL@%
%@NL@%
    schfile();                          %@AB@%/* find and list files */%@AE@%%@NL@%
%@NL@%
                                        %@AB@%/* search for directories */%@AE@%%@NL@%
    if(!DosFindFirst("*.*", &shan, NORM|DIR, &sbuf, sizeof(sbuf), &scnt, 0L))%@NL@%
    {%@NL@%
        do                              %@AB@%/* if found directory other */%@AE@%%@NL@%
        {                               %@AB@%/* than . and .. aliases */%@AE@%%@NL@%
            if((sbuf.fattr & DIR) && (sbuf.fname[0] != '.'))%@NL@%
            {%@NL@%
                schdir(sbuf.fname);     %@AB@%/* search the directory */%@AE@%%@NL@%
                DosChDir("..", 0L);     %@AB@%/* restore old directory */%@AE@%%@NL@%
            }%@NL@%
                                        %@AB@%/* look for more directories */%@AE@%%@NL@%
        } while(DosFindNext(shan, &sbuf, sizeof(sbuf), &scnt) == 0);%@NL@%
    }%@NL@%
%@NL@%
    DosFindClose(shan);                 %@AB@%/* close search handle */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    SCHFILE: search current directory for files%@NL@%
%@AB@%             matching string in 'sname'%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
schfile()%@NL@%
{%@NL@%
    unsigned shan = -1;                 %@AB@%/* search handle */%@AE@%%@NL@%
    int scnt = 1;                       %@AB@%/* max search matches */%@AE@%%@NL@%
%@NL@%
    if(!DosFindFirst(sname, &shan, NORM, &sbuf, sizeof(sbuf), &scnt, 0L))%@NL@%
    {%@NL@%
        do pfile();                     %@AB@%/* list matching files */%@AE@%%@NL@%
        while(DosFindNext(shan, &sbuf, sizeof(sbuf), &scnt) == 0);%@NL@%
    }%@NL@%
%@NL@%
    DosFindClose(shan);                 %@AB@%/* close search handle */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    PFILE: display current drive and directory, %@NL@%
%@AB@%           followed by filename from 'sbuf.fname'%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
pfile()%@NL@%
{%@NL@%
    count++;                            %@AB@%/* count matched files */%@AE@%%@NL@%
    pdir();                                %@AB@%/* list drive and path */%@AE@%%@NL@%
    printf("%s\n", strlwr(sbuf.fname)); %@AB@%/* list filename */%@AE@%%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@%    PDIR: display current drive and directory%@NL@%
%@AB@%*/%@AE@%%@NL@%
%@NL@%
pdir()%@NL@%
{%@NL@%
    char dbuf[80];                        %@AB@%/* receives current dir */%@AE@%%@NL@%
    int dlen = sizeof(dbuf);            %@AB@%/* length of buffer */%@AE@%%@NL@%
%@NL@%
    DosQCurDir(0, dbuf, &dlen);         %@AB@%/* get current directory */%@AE@%%@NL@%
%@NL@%
    if(strlen(dbuf) != 0)               %@AB@%/* add backslash to */%@AE@%%@NL@%
        strcat(dbuf,"\\");              %@AB@%/* directory if not root */%@AE@%%@NL@%
    %@NL@%
                                        %@AB@%/* display drive and path */%@AE@%%@NL@%
    printf("%c:\\%s", drvno+'a'-1, strlwr(dbuf));%@NL@%
}%@NL@%
%@NL@%
%@1@%%@AH@%Programming the Presentation Manager - Sample Code%@EH@%%@AE@%
%@NL@%
%@NL@%
%@2@%%@AH@%ABOUTBOX.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP14\ABOUTBOX.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------------------------%@NL@%
%@AB@%   ABOUTBOX.C -- Demonstration of About Box Dialog Procedure%@NL@%
%@AB@%  -----------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"aboutbox.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT EXPENTRY AboutDlgProc  (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "AboutBox" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU          | FCF_ICON ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_NEW:%@NL@%
                    case IDM_OPEN:%@NL@%
                    case IDM_SAVE:%@NL@%
                    case IDM_SAVEAS:%@NL@%
                         WinAlarm (HWND_DESKTOP, WA_NOTE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ABOUT:%@NL@%
                         WinDlgBox (HWND_DESKTOP, hwnd, AboutDlgProc,%@NL@%
                                    NULL, IDD_ABOUT, NULL) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY AboutDlgProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case DID_OK:%@NL@%
                    case DID_CANCEL:%@NL@%
                         WinDismissDlg (hwnd, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
          }%@NL@%
     return WinDefDlgProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ALTWIND.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\ALTWIND.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------------%@NL@%
%@AB@%   ALTWIND.C -- Alternate and Winding Modes%@NL@%
%@AB@% -------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "AltWind" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static POINTL aptlFigure[10] = { 10,30, 50,30, 50,90, 90,90, 90,50,%@NL@%
                                      30,50, 30,10, 70,10, 70,70, 10,70 } ;%@NL@%
     static SHORT  cxClient, cyClient ;%@NL@%
     HPS           hps ;%@NL@%
     POINTL        aptl[10] ;%@NL@%
     SHORT         sIndex ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
               GpiSetPattern (hps, PATSYM_HALFTONE) ;%@NL@%
%@NL@%
                         %@AB@%/*---------------------%@NL@%
%@AB@%                            Alternate Fill Mode%@NL@%
%@AB@%                           ---------------------*/%@AE@%%@NL@%
%@NL@%
               for (sIndex = 0 ; sIndex < 10 ; sIndex++)%@NL@%
                    {%@NL@%
                    aptl[sIndex].x = cxClient * aptlFigure[sIndex].x / 200 ;%@NL@%
                    aptl[sIndex].y = cyClient * aptlFigure[sIndex].y / 100 ;%@NL@%
                    }%@NL@%
%@NL@%
               GpiBeginArea (hps, BA_BOUNDARY | BA_ALTERNATE) ;%@NL@%
               GpiMove (hps, aptl) ;%@NL@%
               GpiPolyLine (hps, 9L, aptl + 1) ;%@NL@%
               GpiEndArea (hps) ;%@NL@%
%@NL@%
                         %@AB@%/*-------------------%@NL@%
%@AB@%                            Winding Fill Mode%@NL@%
%@AB@%                           -------------------*/%@AE@%%@NL@%
%@NL@%
               for (sIndex = 0 ; sIndex < 10 ; sIndex++)%@NL@%
                    aptl[sIndex].x += cxClient / 2 ;%@NL@%
%@NL@%
               GpiBeginArea (hps, BA_BOUNDARY | BA_WINDING) ;%@NL@%
               GpiMove (hps, aptl) ;%@NL@%
               GpiPolyLine (hps, 9L, aptl + 1) ;%@NL@%
               GpiEndArea (hps) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%AVIO1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP07\AVIO1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------%@NL@%
%@AB@%   AVIO1.C -- Advanced VIO Display of Text%@NL@%
%@AB@%  -----------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_VIO %@NL@%
%@AI@%#define %@AE@%INCL_AVIO %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%VIDEOWIDTH 40  %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Avio1" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR  *aszAlice [] = {%@NL@%
                                 "Alice was beginning to get very tired of",%@NL@%
                                 "sitting by her sister on the bank and of",%@NL@%
                                 "having nothing to do: once or twice she",%@NL@%
                                 "had peeped into the book her sister was",%@NL@%
                                 "reading, but it had no pictures or ",%@NL@%
                                 "conversations in it, \"and what is the",%@NL@%
                                 "use of a book,\" thought Alice, \"without",%@NL@%
                                 "pictures or conversations?\""%@NL@%
                                 } ;%@NL@%
     static HPS   hps ;%@NL@%
     static HVPS  hvps ;%@NL@%
     static SHORT sNumLines = sizeof aszAlice / sizeof aszAlice[0] ;%@NL@%
     HDC          hdc ;%@NL@%
     SHORT        sRow ;%@NL@%
     SIZEL        sizl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hdc = WinOpenWindowDC (hwnd) ;%@NL@%
%@NL@%
               sizl.cx = sizl.cy = 0 ;%@NL@%
               hps = GpiCreatePS (hab, hdc, &sizl, PU_PELS    | GPIF_DEFAULT |%@NL@%
                                                   GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
               VioCreatePS (&hvps, sNumLines, VIDEOWIDTH, 0, 1, NULL) ;%@NL@%
               VioAssociate (hdc, hvps) ;%@NL@%
%@NL@%
               for (sRow = 0 ; sRow < sNumLines ; sRow++)%@NL@%
                    VioWrtCharStr (aszAlice[sRow], %@NL@%
                                   strlen (aszAlice[sRow]),%@NL@%
                                   sRow, 0, hvps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               WinDefAVioWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               WinBeginPaint (hwnd, hps, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               VioShowBuf (0, 2 * sNumLines * VIDEOWIDTH, hvps) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               VioAssociate (NULL, hvps) ;%@NL@%
               VioDestroyPS (hvps) ;%@NL@%
               GpiDestroyPS (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%AVIO2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP07\AVIO2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------%@NL@%
%@AB@%   AVIO2.C -- Advanced VIO Display of Text%@NL@%
%@AB@%  -----------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_VIO %@NL@%
%@AI@%#define %@AE@%INCL_AVIO %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%VIDEOWIDTH 40 %@NL@%
%@NL@%
typedef struct%@NL@%
     {%@NL@%
     CHAR ch ;%@NL@%
     CHAR attr ;%@NL@%
     }%@NL@%
     VIDEO [][VIDEOWIDTH] ;%@NL@%
%@NL@%
typedef VIDEO FAR *PVIDEO ;%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR    szClientClass [] = "Avio2" ;%@NL@%
     static ULONG   flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                   FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                   FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HMQ            hmq ;%@NL@%
     HWND           hwndFrame, hwndClient ;%@NL@%
     QMSG           qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR  *aszAlice [] = {%@NL@%
                                 "Alice was beginning to get very tired of",%@NL@%
                                 "sitting by her sister on the bank and of",%@NL@%
                                 "having nothing to do: once or twice she",%@NL@%
                                 "had peeped into the book her sister was",%@NL@%
                                 "reading, but it had no pictures or",%@NL@%
                                 "conversations in it, \"and what is the",%@NL@%
                                 "use of a book,\" thought Alice, \"without",%@NL@%
                                 "pictures or conversations?\""%@NL@%
                                 } ;%@NL@%
     static HPS    hps ;%@NL@%
     static HVPS   hvps ;%@NL@%
     static PVIDEO pvideo ;%@NL@%
     static SHORT  sNumLines = sizeof aszAlice / sizeof aszAlice[0] ;%@NL@%
     static USHORT usVideoLength ;%@NL@%
     HDC           hdc ;%@NL@%
     RECTL         rcl ;%@NL@%
     SHORT         sRow, sCol ;%@NL@%
     SIZEL         sizl ;%@NL@%
     ULONG         ulVideoBuffer ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hdc = WinOpenWindowDC (hwnd) ;%@NL@%
%@NL@%
               sizl.cx = sizl.cy = 0 ;%@NL@%
               hps = GpiCreatePS (hab, hdc, &sizl, PU_PELS    | GPIF_DEFAULT |%@NL@%
                                                   GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
               VioCreatePS (&hvps, sNumLines, VIDEOWIDTH, 0, 1, NULL) ;%@NL@%
               VioAssociate (hdc, hvps) ;%@NL@%
%@NL@%
               VioGetBuf (&ulVideoBuffer, &usVideoLength, hvps) ;%@NL@%
               pvideo = (PVIDEO) ulVideoBuffer ;%@NL@%
%@NL@%
               for (sRow = 0 ; sRow < sNumLines ; sRow++)%@NL@%
                    for (sCol = 0 ; sCol < VIDEOWIDTH ; sCol++)%@NL@%
                         (*pvideo) [sRow][sCol].attr = '\x1E' ;%@NL@%
%@NL@%
               for (sRow = 0 ; sRow < sNumLines ; sRow++)%@NL@%
                    for (sCol = 0 ; aszAlice [sRow][sCol] ; sCol++)%@NL@%
                         (*pvideo) [sRow][sCol].ch = aszAlice [sRow][sCol] ;%@NL@%
%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               WinDefAVioWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               WinBeginPaint (hwnd, hps, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               WinFillRect (hps, &rcl, CLR_DARKBLUE) ;%@NL@%
%@NL@%
               VioShowBuf (0, usVideoLength, hvps) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               VioAssociate (NULL, hvps) ;%@NL@%
               VioDestroyPS (hvps) ;%@NL@%
               GpiDestroyPS (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BEEPER1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP10\BEEPER1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------------%@NL@%
%@AB@%   BEEPER1.C -- Timer Demo Program No. 1%@NL@%
%@AB@%  ---------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%ID_TIMER 1 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static char  szClientClass [] = "Beeper1" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinStartTimer (hab, hwndClient, ID_TIMER, 1000) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinStopTimer (hab, hwndClient, ID_TIMER) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL fFlipFlop ;%@NL@%
     HPS         hps ;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_TIMER:%@NL@%
               WinAlarm (HWND_DESKTOP, WA_NOTE) ;%@NL@%
               fFlipFlop = !fFlipFlop ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               WinFillRect (hps, &rcl, fFlipFlop ? CLR_BLUE : CLR_RED) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BEEPER2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP10\BEEPER2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------------%@NL@%
%@AB@%   BEEPER2.C -- Timer Demo Program No. 2%@NL@%
%@AB@%  ---------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
BOOL fFlipFlop ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static char  szClientClass [] = "Beeper2" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
     USHORT       idTimer ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     idTimer = WinStartTimer (hab, NULL, 0, 1000) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          {%@NL@%
          if (qmsg.msg == WM_TIMER && SHORT1FROMMP (qmsg.mp1) == idTimer)%@NL@%
               {%@NL@%
               WinAlarm (HWND_DESKTOP, WA_NOTE) ;%@NL@%
               fFlipFlop = !fFlipFlop ;%@NL@%
               WinInvalidateRect (hwndClient, NULL, FALSE) ;%@NL@%
               }%@NL@%
          else%@NL@%
               WinDispatchMsg (hab, &qmsg) ;%@NL@%
          }%@NL@%
%@NL@%
     WinStopTimer (hab, NULL, idTimer) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     HPS   hps ;%@NL@%
     RECTL rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               WinFillRect (hps, &rcl, fFlipFlop ? CLR_BLUE : CLR_RED) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIGJOB.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP17\BIGJOB.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------------------------%@NL@%
%@AB@%   BIGJOB.C -- Common functions used in BIGJOB1, BIGJOB2, and BIGJOB3%@NL@%
%@AB@%  --------------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
double Savage (double A)%@NL@%
     {%@NL@%
     return tan (atan (exp (log (sqrt (A * A))))) + 1.0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID CheckMenuItem (HWND hwnd, SHORT sMenuItem, BOOL fCheck)%@NL@%
     {%@NL@%
     HWND  hwndParent = WinQueryWindow (hwnd, QW_PARENT, FALSE) ;%@NL@%
     HWND  hwndMenu   = WinWindowFromID (hwndParent, FID_MENU) ;%@NL@%
%@NL@%
     WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                 MPFROM2SHORT (sMenuItem, TRUE),%@NL@%
                 MPFROM2SHORT (MIA_CHECKED, fCheck ? MIA_CHECKED : 0)) ;%@NL@%
     }%@NL@%
%@NL@%
VOID EnableMenuItem (HWND hwnd, SHORT sMenuItem, BOOL fEnable)%@NL@%
     {%@NL@%
     HWND  hwndParent = WinQueryWindow (hwnd, QW_PARENT, FALSE) ;%@NL@%
     HWND  hwndMenu   = WinWindowFromID (hwndParent, FID_MENU) ;%@NL@%
%@NL@%
     WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                 MPFROM2SHORT (sMenuItem, TRUE),%@NL@%
                 MPFROM2SHORT (MIA_DISABLED, fEnable ? 0 : MIA_DISABLED)) ;%@NL@%
     }%@NL@%
%@NL@%
VOID PaintWindow (HWND hwnd, SHORT sStatus, LONG lCalcRep, ULONG ulTime)%@NL@%
     {%@NL@%
     static CHAR *szMessage [3] = { "Ready", "Working...",%@NL@%
                                    "%ld repetitions in %lu msec." } ;%@NL@%
     CHAR        szBuffer [60] ;%@NL@%
     HPS         hps ;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
     hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
     WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
     sprintf (szBuffer, szMessage [sStatus], lCalcRep, ulTime) ;%@NL@%
     WinDrawText (hps, -1, szBuffer, &rcl, CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                  DT_CENTER | DT_VCENTER | DT_ERASERECT) ;%@NL@%
%@NL@%
     WinEndPaint (hps) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIGJOB1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP17\BIGJOB1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------------------%@NL@%
%@AB@%   BIGJOB1.C -- Naive approach to lengthy processing job%@NL@%
%@AB@% --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"bigjob.h" %@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "BigJob1" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU ;%@NL@%
     HMQ            hmq ;%@NL@%
     HWND           hwndFrame, hwndClient ;%@NL@%
     QMSG           qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc,%@NL@%
                       CS_SYNCPAINT | CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass,%@NL@%
                                     " - The Bad Program",%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static LONG  lCalcRep, lRepAmts [] = { 10, 100, 1000, 10000, 100000 } ;%@NL@%
     static SHORT sCurrentRep = IDM_10 ;%@NL@%
     static SHORT sStatus = STATUS_READY ;%@NL@%
     static ULONG ulElapsedTime ;%@NL@%
     double       A ;%@NL@%
     LONG         lRep ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_10:%@NL@%
                    case IDM_100:%@NL@%
                    case IDM_1000:%@NL@%
                    case IDM_10000:%@NL@%
                    case IDM_100000:%@NL@%
                         CheckMenuItem (hwnd, sCurrentRep, FALSE) ;%@NL@%
                         sCurrentRep = COMMANDMSG(&msg)->cmd ;%@NL@%
                         CheckMenuItem (hwnd, sCurrentRep, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_START:%@NL@%
                         EnableMenuItem (hwnd, IDM_START, FALSE) ;%@NL@%
                         EnableMenuItem (hwnd, IDM_ABORT, TRUE) ;%@NL@%
%@NL@%
                         sStatus = STATUS_WORKING ;%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
%@NL@%
                         WinSetPointer (HWND_DESKTOP,%@NL@%
                                   WinQuerySysPointer (HWND_DESKTOP,%@NL@%
                                                       SPTR_WAIT, FALSE)) ;%@NL@%
%@NL@%
                         if (WinQuerySysValue (HWND_DESKTOP, SV_MOUSEPRESENT)%@NL@%
                                   == 0)%@NL@%
                              WinShowPointer (HWND_DESKTOP, TRUE) ;%@NL@%
%@NL@%
                         lCalcRep = lRepAmts [sCurrentRep - IDM_10] ;%@NL@%
                         ulElapsedTime = WinGetCurrentTime (hab) ;%@NL@%
%@NL@%
                         for (A = 1.0, lRep = 0 ; lRep < lCalcRep ; lRep++)%@NL@%
                              A = Savage (A) ;%@NL@%
%@NL@%
                         ulElapsedTime = WinGetCurrentTime (hab) -%@NL@%
                                        ulElapsedTime ;%@NL@%
%@NL@%
                         if (WinQuerySysValue (HWND_DESKTOP, SV_MOUSEPRESENT)%@NL@%
                                   == 0)%@NL@%
                              WinShowPointer (HWND_DESKTOP, FALSE) ;%@NL@%
%@NL@%
                         WinSetPointer (HWND_DESKTOP,%@NL@%
                                   WinQuerySysPointer (HWND_DESKTOP,%@NL@%
                                                       SPTR_ARROW, FALSE)) ;%@NL@%
                         sStatus = STATUS_DONE ;%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
%@NL@%
                         EnableMenuItem (hwnd, IDM_START, TRUE) ;%@NL@%
                         EnableMenuItem (hwnd, IDM_ABORT, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ABORT:     // Not much we can do here%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               PaintWindow (hwnd, sStatus, lCalcRep, ulElapsedTime) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIGJOB2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP17\BIGJOB2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------------------%@NL@%
%@AB@%   BIGJOB2.C -- Timer approach to lengthy processing job%@NL@%
%@AB@% --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"bigjob.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%ID_TIMER 1 %@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "BigJob2" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc,%@NL@%
                       CS_SYNCPAINT | CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass,%@NL@%
                                     " - The Timer",%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static double A ;%@NL@%
     static LONG   lRep, lCalcRep,%@NL@%
                   lRepAmts [] = { 10, 100, 1000, 10000, 100000 } ;%@NL@%
     static SHORT  sCurrentRep = IDM_10 ;%@NL@%
     static SHORT  sStatus = STATUS_READY ;%@NL@%
     static ULONG  ulElapsedTime ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_10:%@NL@%
                    case IDM_100:%@NL@%
                    case IDM_1000:%@NL@%
                    case IDM_10000:%@NL@%
                    case IDM_100000:%@NL@%
                         CheckMenuItem (hwnd, sCurrentRep, FALSE) ;%@NL@%
                         sCurrentRep = COMMANDMSG(&msg)->cmd ;%@NL@%
                         CheckMenuItem (hwnd, sCurrentRep, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_START:%@NL@%
                         if (!WinStartTimer (hab, hwnd, ID_TIMER, 0))%@NL@%
                              {%@NL@%
                              WinAlarm (HWND_DESKTOP, WA_ERROR) ;%@NL@%
                              return 0 ;%@NL@%
                              }%@NL@%
                         EnableMenuItem (hwnd, IDM_START, FALSE) ;%@NL@%
                         EnableMenuItem (hwnd, IDM_ABORT, TRUE) ;%@NL@%
%@NL@%
                         sStatus = STATUS_WORKING ;%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
%@NL@%
                         lCalcRep = lRepAmts [sCurrentRep - IDM_10] ;%@NL@%
                         ulElapsedTime = WinGetCurrentTime (hab) ;%@NL@%
                         A = 1.0 ;%@NL@%
                         lRep = 0 ;%@NL@%
%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ABORT:%@NL@%
                         WinStopTimer (hab, hwnd, ID_TIMER) ;%@NL@%
%@NL@%
                         sStatus = STATUS_READY ;%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
%@NL@%
                         EnableMenuItem (hwnd, IDM_START, TRUE) ;%@NL@%
                         EnableMenuItem (hwnd, IDM_ABORT, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_TIMER:%@NL@%
               A = Savage (A) ;%@NL@%
%@NL@%
               if (++lRep == lCalcRep)%@NL@%
                    {%@NL@%
                    ulElapsedTime = WinGetCurrentTime (hab) -%@NL@%
                                        ulElapsedTime ;%@NL@%
%@NL@%
                    WinStopTimer (hab, hwnd, ID_TIMER) ;%@NL@%
%@NL@%
                    sStatus = STATUS_DONE ;%@NL@%
                    WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
%@NL@%
                    EnableMenuItem (hwnd, IDM_START, TRUE) ;%@NL@%
                    EnableMenuItem (hwnd, IDM_ABORT, FALSE) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               PaintWindow (hwnd, sStatus, lCalcRep, ulElapsedTime) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               if (sStatus == STATUS_WORKING)%@NL@%
                    WinStopTimer (hab, hwnd, ID_TIMER) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIGJOB3.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP17\BIGJOB3.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------------------%@NL@%
%@AB@%   BIGJOB3.C -- Peek Message approach to lengthy processing job%@NL@%
%@AB@% ---------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"bigjob.h" %@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "BigJob3" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass,%@NL@%
                                     " - Message Peeking",%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
        %@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL   fContinueCalc = FALSE ;%@NL@%
     static LONG   lCalcRep, lRepAmts [] = { 10, 100, 1000, 10000, 100000 } ;%@NL@%
     static SHORT  sStatus = STATUS_READY ;%@NL@%
     static SHORT  sCurrentRep = IDM_10 ;%@NL@%
     static ULONG  ulElapsedTime ;%@NL@%
     double        A ;%@NL@%
     LONG          lRep ;%@NL@%
     QMSG          qmsg ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_10:%@NL@%
                    case IDM_100:%@NL@%
                    case IDM_1000:%@NL@%
                    case IDM_10000:%@NL@%
                    case IDM_100000:%@NL@%
                         CheckMenuItem (hwnd, sCurrentRep, FALSE) ;%@NL@%
                         sCurrentRep = COMMANDMSG(&msg)->cmd ;%@NL@%
                         CheckMenuItem (hwnd, sCurrentRep, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_START:%@NL@%
                         EnableMenuItem (hwnd, IDM_START, FALSE) ;%@NL@%
                         EnableMenuItem (hwnd, IDM_ABORT, TRUE) ;%@NL@%
%@NL@%
                         sStatus = STATUS_WORKING ;%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
%@NL@%
                         lCalcRep = lRepAmts [sCurrentRep - IDM_10] ;%@NL@%
                         fContinueCalc = TRUE ;%@NL@%
                         ulElapsedTime = WinGetCurrentTime (hab) ;%@NL@%
%@NL@%
                         qmsg.msg = WM_NULL ;%@NL@%
%@NL@%
                         for (A = 1.0, lRep = 0 ; lRep < lCalcRep ; lRep++)%@NL@%
                              {%@NL@%
                              A = Savage (A) ;%@NL@%
%@NL@%
                              while (WinPeekMsg (hab, &qmsg, NULL, 0, 0,%@NL@%
                                                 PM_NOREMOVE))%@NL@%
                                   {%@NL@%
                                   if (qmsg.msg == WM_QUIT)%@NL@%
                                        break ;%@NL@%
%@NL@%
                                   WinGetMsg (hab, &qmsg, NULL, 0, 0) ;%@NL@%
                                   WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
                                   if (!fContinueCalc)%@NL@%
                                        break ;%@NL@%
                                   }%@NL@%
                              if (!fContinueCalc || qmsg.msg == WM_QUIT)%@NL@%
                                   break ;%@NL@%
                              }%@NL@%
                         ulElapsedTime = WinGetCurrentTime (hab) - %@NL@%
                                                  ulElapsedTime ;%@NL@%
%@NL@%
                         if (!fContinueCalc || qmsg.msg == WM_QUIT)%@NL@%
                              sStatus = STATUS_READY ;%@NL@%
                         else%@NL@%
                              sStatus = STATUS_DONE ;%@NL@%
%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
%@NL@%
                         EnableMenuItem (hwnd, IDM_START, TRUE) ;%@NL@%
                         EnableMenuItem (hwnd, IDM_ABORT, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ABORT:%@NL@%
                         fContinueCalc = FALSE ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               PaintWindow (hwnd, sStatus, lCalcRep, ulElapsedTime) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIGJOB4.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP17\BIGJOB4.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------------------------------------%@NL@%
%@AB@%   BIGJOB4.C -- Second thread approach to lengthy processing job%@NL@%
%@AB@% ----------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_DOS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<mt\process.h> %@NL@%
%@AI@%#include %@AE@%<mt\stdlib.h> %@NL@%
%@AI@%#include %@AE@%"bigjob.h" %@NL@%
%@NL@%
VOID _CDECL FAR CalcThread (PCALCPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "BigJob4" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass,%@NL@%
                                     " - A Second Thread",%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
        %@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CALCPARAM cp ;%@NL@%
     static LONG      lRepAmts [] = { 10, 100, 1000, 10000, 100000 } ;%@NL@%
     static SHORT     sCurrentRep = IDM_10 ;%@NL@%
     static SHORT     sStatus = STATUS_READY ;%@NL@%
     static TID       tidCalc ;%@NL@%
     static ULONG     ulElapsedTime ;%@NL@%
     static VOID      *pThreadStack ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_10:%@NL@%
                    case IDM_100:%@NL@%
                    case IDM_1000:%@NL@%
                    case IDM_10000:%@NL@%
                    case IDM_100000:%@NL@%
                         CheckMenuItem (hwnd, sCurrentRep, FALSE) ;%@NL@%
                         sCurrentRep = COMMANDMSG(&msg)->cmd ;%@NL@%
                         CheckMenuItem (hwnd, sCurrentRep, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_START:%@NL@%
                         if (NULL == (pThreadStack = malloc (STACKSIZE)))%@NL@%
                              {%@NL@%
                              WinAlarm (HWND_DESKTOP, WA_ERROR) ;%@NL@%
                              return 0 ;%@NL@%
                              }%@NL@%
%@NL@%
                         cp.hwnd = hwnd ;%@NL@%
                         cp.lCalcRep = lRepAmts [sCurrentRep - IDM_10] ;%@NL@%
                         cp.fContinueCalc = TRUE ;%@NL@%
%@NL@%
                         if (-1 == (tidCalc = _beginthread (CalcThread,%@NL@%
                                        pThreadStack, STACKSIZE, &cp)))%@NL@%
                              {%@NL@%
                              free (pThreadStack) ;%@NL@%
                              WinAlarm (HWND_DESKTOP, WA_ERROR) ;%@NL@%
                              return 0 ;%@NL@%
                              }%@NL@%
%@NL@%
                         sStatus = STATUS_WORKING ;%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         EnableMenuItem (hwnd, IDM_START, FALSE) ;%@NL@%
                         EnableMenuItem (hwnd, IDM_ABORT, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ABORT:%@NL@%
                         cp.fContinueCalc = FALSE ;%@NL@%
                         EnableMenuItem (hwnd, IDM_ABORT, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_CALC_DONE:%@NL@%
               sStatus = STATUS_DONE ;%@NL@%
               ulElapsedTime = LONGFROMMP (mp1) ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               EnableMenuItem (hwnd, IDM_START, TRUE) ;%@NL@%
               EnableMenuItem (hwnd, IDM_ABORT, FALSE) ;%@NL@%
               free (pThreadStack) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CALC_ABORTED:%@NL@%
               sStatus = STATUS_READY ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               EnableMenuItem (hwnd, IDM_START, TRUE) ;%@NL@%
               free (pThreadStack) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               PaintWindow (hwnd, sStatus, cp.lCalcRep, ulElapsedTime) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               if (sStatus = STATUS_WORKING)%@NL@%
                    DosSuspendThread (tidCalc) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
VOID _CDECL FAR CalcThread (PCALCPARAM pcp)%@NL@%
     {%@NL@%
     double A ;%@NL@%
     LONG   lRep, lTime ;%@NL@%
%@NL@%
     lTime = WinGetCurrentTime (hab) ;%@NL@%
%@NL@%
     for (A = 1.0, lRep = 0 ; lRep < pcp->lCalcRep &&%@NL@%
                              pcp->fContinueCalc ; lRep++)%@NL@%
          A = Savage (A) ;%@NL@%
%@NL@%
     DosEnterCritSec () ;     // So thread is dead when message retrieved%@NL@%
%@NL@%
     if (pcp->fContinueCalc)%@NL@%
          {%@NL@%
          lTime = WinGetCurrentTime (hab) - lTime ;%@NL@%
          WinPostMsg (pcp->hwnd, WM_CALC_DONE, MPFROMLONG (lTime), NULL) ;%@NL@%
          }%@NL@%
     else%@NL@%
          WinPostMsg (pcp->hwnd, WM_CALC_ABORTED, NULL, NULL) ;%@NL@%
%@NL@%
     _endthread () ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIGJOB5.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP17\BIGJOB5.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------%@NL@%
%@AB@%   BIGJOB5.C -- Second thread and semaphore trigger%@NL@%
%@AB@% ---------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_DOS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<mt\process.h> %@NL@%
%@AI@%#include %@AE@%<mt\stdlib.h> %@NL@%
%@AI@%#include %@AE@%"bigjob.h" %@NL@%
%@NL@%
VOID _CDECL FAR CalcThread (PCALCPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "BigJob5" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass,%@NL@%
                                     " - Second Thread with Semaphore",%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
        %@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CALCPARAM cp ;%@NL@%
     static INT       iThreadStack [STACKSIZE / 2] ;%@NL@%
     static LONG      lRepAmts [] = { 10, 100, 1000, 10000, 100000 } ;%@NL@%
     static SHORT     sCurrentRep = IDM_10 ;%@NL@%
     static SHORT     sStatus = STATUS_READY ;%@NL@%
     static TID       tidCalc ;%@NL@%
     static ULONG     ulElapsedTime ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               cp.hwnd = hwnd ;%@NL@%
               DosSemSet (&cp.ulSemTrigger) ;%@NL@%
%@NL@%
               tidCalc = _beginthread (CalcThread, iThreadStack,%@NL@%
                                       STACKSIZE, &cp) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_INITMENU:%@NL@%
               if (tidCalc == -1 && SHORT1FROMMP (mp1) == IDM_ACTION)%@NL@%
                    EnableMenuItem (hwnd, IDM_START, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_10:%@NL@%
                    case IDM_100:%@NL@%
                    case IDM_1000:%@NL@%
                    case IDM_10000:%@NL@%
                    case IDM_100000:%@NL@%
                         CheckMenuItem (hwnd, sCurrentRep, FALSE) ;%@NL@%
                         sCurrentRep = COMMANDMSG(&msg)->cmd ;%@NL@%
                         CheckMenuItem (hwnd, sCurrentRep, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_START:%@NL@%
                         cp.lCalcRep = lRepAmts [sCurrentRep - IDM_10] ;%@NL@%
                         cp.fContinueCalc = TRUE ;%@NL@%
                         DosSemClear (&cp.ulSemTrigger) ;%@NL@%
%@NL@%
                         sStatus = STATUS_WORKING ;%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         EnableMenuItem (hwnd, IDM_START, FALSE) ;%@NL@%
                         EnableMenuItem (hwnd, IDM_ABORT, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ABORT:%@NL@%
                         cp.fContinueCalc = FALSE ;%@NL@%
                         EnableMenuItem (hwnd, IDM_ABORT, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_CALC_DONE:%@NL@%
               sStatus = STATUS_DONE ;%@NL@%
               ulElapsedTime = LONGFROMMP (mp1) ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               EnableMenuItem (hwnd, IDM_START, TRUE) ;%@NL@%
               EnableMenuItem (hwnd, IDM_ABORT, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CALC_ABORTED:%@NL@%
               sStatus = STATUS_READY ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               EnableMenuItem (hwnd, IDM_START, TRUE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               PaintWindow (hwnd, sStatus, cp.lCalcRep, ulElapsedTime) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               if (sStatus = STATUS_WORKING)%@NL@%
                    DosSuspendThread (tidCalc) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
VOID _CDECL FAR CalcThread (PCALCPARAM pcp)%@NL@%
     {%@NL@%
     double A ;%@NL@%
     LONG   lRep, lTime ;%@NL@%
%@NL@%
     while (TRUE)%@NL@%
          {%@NL@%
          DosSemWait (&pcp->ulSemTrigger, SEM_INDEFINITE_WAIT) ;%@NL@%
%@NL@%
          lTime = WinGetCurrentTime (hab) ;%@NL@%
%@NL@%
          for (A = 1.0, lRep = 0 ; lRep < pcp->lCalcRep &&%@NL@%
                                   pcp->fContinueCalc ; lRep++)%@NL@%
               A = Savage (A) ;%@NL@%
%@NL@%
          DosSemSet (&pcp->ulSemTrigger) ;%@NL@%
%@NL@%
          if (pcp->fContinueCalc)%@NL@%
               {%@NL@%
               lTime = WinGetCurrentTime (hab) - lTime ;%@NL@%
               WinPostMsg (pcp->hwnd, WM_CALC_DONE, MPFROMLONG (lTime), NULL) ;%@NL@%
               }%@NL@%
          else%@NL@%
               WinPostMsg (pcp->hwnd, WM_CALC_ABORTED, NULL, NULL) ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIGJOBMT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP17\BIGJOBMT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------------------------------%@NL@%
%@AB@%   BIGJOBMT.C -- Common functions used in BIGJOB4 and BIGJOB5%@NL@%
%@AB@%  ------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<mt\math.h> %@NL@%
%@AI@%#include %@AE@%<mt\stdio.h> %@NL@%
%@NL@%
double Savage (double A)%@NL@%
     {%@NL@%
     return tan (atan (exp (log (sqrt (A * A))))) + 1.0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID CheckMenuItem (HWND hwnd, SHORT sMenuItem, BOOL fCheck)%@NL@%
     {%@NL@%
     HWND  hwndParent = WinQueryWindow (hwnd, QW_PARENT, FALSE) ;%@NL@%
     HWND  hwndMenu   = WinWindowFromID (hwndParent, FID_MENU) ;%@NL@%
%@NL@%
     WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                 MPFROM2SHORT (sMenuItem, TRUE),%@NL@%
                 MPFROM2SHORT (MIA_CHECKED, fCheck ? MIA_CHECKED : 0)) ;%@NL@%
     }%@NL@%
%@NL@%
VOID EnableMenuItem (HWND hwnd, SHORT sMenuItem, BOOL fEnable)%@NL@%
     {%@NL@%
     HWND  hwndParent = WinQueryWindow (hwnd, QW_PARENT, FALSE) ;%@NL@%
     HWND  hwndMenu   = WinWindowFromID (hwndParent, FID_MENU) ;%@NL@%
%@NL@%
     WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                 MPFROM2SHORT (sMenuItem, TRUE),%@NL@%
                 MPFROM2SHORT (MIA_DISABLED, fEnable ? 0 : MIA_DISABLED)) ;%@NL@%
     }%@NL@%
%@NL@%
VOID PaintWindow (HWND hwnd, SHORT sStatus, LONG lCalcRep, ULONG ulTime)%@NL@%
     {%@NL@%
     static CHAR *szMessage [3] = { "Ready", "Working...",%@NL@%
                                    "%ld repetitions in %lu msec." } ;%@NL@%
     CHAR        szBuffer [60] ;%@NL@%
     HPS         hps ;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
     hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
     WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
     sprintf (szBuffer, szMessage [sStatus], lCalcRep, ulTime) ;%@NL@%
     WinDrawText (hps, -1, szBuffer, &rcl, CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                  DT_CENTER | DT_VCENTER | DT_ERASERECT) ;%@NL@%
%@NL@%
     WinEndPaint (hps) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BITCAT1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP06\BITCAT1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------------%@NL@%
%@AB@%   BITCAT1.C -- Bitmap Creation and Display%@NL@%
%@AB@%  ------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%"bitcat.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "BitCat1" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static HBITMAP   hbm ;%@NL@%
     BITMAPINFO       *pbmi ;%@NL@%
     BITMAPINFOHEADER bmp ;%@NL@%
     HPS              hps ;%@NL@%
     RECTL            rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
%@NL@%
                         %@AB@%/*-----------------------------------%@NL@%
%@AB@%                            Create 32-by-32 monochrome bitmap%@NL@%
%@AB@%                           -----------------------------------*/%@AE@%%@NL@%
%@NL@%
               bmp.cbFix     = sizeof bmp ;%@NL@%
               bmp.cx        = 32 ;%@NL@%
               bmp.cy        = 32 ;%@NL@%
               bmp.cPlanes   = 1 ;%@NL@%
               bmp.cBitCount = 1 ;%@NL@%
%@NL@%
               pbmi = malloc (sizeof (BITMAPINFO) + sizeof (RGB)) ;%@NL@%
%@NL@%
               pbmi->cbFix     = sizeof bmp ;%@NL@%
               pbmi->cx        = 32 ;%@NL@%
               pbmi->cy        = 32 ;%@NL@%
               pbmi->cPlanes   = 1 ;%@NL@%
               pbmi->cBitCount = 1;%@NL@%
%@NL@%
               pbmi->argbColor[0].bBlue  = 0 ;%@NL@%
               pbmi->argbColor[0].bGreen = 0 ;%@NL@%
               pbmi->argbColor[0].bRed   = 0 ;%@NL@%
               pbmi->argbColor[1].bBlue  = 0xFF ;%@NL@%
               pbmi->argbColor[1].bGreen = 0xFF ;%@NL@%
               pbmi->argbColor[1].bRed   = 0xFF ;%@NL@%
%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               hbm = GpiCreateBitmap (hps, &bmp, CBM_INIT, abBitCat, pbmi) ;%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
               free (pbmi) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
               WinDrawBitmap (hps, hbm, NULL, (PPOINTL) &rcl,%@NL@%
                              CLR_NEUTRAL, CLR_BACKGROUND, DBM_STRETCH) ;%@NL@%
%@NL@%
               WinDrawBitmap (hps, hbm, NULL, (PPOINTL) &rcl,%@NL@%
                              CLR_NEUTRAL, CLR_BACKGROUND, DBM_NORMAL) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               GpiDeleteBitmap (hbm) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BITCAT2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP06\BITCAT2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------------%@NL@%
%@AB@%   BITCAT2.C -- Bitmap Creation and Display%@NL@%
%@AB@%  ------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%"bitcat.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "BitCat2" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static HBITMAP   hbm ;%@NL@%
     static HDC       hdcMemory ;%@NL@%
     static HPS       hpsMemory ;%@NL@%
     static SHORT     cxClient, cyClient ;%@NL@%
     BITMAPINFO       *pbmi ;%@NL@%
     BITMAPINFOHEADER bmp ;%@NL@%
     HPS              hps ;%@NL@%
     POINTL           aptl [4] ;%@NL@%
     SIZEL            sizl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
%@NL@%
                         %@AB@%/*-------------------------------------------------%@NL@%
%@AB@%                            Open memory DC and create PS associated with it%@NL@%
%@AB@%                           -------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
               hdcMemory = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
%@NL@%
               sizl.cx = 0 ;%@NL@%
               sizl.cy = 0 ;%@NL@%
%@NL@%
               hpsMemory = GpiCreatePS (hab, hdcMemory, &sizl,%@NL@%
                                        PU_PELS    | GPIF_DEFAULT |%@NL@%
                                        GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
                         %@AB@%/*------------------------%@NL@%
%@AB@%                            Create 32 by 32 bitmap%@NL@%
%@AB@%                           ------------------------*/%@AE@%%@NL@%
%@NL@%
               bmp.cbFix     = sizeof bmp ;%@NL@%
               bmp.cx        = 32 ;%@NL@%
               bmp.cy        = 32 ;%@NL@%
               bmp.cPlanes   = 1 ;%@NL@%
               bmp.cBitCount = 1 ;%@NL@%
%@NL@%
               hbm = GpiCreateBitmap (hpsMemory, &bmp, 0L, NULL, NULL) ;%@NL@%
%@NL@%
                         %@AB@%/*------------------------------%@NL@%
%@AB@%                            Select bitmap into memory PS%@NL@%
%@AB@%                           ------------------------------*/%@AE@%%@NL@%
%@NL@%
               GpiSetBitmap (hpsMemory, hbm) ;%@NL@%
%@NL@%
                         %@AB@%/*-------------------------------------%@NL@%
%@AB@%                            Set bitmap bits from abBitCat array%@NL@%
%@AB@%                           -------------------------------------*/%@AE@%%@NL@%
%@NL@%
               pbmi = malloc (sizeof (BITMAPINFO) + sizeof (RGB)) ;%@NL@%
%@NL@%
               pbmi->cbFix     = sizeof bmp ;%@NL@%
               pbmi->cx        = 32 ;%@NL@%
               pbmi->cy        = 32 ;%@NL@%
               pbmi->cPlanes   = 1 ;%@NL@%
               pbmi->cBitCount = 1 ;%@NL@%
%@NL@%
               pbmi->argbColor[0].bBlue  = 0 ;%@NL@%
               pbmi->argbColor[0].bGreen = 0 ;%@NL@%
               pbmi->argbColor[0].bRed   = 0 ;%@NL@%
               pbmi->argbColor[1].bBlue  = 0xFF ;%@NL@%
               pbmi->argbColor[1].bGreen = 0xFF ;%@NL@%
               pbmi->argbColor[1].bRed   = 0xFF ;%@NL@%
%@NL@%
               GpiSetBitmapBits (hpsMemory, 0L, 32L, abBitCat, pbmi) ;%@NL@%
%@NL@%
               free (pbmi) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               aptl[0].x = 0 ;                    // target lower left%@NL@%
               aptl[0].y = 0 ;%@NL@%
%@NL@%
               aptl[1].x = cxClient ;             // target upper right%@NL@%
               aptl[1].y = cyClient ;%@NL@%
%@NL@%
               aptl[2].x = 0 ;                    // source lower left%@NL@%
               aptl[2].y = 0 ;%@NL@%
%@NL@%
               aptl[3].x = 32 ;                   // source upper right%@NL@%
               aptl[3].y = 32 ;%@NL@%
%@NL@%
               GpiBitBlt (hps, hpsMemory, 4L, aptl, ROP_SRCCOPY, BBO_AND) ;%@NL@%
%@NL@%
               aptl[1] = aptl[3] ;                // target upper right%@NL@%
%@NL@%
               GpiBitBlt (hps, hpsMemory, 3L, aptl, ROP_SRCCOPY, BBO_AND) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               GpiDestroyPS (hpsMemory) ;%@NL@%
               DevCloseDC (hdcMemory) ;%@NL@%
               GpiDeleteBitmap (hbm) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BITLIB.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP16\BITLIB.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%;---------------------------------------------------------------%@AE@%%@NL@%
%@AB@%; BITLIB.ASM assembly language module for resource-only library%@AE@%%@NL@%
%@AB@%;---------------------------------------------------------------%@AE@%%@NL@%
%@NL@%
end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BLOKOUT1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP09\BLOKOUT1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------%@NL@%
%@AB@%   BLOKOUT1.C -- Mouse Button Demo Program %@NL@%
%@AB@%  -----------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "BlokOut1" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID DrawBoxOutline (HWND hwnd, POINTL *pptlStart, POINTL *pptlEnd)%@NL@%
     {%@NL@%
     HPS hps ;%@NL@%
%@NL@%
     hps = WinGetPS (hwnd) ;%@NL@%
     GpiSetMix (hps, FM_INVERT) ;%@NL@%
%@NL@%
     GpiMove (hps, pptlStart) ;%@NL@%
     GpiBox (hps, DRO_OUTLINE, pptlEnd, 0L, 0L) ;%@NL@%
%@NL@%
     WinReleasePS (hps) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL   fButtonDown, fValidBox ;%@NL@%
     static POINTL ptlStart, ptlEnd, ptlBoxStart, ptlBoxEnd ;%@NL@%
     HPS           hps ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               ptlStart.x = ptlEnd.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptlStart.y = ptlEnd.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
               DrawBoxOutline (hwnd, &ptlStart, &ptlEnd) ;%@NL@%
%@NL@%
               fButtonDown = TRUE ;%@NL@%
               break ;                       // do default processing%@NL@%
%@NL@%
          case WM_MOUSEMOVE:%@NL@%
               if (fButtonDown)%@NL@%
                    {%@NL@%
                    DrawBoxOutline (hwnd, &ptlStart, &ptlEnd) ;%@NL@%
%@NL@%
                    ptlEnd.x = MOUSEMSG(&msg)->x ;%@NL@%
                    ptlEnd.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
                    DrawBoxOutline (hwnd, &ptlStart, &ptlEnd) ;%@NL@%
                    }%@NL@%
               break ;                       // do default processing%@NL@%
%@NL@%
          case WM_BUTTON1UP:%@NL@%
               if (fButtonDown)%@NL@%
                    {%@NL@%
                    DrawBoxOutline (hwnd, &ptlStart, &ptlEnd) ;%@NL@%
%@NL@%
                    ptlBoxStart = ptlStart ;%@NL@%
                    ptlBoxEnd.x = MOUSEMSG(&msg)->x ;%@NL@%
                    ptlBoxEnd.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
                    fButtonDown = FALSE ;%@NL@%
                    fValidBox = TRUE ;%@NL@%
                    WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               if (fValidBox)%@NL@%
                    {%@NL@%
                    GpiMove (hps, &ptlBoxStart) ;%@NL@%
                    GpiBox (hps, DRO_OUTLINEFILL, &ptlBoxEnd, 0L, 0L) ;%@NL@%
                    }%@NL@%
               if (fButtonDown)%@NL@%
                    {%@NL@%
                    GpiSetMix (hps, FM_INVERT) ;%@NL@%
%@NL@%
                    GpiMove (hps, &ptlStart) ;%@NL@%
                    GpiBox (hps, DRO_OUTLINE, &ptlEnd, 0L, 0L) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BLOKOUT2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP09\BLOKOUT2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------------------------%@NL@%
%@AB@%   BLOKOUT2.C -- Mouse Button & Capture Demo Program%@NL@%
%@AB@%  ---------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "BlokOut2" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID DrawBoxOutline (HWND hwnd, POINTL *pptlStart, POINTL *pptlEnd)%@NL@%
     {%@NL@%
     HPS hps ;%@NL@%
%@NL@%
     hps = WinGetPS (hwnd) ;%@NL@%
     GpiSetMix (hps, FM_INVERT) ;%@NL@%
%@NL@%
     GpiMove (hps, pptlStart) ;%@NL@%
     GpiBox (hps, DRO_OUTLINE, pptlEnd, 0L, 0L) ;%@NL@%
%@NL@%
     WinReleasePS (hps) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL   fCapture, fValidBox ;%@NL@%
     static POINTL ptlStart, ptlEnd, ptlBoxStart, ptlBoxEnd ;%@NL@%
     HPS           hps ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               ptlStart.x = ptlEnd.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptlStart.y = ptlEnd.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
               DrawBoxOutline (hwnd, &ptlStart, &ptlEnd) ;%@NL@%
%@NL@%
               WinSetCapture (HWND_DESKTOP, hwnd) ;%@NL@%
               fCapture = TRUE ;%@NL@%
               break ;                       // do default processing%@NL@%
%@NL@%
          case WM_MOUSEMOVE:%@NL@%
               if (fCapture)%@NL@%
                    {%@NL@%
                    DrawBoxOutline (hwnd, &ptlStart, &ptlEnd) ;%@NL@%
%@NL@%
                    ptlEnd.x = MOUSEMSG(&msg)->x ;%@NL@%
                    ptlEnd.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
                    DrawBoxOutline (hwnd, &ptlStart, &ptlEnd) ;%@NL@%
                    }%@NL@%
               break ;                       // do default processing%@NL@%
%@NL@%
          case WM_BUTTON1UP:%@NL@%
               if (fCapture)%@NL@%
                    {%@NL@%
                    DrawBoxOutline (hwnd, &ptlStart, &ptlEnd) ;%@NL@%
%@NL@%
                    ptlBoxStart = ptlStart ;%@NL@%
                    ptlBoxEnd.x = MOUSEMSG(&msg)->x ;%@NL@%
                    ptlBoxEnd.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
                    WinSetCapture (HWND_DESKTOP, NULL) ;%@NL@%
                    fCapture = FALSE ;%@NL@%
                    fValidBox = TRUE ;%@NL@%
                    WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               if (fCapture && CHARMSG(&msg)->fs   &  KC_VIRTUALKEY &&%@NL@%
                             !(CHARMSG(&msg)->fs   &  KC_KEYUP)     &&%@NL@%
                               CHARMSG(&msg)->vkey == VK_ESC)%@NL@%
                    {%@NL@%
                    DrawBoxOutline (hwnd, &ptlStart, &ptlEnd) ;%@NL@%
%@NL@%
                    WinSetCapture (HWND_DESKTOP, NULL) ;%@NL@%
                    fCapture = FALSE ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               if (fValidBox)%@NL@%
                    {%@NL@%
                    GpiMove (hps, &ptlBoxStart) ;%@NL@%
                    GpiBox (hps, DRO_OUTLINEFILL, &ptlBoxEnd, 0L, 0L) ;%@NL@%
                    }%@NL@%
               if (fCapture)%@NL@%
                    {%@NL@%
                    GpiSetMix (hps, FM_INVERT) ;%@NL@%
                    GpiMove (hps, &ptlStart) ;%@NL@%
                    GpiBox (hps, DRO_OUTLINE, &ptlEnd, 0L, 0L) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BLOWUP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP15\BLOWUP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------%@NL@%
%@AB@%   BLOWUP.C -- Screen Capture Program%@NL@%
%@AB@%  ------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"blowup.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
CHAR szClientClass [] = "BlowUp" ;%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU          | FCF_ACCELTABLE ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
BOOL BeginTracking (RECTL *prclTrack)%@NL@%
     {%@NL@%
     LONG      cxScreen, cyScreen, cxPointer, cyPointer ;%@NL@%
     TRACKINFO ti ;%@NL@%
%@NL@%
     cxScreen  = WinQuerySysValue (HWND_DESKTOP, SV_CXSCREEN) ;%@NL@%
     cyScreen  = WinQuerySysValue (HWND_DESKTOP, SV_CYSCREEN) ;%@NL@%
     cxPointer = WinQuerySysValue (HWND_DESKTOP, SV_CXPOINTER) ;%@NL@%
     cyPointer = WinQuerySysValue (HWND_DESKTOP, SV_CYPOINTER) ;%@NL@%
%@NL@%
                                   // Set up track rectangle for moving%@NL@%
%@NL@%
     ti.cxBorder = 1 ;                       // Border width%@NL@%
     ti.cyBorder = 1 ;%@NL@%
     ti.cxGrid = 0 ;                         // Not used%@NL@%
     ti.cyGrid = 0 ;%@NL@%
     ti.cxKeyboard = 4 ;                     // Pixel increment for keyboard%@NL@%
     ti.cyKeyboard = 4 ;%@NL@%
%@NL@%
     ti.rclBoundary.xLeft   = 0 ;            // Area for tracking rectangle%@NL@%
     ti.rclBoundary.yBottom = 0 ;%@NL@%
     ti.rclBoundary.xRight  = cxScreen ;%@NL@%
     ti.rclBoundary.yTop    = cyScreen ;%@NL@%
%@NL@%
     ti.ptlMinTrackSize.x = 1 ;              // Minimum rectangle size%@NL@%
     ti.ptlMinTrackSize.y = 1 ;%@NL@%
%@NL@%
     ti.ptlMaxTrackSize.x = cxScreen ;       // Maximum rectangle size%@NL@%
     ti.ptlMaxTrackSize.y = cyScreen ;%@NL@%
                                             // Initial position%@NL@%
%@NL@%
     ti.rclTrack.xLeft   = (cxScreen - cxPointer) / 2 ;%@NL@%
     ti.rclTrack.yBottom = (cyScreen - cyPointer) / 2 ;%@NL@%
     ti.rclTrack.xRight  = (cxScreen + cxPointer) / 2 ;%@NL@%
     ti.rclTrack.yTop    = (cyScreen + cyPointer) / 2 ;%@NL@%
%@NL@%
     ti.fs = TF_MOVE | TF_STANDARD | TF_SETPOINTERPOS ;     // Flags%@NL@%
%@NL@%
     if (!WinTrackRect (HWND_DESKTOP, NULL, &ti))%@NL@%
          return FALSE ;%@NL@%
                                   // Switch to "sizing" pointer%@NL@%
     WinSetPointer (HWND_DESKTOP,%@NL@%
               WinQuerySysPointer (HWND_DESKTOP, SPTR_SIZENESW, FALSE)) ;%@NL@%
%@NL@%
                                   // Track rectangle for sizing%@NL@%
%@NL@%
     ti.fs = TF_RIGHT | TF_TOP | TF_STANDARD | TF_SETPOINTERPOS ;%@NL@%
%@NL@%
     if (!WinTrackRect (HWND_DESKTOP, NULL, &ti))%@NL@%
          return FALSE ;%@NL@%
%@NL@%
     *prclTrack = ti.rclTrack ;    // Final rectangle%@NL@%
%@NL@%
     return TRUE ;%@NL@%
     }%@NL@%
%@NL@%
HBITMAP CopyScreenToBitmap (RECTL *prclTrack)%@NL@%
     {%@NL@%
     BITMAPINFOHEADER bmp ;%@NL@%
     HBITMAP          hbm ;%@NL@%
     HDC              hdcMemory ;%@NL@%
     HPS              hps, hpsMemory ;%@NL@%
     LONG             alBmpFormats[2] ;%@NL@%
     POINTL           aptl[3] ;%@NL@%
     SIZEL            sizl ;%@NL@%
                                   // Create memory DC and PS%@NL@%
%@NL@%
     hdcMemory = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
%@NL@%
     sizl.cx = sizl.cy = 0 ;%@NL@%
     hpsMemory = GpiCreatePS (hab, hdcMemory, &sizl,%@NL@%
                              PU_PELS    | GPIF_DEFAULT |%@NL@%
                              GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
                                   // Create bitmap for destination%@NL@%
%@NL@%
     GpiQueryDeviceBitmapFormats (hpsMemory, 2L, alBmpFormats) ;%@NL@%
%@NL@%
     bmp.cbFix     = sizeof bmp ;%@NL@%
     bmp.cx        = (USHORT) (prclTrack->xRight - prclTrack->xLeft) ;%@NL@%
     bmp.cy        = (USHORT) (prclTrack->yTop   - prclTrack->yBottom) ;%@NL@%
     bmp.cPlanes   = (USHORT) alBmpFormats[0] ;%@NL@%
     bmp.cBitCount = (USHORT) alBmpFormats[1] ;%@NL@%
%@NL@%
     hbm = GpiCreateBitmap (hpsMemory, &bmp, 0L, NULL, NULL) ;%@NL@%
%@NL@%
                                   // Copy from screen to bitmap%@NL@%
     if (hbm != NULL)%@NL@%
          {%@NL@%
          GpiSetBitmap (hpsMemory, hbm) ;%@NL@%
          hps = WinGetScreenPS (HWND_DESKTOP) ;%@NL@%
%@NL@%
          aptl[0].x = 0 ;%@NL@%
          aptl[0].y = 0 ;%@NL@%
          aptl[1].x = bmp.cx ;%@NL@%
          aptl[1].y = bmp.cy ;%@NL@%
          aptl[2].x = prclTrack->xLeft ;%@NL@%
          aptl[2].y = prclTrack->yBottom ;%@NL@%
%@NL@%
          WinLockVisRegions (HWND_DESKTOP, TRUE) ;%@NL@%
%@NL@%
          GpiBitBlt (hpsMemory, hps, 3L, aptl, ROP_SRCCOPY, BBO_IGNORE);%@NL@%
%@NL@%
          WinLockVisRegions (HWND_DESKTOP, FALSE) ;%@NL@%
%@NL@%
          WinReleasePS (hps) ;%@NL@%
          }%@NL@%
                                   // Clean up%@NL@%
     GpiDestroyPS (hpsMemory) ;%@NL@%
     DevCloseDC (hdcMemory) ;%@NL@%
%@NL@%
     return hbm ;%@NL@%
     }%@NL@%
%@NL@%
HBITMAP CopyBitmap (HBITMAP hbmSrc)%@NL@%
     {%@NL@%
     BITMAPINFOHEADER bmp ;%@NL@%
     HBITMAP          hbmDst ;%@NL@%
     HDC              hdcSrc, hdcDst ;%@NL@%
     HPS              hpsSrc, hpsDst ;%@NL@%
     POINTL           aptl[3] ;%@NL@%
     SIZEL            sizl ;%@NL@%
%@NL@%
                                   // Create memory DC's and PS's%@NL@%
%@NL@%
     hdcSrc = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
     hdcDst = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
%@NL@%
     sizl.cx = sizl.cy = 0 ;%@NL@%
     hpsSrc = GpiCreatePS (hab, hdcSrc, &sizl, PU_PELS    | GPIF_DEFAULT |%@NL@%
                                               GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
     hpsDst = GpiCreatePS (hab, hdcDst, &sizl, PU_PELS    | GPIF_DEFAULT |%@NL@%
                                               GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
                                   // Create bitmap%@NL@%
%@NL@%
     GpiQueryBitmapParameters (hbmSrc, &bmp) ;%@NL@%
     hbmDst = GpiCreateBitmap (hpsDst, &bmp, 0L, NULL, NULL) ;%@NL@%
%@NL@%
                                   // Copy from source to destination%@NL@%
%@NL@%
     if (hbmDst != NULL)%@NL@%
          {%@NL@%
          GpiSetBitmap (hpsSrc, hbmSrc) ;%@NL@%
          GpiSetBitmap (hpsDst, hbmDst) ;%@NL@%
%@NL@%
          aptl[0].x = aptl[0].y = 0 ;%@NL@%
          aptl[1].x = bmp.cx ;%@NL@%
          aptl[1].y = bmp.cy ;%@NL@%
          aptl[2]   = aptl[0] ;%@NL@%
%@NL@%
          GpiBitBlt (hpsDst, hpsSrc, 3L, aptl, ROP_SRCCOPY, BBO_IGNORE) ;%@NL@%
          }%@NL@%
                                   // Clean up%@NL@%
     GpiDestroyPS (hpsSrc) ;%@NL@%
     GpiDestroyPS (hpsDst) ;%@NL@%
     DevCloseDC (hdcSrc) ;%@NL@%
     DevCloseDC (hdcDst) ;%@NL@%
%@NL@%
     return hbmDst ;%@NL@%
     }%@NL@%
%@NL@%
VOID BitmapCreationError (HWND hwnd)%@NL@%
     {%@NL@%
     WinMessageBox (HWND_DESKTOP, hwnd, "Cannot create bitmap.",%@NL@%
                    szClientClass, 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static HBITMAP   hbm ;%@NL@%
     static HWND      hwndMenu ;%@NL@%
     static SHORT     sDisplay = IDM_ACTUAL ;%@NL@%
     HBITMAP          hbmClip ;%@NL@%
     HPS              hps ;%@NL@%
     RECTL            rclTrack, rclClient ;%@NL@%
     USHORT           usfInfo ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hwndMenu = WinWindowFromID (%@NL@%
                               WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                               FID_MENU) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_INITMENU:%@NL@%
               switch (SHORT1FROMMP (mp1))%@NL@%
                    {%@NL@%
                    case IDM_EDIT:%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (IDM_COPY, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_DISABLED,%@NL@%
                                          hbm != NULL ? 0 : MIA_DISABLED)) ;%@NL@%
%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (IDM_PASTE, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_DISABLED,%@NL@%
                              WinQueryClipbrdFmtInfo (hab, CF_BITMAP, &usfInfo)%@NL@%
                                        ? 0 : MIA_DISABLED)) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_COPY:%@NL@%
                                        // Make copy of stored bitmap%@NL@%
%@NL@%
                         hbmClip = CopyBitmap (hbm) ;%@NL@%
%@NL@%
                                        // Set clipboard data to copy of bitmap%@NL@%
%@NL@%
                         if (hbmClip != NULL)%@NL@%
                              {%@NL@%
                              WinOpenClipbrd (hab) ;%@NL@%
                              WinEmptyClipbrd (hab) ;%@NL@%
                              WinSetClipbrdData (hab, (ULONG) hbmClip,%@NL@%
                                                 CF_BITMAP, CFI_HANDLE) ;%@NL@%
                              WinCloseClipbrd (hab) ;%@NL@%
                              }%@NL@%
                         else%@NL@%
                              BitmapCreationError (hwnd) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_PASTE:%@NL@%
                                         // Get bitmap from clipboard%@NL@%
%@NL@%
                         WinOpenClipbrd (hab) ;%@NL@%
                         hbmClip = WinQueryClipbrdData (hab, CF_BITMAP) ;%@NL@%
%@NL@%
                         if (hbmClip != NULL)%@NL@%
                              {%@NL@%
                              if (hbm != NULL)%@NL@%
                                   GpiDeleteBitmap (hbm) ;%@NL@%
%@NL@%
                                        // Make copy of it%@NL@%
%@NL@%
                              hbm = CopyBitmap (hbmClip) ;%@NL@%
%@NL@%
                              if (hbm == NULL)%@NL@%
                                   BitmapCreationError (hwnd) ;%@NL@%
                              }%@NL@%
                         WinCloseClipbrd (hab) ;%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_CAPTURE:%@NL@%
                         if (BeginTracking (&rclTrack))%@NL@%
                              {%@NL@%
                              if (hbm != NULL)%@NL@%
                                   GpiDeleteBitmap (hbm) ;%@NL@%
%@NL@%
                              hbm = CopyScreenToBitmap (&rclTrack) ;%@NL@%
%@NL@%
                              if (hbm == NULL)%@NL@%
                                   BitmapCreationError (hwnd) ;%@NL@%
%@NL@%
                              WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                              }%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ACTUAL:%@NL@%
                    case IDM_STRETCH:%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (sDisplay, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_CHECKED, 0)) ;%@NL@%
%@NL@%
                         sDisplay = COMMANDMSG(&msg)->cmd ;%@NL@%
%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (sDisplay, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_CHECKED, MIA_CHECKED)) ;%@NL@%
%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               if (hbm != NULL)%@NL@%
                    {%@NL@%
                    WinQueryWindowRect (hwnd, &rclClient) ;%@NL@%
%@NL@%
                    WinDrawBitmap (hps, hbm, NULL, (PPOINTL) &rclClient,%@NL@%
                                   CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                                   sDisplay == IDM_STRETCH ?%@NL@%
                                        DBM_STRETCH : DBM_NORMAL) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               if (hbm != NULL)%@NL@%
                    GpiDeleteBitmap (hbm) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BRICKS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP06\BRICKS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------%@NL@%
%@AB@%   BRICKS.C -- Customized Pattern from Bitmap%@NL@%
%@AB@%  --------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%LCID_BRICKS_BITMAP    1L %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Bricks" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BYTE      abBrick [] = {%@NL@%
                                   0x00, 0x00, 0x00, 0x00,%@NL@%
                                   0xF3, 0x00, 0x00, 0x00,%@NL@%
                                   0xF3, 0x00, 0x00, 0x00,%@NL@%
                                   0xF3, 0x00, 0x00, 0x00,%@NL@%
                                   0x00, 0x00, 0x00, 0x00,%@NL@%
                                   0x3F, 0x00, 0x00, 0x00,%@NL@%
                                   0x3F, 0x00, 0x00, 0x00,%@NL@%
                                   0x3F, 0x00, 0x00, 0x00%@NL@%
                                   } ;%@NL@%
     static HBITMAP   hbm ;%@NL@%
     static POINTL    aptl [2] ;%@NL@%
     BITMAPINFO       *pbmi ;%@NL@%
     BITMAPINFOHEADER bmp ;%@NL@%
     HPS              hps ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
                              %@AB@%/*----------------------%@NL@%
%@AB@%                                 Create 8 by 8 bitmap%@NL@%
%@AB@%                                ----------------------*/%@AE@%%@NL@%
%@NL@%
               bmp.cbFix     = sizeof bmp ;%@NL@%
               bmp.cx        = 8 ;%@NL@%
               bmp.cy        = 8 ;%@NL@%
               bmp.cPlanes   = 1 ;%@NL@%
               bmp.cBitCount = 1 ;%@NL@%
%@NL@%
               pbmi = malloc (sizeof (BITMAPINFO) + sizeof (RGB)) ;%@NL@%
%@NL@%
               pbmi->cbFix     = sizeof bmp ;%@NL@%
               pbmi->cx        = 8 ;%@NL@%
               pbmi->cy        = 8 ;%@NL@%
               pbmi->cPlanes   = 1 ;%@NL@%
               pbmi->cBitCount = 1 ;%@NL@%
%@NL@%
               pbmi->argbColor[0].bBlue  = 0 ;%@NL@%
               pbmi->argbColor[0].bGreen = 0 ;%@NL@%
               pbmi->argbColor[0].bRed   = 0 ;%@NL@%
               pbmi->argbColor[1].bBlue  = 0xFF ;%@NL@%
               pbmi->argbColor[1].bGreen = 0xFF ;%@NL@%
               pbmi->argbColor[1].bRed   = 0xFF ;%@NL@%
%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               hbm = GpiCreateBitmap (hps, &bmp, CBM_INIT, abBrick, pbmi) ;%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
               free (pbmi) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               aptl[1].x = SHORT1FROMMP (mp2) ;%@NL@%
               aptl[1].y = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               GpiSetBitmapId (hps, hbm, LCID_BRICKS_BITMAP) ;%@NL@%
               GpiSetPatternSet (hps, LCID_BRICKS_BITMAP) ;%@NL@%
%@NL@%
               GpiBitBlt (hps, NULL, 2L, aptl, ROP_PATCOPY, BBO_AND) ;%@NL@%
%@NL@%
               GpiSetPatternSet (hps, LCID_DEFAULT) ;%@NL@%
               GpiDeleteSetId (hps, LCID_BRICKS_BITMAP) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               GpiDeleteBitmap (hbm) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BUTTONS1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP11\BUTTONS1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------%@NL@%
%@AB@%   BUTTONS1.C -- Push Button Demonstration%@NL@%
%@AB@%  -----------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "Buttons1" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR  *szButtonLabel[] = { "Smaller", "Larger" } ;%@NL@%
     static HWND  hwndFrame, hwndButton[2] ;%@NL@%
     static SHORT cxClient, cyClient, cxChar, cyChar ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     HPS          hps ;%@NL@%
     SHORT        id ;%@NL@%
     RECTL        rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE :%@NL@%
               hwndFrame = WinQueryWindow (hwnd, QW_PARENT, FALSE) ;%@NL@%
%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               for (id = 0 ; id < 2 ; id++)%@NL@%
                    hwndButton[id] = WinCreateWindow (%@NL@%
                                        hwnd,               // Parent%@NL@%
                                        WC_BUTTON,          // Class%@NL@%
                                        szButtonLabel[id],  // Text%@NL@%
                                        WS_VISIBLE |        // Style%@NL@%
                                             BS_PUSHBUTTON,%@NL@%
                                        0, 0,               // Position%@NL@%
                                        12 * cxChar,        // Width%@NL@%
                                        2 * cyChar,         // Height%@NL@%
                                        hwnd,               // Owner%@NL@%
                                        HWND_BOTTOM,        // Placement%@NL@%
                                        id,                 // ID%@NL@%
                                        NULL,               // Ctrl Data%@NL@%
                                        NULL) ;             // Pres Params%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE :%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               for (id = 0 ; id < 2 ; id++)%@NL@%
                    WinSetWindowPos (hwndButton[id], NULL,%@NL@%
                              cxClient / 2 + (14 * id - 13) * cxChar,%@NL@%
                              (cyClient - 2 * cyChar) / 2,%@NL@%
                              0, 0, SWP_MOVE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               WinMapWindowPoints (hwnd, HWND_DESKTOP, (PPOINTL) &rcl, 2) ;%@NL@%
%@NL@%
               switch (COMMANDMSG(&msg)->cmd)               // Child ID%@NL@%
                    {%@NL@%
                    case 0:                                 // "Smaller"%@NL@%
                         rcl.xLeft   += cxClient / 20 ;%@NL@%
                         rcl.xRight  -= cxClient / 20 ;%@NL@%
                         rcl.yBottom += cyClient / 20 ;%@NL@%
                         rcl.yTop    -= cyClient / 20 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case 1:                                 // "Larger"%@NL@%
                         rcl.xLeft   -= cxClient / 20 ;%@NL@%
                         rcl.xRight  += cxClient / 20 ;%@NL@%
                         rcl.yBottom -= cyClient / 20 ;%@NL@%
                         rcl.yTop    += cyClient / 20 ;%@NL@%
                         break ;%@NL@%
                    }%@NL@%
               WinCalcFrameRect (hwndFrame, &rcl, FALSE) ;%@NL@%
%@NL@%
               WinSetWindowPos (hwndFrame, NULL,%@NL@%
                                (SHORT) rcl.xLeft, (SHORT) rcl.yBottom,%@NL@%
                                (SHORT) rcl.xRight - (SHORT) rcl.xLeft,%@NL@%
                                (SHORT) rcl.yTop   - (SHORT) rcl.yBottom,%@NL@%
                                SWP_MOVE | SWP_SIZE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BUTTONS2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP11\BUTTONS2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------%@NL@%
%@AB@%   BUTTONS2.C -- Square Button Demonstration%@NL@%
%@AB@%  -------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
BOOL RegisterSqBtnClass (HAB) ;         // In SQBTN.C%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "Buttons2" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR  szSqBtnClass[] = "SqBtn",%@NL@%
                  *szButtonLabel[] = { "Smaller", "Larger" } ;%@NL@%
     static HWND  hwndFrame, hwndButton[2] ;%@NL@%
     static SHORT cxClient, cyClient, cxChar, cyChar ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     HPS          hps ;%@NL@%
     SHORT        id ;%@NL@%
     RECTL        rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE :%@NL@%
               hwndFrame = WinQueryWindow (hwnd, QW_PARENT, FALSE) ;%@NL@%
%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               RegisterSqBtnClass (hab) ;%@NL@%
%@NL@%
               for (id = 0 ; id < 2 ; id++)%@NL@%
                    hwndButton[id] = WinCreateWindow (%@NL@%
                                        hwnd,               // Parent%@NL@%
                                        "SqBtn",            // Class%@NL@%
                                        szButtonLabel[id],  // Text%@NL@%
                                        WS_VISIBLE,         // Style%@NL@%
                                        0, 0,               // Position%@NL@%
                                        12 * cxChar,        // Width%@NL@%
                                        2 * cyChar,         // Height%@NL@%
                                        hwnd,               // Owner%@NL@%
                                        HWND_BOTTOM,        // Placement%@NL@%
                                        id,                 // ID%@NL@%
                                        NULL,               // Ctrl Data%@NL@%
                                        NULL) ;             // Pres Params%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE :%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               for (id = 0 ; id < 2 ; id++)%@NL@%
                    WinSetWindowPos (hwndButton[id], NULL,%@NL@%
                              cxClient / 2 + (14 * id - 13) * cxChar,%@NL@%
                              (cyClient - 2 * cyChar) / 2,%@NL@%
                              0, 0, SWP_MOVE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               WinMapWindowPoints (hwnd, HWND_DESKTOP, (PPOINTL) &rcl, 2) ;%@NL@%
%@NL@%
               switch (COMMANDMSG(&msg)->cmd)               // Child ID%@NL@%
                    {%@NL@%
                    case 0:                                 // "Smaller"%@NL@%
                         rcl.xLeft   += cxClient / 20 ;%@NL@%
                         rcl.xRight  -= cxClient / 20 ;%@NL@%
                         rcl.yBottom += cyClient / 20 ;%@NL@%
                         rcl.yTop    -= cyClient / 20 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case 1:                                 // "Larger"%@NL@%
                         rcl.xLeft   -= cxClient / 20 ;%@NL@%
                         rcl.xRight  += cxClient / 20 ;%@NL@%
                         rcl.yBottom -= cyClient / 20 ;%@NL@%
                         rcl.yTop    += cyClient / 20 ;%@NL@%
                         break ;%@NL@%
                    }%@NL@%
               WinCalcFrameRect (hwndFrame, &rcl, FALSE) ;%@NL@%
%@NL@%
               WinSetWindowPos (hwndFrame, NULL,%@NL@%
                                (SHORT) rcl.xLeft, (SHORT) rcl.yBottom,%@NL@%
                                (SHORT) rcl.xRight - (SHORT) rcl.xLeft,%@NL@%
                                (SHORT) rcl.yTop   - (SHORT) rcl.yBottom,%@NL@%
                                SWP_MOVE | SWP_SIZE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BUTTONS3.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP16\BUTTONS3.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------------%@NL@%
%@AB@%   BUTTONS3.C -- Square Button Demonstration with DLL%@NL@%
%@AB@%  ----------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"sqbtnlib.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "Buttons3" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR  szSqBtnClass [] = "SqBtn",%@NL@%
                  *szButtonLabel [] = { "Smaller", "Larger" } ;%@NL@%
     static HWND  hwndFrame, hwndButton [2] ;%@NL@%
     static SHORT cxClient, cyClient, cxChar, cyChar ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     HPS          hps ;%@NL@%
     SHORT        id ;%@NL@%
     RECTL        rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE :%@NL@%
               hwndFrame = WinQueryWindow (hwnd, QW_PARENT, FALSE) ;%@NL@%
%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               RegisterSqBtnClass (hab) ;%@NL@%
%@NL@%
               for (id = 0 ; id < 2 ; id++)%@NL@%
                    hwndButton [id] = WinCreateWindow (%@NL@%
                                        hwnd,               // Parent%@NL@%
                                        "SqBtn",            // Class%@NL@%
                                        szButtonLabel [id], // Text%@NL@%
                                        WS_VISIBLE,         // Style%@NL@%
                                        0, 0,               // Position%@NL@%
                                        12 * cxChar,        // Width%@NL@%
                                        2 * cyChar,         // Height%@NL@%
                                        hwnd,               // Owner%@NL@%
                                        HWND_BOTTOM,        // Placement%@NL@%
                                        id,                 // ID%@NL@%
                                        NULL,               // Ctrl Data%@NL@%
                                        NULL) ;             // Pres Params%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE :%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               for (id = 0 ; id < 2 ; id++)%@NL@%
                    WinSetWindowPos (hwndButton [id], NULL,%@NL@%
                              cxClient / 2 + (14 * id - 13) * cxChar,%@NL@%
                              (cyClient - 2 * cyChar) / 2,%@NL@%
                              0, 0, SWP_MOVE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               WinMapWindowPoints (hwnd, HWND_DESKTOP, (PPOINTL) &rcl, 2) ;%@NL@%
%@NL@%
               switch (COMMANDMSG(&msg)->cmd)               // Child ID%@NL@%
                    {%@NL@%
                    case 0:                                 // "Smaller"%@NL@%
                         rcl.xLeft   += cxClient / 20 ;%@NL@%
                         rcl.xRight  -= cxClient / 20 ;%@NL@%
                         rcl.yBottom += cyClient / 20 ;%@NL@%
                         rcl.yTop    -= cyClient / 20 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case 1:                                 // "Larger"%@NL@%
                         rcl.xLeft   -= cxClient / 20 ;%@NL@%
                         rcl.xRight  += cxClient / 20 ;%@NL@%
                         rcl.yBottom -= cyClient / 20 ;%@NL@%
                         rcl.yTop    += cyClient / 20 ;%@NL@%
                         break ;%@NL@%
                    }%@NL@%
               WinCalcFrameRect (hwndFrame, &rcl, FALSE) ;%@NL@%
%@NL@%
               WinSetWindowPos (hwndFrame, NULL,%@NL@%
                                (SHORT) rcl.xLeft, (SHORT) rcl.yBottom,%@NL@%
                                (SHORT) rcl.xRight - (SHORT) rcl.xLeft,%@NL@%
                                (SHORT) rcl.yTop   - (SHORT) rcl.yBottom,%@NL@%
                                SWP_MOVE | SWP_SIZE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CHECKER1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP09\CHECKER1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------%@NL@%
%@AB@%   CHECKER1.C -- Mouse Hit-Test Demo Program %@NL@%
%@AB@%  -------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%DIVISIONS 5 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Checker1" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID DrawLine (HPS hps, LONG x1, LONG y1, LONG x2, LONG y2)%@NL@%
     {%@NL@%
     POINTL ptl ;%@NL@%
%@NL@%
     ptl.x = x1 ;  ptl.y = y1 ;  GpiMove (hps, &ptl) ;%@NL@%
     ptl.x = x2 ;  ptl.y = y2 ;  GpiLine (hps, &ptl) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL  fBlockState [DIVISIONS] [DIVISIONS] ;%@NL@%
     static SHORT xBlock, yBlock ;%@NL@%
     HPS          hps ;%@NL@%
     RECTL        rcl ;%@NL@%
     SHORT        x, y ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               xBlock = SHORT1FROMMP (mp2) / DIVISIONS ;%@NL@%
               yBlock = SHORT2FROMMP (mp2) / DIVISIONS ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
          case WM_BUTTON1DBLCLK:%@NL@%
               if (xBlock > 0 && yBlock > 0)%@NL@%
                    {%@NL@%
                    x = MOUSEMSG(&msg)->x / xBlock ;%@NL@%
                    y = MOUSEMSG(&msg)->y / yBlock ;%@NL@%
%@NL@%
                    if (x < DIVISIONS && y < DIVISIONS)%@NL@%
                         {%@NL@%
                         fBlockState [x][y] = !fBlockState [x][y] ;%@NL@%
%@NL@%
                         rcl.xRight = xBlock + (rcl.xLeft   = x * xBlock) ;%@NL@%
                         rcl.yTop   = yBlock + (rcl.yBottom = y * yBlock) ;%@NL@%
%@NL@%
                         WinInvalidateRect (hwnd, &rcl, FALSE) ;%@NL@%
                         }%@NL@%
                    else%@NL@%
                         WinAlarm (HWND_DESKTOP, WA_WARNING) ;%@NL@%
                    }%@NL@%
               else%@NL@%
                    WinAlarm (HWND_DESKTOP, WA_WARNING) ;%@NL@%
%@NL@%
               break ;                       // do default processing%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               if (xBlock > 0 && yBlock > 0)%@NL@%
                    for (x = 0 ; x < DIVISIONS ; x++)%@NL@%
                         for (y = 0 ; y < DIVISIONS ; y++)%@NL@%
                              {%@NL@%
                              rcl.xRight = xBlock + (rcl.xLeft   = x * xBlock);%@NL@%
                              rcl.yTop   = yBlock + (rcl.yBottom = y * yBlock);%@NL@%
%@NL@%
                              WinDrawBorder (hps, &rcl, 1, 1,%@NL@%
                                             CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                                             DB_STANDARD | DB_INTERIOR) ;%@NL@%
%@NL@%
                              if (fBlockState [x][y])%@NL@%
                                   {%@NL@%
                                   DrawLine (hps, rcl.xLeft,  rcl.yBottom,%@NL@%
                                                  rcl.xRight, rcl.yTop) ;%@NL@%
%@NL@%
                                   DrawLine (hps, rcl.xLeft,  rcl.yTop,%@NL@%
                                                  rcl.xRight, rcl.yBottom) ;%@NL@%
                                   }%@NL@%
                              }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CHECKER2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP09\CHECKER2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------------------------------%@NL@%
%@AB@%   CHECKER2.C -- Mouse Hit-Test Demo Program with Keyboard Interface%@NL@%
%@AB@%  -------------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%DIVISIONS 5 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Checker2" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID DrawLine (HPS hps, LONG x1, LONG y1, LONG x2, LONG y2)%@NL@%
     {%@NL@%
     POINTL ptl ;%@NL@%
%@NL@%
     ptl.x = x1 ;  ptl.y = y1 ;  GpiMove (hps, &ptl) ;%@NL@%
     ptl.x = x2 ;  ptl.y = y2 ;  GpiLine (hps, &ptl) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL  fBlockState [DIVISIONS] [DIVISIONS] ;%@NL@%
     static SHORT xBlock, yBlock ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       ptl ;%@NL@%
     RECTL        rcl ;%@NL@%
     SHORT        x, y ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               xBlock = SHORT1FROMMP (mp2) / DIVISIONS ;%@NL@%
               yBlock = SHORT2FROMMP (mp2) / DIVISIONS ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
          case WM_BUTTON1DBLCLK:%@NL@%
               if (xBlock > 0 && yBlock > 0)%@NL@%
                    {%@NL@%
                    x = MOUSEMSG(&msg)->x / xBlock ;%@NL@%
                    y = MOUSEMSG(&msg)->y / yBlock ;%@NL@%
%@NL@%
                    if (x < DIVISIONS && y < DIVISIONS)%@NL@%
                         {%@NL@%
                         fBlockState [x][y] = !fBlockState [x][y] ;%@NL@%
%@NL@%
                         rcl.xRight = xBlock + (rcl.xLeft   = x * xBlock) ;%@NL@%
                         rcl.yTop   = yBlock + (rcl.yBottom = y * yBlock) ;%@NL@%
%@NL@%
                         WinInvalidateRect (hwnd, &rcl, FALSE) ;%@NL@%
                         }%@NL@%
                    else%@NL@%
                         WinAlarm (HWND_DESKTOP, WA_WARNING) ;%@NL@%
                    }%@NL@%
               else%@NL@%
                    WinAlarm (HWND_DESKTOP, WA_WARNING) ;%@NL@%
%@NL@%
               break ;                       // do default processing%@NL@%
%@NL@%
          case WM_SETFOCUS:%@NL@%
               if (WinQuerySysValue (HWND_DESKTOP, SV_MOUSEPRESENT) == 0)%@NL@%
                    WinShowPointer (HWND_DESKTOP,%@NL@%
                                    SHORT1FROMMP (mp2) ? TRUE : FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               if (xBlock == 0 || yBlock == 0)%@NL@%
                    break ;%@NL@%
%@NL@%
               if (CHARMSG(&msg)->fs & KC_KEYUP)%@NL@%
                    break ;%@NL@%
%@NL@%
               if (!(CHARMSG(&msg)->fs & KC_VIRTUALKEY))%@NL@%
                    break ;%@NL@%
%@NL@%
               WinQueryPointerPos (HWND_DESKTOP, &ptl) ;%@NL@%
               WinMapWindowPoints (HWND_DESKTOP, hwnd, &ptl, 1) ;%@NL@%
%@NL@%
               x = max (0, min (DIVISIONS - 1, (SHORT) ptl.x / xBlock)) ;%@NL@%
               y = max (0, min (DIVISIONS - 1, (SHORT) ptl.y / yBlock)) ;%@NL@%
%@NL@%
               switch (CHARMSG(&msg)->vkey)%@NL@%
                    {%@NL@%
                    case VK_LEFT:%@NL@%
                         x-- ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case VK_RIGHT:%@NL@%
                         x++ ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case VK_DOWN:%@NL@%
                         y-- ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case VK_UP:%@NL@%
                         y++ ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case VK_HOME:%@NL@%
                         x = 0 ;%@NL@%
                         y = DIVISIONS - 1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case VK_END:%@NL@%
                         x = DIVISIONS - 1 ;%@NL@%
                         y = 0 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case VK_NEWLINE:%@NL@%
                    case VK_ENTER:%@NL@%
                    case VK_SPACE:%@NL@%
                         WinSendMsg (hwnd, WM_BUTTON1DOWN, %@NL@%
                              MPFROM2SHORT (x * xBlock, y * yBlock), NULL) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    default:%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               x = (x + DIVISIONS) % DIVISIONS ;%@NL@%
               y = (y + DIVISIONS) % DIVISIONS ;%@NL@%
%@NL@%
               ptl.x = x * xBlock + xBlock / 2 ;%@NL@%
               ptl.y = y * yBlock + yBlock / 2 ;%@NL@%
%@NL@%
               WinMapWindowPoints (hwnd, HWND_DESKTOP, &ptl, 1) ;%@NL@%
               WinSetPointerPos (HWND_DESKTOP, (SHORT) ptl.x, (SHORT) ptl.y) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               if (xBlock > 0 && yBlock > 0)%@NL@%
                    for (x = 0 ; x < DIVISIONS ; x++)%@NL@%
                         for (y = 0 ; y < DIVISIONS ; y++)%@NL@%
                              {%@NL@%
                              rcl.xRight = xBlock + (rcl.xLeft   = x * xBlock);%@NL@%
                              rcl.yTop   = yBlock + (rcl.yBottom = y * yBlock);%@NL@%
%@NL@%
                              WinDrawBorder (hps, &rcl, 1, 1,%@NL@%
                                             CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                                             DB_STANDARD | DB_INTERIOR) ;%@NL@%
%@NL@%
                              if (fBlockState [x][y])%@NL@%
                                   {%@NL@%
                                   DrawLine (hps, rcl.xLeft,  rcl.yBottom,%@NL@%
                                                  rcl.xRight, rcl.yTop) ;%@NL@%
%@NL@%
                                   DrawLine (hps, rcl.xLeft,  rcl.yTop,%@NL@%
                                                  rcl.xRight, rcl.yBottom) ;%@NL@%
                                   }%@NL@%
                              }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CHECKER3.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP09\CHECKER3.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------------------%@NL@%
%@AB@%   CHECKER3.C -- Mouse Hit-Test Demo Program with Child Windows%@NL@%
%@AB@%  --------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%DIVISIONS 5 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT EXPENTRY ChildWndProc  (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Checker3" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID DrawLine (HPS hps, LONG x1, LONG y1, LONG x2, LONG y2)%@NL@%
     {%@NL@%
     POINTL ptl ;%@NL@%
%@NL@%
     ptl.x = x1 ;  ptl.y = y1 ;  GpiMove (hps, &ptl) ;%@NL@%
     ptl.x = x2 ;  ptl.y = y2 ;  GpiLine (hps, &ptl) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR szChildClass [] = "Checker3.Child" ;%@NL@%
     static HWND hwndChild [DIVISIONS][DIVISIONS] ;%@NL@%
     SHORT       xBlock, yBlock, x, y ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               WinRegisterClass (hab, szChildClass, ChildWndProc,%@NL@%
                                 CS_SIZEREDRAW, sizeof (USHORT)) ;%@NL@%
%@NL@%
               for (x = 0 ; x < DIVISIONS ; x++)%@NL@%
                    for (y = 0 ; y < DIVISIONS ; y++)%@NL@%
%@NL@%
                         hwndChild [x][y] =%@NL@%
                              WinCreateWindow (%@NL@%
                                        hwnd,          // Parent window%@NL@%
                                        szChildClass,  // Window class%@NL@%
                                        NULL,          // Window text%@NL@%
                                        WS_VISIBLE,    // Window style%@NL@%
                                        0, 0, 0, 0,    // Position & size%@NL@%
                                        hwnd,          // Owner window%@NL@%
                                        HWND_BOTTOM,   // Placement%@NL@%
                                        y << 8 | x,    // Child window ID%@NL@%
                                        NULL,          // Control data%@NL@%
                                        NULL) ;        // Pres. Params%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               xBlock = SHORT1FROMMP (mp2) / DIVISIONS ;%@NL@%
               yBlock = SHORT2FROMMP (mp2) / DIVISIONS ;%@NL@%
%@NL@%
               for (x = 0 ; x < DIVISIONS ; x++)%@NL@%
                    for (y = 0 ; y < DIVISIONS ; y++)%@NL@%
%@NL@%
                         WinSetWindowPos (hwndChild [x][y], NULL,%@NL@%
                              x * xBlock, y * yBlock, xBlock, yBlock,%@NL@%
                              SWP_MOVE | SWP_SIZE) ;      %@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
          case WM_BUTTON1DBLCLK:%@NL@%
               WinAlarm (HWND_DESKTOP, WA_WARNING) ;%@NL@%
               break ;                       // do default processing%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ChildWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     HPS   hps ;%@NL@%
     RECTL rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               WinSetWindowUShort (hwnd, 0, 0) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
          case WM_BUTTON1DBLCLK:%@NL@%
               WinSetActiveWindow (HWND_DESKTOP, hwnd) ;%@NL@%
               WinSetWindowUShort (hwnd, 0, !WinQueryWindowUShort (hwnd, 0)) ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
               WinDrawBorder (hps, &rcl, 1, 1, CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                                   DB_STANDARD | DB_INTERIOR) ;%@NL@%
%@NL@%
               if (WinQueryWindowUShort (hwnd, 0))%@NL@%
                    {%@NL@%
                    DrawLine (hps, rcl.xLeft,  rcl.yBottom,%@NL@%
                                   rcl.xRight, rcl.yTop) ;%@NL@%
                    DrawLine (hps, rcl.xLeft,  rcl.yTop,%@NL@%
                                   rcl.xRight, rcl.yBottom) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CLOCK.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP10\CLOCK.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------%@NL@%
%@AB@%   CLOCK.C -- Analog Clock %@NL@%
%@AB@%  -------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%ID_TIMER 1 %@NL@%
%@NL@%
typedef struct%@NL@%
     {%@NL@%
     SHORT cxClient ;%@NL@%
     SHORT cyClient ;%@NL@%
     SHORT cxPixelDiam ;%@NL@%
     SHORT cyPixelDiam ;%@NL@%
     }%@NL@%
     WINDOWINFO ;%@NL@%
%@NL@%
typedef WINDOWINFO *PWINDOWINFO ;%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "Clock" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     if (WinStartTimer (hab, hwndClient, ID_TIMER, 1000))%@NL@%
          {%@NL@%
          while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
               WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
          WinStopTimer (hab, hwndClient, ID_TIMER) ;%@NL@%
          }%@NL@%
     else%@NL@%
          WinMessageBox (HWND_DESKTOP, hwndClient,%@NL@%
                         "Too many clocks or timers",%@NL@%
                         szClientClass, 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID RotatePoint (POINTL aptl[], SHORT sNum, SHORT sAngle)%@NL@%
     {%@NL@%
     static SHORT sSin [60] =%@NL@%
                    {%@NL@%
                       0,  105,  208,  309,  407,  500,  588,  669,  743,  809,%@NL@%
                     866,  914,  951,  978,  995, 1000,  995,  978,  951,  914,%@NL@%
                     866,  809,  743,  669,  588,  500,  407,  309,  208,  105,%@NL@%
                       0, -104, -207, -308, -406, -499, -587, -668, -742, -808,%@NL@%
                    -865, -913, -950, -977, -994, -999, -994, -977, -950, -913,%@NL@%
                    -865, -808, -742, -668, -587, -499, -406, -308, -207, -104%@NL@%
                    } ;%@NL@%
     POINTL       ptlTemp ;%@NL@%
     SHORT        sIndex ;%@NL@%
%@NL@%
     for (sIndex = 0 ; sIndex < sNum ; sIndex++)%@NL@%
          {%@NL@%
          ptlTemp.x = (aptl[sIndex].x * sSin [(sAngle + 15) % 60] +%@NL@%
                       aptl[sIndex].y * sSin [sAngle]) / 1000 ;%@NL@%
%@NL@%
          ptlTemp.y = (aptl[sIndex].y * sSin [(sAngle + 15) % 60] -%@NL@%
                       aptl[sIndex].x * sSin [sAngle]) / 1000 ;%@NL@%
%@NL@%
          aptl[sIndex] = ptlTemp ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
VOID ScalePoint (POINTL aptl[], SHORT sNum, PWINDOWINFO pwi)%@NL@%
     {%@NL@%
     SHORT sIndex ;%@NL@%
%@NL@%
     for (sIndex = 0 ; sIndex < sNum ; sIndex++)%@NL@%
          {%@NL@%
          aptl[sIndex].x = aptl[sIndex].x * pwi->cxPixelDiam / 200 ;%@NL@%
          aptl[sIndex].y = aptl[sIndex].y * pwi->cyPixelDiam / 200 ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
VOID TranslatePoint (POINTL aptl[], SHORT sNum, PWINDOWINFO pwi)%@NL@%
     {%@NL@%
     SHORT sIndex ;%@NL@%
%@NL@%
     for (sIndex = 0 ; sIndex < sNum ; sIndex++)%@NL@%
          {%@NL@%
          aptl[sIndex].x += pwi->cxClient / 2 ;%@NL@%
          aptl[sIndex].y += pwi->cyClient / 2 ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
VOID DrawHand (HPS hps, POINTL aptlIn[], SHORT sNum, SHORT sAngle,%@NL@%
               PWINDOWINFO pwi)%@NL@%
     {%@NL@%
     POINTL aptl [5] ;%@NL@%
     SHORT  sIndex ;%@NL@%
%@NL@%
     for (sIndex = 0 ; sIndex < sNum ; sIndex++)%@NL@%
          aptl [sIndex] = aptlIn [sIndex] ;%@NL@%
%@NL@%
     RotatePoint    (aptl, sNum, sAngle) ;%@NL@%
     ScalePoint     (aptl, sNum, pwi) ;%@NL@%
     TranslatePoint (aptl, sNum, pwi) ;%@NL@%
%@NL@%
     GpiMove (hps, aptl) ;%@NL@%
     GpiPolyLine (hps, sNum - 1L, aptl + 1) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static DATETIME   dtPrevious ;%@NL@%
     static HDC        hdc ;%@NL@%
     static LONG       xPixelsPerMeter, yPixelsPerMeter ;%@NL@%
     static POINTL     aptlHour   [5] = { 0,-15, 10,0, 0,60, -10,0, 0,-15 },%@NL@%
                       aptlMinute [5] = { 0,-20,  5,0, 0,80,  -5,0, 0,-20 },%@NL@%
                       aptlSecond [2] = { 0,  0,  0,80 } ;%@NL@%
     static WINDOWINFO wi ;%@NL@%
     DATETIME          dt ;%@NL@%
     HPS               hps ;%@NL@%
     POINTL            aptl [3] ;%@NL@%
     SHORT             sDiamMM, sAngle ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hdc = WinOpenWindowDC (hwnd) ;%@NL@%
%@NL@%
               DevQueryCaps (hdc, CAPS_VERTICAL_RESOLUTION,%@NL@%
                                  1L, &yPixelsPerMeter) ;%@NL@%
               DevQueryCaps (hdc, CAPS_HORIZONTAL_RESOLUTION,%@NL@%
                                  1L, &xPixelsPerMeter) ;%@NL@%
%@NL@%
               DosGetDateTime (&dtPrevious) ;%@NL@%
               dtPrevious.hours = (dtPrevious.hours * 5) % 60 +%@NL@%
                                   dtPrevious.minutes / 12 ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               wi.cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               wi.cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               sDiamMM = (SHORT) min (wi.cxClient * 1000L / xPixelsPerMeter,%@NL@%
                                      wi.cyClient * 1000L / yPixelsPerMeter) ;%@NL@%
%@NL@%
               wi.cxPixelDiam = (SHORT) (xPixelsPerMeter * sDiamMM / 1000) ;%@NL@%
               wi.cyPixelDiam = (SHORT) (yPixelsPerMeter * sDiamMM / 1000) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_TIMER:%@NL@%
               DosGetDateTime (&dt) ;%@NL@%
               dt.hours = (dt.hours * 5) % 60 + dt.minutes / 12 ;%@NL@%
%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiSetColor (hps, CLR_BACKGROUND) ;%@NL@%
%@NL@%
               DrawHand (hps, aptlSecond, 2, dtPrevious.seconds, &wi) ;%@NL@%
%@NL@%
               if (dt.hours   != dtPrevious.hours ||%@NL@%
                   dt.minutes != dtPrevious.minutes)%@NL@%
                    {%@NL@%
                    DrawHand (hps, aptlHour,   5, dtPrevious.hours,   &wi) ;%@NL@%
                    DrawHand (hps, aptlMinute, 5, dtPrevious.minutes, &wi) ;%@NL@%
                    }%@NL@%
%@NL@%
               GpiSetColor (hps, CLR_NEUTRAL) ;%@NL@%
%@NL@%
               DrawHand (hps, aptlHour,   5, dt.hours,   &wi) ;%@NL@%
               DrawHand (hps, aptlMinute, 5, dt.minutes, &wi) ;%@NL@%
               DrawHand (hps, aptlSecond, 2, dt.seconds, &wi) ;%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
               dtPrevious = dt ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               for (sAngle = 0 ; sAngle < 60 ; sAngle++)%@NL@%
                    {%@NL@%
                    aptl[0].x = 0 ;%@NL@%
                    aptl[0].y = 90 ;%@NL@%
%@NL@%
                    RotatePoint    (aptl, 1, sAngle) ;%@NL@%
                    ScalePoint     (aptl, 1, &wi) ;%@NL@%
                    TranslatePoint (aptl, 1, &wi) ;%@NL@%
%@NL@%
                    aptl[2].x = aptl[2].y = sAngle % 5 ? 2 : 10 ;%@NL@%
%@NL@%
                    ScalePoint (aptl + 2, 1, &wi) ;%@NL@%
%@NL@%
                    aptl[0].x -= aptl[2].x / 2 ;%@NL@%
                    aptl[0].y -= aptl[2].y / 2 ;%@NL@%
%@NL@%
                    aptl[1].x = aptl[0].x + aptl[2].x ;%@NL@%
                    aptl[1].y = aptl[0].y + aptl[2].y ;%@NL@%
%@NL@%
                    GpiMove (hps, aptl) ;%@NL@%
                    GpiBox (hps, DRO_OUTLINEFILL, aptl + 1,%@NL@%
                                 aptl[2].x, aptl[2].y) ;%@NL@%
                    }%@NL@%
               DrawHand (hps, aptlHour,   5, dtPrevious.hours,   &wi) ;%@NL@%
               DrawHand (hps, aptlMinute, 5, dtPrevious.minutes, &wi) ;%@NL@%
               DrawHand (hps, aptlSecond, 2, dtPrevious.seconds, &wi) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%COLORS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\COLORS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------%@NL@%
%@AB@%   COLORS.C -- GPI Foreground Colors%@NL@%
%@AB@%  -----------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Colors" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static struct {%@NL@%
                   LONG lColorIndex ;%@NL@%
                   CHAR *szColorIndex ;%@NL@%
                   }%@NL@%
                   show [] = %@NL@%
                   {%@NL@%
                   CLR_FALSE      , "CLR_FALSE"      , %@NL@%
                   CLR_TRUE       , "CLR_TRUE"       , %@NL@%
                   CLR_DEFAULT    , "CLR_DEFAULT"    , %@NL@%
                   CLR_WHITE      , "CLR_WHITE"      , %@NL@%
                   CLR_BLACK      , "CLR_BLACK"      , %@NL@%
                   CLR_BACKGROUND , "CLR_BACKGROUND" , %@NL@%
                   CLR_BLUE       , "CLR_BLUE"       , %@NL@%
                   CLR_RED        , "CLR_RED"        , %@NL@%
                   CLR_PINK       , "CLR_PINK"       , %@NL@%
                   CLR_GREEN      , "CLR_GREEN"      , %@NL@%
                   CLR_CYAN       , "CLR_CYAN"       , %@NL@%
                   CLR_YELLOW     , "CLR_YELLOW"     , %@NL@%
                   CLR_NEUTRAL    , "CLR_NEUTRAL"    , %@NL@%
                   CLR_DARKGRAY   , "CLR_DARKGRAY"   , %@NL@%
                   CLR_DARKBLUE   , "CLR_DARKBLUE"   ,%@NL@%
                   CLR_DARKRED    , "CLR_DARKRED"    ,%@NL@%
                   CLR_DARKPINK   , "CLR_DARKPINK"   ,%@NL@%
                   CLR_DARKGREEN  , "CLR_DARKGREEN"  , %@NL@%
                   CLR_DARKCYAN   , "CLR_DARKCYAN"   , %@NL@%
                   CLR_BROWN      , "CLR_BROWN"      , %@NL@%
                   CLR_PALEGRAY   , "CLR_PALEGRAY"%@NL@%
                   } ;%@NL@%
     static SHORT  cxClient, cyClient, cxCaps, cyChar, cyDesc,%@NL@%
                   sNumColors = sizeof show / sizeof show[0] ;%@NL@%
     FONTMETRICS   fm ;%@NL@%
     HPS           hps ;%@NL@%
     POINTL        ptl ;%@NL@%
     SHORT         sIndex ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxCaps = (SHORT) fm.lEmInc ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               for (sIndex = 0 ; sIndex < sNumColors ; sIndex ++)%@NL@%
                    {%@NL@%
                    ptl.x = (sIndex < 11 ? 1 : 33) * cxCaps ;%@NL@%
                    ptl.y = cyClient - (sIndex % 11 * 5 + 4) * cyChar / 2%@NL@%
                                                       + cyDesc ;%@NL@%
%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                          (LONG) strlen (show [sIndex].szColorIndex),%@NL@%
                               show [sIndex].szColorIndex) ;%@NL@%
%@NL@%
                    ptl.x = (sIndex < 11 ? 20 : 52) * cxCaps ;%@NL@%
                           ptl.y -= cyDesc + cyChar / 2 ;%@NL@%
                    GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
                    GpiSavePS (hps) ;%@NL@%
                    GpiSetColor (hps, show [sIndex].lColorIndex) ;%@NL@%
%@NL@%
                    ptl.x += 10 * cxCaps ;%@NL@%
                    ptl.y += 2 * cyChar ;%@NL@%
                    GpiBox (hps, DRO_FILL, &ptl, 0L, 0L) ;%@NL@%
%@NL@%
                    GpiRestorePS (hps, -1L) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%COLORSCR.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP11\COLORSCR.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------------%@NL@%
%@AB@%   COLORSCR.C -- Color Scroll using child window controls%@NL@%
%@AB@%  --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT EXPENTRY ScrollProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HWND  hwndScroll[3], hwndFocus ;%@NL@%
PFNWP pfnOldScroll[3] ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "ColorScr" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSetFocus (HWND_DESKTOP, hwndFocus = hwndScroll[0]) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR  *szColorLabel[] = { "Red", "Green", "Blue" } ;%@NL@%
     static HWND  hwndLabel[3], hwndValue[3] ;%@NL@%
     static SHORT cyChar, sColor[3] ;%@NL@%
     static RECTL rclRightHalf ;%@NL@%
     CHAR         szBuffer[10] ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     HPS          hps ;%@NL@%
     SHORT        s, id, cxClient, cyClient ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE :%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               for (s = 0 ; s < 3 ; s++)%@NL@%
                    {%@NL@%
                    hwndScroll[s] = WinCreateWindow (%@NL@%
                                        hwnd,               // Parent%@NL@%
                                        WC_SCROLLBAR,       // Class%@NL@%
                                        NULL,               // Text%@NL@%
                                        WS_VISIBLE |        // Style%@NL@%
                                             SBS_VERT,%@NL@%
                                        0, 0,               // Position%@NL@%
                                        0, 0,               // Size%@NL@%
                                        hwnd,               // Owner%@NL@%
                                        HWND_BOTTOM,        // Placement%@NL@%
                                        s,                  // ID%@NL@%
                                        NULL,               // Ctrl Data%@NL@%
                                        NULL) ;             // Pres Params%@NL@%
%@NL@%
                    hwndLabel[s]  = WinCreateWindow (%@NL@%
                                        hwnd,               // Parent%@NL@%
                                        WC_STATIC,          // Class%@NL@%
                                        szColorLabel[s],    // Text%@NL@%
                                        WS_VISIBLE |        // Style%@NL@%
                                          SS_TEXT | DT_CENTER,%@NL@%
                                        0, 0,               // Position%@NL@%
                                        0, 0,               // Size%@NL@%
                                        hwnd,               // Owner%@NL@%
                                        HWND_BOTTOM,        // Placement%@NL@%
                                        s + 3,              // ID%@NL@%
                                        NULL,               // Ctrl Data%@NL@%
                                        NULL) ;             // Pres Params%@NL@%
%@NL@%
                    hwndValue[s]  = WinCreateWindow (%@NL@%
                                        hwnd,               // Parent%@NL@%
                                        WC_STATIC,          // Class%@NL@%
                                        "0",                // Text%@NL@%
                                        WS_VISIBLE |        // Style%@NL@%
                                          SS_TEXT | DT_CENTER,%@NL@%
                                        0, 0,               // Position%@NL@%
                                        0, 0,               // Size%@NL@%
                                        hwnd,               // Owner%@NL@%
                                        HWND_BOTTOM,        // Placement%@NL@%
                                        s + 6,              // ID%@NL@%
                                        NULL,               // Ctrl Data%@NL@%
                                        NULL) ;             // Pres Params%@NL@%
%@NL@%
                    pfnOldScroll[s] =%@NL@%
                              WinSubclassWindow (hwndScroll[s], ScrollProc) ;%@NL@%
%@NL@%
                    WinSendMsg (hwndScroll[s], SBM_SETSCROLLBAR,%@NL@%
                                MPFROM2SHORT (0, 0), MPFROM2SHORT (0, 255)) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE :%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               for (s = 0 ; s < 3 ; s++)%@NL@%
                    {%@NL@%
                    WinSetWindowPos (hwndScroll[s], NULL,%@NL@%
                                     (2 * s + 1) * cxClient / 14, 2 * cyChar,%@NL@%
                                     cxClient / 14, cyClient - 4 * cyChar,%@NL@%
                                     SWP_SIZE | SWP_MOVE) ;%@NL@%
%@NL@%
                    WinSetWindowPos (hwndLabel[s], NULL,%@NL@%
                                     (4 * s + 1) * cxClient / 28,%@NL@%
                                     cyClient - 3 * cyChar / 2,%@NL@%
                                     cxClient / 7, cyChar,%@NL@%
                                     SWP_SIZE | SWP_MOVE) ;%@NL@%
%@NL@%
                    WinSetWindowPos (hwndValue[s], NULL,%@NL@%
                                     (4 * s + 1) * cxClient / 28, cyChar / 2,%@NL@%
                                     cxClient / 7, cyChar,%@NL@%
                                     SWP_SIZE | SWP_MOVE) ;%@NL@%
                    }%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rclRightHalf) ;%@NL@%
               rclRightHalf.xLeft = rclRightHalf.xRight / 2 ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_VSCROLL :%@NL@%
               id = SHORT1FROMMP (mp1) ;          // ID of scroll bar%@NL@%
%@NL@%
               switch (SHORT2FROMMP (mp2))%@NL@%
                    {%@NL@%
                    case SB_LINEDOWN :%@NL@%
                         sColor[id] = min (255, sColor[id] + 1) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_LINEUP :%@NL@%
                         sColor[id] = max (0, sColor[id] - 1) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEDOWN :%@NL@%
                         sColor[id] = min (255, sColor[id] + 16) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEUP :%@NL@%
                         sColor[id] = max (0, sColor[id] - 16) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_SLIDERTRACK :%@NL@%
                         sColor[id] = SHORT1FROMMP (mp2) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    default :%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               WinSendMsg (hwndScroll[id], SBM_SETPOS,%@NL@%
                           MPFROM2SHORT (sColor[id], 0), NULL) ;%@NL@%
%@NL@%
               WinSetWindowText (hwndValue[id],%@NL@%
                                 itoa (sColor[id], szBuffer, 10)) ;%@NL@%
               WinInvalidateRect (hwnd, &rclRightHalf, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               GpiCreateLogColorTable (hps, LCOL_RESET, LCOLF_RGB,%@NL@%
                                            0L, 0L, NULL) ;%@NL@%
%@NL@%
               WinFillRect (hps, &rclRightHalf, (ULONG) sColor[0] << 16 |%@NL@%
                                                (ULONG) sColor[1] <<  8 |%@NL@%
                                                (ULONG) sColor[2]) ;%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ScrollProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     USHORT id ;%@NL@%
%@NL@%
     id = WinQueryWindowUShort (hwnd, QWS_ID) ;   // ID of scroll bar%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CHAR:%@NL@%
               if (!(CHARMSG(&msg)->fs & KC_VIRTUALKEY))%@NL@%
                    break ;%@NL@%
%@NL@%
               switch (CHARMSG(&msg)->vkey)%@NL@%
                    {%@NL@%
                    case VK_TAB:%@NL@%
                         if (!(CHARMSG(&msg)->fs & KC_KEYUP))%@NL@%
                              {%@NL@%
                              hwndFocus = hwndScroll[(id + 1) % 3] ;%@NL@%
                              WinSetFocus (HWND_DESKTOP, hwndFocus) ;%@NL@%
                              }%@NL@%
                         return 1 ;%@NL@%
%@NL@%
                    case VK_BACKTAB:%@NL@%
                         if (!(CHARMSG(&msg)->fs & KC_KEYUP))%@NL@%
                              {%@NL@%
                              hwndFocus = hwndScroll[(id + 2) % 3] ;%@NL@%
                              WinSetFocus (HWND_DESKTOP, hwndFocus) ;%@NL@%
                              }%@NL@%
                         return 1 ;%@NL@%
%@NL@%
                    default:%@NL@%
                         break ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               WinSetFocus (HWND_DESKTOP, hwndFocus = hwnd) ;%@NL@%
               break ;%@NL@%
          }%@NL@%
     return pfnOldScroll[id] (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CONVMENU.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP13\CONVMENU.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------%@NL@%
%@AB@%   CONVMENU.C -- Conventional Menu Use%@NL@%
%@AB@%  -------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"convmenu.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%ID_TIMER    1 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
CHAR szClientClass[] = "ConvMenu" ;%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU          | FCF_ACCELTABLE ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (TRUE)%@NL@%
          {%@NL@%
          while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
               WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
          if (MBID_OK == WinMessageBox (HWND_DESKTOP, hwndClient,%@NL@%
                                        "Really want to end program?",%@NL@%
                                        szClientClass, 0,%@NL@%
                                        MB_OKCANCEL | MB_ICONQUESTION))%@NL@%
               break ;%@NL@%
%@NL@%
          WinCancelShutdown (hmq, FALSE) ;%@NL@%
          }%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL  fTimerGoing = FALSE ;%@NL@%
     static COLOR colBackground [] = {%@NL@%
                                     0xFFFFFFL, 0xC0C0C0L, 0x808080L,%@NL@%
                                     0x404040L, 0x000000L%@NL@%
                                     } ;%@NL@%
     static HWND  hwndMenu ;%@NL@%
     static SHORT sCurrentBackground = IDM_WHITE ;%@NL@%
     HPS          hps ;%@NL@%
     RECTL        rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hwndMenu = WinWindowFromID (%@NL@%
                              WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                              FID_MENU) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_INITMENU:%@NL@%
               switch (SHORT1FROMMP (mp1))%@NL@%
                    {%@NL@%
                    case IDM_TIMER:%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                   MPFROM2SHORT (IDM_START, TRUE),%@NL@%
                                   MPFROM2SHORT (MIA_DISABLED, %@NL@%
                                             !fTimerGoing &&%@NL@%
                              WinQuerySysValue (HWND_DESKTOP, SV_CTIMERS) ?%@NL@%
                                             0 : MIA_DISABLED)) ;%@NL@%
%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                   MPFROM2SHORT (IDM_STOP, TRUE),%@NL@%
                                   MPFROM2SHORT (MIA_DISABLED,%@NL@%
                                        fTimerGoing ? 0 : MIA_DISABLED)) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_NEW:%@NL@%
                         WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                                   "Bogus \"New\" Dialog",%@NL@%
                                   szClientClass, 0, MB_OK | MB_ICONASTERISK) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_OPEN:%@NL@%
                         WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                                   "Bogus \"Open\" Dialog",%@NL@%
                                   szClientClass, 0, MB_OK | MB_ICONASTERISK) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_SAVE:%@NL@%
                         WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                                   "Bogus \"Save\" Dialog",%@NL@%
                                   szClientClass, 0, MB_OK | MB_ICONASTERISK) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_SAVEAS:%@NL@%
                         WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                                   "Bogus \"Save As\" Dialog",%@NL@%
                                   szClientClass, 0, MB_OK | MB_ICONASTERISK) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_EXIT:%@NL@%
                         WinSendMsg (hwnd, WM_CLOSE, 0L, 0L) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ABOUT:%@NL@%
                         WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                                   "Bogus \"About\" Dialog",%@NL@%
                                   szClientClass, 0, MB_OK | MB_ICONASTERISK) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_START:%@NL@%
                         if (WinStartTimer (hab, hwnd, ID_TIMER, 1000))%@NL@%
                              fTimerGoing = TRUE ;%@NL@%
                         else%@NL@%
                              WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                                   "Too many clocks or timers",%@NL@%
                                   szClientClass, 0,%@NL@%
                                   MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_STOP:%@NL@%
                         WinStopTimer (hab, hwnd, ID_TIMER) ;%@NL@%
                         fTimerGoing = FALSE ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_WHITE:%@NL@%
                    case IDM_LTGRAY:%@NL@%
                    case IDM_GRAY:%@NL@%
                    case IDM_DKGRAY:%@NL@%
                    case IDM_BLACK:%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (sCurrentBackground, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_CHECKED, 0)) ;%@NL@%
%@NL@%
                         sCurrentBackground = COMMANDMSG(&msg)->cmd ;%@NL@%
%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (sCurrentBackground, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_CHECKED, MIA_CHECKED)) ;%@NL@%
%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_HELP:%@NL@%
               WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                              "Help not yet implemented",%@NL@%
                              szClientClass, 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_TIMER:%@NL@%
               WinAlarm (HWND_DESKTOP, WA_NOTE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiSavePS (hps) ;%@NL@%
%@NL@%
               GpiCreateLogColorTable (hps, 0L, LCOLF_RGB, 0L, 0L, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
               WinFillRect (hps, &rcl,%@NL@%
                            colBackground [sCurrentBackground - IDM_WHITE]) ;%@NL@%
%@NL@%
               GpiRestorePS (hps, -1L) ;%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               if (fTimerGoing)%@NL@%
                    {%@NL@%
                    WinStopTimer (hab, hwnd, ID_TIMER) ;%@NL@%
                    fTimerGoing = FALSE ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DEVCAPS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\DEVCAPS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------%@NL@%
%@AB@%   DEVCAPS.C -- Device Capabilities Display Program%@NL@%
%@AB@%  --------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"devcaps.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "DevCaps" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
LONG RtJustCharStringAt (HPS hps, POINTL *pptl, LONG lLength, CHAR *pchText)%@NL@%
     {%@NL@%
     POINTL aptlTextBox[TXTBOX_COUNT] ;%@NL@%
%@NL@%
     GpiQueryTextBox (hps, lLength, pchText, TXTBOX_COUNT, aptlTextBox) ;%@NL@%
%@NL@%
     pptl->x -= aptlTextBox[TXTBOX_CONCAT].x ;%@NL@%
%@NL@%
     return GpiCharStringAt (hps, pptl, lLength, pchText) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static HDC   hdc ;%@NL@%
     static SHORT cxClient, cyClient, cxCaps, cyChar, cyDesc ;%@NL@%
     CHAR         szBuffer [12] ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     LONG         lValue ;%@NL@%
     POINTL       ptl ;%@NL@%
     HPS          hps ;%@NL@%
     SHORT        sLine ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxCaps = (SHORT) fm.lEmInc ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               hdc = WinOpenWindowDC (hwnd) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               for (sLine = 0 ; sLine < NUMLINES ; sLine++)%@NL@%
                    {%@NL@%
                    ptl.x = cxCaps ;%@NL@%
                    ptl.y = cyClient - cyChar * (sLine + 2) + cyDesc ;%@NL@%
%@NL@%
                    if (sLine >= (NUMLINES + 1) / 2)%@NL@%
                         {%@NL@%
                         ptl.x += cxCaps * 35 ;%@NL@%
                         ptl.y += cyChar * (NUMLINES + 1) / 2 ;%@NL@%
                         }%@NL@%
%@NL@%
                    DevQueryCaps (hdc, devcaps[sLine].lIndex, 1L, &lValue) ;%@NL@%
%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                              (LONG) strlen (devcaps[sLine].szIdentifier),%@NL@%
                              devcaps[sLine].szIdentifier) ;%@NL@%
%@NL@%
                    ptl.x += 33 * cxCaps ;%@NL@%
                    RtJustCharStringAt (hps, &ptl,%@NL@%
                              (LONG) strlen (ltoa (lValue, szBuffer, 10)),%@NL@%
                              szBuffer) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DIGCLOCK.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP10\DIGCLOCK.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------%@NL@%
%@AB@%   DIGCLOCK.C -- Digital Clock %@NL@%
%@AB@%  -----------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#define %@AE@%INCL_DOS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%ID_TIMER 1 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
VOID    SizeTheWindow (HWND) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "DigClock" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR | FCF_SYSMENU  |%@NL@%
                                 FCF_BORDER   | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
     SizeTheWindow (hwndFrame) ;%@NL@%
%@NL@%
     if (WinStartTimer (hab, hwndClient, ID_TIMER, 1000))%@NL@%
          {%@NL@%
          while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
               WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
          WinStopTimer (hab, hwndClient, ID_TIMER) ;%@NL@%
          }%@NL@%
     else%@NL@%
          WinMessageBox (HWND_DESKTOP, hwndClient,%@NL@%
                         "Too many clocks or timers",%@NL@%
                         szClientClass, 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID SizeTheWindow (HWND hwndFrame)%@NL@%
     {%@NL@%
     FONTMETRICS fm ;%@NL@%
     HPS         hps ;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
     hps = WinGetPS (hwndFrame) ;%@NL@%
     GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
     WinReleasePS (hps) ;%@NL@%
%@NL@%
     rcl.yBottom = 0 ;%@NL@%
     rcl.yTop    = 11 * fm.lMaxBaselineExt / 4 ;%@NL@%
     rcl.xRight  = WinQuerySysValue (HWND_DESKTOP, SV_CXSCREEN) ;%@NL@%
     rcl.xLeft   = rcl.xRight - 16 * fm.lEmInc ;%@NL@%
%@NL@%
     WinCalcFrameRect (hwndFrame, &rcl, FALSE) ;%@NL@%
%@NL@%
     WinSetWindowPos (hwndFrame, NULL, (SHORT) rcl.xLeft, (SHORT) rcl.yBottom,%@NL@%
                      (SHORT) (rcl.xRight - rcl.xLeft),%@NL@%
                      (SHORT) (rcl.yTop - rcl.yBottom), SWP_SIZE | SWP_MOVE) ;%@NL@%
     }%@NL@%
%@NL@%
VOID UpdateTime (HWND hwnd, HPS hps)%@NL@%
     {%@NL@%
     static BOOL        fHaveCtryInfo = FALSE ;%@NL@%
     static CHAR        *szDayName [] = { "Sun", "Mon", "Tue", "Wed",%@NL@%
                                          "Thu", "Fri", "Sat" } ;%@NL@%
     static CHAR        szDateFormat [] = " %s  %d%s%02d%s%02d " ;%@NL@%
     static COUNTRYCODE ctryc = { 0, 0 } ;%@NL@%
     static COUNTRYINFO ctryi ;%@NL@%
     CHAR               szBuffer [20] ;%@NL@%
     DATETIME           dt ;%@NL@%
     RECTL              rcl ;%@NL@%
     USHORT             usDataLength ;%@NL@%
%@NL@%
               %@AB@%/*----------------------------------------%@NL@%
%@AB@%                  Get Country Information, Date and Time%@NL@%
%@AB@%                 ----------------------------------------*/%@AE@%%@NL@%
%@NL@%
     if (!fHaveCtryInfo)%@NL@%
          {%@NL@%
          DosGetCtryInfo (sizeof ctryi, &ctryc, &ctryi, &usDataLength) ;%@NL@%
          fHaveCtryInfo = TRUE ;%@NL@%
          }%@NL@%
     DosGetDateTime (&dt) ;%@NL@%
     dt.year %= 100 ;%@NL@%
%@NL@%
               %@AB@%/*-------------%@NL@%
%@AB@%                  Format Date%@NL@%
%@AB@%                 -------------*/%@AE@%%@NL@%
                                   %@AB@%/*-----------------%@NL@%
%@AB@%                                      mm/dd/yy format%@NL@%
%@AB@%                                     -----------------*/%@AE@%%@NL@%
     if (ctryi.fsDateFmt == 0)%@NL@%
%@NL@%
          sprintf (szBuffer, szDateFormat, szDayName [dt.weekday],%@NL@%
                             dt.month, ctryi.szDateSeparator,%@NL@%
                             dt.day,   ctryi.szDateSeparator, dt.year) ;%@NL@%
%@NL@%
                                   %@AB@%/*-----------------%@NL@%
%@AB@%                                      dd/mm/yy format%@NL@%
%@AB@%                                     -----------------*/%@AE@%%@NL@%
     else if (ctryi.fsDateFmt == 1)%@NL@%
%@NL@%
          sprintf (szBuffer, szDateFormat, szDayName [dt.weekday],%@NL@%
                             dt.day,   ctryi.szDateSeparator,%@NL@%
                             dt.month, ctryi.szDateSeparator, dt.year) ;%@NL@%
%@NL@%
                                   %@AB@%/*-----------------%@NL@%
%@AB@%                                      yy/mm/dd format%@NL@%
%@AB@%                                     -----------------*/%@AE@%%@NL@%
     else%@NL@%
          sprintf (szBuffer, szDateFormat, szDayName [dt.weekday],%@NL@%
                             dt.year,  ctryi.szDateSeparator,%@NL@%
                             dt.month, ctryi.szDateSeparator, dt.day) ;%@NL@%
%@NL@%
               %@AB@%/*--------------%@NL@%
%@AB@%                  Display Date%@NL@%
%@AB@%                 --------------*/%@AE@%%@NL@%
%@NL@%
     WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
     rcl.yBottom += 5 * rcl.yTop / 11 ;%@NL@%
     WinDrawText (hps, -1, szBuffer, &rcl, CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                  DT_CENTER | DT_VCENTER) ;%@NL@%
%@NL@%
               %@AB@%/*-------------%@NL@%
%@AB@%                  Format Time%@NL@%
%@AB@%                 -------------*/%@AE@%%@NL@%
                                   %@AB@%/*----------------%@NL@%
%@AB@%                                      12-hour format%@NL@%
%@AB@%                                     ----------------*/%@AE@%%@NL@%
     if ((ctryi.fsTimeFmt & 1) == 0)%@NL@%
%@NL@%
          sprintf (szBuffer, " %d%s%02d%s%02d %cm ",%@NL@%
                             (dt.hours + 11) % 12 + 1, ctryi.szTimeSeparator,%@NL@%
                             dt.minutes, ctryi.szTimeSeparator,%@NL@%
                             dt.seconds, dt.hours / 12 ? 'p' : 'a') ;%@NL@%
%@NL@%
                                   %@AB@%/*----------------%@NL@%
%@AB@%                                      24-hour format%@NL@%
%@AB@%                                     ----------------*/%@AE@%%@NL@%
     else%@NL@%
          sprintf (szBuffer, " %02d%s%02d%s%02d ",%@NL@%
                             dt.hours,   ctryi.szTimeSeparator,%@NL@%
                             dt.minutes, ctryi.szTimeSeparator, dt.seconds) ;%@NL@%
%@NL@%
               %@AB@%/*--------------%@NL@%
%@AB@%                  Display Time%@NL@%
%@AB@%                 --------------*/%@AE@%%@NL@%
%@NL@%
     WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
     rcl.yTop -= 5 * rcl.yTop / 11 ;%@NL@%
     WinDrawText (hps, -1, szBuffer, &rcl, CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                  DT_CENTER | DT_VCENTER) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     HPS  hps;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_TIMER:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiSetBackMix (hps, BM_OVERPAINT) ;%@NL@%
%@NL@%
               UpdateTime (hwnd, hps) ;%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               UpdateTime (hwnd, hps) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DRAWLINE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP11\DRAWLINE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------%@NL@%
%@AB@%   DRAWLINE.C -- Draw line from radio buttons%@NL@%
%@AB@%  --------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "DrawLine" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR   *szGroupText[] = { "Color", "Type" } ;%@NL@%
     static CHAR   *szColorText[] = { "Background", "Blue",      "Red",%@NL@%
                                       "Pink",       "Green",     "Cyan",%@NL@%
                                       "Yellow",     "Neutral",   "Dark Gray",%@NL@%
                                       "Dark Blue",  "Dark Red",  "Dark Pink",%@NL@%
                                       "Dark Green", "Dark Cyan", "Brown",     %@NL@%
                                       "Pale Gray" } ;%@NL@%
     static CHAR   *szTypeText [] = { "Dot",       "Short Dash",%@NL@%
                                       "Dash Dot",  "Double Dot",%@NL@%
                                       "Long Dash", "Dash Double Dot",%@NL@%
                                       "Solid",     "Invisible" } ;%@NL@%
     static HWND   hwndGroup[2], hwndRadioColor[8], hwndRadioType[8] ;%@NL@%
     static POINTL aptl[5] ;%@NL@%
     static SHORT  sCurrentColor = 7,   // Neutral%@NL@%
                   sCurrentType  = 6 ;  // Solid%@NL@%
     FONTMETRICS   fm ;%@NL@%
     HPS           hps ;%@NL@%
     SHORT         s, id, cxChar, cyChar ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE :%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               for (s = 0 ; s < 2 ; s++)%@NL@%
%@NL@%
                    hwndGroup[s] = WinCreateWindow (%@NL@%
                                        hwnd,               // Parent%@NL@%
                                        WC_STATIC,          // Class%@NL@%
                                        szGroupText[s],     // Text%@NL@%
                                        WS_VISIBLE |        // Style%@NL@%
                                             SS_GROUPBOX,%@NL@%
                                        (8 + 42 * s) * cxChar,%@NL@%
                                        4 * cyChar,         // Position%@NL@%
                                        (26 + 12 * (1 - s)) *%@NL@%
                                             cxChar,        // Width%@NL@%
                                        14 * cyChar,        // Height%@NL@%
                                        hwnd,               // Owner%@NL@%
                                        HWND_TOP,           // Placement%@NL@%
                                        s + 24,             // ID%@NL@%
                                        NULL,               // Ctrl Data%@NL@%
                                        NULL) ;             // Pres Params%@NL@%
%@NL@%
               for (s = 0 ; s < 16 ; s++)%@NL@%
%@NL@%
                    hwndRadioColor[s] = WinCreateWindow (%@NL@%
                                        hwnd,               // Parent%@NL@%
                                        WC_BUTTON,          // Class%@NL@%
                                        szColorText[s],     // Text%@NL@%
                                        WS_VISIBLE |        // Style%@NL@%
                                             BS_RADIOBUTTON,%@NL@%
                                        (10 + (s > 7 ? 18 : 0))%@NL@%
                                             * cxChar,      // X Position%@NL@%
                                        (31 - 3 * (s % 8))%@NL@%
                                             * cyChar / 2,  // Y Position%@NL@%
                                        16 * cxChar,        // Width%@NL@%
                                        3 * cyChar / 2,     // Height%@NL@%
                                        hwnd,               // Owner%@NL@%
                                        HWND_BOTTOM,        // Placement%@NL@%
                                        s,                  // ID%@NL@%
                                        NULL,               // Ctrl Data%@NL@%
                                        NULL) ;             // Pres Params%@NL@%
%@NL@%
               for (s = 0 ; s < 8 ; s++)%@NL@%
%@NL@%
                    hwndRadioType[s]  = WinCreateWindow (%@NL@%
                                        hwnd,               // Parent%@NL@%
                                        WC_BUTTON,          // Class%@NL@%
                                        szTypeText[s],      // Text%@NL@%
                                        WS_VISIBLE |        // Style%@NL@%
                                             BS_RADIOBUTTON,%@NL@%
                                        52 * cxChar,        // Position%@NL@%
                                        (31 - 3 * s) * cyChar / 2,%@NL@%
                                        22 * cxChar,        // Width%@NL@%
                                        3 * cyChar / 2,     // Height%@NL@%
                                        hwnd,               // Owner%@NL@%
                                        HWND_BOTTOM,        // Placement%@NL@%
                                        s + 16,             // ID%@NL@%
                                        NULL,               // Ctrl Data%@NL@%
                                        NULL) ;             // Pres Params%@NL@%
                    %@NL@%
               WinSendMsg (hwndRadioColor[sCurrentColor],%@NL@%
                           BM_SETCHECK, MPFROMSHORT (1), NULL) ;%@NL@%
%@NL@%
               WinSendMsg (hwndRadioType[sCurrentType],%@NL@%
                           BM_SETCHECK, MPFROMSHORT (1), NULL) ;%@NL@%
%@NL@%
               aptl[0].x = aptl[3].x = aptl[4].x = 4 * cxChar ;%@NL@%
               aptl[1].x = aptl[2].x = 80 * cxChar ;%@NL@%
%@NL@%
               aptl[0].y = aptl[1].y = aptl[4].y = 2 * cyChar ;%@NL@%
               aptl[2].y = aptl[3].y = 20 * cyChar ;%@NL@%
%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CONTROL:%@NL@%
               id = SHORT1FROMMP (mp1) ;%@NL@%
%@NL@%
               if (id < 16)             // Color IDs%@NL@%
                    {%@NL@%
                    WinSendMsg (hwndRadioColor[sCurrentColor],%@NL@%
                                BM_SETCHECK, MPFROMSHORT (0), NULL) ;%@NL@%
%@NL@%
                    sCurrentColor = id ;%@NL@%
%@NL@%
                    WinSendMsg (hwndRadioColor[sCurrentColor],%@NL@%
                                BM_SETCHECK, MPFROMSHORT (1), NULL) ;%@NL@%
                    }%@NL@%
%@NL@%
               else if (id < 24)        // Line Type IDs%@NL@%
                    {%@NL@%
                    WinSendMsg (hwndRadioType[sCurrentType],%@NL@%
                                BM_SETCHECK, MPFROMSHORT (0), NULL) ;%@NL@%
%@NL@%
                    sCurrentType = id - 16 ;%@NL@%
%@NL@%
                    WinSendMsg (hwndRadioType[sCurrentType],%@NL@%
                                BM_SETCHECK, MPFROMSHORT (1), NULL) ;%@NL@%
                    }%@NL@%
               WinInvalidateRect (hwnd, NULL, TRUE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               GpiSetColor (hps, (LONG) sCurrentColor) ;%@NL@%
               GpiSetLineType (hps, sCurrentType + LINETYPE_DOT) ;%@NL@%
               GpiMove (hps, aptl) ;%@NL@%
               GpiPolyLine (hps, 4L, aptl + 1) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EASYFONT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP14\EASYFONT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------%@NL@%
%@AB@%   EASYFONT.C -- Routines for Using Image Fonts%@NL@%
%@AB@%  ----------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"easyfont.h" %@NL@%
%@NL@%
static SHORT sFontSize[6]   = { 80, 100, 120, 140, 180, 240 } ;%@NL@%
static CHAR  *szFacename[4] = { "System Proportional",%@NL@%
                                "Courier", "Helv", "Tms Rmn" } ;%@NL@%
static LONG  alMatch[4][6] ;%@NL@%
%@NL@%
BOOL EzfQueryFonts (HPS hps)%@NL@%
     {%@NL@%
     FONTMETRICS *pfm ;%@NL@%
     HDC         hdc ;%@NL@%
     LONG        lHorzRes, lVertRes, lRequestFonts, lNumberFonts ;%@NL@%
     SHORT       sIndex, sFace, sSize ;%@NL@%
%@NL@%
     hdc = GpiQueryDevice (hps) ;%@NL@%
     DevQueryCaps (hdc, CAPS_HORIZONTAL_FONT_RES, 1L, &lHorzRes) ;%@NL@%
     DevQueryCaps (hdc, CAPS_VERTICAL_FONT_RES,   1L, &lVertRes) ;%@NL@%
%@NL@%
     for (sFace = 0 ; sFace < 4 ; sFace++)%@NL@%
          {%@NL@%
          lRequestFonts = 0 ;%@NL@%
          lNumberFonts = GpiQueryFonts (hps, QF_PUBLIC, szFacename[sFace],%@NL@%
                                        &lRequestFonts, 0L, NULL) ;%@NL@%
          if (lNumberFonts == 0)%@NL@%
               continue ;%@NL@%
%@NL@%
          if (lNumberFonts * sizeof (FONTMETRICS) >= 65536L)%@NL@%
               return FALSE ;%@NL@%
%@NL@%
          pfm = malloc ((SHORT) lNumberFonts * sizeof (FONTMETRICS)) ;%@NL@%
%@NL@%
          if (pfm == NULL)%@NL@%
               return FALSE ;%@NL@%
%@NL@%
          GpiQueryFonts (hps, QF_PUBLIC, szFacename[sFace],%@NL@%
                         &lNumberFonts, (LONG) sizeof (FONTMETRICS), pfm) ;%@NL@%
%@NL@%
          for (sIndex = 0 ; sIndex < (SHORT) lNumberFonts ; sIndex++)%@NL@%
               if (pfm[sIndex].sXDeviceRes == (SHORT) lHorzRes &&%@NL@%
                   pfm[sIndex].sYDeviceRes == (SHORT) lVertRes &&%@NL@%
                  (pfm[sIndex].fsDefn & 1) == 0)%@NL@%
                    {%@NL@%
                    for (sSize = 0 ; sSize < 6 ; sSize++)%@NL@%
                         if (pfm[sIndex].sNominalPointSize == sFontSize[sSize])%@NL@%
                              break ;%@NL@%
%@NL@%
                    if (sSize != 6)%@NL@%
                         alMatch[sFace][sSize] = pfm[sIndex].lMatch ;%@NL@%
                    }%@NL@%
%@NL@%
          free (pfm) ;%@NL@%
          }%@NL@%
     return TRUE ;%@NL@%
     }%@NL@%
%@NL@%
LONG EzfCreateLogFont (HPS hps, LONG lcid, USHORT idFace, USHORT idSize,%@NL@%
                                           USHORT fsSelection)%@NL@%
     {%@NL@%
     static FATTRS fat ;%@NL@%
%@NL@%
     if (idFace > 3 || idSize > 5 || alMatch[idFace][idSize] == 0)%@NL@%
          return FALSE ;%@NL@%
%@NL@%
     fat.usRecordLength = sizeof fat ;%@NL@%
     fat.fsSelection    = fsSelection ;%@NL@%
     fat.lMatch         = alMatch[idFace][idSize] ;%@NL@%
%@NL@%
     strcpy (fat.szFacename, szFacename[idFace]) ;%@NL@%
%@NL@%
     return GpiCreateLogFont (hps, NULL, lcid, &fat) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EASYFONT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP08\EASYFONT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------%@NL@%
%@AB@%   EASYFONT.C -- Routines for Using Image Fonts%@NL@%
%@AB@%  ----------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"easyfont.h" %@NL@%
%@NL@%
static SHORT sFontSize[6]   = { 80, 100, 120, 140, 180, 240 } ;%@NL@%
static CHAR  *szFacename[4] = { "System Proportional",%@NL@%
                                "Courier", "Helv", "Tms Rmn" } ;%@NL@%
static LONG  alMatch[4][6] ;%@NL@%
%@NL@%
BOOL EzfQueryFonts (HPS hps)%@NL@%
     {%@NL@%
     FONTMETRICS *pfm ;%@NL@%
     HDC         hdc ;%@NL@%
     LONG        lHorzRes, lVertRes, lRequestFonts, lNumberFonts ;%@NL@%
     SHORT       sIndex, sFace, sSize ;%@NL@%
%@NL@%
     hdc = GpiQueryDevice (hps) ;%@NL@%
     DevQueryCaps (hdc, CAPS_HORIZONTAL_FONT_RES, 1L, &lHorzRes) ;%@NL@%
     DevQueryCaps (hdc, CAPS_VERTICAL_FONT_RES,   1L, &lVertRes) ;%@NL@%
%@NL@%
     for (sFace = 0 ; sFace < 4 ; sFace++)%@NL@%
          {%@NL@%
          lRequestFonts = 0 ;%@NL@%
          lNumberFonts = GpiQueryFonts (hps, QF_PUBLIC, szFacename[sFace],%@NL@%
                                        &lRequestFonts, 0L, NULL) ;%@NL@%
          if (lNumberFonts == 0)%@NL@%
               continue ;%@NL@%
%@NL@%
          if (lNumberFonts * sizeof (FONTMETRICS) >= 65536L)%@NL@%
               return FALSE ;%@NL@%
%@NL@%
          pfm = malloc ((SHORT) lNumberFonts * sizeof (FONTMETRICS)) ;%@NL@%
%@NL@%
          if (pfm == NULL)%@NL@%
               return FALSE ;%@NL@%
%@NL@%
          GpiQueryFonts (hps, QF_PUBLIC, szFacename[sFace],%@NL@%
                         &lNumberFonts, (LONG) sizeof (FONTMETRICS), pfm) ;%@NL@%
%@NL@%
          for (sIndex = 0 ; sIndex < (SHORT) lNumberFonts ; sIndex++)%@NL@%
               if (pfm[sIndex].sXDeviceRes == (SHORT) lHorzRes &&%@NL@%
                   pfm[sIndex].sYDeviceRes == (SHORT) lVertRes &&%@NL@%
                  (pfm[sIndex].fsDefn & 1) == 0)%@NL@%
                    {%@NL@%
                    for (sSize = 0 ; sSize < 6 ; sSize++)%@NL@%
                         if (pfm[sIndex].sNominalPointSize == sFontSize[sSize])%@NL@%
                              break ;%@NL@%
%@NL@%
                    if (sSize != 6)%@NL@%
                         alMatch[sFace][sSize] = pfm[sIndex].lMatch ;%@NL@%
                    }%@NL@%
%@NL@%
          free (pfm) ;%@NL@%
          }%@NL@%
     return TRUE ;%@NL@%
     }%@NL@%
%@NL@%
LONG EzfCreateLogFont (HPS hps, LONG lcid, USHORT idFace, USHORT idSize,%@NL@%
                                           USHORT fsSelection)%@NL@%
     {%@NL@%
     static FATTRS fat ;%@NL@%
%@NL@%
     if (idFace > 3 || idSize > 5 || alMatch[idFace][idSize] == 0)%@NL@%
          return FALSE ;%@NL@%
%@NL@%
     fat.usRecordLength = sizeof fat ;%@NL@%
     fat.fsSelection    = fsSelection ;%@NL@%
     fat.lMatch         = alMatch[idFace][idSize] ;%@NL@%
%@NL@%
     strcpy (fat.szFacename, szFacename[idFace]) ;%@NL@%
%@NL@%
     return GpiCreateLogFont (hps, NULL, lcid, &fat) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EASYFONT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\EASYFONT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------%@NL@%
%@AB@%   EASYFONT.C -- Routines for Using Image Fonts%@NL@%
%@AB@%  ----------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"easyfont.h" %@NL@%
%@NL@%
static SHORT sFontSize[6]   = { 80, 100, 120, 140, 180, 240 } ;%@NL@%
static CHAR  *szFacename[4] = { "System Proportional",%@NL@%
                                "Courier", "Helv", "Tms Rmn" } ;%@NL@%
static LONG  alMatch[4][6] ;%@NL@%
%@NL@%
BOOL EzfQueryFonts (HPS hps)%@NL@%
     {%@NL@%
     FONTMETRICS *pfm ;%@NL@%
     HDC         hdc ;%@NL@%
     LONG        lHorzRes, lVertRes, lRequestFonts, lNumberFonts ;%@NL@%
     SHORT       sIndex, sFace, sSize ;%@NL@%
%@NL@%
     hdc = GpiQueryDevice (hps) ;%@NL@%
     DevQueryCaps (hdc, CAPS_HORIZONTAL_FONT_RES, 1L, &lHorzRes) ;%@NL@%
     DevQueryCaps (hdc, CAPS_VERTICAL_FONT_RES,   1L, &lVertRes) ;%@NL@%
%@NL@%
     for (sFace = 0 ; sFace < 4 ; sFace++)%@NL@%
          {%@NL@%
          lRequestFonts = 0 ;%@NL@%
          lNumberFonts = GpiQueryFonts (hps, QF_PUBLIC, szFacename[sFace],%@NL@%
                                        &lRequestFonts, 0L, NULL) ;%@NL@%
          if (lNumberFonts == 0)%@NL@%
               continue ;%@NL@%
%@NL@%
          if (lNumberFonts * sizeof (FONTMETRICS) >= 65536L)%@NL@%
               return FALSE ;%@NL@%
%@NL@%
          pfm = malloc ((SHORT) lNumberFonts * sizeof (FONTMETRICS)) ;%@NL@%
%@NL@%
          if (pfm == NULL)%@NL@%
               return FALSE ;%@NL@%
%@NL@%
          GpiQueryFonts (hps, QF_PUBLIC, szFacename[sFace],%@NL@%
                         &lNumberFonts, (LONG) sizeof (FONTMETRICS), pfm) ;%@NL@%
%@NL@%
          for (sIndex = 0 ; sIndex < (SHORT) lNumberFonts ; sIndex++)%@NL@%
               if (pfm[sIndex].sXDeviceRes == (SHORT) lHorzRes &&%@NL@%
                   pfm[sIndex].sYDeviceRes == (SHORT) lVertRes &&%@NL@%
                  (pfm[sIndex].fsDefn & 1) == 0)%@NL@%
                    {%@NL@%
                    for (sSize = 0 ; sSize < 6 ; sSize++)%@NL@%
                         if (pfm[sIndex].sNominalPointSize == sFontSize[sSize])%@NL@%
                              break ;%@NL@%
%@NL@%
                    if (sSize != 6)%@NL@%
                         alMatch[sFace][sSize] = pfm[sIndex].lMatch ;%@NL@%
                    }%@NL@%
%@NL@%
          free (pfm) ;%@NL@%
          }%@NL@%
     return TRUE ;%@NL@%
     }%@NL@%
%@NL@%
LONG EzfCreateLogFont (HPS hps, LONG lcid, USHORT idFace, USHORT idSize,%@NL@%
                                           USHORT fsSelection)%@NL@%
     {%@NL@%
     static FATTRS fat ;%@NL@%
%@NL@%
     if (idFace > 3 || idSize > 5 || alMatch[idFace][idSize] == 0)%@NL@%
          return FALSE ;%@NL@%
%@NL@%
     fat.usRecordLength = sizeof fat ;%@NL@%
     fat.fsSelection    = fsSelection ;%@NL@%
     fat.lMatch         = alMatch[idFace][idSize] ;%@NL@%
%@NL@%
     strcpy (fat.szFacename, szFacename[idFace]) ;%@NL@%
%@NL@%
     return GpiCreateLogFont (hps, NULL, lcid, &fat) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FONTS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\FONTS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------%@NL@%
%@AB@%   FONTS.C -- GPI Image Fonts%@NL@%
%@AB@%  ----------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%"easyfont.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%LCID_MYFONT 1L %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Fonts" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_VERTSCROLL    | FCF_HORZSCROLL ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR   *szFace[] = { "System", "Courier",%@NL@%
                                 "Helv",   "Tms Rmn" } ;%@NL@%
     static CHAR   *szSize[] = { "8", "10", "12", "14", "18", "24" } ;%@NL@%
     static CHAR   *szSel[]  = { "Normal",     "Italic",  "Underscore",%@NL@%
                                 "Strike-out", "Bold" } ;%@NL@%
     static CHAR   szBuffer[80] ;%@NL@%
     static HWND   hwndVscroll, hwndHscroll ;%@NL@%
     static USHORT idFace[] = { FONTFACE_SYSTEM, FONTFACE_COUR,%@NL@%
                                FONTFACE_HELV,   FONTFACE_TIMES } ;%@NL@%
     static USHORT idSize[] = { FONTSIZE_8,  FONTSIZE_10, FONTSIZE_12,%@NL@%
                                FONTSIZE_14, FONTSIZE_18, FONTSIZE_24 } ;%@NL@%
     static USHORT afsSel[] = { 0, FATTR_SEL_ITALIC,    FATTR_SEL_UNDERSCORE,%@NL@%
                                   FATTR_SEL_STRIKEOUT, FATTR_SEL_BOLD } ;%@NL@%
     static SHORT  sVscrollMax = sizeof idFace / sizeof idFace[0] - 1,%@NL@%
                   sHscrollMax = sizeof afsSel / sizeof afsSel[0] - 1,%@NL@%
                   cxClient, cyClient, sHscrollPos, sVscrollPos ;%@NL@%
     FONTMETRICS   fm ;%@NL@%
     HPS           hps;%@NL@%
     HWND          hwndFrame ;%@NL@%
     POINTL        ptl ;%@NL@%
     SHORT         sIndex ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               EzfQueryFonts (hps) ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               hwndFrame   = WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
               hwndVscroll = WinWindowFromID (hwndFrame, FID_VERTSCROLL) ;%@NL@%
               hwndHscroll = WinWindowFromID (hwndFrame, FID_HORZSCROLL) ;%@NL@%
%@NL@%
               WinSendMsg (hwndVscroll, SBM_SETSCROLLBAR,%@NL@%
                           MPFROM2SHORT (sVscrollPos, 0),%@NL@%
                           MPFROM2SHORT (0, sVscrollMax)) ;%@NL@%
%@NL@%
               WinSendMsg (hwndHscroll, SBM_SETSCROLLBAR,%@NL@%
                           MPFROM2SHORT (sHscrollPos, 0),%@NL@%
                           MPFROM2SHORT (0, sHscrollMax)) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_VSCROLL:%@NL@%
               switch (SHORT2FROMMP (mp2))%@NL@%
                    {%@NL@%
                    case SB_LINEUP:%@NL@%
                    case SB_PAGEUP:%@NL@%
                         sVscrollPos = max (0, sVscrollPos - 1) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_LINEDOWN:%@NL@%
                    case SB_PAGEDOWN:%@NL@%
                         sVscrollPos = min (sVscrollMax, sVscrollPos + 1) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_SLIDERPOSITION:%@NL@%
                         sVscrollPos = SHORT1FROMMP (mp2) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    default:%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               WinSendMsg (hwndVscroll, SBM_SETPOS,%@NL@%
                           MPFROM2SHORT (sVscrollPos, 0), NULL) ;%@NL@%
%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_HSCROLL:%@NL@%
               switch (SHORT2FROMMP (mp2))%@NL@%
                    {%@NL@%
                    case SB_LINELEFT:%@NL@%
                    case SB_PAGELEFT:%@NL@%
                         sHscrollPos = max (0, sHscrollPos - 1) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_LINERIGHT:%@NL@%
                    case SB_PAGERIGHT:%@NL@%
                         sHscrollPos = min (sHscrollMax, sHscrollPos + 1) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_SLIDERPOSITION:%@NL@%
                         sHscrollPos = SHORT1FROMMP (mp2) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    default:%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               WinSendMsg (hwndHscroll, SBM_SETPOS,%@NL@%
                           MPFROM2SHORT (sHscrollPos, 0), NULL) ;%@NL@%
%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               switch (CHARMSG(&msg)->vkey)%@NL@%
                    {%@NL@%
                    case VK_LEFT:%@NL@%
                    case VK_RIGHT:%@NL@%
                         return WinSendMsg (hwndHscroll, msg, mp1, mp2) ;%@NL@%
                    case VK_UP:%@NL@%
                    case VK_DOWN:%@NL@%
                    case VK_PAGEUP:%@NL@%
                    case VK_PAGEDOWN:%@NL@%
                         return WinSendMsg (hwndVscroll, msg, mp1, mp2) ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               ptl.x = 0 ;%@NL@%
               ptl.y = cyClient ;%@NL@%
%@NL@%
               for (sIndex = 0 ; sIndex < 6 ; sIndex++)%@NL@%
                    if (EzfCreateLogFont (hps, LCID_MYFONT,%@NL@%
                                          idFace[sVscrollPos],%@NL@%
                                          idSize[sIndex],%@NL@%
                                          afsSel[sHscrollPos]))%@NL@%
                         {%@NL@%
                         GpiSetCharSet (hps, LCID_MYFONT) ;%@NL@%
                         GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
%@NL@%
                         ptl.y -= fm.lMaxBaselineExt ;%@NL@%
%@NL@%
                         GpiCharStringAt (hps, &ptl,%@NL@%
                              (LONG) sprintf (szBuffer, "%s, %s point, %s",%@NL@%
                                              szFace[sVscrollPos],%@NL@%
                                              szSize[sIndex],%@NL@%
                                              szSel[sHscrollPos]),%@NL@%
                              szBuffer) ;%@NL@%
%@NL@%
                         GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
                         GpiDeleteSetId (hps, LCID_MYFONT) ;%@NL@%
                         }%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FREEMEM.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP10\FREEMEM.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------%@NL@%
%@AB@%   FREEMEM.C -- Free Memory Display %@NL@%
%@AB@%  ----------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#define %@AE@%INCL_DOS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%ID_TIMER 1 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
VOID    SizeTheWindow (HWND) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "FreeMem" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR | FCF_SYSMENU  |%@NL@%
                                 FCF_BORDER   | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
     SizeTheWindow (hwndFrame) ;%@NL@%
%@NL@%
     if (WinStartTimer (hab, hwndClient, ID_TIMER, 1000))%@NL@%
          {%@NL@%
          while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
               WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
          WinStopTimer (hab, hwndClient, ID_TIMER) ;%@NL@%
          }%@NL@%
     else%@NL@%
          WinMessageBox (HWND_DESKTOP, hwndClient,%@NL@%
                         "Too many clocks or timers",%@NL@%
                         szClientClass, 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID SizeTheWindow (HWND hwndFrame)%@NL@%
     {%@NL@%
     static CHAR szText [] = "1,234,567,890 bytes" ;%@NL@%
     HPS         hps ;%@NL@%
     POINTL      aptl[TXTBOX_COUNT] ;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
     hps = WinGetPS (hwndFrame) ;%@NL@%
     GpiQueryTextBox (hps, sizeof szText - 1L, szText, TXTBOX_COUNT, aptl) ;%@NL@%
     WinReleasePS (hps) ;%@NL@%
%@NL@%
     rcl.yBottom = 0 ;%@NL@%
     rcl.yTop    = 3 * (aptl[TXTBOX_TOPLEFT].y -%@NL@%
                        aptl[TXTBOX_BOTTOMLEFT].y) / 2 ;%@NL@%
     rcl.xLeft   = 0 ;%@NL@%
     rcl.xRight  = (sizeof szText + 1L) * (aptl[TXTBOX_BOTTOMRIGHT].x -%@NL@%
                   aptl[TXTBOX_BOTTOMLEFT].x) / (sizeof szText - 1L) ;%@NL@%
%@NL@%
     WinCalcFrameRect (hwndFrame, &rcl, FALSE) ;%@NL@%
%@NL@%
     WinSetWindowPos (hwndFrame, NULL, (SHORT) rcl.xLeft, (SHORT) rcl.yBottom,%@NL@%
                      (SHORT) (rcl.xRight - rcl.xLeft),%@NL@%
                      (SHORT) (rcl.yTop - rcl.yBottom), SWP_SIZE | SWP_MOVE) ;%@NL@%
     }%@NL@%
%@NL@%
VOID FormatNumber (CHAR *pchResult, ULONG ulValue)%@NL@%
     {%@NL@%
     BOOL  fDisplay = FALSE ;%@NL@%
     SHORT sDigit ;%@NL@%
     ULONG ulQuotient, ulDivisor = 1000000000L ;%@NL@%
%@NL@%
     for (sDigit = 0 ; sDigit < 10 ; sDigit++)%@NL@%
          {%@NL@%
          ulQuotient = ulValue / ulDivisor ;%@NL@%
%@NL@%
          if (fDisplay || ulQuotient > 0 || sDigit == 9)%@NL@%
               {%@NL@%
               fDisplay = TRUE ;%@NL@%
%@NL@%
               *pchResult++ = (CHAR) ('0' + ulQuotient) ;%@NL@%
%@NL@%
               if ((sDigit % 3 == 0) && sDigit != 9)%@NL@%
                    *pchResult++ = ',' ;%@NL@%
               }%@NL@%
          ulValue -= ulQuotient * ulDivisor ;%@NL@%
          ulDivisor /= 10 ;%@NL@%
          }%@NL@%
     *pchResult = '\0' ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static RECTL rcl ;%@NL@%
     static ULONG ulFreeMem, ulPrevMem ;%@NL@%
     CHAR         szBuffer [24] ;%@NL@%
     HPS          hps;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               return 0 ;               %@NL@%
%@NL@%
          case WM_TIMER:%@NL@%
               DosMemAvail (&ulFreeMem) ;%@NL@%
%@NL@%
               if (ulFreeMem != ulPrevMem)%@NL@%
                    {%@NL@%
                    WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                    ulPrevMem = ulFreeMem ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               FormatNumber (szBuffer, ulFreeMem) ;%@NL@%
               strcat (szBuffer, " bytes") ;%@NL@%
%@NL@%
               WinDrawText (hps, -1, szBuffer, &rcl, %@NL@%
                            CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                            DT_CENTER | DT_VCENTER | DT_ERASERECT) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%GRAFMENU.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP13\GRAFMENU.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------%@NL@%
%@AB@%   GRAFMENU.C -- A Menu with Graphics%@NL@%
%@AB@%  ------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"grafmenu.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
CHAR szClientClass[] = "GrafMenu" ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static MENUITEM miBigHelp = { 0,                       // iPosition%@NL@%
                                   MIS_BITMAP | MIS_HELP,   // afStyle%@NL@%
                                   0,                       // afAttribute%@NL@%
                                   IDM_HELP,                // id%@NL@%
                                   NULL,                    // hwndSubMenu%@NL@%
                                   NULL } ;                 // hItem%@NL@%
     FONTMETRICS     fm ;%@NL@%
     HBITMAP         hbm ;%@NL@%
     HPS             hps ;%@NL@%
     HWND            hwndMenu ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
%@NL@%
                    %@AB@%/*----------------------%@NL@%
%@AB@%                       Load bitmap resource%@NL@%
%@AB@%                      ----------------------*/%@AE@%%@NL@%
%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               hbm = GpiLoadBitmap (hps, NULL, IDB_BIGHELP,%@NL@%
                                    64 * fm.lAveCharWidth / 3,%@NL@%
                                    64 * fm.lMaxBaselineExt / 8) ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
                    %@AB@%/*-----------------------%@NL@%
%@AB@%                       Attach bitmap to menu%@NL@%
%@AB@%                      -----------------------*/%@AE@%%@NL@%
%@NL@%
               miBigHelp.hItem = (ULONG) hbm ;%@NL@%
%@NL@%
               hwndMenu = WinWindowFromID (%@NL@%
                               WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                               FID_MENU) ;%@NL@%
%@NL@%
               WinSendMsg (hwndMenu, MM_SETITEM,%@NL@%
                           MPFROM2SHORT (0, TRUE), MPFROMP (&miBigHelp)) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_NEW:%@NL@%
                    case IDM_OPEN:%@NL@%
                    case IDM_SAVE:%@NL@%
                    case IDM_SAVEAS:%@NL@%
                    case IDM_ABOUT:%@NL@%
                         WinAlarm (HWND_DESKTOP, WA_NOTE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_HELP:%@NL@%
               WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                              "Help not yet implemented",%@NL@%
                              szClientClass, 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%HDRLIB.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP16\HDRLIB.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------------------------%@NL@%
%@AB@%   HDRLIB.C -- "Handy Drawing Routines" Dynamic Link Library%@NL@%
%@AB@%  -----------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdarg.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"hdrlib.h" %@NL@%
%@NL@%
SHORT APIENTRY HdrPuts (HPS hps, PPOINTL pptl, PCHAR szText)%@NL@%
     {%@NL@%
     SHORT sLength = strlen (szText) ;%@NL@%
%@NL@%
     if (pptl == NULL)%@NL@%
          GpiCharString (hps, (LONG) sLength, szText) ;%@NL@%
     else%@NL@%
          GpiCharStringAt (hps, pptl, (LONG) sLength, szText) ;%@NL@%
%@NL@%
     return sLength ;%@NL@%
     }%@NL@%
%@NL@%
SHORT cdecl FAR HdrPrintf (HPS hps, PPOINTL pptl, PCHAR szFormat, ...)%@NL@%
     {%@NL@%
     static CHAR chBuffer [1024] ;%@NL@%
     SHORT       sLength ;%@NL@%
     va_list     pArguments ;%@NL@%
%@NL@%
     va_start (pArguments, szFormat) ;%@NL@%
     sLength = vsprintf (chBuffer, szFormat, pArguments) ;%@NL@%
%@NL@%
     if (pptl == NULL)%@NL@%
          GpiCharString (hps, (LONG) sLength, chBuffer) ;%@NL@%
     else%@NL@%
          GpiCharStringAt (hps, pptl, (LONG) sLength, chBuffer) ;%@NL@%
%@NL@%
     va_end (pArguments) ;%@NL@%
     return sLength ;%@NL@%
     }%@NL@%
%@NL@%
LONG APIENTRY HdrEllipse (HPS hps, LONG lOption, PPOINTL pptl)%@NL@%
     {%@NL@%
     POINTL ptlCurrent ;%@NL@%
%@NL@%
     GpiQueryCurrentPosition (hps, &ptlCurrent) ;%@NL@%
%@NL@%
     return GpiBox (hps, lOption, pptl, labs (pptl->x - ptlCurrent.x),%@NL@%
                                        labs (pptl->y - ptlCurrent.y)) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%HDRTEST.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP16\HDRTEST.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------------------%@NL@%
%@AB@%   HDRTEST.C -- Program to Test HDRLIB.DLL Dynamic Link Library%@NL@%
%@AB@%  --------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"hdrlib.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "HdrTest" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB            hab ;%@NL@%
     HMQ            hmq ;%@NL@%
     HWND           hwndFrame, hwndClient ;%@NL@%
     QMSG           qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static SHORT cxClient, cyClient ;%@NL@%
     HPS          hps;%@NL@%
     POINTL       ptl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               ptl.x = cxClient / 8 ;%@NL@%
               ptl.y = 3 * cyClient / 4 ;%@NL@%
               HdrPrintf (hps, &ptl, "Welcome to the %s",%@NL@%
                          (PCHAR) "OS/2 Presentation Manager") ;%@NL@%
%@NL@%
               ptl.x = cxClient / 8 ;%@NL@%
               ptl.y = cyClient / 4 ;%@NL@%
               HdrPuts (hps, &ptl, "This line was displayed by a ") ;%@NL@%
               HdrPuts (hps, NULL, "routine in a dynamic link library.") ;%@NL@%
%@NL@%
               ptl.x = 0 ;%@NL@%
               ptl.y = 0 ;%@NL@%
               GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
               ptl.x = cxClient - 1 ;%@NL@%
               ptl.y = cyClient - 1 ;%@NL@%
               HdrEllipse (hps, DRO_OUTLINE, &ptl) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%HEAD.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP14\HEAD.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------%@NL@%
%@AB@%   HEAD.C -- Displays File Head%@NL@%
%@AB@%  ------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<malloc.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"easyfont.h" %@NL@%
%@AI@%#include %@AE@%"head.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%LCID_FIXEDFONT   1L %@NL@%
%@AI@%#define %@AE@%LCID_BOLDFONT    2L %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT EXPENTRY AboutDlgProc  (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT EXPENTRY OpenDlgProc   (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
SHORT            ParseFileName (CHAR *, CHAR *) ;%@NL@%
%@NL@%
CHAR szClientClass [] = "Head" ;%@NL@%
CHAR szFileName [80] ;%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (int argc, char *argv[])%@NL@%
     {%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
               // Check for filename parameter and copy to szFileName%@NL@%
%@NL@%
     if (argc > 1)%@NL@%
          ParseFileName (szFileName, argv [1]) ;%@NL@%
%@NL@%
               // Continue normally%@NL@%
     %@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     if (hwndFrame != NULL)%@NL@%
          {%@NL@%
          WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                      WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                      NULL) ;%@NL@%
%@NL@%
          while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
               WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
          WinDestroyWindow (hwndFrame) ;%@NL@%
          }%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR  szErrorMsg [] = "File not found or could not be opened" ;%@NL@%
     static SHORT cxClient, cyClient, cxChar, cyChar, cyDesc ;%@NL@%
     CHAR         *pcReadBuffer ;%@NL@%
     FILE         *fileInput ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       ptl ;%@NL@%
     SHORT        sLength ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               EzfQueryFonts (hps) ;%@NL@%
%@NL@%
               if (!EzfCreateLogFont (hps, LCID_FIXEDFONT, FONTFACE_COUR,%@NL@%
                                                           FONTSIZE_10, 0))%@NL@%
                    {%@NL@%
                    WinReleasePS (hps) ;%@NL@%
%@NL@%
                    WinMessageBox (HWND_DESKTOP, HWND_DESKTOP,%@NL@%
                         "Cannot find a fixed-pitch font.  Load the Courier "%@NL@%
                         "fonts from the Control Panel and try again.",%@NL@%
                         szClientClass, 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
%@NL@%
                    return 1 ;%@NL@%
                    }%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
%@NL@%
               GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
               GpiDeleteSetId (hps, LCID_FIXEDFONT) ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
          %@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_OPEN:%@NL@%
                         if (WinDlgBox (HWND_DESKTOP, hwnd, OpenDlgProc,%@NL@%
                                        NULL, IDD_OPEN, NULL))%@NL@%
                              WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ABOUT:%@NL@%
                         WinDlgBox (HWND_DESKTOP, hwnd, AboutDlgProc,%@NL@%
                                    NULL, IDD_ABOUT, NULL) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               if (szFileName [0] != '\0')%@NL@%
                    {%@NL@%
                    EzfCreateLogFont (hps, LCID_FIXEDFONT, FONTFACE_COUR,%@NL@%
                                           FONTSIZE_10,    0) ;%@NL@%
                    EzfCreateLogFont (hps, LCID_BOLDFONT,  FONTFACE_COUR,%@NL@%
                                           FONTSIZE_10,    FATTR_SEL_BOLD) ;%@NL@%
%@NL@%
                    GpiSetCharSet (hps, LCID_BOLDFONT) ;%@NL@%
                    ptl.x = cxChar ;%@NL@%
                    ptl.y = cyClient - cyChar + cyDesc ;%@NL@%
                    GpiCharStringAt (hps, &ptl, (LONG) strlen (szFileName),%@NL@%
                                                szFileName) ;%@NL@%
                    ptl.y -= cyChar ;%@NL@%
                                %@NL@%
                    if ((fileInput = fopen (szFileName, "r")) != NULL)%@NL@%
                         {%@NL@%
                         GpiSetCharSet (hps, LCID_FIXEDFONT) ;%@NL@%
                         pcReadBuffer = malloc (cxClient / cxChar) ;%@NL@%
%@NL@%
                         while ((ptl.y -= cyChar) > 0 &&%@NL@%
                                fgets (pcReadBuffer, cxClient / cxChar - 2,%@NL@%
                                       fileInput) != NULL)%@NL@%
                              {%@NL@%
                              sLength = strlen (pcReadBuffer) ;%@NL@%
%@NL@%
                              if (pcReadBuffer [sLength - 1] == '\n')%@NL@%
                                   sLength-- ;%@NL@%
%@NL@%
                              if (sLength > 0)%@NL@%
                                   GpiCharStringAt (hps, &ptl, (LONG) sLength,%@NL@%
                                                         pcReadBuffer) ;%@NL@%
                              }%@NL@%
                         free (pcReadBuffer) ;%@NL@%
                         fclose (fileInput) ;%@NL@%
                         }%@NL@%
                    else           // file cannot be opened%@NL@%
                         {%@NL@%
                         ptl.y -= cyChar ;%@NL@%
                         GpiCharStringAt (hps, &ptl,%@NL@%
                                          (LONG) strlen (szErrorMsg),%@NL@%
                                          szErrorMsg) ;%@NL@%
                         }%@NL@%
                    GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
                    GpiDeleteSetId (hps, LCID_FIXEDFONT) ;%@NL@%
                    GpiDeleteSetId (hps, LCID_BOLDFONT) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY AboutDlgProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case DID_OK:%@NL@%
                    case DID_CANCEL:%@NL@%
                         WinDismissDlg (hwnd, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
          }%@NL@%
     return WinDefDlgProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
VOID FillDirListBox (HWND hwnd, CHAR *pcCurrentPath)%@NL@%
     {%@NL@%
     static CHAR szDrive [] = "  :" ;%@NL@%
     FILEFINDBUF findbuf ;%@NL@%
     HDIR        hDir = 1 ;%@NL@%
     SHORT       sDrive ;%@NL@%
     USHORT      usDriveNum, usCurPathLen, usSearchCount = 1 ;%@NL@%
     ULONG       ulDriveMap ;%@NL@%
%@NL@%
     DosQCurDisk (&usDriveNum, &ulDriveMap) ;%@NL@%
     pcCurrentPath [0] = (CHAR) usDriveNum + '@' ;%@NL@%
     pcCurrentPath [1] = ':' ;%@NL@%
     pcCurrentPath [2] = '\\' ;%@NL@%
     usCurPathLen = 64 ;%@NL@%
     DosQCurDir (0, pcCurrentPath + 3, &usCurPathLen) ;%@NL@%
%@NL@%
     WinSetDlgItemText (hwnd, IDD_PATH, pcCurrentPath) ;%@NL@%
     WinSendDlgItemMsg (hwnd, IDD_DIRLIST, LM_DELETEALL, NULL, NULL) ;%@NL@%
%@NL@%
     for (sDrive = 0 ; sDrive < 26 ; sDrive++)%@NL@%
          if (ulDriveMap & 1L << sDrive)%@NL@%
               {%@NL@%
               szDrive [1] = (CHAR) sDrive + 'A' ;%@NL@%
%@NL@%
               WinSendDlgItemMsg (hwnd, IDD_DIRLIST, LM_INSERTITEM,%@NL@%
                                  MPFROM2SHORT (LIT_END, 0),%@NL@%
                                  MPFROMP (szDrive)) ;%@NL@%
               }%@NL@%
%@NL@%
     DosFindFirst ("*.*", &hDir, 0x0017, &findbuf, sizeof findbuf,%@NL@%
                              &usSearchCount, 0L) ;%@NL@%
     while (usSearchCount)%@NL@%
          {%@NL@%
          if (findbuf.attrFile & 0x0010 &&%@NL@%
                    (findbuf.achName [0] != '.' || findbuf.achName [1]))%@NL@%
               %@NL@%
               WinSendDlgItemMsg (hwnd, IDD_DIRLIST, LM_INSERTITEM,%@NL@%
                                  MPFROM2SHORT (LIT_SORTASCENDING, 0),%@NL@%
                                  MPFROMP (findbuf.achName)) ;%@NL@%
%@NL@%
          DosFindNext (hDir, &findbuf, sizeof findbuf, &usSearchCount) ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
VOID FillFileListBox (HWND hwnd)%@NL@%
     {%@NL@%
     FILEFINDBUF findbuf ;%@NL@%
     HDIR        hDir = 1 ;%@NL@%
     USHORT      usSearchCount = 1 ;%@NL@%
%@NL@%
     WinSendDlgItemMsg (hwnd, IDD_FILELIST, LM_DELETEALL, NULL, NULL) ;%@NL@%
%@NL@%
     DosFindFirst ("*.*", &hDir, 0x0007, &findbuf, sizeof findbuf,%@NL@%
                              &usSearchCount, 0L) ;%@NL@%
     while (usSearchCount)%@NL@%
          {%@NL@%
          WinSendDlgItemMsg (hwnd, IDD_FILELIST, LM_INSERTITEM,%@NL@%
                             MPFROM2SHORT (LIT_SORTASCENDING, 0),%@NL@%
                             MPFROMP (findbuf.achName)) ;%@NL@%
%@NL@%
          DosFindNext (hDir, &findbuf, sizeof findbuf, &usSearchCount) ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY OpenDlgProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR szCurrentPath [80], szBuffer [80] ;%@NL@%
     SHORT       sSelect ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_INITDLG:%@NL@%
               FillDirListBox (hwnd, szCurrentPath) ;%@NL@%
               FillFileListBox (hwnd) ;%@NL@%
%@NL@%
               WinSendDlgItemMsg (hwnd, IDD_FILEEDIT, EM_SETTEXTLIMIT,%@NL@%
                                        MPFROM2SHORT (80, 0), NULL) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CONTROL:%@NL@%
               if (SHORT1FROMMP (mp1) == IDD_DIRLIST ||%@NL@%
                   SHORT1FROMMP (mp1) == IDD_FILELIST)%@NL@%
                    {%@NL@%
                    sSelect = (USHORT) WinSendDlgItemMsg (hwnd,%@NL@%
                                                  SHORT1FROMMP (mp1),%@NL@%
                                                  LM_QUERYSELECTION, 0L, 0L) ;%@NL@%
%@NL@%
                    WinSendDlgItemMsg (hwnd, SHORT1FROMMP (mp1),%@NL@%
                                       LM_QUERYITEMTEXT,%@NL@%
                                       MPFROM2SHORT (sSelect, sizeof szBuffer),%@NL@%
                                       MPFROMP (szBuffer)) ;%@NL@%
                    }%@NL@%
%@NL@%
               switch (SHORT1FROMMP (mp1))             // Control ID%@NL@%
                    {%@NL@%
                    case IDD_DIRLIST:%@NL@%
                         switch (SHORT2FROMMP (mp1))   // notification code%@NL@%
                              {%@NL@%
                              case LN_ENTER:%@NL@%
                                   if (szBuffer [0] == ' ')%@NL@%
                                        DosSelectDisk (szBuffer [1] - '@') ;%@NL@%
                                   else%@NL@%
                                        DosChDir (szBuffer, 0L) ;%@NL@%
%@NL@%
                                   FillDirListBox (hwnd, szCurrentPath) ;%@NL@%
                                   FillFileListBox (hwnd) ;%@NL@%
%@NL@%
                                   WinSetDlgItemText (hwnd, IDD_FILEEDIT, "") ;%@NL@%
                                   return 0 ;%@NL@%
                              }%@NL@%
                         break ;%@NL@%
%@NL@%
                    case IDD_FILELIST:%@NL@%
                         switch (SHORT2FROMMP (mp1))   // notification code%@NL@%
                              {%@NL@%
                              case LN_SELECT:%@NL@%
                                   WinSetDlgItemText (hwnd, IDD_FILEEDIT,%@NL@%
                                                      szBuffer) ;%@NL@%
                                   return 0 ;%@NL@%
%@NL@%
                              case LN_ENTER:%@NL@%
                                   ParseFileName (szFileName, szBuffer) ;%@NL@%
                                   WinDismissDlg (hwnd, TRUE) ;%@NL@%
                                   return 0 ;%@NL@%
                              }%@NL@%
                         break ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case DID_OK:%@NL@%
                         WinQueryDlgItemText (hwnd, IDD_FILEEDIT,%@NL@%
                                              sizeof szBuffer, szBuffer) ;%@NL@%
%@NL@%
                         switch (ParseFileName (szCurrentPath, szBuffer))%@NL@%
                              {%@NL@%
                              case 0:%@NL@%
                                   WinAlarm (HWND_DESKTOP, WA_ERROR) ;%@NL@%
                                   FillDirListBox (hwnd, szCurrentPath) ;%@NL@%
                                   FillFileListBox (hwnd) ;%@NL@%
                                   return 0 ;%@NL@%
%@NL@%
                              case 1:%@NL@%
                                   FillDirListBox (hwnd, szCurrentPath) ;%@NL@%
                                   FillFileListBox (hwnd) ;%@NL@%
                                   WinSetDlgItemText (hwnd, IDD_FILEEDIT, "") ;%@NL@%
                                   return 0 ;%@NL@%
%@NL@%
                              case 2:%@NL@%
                                   strcpy (szFileName, szCurrentPath) ;%@NL@%
                                   WinDismissDlg (hwnd, TRUE) ;%@NL@%
                                   return 0 ;%@NL@%
                              }%@NL@%
                         break ;%@NL@%
%@NL@%
                    case DID_CANCEL:%@NL@%
                         WinDismissDlg (hwnd, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
          }%@NL@%
     return WinDefDlgProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
SHORT ParseFileName (CHAR *pcOut, CHAR *pcIn)%@NL@%
     {%@NL@%
          %@AB@%/*----------------------------------------------------------------%@NL@%
%@AB@%             Input:    pcOut -- Pointer to parsed file specification.%@NL@%
%@AB@%                       pcIn  -- Pointer to raw file specification.%@NL@%
%@AB@%                       %@NL@%
%@AB@%             Returns:  0 -- pcIn had invalid drive or directory.%@NL@%
%@AB@%                       1 -- pcIn was empty or had no filename.%@NL@%
%@AB@%                       2 -- pcOut points to drive, full dir, and file name.%@NL@%
%@AB@%%@NL@%
%@AB@%             Changes current drive and directory per pcIn string.%@NL@%
%@AB@%            ----------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
     CHAR   *pcLastSlash, *pcFileOnly ;%@NL@%
     ULONG  ulDriveMap ;%@NL@%
     USHORT usDriveNum, usDirLen = 64 ;%@NL@%
%@NL@%
     strupr (pcIn) ;%@NL@%
%@NL@%
               // If input string is empty, return 1%@NL@%
%@NL@%
     if (pcIn [0] == '\0')%@NL@%
          return 1 ;%@NL@%
%@NL@%
               // Get drive from input string or current drive%@NL@%
%@NL@%
     if (pcIn [1] == ':')%@NL@%
          {%@NL@%
          if (DosSelectDisk (pcIn [0] - '@'))%@NL@%
               return 0 ;%@NL@%
%@NL@%
          pcIn += 2 ;%@NL@%
          }%@NL@%
     DosQCurDisk (&usDriveNum, &ulDriveMap) ;%@NL@%
%@NL@%
     *pcOut++ = (CHAR) usDriveNum + '@' ;%@NL@%
     *pcOut++ = ':' ;%@NL@%
     *pcOut++ = '\\' ;%@NL@%
%@NL@%
               // If rest of string is empty, return 1%@NL@%
%@NL@%
     if (pcIn [0] == '\0')%@NL@%
          return 1 ;%@NL@%
%@NL@%
               // Search for last backslash.  If none, could be directory.%@NL@%
%@NL@%
     if (NULL == (pcLastSlash = strrchr (pcIn, '\\')))%@NL@%
          {%@NL@%
          if (!DosChDir (pcIn, 0L))%@NL@%
               return 1 ;%@NL@%
%@NL@%
                    // Otherwise, get current dir & attach input filename%@NL@%
%@NL@%
          DosQCurDir (0, pcOut, &usDirLen) ;%@NL@%
%@NL@%
          if (strlen (pcIn) > 12)%@NL@%
               return 0 ;%@NL@%
%@NL@%
          if (*(pcOut + strlen (pcOut) - 1) != '\\')%@NL@%
               strcat (pcOut++, "\\") ;%@NL@%
%@NL@%
          strcat (pcOut, pcIn) ;%@NL@%
          return 2 ;%@NL@%
          }%@NL@%
               // If the only backslash is at beginning, change to root%@NL@%
%@NL@%
     if (pcIn == pcLastSlash)%@NL@%
          {%@NL@%
          DosChDir ("\\", 0L) ;%@NL@%
%@NL@%
          if (pcIn [1] == '\0')%@NL@%
               return 1 ;%@NL@%
%@NL@%
          strcpy (pcOut, pcIn + 1) ;%@NL@%
          return 2 ;%@NL@%
          }%@NL@%
               // Attempt to change directory -- Get current dir if OK%@NL@%
%@NL@%
     *pcLastSlash = '\0' ;%@NL@%
%@NL@%
     if (DosChDir (pcIn, 0L))%@NL@%
          return 0 ;%@NL@%
%@NL@%
     DosQCurDir (0, pcOut, &usDirLen) ;%@NL@%
%@NL@%
               // Append input filename, if any%@NL@%
%@NL@%
     pcFileOnly = pcLastSlash + 1 ;%@NL@%
%@NL@%
     if (*pcFileOnly == '\0')%@NL@%
          return 1 ;%@NL@%
%@NL@%
     if (strlen (pcFileOnly) > 12)%@NL@%
          return 0 ;%@NL@%
%@NL@%
     if (*(pcOut + strlen (pcOut) - 1) != '\\')%@NL@%
          strcat (pcOut++, "\\") ;%@NL@%
%@NL@%
     strcat (pcOut, pcFileOnly) ;%@NL@%
     return 2 ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%HELLOBIT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP06\HELLOBIT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------%@NL@%
%@AB@%   HELLOBIT.C -- "Hello, world" Bitmap%@NL@%
%@AB@%  -------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "HelloBit" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR      szHello [] = " Hello, world " ;%@NL@%
     static HBITMAP   hbm ;%@NL@%
     static HDC       hdcMemory ;%@NL@%
     static HPS       hpsMemory ;%@NL@%
     static SHORT     cxClient, cyClient, cxString, cyString ;%@NL@%
     BITMAPINFOHEADER bmp ;%@NL@%
     HPS              hps ;%@NL@%
     POINTL           aptl [4], ptl ;%@NL@%
     SHORT            x, y ;%@NL@%
     SIZEL            sizl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
%@NL@%
                         %@AB@%/*-------------------------------------------------%@NL@%
%@AB@%                            Open memory DC and create PS associated with it%@NL@%
%@AB@%                           -------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
               hdcMemory = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
%@NL@%
               sizl.cx = 0 ;%@NL@%
               sizl.cy = 0 ;%@NL@%
               hpsMemory = GpiCreatePS (hab, hdcMemory, &sizl,%@NL@%
                                        PU_PELS    | GPIF_DEFAULT |%@NL@%
                                        GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
                         %@AB@%/*-------------------------------------%@NL@%
%@AB@%                            Determine dimensions of text string%@NL@%
%@AB@%                           -------------------------------------*/%@AE@%%@NL@%
%@NL@%
               GpiQueryTextBox (hpsMemory, sizeof szHello - 1L,%@NL@%
                                szHello, 4L, aptl) ;%@NL@%
%@NL@%
               cxString = (SHORT) (aptl [TXTBOX_TOPRIGHT].x -%@NL@%
                                   aptl [TXTBOX_TOPLEFT].x) ;%@NL@%
%@NL@%
               cyString = (SHORT) (aptl [TXTBOX_TOPLEFT].y -%@NL@%
                                   aptl [TXTBOX_BOTTOMLEFT].y) ;%@NL@%
%@NL@%
                         %@AB@%/*-------------------------------------------%@NL@%
%@AB@%                            Create bitmap and set it in the memory PS%@NL@%
%@AB@%                           -------------------------------------------*/%@AE@%%@NL@%
%@NL@%
               bmp.cbFix     = sizeof bmp ;%@NL@%
               bmp.cx        = cxString ;%@NL@%
               bmp.cy        = cyString ;%@NL@%
               bmp.cPlanes   = 1 ;%@NL@%
               bmp.cBitCount = 1 ;%@NL@%
%@NL@%
               hbm = GpiCreateBitmap (hpsMemory, &bmp, 0L, 0L, NULL) ;%@NL@%
%@NL@%
               GpiSetBitmap (hpsMemory, hbm) ;%@NL@%
%@NL@%
                         %@AB@%/*----------------------------------------%@NL@%
%@AB@%                            Write the text string to the memory PS%@NL@%
%@AB@%                           ----------------------------------------*/%@AE@%%@NL@%
%@NL@%
               ptl.x = 0 ;%@NL@%
               ptl.y = - aptl [TXTBOX_BOTTOMLEFT].y ;%@NL@%
%@NL@%
               GpiSetColor (hpsMemory, CLR_TRUE) ;%@NL@%
               GpiSetBackColor (hpsMemory, CLR_FALSE) ;%@NL@%
               GpiSetBackMix (hpsMemory, BM_OVERPAINT) ;%@NL@%
               GpiCharStringAt (hpsMemory, &ptl, sizeof szHello - 1L,%@NL@%
                                szHello) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               for (y = 0 ; y <= cyClient / cyString ; y++)%@NL@%
                    for (x = 0 ; x <= cxClient / cxString ; x++)%@NL@%
                         {%@NL@%
                         aptl[0].x = x * cxString ;    // target lower left%@NL@%
                         aptl[0].y = y * cyString ;%@NL@%
%@NL@%
                         aptl[1].x = aptl[0].x + cxString ; // upper right%@NL@%
                         aptl[1].y = aptl[0].y + cyString ;%@NL@%
%@NL@%
                         aptl[2].x = 0 ;               // source lower left%@NL@%
                         aptl[2].y = 0 ;%@NL@%
%@NL@%
                         GpiBitBlt (hps, hpsMemory, 3L, aptl, ROP_SRCCOPY,%@NL@%
                                    BBO_AND) ;%@NL@%
                         }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               GpiDestroyPS (hpsMemory) ;%@NL@%
               DevCloseDC (hdcMemory) ;%@NL@%
               GpiDeleteBitmap (hbm) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%HEXCALC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP14\HEXCALC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------%@NL@%
%@AB@%   HEXCALC.C -- Hexadecimal Calculator%@NL@%
%@AB@%  -------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<ctype.h> %@NL@%
%@AI@%#include %@AE@%<limits.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"hexcalc.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     HAB  hab ;%@NL@%
     HMQ  hmq ;%@NL@%
     HWND hwndFrame ;%@NL@%
     QMSG qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, CLIENTCLASS, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinLoadDlg (HWND_DESKTOP, HWND_DESKTOP,%@NL@%
                             NULL, NULL, ID_HEXCALC, NULL) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinLoadPointer (HWND_DESKTOP, NULL, ID_ICON), NULL) ;%@NL@%
%@NL@%
     WinSetFocus (HWND_DESKTOP, WinWindowFromID (hwndFrame, FID_CLIENT)) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
void ShowNumber (HWND hwnd, ULONG ulNumber)%@NL@%
     {%@NL@%
     CHAR szBuffer [20] ;%@NL@%
%@NL@%
     WinSetWindowText (WinWindowFromID (hwnd, ESCAPE),%@NL@%
                       strupr (ltoa (ulNumber, szBuffer, 16))) ;%@NL@%
     }%@NL@%
%@NL@%
ULONG CalcIt (ULONG ulFirstNum, SHORT sOperation, ULONG ulNum)%@NL@%
     {%@NL@%
     switch (sOperation)%@NL@%
          {%@NL@%
          case '=' : return ulNum ;%@NL@%
          case '+' : return ulFirstNum +  ulNum ;%@NL@%
          case '-' : return ulFirstNum -  ulNum ;%@NL@%
          case '*' : return ulFirstNum *  ulNum ;%@NL@%
          case '&' : return ulFirstNum &  ulNum ;%@NL@%
          case '|' : return ulFirstNum |  ulNum ;%@NL@%
          case '^' : return ulFirstNum ^  ulNum ;%@NL@%
          case '<' : return ulFirstNum << ulNum ;%@NL@%
          case '>' : return ulFirstNum >> ulNum ;%@NL@%
          case '/' : return ulNum ? ulFirstNum / ulNum : ULONG_MAX ;%@NL@%
          case '%' : return ulNum ? ulFirstNum % ulNum : ULONG_MAX ;%@NL@%
          default  : return 0L ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL  fNewNumber = TRUE ;%@NL@%
     static ULONG ulNumber, ulFirstNum ;%@NL@%
     static SHORT sOperation = '=' ;%@NL@%
     HWND         hwndButton ;%@NL@%
     SHORT        idButton ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CHAR:%@NL@%
               if (CHARMSG(&msg)->fs & KC_KEYUP)%@NL@%
                    return 0 ;%@NL@%
%@NL@%
               if (CHARMSG(&msg)->fs & KC_VIRTUALKEY)%@NL@%
                    switch (CHARMSG(&msg)->vkey)%@NL@%
                         {%@NL@%
                         case VK_LEFT:%@NL@%
                              if (!(CHARMSG(&msg)->fs & KC_CHAR))%@NL@%
                                   {%@NL@%
                                   CHARMSG(&msg)->chr = '\b' ;%@NL@%
                                   CHARMSG(&msg)->fs |= KC_CHAR ;%@NL@%
                                   }%@NL@%
                              break ;%@NL@%
%@NL@%
                         case VK_ESC:%@NL@%
                              CHARMSG(&msg)->chr = ESCAPE ;%@NL@%
                              CHARMSG(&msg)->fs |= KC_CHAR ;%@NL@%
                              break ;%@NL@%
%@NL@%
                         case VK_NEWLINE:%@NL@%
                         case VK_ENTER:%@NL@%
                              CHARMSG(&msg)->chr = '=' ;%@NL@%
                              CHARMSG(&msg)->fs |= KC_CHAR ;%@NL@%
                              break ;%@NL@%
                         }%@NL@%
%@NL@%
               if (CHARMSG(&msg)->fs & KC_CHAR)%@NL@%
                    {%@NL@%
                    CHARMSG(&msg)->chr = toupper (CHARMSG(&msg)->chr) ;%@NL@%
%@NL@%
                    if (hwndButton = WinWindowFromID (hwnd,CHARMSG(&msg)->chr))%@NL@%
                         WinSendMsg (hwndButton, BM_CLICK, NULL, NULL) ;%@NL@%
                    else%@NL@%
                         WinAlarm (HWND_DESKTOP, WA_ERROR) ;%@NL@%
                    }%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               idButton = COMMANDMSG(&msg)->cmd ;%@NL@%
%@NL@%
               if (idButton == '\b')                        // backspace%@NL@%
                    ShowNumber (hwnd, ulNumber /= 16) ;%@NL@%
%@NL@%
               else if (idButton == ESCAPE)                 // escape%@NL@%
                    ShowNumber (hwnd, ulNumber = 0L) ;%@NL@%
%@NL@%
               else if (isxdigit (idButton))                // hex digit%@NL@%
                    {%@NL@%
                    if (fNewNumber)%@NL@%
                         {%@NL@%
                         ulFirstNum = ulNumber ;%@NL@%
                         ulNumber = 0L ;%@NL@%
                         }%@NL@%
                    fNewNumber = FALSE ;%@NL@%
%@NL@%
                    if (ulNumber <= ULONG_MAX >> 4)%@NL@%
                         ShowNumber (hwnd,%@NL@%
                              ulNumber = 16 * ulNumber + idButton -%@NL@%
                                   (isdigit (idButton) ? '0' : 'A' - 10)) ;%@NL@%
                    else%@NL@%
                         WinAlarm (HWND_DESKTOP, WA_ERROR) ;%@NL@%
                    }%@NL@%
               else                                         // operation%@NL@%
                    {%@NL@%
                    if (!fNewNumber)%@NL@%
                         ShowNumber (hwnd, ulNumber =%@NL@%
                              CalcIt (ulFirstNum, sOperation, ulNumber)) ;%@NL@%
                    fNewNumber = TRUE ;%@NL@%
                    sOperation = idButton ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               WinAlarm (HWND_DESKTOP, WA_ERROR) ;%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%HEXCALC2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP15\HEXCALC2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------------------------------%@NL@%
%@AB@%   HEXCALC2.C -- Hexadecimal Calculator with Clipboard Cut and Paste%@NL@%
%@AB@%  -------------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<ctype.h> %@NL@%
%@AI@%#include %@AE@%<limits.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"hexcalc.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%IDM_COPY    256 %@NL@%
%@AI@%#define %@AE@%IDM_PASTE   257 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     HMQ  hmq ;%@NL@%
     HWND hwndFrame ;%@NL@%
     QMSG qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, CLIENTCLASS, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinLoadDlg (HWND_DESKTOP, HWND_DESKTOP,%@NL@%
                             NULL, NULL, ID_HEXCALC, NULL) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinLoadPointer (HWND_DESKTOP, NULL, ID_ICON), NULL) ;%@NL@%
%@NL@%
     WinSetFocus (HWND_DESKTOP, WinWindowFromID (hwndFrame, FID_CLIENT)) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
HACCEL AddItemsToSysMenu (HWND hwndFrame)%@NL@%
     {%@NL@%
     static CHAR     *szMenuText [3] = { NULL, "~Copy\tCtrl+Ins",%@NL@%
                                               "~Paste\tShift+Ins" } ;%@NL@%
     static MENUITEM mi [3] = {%@NL@%
                              MIT_END, MIS_SEPARATOR, 0, 0,         NULL, NULL,%@NL@%
                              MIT_END, MIS_TEXT,      0, IDM_COPY,  NULL, NULL,%@NL@%
                              MIT_END, MIS_TEXT,      0, IDM_PASTE, NULL, NULL%@NL@%
                              } ;%@NL@%
     ACCELTABLE      *pacct ;%@NL@%
     HACCEL          haccel ;%@NL@%
     HWND            hwndSysMenu, hwndSysSubMenu ;%@NL@%
     MENUITEM        miSysMenu ;%@NL@%
     SHORT           idSysMenu, sItem ;%@NL@%
%@NL@%
                              // Add items to system menu%@NL@%
%@NL@%
     hwndSysMenu = WinWindowFromID (hwndFrame, FID_SYSMENU) ;%@NL@%
     idSysMenu = SHORT1FROMMR (WinSendMsg (hwndSysMenu,%@NL@%
                                           MM_ITEMIDFROMPOSITION,%@NL@%
                                           NULL, NULL)) ;%@NL@%
%@NL@%
     WinSendMsg (hwndSysMenu, MM_QUERYITEM,%@NL@%
                 MPFROM2SHORT (idSysMenu, FALSE),%@NL@%
                 MPFROMP (&miSysMenu)) ;%@NL@%
%@NL@%
     hwndSysSubMenu = miSysMenu.hwndSubMenu ;%@NL@%
%@NL@%
     for (sItem = 0 ; sItem < 3 ; sItem++)%@NL@%
          WinSendMsg (hwndSysSubMenu, MM_INSERTITEM,%@NL@%
                      MPFROMP (mi + sItem),%@NL@%
                      MPFROMP (szMenuText [sItem])) ;%@NL@%
%@NL@%
                              // Create and set accelerator table%@NL@%
%@NL@%
     pacct = malloc (sizeof (ACCELTABLE) + sizeof (ACCEL)) ;%@NL@%
%@NL@%
     pacct->cAccel        = 2 ;    // Number of accelerators%@NL@%
     pacct->codepage      = 0 ;    // Not used%@NL@%
%@NL@%
     pacct->aaccel[0].fs  = AF_VIRTUALKEY | AF_CONTROL ;%@NL@%
     pacct->aaccel[0].key = VK_INSERT ;%@NL@%
     pacct->aaccel[0].cmd = IDM_COPY ;%@NL@%
%@NL@%
     pacct->aaccel[1].fs  = AF_VIRTUALKEY | AF_SHIFT ;%@NL@%
     pacct->aaccel[1].key = VK_INSERT ;%@NL@%
     pacct->aaccel[1].cmd = IDM_PASTE ;%@NL@%
%@NL@%
     haccel = WinCreateAccelTable (hab, pacct) ;%@NL@%
     WinSetAccelTable (hab, haccel, hwndFrame) ;%@NL@%
%@NL@%
     free (pacct) ;%@NL@%
%@NL@%
     return haccel ;%@NL@%
     }%@NL@%
%@NL@%
VOID EnableSysMenuItem (HWND hwnd, USHORT idItem, BOOL fEnable)%@NL@%
     {%@NL@%
     HWND hwndSysMenu ;%@NL@%
%@NL@%
     hwndSysMenu = WinWindowFromID (WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                                    FID_SYSMENU) ;%@NL@%
%@NL@%
     WinSendMsg (hwndSysMenu, MM_SETITEMATTR,%@NL@%
                 MPFROM2SHORT (idItem, TRUE),%@NL@%
                 MPFROM2SHORT (MIA_DISABLED, fEnable ? 0 : MIA_DISABLED)) ;%@NL@%
     }%@NL@%
%@NL@%
void ShowNumber (HWND hwnd, ULONG ulNumber)%@NL@%
     {%@NL@%
     CHAR szBuffer [20] ;%@NL@%
%@NL@%
     WinSetWindowText (WinWindowFromID (hwnd, ESCAPE),%@NL@%
                       strupr (ltoa (ulNumber, szBuffer, 16))) ;%@NL@%
     }%@NL@%
%@NL@%
ULONG CalcIt (ULONG ulFirstNum, SHORT sOperation, ULONG ulNum)%@NL@%
     {%@NL@%
     switch (sOperation)%@NL@%
          {%@NL@%
          case '=' : return ulNum ;%@NL@%
          case '+' : return ulFirstNum +  ulNum ;%@NL@%
          case '-' : return ulFirstNum -  ulNum ;%@NL@%
          case '*' : return ulFirstNum *  ulNum ;%@NL@%
          case '&' : return ulFirstNum &  ulNum ;%@NL@%
          case '|' : return ulFirstNum |  ulNum ;%@NL@%
          case '^' : return ulFirstNum ^  ulNum ;%@NL@%
          case '<' : return ulFirstNum << ulNum ;%@NL@%
          case '>' : return ulFirstNum >> ulNum ;%@NL@%
          case '/' : return ulNum ? ulFirstNum / ulNum : ULONG_MAX ;%@NL@%
          case '%' : return ulNum ? ulFirstNum % ulNum : ULONG_MAX ;%@NL@%
          default  : return 0L ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL   fNewNumber = TRUE ;%@NL@%
     static HACCEL haccel ;%@NL@%
     static ULONG  ulNumber, ulFirstNum ;%@NL@%
     static SHORT  sOperation = '=' ;%@NL@%
     HWND          hwndButton ;%@NL@%
     PCHAR         pchClipText ;%@NL@%
     QMSG          qmsg ;%@NL@%
     SEL           selClipText ;%@NL@%
     SHORT         s, sLen, idButton ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               haccel = AddItemsToSysMenu (%@NL@%
                              WinQueryWindow (hwnd, QW_PARENT, FALSE)) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               if (CHARMSG(&msg)->fs & KC_KEYUP)%@NL@%
                    return 0 ;%@NL@%
%@NL@%
               if (CHARMSG(&msg)->fs & KC_VIRTUALKEY)%@NL@%
                    switch (CHARMSG(&msg)->vkey)%@NL@%
                         {%@NL@%
                         case VK_LEFT:%@NL@%
                              if (!(CHARMSG(&msg)->fs & KC_CHAR))%@NL@%
                                   {%@NL@%
                                   CHARMSG(&msg)->chr = '\b' ;%@NL@%
                                   CHARMSG(&msg)->fs |= KC_CHAR ;%@NL@%
                                   }%@NL@%
                              break ;%@NL@%
%@NL@%
                         case VK_ESC:%@NL@%
                              CHARMSG(&msg)->chr = ESCAPE ;%@NL@%
                              CHARMSG(&msg)->fs |= KC_CHAR ;%@NL@%
                              break ;%@NL@%
%@NL@%
                         case VK_NEWLINE:%@NL@%
                         case VK_ENTER:%@NL@%
                              CHARMSG(&msg)->chr = '=' ;%@NL@%
                              CHARMSG(&msg)->fs |= KC_CHAR ;%@NL@%
                              break ;%@NL@%
                         }%@NL@%
%@NL@%
               if (CHARMSG(&msg)->fs & KC_CHAR)%@NL@%
                    {%@NL@%
                    CHARMSG(&msg)->chr = toupper (CHARMSG(&msg)->chr) ;%@NL@%
%@NL@%
                    if (hwndButton = WinWindowFromID (hwnd,CHARMSG(&msg)->chr))%@NL@%
                         WinSendMsg (hwndButton, BM_CLICK, NULL, NULL) ;%@NL@%
                    else%@NL@%
                         WinAlarm (HWND_DESKTOP, WA_ERROR) ;%@NL@%
                    }%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               idButton = COMMANDMSG(&msg)->cmd ;%@NL@%
%@NL@%
               if (idButton == IDM_COPY)                    // "Copy"%@NL@%
                    {%@NL@%
                    hwndButton = WinWindowFromID (hwnd, ESCAPE) ;%@NL@%
                    sLen = WinQueryWindowTextLength (hwndButton) + 1 ;%@NL@%
%@NL@%
                    DosAllocSeg (sLen, &selClipText, SEG_GIVEABLE) ;%@NL@%
                    pchClipText = MAKEP (selClipText, 0) ;%@NL@%
                    WinQueryWindowText (hwndButton, sLen, pchClipText) ;%@NL@%
%@NL@%
                    WinOpenClipbrd (hab) ;%@NL@%
                    WinEmptyClipbrd (hab) ;%@NL@%
                    WinSetClipbrdData (hab, (ULONG) selClipText, CF_TEXT,%@NL@%
                                       CFI_SELECTOR) ;%@NL@%
                    WinCloseClipbrd (hab) ;%@NL@%
                    }%@NL@%
%@NL@%
               else if (idButton == IDM_PASTE)              // "Paste"%@NL@%
                    {%@NL@%
                    EnableSysMenuItem (hwnd, IDM_COPY,  FALSE) ;%@NL@%
                    EnableSysMenuItem (hwnd, IDM_PASTE, FALSE) ;%@NL@%
%@NL@%
                    WinOpenClipbrd (hab) ;%@NL@%
%@NL@%
                    selClipText = (SEL) WinQueryClipbrdData (hab, CF_TEXT) ;%@NL@%
%@NL@%
                    if (selClipText != 0)%@NL@%
                         {%@NL@%
                         pchClipText = MAKEP (selClipText, 0) ;%@NL@%
%@NL@%
                         for (s = 0 ; pchClipText[s] ; s++)%@NL@%
                              {%@NL@%
                              if (pchClipText[s] == '\r')%@NL@%
                                   WinSendMsg (hwnd, WM_CHAR,%@NL@%
                                               MPFROM2SHORT (KC_CHAR, 1),%@NL@%
                                               MPFROM2SHORT ('=', 0)) ;%@NL@%
%@NL@%
                              else if (pchClipText[s] != '\n' &&%@NL@%
                                       pchClipText[s] != ' ')%@NL@%
                                   WinSendMsg (hwnd, WM_CHAR,%@NL@%
                                               MPFROM2SHORT (KC_CHAR, 1),%@NL@%
                                               MPFROM2SHORT (pchClipText[s],%@NL@%
                                                             0)) ;%@NL@%
%@NL@%
                              while (WinPeekMsg (hab, &qmsg, NULL, 0, 0,%@NL@%
                                                 PM_NOREMOVE))%@NL@%
                                   {%@NL@%
                                   if (qmsg.msg == WM_QUIT)%@NL@%
                                        {%@NL@%
                                        WinCloseClipbrd (hab) ;%@NL@%
                                        return 0 ;%@NL@%
                                        }%@NL@%
                                   else%@NL@%
                                        {%@NL@%
                                        WinGetMsg (hab, &qmsg, NULL, 0, 0) ;%@NL@%
                                        WinDispatchMsg (hab, &qmsg) ;%@NL@%
                                        }%@NL@%
                                   }%@NL@%
                              }%@NL@%
                         }%@NL@%
                    WinCloseClipbrd (hab) ;%@NL@%
%@NL@%
                    EnableSysMenuItem (hwnd, IDM_COPY,  TRUE) ;%@NL@%
                    EnableSysMenuItem (hwnd, IDM_PASTE, TRUE) ;%@NL@%
                    }%@NL@%
%@NL@%
               else if (idButton == '\b')                   // backspace%@NL@%
                    ShowNumber (hwnd, ulNumber /= 16) ;%@NL@%
%@NL@%
               else if (idButton == ESCAPE)                 // escape%@NL@%
                    ShowNumber (hwnd, ulNumber = 0L) ;%@NL@%
%@NL@%
               else if (isxdigit (idButton))                // hex digit%@NL@%
                    {%@NL@%
                    if (fNewNumber)%@NL@%
                         {%@NL@%
                         ulFirstNum = ulNumber ;%@NL@%
                         ulNumber = 0L ;%@NL@%
                         }%@NL@%
                    fNewNumber = FALSE ;%@NL@%
%@NL@%
                    if (ulNumber <= ULONG_MAX >> 4)%@NL@%
                         ShowNumber (hwnd,%@NL@%
                              ulNumber = 16 * ulNumber + idButton -%@NL@%
                                   (isdigit (idButton) ? '0' : 'A' - 10)) ;%@NL@%
                    else%@NL@%
                         WinAlarm (HWND_DESKTOP, WA_ERROR) ;%@NL@%
                    }%@NL@%
               else                                         // operation%@NL@%
                    {%@NL@%
                    if (!fNewNumber)%@NL@%
                         ShowNumber (hwnd, ulNumber =%@NL@%
                              CalcIt (ulFirstNum, sOperation, ulNumber)) ;%@NL@%
                    fNewNumber = TRUE ;%@NL@%
                    sOperation = idButton ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               WinAlarm (HWND_DESKTOP, WA_ERROR) ;%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               WinDestroyAccelTable (haccel) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%IMAGECAT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\IMAGECAT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------%@NL@%
%@AB@%   IMAGECAT.C -- Cat drawn using GpiImage%@NL@%
%@AB@%  ----------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "ImageCat" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BYTE  abCat [] = { %@NL@%
                             0x01, 0xF8, 0x1F, 0x80, 0x01, 0x04, 0x20, 0x80, %@NL@%
                             0x00, 0x8F, 0xF1, 0x00, 0x00, 0x48, 0x12, 0x00, %@NL@%
                             0x00, 0x28, 0x14, 0x00, 0x00, 0x1A, 0x58, 0x00, %@NL@%
                             0x00, 0x08, 0x10, 0x00, 0x00, 0xFC, 0x3F, 0x00, %@NL@%
                             0x00, 0x09, 0x90, 0x00, 0x00, 0xFC, 0x3F, 0x00, %@NL@%
                             0x00, 0x08, 0x10, 0x00, 0x00, 0x07, 0xE0, 0x00, %@NL@%
                             0x00, 0x08, 0x10, 0x00, 0x00, 0x08, 0x10, 0xC0, %@NL@%
                             0x00, 0x08, 0x10, 0x20, 0x00, 0x10, 0x08, 0x10,%@NL@%
                             0x00, 0x10, 0x08, 0x08, 0x00, 0x10, 0x08, 0x04,%@NL@%
                             0x00, 0x20, 0x04, 0x04, 0x00, 0x20, 0x04, 0x04, %@NL@%
                             0x00, 0x20, 0x04, 0x04, 0x00, 0x40, 0x02, 0x04, %@NL@%
                             0x00, 0x40, 0x02, 0x04, 0x00, 0x40, 0x02, 0x04, %@NL@%
                             0x00, 0xC0, 0x03, 0x04, 0x00, 0x9C, 0x39, 0x08, %@NL@%
                             0x00, 0xA2, 0x45, 0x08, 0x00, 0xA2, 0x45, 0x10, %@NL@%
                             0x00, 0xA2, 0x45, 0xE0, 0x00, 0xA2, 0x45, 0x00, %@NL@%
                             0x00, 0xA2, 0x45, 0x00, 0x00, 0xFF, 0xFF, 0x00 } ;%@NL@%
     static SHORT cxClient, cyClient ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       ptl ;%@NL@%
     SIZEL        sizl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               ptl.x = cxClient / 2 - 16 ;%@NL@%
               ptl.y = cyClient / 2 + 16 ;%@NL@%
               GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
               sizl.cx = 32 ;%@NL@%
               sizl.cy = 32 ;%@NL@%
               GpiImage (hps, 0L, &sizl, (LONG) sizeof abCat, abCat) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%KEYLOOK.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP08\KEYLOOK.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------%@NL@%
%@AB@%   KEYLOOK.C -- Displays WM_CHAR Messages%@NL@%
%@AB@%  ----------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%"easyfont.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%LCID_FIXEDFONT 1L %@NL@%
%@AI@%#define %@AE@%MAX_KEYS       100 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
CHAR szClientClass [] = "KeyLook" ;%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
     if (hwndFrame != NULL)%@NL@%
          {%@NL@%
          WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                      WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                      NULL) ;%@NL@%
%@NL@%
          while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
               WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
          WinDestroyWindow (hwndFrame) ;%@NL@%
          }%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR   szHeader [] = "Scan  Rept  IN TG IC CM DK LK PD KU"%@NL@%
                                 " AL CT SH SC VK CH  Virt  Char" ;%@NL@%
     static CHAR   szUndrLn [] = "----  ----  -- -- -- -- -- -- -- --"%@NL@%
                                 " -- -- -- -- -- --  ----  ----" ;%@NL@%
     static CHAR   szFormat [] = "%4X %4dx  %2d %2d %2d %2d %2d %2d %2d %2d"%@NL@%
                                 " %2d %2d %2d %2d %2d %2d  %4X  %4X  %c" ;%@NL@%
%@NL@%
     static SHORT  cxChar, cyChar, cyDesc, cxClient, cyClient, sNextKey ;%@NL@%
     static struct {%@NL@%
                   MPARAM mp1 ;%@NL@%
                   MPARAM mp2 ;%@NL@%
                   BOOL   fValid ;%@NL@%
                   }%@NL@%
                   key [MAX_KEYS] ;%@NL@%
     CHAR          szBuffer [80] ;%@NL@%
     FONTMETRICS   fm ;%@NL@%
     HPS           hps ;%@NL@%
     POINTL        ptl ;%@NL@%
     RECTL         rcl, rclInvalid ;%@NL@%
     SHORT         sKey, sIndex, sFlag ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               EzfQueryFonts (hps) ;%@NL@%
%@NL@%
               if (!EzfCreateLogFont (hps, LCID_FIXEDFONT, FONTFACE_COUR,%@NL@%
                                                           FONTSIZE_10, 0))%@NL@%
                    {%@NL@%
                    WinReleasePS (hps) ;%@NL@%
%@NL@%
                    WinMessageBox (HWND_DESKTOP, HWND_DESKTOP,%@NL@%
                         "Cannot find a fixed-pitch font.  Load the Courier "%@NL@%
                         "fonts from the Control Panel and try again.",%@NL@%
                         szClientClass, 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
%@NL@%
                    return 1 ;%@NL@%
                    }%@NL@%
%@NL@%
               GpiSetCharSet (hps, LCID_FIXEDFONT) ;%@NL@%
%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
%@NL@%
               GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
               GpiDeleteSetId (hps, LCID_FIXEDFONT) ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               key [sNextKey].mp1 = mp1 ;%@NL@%
               key [sNextKey].mp2 = mp2 ;%@NL@%
               key [sNextKey].fValid = TRUE ;%@NL@%
%@NL@%
               sNextKey = (sNextKey + 1) % MAX_KEYS ;%@NL@%
%@NL@%
               WinSetRect (hwnd, &rcl,%@NL@%
                           0, 2 * cyChar, cxClient, cyClient - 2 * cyChar) ;%@NL@%
%@NL@%
               WinScrollWindow (hwnd, 0, cyChar, &rcl, &rcl, NULL, NULL,%@NL@%
                                                 SW_INVALIDATERGN) ;%@NL@%
               WinUpdateWindow (hwnd) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, &rclInvalid) ;%@NL@%
               GpiErase (hps) ;%@NL@%
               EzfCreateLogFont (hps, LCID_FIXEDFONT, FONTFACE_COUR,%@NL@%
                                                      FONTSIZE_10, 0) ;%@NL@%
               GpiSetCharSet (hps, LCID_FIXEDFONT) ;%@NL@%
%@NL@%
               ptl.x = cxChar ;%@NL@%
               ptl.y = cyDesc ;%@NL@%
               GpiCharStringAt (hps, &ptl, sizeof szHeader - 1L, szHeader) ;%@NL@%
%@NL@%
               ptl.y += cyChar ;%@NL@%
               GpiCharStringAt (hps, &ptl, sizeof szUndrLn - 1L, szUndrLn) ;%@NL@%
%@NL@%
               for (sKey = 0 ; sKey < MAX_KEYS ; sKey++)%@NL@%
                    {%@NL@%
                    ptl.y += cyChar ;%@NL@%
%@NL@%
                    sIndex = (sNextKey - sKey - 1 + MAX_KEYS) % MAX_KEYS ;%@NL@%
%@NL@%
                    if (ptl.y > rclInvalid.yTop ||%@NL@%
                              ptl.y > cyClient - 2 * cyChar ||%@NL@%
                                   !key [sIndex].fValid)%@NL@%
                         break ;%@NL@%
                         %@NL@%
                    mp1 = key [sIndex].mp1 ;%@NL@%
                    mp2 = key [sIndex].mp2 ;%@NL@%
%@NL@%
                    sFlag = CHARMSG(&msg)->fs ;%@NL@%
%@NL@%
                    GpiCharStringAt (hps, &ptl, %@NL@%
                         (LONG) sprintf (szBuffer, szFormat,%@NL@%
                                   CHARMSG(&msg)->scancode,%@NL@%
                                   CHARMSG(&msg)->cRepeat,%@NL@%
                                   sFlag & KC_INVALIDCHAR ? 1 : 0,%@NL@%
                                   sFlag & KC_TOGGLE      ? 1 : 0,%@NL@%
                                   sFlag & KC_INVALIDCOMP ? 1 : 0,%@NL@%
                                   sFlag & KC_COMPOSITE   ? 1 : 0,%@NL@%
                                   sFlag & KC_DEADKEY     ? 1 : 0,%@NL@%
                                   sFlag & KC_LONEKEY     ? 1 : 0,%@NL@%
                                   sFlag & KC_PREVDOWN    ? 1 : 0,%@NL@%
                                   sFlag & KC_KEYUP       ? 1 : 0,%@NL@%
                                   sFlag & KC_ALT         ? 1 : 0,%@NL@%
                                   sFlag & KC_CTRL        ? 1 : 0,%@NL@%
                                   sFlag & KC_SHIFT       ? 1 : 0,%@NL@%
                                   sFlag & KC_SCANCODE    ? 1 : 0,%@NL@%
                                   sFlag & KC_VIRTUALKEY  ? 1 : 0,%@NL@%
                                   sFlag & KC_CHAR        ? 1 : 0,%@NL@%
                                   CHARMSG(&msg)->vkey,%@NL@%
                                   CHARMSG(&msg)->chr,%@NL@%
                                   sFlag & KC_CHAR ? CHARMSG(&msg)->chr : ' '),%@NL@%
                              szBuffer) ;%@NL@%
                    }%@NL@%
               ptl.y = cyClient - cyChar + cyDesc ;%@NL@%
               GpiCharStringAt (hps, &ptl, sizeof szHeader - 1L, szHeader) ;%@NL@%
%@NL@%
               ptl.y -= cyChar ;%@NL@%
               GpiCharStringAt (hps, &ptl, sizeof szUndrLn - 1L, szUndrLn) ;%@NL@%
%@NL@%
               GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
               GpiDeleteSetId (hps, LCID_FIXEDFONT) ;%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LIFE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP13\LIFE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------%@NL@%
%@AB@%   LIFE.C -- John Conway's Game of Life%@NL@%
%@AB@%  --------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"life.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%ID_TIMER    1 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
CHAR szClientClass [] = "Life" ;%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU          | FCF_ICON ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID EnableMenuItem (HWND hwndMenu, SHORT idMenuItem, BOOL fEnable)%@NL@%
     {%@NL@%
     WinSendMsg (hwndMenu, MM_SETITEMATTR, %@NL@%
                 MPFROM2SHORT (idMenuItem, TRUE),%@NL@%
                 MPFROM2SHORT (MIA_DISABLED, fEnable ? 0 : MIA_DISABLED)) ;%@NL@%
     }%@NL@%
%@NL@%
VOID ErrorMsg (HWND hwnd, CHAR *szMessage)%@NL@%
     {%@NL@%
     WinMessageBox (HWND_DESKTOP, hwnd, szMessage, szClientClass, 0,%@NL@%
                    MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
     }%@NL@%
%@NL@%
VOID DrawCell (HPS hps, SHORT x, SHORT y, SHORT cxCell, SHORT cyCell,%@NL@%
               BYTE bCell)%@NL@%
     {%@NL@%
     RECTL rcl ;%@NL@%
%@NL@%
     rcl.xLeft   = x * cxCell ;%@NL@%
     rcl.yBottom = y * cyCell ;%@NL@%
     rcl.xRight  = rcl.xLeft   + cxCell - 1 ;%@NL@%
     rcl.yTop    = rcl.yBottom + cyCell - 1 ;%@NL@%
%@NL@%
     WinFillRect (hps, &rcl, bCell & 1 ? CLR_NEUTRAL : CLR_BACKGROUND) ;%@NL@%
     }%@NL@%
%@NL@%
VOID DoGeneration (HPS hps, PBYTE pbGrid, SHORT xNumCells, SHORT yNumCells,%@NL@%
                   SHORT cxCell, SHORT cyCell)%@NL@%
     {%@NL@%
     SHORT x, y, sSum ;%@NL@%
%@NL@%
     for (y = 0 ; y < yNumCells - 1 ; y++)%@NL@%
          for (x = 0 ; x < xNumCells ; x++)%@NL@%
               {%@NL@%
               if (x == 0 || x == xNumCells - 1 || y == 0)%@NL@%
                    *pbGrid |= *pbGrid << 4 ;%@NL@%
               else%@NL@%
                    {%@NL@%
                    sSum = (*(pbGrid             - 1) +    // Left%@NL@%
                            *(pbGrid - xNumCells - 1) +    // Lower Left%@NL@%
                            *(pbGrid - xNumCells    ) +    // Lower%@NL@%
                            *(pbGrid - xNumCells + 1))     // Lower Right%@NL@%
                                             >> 4 ;%@NL@%
%@NL@%
                    sSum += *(pbGrid             + 1) +    // Right%@NL@%
                            *(pbGrid + xNumCells + 1) +    // Upper Right%@NL@%
                            *(pbGrid + xNumCells    ) +    // Upper%@NL@%
                            *(pbGrid + xNumCells - 1) ;    // Upper Left%@NL@%
%@NL@%
                    sSum = (sSum | *pbGrid) & 0x0F ;%@NL@%
%@NL@%
                    *pbGrid <<= 4 ;%@NL@%
%@NL@%
                    if (sSum == 3)%@NL@%
                         *pbGrid |= 1 ;%@NL@%
%@NL@%
                    if ((*pbGrid & 1) != *pbGrid >> 4)%@NL@%
                         DrawCell (hps, x, y, cxCell, cyCell, *pbGrid) ;%@NL@%
                    }%@NL@%
               pbGrid++ ;%@NL@%
               }%@NL@%
     }%@NL@%
%@NL@%
VOID DisplayGenerationNum (HPS hps, SHORT xGen, SHORT yGen, LONG lGeneration)%@NL@%
     {%@NL@%
     static CHAR szBuffer [24] = "Generation " ;%@NL@%
     POINTL      ptl ;%@NL@%
%@NL@%
     ptl.x = xGen ;%@NL@%
     ptl.y = yGen ;%@NL@%
%@NL@%
     ltoa (lGeneration, szBuffer + 11, 10) ;%@NL@%
%@NL@%
     GpiSavePS (hps) ;%@NL@%
%@NL@%
     GpiSetBackMix (hps, BM_OVERPAINT) ;%@NL@%
     GpiCharStringAt (hps, &ptl, (LONG) strlen (szBuffer), szBuffer) ;%@NL@%
%@NL@%
     GpiRestorePS (hps, -1L) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL  fTimerGoing ;%@NL@%
     static HWND  hwndMenu ;%@NL@%
     static LONG  lGeneration ;%@NL@%
     static SEL   selGrid ;%@NL@%
     static SHORT cxChar, cyChar, cyDesc, cxClient, cyClient, xGenNum, yGenNum,%@NL@%
                  cxCell, cyCell, xNumCells, yNumCells, sCellScale = 1 ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     HPS          hps ;%@NL@%
     PBYTE        pbGrid ;%@NL@%
     POINTL       ptl ;%@NL@%
     SHORT        x, y ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               hwndMenu = WinWindowFromID (%@NL@%
                               WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                               FID_MENU) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               if (selGrid)%@NL@%
                    {%@NL@%
                    DosFreeSeg (selGrid) ;%@NL@%
                    selGrid = 0 ;%@NL@%
                    }%@NL@%
%@NL@%
               if (fTimerGoing)%@NL@%
                    {%@NL@%
                    WinStopTimer (hab, hwnd, ID_TIMER) ;%@NL@%
                    fTimerGoing = FALSE ;%@NL@%
                    }%@NL@%
%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               xGenNum = cxChar ;%@NL@%
               yGenNum = cyClient - cyChar + cyDesc ;%@NL@%
%@NL@%
               cxCell = cxChar * 2 / sCellScale ;%@NL@%
               cyCell = cyChar / sCellScale ;%@NL@%
%@NL@%
               xNumCells = cxClient / cxCell ;%@NL@%
               yNumCells = (cyClient - cyChar) / cyCell ;%@NL@%
%@NL@%
               if (xNumCells <= 0 || yNumCells <= 0)%@NL@%
                    {%@NL@%
                    ErrorMsg (hwnd, "Not enough room for even one cell.") ;%@NL@%
                    }%@NL@%
%@NL@%
               else if ((LONG) xNumCells * yNumCells > 65536L)%@NL@%
                    {%@NL@%
                    ErrorMsg (hwnd, "More than 64K cells not supported.") ;%@NL@%
                    }%@NL@%
%@NL@%
               else if (DosAllocSeg (xNumCells * yNumCells, &selGrid, 0))%@NL@%
                    {%@NL@%
                    ErrorMsg (hwnd, "Not enough memory for this many cells.") ;%@NL@%
                    selGrid = 0 ;%@NL@%
                    }%@NL@%
%@NL@%
               else%@NL@%
                    {%@NL@%
                    pbGrid = MAKEP (selGrid, 0) ;%@NL@%
%@NL@%
                    for (y = 0 ; y < yNumCells ; y++)%@NL@%
                         for (x = 0 ; x < xNumCells ; x++)%@NL@%
                              *pbGrid++ = 0 ;%@NL@%
                    }%@NL@%
%@NL@%
               EnableMenuItem (hwndMenu, IDM_SIZE,  TRUE) ;%@NL@%
               EnableMenuItem (hwndMenu, IDM_START, selGrid != 0) ;%@NL@%
               EnableMenuItem (hwndMenu, IDM_STOP,  FALSE) ;%@NL@%
               EnableMenuItem (hwndMenu, IDM_STEP,  selGrid != 0) ;%@NL@%
               EnableMenuItem (hwndMenu, IDM_CLEAR, selGrid != 0) ;%@NL@%
%@NL@%
               lGeneration = 0 ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               x = MOUSEMSG(&msg)->x / cxCell ;%@NL@%
               y = MOUSEMSG(&msg)->y / cyCell ;%@NL@%
%@NL@%
               if (selGrid && !fTimerGoing && x < xNumCells && y < yNumCells)%@NL@%
                    {%@NL@%
                    pbGrid = MAKEP (selGrid, 0) ;%@NL@%
%@NL@%
                    hps = WinGetPS (hwnd) ;%@NL@%
%@NL@%
                    DrawCell (hps, x, y, cxCell, cyCell,%@NL@%
                              *(pbGrid + y * xNumCells + x) ^= 1) ;%@NL@%
%@NL@%
                    WinReleasePS (hps) ;%@NL@%
                    }%@NL@%
               else%@NL@%
                    WinAlarm (HWND_DESKTOP, WA_WARNING) ;%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_LARGE:%@NL@%
                    case IDM_SMALL:%@NL@%
                    case IDM_TINY:%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (sCellScale, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_CHECKED, 0)) ;%@NL@%
%@NL@%
                         sCellScale = COMMANDMSG(&msg)->cmd ;%@NL@%
%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (sCellScale, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_CHECKED, MIA_CHECKED)) ;%@NL@%
%@NL@%
                         WinSendMsg (hwnd, WM_SIZE, NULL,%@NL@%
                                     MPFROM2SHORT (cxClient, cyClient)) ;%@NL@%
%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_START:%@NL@%
                         if (!WinStartTimer (hab, hwnd, ID_TIMER, 1))%@NL@%
                              {%@NL@%
                              ErrorMsg (hwnd, "Too many clocks or timers.") ;%@NL@%
                              }%@NL@%
                         else%@NL@%
                              {%@NL@%
                              fTimerGoing = TRUE ;%@NL@%
%@NL@%
                              EnableMenuItem (hwndMenu, IDM_SIZE,  FALSE) ;%@NL@%
                              EnableMenuItem (hwndMenu, IDM_START, FALSE) ;%@NL@%
                              EnableMenuItem (hwndMenu, IDM_STOP,  TRUE) ;%@NL@%
                              EnableMenuItem (hwndMenu, IDM_STEP,  FALSE) ;%@NL@%
                              EnableMenuItem (hwndMenu, IDM_CLEAR, FALSE) ;%@NL@%
                              }%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_STOP:%@NL@%
                         WinStopTimer (hab, hwnd, ID_TIMER) ;%@NL@%
                         fTimerGoing = FALSE ;%@NL@%
%@NL@%
                         EnableMenuItem (hwndMenu, IDM_SIZE,  TRUE) ;%@NL@%
                         EnableMenuItem (hwndMenu, IDM_START, TRUE) ;%@NL@%
                         EnableMenuItem (hwndMenu, IDM_STOP,  FALSE) ;%@NL@%
                         EnableMenuItem (hwndMenu, IDM_STEP,  TRUE) ;%@NL@%
                         EnableMenuItem (hwndMenu, IDM_CLEAR, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_STEP:%@NL@%
                         WinSendMsg (hwnd, WM_TIMER, NULL, NULL) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_CLEAR:%@NL@%
                         lGeneration = 0L ;%@NL@%
%@NL@%
                         pbGrid = MAKEP (selGrid, 0) ;%@NL@%
%@NL@%
                         for (y = 0 ; y < yNumCells ; y++)%@NL@%
                              for (x = 0 ; x < xNumCells ; x++)%@NL@%
                                   *pbGrid++ = 0 ;%@NL@%
%@NL@%
                         WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_TIMER:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
%@NL@%
               DisplayGenerationNum (hps, xGenNum, yGenNum, ++lGeneration) ;%@NL@%
%@NL@%
               pbGrid = MAKEP (selGrid, 0) ;%@NL@%
%@NL@%
               DoGeneration (hps, pbGrid, xNumCells, yNumCells, cxCell, cyCell);%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               if (selGrid)%@NL@%
                    {%@NL@%
                    for (x = 1 ; x <= xNumCells ; x++)%@NL@%
                         {%@NL@%
                         ptl.x = cxCell * x - 1 ;%@NL@%
                         ptl.y = 0 ;%@NL@%
                         GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
                         ptl.y = cyCell * yNumCells - 1 ;%@NL@%
                         GpiLine (hps, &ptl) ;%@NL@%
                         }%@NL@%
%@NL@%
                    for (y = 1 ; y <= yNumCells ; y++)%@NL@%
                         {%@NL@%
                         ptl.x = 0 ;%@NL@%
                         ptl.y = cyCell * y - 1 ;%@NL@%
                         GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
                         ptl.x = cxCell * xNumCells - 1 ;%@NL@%
                         GpiLine (hps, &ptl) ;%@NL@%
                         }%@NL@%
%@NL@%
                    pbGrid = MAKEP (selGrid, 0) ;%@NL@%
%@NL@%
                    for (y = 0 ; y < yNumCells ; y++)%@NL@%
                         for (x = 0 ; x < xNumCells ; x++)%@NL@%
                              if (*pbGrid++)%@NL@%
                                   DrawCell (hps, x, y, cxCell, cyCell,%@NL@%
                                             *(pbGrid - 1)) ;%@NL@%
%@NL@%
                    DisplayGenerationNum (hps, xGenNum, yGenNum, lGeneration) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               if (fTimerGoing)%@NL@%
                    WinStopTimer (hab, hwnd, ID_TIMER) ;%@NL@%
%@NL@%
               if (selGrid)%@NL@%
                    DosFreeSeg (selGrid) ;%@NL@%
%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LINETYPE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\LINETYPE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------%@NL@%
%@AB@%   LINETYPE.C -- GPI Line Types%@NL@%
%@AB@%  ------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "LineType" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static struct {%@NL@%
                   LONG lLineType ;%@NL@%
                   CHAR *szLineType ;%@NL@%
                   }%@NL@%
                   show [] = %@NL@%
                   {%@NL@%
                   LINETYPE_DEFAULT       , "LINETYPE_DEFAULT"       , %@NL@%
                   LINETYPE_DOT           , "LINETYPE_DOT"           , %@NL@%
                   LINETYPE_SHORTDASH     , "LINETYPE_SHORTDASH"     , %@NL@%
                   LINETYPE_DASHDOT       , "LINETYPE_DASHDOT"       , %@NL@%
                   LINETYPE_DOUBLEDOT     , "LINETYPE_DOUBLEDOT"     , %@NL@%
                   LINETYPE_LONGDASH      , "LINETYPE_LONGDASH"      , %@NL@%
                   LINETYPE_DASHDOUBLEDOT , "LINETYPE_DASHDOUBLEDOT" , %@NL@%
                   LINETYPE_SOLID         , "LINETYPE_SOLID"         , %@NL@%
                   LINETYPE_INVISIBLE     , "LINETYPE_INVISIBLE"     , %@NL@%
                   LINETYPE_ALTERNATE     , "LINETYPE_ALTERNATE"%@NL@%
                   } ;%@NL@%
     static SHORT  cxClient, cyClient, cxCaps, cyChar, cyDesc,%@NL@%
                   sNumTypes = sizeof show / sizeof show[0] ;%@NL@%
     FONTMETRICS   fm ;%@NL@%
     HPS           hps ;%@NL@%
     POINTL        ptl ;%@NL@%
     SHORT         sIndex ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxCaps = (SHORT) fm.lEmInc ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               for (sIndex = 0 ; sIndex < sNumTypes ; sIndex ++)%@NL@%
                    {%@NL@%
                    GpiSetLineType (hps, show [sIndex].lLineType) ;%@NL@%
%@NL@%
                    ptl.x = cxCaps ;%@NL@%
                    ptl.y = cyClient - 2 * (sIndex + 1) * cyChar + cyDesc ;%@NL@%
%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                                     (LONG) strlen (show [sIndex].szLineType),%@NL@%
                                     show [sIndex].szLineType) ;%@NL@%
%@NL@%
                    if (cxClient > 25 * cxCaps)%@NL@%
                         {%@NL@%
                         ptl.x = 24 * cxCaps ;%@NL@%
                         ptl.y += cyChar / 2 - cyDesc ;%@NL@%
                         GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
                         ptl.x = cxClient - cxCaps ;%@NL@%
                         GpiLine (hps, &ptl) ;%@NL@%
                         }%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LOADBMP1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP12\LOADBMP1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------------%@NL@%
%@AB@%   LOADBMP1.C -- Loads a Bitmap Resource and Draws it%@NL@%
%@AB@%  ----------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"loadbmp.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "LoadBmp1" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static SHORT cxClient, cyClient ;%@NL@%
     HBITMAP      hbm ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       ptl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               hbm = GpiLoadBitmap (hps, NULL, IDB_HELLO,%@NL@%
                                    (LONG) cxClient, (LONG) cyClient) ;%@NL@%
               if (hbm)%@NL@%
                    {%@NL@%
                    ptl.x = 0 ;%@NL@%
                    ptl.y = 0 ;%@NL@%
%@NL@%
                    WinDrawBitmap (hps, hbm, NULL, &ptl,%@NL@%
                                   CLR_NEUTRAL, CLR_BACKGROUND, DBM_NORMAL) ;%@NL@%
%@NL@%
                    GpiDeleteBitmap (hbm) ;               %@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LOADBMP2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP12\LOADBMP2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------------%@NL@%
%@AB@%   LOADBMP2.C -- Loads a Bitmap Resource and Draws it%@NL@%
%@AB@%  ----------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"loadbmp.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "LoadBmp2" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static HBITMAP hbm ;%@NL@%
     HPS            hps ;%@NL@%
     RECTL          rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               hbm = GpiLoadBitmap (hps, NULL, IDB_HELLO, 0L, 0L) ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
               if (hbm)%@NL@%
                    WinDrawBitmap (hps, hbm, NULL, (PPOINTL) &rcl,%@NL@%
                                   CLR_NEUTRAL, CLR_BACKGROUND, DBM_STRETCH) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               if (hbm)%@NL@%
                    GpiDeleteBitmap (hbm) ;               %@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MINMAX1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP06\MINMAX1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------------%@NL@%
%@AB@%   MINMAX1.C -- Bitblt of Minimize-Maximize Menu%@NL@%
%@AB@%  -----------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "MinMax1" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static LONG  cxMinMax, cyMinMax ;%@NL@%
     static SHORT cxClient, cyClient ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       aptl[3] ;%@NL@%
     LONG         lRow, lCol ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               cxMinMax = WinQuerySysValue (HWND_DESKTOP, SV_CXMINMAXBUTTON) ;%@NL@%
               cyMinMax = WinQuerySysValue (HWND_DESKTOP, SV_CYMINMAXBUTTON) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               for (lRow = 0 ; lRow <= cyClient / cyMinMax ; lRow++)%@NL@%
                    for (lCol = 0 ; lCol <= cxClient / cxMinMax ; lCol++)%@NL@%
                         {%@NL@%
                         aptl[0].x = lCol * cxMinMax ;      // target%@NL@%
                         aptl[0].y = lRow * cyMinMax ;      //   lower left%@NL@%
%@NL@%
                         aptl[1].x = aptl[0].x + cxMinMax ; // target%@NL@%
                         aptl[1].y = aptl[0].y + cyMinMax ; //   upper right%@NL@%
%@NL@%
                         aptl[2].x = cxClient - cxMinMax ;  // source%@NL@%
                         aptl[2].y = cyClient ;             //   lower left%@NL@%
%@NL@%
                         GpiBitBlt (hps, hps, 3L, aptl, ROP_SRCCOPY, BBO_AND) ;%@NL@%
                         }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MINMAX2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP06\MINMAX2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------------%@NL@%
%@AB@%   MINMAX2.C -- Bitblt of Minimize-Maximize Menu%@NL@%
%@AB@%  -----------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "MinMax2" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static LONG  cxMinMax, cyMinMax ;%@NL@%
     static SHORT cxClient, cyClient ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       aptl[4] ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               cxMinMax = WinQuerySysValue (HWND_DESKTOP, SV_CXMINMAXBUTTON) ;%@NL@%
               cyMinMax = WinQuerySysValue (HWND_DESKTOP, SV_CYMINMAXBUTTON) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               aptl[0].x = 0 ;                    // target lower left%@NL@%
               aptl[0].y = 0 ;%@NL@%
%@NL@%
               aptl[1].x = cxClient ;             // target upper right%@NL@%
               aptl[1].y = cyClient ;%@NL@%
%@NL@%
               aptl[2].x = cxClient - cxMinMax ;  // source lower left%@NL@%
               aptl[2].y = cyClient ;%@NL@%
%@NL@%
               aptl[3].x = cxClient ;             // source upper right%@NL@%
               aptl[3].y = cyClient + cyMinMax ;%@NL@%
%@NL@%
               GpiBitBlt (hps, hps, 4L, aptl, ROP_SRCCOPY, BBO_AND) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MINMAX3.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP06\MINMAX3.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------------%@NL@%
%@AB@%   MINMAX3.C -- Minimize-Maximize Bitmap%@NL@%
%@AB@%  ---------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "MinMax3" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static SHORT cxClient, cyClient ;%@NL@%
     HBITMAP      hbmMin, hbmMax ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       aptl [2] ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               hbmMin = WinGetSysBitmap (HWND_DESKTOP, SBMP_MINBUTTON) ;%@NL@%
               hbmMax = WinGetSysBitmap (HWND_DESKTOP, SBMP_MAXBUTTON) ;%@NL@%
%@NL@%
               aptl[0].x = 0 ;               // Target lower left%@NL@%
               aptl[0].y = 0 ;%@NL@%
               aptl[1].x = cxClient / 2 ;    // Target upper right%@NL@%
               aptl[1].y = cyClient ;%@NL@%
%@NL@%
               WinDrawBitmap (hps, hbmMin, NULL, aptl,%@NL@%
                              CLR_NEUTRAL, CLR_BACKGROUND, DBM_STRETCH) ;%@NL@%
%@NL@%
               aptl[0].x = cxClient / 2 ;    // Target left%@NL@%
               aptl[1].x = cxClient ;        // Target right%@NL@%
%@NL@%
               WinDrawBitmap (hps, hbmMax, NULL, aptl,%@NL@%
                              CLR_NEUTRAL, CLR_BACKGROUND, DBM_STRETCH) ;%@NL@%
%@NL@%
               GpiDeleteBitmap (hbmMin) ;%@NL@%
               GpiDeleteBitmap (hbmMax) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ORGAN.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP08\ORGAN.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------%@NL@%
%@AB@%   ORGAN.C --  Play Organ from Keyboard%@NL@%
%@AB@%  --------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOS %@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"organ.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
VOID    EXPENTRY Speaker (USHORT usFreq) ;%@NL@%
%@NL@%
SHORT  xOffset, yOffset, cxCaps, cyChar ;%@NL@%
USHORT usLastScan ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Organ" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     if (DosPortAccess (0, 0, 0x42, 0x61))   // Don't run if port access fails%@NL@%
          return 1 ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     DosPortAccess (0, 1, 0x42, 0x61) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID DrawKey (HPS hps, USHORT usScanCode, BOOL fInvert)%@NL@%
     {%@NL@%
     RECTL rcl ;%@NL@%
%@NL@%
     rcl.xLeft   = 3 * cxCaps * key[usScanCode].xPos / 2 + xOffset ;%@NL@%
     rcl.yBottom = 3 * cyChar * key[usScanCode].yPos / 2 + yOffset ;%@NL@%
     rcl.xRight  = rcl.xLeft   + 3 * cxCaps ;%@NL@%
     rcl.yTop    = rcl.yBottom + 3 * cyChar / 2 ;%@NL@%
%@NL@%
     WinDrawText (hps, -1, key[usScanCode].szKey, &rcl,%@NL@%
                  CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                  DT_CENTER | DT_VCENTER | DT_ERASERECT) ;%@NL@%
     if (fInvert)%@NL@%
          WinInvertRect (hps, &rcl) ;%@NL@%
%@NL@%
     WinDrawBorder (hps, &rcl, 1, 1, CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                    DB_STANDARD) ;%@NL@%
     }%@NL@%
%@NL@%
VOID ProcessKey (HPS hps, USHORT usScanCode, USHORT fsFlags)%@NL@%
     {%@NL@%
     static USHORT ausOctFreq [] = { 262, 277, 294, 311, 330, 349,%@NL@%
                                     370, 392, 415, 440, 466, 494 } ;%@NL@%
     USHORT        usOct, usFreq ;%@NL@%
%@NL@%
     if (usScanCode >= NUMSCANS)                       // No scan codes over 53%@NL@%
          return ;%@NL@%
     if ((usOct = key[usScanCode].sOctave) == -1)      // Non-music key%@NL@%
          return ;%@NL@%
%@NL@%
     if (fsFlags & KC_KEYUP)                           // For key up%@NL@%
          {%@NL@%
          if (usLastScan == usScanCode)                // If that's the note%@NL@%
               {%@NL@%
               Speaker (0) ;                           // turn off speaker%@NL@%
               DrawKey (hps, usScanCode, FALSE) ;      // and redraw key%@NL@%
               usLastScan = 0 ;%@NL@%
               }%@NL@%
          return ;%@NL@%
          }%@NL@%
     if (fsFlags & KC_PREVDOWN)                        // Ignore typematics%@NL@%
          return ;%@NL@%
%@NL@%
     usFreq = ausOctFreq [key[usScanCode].sNote] ;     // Get frequency%@NL@%
%@NL@%
     if (fsFlags & KC_SHIFT)%@NL@%
          usOct += fsFlags & KC_ALT ? 2 : 1 ;          // Higher octave%@NL@%
     else if (fsFlags & KC_CTRL)%@NL@%
          usOct -= fsFlags & KC_ALT ? 2 : 1 ;          // Lower octave%@NL@%
%@NL@%
     if (usOct > 4)                                    // Shift frequency%@NL@%
          usFreq <<= (usOct - 4) ;                     //   for octave%@NL@%
     else if (usOct < 4)%@NL@%
          usFreq >>= (4 - usOct) ;%@NL@%
%@NL@%
     Speaker (usFreq) ;                                // Turn on speaker%@NL@%
     DrawKey (hps, usScanCode, TRUE) ;                 // Draw the inverted key%@NL@%
%@NL@%
     if (usLastScan != 0)%@NL@%
          DrawKey (hps, usLastScan, FALSE) ;           // Redraw previous key%@NL@%
     usLastScan = usScanCode ;                         // Save scan code%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     FONTMETRICS fm ;%@NL@%
     HPS         hps ;%@NL@%
     SHORT       cxClient, cyClient ;%@NL@%
     USHORT      usScanCode ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxCaps = (SHORT) fm.lEmInc ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               xOffset = (cxClient - 25 * 3 * cxCaps / 2) / 2 ;%@NL@%
               yOffset = (cyClient - 6 * cyChar) / 2 ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               if (!(CHARMSG(&msg)->fs & KC_SCANCODE))%@NL@%
                    break ;%@NL@%
%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               ProcessKey (hps, CHARMSG(&msg)->scancode, CHARMSG(&msg)->fs) ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               for (usScanCode = 0 ; usScanCode < NUMSCANS ; usScanCode++)%@NL@%
                    if (key[usScanCode].xPos != -1)%@NL@%
                         DrawKey (hps, usScanCode, usScanCode == usLastScan) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PATTDLG.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP14\PATTDLG.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------%@NL@%
%@AB@%   PATTDLG.C -- Select GPI Patterns from Dialog Box%@NL@%
%@AB@%  --------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"pattdlg.h" %@NL@%
%@NL@%
typedef struct%@NL@%
     {%@NL@%
     SHORT sPattern ;%@NL@%
     SHORT sColor ;%@NL@%
     BOOL  fBorder ;%@NL@%
     }%@NL@%
     PATTERNSDATA ;%@NL@%
%@NL@%
typedef PATTERNSDATA FAR *PPATTERNSDATA ;%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc  (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT EXPENTRY AboutDlgProc   (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT EXPENTRY PatternDlgProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "PattDlg" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR         szAppName [] = "PATTDLG" ;%@NL@%
     static CHAR         szKeyName [] = "SETTINGS" ;%@NL@%
     static PATTERNSDATA pdCurrent = { IDD_DENSE1, IDD_BKGRND, TRUE } ;%@NL@%
     static SHORT        cxClient, cyClient ;%@NL@%
     HPS                 hps ;%@NL@%
     POINTL              ptl ;%@NL@%
     SHORT               sDataLength ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               sDataLength = sizeof pdCurrent ;%@NL@%
%@NL@%
               WinQueryProfileData (hab, szAppName, szKeyName, &pdCurrent,%@NL@%
                                    &sDataLength) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_PATTERNS:%@NL@%
                         if (WinDlgBox (HWND_DESKTOP, hwnd, PatternDlgProc,%@NL@%
                                        NULL, IDD_PATTERNS, &pdCurrent))%@NL@%
%@NL@%
                              WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ABOUT:%@NL@%
                         WinDlgBox (HWND_DESKTOP, hwnd, AboutDlgProc,%@NL@%
                                    NULL, IDD_ABOUT, NULL) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               GpiSetColor (hps, pdCurrent.sColor -%@NL@%
                                 IDD_BKGRND + CLR_BACKGROUND) ;%@NL@%
%@NL@%
               GpiSetPattern (hps, pdCurrent.sPattern -%@NL@%
                                   IDD_DENSE1 + PATSYM_DENSE1) ;%@NL@%
%@NL@%
               ptl.x = cxClient / 4 ;%@NL@%
               ptl.y = cyClient / 4 ;%@NL@%
               GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
               ptl.x *= 3 ;%@NL@%
               ptl.y *= 3 ;%@NL@%
               GpiBox (hps, pdCurrent.fBorder ? DRO_OUTLINEFILL : DRO_FILL,%@NL@%
                            &ptl, 0L, 0L) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               if (MBID_YES == WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                                    "Save current settings?", szAppName, 0,%@NL@%
                                    MB_YESNO | MB_ICONQUESTION))%@NL@%
%@NL@%
                    WinWriteProfileData (hab, szAppName, szKeyName, &pdCurrent,%@NL@%
                                         sizeof pdCurrent) ;%@NL@%
               break ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY AboutDlgProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case DID_OK:%@NL@%
                    case DID_CANCEL:%@NL@%
                         WinDismissDlg (hwnd, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
          }%@NL@%
     return WinDefDlgProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY PatternDlgProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static PATTERNSDATA  pdLocal ;%@NL@%
     static PPATTERNSDATA ppdCurrent ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_INITDLG:%@NL@%
               ppdCurrent = MPFROMP (mp2) ;%@NL@%
               pdLocal = *ppdCurrent ;%@NL@%
%@NL@%
               WinSendDlgItemMsg (hwnd, pdLocal.sPattern, BM_SETCHECK,%@NL@%
                                  MPFROM2SHORT (TRUE, 0), NULL) ;%@NL@%
%@NL@%
               WinSendDlgItemMsg (hwnd, pdLocal.sColor, BM_SETCHECK,%@NL@%
                                  MPFROM2SHORT (TRUE, 0), NULL) ;%@NL@%
%@NL@%
               WinSendDlgItemMsg (hwnd, IDD_BORDER, BM_SETCHECK,%@NL@%
                                  MPFROM2SHORT (pdLocal.fBorder, 0), NULL) ;%@NL@%
%@NL@%
               WinSetFocus (HWND_DESKTOP,%@NL@%
                            WinWindowFromID (hwnd, pdLocal.sPattern)) ;%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_CONTROL:%@NL@%
               if (SHORT1FROMMP (mp1) >= IDD_DENSE1 &&%@NL@%
                   SHORT1FROMMP (mp1) <= IDD_HALFTONE)%@NL@%
                    {%@NL@%
                    WinSendDlgItemMsg (hwnd, pdLocal.sPattern, BM_SETCHECK,%@NL@%
                                       MPFROM2SHORT (FALSE, 0), NULL) ;%@NL@%
%@NL@%
                    pdLocal.sPattern = SHORT1FROMMP (mp1) ;%@NL@%
%@NL@%
                    WinSendDlgItemMsg (hwnd, pdLocal.sPattern, BM_SETCHECK,%@NL@%
                                       MPFROM2SHORT (TRUE, 0), NULL) ;%@NL@%
                    }%@NL@%
%@NL@%
               else if (SHORT1FROMMP (mp1) >= IDD_BKGRND &&%@NL@%
                        SHORT1FROMMP (mp1) <= IDD_PALEGRAY)%@NL@%
                    {%@NL@%
                    WinSendDlgItemMsg (hwnd, pdLocal.sColor, BM_SETCHECK,%@NL@%
                                       MPFROM2SHORT (FALSE, 0), NULL) ;%@NL@%
%@NL@%
                    pdLocal.sColor = SHORT1FROMMP (mp1) ;%@NL@%
%@NL@%
                    WinSendDlgItemMsg (hwnd, pdLocal.sColor, BM_SETCHECK,%@NL@%
                                             MPFROM2SHORT (TRUE, 0), NULL) ; %@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case DID_OK:%@NL@%
                         pdLocal.fBorder = (BOOL) WinSendDlgItemMsg (hwnd,%@NL@%
                                   IDD_BORDER, BM_QUERYCHECK, NULL, NULL) ;%@NL@%
%@NL@%
                         *ppdCurrent = pdLocal ;%@NL@%
%@NL@%
                         WinDismissDlg (hwnd, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case DID_CANCEL:%@NL@%
                         WinDismissDlg (hwnd, FALSE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
          }%@NL@%
     return WinDefDlgProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PATTERNS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\PATTERNS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------%@NL@%
%@AB@%   PATTERNS.C -- GPI Area Patterns%@NL@%
%@AB@%  ---------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Patterns" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static struct {%@NL@%
                   LONG lPatternSymbol ;%@NL@%
                   CHAR *szPatternSymbol ;%@NL@%
                   }%@NL@%
                   show [] = %@NL@%
                   {%@NL@%
                   PATSYM_DEFAULT  , "PATSYM_DEFAULT"  , %@NL@%
                   PATSYM_DENSE1   , "PATSYM_DENSE1"   , %@NL@%
                   PATSYM_DENSE2   , "PATSYM_DENSE2"   , %@NL@%
                   PATSYM_DENSE3   , "PATSYM_DENSE3"   , %@NL@%
                   PATSYM_DENSE4   , "PATSYM_DENSE4"   , %@NL@%
                   PATSYM_DENSE5   , "PATSYM_DENSE5"   , %@NL@%
                   PATSYM_DENSE6   , "PATSYM_DENSE6"   , %@NL@%
                   PATSYM_DENSE7   , "PATSYM_DENSE7"   , %@NL@%
                   PATSYM_DENSE8   , "PATSYM_DENSE8"   , %@NL@%
                   PATSYM_VERT     , "PATSYM_VERT"     , %@NL@%
                   PATSYM_HORIZ    , "PATSYM_HORIZ"    , %@NL@%
                   PATSYM_DIAG1    , "PATSYM_DIAG1"    , %@NL@%
                   PATSYM_DIAG2    , "PATSYM_DIAG2"    , %@NL@%
                   PATSYM_DIAG3    , "PATSYM_DIAG3"    , %@NL@%
                   PATSYM_DIAG4    , "PATSYM_DIAG4"    , %@NL@%
                   PATSYM_NOSHADE  , "PATSYM_NOSHADE"  , %@NL@%
                   PATSYM_SOLID    , "PATSYM_SOLID"    , %@NL@%
                   PATSYM_HALFTONE , "PATSYM_HALFTONE" , %@NL@%
                   PATSYM_BLANK    , "PATSYM_BLANK"    , %@NL@%
                   } ;%@NL@%
     static SHORT  cxClient, cyClient, cxCaps, cyChar, cyDesc,%@NL@%
                   sNumTypes = sizeof show / sizeof show[0] ;%@NL@%
     FONTMETRICS   fm ;%@NL@%
     HPS           hps ;%@NL@%
     POINTL        ptl ;%@NL@%
     SHORT         sIndex ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxCaps = (SHORT) fm.lEmInc ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               for (sIndex = 0 ; sIndex < sNumTypes ; sIndex ++)%@NL@%
                    {%@NL@%
                    GpiSetPattern (hps, show [sIndex].lPatternSymbol) ;%@NL@%
%@NL@%
                    ptl.x = (sIndex < 10 ? 1 : 33) * cxCaps ;%@NL@%
                    ptl.y = cyClient - (sIndex % 10 * 5 + 4) * cyChar / 2%@NL@%
                                                       + cyDesc ;%@NL@%
%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                          (LONG) strlen (show [sIndex].szPatternSymbol),%@NL@%
                               show [sIndex].szPatternSymbol) ;%@NL@%
%@NL@%
                    ptl.x = (sIndex < 10 ? 20 : 52) * cxCaps ;%@NL@%
                           ptl.y -= cyDesc + cyChar / 2 ;%@NL@%
                    GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
                    ptl.x += 10 * cxCaps ;%@NL@%
                    ptl.y += 2 * cyChar ;%@NL@%
                    GpiBox (hps, DRO_FILL, &ptl, 0L, 0L) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%POEPOEM.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP12\POEPOEM.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------------%@NL@%
%@AB@%   POEPOEM.C -- Demonstrates Programmer-Defined Resources%@NL@%
%@AB@%  --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#define %@AE@%INCL_DOS %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%"poepoem.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [10] ;%@NL@%
     static CHAR  szTitleBar [40] ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_VERTSCROLL    | FCF_ICON ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinLoadString (hab, NULL, IDS_CLASS, sizeof szClientClass, szClientClass);%@NL@%
     WinLoadString (hab, NULL, IDS_TITLE, sizeof szTitleBar,    szTitleBar) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, szTitleBar,%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static HWND   hwndScroll ;%@NL@%
     static PCHAR  pResource ;%@NL@%
     static SEL    selResource ;%@NL@%
     static SHORT  cxClient, cyClient, cxChar, cyChar, cyDesc,%@NL@%
                   sScrollPos, sNumLines ;%@NL@%
     FONTMETRICS   fm ;%@NL@%
     HPS           hps ;%@NL@%
     PCHAR         pText ;%@NL@%
     POINTL        ptl ;%@NL@%
     SHORT         sLineLength, sLine ;%@NL@%
     ULONG         ulSegSize ;%@NL@%
     %@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
%@NL@%
                    %@AB@%/*-----------------------------------------%@NL@%
%@AB@%                       Load the resource, get size and address%@NL@%
%@AB@%                      -----------------------------------------*/%@AE@%%@NL@%
%@NL@%
               DosGetResource (NULL, IDT_TEXT, IDT_POEM, &selResource) ;%@NL@%
               DosSizeSeg (selResource, &ulSegSize) ;%@NL@%
               pResource = MAKEP (selResource, 0) ;%@NL@%
%@NL@%
                    %@AB@%/*-----------------------------------------------%@NL@%
%@AB@%                       Determine how many text lines are in resource%@NL@%
%@AB@%                      -----------------------------------------------*/%@AE@%%@NL@%
%@NL@%
               pText = pResource ;%@NL@%
%@NL@%
               while (pText - pResource < (USHORT) ulSegSize)%@NL@%
                    {%@NL@%
                    if (*pText == '\0' || *pText == '\x1A')%@NL@%
                         break ;%@NL@%
%@NL@%
                    if (*pText == '\r')%@NL@%
                         sNumLines ++ ;%@NL@%
%@NL@%
                    pText++ ;%@NL@%
                    }%@NL@%
%@NL@%
                    %@AB@%/*------------------------------------------%@NL@%
%@AB@%                       Initialize scroll bar range and position%@NL@%
%@AB@%                      ------------------------------------------*/%@AE@%%@NL@%
%@NL@%
               hwndScroll = WinWindowFromID (%@NL@%
                                   WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                                   FID_VERTSCROLL) ;%@NL@%
%@NL@%
               WinSendMsg (hwndScroll, SBM_SETSCROLLBAR,%@NL@%
                                       MPFROM2SHORT (sScrollPos, 0),%@NL@%
                                       MPFROM2SHORT (0, sNumLines - 1)) ;%@NL@%
%@NL@%
                    %@AB@%/*----------------------%@NL@%
%@AB@%                       Query character size%@NL@%
%@AB@%                      ----------------------*/%@AE@%%@NL@%
%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               return WinSendMsg (hwndScroll, msg, mp1, mp2) ;%@NL@%
%@NL@%
          case WM_VSCROLL:%@NL@%
               switch (SHORT2FROMMP (mp2))%@NL@%
                    {%@NL@%
                    case SB_LINEUP:%@NL@%
                         sScrollPos -= 1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_LINEDOWN:%@NL@%
                         sScrollPos += 1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEUP:%@NL@%
                         sScrollPos -= cyClient / cyChar ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEDOWN:%@NL@%
                         sScrollPos += cyClient / cyChar ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_SLIDERPOSITION:%@NL@%
                         sScrollPos = SHORT1FROMMP (mp2) ;%@NL@%
                         break ;%@NL@%
                    }%@NL@%
               sScrollPos = max (0, min (sScrollPos, sNumLines - 1)) ;%@NL@%
%@NL@%
               if (sScrollPos != (SHORT) WinSendMsg (hwndScroll,%@NL@%
                                                     SBM_QUERYPOS, 0L, 0L))%@NL@%
                    {%@NL@%
                    WinSendMsg (hwndScroll, SBM_SETPOS,%@NL@%
                                MPFROM2SHORT (sScrollPos, 0), NULL) ;%@NL@%
                    WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               pText = pResource ;%@NL@%
%@NL@%
               for (sLine = 0 ; sLine < sNumLines ; sLine++)%@NL@%
                    {%@NL@%
                    sLineLength = 0 ;%@NL@%
%@NL@%
                    while (pText [sLineLength] != '\r')%@NL@%
                         sLineLength ++ ;%@NL@%
%@NL@%
                    ptl.x = cxChar ;%@NL@%
                    ptl.y = cyClient - cyChar * (sLine + 1 - sScrollPos)%@NL@%
                                     + cyDesc ;%@NL@%
                    %@NL@%
                    GpiCharStringAt (hps, &ptl, (LONG) sLineLength, pText) ;%@NL@%
%@NL@%
                    pText += sLineLength + 2 ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               DosFreeSeg (selResource) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%POORMENU.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP13\POORMENU.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------%@NL@%
%@AB@%   POORMENU.C -- Poor Person's Menu%@NL@%
%@AB@%  ----------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%IDM_ABOUT   10 %@NL@%
%@AI@%#define %@AE@%IDM_HELP    11 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
CHAR szCaption [] = "Poor Person\'s Menu" ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "PoorMenu" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR     *szMenuText [3] = { NULL,%@NL@%
                                         "A~bout PoorMenu...",%@NL@%
                                         "~Help..." } ;%@NL@%
     static MENUITEM mi [3] = {%@NL@%
                              MIT_END, MIS_SEPARATOR, 0, 0,         NULL, NULL,%@NL@%
                              MIT_END, MIS_TEXT,      0, IDM_ABOUT, NULL, NULL,%@NL@%
                              MIT_END, MIS_TEXT,      0, IDM_HELP,  NULL, NULL%@NL@%
                              } ;%@NL@%
     HWND            hwndSysMenu, hwndSysSubMenu ;%@NL@%
     MENUITEM        miSysMenu ;%@NL@%
     SHORT           sItem, idSysMenu ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hwndSysMenu = WinWindowFromID (%@NL@%
                                  WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                                  FID_SYSMENU) ;%@NL@%
%@NL@%
               idSysMenu = SHORT1FROMMR (WinSendMsg (hwndSysMenu,%@NL@%
                                                     MM_ITEMIDFROMPOSITION,%@NL@%
                                                     NULL, NULL)) ;%@NL@%
%@NL@%
               WinSendMsg (hwndSysMenu, MM_QUERYITEM,%@NL@%
                           MPFROM2SHORT (idSysMenu, FALSE),%@NL@%
                           MPFROMP (&miSysMenu)) ;%@NL@%
%@NL@%
               hwndSysSubMenu = miSysMenu.hwndSubMenu ;%@NL@%
%@NL@%
               for (sItem = 0 ; sItem < 3 ; sItem++)%@NL@%
                    WinSendMsg (hwndSysSubMenu, MM_INSERTITEM,%@NL@%
                                MPFROMP (mi + sItem),%@NL@%
                                MPFROMP (szMenuText [sItem])) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_ABOUT:%@NL@%
                         WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                                   "(C) Charles Petzold, 1988",%@NL@%
                                   szCaption, 0, MB_OK | MB_ICONASTERISK) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_HELP:%@NL@%
                         WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                                   "Help not yet implemented",%@NL@%
                                   szCaption, 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%RESOURCE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP12\RESOURCE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------------%@NL@%
%@AB@%   RESOURCE.C -- Uses an Icon and Pointer Resource%@NL@%
%@AB@%  -------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"resource.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Resource" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_ICON ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static HPOINTER hIcon, hptr ;%@NL@%
     static SHORT    cxClient, cyClient, cxIcon, cyIcon ;%@NL@%
     HPS             hps ;%@NL@%
     RECTL           rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hIcon = WinLoadPointer (HWND_DESKTOP, NULL, ID_RESOURCE) ;%@NL@%
               hptr  = WinLoadPointer (HWND_DESKTOP, NULL, IDP_CIRCLE) ;%@NL@%
%@NL@%
               cxIcon = (SHORT) WinQuerySysValue (HWND_DESKTOP, SV_CXICON) ;%@NL@%
               cyIcon = (SHORT) WinQuerySysValue (HWND_DESKTOP, SV_CYICON) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_MOUSEMOVE:%@NL@%
               WinSetPointer (HWND_DESKTOP, hptr) ;%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               WinFillRect (hps, &rcl, CLR_CYAN) ;%@NL@%
%@NL@%
               WinDrawPointer (hps, 0, 0, hIcon, DP_NORMAL) ;%@NL@%
               WinDrawPointer (hps, 0, cyClient - cyIcon, hIcon, DP_NORMAL) ;%@NL@%
               WinDrawPointer (hps, cxClient - cyIcon, 0, hIcon, DP_NORMAL) ;%@NL@%
               WinDrawPointer (hps, cxClient - cxIcon, cyClient - cyIcon,%@NL@%
                                    hIcon, DP_NORMAL) ;%@NL@%
%@NL@%
               WinDrawPointer (hps, cxClient / 3, cyClient / 2, hIcon,%@NL@%
                                                       DP_HALFTONED) ;%@NL@%
               WinDrawPointer (hps, 2 * cxClient / 3, cyClient / 2, hIcon,%@NL@%
                                                       DP_INVERTED) ;%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               WinDestroyPointer (hIcon) ;%@NL@%
               WinDestroyPointer (hptr) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%RULER.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\RULER.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------%@NL@%
%@AB@%   RULER.C -- Draw a Ruler%@NL@%
%@AB@%  -------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Ruler" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static SHORT sTick[16] = { 100, 25, 35, 25, 50, 25, 35, 25,%@NL@%
                                 70, 25, 35, 25, 50, 25, 35, 25 } ;%@NL@%
     static SHORT cxClient, cyClient, cxChar, cyChar, cyDesc ;%@NL@%
     static SIZEL sizl ;%@NL@%
     CHAR         szBuffer [4] ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       ptl ;%@NL@%
     SHORT        sIndex ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiSetPS (hps, &sizl, PU_LOENGLISH) ;%@NL@%
%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               ptl.x = SHORT1FROMMP (mp2) ;%@NL@%
               ptl.y = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiSetPS (hps, &sizl, PU_LOENGLISH) ;%@NL@%
               GpiConvert (hps, CVTC_DEVICE, CVTC_PAGE, 1L, &ptl) ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               cxClient = (SHORT) ptl.x ;%@NL@%
               cyClient = (SHORT) ptl.y ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiSetPS (hps, &sizl, PU_LOENGLISH) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               for (sIndex = 0 ; sIndex < 16 * (SHORT) cxClient / 100 ;%@NL@%
                                 sIndex ++)%@NL@%
                    {%@NL@%
                    ptl.x = 100 * sIndex / 16 ;%@NL@%
                    ptl.y = 0 ;%@NL@%
                    GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
                    ptl.y = sTick [sIndex % 16] ;%@NL@%
                    GpiLine (hps, &ptl) ;%@NL@%
%@NL@%
                    if (sIndex % 16 == 0)%@NL@%
                         {%@NL@%
                         ptl.x -= cxChar / (sIndex > 160 ? 1 : 2) ;%@NL@%
                         ptl.y += cyDesc ;%@NL@%
                         GpiCharStringAt (hps, &ptl,%@NL@%
                              (LONG) sprintf (szBuffer, "%d", sIndex / 16),%@NL@%
                              szBuffer) ;%@NL@%
                         }%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SHOWBIT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP16\SHOWBIT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------------------------%@NL@%
%@AB@%   SHOWBIT.C -- Loads Bitmap Resources from BITLIB.DLL and Draws Them%@NL@%
%@AB@%  --------------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_DOS %@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "ShowBit" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass,%@NL@%
                                     " (Space bar or mouse click for next)",%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
     if (hwndFrame != NULL)%@NL@%
          {%@NL@%
          while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
               WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
          WinDestroyWindow (hwndFrame) ;%@NL@%
          }%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static HMODULE hmodBitLib ;%@NL@%
     static USHORT  idBitmap = 1 ;%@NL@%
     HBITMAP        hbm ;%@NL@%
     HPS            hps ;%@NL@%
     RECTL          rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               if (DosLoadModule (NULL, 0, "BITLIB", &hmodBitLib))%@NL@%
                    {%@NL@%
                    WinMessageBox (HWND_DESKTOP, HWND_DESKTOP,%@NL@%
                                   "Cannot load BITLIB.DLL library",%@NL@%
                                   "ShowBit", 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
                    return 1 ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               if (  CHARMSG(&msg)->fs & KC_KEYUP ||%@NL@%
                   !(CHARMSG(&msg)->fs & KC_VIRTUALKEY) ||%@NL@%
                   !(CHARMSG(&msg)->vkey == VK_SPACE))%@NL@%
                         break ;%@NL@%
%@NL@%
               if (++idBitmap == 10)%@NL@%
                    idBitmap = 1 ;%@NL@%
%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               if (++idBitmap == 10)%@NL@%
                    idBitmap = 1 ;%@NL@%
%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               hbm = GpiLoadBitmap (hps, hmodBitLib, idBitmap, 0L, 0L) ;%@NL@%
%@NL@%
               if (hbm != NULL)%@NL@%
                    {%@NL@%
                    WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
                    WinDrawBitmap (hps, hbm, NULL, (PPOINTL) &rcl,%@NL@%
                                   CLR_NEUTRAL, CLR_BACKGROUND, DBM_STRETCH) ;%@NL@%
%@NL@%
                    GpiDeleteBitmap (hbm) ;               %@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               DosFreeModule (hmodBitLib) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SKETCH.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP09\SKETCH.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------%@NL@%
%@AB@%   SKETCH.C -- Mouse Sketching Program%@NL@%
%@AB@%  -------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Sketch" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     if (hwndFrame == NULL)%@NL@%
          WinMessageBox (HWND_DESKTOP, HWND_DESKTOP,%@NL@%
                         "Not enough memory to create the "%@NL@%
                         "bitmap used for storing images.",%@NL@%
                         szClientClass, 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
     else%@NL@%
          {%@NL@%
          WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                      WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                      NULL) ;%@NL@%
%@NL@%
          while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
               WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
          WinDestroyWindow (hwndFrame) ;%@NL@%
          }%@NL@%
%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL      fButton1Down, fButton2Down ;%@NL@%
     static HBITMAP   hbm ;%@NL@%
     static HDC       hdcMemory ;%@NL@%
     static HPS       hpsMemory ;%@NL@%
     static POINTL    ptlPointerPos, aptl [3] ;%@NL@%
     BITMAPINFOHEADER bmp ;%@NL@%
     HPS              hpsWindow ;%@NL@%
     LONG             cxFullScrn, cyFullScrn ;%@NL@%
     SIZEL            sizl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               cxFullScrn = WinQuerySysValue (HWND_DESKTOP, SV_CXFULLSCREEN) ;%@NL@%
               cyFullScrn = WinQuerySysValue (HWND_DESKTOP, SV_CYFULLSCREEN) ;%@NL@%
%@NL@%
                         %@AB@%/*-------------------------%@NL@%
%@AB@%                            Create Memory DC and PS%@NL@%
%@AB@%                           -------------------------*/%@AE@%%@NL@%
%@NL@%
               hdcMemory = DevOpenDC (hab, OD_MEMORY, "*", 0L, NULL, NULL) ;%@NL@%
%@NL@%
               sizl.cx = 0 ;%@NL@%
               sizl.cy = 0 ;%@NL@%
               hpsMemory = GpiCreatePS (hab, hdcMemory, &sizl,%@NL@%
                                        PU_PELS    | GPIF_DEFAULT |%@NL@%
                                        GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
                         %@AB@%/*----------------------------------------------%@NL@%
%@AB@%                            Create monochrome bitmap, return 1 if cannot%@NL@%
%@AB@%                           ----------------------------------------------*/%@AE@%%@NL@%
%@NL@%
               bmp.cbFix     = sizeof bmp ;%@NL@%
               bmp.cx        = (SHORT) cxFullScrn ;%@NL@%
               bmp.cy        = (SHORT) cyFullScrn ;%@NL@%
               bmp.cPlanes   = 1 ;%@NL@%
               bmp.cBitCount = 1 ;%@NL@%
               hbm = GpiCreateBitmap (hpsMemory, &bmp, 0L, 0L, NULL) ;%@NL@%
%@NL@%
               if (hbm == NULL)%@NL@%
                    {%@NL@%
                    GpiDestroyPS (hpsMemory) ;%@NL@%
                    DevCloseDC (hdcMemory) ;%@NL@%
                    return 1 ;%@NL@%
                    }%@NL@%
%@NL@%
                         %@AB@%/*--------------------------------------%@NL@%
%@AB@%                            Set bitmap in memory PS and clear it%@NL@%
%@AB@%                           --------------------------------------*/%@AE@%%@NL@%
%@NL@%
               GpiSetBitmap (hpsMemory, hbm) ;%@NL@%
%@NL@%
               aptl[1].x = cxFullScrn ;%@NL@%
               aptl[1].y = cyFullScrn ;%@NL@%
               GpiBitBlt (hpsMemory, NULL, 2L, aptl, ROP_ZERO, BBO_OR) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               if (!fButton2Down)%@NL@%
                    WinSetCapture (HWND_DESKTOP, hwnd) ;%@NL@%
%@NL@%
               ptlPointerPos.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptlPointerPos.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
               fButton1Down = TRUE ;%@NL@%
               break ;                       // do default processing%@NL@%
%@NL@%
          case WM_BUTTON1UP:%@NL@%
               if (!fButton2Down)%@NL@%
                    WinSetCapture (HWND_DESKTOP, NULL) ;%@NL@%
%@NL@%
               fButton1Down = FALSE ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_BUTTON2DOWN:%@NL@%
               if (!fButton1Down)%@NL@%
                    WinSetCapture (HWND_DESKTOP, hwnd) ;%@NL@%
%@NL@%
               ptlPointerPos.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptlPointerPos.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
               fButton2Down = TRUE ;%@NL@%
               break ;                       // do default processing%@NL@%
%@NL@%
          case WM_BUTTON2UP:%@NL@%
               if (!fButton1Down)%@NL@%
                    WinSetCapture (HWND_DESKTOP, NULL) ;%@NL@%
%@NL@%
               fButton2Down = FALSE ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_MOUSEMOVE:%@NL@%
               if (!fButton1Down && !fButton2Down)%@NL@%
                    break ;%@NL@%
%@NL@%
               hpsWindow = WinGetPS (hwnd) ;%@NL@%
%@NL@%
               GpiSetColor (hpsMemory, fButton1Down ? CLR_TRUE : CLR_FALSE) ;%@NL@%
               GpiSetColor (hpsWindow,%@NL@%
                            fButton1Down ? CLR_NEUTRAL : CLR_BACKGROUND) ;%@NL@%
%@NL@%
               GpiMove (hpsMemory, &ptlPointerPos) ;%@NL@%
               GpiMove (hpsWindow, &ptlPointerPos) ;%@NL@%
%@NL@%
               ptlPointerPos.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptlPointerPos.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
               GpiLine (hpsMemory, &ptlPointerPos) ;%@NL@%
               GpiLine (hpsWindow, &ptlPointerPos) ;%@NL@%
%@NL@%
               WinReleasePS (hpsWindow) ;%@NL@%
               break ;                       // do default processing%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hpsWindow = WinBeginPaint (hwnd, NULL, (PRECTL) aptl) ;%@NL@%
%@NL@%
               aptl[2] = aptl[0] ;%@NL@%
%@NL@%
               GpiBitBlt (hpsWindow, hpsMemory, 3L, aptl, ROP_SRCCOPY,%@NL@%
                          BBO_OR) ;%@NL@%
%@NL@%
               WinEndPaint (hpsWindow) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               GpiDestroyPS (hpsMemory) ;%@NL@%
               DevCloseDC (hdcMemory) ;%@NL@%
               GpiDeleteBitmap (hbm) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SPEAKER.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP08\SPEAKER.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%;-------------------------------------------------%@AE@%%@NL@%
%@AB@%; SPEAKER.ASM -- Ring 2 routine for ORGAN program%@AE@%%@NL@%
%@AB@%;                (Accesses Intel 8255 Timer chip)%@AE@%%@NL@%
%@AB@%;-------------------------------------------------%@AE@%%@NL@%
%@NL@%
               PUBLIC    Speaker%@NL@%
               .286%@NL@%
               .MODEL    MEDIUM, PASCAL%@NL@%
%@NL@%
               .DATA%@NL@%
ClockFreq      dd   1193180%@NL@%
%@NL@%
               .CODE     SPEAKER_TEXT%@NL@%
Speaker        PROC FAR  Frequency:WORD%@NL@%
               Cli                                %@AB@%; Disable interrupts%@AE@%%@NL@%
%@NL@%
               Mov  BX, Frequency                 %@AB@%; Get parameter from stack%@AE@%%@NL@%
               Or   BX, BX                        %@AB@%; Check if it's zero%@AE@%%@NL@%
               Jz   TurnOff                       %@AB@%; If so, turn off sound%@AE@%%@NL@%
%@NL@%
               Mov  AL, 10110110b                 %@AB@%; Set flags for programming%@AE@%%@NL@%
               Out  43h, AL%@NL@%
%@NL@%
               Mov  AX, WORD PTR [ClockFreq]      %@AB@%; Calculate timer frequency%@AE@%%@NL@%
               Mov  DX, WORD PTR [ClockFreq + 2]%@NL@%
               Div  BX%@NL@%
%@NL@%
               Out  42h, AL                       %@AB@%; Output low byte%@AE@%%@NL@%
               Jmp  $ + 2                         %@AB@%; Delay%@AE@%%@NL@%
%@NL@%
               Mov  AL, AH                        %@AB@%; Output high byte%@AE@%%@NL@%
               Out  42h, AL%@NL@%
               Jmp  $ + 2                         %@AB@%; Delay%@AE@%%@NL@%
%@NL@%
               In   AL, 61h                       %@AB@%; Get 8255 bits%@AE@%%@NL@%
               Jmp  $ + 2                         %@AB@%; Delay%@AE@%%@NL@%
%@NL@%
               Or   AL, 00000011b                 %@AB@%; Set bits for speaker%@AE@%%@NL@%
               Out  61h, AL                       %@AB@%; Set 8255 bits%@AE@%%@NL@%
               Jmp  Return%@NL@%
%@NL@%
TurnOff:       In   AL, 61h                       %@AB@%; Get 8255 bits%@AE@%%@NL@%
               Jmp  $ + 2                         %@AB@%; Delay%@AE@%%@NL@%
               And  AL, 11111101b                 %@AB@%; Set bits for no speaker%@AE@%%@NL@%
               Out  61h, AL                       %@AB@%; Set 8255 bits%@AE@%%@NL@%
%@NL@%
Return:        Sti                                %@AB@%; Enable interrupts%@AE@%%@NL@%
               Ret%@NL@%
Speaker        ENDP%@NL@%
               END%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SPIRAL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\SPIRAL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------%@NL@%
%@AB@%   SPIRAL.C -- GPI Spiral Drawing%@NL@%
%@AB@% ---------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<math.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%NUMPOINTS 1000 %@NL@%
%@AI@%#define %@AE@%NUMREV    20 %@NL@%
%@AI@%#define %@AE@%PI        3.14159 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Spiral" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static SHORT cxClient, cyClient ;%@NL@%
     double       dAngle, dScale ;%@NL@%
     HPS          hps ;%@NL@%
     PPOINTL      pptl ;%@NL@%
     SEL          sel ;%@NL@%
     SHORT        sIndex ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               if (!DosAllocSeg (NUMPOINTS * sizeof (POINTL), &sel, 0))%@NL@%
                    {%@NL@%
                    pptl = MAKEP (sel, 0) ;%@NL@%
%@NL@%
                    for (sIndex = 0 ; sIndex < NUMPOINTS ; sIndex ++)%@NL@%
                        {%@NL@%
                        dAngle = sIndex * 2 * PI / (NUMPOINTS / NUMREV) ;%@NL@%
                        dScale = 1 - (double) sIndex / NUMPOINTS ;%@NL@%
%@NL@%
                        pptl[sIndex].x = (LONG) (cxClient / 2 *%@NL@%
                                                 (1 + dScale * cos (dAngle))) ;%@NL@%
%@NL@%
                        pptl[sIndex].y = (LONG) (cyClient / 2 *%@NL@%
                                                 (1 + dScale * sin (dAngle))) ;%@NL@%
                        }%@NL@%
                    GpiMove (hps, pptl) ;%@NL@%
                    GpiPolyLine (hps, NUMPOINTS - 1L, pptl + 1) ;%@NL@%
%@NL@%
                    DosFreeSeg (sel) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SQABOUT.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP14\SQABOUT.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------------------------------------%@NL@%
%@AB@%   SQABOUT.C -- Demonstration of About Box with Square 3D Button%@NL@%
%@AB@%  ---------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%"aboutbox.h" %@NL@%
%@NL@%
VOID RegisterSqBtnClass (HAB) ;         // In SQBTN.C%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT EXPENTRY AboutDlgProc  (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass[] = "SqAbout" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU          | FCF_ICON ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     RegisterSqBtnClass (hab) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_NEW:%@NL@%
                    case IDM_OPEN:%@NL@%
                    case IDM_SAVE:%@NL@%
                    case IDM_SAVEAS:%@NL@%
                         WinAlarm (HWND_DESKTOP, WA_NOTE) ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_ABOUT:%@NL@%
                         WinDlgBox (HWND_DESKTOP, hwnd, AboutDlgProc,%@NL@%
                                    NULL, IDD_ABOUT, NULL) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY AboutDlgProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case DID_OK:%@NL@%
                    case DID_CANCEL:%@NL@%
                         WinDismissDlg (hwnd, TRUE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
          }%@NL@%
     return WinDefDlgProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SQBTN.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP14\SQBTN.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------------------------%@NL@%
%@AB@%   SQBTN.C -- Contains window procedure for square 3D push button%@NL@%
%@AB@%  ----------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<malloc.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%LCID_ITALIC 1L %@NL@%
%@NL@%
               %@AB@%/*--------------------------------------------------%@NL@%
%@AB@%                  Structure for storing data unique to each window%@NL@%
%@AB@%                 --------------------------------------------------*/%@AE@%%@NL@%
typedef struct%@NL@%
     {%@NL@%
     PSZ  pszText ;%@NL@%
     BOOL fHaveCapture ;%@NL@%
     BOOL fHaveFocus ;%@NL@%
     BOOL fInsideRect ;%@NL@%
     BOOL fSpaceDown ;%@NL@%
     }%@NL@%
     SQBTN ;%@NL@%
%@NL@%
typedef SQBTN FAR *PSQBTN ;%@NL@%
%@NL@%
MRESULT EXPENTRY SqBtnWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
VOID             DrawButton   (HWND, HPS, PSQBTN) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
          %@AB@%/*--------------------------------------------------------%@NL@%
%@AB@%             RegisterSqBtnClass function available to other modules%@NL@%
%@AB@%            --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
BOOL RegisterSqBtnClass (HAB habIn)%@NL@%
     {%@NL@%
     hab = habIn ;%@NL@%
%@NL@%
     return WinRegisterClass (hab, "SqBtn", SqBtnWndProc,%@NL@%
                              CS_SIZEREDRAW, sizeof (PSQBTN)) ;%@NL@%
     }%@NL@%
%@NL@%
          %@AB@%/*-------------------------------------------%@NL@%
%@AB@%             String functions that accept far pointers%@NL@%
%@AB@%            -------------------------------------------*/%@AE@%%@NL@%
%@NL@%
USHORT fstrlen (PCHAR pch)%@NL@%
     {%@NL@%
     USHORT usLen ;%@NL@%
     for (usLen = 0 ; pch[usLen] ; usLen++) ;%@NL@%
     return usLen ;%@NL@%
     }%@NL@%
%@NL@%
PCHAR fstrcpy (PCHAR pchDst, PCHAR pchSrc)%@NL@%
     {%@NL@%
     USHORT usIndex ;%@NL@%
     for (usIndex = 0 ; pchDst[usIndex] = pchSrc[usIndex] ; usIndex++) ;%@NL@%
     return pchDst ;%@NL@%
     }%@NL@%
%@NL@%
          %@AB@%/*-------------------------------%@NL@%
%@AB@%             SqBtnWndProc window procedure%@NL@%
%@AB@%            -------------------------------*/%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY SqBtnWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     BOOL          fTestInsideRect ;%@NL@%
     HPS           hps ;%@NL@%
     PCREATESTRUCT pcrst ;%@NL@%
     POINTL        ptl ;%@NL@%
     PSQBTN        pSqBtn ;%@NL@%
     PWNDPARAMS    pwprm ;%@NL@%
     RECTL         rcl ;%@NL@%
%@NL@%
     pSqBtn = WinQueryWindowPtr (hwnd, 0) ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               pSqBtn = _fmalloc (sizeof (SQBTN)) ;%@NL@%
%@NL@%
                         // Initialize structure%@NL@%
%@NL@%
               pSqBtn->fHaveCapture = FALSE ;%@NL@%
               pSqBtn->fHaveFocus   = FALSE ;%@NL@%
               pSqBtn->fInsideRect  = FALSE ;%@NL@%
               pSqBtn->fSpaceDown   = FALSE ;%@NL@%
%@NL@%
                         // Get window text from creation structure%@NL@%
%@NL@%
               pcrst = (PCREATESTRUCT) PVOIDFROMMP (mp2) ;%@NL@%
%@NL@%
               pSqBtn->pszText = _fmalloc (1 + fstrlen (pcrst->pszText)) ;%@NL@%
               fstrcpy (pSqBtn->pszText, pcrst->pszText) ;%@NL@%
%@NL@%
               WinSetWindowPtr (hwnd, 0, pSqBtn) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SETWINDOWPARAMS:%@NL@%
               pwprm = (PWNDPARAMS) PVOIDFROMMP (mp1) ;%@NL@%
%@NL@%
                         // Get window text from window parameter structure%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_TEXT)%@NL@%
                    {%@NL@%
                    _ffree (pSqBtn->pszText) ;%@NL@%
                    pSqBtn->pszText = _fmalloc (1 + pwprm->cchText) ;%@NL@%
                    fstrcpy (pSqBtn->pszText, pwprm->pszText) ;%@NL@%
                    }%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_QUERYWINDOWPARAMS:%@NL@%
               pwprm == (PWNDPARAMS) PVOIDFROMMP (mp1) ;%@NL@%
%@NL@%
                         // Set window parameter structure fields%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CCHTEXT)%@NL@%
                    pwprm->cchText = fstrlen (pSqBtn->pszText) ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_TEXT)%@NL@%
                    fstrcpy (pwprm->pszText, pSqBtn->pszText) ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CBPRESPARAMS)%@NL@%
                    pwprm->cbPresParams = 0 ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_PRESPARAMS)%@NL@%
                    pwprm->pPresParams = NULL ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CBCTLDATA)%@NL@%
                    pwprm->cbCtlData = 0 ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CTLDATA)%@NL@%
                    pwprm->pCtlData = NULL ;%@NL@%
%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               WinSetFocus (HWND_DESKTOP, hwnd) ;%@NL@%
               WinSetCapture (HWND_DESKTOP, hwnd) ;%@NL@%
               pSqBtn->fHaveCapture = TRUE ;%@NL@%
               pSqBtn->fInsideRect  = TRUE ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_MOUSEMOVE:%@NL@%
               if (!pSqBtn->fHaveCapture)%@NL@%
                    break ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               ptl.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptl.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
                         // Test if mouse pointer is still in window%@NL@%
%@NL@%
               fTestInsideRect = WinPtInRect (hab, &rcl, &ptl) ;%@NL@%
%@NL@%
               if (pSqBtn->fInsideRect != fTestInsideRect)%@NL@%
                    {%@NL@%
                    pSqBtn->fInsideRect = fTestInsideRect ;%@NL@%
                    WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_BUTTON1UP:%@NL@%
               if (!pSqBtn->fHaveCapture)%@NL@%
                    break ;%@NL@%
%@NL@%
               WinSetCapture (HWND_DESKTOP, NULL) ;%@NL@%
               pSqBtn->fHaveCapture = FALSE ;%@NL@%
               pSqBtn->fInsideRect  = FALSE ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               ptl.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptl.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
                         // Post WM_COMMAND if mouse pointer is in window%@NL@%
%@NL@%
               if (WinPtInRect (hab, &rcl, &ptl))%@NL@%
                    WinPostMsg (WinQueryWindow (hwnd, QW_OWNER, FALSE),%@NL@%
                         WM_COMMAND,%@NL@%
                         MPFROMSHORT (WinQueryWindowUShort (hwnd, QWS_ID)),%@NL@%
                         MPFROM2SHORT (CMDSRC_OTHER, TRUE)) ;%@NL@%
%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_ENABLE:%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SETFOCUS:%@NL@%
               pSqBtn->fHaveFocus = SHORT1FROMMP (mp2) ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               if (!(CHARMSG(&msg)->fs & KC_VIRTUALKEY) ||%@NL@%
                     CHARMSG(&msg)->vkey != VK_SPACE    ||%@NL@%
                     CHARMSG(&msg)->fs & KC_PREVDOWN)%@NL@%
                    break ;%@NL@%
%@NL@%
                         // Post WM_COMMAND when space bar is released%@NL@%
%@NL@%
               if (!(CHARMSG(&msg)->fs & KC_KEYUP))%@NL@%
                    pSqBtn->fSpaceDown = TRUE ;%@NL@%
               else%@NL@%
                    {%@NL@%
                    pSqBtn->fSpaceDown = FALSE ;%@NL@%
                    WinPostMsg (WinQueryWindow (hwnd, QW_OWNER, FALSE),%@NL@%
                         WM_COMMAND,%@NL@%
                         MPFROMSHORT (WinQueryWindowUShort (hwnd, QWS_ID)),%@NL@%
                         MPFROM2SHORT (CMDSRC_OTHER, FALSE)) ;%@NL@%
                    }%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               DrawButton (hwnd, hps, pSqBtn) ;%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               _ffree (pSqBtn->pszText) ;%@NL@%
               _ffree (pSqBtn) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
          %@AB@%/*--------------------------------------------------------%@NL@%
%@AB@%             Draws filled and outlined polygon (used by DrawButton)%@NL@%
%@AB@%            --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
VOID Polygon (HPS hps, LONG lPoints, POINTL aptl[], LONG lColor)%@NL@%
     {%@NL@%
               // Draw interior in specified color%@NL@%
%@NL@%
     GpiSavePS (hps) ;%@NL@%
     GpiSetColor (hps, lColor) ;%@NL@%
%@NL@%
     GpiBeginArea (hps, BA_NOBOUNDARY | BA_ALTERNATE) ;%@NL@%
     GpiMove (hps, aptl) ;%@NL@%
     GpiPolyLine (hps, lPoints - 1, aptl + 1) ;%@NL@%
     GpiEndArea (hps) ;%@NL@%
%@NL@%
     GpiRestorePS (hps, -1L) ;%@NL@%
%@NL@%
               // Draw boundary in default color%@NL@%
%@NL@%
     GpiMove (hps, aptl + lPoints - 1) ;%@NL@%
     GpiPolyLine (hps, lPoints, aptl) ;%@NL@%
     }%@NL@%
%@NL@%
          %@AB@%/*---------------------%@NL@%
%@AB@%             Draws Square Button%@NL@%
%@AB@%            ---------------------*/%@AE@%%@NL@%
%@NL@%
VOID DrawButton (HWND hwnd, HPS hps, PSQBTN pSqBtn)%@NL@%
     {%@NL@%
     FATTRS      fat ;%@NL@%
     FONTMETRICS fm ;%@NL@%
     HDC         hdc ;%@NL@%
     LONG        lColor, lHorzRes, lVertRes, cxEdge, cyEdge ;%@NL@%
     POINTL      aptl[10], aptlTextBox[TXTBOX_COUNT], ptlShadow, ptlText ;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
               // Find 2 millimeter edge width in pixels%@NL@%
%@NL@%
     hdc = GpiQueryDevice (hps) ;%@NL@%
     DevQueryCaps (hdc, CAPS_HORIZONTAL_RESOLUTION, 1L, &lHorzRes) ;%@NL@%
     DevQueryCaps (hdc, CAPS_VERTICAL_RESOLUTION,   1L, &lVertRes) ;%@NL@%
%@NL@%
     cxEdge = lHorzRes / 500 ;%@NL@%
     cyEdge = lVertRes / 500 ;%@NL@%
%@NL@%
               // Set up coordinates for drawing the button%@NL@%
%@NL@%
     WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
     aptl[0].x = 0 ;                    aptl[0].y = 0 ;%@NL@%
     aptl[1].x = cxEdge ;               aptl[1].y = cyEdge ;%@NL@%
     aptl[2].x = rcl.xRight - cxEdge ;  aptl[2].y = cyEdge ;%@NL@%
     aptl[3].x = rcl.xRight - 1 ;       aptl[3].y = 0 ;%@NL@%
     aptl[4].x = rcl.xRight - 1 ;       aptl[4].y = rcl.yTop - 1 ;%@NL@%
     aptl[5].x = rcl.xRight - cxEdge ;  aptl[5].y = rcl.yTop - cyEdge ;%@NL@%
     aptl[6].x = cxEdge ;               aptl[6].y = rcl.yTop - cyEdge ;%@NL@%
     aptl[7].x = 0 ;                    aptl[7].y = rcl.yTop - 1 ;%@NL@%
     aptl[8].x = 0 ;                    aptl[8].y = 0 ;%@NL@%
     aptl[9].x = cxEdge ;               aptl[9].y = cyEdge ;%@NL@%
%@NL@%
               // Paint edges at bottom and right side%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_BLACK) ;%@NL@%
     lColor = (pSqBtn->fInsideRect || pSqBtn->fSpaceDown) ?%@NL@%
                              CLR_PALEGRAY : CLR_DARKGRAY ;%@NL@%
     Polygon (hps, 4L, aptl + 0, lColor) ;%@NL@%
     Polygon (hps, 4L, aptl + 2, lColor) ;%@NL@%
%@NL@%
               // Paint edges at top and left side%@NL@%
%@NL@%
     lColor = (pSqBtn->fInsideRect || pSqBtn->fSpaceDown) ?%@NL@%
                              CLR_DARKGRAY : CLR_WHITE ;%@NL@%
     Polygon (hps, 4L, aptl + 4, lColor) ;%@NL@%
     Polygon (hps, 4L, aptl + 6, lColor) ;%@NL@%
%@NL@%
               // Paint interior area%@NL@%
%@NL@%
     GpiSavePS (hps) ;%@NL@%
     GpiSetColor (hps, (pSqBtn->fInsideRect || pSqBtn->fSpaceDown) ?%@NL@%
                              CLR_DARKGRAY : CLR_PALEGRAY) ;%@NL@%
     GpiMove (hps, aptl + 1) ;%@NL@%
     GpiBox (hps, DRO_FILL, aptl + 5, 0L, 0L) ;%@NL@%
     GpiRestorePS (hps, -1L) ;%@NL@%
     GpiBox (hps, DRO_OUTLINE, aptl + 5, 0L, 0L) ;%@NL@%
%@NL@%
               // If button has focus, use italic font%@NL@%
%@NL@%
     GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
%@NL@%
     if (pSqBtn->fHaveFocus)%@NL@%
          {%@NL@%
          fat.usRecordLength  = sizeof fat ;%@NL@%
          fat.fsSelection     = FATTR_SEL_ITALIC ;%@NL@%
          fat.lMatch          = 0 ;%@NL@%
          fat.idRegistry      = fm.idRegistry ;%@NL@%
          fat.usCodePage      = fm.usCodePage ;%@NL@%
          fat.lMaxBaselineExt = fm.lMaxBaselineExt ;%@NL@%
          fat.lAveCharWidth   = fm.lAveCharWidth ;%@NL@%
          fat.fsType          = 0 ;%@NL@%
          fat.fsFontUse       = 0 ;%@NL@%
          strcpy (fat.szFacename, fm.szFacename) ;%@NL@%
%@NL@%
          GpiCreateLogFont (hps, NULL, LCID_ITALIC, &fat) ;%@NL@%
          GpiSetCharSet (hps, LCID_ITALIC) ;%@NL@%
          }%@NL@%
               // Calculate text position%@NL@%
%@NL@%
     GpiQueryTextBox (hps, (LONG) fstrlen (pSqBtn->pszText), pSqBtn->pszText,%@NL@%
                           TXTBOX_COUNT, aptlTextBox) ;%@NL@%
%@NL@%
     ptlText.x = (rcl.xRight - aptlTextBox[TXTBOX_CONCAT].x) / 2 ;%@NL@%
     ptlText.y = (rcl.yTop   - aptlTextBox[TXTBOX_TOPLEFT].y -%@NL@%
                               aptlTextBox[TXTBOX_BOTTOMLEFT].y) / 2 ;%@NL@%
%@NL@%
     ptlShadow.x = ptlText.x + fm.lAveCharWidth   / 3 ;%@NL@%
     ptlShadow.y = ptlText.y - fm.lMaxBaselineExt / 8 ;%@NL@%
%@NL@%
               // Display text shadow in black, and text in white%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_BLACK) ;%@NL@%
     GpiCharStringAt (hps, &ptlShadow, (LONG) fstrlen (pSqBtn->pszText),%@NL@%
                                       pSqBtn->pszText) ;%@NL@%
     GpiSetColor (hps, CLR_WHITE) ;%@NL@%
     GpiCharStringAt (hps, &ptlText, (LONG) fstrlen (pSqBtn->pszText),%@NL@%
                                     pSqBtn->pszText) ;%@NL@%
%@NL@%
               // X out button if the window is not enabled%@NL@%
%@NL@%
     if (!WinIsWindowEnabled (hwnd))%@NL@%
          {%@NL@%
          GpiMove (hps, aptl + 1) ;%@NL@%
          GpiLine (hps, aptl + 5) ;%@NL@%
          GpiMove (hps, aptl + 2) ;%@NL@%
          GpiLine (hps, aptl + 6) ;%@NL@%
          }%@NL@%
               // Clean up%@NL@%
%@NL@%
     if (pSqBtn->fHaveFocus)%@NL@%
          {%@NL@%
          GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
          GpiDeleteSetId (hps, LCID_ITALIC) ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SQBTN.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP11\SQBTN.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------------------------%@NL@%
%@AB@%   SQBTN.C -- Contains window procedure for square 3D push button%@NL@%
%@AB@%  ----------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<malloc.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%LCID_ITALIC 1L %@NL@%
%@NL@%
               %@AB@%/*--------------------------------------------------%@NL@%
%@AB@%                  Structure for storing data unique to each window%@NL@%
%@AB@%                 --------------------------------------------------*/%@AE@%%@NL@%
typedef struct%@NL@%
     {%@NL@%
     PSZ  pszText ;%@NL@%
     BOOL fHaveCapture ;%@NL@%
     BOOL fHaveFocus ;%@NL@%
     BOOL fInsideRect ;%@NL@%
     BOOL fSpaceDown ;%@NL@%
     }%@NL@%
     SQBTN ;%@NL@%
%@NL@%
typedef SQBTN FAR *PSQBTN ;%@NL@%
%@NL@%
MRESULT EXPENTRY SqBtnWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
VOID             DrawButton   (HWND, HPS, PSQBTN) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
          %@AB@%/*--------------------------------------------------------%@NL@%
%@AB@%             RegisterSqBtnClass function available to other modules%@NL@%
%@AB@%            --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
BOOL RegisterSqBtnClass (HAB habIn)%@NL@%
     {%@NL@%
     hab = habIn ;%@NL@%
%@NL@%
     return WinRegisterClass (hab, "SqBtn", SqBtnWndProc,%@NL@%
                              CS_SIZEREDRAW, sizeof (PSQBTN)) ;%@NL@%
     }%@NL@%
%@NL@%
          %@AB@%/*-------------------------------------------%@NL@%
%@AB@%             String functions that accept far pointers%@NL@%
%@AB@%            -------------------------------------------*/%@AE@%%@NL@%
%@NL@%
USHORT fstrlen (PCHAR pch)%@NL@%
     {%@NL@%
     USHORT usLen ;%@NL@%
     for (usLen = 0 ; pch[usLen] ; usLen++) ;%@NL@%
     return usLen ;%@NL@%
     }%@NL@%
%@NL@%
PCHAR fstrcpy (PCHAR pchDst, PCHAR pchSrc)%@NL@%
     {%@NL@%
     USHORT usIndex ;%@NL@%
     for (usIndex = 0 ; pchDst[usIndex] = pchSrc[usIndex] ; usIndex++) ;%@NL@%
     return pchDst ;%@NL@%
     }%@NL@%
%@NL@%
          %@AB@%/*-------------------------------%@NL@%
%@AB@%             SqBtnWndProc window procedure%@NL@%
%@AB@%            -------------------------------*/%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY SqBtnWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     BOOL          fTestInsideRect ;%@NL@%
     HPS           hps ;%@NL@%
     PCREATESTRUCT pcrst ;%@NL@%
     POINTL        ptl ;%@NL@%
     PSQBTN        pSqBtn ;%@NL@%
     PWNDPARAMS    pwprm ;%@NL@%
     RECTL         rcl ;%@NL@%
%@NL@%
     pSqBtn = WinQueryWindowPtr (hwnd, 0) ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               pSqBtn = _fmalloc (sizeof (SQBTN)) ;%@NL@%
%@NL@%
                         // Initialize structure%@NL@%
%@NL@%
               pSqBtn->fHaveCapture = FALSE ;%@NL@%
               pSqBtn->fHaveFocus   = FALSE ;%@NL@%
               pSqBtn->fInsideRect  = FALSE ;%@NL@%
               pSqBtn->fSpaceDown   = FALSE ;%@NL@%
%@NL@%
                         // Get window text from creation structure%@NL@%
%@NL@%
               pcrst = (PCREATESTRUCT) PVOIDFROMMP (mp2) ;%@NL@%
%@NL@%
               pSqBtn->pszText = _fmalloc (1 + fstrlen (pcrst->pszText)) ;%@NL@%
               fstrcpy (pSqBtn->pszText, pcrst->pszText) ;%@NL@%
%@NL@%
               WinSetWindowPtr (hwnd, 0, pSqBtn) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SETWINDOWPARAMS:%@NL@%
               pwprm = (PWNDPARAMS) PVOIDFROMMP (mp1) ;%@NL@%
%@NL@%
                         // Get window text from window parameter structure%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_TEXT)%@NL@%
                    {%@NL@%
                    _ffree (pSqBtn->pszText) ;%@NL@%
                    pSqBtn->pszText = _fmalloc (1 + pwprm->cchText) ;%@NL@%
                    fstrcpy (pSqBtn->pszText, pwprm->pszText) ;%@NL@%
                    }%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_QUERYWINDOWPARAMS:%@NL@%
               pwprm == (PWNDPARAMS) PVOIDFROMMP (mp1) ;%@NL@%
%@NL@%
                         // Set window parameter structure fields%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CCHTEXT)%@NL@%
                    pwprm->cchText = fstrlen (pSqBtn->pszText) ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_TEXT)%@NL@%
                    fstrcpy (pwprm->pszText, pSqBtn->pszText) ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CBPRESPARAMS)%@NL@%
                    pwprm->cbPresParams = 0 ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_PRESPARAMS)%@NL@%
                    pwprm->pPresParams = NULL ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CBCTLDATA)%@NL@%
                    pwprm->cbCtlData = 0 ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CTLDATA)%@NL@%
                    pwprm->pCtlData = NULL ;%@NL@%
%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               WinSetFocus (HWND_DESKTOP, hwnd) ;%@NL@%
               WinSetCapture (HWND_DESKTOP, hwnd) ;%@NL@%
               pSqBtn->fHaveCapture = TRUE ;%@NL@%
               pSqBtn->fInsideRect  = TRUE ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_MOUSEMOVE:%@NL@%
               if (!pSqBtn->fHaveCapture)%@NL@%
                    break ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               ptl.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptl.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
                         // Test if mouse pointer is still in window%@NL@%
%@NL@%
               fTestInsideRect = WinPtInRect (hab, &rcl, &ptl) ;%@NL@%
%@NL@%
               if (pSqBtn->fInsideRect != fTestInsideRect)%@NL@%
                    {%@NL@%
                    pSqBtn->fInsideRect = fTestInsideRect ;%@NL@%
                    WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_BUTTON1UP:%@NL@%
               if (!pSqBtn->fHaveCapture)%@NL@%
                    break ;%@NL@%
%@NL@%
               WinSetCapture (HWND_DESKTOP, NULL) ;%@NL@%
               pSqBtn->fHaveCapture = FALSE ;%@NL@%
               pSqBtn->fInsideRect  = FALSE ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               ptl.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptl.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
                         // Post WM_COMMAND if mouse pointer is in window%@NL@%
%@NL@%
               if (WinPtInRect (hab, &rcl, &ptl))%@NL@%
                    WinPostMsg (WinQueryWindow (hwnd, QW_OWNER, FALSE),%@NL@%
                         WM_COMMAND,%@NL@%
                         MPFROMSHORT (WinQueryWindowUShort (hwnd, QWS_ID)),%@NL@%
                         MPFROM2SHORT (CMDSRC_OTHER, TRUE)) ;%@NL@%
%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_ENABLE:%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SETFOCUS:%@NL@%
               pSqBtn->fHaveFocus = SHORT1FROMMP (mp2) ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               if (!(CHARMSG(&msg)->fs & KC_VIRTUALKEY) ||%@NL@%
                     CHARMSG(&msg)->vkey != VK_SPACE    ||%@NL@%
                     CHARMSG(&msg)->fs & KC_PREVDOWN)%@NL@%
                    break ;%@NL@%
%@NL@%
                         // Post WM_COMMAND when space bar is released%@NL@%
%@NL@%
               if (!(CHARMSG(&msg)->fs & KC_KEYUP))%@NL@%
                    pSqBtn->fSpaceDown = TRUE ;%@NL@%
               else%@NL@%
                    {%@NL@%
                    pSqBtn->fSpaceDown = FALSE ;%@NL@%
                    WinPostMsg (WinQueryWindow (hwnd, QW_OWNER, FALSE),%@NL@%
                         WM_COMMAND,%@NL@%
                         MPFROMSHORT (WinQueryWindowUShort (hwnd, QWS_ID)),%@NL@%
                         MPFROM2SHORT (CMDSRC_OTHER, FALSE)) ;%@NL@%
                    }%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               DrawButton (hwnd, hps, pSqBtn) ;%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               _ffree (pSqBtn->pszText) ;%@NL@%
               _ffree (pSqBtn) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
          %@AB@%/*--------------------------------------------------------%@NL@%
%@AB@%             Draws filled and outlined polygon (used by DrawButton)%@NL@%
%@AB@%            --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
VOID Polygon (HPS hps, LONG lPoints, POINTL aptl[], LONG lColor)%@NL@%
     {%@NL@%
               // Draw interior in specified color%@NL@%
%@NL@%
     GpiSavePS (hps) ;%@NL@%
     GpiSetColor (hps, lColor) ;%@NL@%
%@NL@%
     GpiBeginArea (hps, BA_NOBOUNDARY | BA_ALTERNATE) ;%@NL@%
     GpiMove (hps, aptl) ;%@NL@%
     GpiPolyLine (hps, lPoints - 1, aptl + 1) ;%@NL@%
     GpiEndArea (hps) ;%@NL@%
%@NL@%
     GpiRestorePS (hps, -1L) ;%@NL@%
%@NL@%
               // Draw boundary in default color%@NL@%
%@NL@%
     GpiMove (hps, aptl + lPoints - 1) ;%@NL@%
     GpiPolyLine (hps, lPoints, aptl) ;%@NL@%
     }%@NL@%
%@NL@%
          %@AB@%/*---------------------%@NL@%
%@AB@%             Draws Square Button%@NL@%
%@AB@%            ---------------------*/%@AE@%%@NL@%
%@NL@%
VOID DrawButton (HWND hwnd, HPS hps, PSQBTN pSqBtn)%@NL@%
     {%@NL@%
     FATTRS      fat ;%@NL@%
     FONTMETRICS fm ;%@NL@%
     HDC         hdc ;%@NL@%
     LONG        lColor, lHorzRes, lVertRes, cxEdge, cyEdge ;%@NL@%
     POINTL      aptl[10], aptlTextBox[TXTBOX_COUNT], ptlShadow, ptlText ;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
               // Find 2 millimeter edge width in pixels%@NL@%
%@NL@%
     hdc = GpiQueryDevice (hps) ;%@NL@%
     DevQueryCaps (hdc, CAPS_HORIZONTAL_RESOLUTION, 1L, &lHorzRes) ;%@NL@%
     DevQueryCaps (hdc, CAPS_VERTICAL_RESOLUTION,   1L, &lVertRes) ;%@NL@%
%@NL@%
     cxEdge = lHorzRes / 500 ;%@NL@%
     cyEdge = lVertRes / 500 ;%@NL@%
%@NL@%
               // Set up coordinates for drawing the button%@NL@%
%@NL@%
     WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
     aptl[0].x = 0 ;                    aptl[0].y = 0 ;%@NL@%
     aptl[1].x = cxEdge ;               aptl[1].y = cyEdge ;%@NL@%
     aptl[2].x = rcl.xRight - cxEdge ;  aptl[2].y = cyEdge ;%@NL@%
     aptl[3].x = rcl.xRight - 1 ;       aptl[3].y = 0 ;%@NL@%
     aptl[4].x = rcl.xRight - 1 ;       aptl[4].y = rcl.yTop - 1 ;%@NL@%
     aptl[5].x = rcl.xRight - cxEdge ;  aptl[5].y = rcl.yTop - cyEdge ;%@NL@%
     aptl[6].x = cxEdge ;               aptl[6].y = rcl.yTop - cyEdge ;%@NL@%
     aptl[7].x = 0 ;                    aptl[7].y = rcl.yTop - 1 ;%@NL@%
     aptl[8].x = 0 ;                    aptl[8].y = 0 ;%@NL@%
     aptl[9].x = cxEdge ;               aptl[9].y = cyEdge ;%@NL@%
%@NL@%
               // Paint edges at bottom and right side%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_BLACK) ;%@NL@%
     lColor = (pSqBtn->fInsideRect || pSqBtn->fSpaceDown) ?%@NL@%
                              CLR_PALEGRAY : CLR_DARKGRAY ;%@NL@%
     Polygon (hps, 4L, aptl + 0, lColor) ;%@NL@%
     Polygon (hps, 4L, aptl + 2, lColor) ;%@NL@%
%@NL@%
               // Paint edges at top and left side%@NL@%
%@NL@%
     lColor = (pSqBtn->fInsideRect || pSqBtn->fSpaceDown) ?%@NL@%
                              CLR_DARKGRAY : CLR_WHITE ;%@NL@%
     Polygon (hps, 4L, aptl + 4, lColor) ;%@NL@%
     Polygon (hps, 4L, aptl + 6, lColor) ;%@NL@%
%@NL@%
               // Paint interior area%@NL@%
%@NL@%
     GpiSavePS (hps) ;%@NL@%
     GpiSetColor (hps, (pSqBtn->fInsideRect || pSqBtn->fSpaceDown) ?%@NL@%
                              CLR_DARKGRAY : CLR_PALEGRAY) ;%@NL@%
     GpiMove (hps, aptl + 1) ;%@NL@%
     GpiBox (hps, DRO_FILL, aptl + 5, 0L, 0L) ;%@NL@%
     GpiRestorePS (hps, -1L) ;%@NL@%
     GpiBox (hps, DRO_OUTLINE, aptl + 5, 0L, 0L) ;%@NL@%
%@NL@%
               // If button has focus, use italic font%@NL@%
%@NL@%
     GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
%@NL@%
     if (pSqBtn->fHaveFocus)%@NL@%
          {%@NL@%
          fat.usRecordLength  = sizeof fat ;%@NL@%
          fat.fsSelection     = FATTR_SEL_ITALIC ;%@NL@%
          fat.lMatch          = 0 ;%@NL@%
          fat.idRegistry      = fm.idRegistry ;%@NL@%
          fat.usCodePage      = fm.usCodePage ;%@NL@%
          fat.lMaxBaselineExt = fm.lMaxBaselineExt ;%@NL@%
          fat.lAveCharWidth   = fm.lAveCharWidth ;%@NL@%
          fat.fsType          = 0 ;%@NL@%
          fat.fsFontUse       = 0 ;%@NL@%
          strcpy (fat.szFacename, fm.szFacename) ;%@NL@%
%@NL@%
          GpiCreateLogFont (hps, NULL, LCID_ITALIC, &fat) ;%@NL@%
          GpiSetCharSet (hps, LCID_ITALIC) ;%@NL@%
          }%@NL@%
               // Calculate text position%@NL@%
%@NL@%
     GpiQueryTextBox (hps, (LONG) fstrlen (pSqBtn->pszText), pSqBtn->pszText,%@NL@%
                           TXTBOX_COUNT, aptlTextBox) ;%@NL@%
%@NL@%
     ptlText.x = (rcl.xRight - aptlTextBox[TXTBOX_CONCAT].x) / 2 ;%@NL@%
     ptlText.y = (rcl.yTop   - aptlTextBox[TXTBOX_TOPLEFT].y -%@NL@%
                               aptlTextBox[TXTBOX_BOTTOMLEFT].y) / 2 ;%@NL@%
%@NL@%
     ptlShadow.x = ptlText.x + fm.lAveCharWidth   / 3 ;%@NL@%
     ptlShadow.y = ptlText.y - fm.lMaxBaselineExt / 8 ;%@NL@%
%@NL@%
               // Display text shadow in black, and text in white%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_BLACK) ;%@NL@%
     GpiCharStringAt (hps, &ptlShadow, (LONG) fstrlen (pSqBtn->pszText),%@NL@%
                                       pSqBtn->pszText) ;%@NL@%
     GpiSetColor (hps, CLR_WHITE) ;%@NL@%
     GpiCharStringAt (hps, &ptlText, (LONG) fstrlen (pSqBtn->pszText),%@NL@%
                                     pSqBtn->pszText) ;%@NL@%
%@NL@%
               // X out button if the window is not enabled%@NL@%
%@NL@%
     if (!WinIsWindowEnabled (hwnd))%@NL@%
          {%@NL@%
          GpiMove (hps, aptl + 1) ;%@NL@%
          GpiLine (hps, aptl + 5) ;%@NL@%
          GpiMove (hps, aptl + 2) ;%@NL@%
          GpiLine (hps, aptl + 6) ;%@NL@%
          }%@NL@%
               // Clean up%@NL@%
%@NL@%
     if (pSqBtn->fHaveFocus)%@NL@%
          {%@NL@%
          GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
          GpiDeleteSetId (hps, LCID_ITALIC) ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SQBTNLIB.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP16\SQBTNLIB.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------------------------------------------%@NL@%
%@AB@%   SQBTNLIB.C -- Dynamic link library version of square 3D push button%@NL@%
%@AB@%  ---------------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<malloc.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"sqbtnlib.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%LCID_ITALIC 1L %@NL@%
%@NL@%
               %@AB@%/*--------------------------------------------------%@NL@%
%@AB@%                  Structure for storing data unique to each window%@NL@%
%@AB@%                 --------------------------------------------------*/%@AE@%%@NL@%
typedef struct%@NL@%
     {%@NL@%
     PSZ  pszText ;%@NL@%
     BOOL fHaveCapture ;%@NL@%
     BOOL fHaveFocus ;%@NL@%
     BOOL fInsideRect ;%@NL@%
     BOOL fSpaceDown ;%@NL@%
     }%@NL@%
     SQBTN ;%@NL@%
%@NL@%
typedef SQBTN *PSQBTN ;%@NL@%
%@NL@%
MRESULT EXPENTRY SqBtnWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
VOID             DrawButton   (HWND, HPS, PSQBTN) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
          %@AB@%/*--------------------------------------------------------%@NL@%
%@AB@%             RegisterSqBtnClass function available to other modules%@NL@%
%@AB@%            --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
BOOL APIENTRY RegisterSqBtnClass (HAB habIn)%@NL@%
     {%@NL@%
     hab = habIn ;%@NL@%
%@NL@%
     return WinRegisterClass (hab, "SqBtn", SqBtnWndProc,%@NL@%
                              CS_SIZEREDRAW, sizeof (PSQBTN)) ;%@NL@%
     }%@NL@%
%@NL@%
          %@AB@%/*-------------------------------%@NL@%
%@AB@%             SqBtnWndProc window procedure%@NL@%
%@AB@%            -------------------------------*/%@AE@%%@NL@%
%@NL@%
MRESULT EXPENTRY SqBtnWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     BOOL          fTestInsideRect ;%@NL@%
     HPS           hps ;%@NL@%
     PCREATESTRUCT pcrst ;%@NL@%
     POINTL        ptl ;%@NL@%
     PSQBTN        pSqBtn ;%@NL@%
     PWNDPARAMS    pwprm ;%@NL@%
     RECTL         rcl ;%@NL@%
%@NL@%
     pSqBtn = WinQueryWindowPtr (hwnd, 0) ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               pSqBtn = malloc (sizeof (SQBTN)) ;%@NL@%
%@NL@%
                         // Initialize structure%@NL@%
%@NL@%
               pSqBtn->fHaveCapture = FALSE ;%@NL@%
               pSqBtn->fHaveFocus   = FALSE ;%@NL@%
               pSqBtn->fInsideRect  = FALSE ;%@NL@%
               pSqBtn->fSpaceDown   = FALSE ;%@NL@%
%@NL@%
                         // Get window text from creation structure%@NL@%
%@NL@%
               pcrst = (PCREATESTRUCT) PVOIDFROMMP (mp2) ;%@NL@%
%@NL@%
               pSqBtn->pszText = malloc (1 + strlen (pcrst->pszText)) ;%@NL@%
               strcpy (pSqBtn->pszText, pcrst->pszText) ;%@NL@%
%@NL@%
               WinSetWindowPtr (hwnd, 0, pSqBtn) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SETWINDOWPARAMS:%@NL@%
               pwprm = (PWNDPARAMS) PVOIDFROMMP (mp1) ;%@NL@%
%@NL@%
                         // Get window text from window parameter structure%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_TEXT)%@NL@%
                    {%@NL@%
                    free (pSqBtn->pszText) ;%@NL@%
                    pSqBtn->pszText = malloc (1 + pwprm->cchText) ;%@NL@%
                    strcpy (pSqBtn->pszText, pwprm->pszText) ;%@NL@%
                    }%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_QUERYWINDOWPARAMS:%@NL@%
               pwprm == (PWNDPARAMS) PVOIDFROMMP (mp1) ;%@NL@%
%@NL@%
                         // Set window parameter structure fields%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CCHTEXT)%@NL@%
                    pwprm->cchText = strlen (pSqBtn->pszText) ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_TEXT)%@NL@%
                    strcpy (pwprm->pszText, pSqBtn->pszText) ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CBPRESPARAMS)%@NL@%
                    pwprm->cbPresParams = 0 ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_PRESPARAMS)%@NL@%
                    pwprm->pPresParams = NULL ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CBCTLDATA)%@NL@%
                    pwprm->cbCtlData = 0 ;%@NL@%
%@NL@%
               if (pwprm->fsStatus & WPM_CTLDATA)%@NL@%
                    pwprm->pCtlData = NULL ;%@NL@%
%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               WinSetFocus (HWND_DESKTOP, hwnd) ;%@NL@%
               WinSetCapture (HWND_DESKTOP, hwnd) ;%@NL@%
               pSqBtn->fHaveCapture = TRUE ;%@NL@%
               pSqBtn->fInsideRect  = TRUE ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_MOUSEMOVE:%@NL@%
               if (!pSqBtn->fHaveCapture)%@NL@%
                    break ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               ptl.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptl.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
                         // Test if mouse pointer is still in window%@NL@%
%@NL@%
               fTestInsideRect = WinPtInRect (hab, &rcl, &ptl) ;%@NL@%
%@NL@%
               if (pSqBtn->fInsideRect != fTestInsideRect)%@NL@%
                    {%@NL@%
                    pSqBtn->fInsideRect = fTestInsideRect ;%@NL@%
                    WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_BUTTON1UP:%@NL@%
               if (!pSqBtn->fHaveCapture)%@NL@%
                    break ;%@NL@%
%@NL@%
               WinSetCapture (HWND_DESKTOP, NULL) ;%@NL@%
               pSqBtn->fHaveCapture = FALSE ;%@NL@%
               pSqBtn->fInsideRect  = FALSE ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               ptl.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptl.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
                         // Post WM_COMMAND if mouse pointer is in window%@NL@%
%@NL@%
               if (WinPtInRect (hab, &rcl, &ptl))%@NL@%
                    WinPostMsg (WinQueryWindow (hwnd, QW_OWNER, FALSE),%@NL@%
                         WM_COMMAND,%@NL@%
                         MPFROMSHORT (WinQueryWindowUShort (hwnd, QWS_ID)),%@NL@%
                         MPFROM2SHORT (CMDSRC_OTHER, TRUE)) ;%@NL@%
%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_ENABLE:%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SETFOCUS:%@NL@%
               pSqBtn->fHaveFocus = SHORT1FROMMP (mp2) ;%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               if (!(CHARMSG(&msg)->fs & KC_VIRTUALKEY) ||%@NL@%
                     CHARMSG(&msg)->vkey != VK_SPACE    ||%@NL@%
                     CHARMSG(&msg)->fs & KC_PREVDOWN)%@NL@%
                    break ;%@NL@%
%@NL@%
                         // Post WM_COMMAND when space bar is released%@NL@%
%@NL@%
               if (!(CHARMSG(&msg)->fs & KC_KEYUP))%@NL@%
                    pSqBtn->fSpaceDown = TRUE ;%@NL@%
               else%@NL@%
                    {%@NL@%
                    pSqBtn->fSpaceDown = FALSE ;%@NL@%
                    WinPostMsg (WinQueryWindow (hwnd, QW_OWNER, FALSE),%@NL@%
                         WM_COMMAND,%@NL@%
                         MPFROMSHORT (WinQueryWindowUShort (hwnd, QWS_ID)),%@NL@%
                         MPFROM2SHORT (CMDSRC_OTHER, FALSE)) ;%@NL@%
                    }%@NL@%
               WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               DrawButton (hwnd, hps, pSqBtn) ;%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               free (pSqBtn->pszText) ;%@NL@%
               free (pSqBtn) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
          %@AB@%/*--------------------------------------------------------%@NL@%
%@AB@%             Draws filled and outlined polygon (used by DrawButton)%@NL@%
%@AB@%            --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
VOID Polygon (HPS hps, LONG lPoints, POINTL aptl[], LONG lColor)%@NL@%
     {%@NL@%
               // Draw interior in specified color%@NL@%
%@NL@%
     GpiSavePS (hps) ;%@NL@%
     GpiSetColor (hps, lColor) ;%@NL@%
%@NL@%
     GpiBeginArea (hps, BA_NOBOUNDARY | BA_ALTERNATE) ;%@NL@%
     GpiMove (hps, aptl) ;%@NL@%
     GpiPolyLine (hps, lPoints - 1, aptl + 1) ;%@NL@%
     GpiEndArea (hps) ;%@NL@%
%@NL@%
     GpiRestorePS (hps, -1L) ;%@NL@%
%@NL@%
               // Draw boundary in default color%@NL@%
%@NL@%
     GpiMove (hps, aptl + lPoints - 1) ;%@NL@%
     GpiPolyLine (hps, lPoints, aptl) ;%@NL@%
     }%@NL@%
%@NL@%
          %@AB@%/*---------------------%@NL@%
%@AB@%             Draws Square Button%@NL@%
%@AB@%            ---------------------*/%@AE@%%@NL@%
%@NL@%
VOID DrawButton (HWND hwnd, HPS hps, PSQBTN pSqBtn)%@NL@%
     {%@NL@%
     FATTRS      fat ;%@NL@%
     FONTMETRICS fm ;%@NL@%
     HDC         hdc ;%@NL@%
     LONG        lColor, lHorzRes, lVertRes, cxEdge, cyEdge ;%@NL@%
     POINTL      aptl[10], aptlTextBox[TXTBOX_COUNT], ptlShadow, ptlText ;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
               // Find 2 millimeter edge width in pixels%@NL@%
%@NL@%
     hdc = GpiQueryDevice (hps) ;%@NL@%
     DevQueryCaps (hdc, CAPS_HORIZONTAL_RESOLUTION, 1L, &lHorzRes) ;%@NL@%
     DevQueryCaps (hdc, CAPS_VERTICAL_RESOLUTION,   1L, &lVertRes) ;%@NL@%
%@NL@%
     cxEdge = lHorzRes / 500 ;%@NL@%
     cyEdge = lVertRes / 500 ;%@NL@%
%@NL@%
               // Set up coordinates for drawing the button%@NL@%
%@NL@%
     WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
     aptl[0].x = 0 ;                    aptl[0].y = 0 ;%@NL@%
     aptl[1].x = cxEdge ;               aptl[1].y = cyEdge ;%@NL@%
     aptl[2].x = rcl.xRight - cxEdge ;  aptl[2].y = cyEdge ;%@NL@%
     aptl[3].x = rcl.xRight - 1 ;       aptl[3].y = 0 ;%@NL@%
     aptl[4].x = rcl.xRight - 1 ;       aptl[4].y = rcl.yTop - 1 ;%@NL@%
     aptl[5].x = rcl.xRight - cxEdge ;  aptl[5].y = rcl.yTop - cyEdge ;%@NL@%
     aptl[6].x = cxEdge ;               aptl[6].y = rcl.yTop - cyEdge ;%@NL@%
     aptl[7].x = 0 ;                    aptl[7].y = rcl.yTop - 1 ;%@NL@%
     aptl[8].x = 0 ;                    aptl[8].y = 0 ;%@NL@%
     aptl[9].x = cxEdge ;               aptl[9].y = cyEdge ;%@NL@%
%@NL@%
               // Paint edges at bottom and right side%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_BLACK) ;%@NL@%
     lColor = (pSqBtn->fInsideRect || pSqBtn->fSpaceDown) ?%@NL@%
                              CLR_PALEGRAY : CLR_DARKGRAY ;%@NL@%
     Polygon (hps, 4L, aptl + 0, lColor) ;%@NL@%
     Polygon (hps, 4L, aptl + 2, lColor) ;%@NL@%
%@NL@%
               // Paint edges at top and left side%@NL@%
%@NL@%
     lColor = (pSqBtn->fInsideRect || pSqBtn->fSpaceDown) ?%@NL@%
                              CLR_DARKGRAY : CLR_WHITE ;%@NL@%
     Polygon (hps, 4L, aptl + 4, lColor) ;%@NL@%
     Polygon (hps, 4L, aptl + 6, lColor) ;%@NL@%
%@NL@%
               // Paint interior area%@NL@%
%@NL@%
     GpiSavePS (hps) ;%@NL@%
     GpiSetColor (hps, (pSqBtn->fInsideRect || pSqBtn->fSpaceDown) ?%@NL@%
                              CLR_DARKGRAY : CLR_PALEGRAY) ;%@NL@%
     GpiMove (hps, aptl + 1) ;%@NL@%
     GpiBox (hps, DRO_FILL, aptl + 5, 0L, 0L) ;%@NL@%
     GpiRestorePS (hps, -1L) ;%@NL@%
     GpiBox (hps, DRO_OUTLINE, aptl + 5, 0L, 0L) ;%@NL@%
%@NL@%
               // If button has focus, use italic font%@NL@%
%@NL@%
     GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
%@NL@%
     if (pSqBtn->fHaveFocus)%@NL@%
          {%@NL@%
          fat.usRecordLength  = sizeof fat ;%@NL@%
          fat.fsSelection     = FATTR_SEL_ITALIC ;%@NL@%
          fat.lMatch          = 0 ;%@NL@%
          fat.idRegistry      = fm.idRegistry ;%@NL@%
          fat.usCodePage      = fm.usCodePage ;%@NL@%
          fat.lMaxBaselineExt = fm.lMaxBaselineExt ;%@NL@%
          fat.lAveCharWidth   = fm.lAveCharWidth ;%@NL@%
          fat.fsType          = 0 ;%@NL@%
          fat.fsFontUse       = 0 ;%@NL@%
          strcpy (fat.szFacename, fm.szFacename) ;%@NL@%
%@NL@%
          GpiCreateLogFont (hps, NULL, LCID_ITALIC, &fat) ;%@NL@%
          GpiSetCharSet (hps, LCID_ITALIC) ;%@NL@%
          }%@NL@%
               // Calculate text position%@NL@%
%@NL@%
     GpiQueryTextBox (hps, (LONG) strlen (pSqBtn->pszText), pSqBtn->pszText,%@NL@%
                           TXTBOX_COUNT, aptlTextBox) ;%@NL@%
%@NL@%
     ptlText.x = (rcl.xRight - aptlTextBox[TXTBOX_CONCAT].x) / 2 ;%@NL@%
     ptlText.y = (rcl.yTop   - aptlTextBox[TXTBOX_TOPLEFT].y -%@NL@%
                               aptlTextBox[TXTBOX_BOTTOMLEFT].y) / 2 ;%@NL@%
%@NL@%
     ptlShadow.x = ptlText.x + fm.lAveCharWidth   / 3 ;%@NL@%
     ptlShadow.y = ptlText.y - fm.lMaxBaselineExt / 8 ;%@NL@%
%@NL@%
               // Display text shadow in black, and text in white%@NL@%
%@NL@%
     GpiSetColor (hps, CLR_BLACK) ;%@NL@%
     GpiCharStringAt (hps, &ptlShadow, (LONG) strlen (pSqBtn->pszText),%@NL@%
                                       pSqBtn->pszText) ;%@NL@%
     GpiSetColor (hps, CLR_WHITE) ;%@NL@%
     GpiCharStringAt (hps, &ptlText, (LONG) strlen (pSqBtn->pszText),%@NL@%
                                     pSqBtn->pszText) ;%@NL@%
%@NL@%
               // X out button if the window is not enabled%@NL@%
%@NL@%
     if (!WinIsWindowEnabled (hwnd))%@NL@%
          {%@NL@%
          GpiMove (hps, aptl + 1) ;%@NL@%
          GpiLine (hps, aptl + 5) ;%@NL@%
          GpiMove (hps, aptl + 2) ;%@NL@%
          GpiLine (hps, aptl + 6) ;%@NL@%
          }%@NL@%
               // Clean up%@NL@%
%@NL@%
     if (pSqBtn->fHaveFocus)%@NL@%
          {%@NL@%
          GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
          GpiDeleteSetId (hps, LCID_ITALIC) ;%@NL@%
          }%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%STAR5.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\STAR5.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------%@NL@%
%@AB@%   STAR5.C -- Draws 5-Pointed Star%@NL@%
%@AB@% ----------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Star5" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static POINTL aptlStar[5] = {-59,-81, 0,100, 59,-81, -95,31, 95,31 } ;%@NL@%
     static SHORT  cxClient, cyClient ;%@NL@%
     HPS           hps ;%@NL@%
     POINTL        aptl[5] ;%@NL@%
     SHORT         sIndex ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               for (sIndex = 0 ; sIndex < 5 ; sIndex++)%@NL@%
                    {%@NL@%
                    aptl[sIndex].x = cxClient / 2 + cxClient *%@NL@%
                                                 aptlStar[sIndex].x / 200 ;%@NL@%
                    aptl[sIndex].y = cyClient / 2 + cyClient *%@NL@%
                                                 aptlStar[sIndex].y / 200 ;%@NL@%
                    }%@NL@%
               GpiMove (hps, aptl + 4) ;%@NL@%
               GpiPolyLine (hps, 5L, aptl) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%STARFILL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP05\STARFILL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------%@NL@%
%@AB@%   STARFILL.C -- Alternate and Winding Modes%@NL@%
%@AB@% --------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "StarFill" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass,%@NL@%
                                     " - Alternate and Winding",%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static POINTL aptlStar[5] = {-59,-81, 0,100, 59,-81, -95,31, 95,31 } ;%@NL@%
     static SHORT  cxClient, cyClient ;%@NL@%
     HPS           hps ;%@NL@%
     POINTL        aptl[5] ;%@NL@%
     SHORT         sIndex ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
               GpiSetPattern (hps, PATSYM_HALFTONE) ;%@NL@%
%@NL@%
                         %@AB@%/*---------------------%@NL@%
%@AB@%                            Alternate Fill Mode%@NL@%
%@AB@%                           ---------------------*/%@AE@%%@NL@%
%@NL@%
               for (sIndex = 0 ; sIndex < 5 ; sIndex++)%@NL@%
                    {%@NL@%
                    aptl[sIndex].x = cxClient / 4 + cxClient *%@NL@%
                                          aptlStar[sIndex].x / 400 ;%@NL@%
                    aptl[sIndex].y = cyClient / 2 + cyClient *%@NL@%
                                          aptlStar[sIndex].y / 200 ;%@NL@%
                    }%@NL@%
%@NL@%
               GpiBeginArea (hps, BA_NOBOUNDARY | BA_ALTERNATE) ;%@NL@%
               GpiMove (hps, aptl) ;%@NL@%
               GpiPolyLine (hps, 4L, aptl + 1) ;%@NL@%
               GpiEndArea (hps) ;%@NL@%
%@NL@%
                         %@AB@%/*-------------------%@NL@%
%@AB@%                            Winding Fill Mode%@NL@%
%@AB@%                           -------------------*/%@AE@%%@NL@%
%@NL@%
               for (sIndex = 0 ; sIndex < 5 ; sIndex++)%@NL@%
                    aptl[sIndex].x += cxClient / 2 ;%@NL@%
%@NL@%
               GpiBeginArea (hps, BA_NOBOUNDARY | BA_WINDING) ;%@NL@%
               GpiMove (hps, aptl) ;%@NL@%
               GpiPolyLine (hps, 4L, aptl + 1) ;%@NL@%
               GpiEndArea (hps) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SYSVALS.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP04\SYSVALS.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------%@NL@%
%@AB@%   SYSVALS.C -- System Values Display Program%@NL@%
%@AB@%  --------------------------------------------*/%@AE@%%@NL@%
 %@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"sysvals.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "SysVals" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_VERTSCROLL    | FCF_HORZSCROLL ;%@NL@%
     HAB            hab ;%@NL@%
     HMQ            hmq ;%@NL@%
     HWND           hwndFrame, hwndClient ;%@NL@%
     QMSG           qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
LONG RtJustCharStringAt (HPS hps, POINTL *pptl, LONG lLength, CHAR *pchText)%@NL@%
     {%@NL@%
     POINTL aptlTextBox[TXTBOX_COUNT] ;%@NL@%
%@NL@%
     GpiQueryTextBox (hps, lLength, pchText, TXTBOX_COUNT, aptlTextBox) ;%@NL@%
%@NL@%
     pptl->x -= aptlTextBox[TXTBOX_CONCAT].x ;%@NL@%
%@NL@%
     return GpiCharStringAt (hps, pptl, lLength, pchText) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static HWND  hwndHscroll, hwndVscroll ;%@NL@%
     static SHORT sHscrollMax, sVscrollMax, sHscrollPos, sVscrollPos,%@NL@%
                  cxChar, cxCaps, cyChar, cyDesc, cxClient, cyClient,%@NL@%
                  cxTextTotal ;%@NL@%
     CHAR         szBuffer [10] ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       ptl ;%@NL@%
     SHORT        sLine, sPaintBeg, sPaintEnd, sHscrollInc, sVscrollInc ;%@NL@%
     RECTL        rclInvalid ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
     %@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cxCaps = (SHORT) fm.lEmInc ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               cxTextTotal = 28 * cxCaps + 38 * cxChar ;%@NL@%
%@NL@%
               hwndHscroll = WinWindowFromID (%@NL@%
                                   WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                                   FID_HORZSCROLL) ;%@NL@%
%@NL@%
               hwndVscroll = WinWindowFromID (%@NL@%
                                   WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                                   FID_VERTSCROLL) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               sHscrollMax = max (0, cxTextTotal - cxClient) ;%@NL@%
               sHscrollPos = min (sHscrollPos, sHscrollMax) ;%@NL@%
%@NL@%
               WinSendMsg (hwndHscroll, SBM_SETSCROLLBAR,%@NL@%
                                        MPFROM2SHORT (sHscrollPos, 0),%@NL@%
                                        MPFROM2SHORT (0, sHscrollMax)) ;%@NL@%
%@NL@%
               WinEnableWindow (hwndHscroll, sHscrollMax ? TRUE : FALSE) ;%@NL@%
%@NL@%
               sVscrollMax = max (0, NUMLINES - cyClient / cyChar) ;%@NL@%
               sVscrollPos = min (sVscrollPos, sVscrollMax) ;%@NL@%
%@NL@%
               WinSendMsg (hwndVscroll, SBM_SETSCROLLBAR,%@NL@%
                                        MPFROM2SHORT (sVscrollPos, 0),%@NL@%
                                        MPFROM2SHORT (0, sVscrollMax)) ;%@NL@%
%@NL@%
               WinEnableWindow (hwndVscroll, sVscrollMax ? TRUE : FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_HSCROLL:%@NL@%
               switch (SHORT2FROMMP (mp2))%@NL@%
                    {%@NL@%
                    case SB_LINELEFT:%@NL@%
                         sHscrollInc = -cxCaps ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_LINERIGHT:%@NL@%
                         sHscrollInc = cxCaps ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGELEFT:%@NL@%
                         sHscrollInc = -8 * cxCaps ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGERIGHT:%@NL@%
                         sHscrollInc = 8 * cxCaps ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_SLIDERPOSITION:%@NL@%
                         sHscrollInc = SHORT1FROMMP (mp2) - sHscrollPos;%@NL@%
                         break ;%@NL@%
%@NL@%
                    default:%@NL@%
                         sHscrollInc = 0 ;%@NL@%
                         break ;%@NL@%
                    }%@NL@%
%@NL@%
               sHscrollInc = max (-sHscrollPos,%@NL@%
                             min (sHscrollInc, sHscrollMax - sHscrollPos)) ;%@NL@%
%@NL@%
               if (sHscrollInc != 0)%@NL@%
                    {%@NL@%
                    sHscrollPos += sHscrollInc ;%@NL@%
                    WinScrollWindow (hwnd, -sHscrollInc, 0,%@NL@%
                                   NULL, NULL, NULL, NULL, SW_INVALIDATERGN) ;%@NL@%
%@NL@%
                    WinSendMsg (hwndHscroll, SBM_SETPOS,%@NL@%
                                MPFROMSHORT (sHscrollPos), NULL) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_VSCROLL:%@NL@%
               switch (SHORT2FROMMP (mp2))%@NL@%
                    {%@NL@%
                    case SB_LINEUP:%@NL@%
                         sVscrollInc = -1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_LINEDOWN:%@NL@%
                         sVscrollInc = 1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEUP:%@NL@%
                         sVscrollInc = min (-1, -cyClient / cyChar) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEDOWN:%@NL@%
                         sVscrollInc = max (1, cyClient / cyChar) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_SLIDERTRACK:%@NL@%
                         sVscrollInc = SHORT1FROMMP (mp2) - sVscrollPos;%@NL@%
                         break ;%@NL@%
%@NL@%
                    default:%@NL@%
                         sVscrollInc = 0 ;%@NL@%
                         break ;%@NL@%
                    }%@NL@%
%@NL@%
               sVscrollInc = max (-sVscrollPos,%@NL@%
                             min (sVscrollInc, sVscrollMax - sVscrollPos)) ;%@NL@%
%@NL@%
               if (sVscrollInc != 0) ;%@NL@%
                    {%@NL@%
                    sVscrollPos += sVscrollInc ;%@NL@%
                    WinScrollWindow (hwnd, 0, cyChar * sVscrollInc,%@NL@%
                                   NULL, NULL, NULL, NULL, SW_INVALIDATERGN) ;%@NL@%
%@NL@%
                    WinSendMsg (hwndVscroll, SBM_SETPOS,%@NL@%
                                MPFROMSHORT (sVscrollPos), NULL) ;%@NL@%
                    WinUpdateWindow (hwnd) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               switch (CHARMSG(&msg)->vkey)%@NL@%
                    {%@NL@%
                    case VK_LEFT:%@NL@%
                    case VK_RIGHT:%@NL@%
                         return WinSendMsg (hwndHscroll, msg, mp1, mp2) ;%@NL@%
                    case VK_UP:%@NL@%
                    case VK_DOWN:%@NL@%
                    case VK_PAGEUP:%@NL@%
                    case VK_PAGEDOWN:%@NL@%
                         return WinSendMsg (hwndVscroll, msg, mp1, mp2) ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, &rclInvalid) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               sPaintBeg = max (0, sVscrollPos +%@NL@%
                              (cyClient - (SHORT) rclInvalid.yTop) / cyChar) ;%@NL@%
               sPaintEnd = min (NUMLINES, sVscrollPos +%@NL@%
                              (cyClient - (SHORT) rclInvalid.yBottom)%@NL@%
                                   / cyChar + 1) ;%@NL@%
%@NL@%
               for (sLine = sPaintBeg ; sLine < sPaintEnd ; sLine++)%@NL@%
                    {%@NL@%
                    ptl.x = cxCaps - sHscrollPos ;%@NL@%
                    ptl.y = cyClient - cyChar * (sLine + 1 - sVscrollPos)%@NL@%
                                     + cyDesc ;%@NL@%
%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                              (LONG) strlen (sysvals[sLine].szIdentifier),%@NL@%
                              sysvals[sLine].szIdentifier) ;%@NL@%
%@NL@%
                    ptl.x += 20 * cxCaps ;%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                              (LONG) strlen (sysvals[sLine].szDescription),%@NL@%
                              sysvals[sLine].szDescription) ;%@NL@%
%@NL@%
                    ltoa (WinQuerySysValue (HWND_DESKTOP,%@NL@%
                               sysvals[sLine].sIndex), szBuffer, 10) ;%@NL@%
%@NL@%
                    ptl.x += 38 * cxChar + 6 * cxCaps ;%@NL@%
                    RtJustCharStringAt (hps, &ptl, (LONG) strlen (szBuffer),%@NL@%
                                        szBuffer) ;%@NL@%
                    }%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SYSVALS1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP04\SYSVALS1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------------------------%@NL@%
%@AB@%   SYSVALS1.C -- System Values Display Program No. 1%@NL@%
%@AB@%  ---------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"sysvals.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "SysVals1" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                      WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                      NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static SHORT cxChar, cxCaps, cyChar, cyDesc, cxClient, cyClient ;%@NL@%
     CHAR         szBuffer [10] ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       ptl ;%@NL@%
     SHORT        sLine ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cxCaps = (SHORT) fm.lEmInc ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               for (sLine = 0 ; sLine < NUMLINES ; sLine++)%@NL@%
                    {%@NL@%
                    ptl.x = cxCaps ;%@NL@%
                    ptl.y = cyClient - cyChar * (sLine + 1) + cyDesc ;%@NL@%
%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                              (LONG) strlen (sysvals[sLine].szIdentifier),%@NL@%
                              sysvals[sLine].szIdentifier) ;%@NL@%
%@NL@%
                    ptl.x += 20 * cxCaps ;%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                              (LONG) strlen (sysvals[sLine].szDescription),%@NL@%
                              sysvals[sLine].szDescription) ;%@NL@%
%@NL@%
                    ltoa (WinQuerySysValue (HWND_DESKTOP,%@NL@%
                               sysvals[sLine].sIndex), szBuffer, 10) ;%@NL@%
%@NL@%
                    ptl.x += 38 * cxChar ;%@NL@%
                    GpiCharStringAt (hps, &ptl, (LONG) strlen (szBuffer),%@NL@%
                                     szBuffer) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SYSVALS2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP04\SYSVALS2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------------------------%@NL@%
%@AB@%   SYSVALS2.C -- System Values Display Program No. 2%@NL@%
%@AB@%  ---------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"sysvals.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "SysVals2" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_VERTSCROLL ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static HWND  hwndVscroll ;%@NL@%
     static SHORT cxChar, cxCaps, cyChar, cyDesc,%@NL@%
                  sVscrollPos, cxClient, cyClient ;%@NL@%
     CHAR         szBuffer [10] ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       ptl ;%@NL@%
     SHORT        sLine ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cxCaps = (SHORT) fm.lEmInc ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               hwndVscroll = WinWindowFromID (%@NL@%
                                   WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                                   FID_VERTSCROLL) ;%@NL@%
%@NL@%
               WinSendMsg (hwndVscroll, SBM_SETSCROLLBAR,%@NL@%
                                   MPFROM2SHORT (sVscrollPos, 0),%@NL@%
                                   MPFROM2SHORT (0, NUMLINES - 1)) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_VSCROLL:%@NL@%
               switch (SHORT2FROMMP (mp2))%@NL@%
                    {%@NL@%
                    case SB_LINEUP:%@NL@%
                         sVscrollPos -= 1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_LINEDOWN:%@NL@%
                         sVscrollPos += 1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEUP:%@NL@%
                         sVscrollPos -= cyClient / cyChar ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEDOWN:%@NL@%
                         sVscrollPos += cyClient / cyChar ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_SLIDERPOSITION:%@NL@%
                         sVscrollPos = SHORT1FROMMP (mp2) ;%@NL@%
                         break ;%@NL@%
                    }%@NL@%
               sVscrollPos = max (0, min (sVscrollPos, NUMLINES - 1)) ;%@NL@%
%@NL@%
               if (sVscrollPos != SHORT1FROMMR (WinSendMsg (hwndVscroll,%@NL@%
                                       SBM_QUERYPOS, NULL, NULL)))%@NL@%
                    {%@NL@%
                    WinSendMsg (hwndVscroll, SBM_SETPOS,%@NL@%
                                MPFROMSHORT (sVscrollPos), NULL) ;%@NL@%
                    WinInvalidateRect (hwnd, NULL, FALSE) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               for (sLine = 0 ; sLine < NUMLINES ; sLine++)%@NL@%
                    {%@NL@%
                    ptl.x = cxCaps ;%@NL@%
                    ptl.y = cyClient - cyChar * (sLine + 1 - sVscrollPos)%@NL@%
                                     + cyDesc ;%@NL@%
%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                              (LONG) strlen (sysvals[sLine].szIdentifier),%@NL@%
                              sysvals[sLine].szIdentifier) ;%@NL@%
%@NL@%
                    ptl.x += 20 * cxCaps ;%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                              (LONG) strlen (sysvals[sLine].szDescription),%@NL@%
                              sysvals[sLine].szDescription) ;%@NL@%
%@NL@%
                    ltoa (WinQuerySysValue (HWND_DESKTOP,%@NL@%
                               sysvals[sLine].sIndex), szBuffer, 10) ;%@NL@%
%@NL@%
                    ptl.x += 38 * cxChar ;%@NL@%
                    GpiCharStringAt (hps, &ptl, (LONG) strlen (szBuffer),%@NL@%
                                     szBuffer) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SYSVALS3.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP04\SYSVALS3.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*---------------------------------------------------%@NL@%
%@AB@%   SYSVALS3.C -- System Values Display Program No. 3%@NL@%
%@AB@%  ---------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@AI@%#include %@AE@%"sysvals.h" %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "SysVals3" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_VERTSCROLL    | FCF_HORZSCROLL ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
LONG RtJustCharStringAt (HPS hps, POINTL *pptl, LONG lLength, CHAR *pchText)%@NL@%
     {%@NL@%
     POINTL aptlTextBox[TXTBOX_COUNT] ;%@NL@%
%@NL@%
     GpiQueryTextBox (hps, lLength, pchText, TXTBOX_COUNT, aptlTextBox) ;%@NL@%
%@NL@%
     pptl->x -= aptlTextBox[TXTBOX_CONCAT].x ;%@NL@%
%@NL@%
     return GpiCharStringAt (hps, pptl, lLength, pchText) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static HWND  hwndHscroll, hwndVscroll ;%@NL@%
     static SHORT sHscrollMax, sVscrollMax, sHscrollPos, sVscrollPos,%@NL@%
                  cxChar, cxCaps, cyChar, cyDesc, cxClient, cyClient,%@NL@%
                  cxTextTotal ;%@NL@%
     CHAR         szBuffer [10] ;%@NL@%
     FONTMETRICS  fm ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       ptl ;%@NL@%
     SHORT        sLine, sPaintBeg, sPaintEnd, sHscrollInc, sVscrollInc ;%@NL@%
     RECTL        rclInvalid ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
%@NL@%
               cxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
               cxCaps = (SHORT) fm.lEmInc ;%@NL@%
               cyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
               cyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
%@NL@%
               cxTextTotal = 28 * cxCaps + 38 * cxChar ;%@NL@%
%@NL@%
               hwndHscroll = WinWindowFromID (%@NL@%
                                   WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                                   FID_HORZSCROLL) ;%@NL@%
%@NL@%
               hwndVscroll = WinWindowFromID (%@NL@%
                                   WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                                   FID_VERTSCROLL) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               sHscrollMax = max (0, cxTextTotal - cxClient) ;%@NL@%
               sHscrollPos = min (sHscrollPos, sHscrollMax) ;%@NL@%
%@NL@%
               WinSendMsg (hwndHscroll, SBM_SETSCROLLBAR,%@NL@%
                                        MPFROM2SHORT (sHscrollPos, 0),%@NL@%
                                        MPFROM2SHORT (0, sHscrollMax)) ;%@NL@%
%@NL@%
               WinEnableWindow (hwndHscroll, sHscrollMax ? TRUE : FALSE) ;%@NL@%
%@NL@%
               sVscrollMax = max (0, NUMLINES - cyClient / cyChar) ;%@NL@%
               sVscrollPos = min (sVscrollPos, sVscrollMax) ;%@NL@%
%@NL@%
               WinSendMsg (hwndVscroll, SBM_SETSCROLLBAR,%@NL@%
                                        MPFROM2SHORT (sVscrollPos, 0),%@NL@%
                                        MPFROM2SHORT (0, sVscrollMax)) ;%@NL@%
%@NL@%
               WinEnableWindow (hwndVscroll, sVscrollMax ? TRUE : FALSE) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_HSCROLL:%@NL@%
               switch (SHORT2FROMMP (mp2))%@NL@%
                    {%@NL@%
                    case SB_LINELEFT:%@NL@%
                         sHscrollInc = -cxCaps ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_LINERIGHT:%@NL@%
                         sHscrollInc = cxCaps ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGELEFT:%@NL@%
                         sHscrollInc = -8 * cxCaps ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGERIGHT:%@NL@%
                         sHscrollInc = 8 * cxCaps ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_SLIDERPOSITION:%@NL@%
                         sHscrollInc = SHORT1FROMMP (mp2) - sHscrollPos;%@NL@%
                         break ;%@NL@%
%@NL@%
                    default:%@NL@%
                         sHscrollInc = 0 ;%@NL@%
                         break ;%@NL@%
                    }%@NL@%
               sHscrollInc = max (-sHscrollPos,%@NL@%
                             min (sHscrollInc, sHscrollMax - sHscrollPos)) ;%@NL@%
%@NL@%
               if (sHscrollInc != 0)%@NL@%
                    {%@NL@%
                    sHscrollPos += sHscrollInc ;%@NL@%
                    WinScrollWindow (hwnd, -sHscrollInc, 0,%@NL@%
                                   NULL, NULL, NULL, NULL, SW_INVALIDATERGN) ;%@NL@%
%@NL@%
                    WinSendMsg (hwndHscroll, SBM_SETPOS,%@NL@%
                                MPFROMSHORT (sHscrollPos), NULL) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_VSCROLL:%@NL@%
               switch (SHORT2FROMMP (mp2))%@NL@%
                    {%@NL@%
                    case SB_LINEUP:%@NL@%
                         sVscrollInc = -1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_LINEDOWN:%@NL@%
                         sVscrollInc = 1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEUP:%@NL@%
                         sVscrollInc = min (-1, -cyClient / cyChar) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEDOWN:%@NL@%
                         sVscrollInc = max (1, cyClient / cyChar) ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_SLIDERTRACK:%@NL@%
                         sVscrollInc = SHORT1FROMMP (mp2) - sVscrollPos;%@NL@%
                         break ;%@NL@%
%@NL@%
                    default:%@NL@%
                         sVscrollInc = 0 ;%@NL@%
                         break ;%@NL@%
                    }%@NL@%
               sVscrollInc = max (-sVscrollPos,%@NL@%
                             min (sVscrollInc, sVscrollMax - sVscrollPos)) ;%@NL@%
%@NL@%
               if (sVscrollInc != 0)%@NL@%
                    {%@NL@%
                    sVscrollPos += sVscrollInc ;%@NL@%
                    WinScrollWindow (hwnd, 0, cyChar * sVscrollInc,%@NL@%
                                   NULL, NULL, NULL, NULL, SW_INVALIDATERGN) ;%@NL@%
%@NL@%
                    WinSendMsg (hwndVscroll, SBM_SETPOS,%@NL@%
                                MPFROMSHORT (sVscrollPos), NULL) ;%@NL@%
%@NL@%
                    WinUpdateWindow (hwnd) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, &rclInvalid) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               sPaintBeg = max (0, sVscrollPos +%@NL@%
                              (cyClient - (SHORT) rclInvalid.yTop) / cyChar) ;%@NL@%
               sPaintEnd = min (NUMLINES, sVscrollPos +%@NL@%
                              (cyClient - (SHORT) rclInvalid.yBottom)%@NL@%
                                   / cyChar + 1) ;%@NL@%
%@NL@%
               for (sLine = sPaintBeg ; sLine < sPaintEnd ; sLine++)%@NL@%
                    {%@NL@%
                    ptl.x = cxCaps - sHscrollPos ;%@NL@%
                    ptl.y = cyClient - cyChar * (sLine + 1 - sVscrollPos)%@NL@%
                                     + cyDesc ;%@NL@%
%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                              (LONG) strlen (sysvals[sLine].szIdentifier),%@NL@%
                              sysvals[sLine].szIdentifier) ;%@NL@%
%@NL@%
                    ptl.x += 20 * cxCaps ;%@NL@%
                    GpiCharStringAt (hps, &ptl,%@NL@%
                              (LONG) strlen (sysvals[sLine].szDescription),%@NL@%
                              sysvals[sLine].szDescription) ;%@NL@%
%@NL@%
                    ltoa (WinQuerySysValue (HWND_DESKTOP,%@NL@%
                               sysvals[sLine].sIndex), szBuffer, 10) ;%@NL@%
%@NL@%
                    ptl.x += 38 * cxChar + 6 * cxCaps ;%@NL@%
                    RtJustCharStringAt (hps, &ptl, (LONG) strlen (szBuffer),%@NL@%
                                        szBuffer) ;%@NL@%
                    }%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SYSVALS4.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP07\SYSVALS4.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------------------%@NL@%
%@AB@%   SYSVALS4.C -- System Values Display Program using AVIO%@NL@%
%@AB@%  --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#define %@AE@%INCL_VIO %@NL@%
%@AI@%#define %@AE@%INCL_AVIO %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%"sysvals.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%MAXWIDTH 60 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "SysVals4" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_VERTSCROLL    | FCF_HORZSCROLL ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
BYTE RgbToVioColor (COLOR clrRgb)%@NL@%
     {%@NL@%
     BYTE bIrgb ;%@NL@%
     RGB  rgb ;%@NL@%
%@NL@%
     rgb = MAKETYPE (clrRgb, RGB) ;%@NL@%
%@NL@%
     if (rgb.bBlue  >= 0x80) bIrgb |= '\x01' ;%@NL@%
     if (rgb.bGreen >= 0x80) bIrgb |= '\x02' ;%@NL@%
     if (rgb.bRed   >= 0x80) bIrgb |= '\x04' ;%@NL@%
%@NL@%
     if (rgb.bBlue >= 0xC0 || rgb.bGreen >= 0xC0 || rgb.bRed >= 0xC0)%@NL@%
          bIrgb |= 8 ;%@NL@%
%@NL@%
     if (bIrgb == 0 && rgb.bBlue >= 0x40 && rgb.bGreen >= 0x40 &&%@NL@%
                       rgb.bRed  >= 0x40)%@NL@%
          bIrgb = 8 ;%@NL@%
%@NL@%
     return bIrgb ;%@NL@%
     }%@NL@%
%@NL@%
BYTE ConstructDefaultAttribute (VOID)%@NL@%
     {%@NL@%
     return RgbToVioColor (%@NL@%
                 WinQuerySysColor (HWND_DESKTOP, SYSCLR_WINDOW, 0L)) << 4 |%@NL@%
            RgbToVioColor (%@NL@%
                 WinQuerySysColor (HWND_DESKTOP, SYSCLR_WINDOWTEXT, 0L)) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BYTE   bBlankCell [2] = " " ;%@NL@%
     static HVPS   hvps ;%@NL@%
     static HWND   hwndHscroll, hwndVscroll ;%@NL@%
     static HPS    hps ;%@NL@%
     static SHORT  sHscrollPos, sVscrollPos,%@NL@%
                   cxChar, cyChar, cxClient, cyClient ;%@NL@%
     CHAR          szBuffer [80] ;%@NL@%
     HDC           hdc ;%@NL@%
     SIZEL         sizl ;%@NL@%
     USHORT        usRow ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hdc = WinOpenWindowDC (hwnd) ;%@NL@%
%@NL@%
               sizl.cx = sizl.cy = 0 ;%@NL@%
               hps = GpiCreatePS (hab, hdc, &sizl, PU_PELS    | GPIF_DEFAULT |%@NL@%
                                                   GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
               VioCreatePS (&hvps, NUMLINES, MAXWIDTH, 0, 1, NULL) ;%@NL@%
               VioAssociate (hdc, hvps) ;%@NL@%
               VioGetDeviceCellSize (&cyChar, &cxChar, hvps) ;%@NL@%
%@NL@%
               bBlankCell[1] = ConstructDefaultAttribute () ;%@NL@%
               VioScrollUp (0, 0, -1, -1, -1, bBlankCell, hvps) ;%@NL@%
%@NL@%
               for (usRow = 0 ; usRow < NUMLINES ; usRow++)%@NL@%
                    VioWrtCharStr (szBuffer,%@NL@%
                                   sprintf (szBuffer, "%-20s%-35s%5ld",%@NL@%
                                            sysvals[usRow].szIdentifier,%@NL@%
                                            sysvals[usRow].szDescription,%@NL@%
                                            WinQuerySysValue (HWND_DESKTOP,%@NL@%
                                            sysvals[usRow].sIndex)),%@NL@%
                                   usRow, 0, hvps) ;%@NL@%
%@NL@%
               hwndHscroll = WinWindowFromID (%@NL@%
                                   WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                                   FID_HORZSCROLL) ;%@NL@%
%@NL@%
               WinSendMsg (hwndHscroll, SBM_SETSCROLLBAR,%@NL@%
                                        MPFROM2SHORT (sHscrollPos, 0),%@NL@%
                                        MPFROM2SHORT (0, MAXWIDTH - 1)) ;%@NL@%
%@NL@%
               hwndVscroll = WinWindowFromID (%@NL@%
                                   WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                                   FID_VERTSCROLL) ;%@NL@%
%@NL@%
               WinSendMsg (hwndVscroll, SBM_SETSCROLLBAR,%@NL@%
                                        MPFROM2SHORT (sVscrollPos, 0),%@NL@%
                                        MPFROM2SHORT (0, NUMLINES - 1)) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               WinDefAVioWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_HSCROLL:%@NL@%
               switch (SHORT2FROMMP (mp2))%@NL@%
                    {%@NL@%
                    case SB_LINELEFT:%@NL@%
                         sHscrollPos -= 1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_LINERIGHT:%@NL@%
                         sHscrollPos += 1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGELEFT:%@NL@%
                         sHscrollPos -= 8 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGERIGHT:%@NL@%
                         sHscrollPos += 8 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_SLIDERPOSITION:%@NL@%
                         sHscrollPos = SHORT1FROMMP (mp2) ;%@NL@%
                         break ;%@NL@%
                    }%@NL@%
               sHscrollPos = max (0, min (sHscrollPos, MAXWIDTH - 1)) ;%@NL@%
%@NL@%
               if (sHscrollPos != SHORT1FROMMR (WinSendMsg (hwndHscroll,%@NL@%
                                       SBM_QUERYPOS, NULL, NULL)))%@NL@%
                    {%@NL@%
                    VioSetOrg (sVscrollPos, sHscrollPos, hvps) ;%@NL@%
%@NL@%
                    WinSendMsg (hwndHscroll, SBM_SETPOS,%@NL@%
                                MPFROM2SHORT (sHscrollPos, 0), NULL) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_VSCROLL:%@NL@%
               switch (SHORT2FROMMP (mp2))%@NL@%
                    {%@NL@%
                    case SB_LINEUP:%@NL@%
                         sVscrollPos -= 1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_LINEDOWN:%@NL@%
                         sVscrollPos += 1 ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEUP:%@NL@%
                         sVscrollPos -= cyClient / cyChar ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_PAGEDOWN:%@NL@%
                         sVscrollPos += cyClient / cyChar ;%@NL@%
                         break ;%@NL@%
%@NL@%
                    case SB_SLIDERPOSITION:%@NL@%
                         sVscrollPos = SHORT1FROMMP (mp2) ;%@NL@%
                         break ;%@NL@%
                    }%@NL@%
               sVscrollPos = max (0, min (sVscrollPos, NUMLINES - 1)) ;%@NL@%
%@NL@%
               if (sVscrollPos != SHORT1FROMMR (WinSendMsg (hwndVscroll,%@NL@%
                                       SBM_QUERYPOS, NULL, NULL)))%@NL@%
                    {%@NL@%
                    VioSetOrg (sVscrollPos, sHscrollPos, hvps) ;%@NL@%
%@NL@%
                    WinSendMsg (hwndVscroll, SBM_SETPOS,%@NL@%
                                MPFROM2SHORT (sVscrollPos, 0), NULL) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               switch (CHARMSG(&msg)->vkey)%@NL@%
                    {%@NL@%
                    case VK_LEFT:%@NL@%
                    case VK_RIGHT:%@NL@%
                         return WinSendMsg (hwndHscroll, msg, mp1, mp2) ;%@NL@%
                    case VK_UP:%@NL@%
                    case VK_DOWN:%@NL@%
                    case VK_PAGEUP:%@NL@%
                    case VK_PAGEDOWN:%@NL@%
                         return WinSendMsg (hwndVscroll, msg, mp1, mp2) ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               WinBeginPaint (hwnd, hps, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
%@NL@%
               VioShowBuf (0, MAXWIDTH * NUMLINES * 2, hvps) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               VioAssociate (NULL, hvps) ;%@NL@%
               VioDestroyPS (hvps) ;%@NL@%
               GpiDestroyPS (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TYPEAWAY.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP08\TYPEAWAY.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------%@NL@%
%@AB@%   TYPEAWAY.C -- Typing Program%@NL@%
%@AB@%  ------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%"easyfont.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%LCID_FIXEDFONT 1L %@NL@%
%@AI@%#define %@AE@%BUFFER(x,y) (*(pBuffer + y * xMax + x)) %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
CHAR szClientClass [] = "TypeAway" ;%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, CS_SIZEREDRAW, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
     if (hwndFrame != NULL)%@NL@%
          {%@NL@%
          WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                      WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                      NULL) ;%@NL@%
%@NL@%
          while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
               WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
          WinDestroyWindow (hwndFrame) ;%@NL@%
          }%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID GetCharXY (HPS hps, SHORT *pcxChar, SHORT *pcyChar, SHORT *pcyDesc)%@NL@%
     {%@NL@%
     FONTMETRICS fm ;%@NL@%
%@NL@%
     GpiQueryFontMetrics (hps, (LONG) sizeof fm, &fm) ;%@NL@%
     *pcxChar = (SHORT) fm.lAveCharWidth ;%@NL@%
     *pcyChar = (SHORT) fm.lMaxBaselineExt ;%@NL@%
     *pcyDesc = (SHORT) fm.lMaxDescender ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL  fInsertMode = FALSE ;%@NL@%
     static CHAR  *pBuffer ;%@NL@%
     static SHORT cxClient, cyClient, cxChar, cyChar, cyDesc,%@NL@%
                  xCursor, yCursor, xMax,  yMax ;%@NL@%
     BOOL         fProcessed ;%@NL@%
     CHAR         szBuffer [20] ;%@NL@%
     HPS          hps ;%@NL@%
     POINTL       ptl ;%@NL@%
     RECTL        rcl ;%@NL@%
     SHORT        sRep, s ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               EzfQueryFonts (hps) ;%@NL@%
%@NL@%
               if (!EzfCreateLogFont (hps, LCID_FIXEDFONT, FONTFACE_COUR,%@NL@%
                                                           FONTSIZE_10, 0))%@NL@%
                    {%@NL@%
                    WinReleasePS (hps) ;%@NL@%
%@NL@%
                    WinMessageBox (HWND_DESKTOP, HWND_DESKTOP,%@NL@%
                         "Cannot find a fixed-pitch font.  Load the Courier "%@NL@%
                         "fonts from the Control Panel and try again.",%@NL@%
                         szClientClass, 0, MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
%@NL@%
                    return 1 ;%@NL@%
                    }%@NL@%
%@NL@%
               GpiSetCharSet (hps, LCID_FIXEDFONT) ;%@NL@%
%@NL@%
               GetCharXY (hps, &cxChar, &cyChar, &cyDesc) ;%@NL@%
%@NL@%
               GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
               GpiDeleteSetId (hps, LCID_FIXEDFONT) ;%@NL@%
               WinReleasePS (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SIZE:%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               xMax = min (255, cxClient / cxChar) ;%@NL@%
               yMax = min (255, cyClient / cyChar - 2) ;%@NL@%
%@NL@%
               if (pBuffer != NULL)%@NL@%
                    free (pBuffer) ;%@NL@%
%@NL@%
               if (NULL == (pBuffer = malloc (xMax * yMax + 1)))%@NL@%
                    {%@NL@%
                    WinMessageBox (HWND_DESKTOP, hwnd,%@NL@%
                         "Cannot allocate memory for text buffer.\n"%@NL@%
                         "Try a smaller window.", szClientClass, 0,%@NL@%
                         MB_OK | MB_ICONEXCLAMATION) ;%@NL@%
%@NL@%
                    xMax = yMax = 0 ;%@NL@%
                    }%@NL@%
               else%@NL@%
                    {                    %@NL@%
                    for (s = 0 ; s < xMax * yMax ; BUFFER (s++, 0) = ' ') ;%@NL@%
%@NL@%
                    xCursor = 0 ;%@NL@%
                    yCursor = 0 ;%@NL@%
                    }%@NL@%
%@NL@%
               if (hwnd == WinQueryFocus (HWND_DESKTOP, FALSE))%@NL@%
                    {%@NL@%
                    WinDestroyCursor (hwnd) ;%@NL@%
%@NL@%
                    WinCreateCursor (hwnd, 0, cyClient - cyChar,%@NL@%
                                     cxChar, cyChar,%@NL@%
                                     CURSOR_SOLID | CURSOR_FLASH, NULL) ;%@NL@%
%@NL@%
                    WinShowCursor (hwnd, xMax > 0 && yMax > 0) ;%@NL@%
                    }%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_SETFOCUS:%@NL@%
               if (SHORT1FROMMP (mp2))%@NL@%
                    {%@NL@%
                    WinCreateCursor (hwnd, cxChar * xCursor,%@NL@%
                                     cyClient - cyChar * (1 + yCursor),%@NL@%
                                     cxChar, cyChar,%@NL@%
                                     CURSOR_SOLID | CURSOR_FLASH, NULL) ;%@NL@%
%@NL@%
                    WinShowCursor (hwnd, xMax > 0 && yMax > 0) ;%@NL@%
                    }%@NL@%
               else%@NL@%
                    WinDestroyCursor (hwnd) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               if (xMax == 0 || yMax == 0)%@NL@%
                    return 0 ;%@NL@%
%@NL@%
               if (CHARMSG(&msg)->fs & KC_KEYUP)%@NL@%
                    return 0 ;%@NL@%
%@NL@%
               if (CHARMSG(&msg)->fs & KC_INVALIDCHAR)%@NL@%
                    return 0 ;%@NL@%
%@NL@%
               if (CHARMSG(&msg)->fs & KC_INVALIDCOMP)%@NL@%
                    {%@NL@%
                    xCursor = (xCursor + 1) % xMax ;        // Advance cursor%@NL@%
                    if (xCursor == 0)%@NL@%
                         yCursor = (yCursor + 1) % yMax ;%@NL@%
%@NL@%
                    WinAlarm (HWND_DESKTOP, WA_ERROR) ;     // And beep%@NL@%
                    }%@NL@%
%@NL@%
               for (sRep = 0 ; sRep < CHARMSG(&msg)->cRepeat ; sRep++)%@NL@%
                    {%@NL@%
                    fProcessed = FALSE ;%@NL@%
%@NL@%
                    ptl.x = xCursor * cxChar ;%@NL@%
                    ptl.y = cyClient - cyChar * (yCursor + 1) + cyDesc ;%@NL@%
%@NL@%
                              %@AB@%/*---------------------------%@NL@%
%@AB@%                                 Process some virtual keys%@NL@%
%@AB@%                                ---------------------------*/%@AE@%%@NL@%
%@NL@%
                    if (CHARMSG(&msg)->fs & KC_VIRTUALKEY)%@NL@%
                         {%@NL@%
                         fProcessed = TRUE ;%@NL@%
%@NL@%
                         switch (CHARMSG(&msg)->vkey)%@NL@%
                              {%@NL@%
                                        %@AB@%/*---------------%@NL@%
%@AB@%                                           Backspace key%@NL@%
%@AB@%                                          ---------------*/%@AE@%%@NL@%
%@NL@%
                              case VK_BACKSPACE:%@NL@%
                                   if (xCursor > 0)%@NL@%
                                        {%@NL@%
                                        WinSendMsg (hwnd, WM_CHAR,%@NL@%
                                             MPFROM2SHORT (KC_VIRTUALKEY, 1),%@NL@%
                                             MPFROM2SHORT (0, VK_LEFT)) ;%@NL@%
%@NL@%
                                        WinSendMsg (hwnd, WM_CHAR,%@NL@%
                                             MPFROM2SHORT (KC_VIRTUALKEY, 1),%@NL@%
                                             MPFROM2SHORT (0, VK_DELETE)) ;%@NL@%
                                        }%@NL@%
                                   break ;%@NL@%
%@NL@%
                                        %@AB@%/*---------%@NL@%
%@AB@%                                           Tab key%@NL@%
%@AB@%                                          ---------*/%@AE@%%@NL@%
%@NL@%
                              case VK_TAB:%@NL@%
                                   s = min (8 - xCursor % 8, xMax - xCursor) ;%@NL@%
%@NL@%
                                   WinSendMsg (hwnd, WM_CHAR, %@NL@%
                                        MPFROM2SHORT (KC_CHAR, s),%@NL@%
                                        MPFROM2SHORT ((USHORT) ' ', 0)) ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                                        %@AB@%/*-------------------------%@NL@%
%@AB@%                                           Backtab (Shift-Tab) key%@NL@%
%@AB@%                                          -------------------------*/%@AE@%%@NL@%
%@NL@%
                              case VK_BACKTAB:%@NL@%
                                   if (xCursor > 0)%@NL@%
                                        {%@NL@%
                                        s = (xCursor - 1) % 8 + 1 ;%@NL@%
%@NL@%
                                        WinSendMsg (hwnd, WM_CHAR,%@NL@%
                                             MPFROM2SHORT (KC_VIRTUALKEY, s),%@NL@%
                                             MPFROM2SHORT (0, VK_LEFT)) ;%@NL@%
                                        }%@NL@%
                                   break ;%@NL@%
%@NL@%
                                        %@AB@%/*------------------------%@NL@%
%@AB@%                                           Newline and Enter keys%@NL@%
%@AB@%                                          ------------------------*/%@AE@%%@NL@%
%@NL@%
                              case VK_NEWLINE:%@NL@%
                              case VK_ENTER:%@NL@%
                                   xCursor = 0 ;%@NL@%
                                   yCursor = (yCursor + 1) % yMax ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                              default:%@NL@%
                                   fProcessed = FALSE ;%@NL@%
                                   break ;%@NL@%
                              }%@NL@%
                         }%@NL@%
%@NL@%
                              %@AB@%/*------------------------%@NL@%
%@AB@%                                 Process character keys%@NL@%
%@AB@%                                ------------------------*/%@AE@%%@NL@%
%@NL@%
                    if (!fProcessed && CHARMSG(&msg)->fs & KC_CHAR)%@NL@%
                         {%@NL@%
                                                  // Shift line if fInsertMode%@NL@%
                         if (fInsertMode)%@NL@%
                              for (s = xMax - 1 ; s > xCursor ; s--)%@NL@%
                                   BUFFER (s, yCursor) =%@NL@%
                                        BUFFER (s - 1, yCursor) ;%@NL@%
%@NL@%
                                                  // Store character in buffer%@NL@%
%@NL@%
                         BUFFER (xCursor, yCursor) =%@NL@%
                                             (CHAR) CHARMSG(&msg)->chr ;%@NL@%
%@NL@%
                                                  // Display char or new line%@NL@%
%@NL@%
                         WinShowCursor (hwnd, FALSE) ;%@NL@%
                         hps = WinGetPS (hwnd) ;%@NL@%
%@NL@%
                         EzfCreateLogFont (hps, LCID_FIXEDFONT,%@NL@%
                                           FONTFACE_COUR, FONTSIZE_10, 0) ;%@NL@%
                         GpiSetCharSet (hps, LCID_FIXEDFONT) ;%@NL@%
                         GpiSetBackMix (hps, BM_OVERPAINT) ;%@NL@%
%@NL@%
                         if (fInsertMode)%@NL@%
                              GpiCharStringAt (hps, &ptl,%@NL@%
                                               (LONG) (xMax - xCursor),%@NL@%
                                               & BUFFER (xCursor, yCursor)) ;%@NL@%
                         else%@NL@%
                              GpiCharStringAt (hps, &ptl, 1L,%@NL@%
                                               (CHAR *) & CHARMSG(&msg)->chr) ;%@NL@%
%@NL@%
                         GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
                         GpiDeleteSetId (hps, LCID_FIXEDFONT) ;%@NL@%
                         WinReleasePS (hps) ;%@NL@%
                         WinShowCursor (hwnd, TRUE) ;%@NL@%
%@NL@%
                                                  // Increment cursor%@NL@%
%@NL@%
                         if (!(CHARMSG(&msg)->fs & KC_DEADKEY))%@NL@%
                              if (0 == (xCursor = (xCursor + 1) % xMax))%@NL@%
                                   yCursor = (yCursor + 1) % yMax ;%@NL@%
%@NL@%
                         fProcessed = TRUE ;%@NL@%
                         }%@NL@%
%@NL@%
                              %@AB@%/*--------------------------------%@NL@%
%@AB@%                                 Process remaining virtual keys%@NL@%
%@AB@%                                --------------------------------*/%@AE@%%@NL@%
%@NL@%
                    if (!fProcessed && CHARMSG(&msg)->fs & KC_VIRTUALKEY)%@NL@%
                         {%@NL@%
                         fProcessed = TRUE ;%@NL@%
%@NL@%
                         switch (CHARMSG(&msg)->vkey)%@NL@%
                              {%@NL@%
                                        %@AB@%/*----------------------%@NL@%
%@AB@%                                           Cursor movement keys%@NL@%
%@AB@%                                          ----------------------*/%@AE@%%@NL@%
%@NL@%
                              case VK_LEFT:%@NL@%
                                   xCursor = (xCursor - 1 + xMax) % xMax ;%@NL@%
%@NL@%
                                   if (xCursor == xMax - 1)%@NL@%
                                        yCursor = (yCursor - 1 + yMax) % yMax ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                              case VK_RIGHT:%@NL@%
                                   xCursor = (xCursor + 1) % xMax ;%@NL@%
%@NL@%
                                   if (xCursor == 0)%@NL@%
                                        yCursor = (yCursor + 1) % yMax ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                              case VK_UP:%@NL@%
                                   yCursor = max (yCursor - 1, 0) ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                              case VK_DOWN:%@NL@%
                                   yCursor = min (yCursor + 1, yMax - 1) ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                              case VK_PAGEUP:%@NL@%
                                   yCursor = 0 ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                              case VK_PAGEDOWN:%@NL@%
                                   yCursor = yMax - 1 ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                              case VK_HOME:%@NL@%
                                   xCursor = 0 ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                              case VK_END:%@NL@%
                                   xCursor = xMax - 1 ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                                        %@AB@%/*------------%@NL@%
%@AB@%                                           Insert key%@NL@%
%@AB@%                                          ------------*/%@AE@%%@NL@%
%@NL@%
                              case VK_INSERT:%@NL@%
                                   fInsertMode = fInsertMode ? FALSE : TRUE ;%@NL@%
                                   WinSetRect (hab, &rcl, 0, 0,%@NL@%
                                               cxClient, cyChar) ;%@NL@%
                                   WinInvalidateRect (hwnd, &rcl, FALSE) ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                                        %@AB@%/*------------%@NL@%
%@AB@%                                           Delete key%@NL@%
%@AB@%                                          ------------*/%@AE@%%@NL@%
%@NL@%
                              case VK_DELETE:%@NL@%
                                   for (s = xCursor ; s < xMax - 1 ; s++)%@NL@%
                                        BUFFER (s, yCursor) =%@NL@%
                                             BUFFER (s + 1, yCursor) ;%@NL@%
%@NL@%
                                   BUFFER (xMax, yCursor) = ' ' ;%@NL@%
%@NL@%
                                   WinShowCursor (hwnd, FALSE) ;%@NL@%
                                   hps = WinGetPS (hwnd) ;%@NL@%
                                   EzfCreateLogFont (hps, LCID_FIXEDFONT,%@NL@%
                                             FONTFACE_COUR, FONTSIZE_10, 0) ;%@NL@%
                                   GpiSetCharSet (hps, LCID_FIXEDFONT) ;%@NL@%
                                   GpiSetBackMix (hps, BM_OVERPAINT) ;%@NL@%
%@NL@%
                                   GpiCharStringAt (hps, &ptl,%@NL@%
                                             (LONG) (xMax - xCursor), %@NL@%
                                             & BUFFER (xCursor, yCursor)) ;%@NL@%
%@NL@%
                                   GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
                                   GpiDeleteSetId (hps, LCID_FIXEDFONT) ;%@NL@%
                                   WinReleasePS (hps) ;%@NL@%
                                   WinShowCursor (hwnd, TRUE) ;%@NL@%
                                   break ;%@NL@%
%@NL@%
                              default:%@NL@%
                                   fProcessed = FALSE ;%@NL@%
                                   break ;%@NL@%
                              }%@NL@%
                         }%@NL@%
                    }%@NL@%
               WinCreateCursor (hwnd, cxChar * xCursor,%@NL@%
                                      cyClient - cyChar * (1 + yCursor),%@NL@%
                                      0, 0, CURSOR_SETPOS, NULL) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
               EzfCreateLogFont (hps, LCID_FIXEDFONT, FONTFACE_COUR,%@NL@%
                                                      FONTSIZE_10, 0) ;%@NL@%
               GpiSetCharSet (hps, LCID_FIXEDFONT) ;%@NL@%
%@NL@%
               ptl.x = cxChar ;%@NL@%
               ptl.y = cyDesc ;%@NL@%
               GpiCharStringAt (hps, &ptl,%@NL@%
                                (LONG) sprintf (szBuffer, "Insert Mode: %s",%@NL@%
                                                fInsertMode ? "ON" : "OFF"),%@NL@%
                                szBuffer) ;%@NL@%
%@NL@%
               ptl.x = 0 ;%@NL@%
               ptl.y = 3 * cyChar / 2 ;%@NL@%
               GpiMove (hps, &ptl) ;%@NL@%
%@NL@%
               ptl.x = cxClient ;%@NL@%
               GpiLine (hps, &ptl) ;%@NL@%
%@NL@%
               if (xMax > 0 && yMax > 0)%@NL@%
                    {%@NL@%
                    for (s = 0 ; s < yMax ; s++)%@NL@%
                         {%@NL@%
                         ptl.x = 0 ;%@NL@%
                         ptl.y = cyClient - cyChar * (s + 1) + cyDesc ;%@NL@%
%@NL@%
                         GpiCharStringAt (hps, &ptl, (LONG) xMax,%@NL@%
                                                     & BUFFER (0, s)) ;%@NL@%
                         }%@NL@%
                    }%@NL@%
               GpiSetCharSet (hps, LCID_DEFAULT) ;%@NL@%
               GpiDeleteSetId (hps, LCID_FIXEDFONT) ;%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               if (pBuffer != NULL)%@NL@%
                    free (pBuffer) ;%@NL@%
               break ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TYPECLIP.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP15\TYPECLIP.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------------%@NL@%
%@AB@%   TYPECLIP.C -- Clipboard Text Demonstration%@NL@%
%@AB@%  --------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_VIO %@NL@%
%@AI@%#define %@AE@%INCL_AVIO %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@AI@%#include %@AE@%<stdlib.h> %@NL@%
%@AI@%#include %@AE@%"typeclip.h" %@NL@%
%@NL@%
%@AI@%#define %@AE@%WM_ADJUST_ORG     (WM_USER + 0) %@NL@%
%@AI@%#define %@AE@%WM_SET_BLOCKOUT   (WM_USER + 1) %@NL@%
%@AI@%#define %@AE@%WM_CLEAR_BLOCKOUT (WM_USER + 2) %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
HAB  hab ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "TypeClip" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST |%@NL@%
                                 FCF_MENU          | FCF_ACCELTABLE ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc, 0L, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, ID_RESOURCE, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static BOOL  fCapture, fValidBlock ;%@NL@%
     static HPS   hps ;%@NL@%
     static HVPS  hvps ;%@NL@%
     static HWND  hwndMenu ;%@NL@%
     static LONG  cxChar, cyChar ;%@NL@%
     static SHORT cxClient, cyClient, cxVioSize, cyVioSize,%@NL@%
                  xBlockBeg, yBlockBeg, xBlockEnd, yBlockEnd,%@NL@%
                  xBeg , yBeg, xEnd, yEnd ;%@NL@%
     CHAR         *pchText ;%@NL@%
     HDC          hdc ;%@NL@%
     PCHAR        pchClipText ;%@NL@%
     RECTL        rcl ;%@NL@%
     SEL          selClipText ;%@NL@%
     SHORT        sRep, sLen, x, y, s,%@NL@%
                  xCursor, yCursor, xOrigin, yOrigin ;%@NL@%
     SIZEL        sizl ;%@NL@%
     USHORT       usfInfo ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
                              %@AB@%/*---------------------------------------%@NL@%
%@AB@%                                 Create, paint, and destroy processing%@NL@%
%@AB@%                                ---------------------------------------*/%@AE@%%@NL@%
          case WM_CREATE:%@NL@%
               hdc = WinOpenWindowDC (hwnd) ;%@NL@%
%@NL@%
               DevQueryCaps (hdc, CAPS_CHAR_WIDTH,  1L, &cxChar) ;%@NL@%
               DevQueryCaps (hdc, CAPS_CHAR_HEIGHT, 1L, &cyChar) ;%@NL@%
%@NL@%
               cxVioSize = (SHORT) (WinQuerySysValue (HWND_DESKTOP,%@NL@%
                                        SV_CXFULLSCREEN) / cxChar) ;%@NL@%
%@NL@%
               cyVioSize = (SHORT) (WinQuerySysValue (HWND_DESKTOP,%@NL@%
                                        SV_CYFULLSCREEN) / cyChar) ;%@NL@%
%@NL@%
               sizl.cx = sizl.cy = 0 ;%@NL@%
               hps = GpiCreatePS (hab, hdc, &sizl, PU_PELS    | GPIF_DEFAULT |%@NL@%
                                                   GPIT_MICRO | GPIA_ASSOC) ;%@NL@%
%@NL@%
               VioCreatePS (&hvps, cyVioSize, cxVioSize, 0, 1, NULL) ;%@NL@%
               VioAssociate (hdc, hvps) ;%@NL@%
%@NL@%
               hwndMenu = WinWindowFromID (%@NL@%
                                WinQueryWindow (hwnd, QW_PARENT, FALSE),%@NL@%
                                FID_MENU) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               WinBeginPaint (hwnd, hps, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
               WinFillRect (hps, &rcl, CLR_BLACK) ;%@NL@%
%@NL@%
               VioShowBuf (0, cxVioSize * cyVioSize * 2, hvps) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               VioAssociate (NULL, hvps) ;%@NL@%
               VioDestroyPS (hvps) ;%@NL@%
               GpiDestroyPS (hps) ;%@NL@%
               return 0 ;%@NL@%
                              %@AB@%/*-------------------------------------------%@NL@%
%@AB@%                                 Window size, keyboard and origin handling%@NL@%
%@AB@%                                -------------------------------------------*/%@AE@%%@NL@%
          case WM_SIZE:%@NL@%
               WinDefAVioWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
%@NL@%
               cxClient = SHORT1FROMMP (mp2) ;%@NL@%
               cyClient = SHORT2FROMMP (mp2) ;%@NL@%
%@NL@%
               VioSetOrg (0, 0, hvps) ;%@NL@%
               WinSendMsg (hwnd, WM_ADJUST_ORG, NULL, NULL) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CHAR:%@NL@%
               if (!(CHARMSG(&msg)->fs & KC_CHAR)        ||%@NL@%
                    (CHARMSG(&msg)->fs & KC_KEYUP)       ||%@NL@%
                    (CHARMSG(&msg)->fs & KC_INVALIDCHAR) ||%@NL@%
                    (CHARMSG(&msg)->fs & KC_DEADKEY))%@NL@%
                         return 0 ;%@NL@%
%@NL@%
               for (sRep = 0 ; sRep < CHARMSG(&msg)->cRepeat ; sRep++)%@NL@%
                    {%@NL@%
                    VioWrtTTY ((PCHAR) & CHARMSG(&msg)->chr, 1, hvps) ;%@NL@%
%@NL@%
                    switch (CHARMSG(&msg)->chr)%@NL@%
                         {%@NL@%
                         case '\b':                         // Backspace%@NL@%
                              VioWrtTTY (" \b", 2, hvps) ;%@NL@%
                              break ;%@NL@%
%@NL@%
                         case '\r':                         // Return%@NL@%
                              VioWrtTTY ("\n", 1, hvps) ;%@NL@%
                              break ;%@NL@%
                         }%@NL@%
                    }%@NL@%
               WinSendMsg (hwnd, WM_ADJUST_ORG, NULL, NULL) ;%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_ADJUST_ORG:%@NL@%
               VioGetOrg    (&yOrigin, &xOrigin, hvps) ;%@NL@%
               VioGetCurPos (&yCursor, &xCursor, hvps) ;%@NL@%
%@NL@%
               if (xCursor < xOrigin)%@NL@%
                    xOrigin = xCursor ;%@NL@%
%@NL@%
               else if (xCursor >= xOrigin + cxClient / (SHORT) cxChar)%@NL@%
                    xOrigin = xCursor - cxClient / (SHORT) cxChar + 1 ;%@NL@%
%@NL@%
               if (yCursor < yOrigin)%@NL@%
                    yOrigin = yCursor ;%@NL@%
%@NL@%
               else if (yCursor >= yOrigin + cyClient / (SHORT) cyChar)%@NL@%
                    yOrigin = yCursor - cyClient / (SHORT) cyChar + 1 ;%@NL@%
%@NL@%
               VioSetOrg (yOrigin, xOrigin, hvps) ;%@NL@%
               return 0 ;%@NL@%
                              %@AB@%/*-----------------------------%@NL@%
%@AB@%                                 Mouse and blockout handling%@NL@%
%@AB@%                                -----------------------------*/%@AE@%%@NL@%
          case WM_BUTTON1DOWN:%@NL@%
               x = MOUSEMSG(&msg)->x / (SHORT) cxChar ;%@NL@%
               y = (cyClient - MOUSEMSG(&msg)->y) / (SHORT) cyChar ;%@NL@%
%@NL@%
               WinSendMsg (hwnd, WM_CLEAR_BLOCKOUT, NULL, NULL) ;%@NL@%
%@NL@%
               WinSetCapture (HWND_DESKTOP, hwnd) ;%@NL@%
               fCapture = TRUE ;%@NL@%
               fValidBlock = FALSE ;%@NL@%
%@NL@%
               VioGetOrg (&yOrigin, &xOrigin, hvps) ;%@NL@%
%@NL@%
               xBlockBeg = xOrigin + x ;%@NL@%
               yBlockBeg = yOrigin + y ;%@NL@%
%@NL@%
               WinSendMsg (hwnd, WM_SET_BLOCKOUT, mp1, mp2) ;%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_MOUSEMOVE:%@NL@%
               if (fCapture)%@NL@%
                    WinSendMsg (hwnd, WM_SET_BLOCKOUT, mp1, mp2) ;%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_BUTTON1UP:%@NL@%
               if (fCapture)%@NL@%
                    {%@NL@%
                    WinSetCapture (HWND_DESKTOP, NULL) ;%@NL@%
                    fCapture = FALSE ;%@NL@%
                    fValidBlock = TRUE ;%@NL@%
%@NL@%
                    WinSendMsg (hwnd, WM_SET_BLOCKOUT, mp1, mp2) ;%@NL@%
                    }%@NL@%
               return 1 ;%@NL@%
%@NL@%
          case WM_SET_BLOCKOUT:%@NL@%
               x = MOUSEMSG(&msg)->x / (SHORT) cxChar ;%@NL@%
               y = (cyClient - MOUSEMSG(&msg)->y) / (SHORT) cyChar ;%@NL@%
%@NL@%
               VioGetOrg (&yOrigin, &xOrigin, hvps) ;%@NL@%
%@NL@%
               xBlockEnd = xOrigin + x ;%@NL@%
               yBlockEnd = yOrigin + y ;%@NL@%
%@NL@%
               if (cxVioSize * yBlockBeg + xBlockBeg <%@NL@%
                   cxVioSize * yBlockEnd + xBlockEnd)%@NL@%
                    {%@NL@%
                    xBeg = xBlockBeg ;%@NL@%
                    yBeg = yBlockBeg ;%@NL@%
                    xEnd = xBlockEnd ;%@NL@%
                    yEnd = yBlockEnd ;%@NL@%
                    }%@NL@%
               else%@NL@%
                    {%@NL@%
                    xBeg = xBlockEnd ;%@NL@%
                    yBeg = yBlockEnd ;%@NL@%
                    xEnd = xBlockBeg ;%@NL@%
                    yEnd = yBlockBeg ;%@NL@%
                    }%@NL@%
%@NL@%
               VioWrtNAttr ("\x07", cxVioSize * yBeg + xBeg, 0, 0, hvps) ;%@NL@%
%@NL@%
               VioWrtNAttr ("\x70",  cxVioSize * yEnd + xEnd -%@NL@%
                                    (cxVioSize * yBeg + xBeg) + 1,%@NL@%
                                    yBeg, xBeg, hvps) ;%@NL@%
%@NL@%
               VioWrtNAttr ("\x07",  cxVioSize * cyVioSize -%@NL@%
                                    (cxVioSize * yEnd + xEnd) - 1,%@NL@%
                                    yEnd, xEnd + 1, hvps) ;%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_CLEAR_BLOCKOUT:%@NL@%
               VioWrtNAttr ("\x07", cxVioSize * cyVioSize, 0, 0, hvps) ;%@NL@%
               fValidBlock = FALSE ;%@NL@%
               break ;%@NL@%
                              %@AB@%/*--------------------%@NL@%
%@AB@%                                 Clipboard handling%@NL@%
%@AB@%                                --------------------*/%@AE@%%@NL@%
          case WM_INITMENU:%@NL@%
               switch (SHORT1FROMMP (mp1))%@NL@%
                    {%@NL@%
                    case IDM_EDIT:%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (IDM_CUT, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_DISABLED,%@NL@%
                                          fValidBlock ? 0 : MIA_DISABLED)) ;%@NL@%
%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (IDM_COPY, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_DISABLED,%@NL@%
                                          fValidBlock ? 0 : MIA_DISABLED)) ;%@NL@%
%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (IDM_CLEAR, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_DISABLED,%@NL@%
                                          fValidBlock ? 0 : MIA_DISABLED)) ;%@NL@%
%@NL@%
                         WinSendMsg (hwndMenu, MM_SETITEMATTR,%@NL@%
                                     MPFROM2SHORT (IDM_PASTE, TRUE),%@NL@%
                                     MPFROM2SHORT (MIA_DISABLED,%@NL@%
                              WinQueryClipbrdFmtInfo (hab, CF_TEXT, &usfInfo)%@NL@%
                                             ? 0 : MIA_DISABLED)) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case IDM_CUT:%@NL@%
                    case IDM_COPY:%@NL@%
                         if (!fValidBlock)%@NL@%
                              return 0 ;%@NL@%
                                                       // Copy text to%@NL@%
                                                       // malloc'ed memory%@NL@%
%@NL@%
                         sLen = (cxVioSize + 2) * (yEnd - yBeg + 1) + 1 ;%@NL@%
                         pchText = malloc (sLen) ;%@NL@%
%@NL@%
                         for (s = 0, y = yBeg ; y <= yEnd ; y++)%@NL@%
                              {%@NL@%
                              x    = (y == yBeg ? xBeg : 0) ;%@NL@%
                              sLen = (y == yEnd ? xEnd + 1 : cxVioSize) - x ;%@NL@%
%@NL@%
                              VioReadCharStr (pchText + s, &sLen,%@NL@%
                                              y, x, hvps) ;%@NL@%
%@NL@%
                              s += sLen ;%@NL@%
                              while (--s >= 0 && pchText[s] == ' ') ;%@NL@%
%@NL@%
                              s++ ;%@NL@%
                              pchText[s++] = '\r' ;%@NL@%
                              pchText[s++] = '\n' ;%@NL@%
                              }%@NL@%
                         pchText[s++] = '\0' ;         // s is string length%@NL@%
%@NL@%
                                                       // Allocate memory block%@NL@%
%@NL@%
                         DosAllocSeg (s, &selClipText, SEG_GIVEABLE) ;%@NL@%
                         pchClipText = MAKEP (selClipText, 0) ;%@NL@%
%@NL@%
                                                       // Copy to giveable seg%@NL@%
%@NL@%
                         for (s = 0 ; pchClipText[s] = pchText[s] ; s++) ;%@NL@%
                         free (pchText) ;%@NL@%
                                                       // Set clipboard data%@NL@%
                         WinOpenClipbrd (hab) ;%@NL@%
                         WinEmptyClipbrd (hab) ;%@NL@%
                         WinSetClipbrdData (hab, (ULONG) selClipText,%@NL@%
                                                 CF_TEXT, CFI_SELECTOR) ;%@NL@%
                         WinCloseClipbrd (hab) ;%@NL@%
                                                       // Clear blockout%@NL@%
%@NL@%
                         if (COMMANDMSG(&msg)->cmd == IDM_COPY)%@NL@%
                              {%@NL@%
                              WinSendMsg (hwnd, WM_CLEAR_BLOCKOUT, NULL, NULL);%@NL@%
                              return 0 ;%@NL@%
                              }%@NL@%
                                             // fall through for IDM_CUT%@NL@%
                    case IDM_CLEAR:%@NL@%
                         if (!fValidBlock)%@NL@%
                              return 0 ;%@NL@%
                                                       // Clear selection%@NL@%
%@NL@%
                         VioWrtNCell (" \x07",  cxVioSize * yEnd + xEnd -%@NL@%
                                               (cxVioSize * yBeg + xBeg) + 1,%@NL@%
                                               yBeg, xBeg, hvps) ;%@NL@%
                         fValidBlock = FALSE ;%@NL@%
                         return 0 ;%@NL@%
%@NL@%
                    case IDM_PASTE:%@NL@%
                                        // Get text selector from clipboard%@NL@%
%@NL@%
                         WinOpenClipbrd (hab) ;%@NL@%
                         selClipText = (SEL) WinQueryClipbrdData (hab,%@NL@%
                                                                  CF_TEXT) ;%@NL@%
                                        // Display to screen%@NL@%
%@NL@%
                         if (selClipText != 0)%@NL@%
                              {%@NL@%
                              pchClipText = MAKEP (selClipText, 0) ;%@NL@%
%@NL@%
                              for (sLen = 0 ; pchClipText[sLen] ; sLen++) ;%@NL@%
%@NL@%
                              VioWrtTTY (pchClipText, sLen, hvps) ;%@NL@%
                              }%@NL@%
                         WinCloseClipbrd (hab) ;%@NL@%
%@NL@%
                         WinSendMsg (hwnd, WM_ADJUST_ORG, NULL, NULL) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%W.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP02\W.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------%@NL@%
%@AB@%   W.C -- A Do-Nothing Program%@NL@%
%@AB@%  -----------------------------*/%@AE@%%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WE.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP02\WE.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------------------%@NL@%
%@AB@%   WE.C -- A Program that Obtains an Anchor Block Handle%@NL@%
%@AB@%  -------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     HAB  hab ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WEB.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP09\WEB.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*--------------------------------------%@NL@%
%@AB@%   WEB.C -- Mouse Movement Demo Program %@NL@%
%@AB@%  --------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#define %@AE@%INCL_GPI %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Web" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (hab, szClientClass, ClientWndProc,%@NL@%
                       CS_SIZEREDRAW | CS_SYNCPAINT, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (HWND_DESKTOP, WS_VISIBLE,%@NL@%
                                     &flFrameFlags, szClientClass, NULL,%@NL@%
                                     0L, NULL, 0, &hwndClient) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
VOID DrawWeb (HPS hps, POINTL *pptlPointerPos, POINTL *pptlClient)%@NL@%
     {%@NL@%
     POINTL ptl ;%@NL@%
                                   // Lower Left --> Pointer --> Upper Right%@NL@%
     ptl.x = 0 ;%@NL@%
     ptl.y = 0 ;%@NL@%
     GpiMove (hps, &ptl) ;%@NL@%
     GpiLine (hps, pptlPointerPos) ;%@NL@%
     GpiLine (hps, pptlClient) ;%@NL@%
                                   // Upper Left --> Pointer --> Lower Right%@NL@%
     ptl.x = 0 ;%@NL@%
     ptl.y = pptlClient->y ;%@NL@%
     GpiMove (hps, &ptl) ;%@NL@%
     GpiLine (hps, pptlPointerPos) ;%@NL@%
%@NL@%
     ptl.x = pptlClient->x ;%@NL@%
     ptl.y = 0 ;%@NL@%
     GpiLine (hps, &ptl) ;%@NL@%
                                   // Lower Center --> Pointer --> Upper Center%@NL@%
     ptl.x = pptlClient->x / 2 ;%@NL@%
     ptl.y = 0 ;%@NL@%
     GpiMove (hps, &ptl) ;%@NL@%
     GpiLine (hps, pptlPointerPos) ;%@NL@%
%@NL@%
     ptl.y = pptlClient->y ;%@NL@%
     GpiLine (hps, &ptl) ;%@NL@%
                                   // Left Center --> Pointer --> Right Center%@NL@%
     ptl.x = 0 ;%@NL@%
     ptl.y = pptlClient->y / 2 ;%@NL@%
     GpiMove (hps, &ptl) ;%@NL@%
     GpiLine (hps, pptlPointerPos) ;%@NL@%
%@NL@%
     ptl.x = pptlClient->x ;%@NL@%
     GpiLine (hps, &ptl) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static POINTL ptlClient, ptlPointerPos ;%@NL@%
     HPS           hps ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_SIZE:%@NL@%
               ptlClient.x = SHORT1FROMMP (mp2) ;%@NL@%
               ptlClient.y = SHORT2FROMMP (mp2) ;%@NL@%
               return 0 ;%@NL@%
     %@NL@%
          case WM_MOUSEMOVE:%@NL@%
               hps = WinGetPS (hwnd) ;%@NL@%
               GpiSetMix (hps, FM_INVERT) ;%@NL@%
%@NL@%
               DrawWeb (hps, &ptlPointerPos, &ptlClient) ;%@NL@%
%@NL@%
               ptlPointerPos.x = MOUSEMSG(&msg)->x ;%@NL@%
               ptlPointerPos.y = MOUSEMSG(&msg)->y ;%@NL@%
%@NL@%
               DrawWeb (hps, &ptlPointerPos, &ptlClient) ;%@NL@%
%@NL@%
               WinReleasePS (hps) ;%@NL@%
               break ;                       // do default processing%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
               GpiErase (hps) ;%@NL@%
               GpiSetMix (hps, FM_INVERT) ;%@NL@%
%@NL@%
               DrawWeb (hps, &ptlPointerPos, &ptlClient) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WEL.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP02\WEL.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------------%@NL@%
%@AB@%   WEL.C -- A Program that Creates a Message Queue%@NL@%
%@AB@%  -------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     HAB  hab ;%@NL@%
     HMQ  hmq ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WELC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP02\WELC.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------------------%@NL@%
%@AB@%   WELC.C -- A Program that Creates a Standard Frame Window%@NL@%
%@AB@%  ----------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (%@NL@%
                    HWND_DESKTOP,       // Parent window handle%@NL@%
                    WS_VISIBLE,         // Style of frame window%@NL@%
                    &flFrameFlags,      // Pointer to control data%@NL@%
                    NULL,               // Client window class name%@NL@%
                    NULL,               // Title bar text%@NL@%
                    0L,                 // Style of client window%@NL@%
                    NULL,               // Module handle for resources%@NL@%
                    0,                  // ID of resources%@NL@%
                    NULL) ;             // Pointer to client window handle%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WELCO.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP02\WELCO.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------------%@NL@%
%@AB@%   WELCO.C -- A Program with a Message Loop%@NL@%
%@AB@%  ------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (%@NL@%
                    HWND_DESKTOP,       // Parent window handle%@NL@%
                    WS_VISIBLE,         // Style of frame window%@NL@%
                    &flFrameFlags,      // Pointer to control data%@NL@%
                    NULL,               // Client window class name%@NL@%
                    NULL,               // Title bar text%@NL@%
                    0L,                 // Style of client window%@NL@%
                    NULL,               // Module handle for resources%@NL@%
                    0,                  // ID of resources%@NL@%
                    NULL) ;             // Pointer to client window handle%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WELCOM.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP02\WELCOM.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------------------%@NL@%
%@AB@%   WELCOM.C -- A Program that has a Standard Icon%@NL@%
%@AB@%  ------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (%@NL@%
                    HWND_DESKTOP,       // Parent window handle%@NL@%
                    WS_VISIBLE,         // Style of frame window%@NL@%
                    &flFrameFlags,      // Pointer to control data%@NL@%
                    NULL,               // Client window class name%@NL@%
                    NULL,               // Title bar text%@NL@%
                    0L,                 // Style of client window%@NL@%
                    NULL,               // Module handle for resources%@NL@%
                    0,                  // ID of resources%@NL@%
                    NULL) ;             // Pointer to client window handle%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WELCOME.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP02\WELCOME.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------------------%@NL@%
%@AB@%   WELCOME.C -- A Program that Creates a Client Window%@NL@%
%@AB@%  -----------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Welcome" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (%@NL@%
                    hab,                // Anchor block handle%@NL@%
                    szClientClass,      // Name of class being registered%@NL@%
                    ClientWndProc,      // Window procedure for class%@NL@%
                    0L,                 // Class style%@NL@%
                    0) ;                // Extra bytes to reserve%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (%@NL@%
                    HWND_DESKTOP,       // Parent window handle%@NL@%
                    WS_VISIBLE,         // Style of frame window%@NL@%
                    &flFrameFlags,      // Pointer to control data%@NL@%
                    szClientClass,      // Client window class name%@NL@%
                    NULL,               // Title bar text%@NL@%
                    0L,                 // Style of client window%@NL@%
                    NULL,               // Module handle for resources%@NL@%
                    0,                  // ID of resources%@NL@%
                    &hwndClient) ;      // Pointer to client window handle%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WELCOME1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP02\WELCOME1.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*----------------------------------------------------------%@NL@%
%@AB@%   WELCOME1.C -- A Program that Writes to its Client Window%@NL@%
%@AB@%  ----------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Welcome1" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame, hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (%@NL@%
                    hab,                // Anchor block handle%@NL@%
                    szClientClass,      // Name of class being registered%@NL@%
                    ClientWndProc,      // Window procedure for class%@NL@%
                    CS_SIZEREDRAW,      // Class style%@NL@%
                    0) ;                // Extra bytes to reserve%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (%@NL@%
                    HWND_DESKTOP,       // Parent window handle%@NL@%
                    WS_VISIBLE,         // Style of frame window%@NL@%
                    &flFrameFlags,      // Pointer to control data%@NL@%
                    szClientClass,      // Client window class name%@NL@%
                    NULL,               // Title bar text%@NL@%
                    0L,                 // Style of client window%@NL@%
                    NULL,               // Module handle for resources%@NL@%
                    0,                  // ID of resources%@NL@%
                    &hwndClient) ;      // Pointer to client window handle%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR szText [] = "Welcome to the OS/2 Presentation Manager" ;%@NL@%
     HPS         hps;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_CREATE:%@NL@%
               DosBeep (261, 100) ;%@NL@%
               DosBeep (330, 100) ;%@NL@%
               DosBeep (392, 100) ;%@NL@%
               DosBeep (523, 500) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
               WinDrawText (hps, -1, szText, &rcl, CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                            DT_CENTER | DT_VCENTER | DT_ERASERECT) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_DESTROY:%@NL@%
               DosBeep (523, 100) ;%@NL@%
               DosBeep (392, 100) ;%@NL@%
               DosBeep (330, 100) ;%@NL@%
               DosBeep (261, 500) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WELCOME2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP03\WELCOME2.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*------------------------------------------------------------%@NL@%
%@AB@%   WELCOME2.C -- A Program that Creates Two Top-Level Windows%@NL@%
%@AB@%  ------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY Client1WndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT EXPENTRY Client2WndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass1 [] = "Welcome2.1",%@NL@%
                  szClientClass2 [] = "Welcome2.2" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX  |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame1, hwndFrame2, hwndClient1, hwndClient2 ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (%@NL@%
                    hab,                // Anchor block handle%@NL@%
                    szClientClass1,     // Name of class being registered%@NL@%
                    Client1WndProc,     // Window procedure for class%@NL@%
                    CS_SIZEREDRAW,      // Class style%@NL@%
                    0) ;                // Extra bytes to reserve%@NL@%
%@NL@%
     WinRegisterClass (%@NL@%
                    hab,                // Anchor block handle%@NL@%
                    szClientClass2,     // Name of class being registered%@NL@%
                    Client2WndProc,     // Window procedure for class%@NL@%
                    CS_SIZEREDRAW,      // Class style%@NL@%
                    0) ;                // Extra bytes to reserve%@NL@%
%@NL@%
     hwndFrame1 = WinCreateStdWindow (%@NL@%
                    HWND_DESKTOP,       // Parent window handle%@NL@%
                    WS_VISIBLE,         // Style of frame window%@NL@%
                    &flFrameFlags,      // Pointer to control data%@NL@%
                    szClientClass1,     // Client window class name%@NL@%
                    NULL,               // Title bar text%@NL@%
                    0L,                 // Style of client window%@NL@%
                    NULL,               // Module handle for resources%@NL@%
                    0,                  // ID of resources%@NL@%
                    &hwndClient1) ;     // Pointer to client window handle%@NL@%
%@NL@%
     hwndFrame2 = WinCreateStdWindow (%@NL@%
                    HWND_DESKTOP,       // Parent window handle%@NL@%
                    WS_VISIBLE,         // Style of frame window%@NL@%
                    &flFrameFlags,      // Pointer to control data%@NL@%
                    szClientClass2,     // Client window class name%@NL@%
                    " - Window No. 2",  // Title bar text%@NL@%
                    0L,                 // Style of client window%@NL@%
                    NULL,               // Module handle for resources%@NL@%
                    0,                  // ID of resources%@NL@%
                    &hwndClient2) ;     // Pointer to client window handle%@NL@%
%@NL@%
     WinSendMsg (hwndFrame1, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     WinSendMsg (hwndFrame2, WM_SETICON,%@NL@%
                 WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                 NULL) ;%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame1) ;%@NL@%
     WinDestroyWindow (hwndFrame2) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY Client1WndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR szText [] = "Welcome to Window No. 1" ;%@NL@%
     HPS         hps ;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
               WinDrawText (hps, -1, szText, &rcl, CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                            DT_CENTER | DT_VCENTER | DT_ERASERECT) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY Client2WndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR szText [] = "Welcome to Window No. 2" ;%@NL@%
     HPS         hps ;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
               WinDrawText (hps, -1, szText, &rcl, CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                            DT_CENTER | DT_VCENTER | DT_ERASERECT) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CLOSE:%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WELCOME3.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP03\WELCOME3.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-----------------------------------------------------------%@NL@%
%@AB@%   WELCOME3.C -- Creates a Top-Level Window and Two Children%@NL@%
%@AB@%  -----------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
MRESULT EXPENTRY ChildWndProc  (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Welcome3",%@NL@%
                  szChildClass  [] = "Welcome3.Child" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU  |%@NL@%
                                 FCF_SIZEBORDER    | FCF_MINMAX   |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame,  hwndChildFrame1,  hwndChildFrame2,%@NL@%
                  hwndClient, hwndChildClient1, hwndChildClient2 ;%@NL@%
     QMSG         qmsg ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (%@NL@%
                    hab,                // Anchor block handle%@NL@%
                    szClientClass,      // Name of class being registered%@NL@%
                    ClientWndProc,      // Window procedure for class%@NL@%
                    CS_SIZEREDRAW,      // Class style%@NL@%
                    0) ;                // Extra bytes to reserve%@NL@%
%@NL@%
     WinRegisterClass (%@NL@%
                    hab,                // Anchor block handle%@NL@%
                    szChildClass,       // Name of class being registered%@NL@%
                    ChildWndProc,       // Window procedure for class%@NL@%
                    CS_SIZEREDRAW,      // Class style%@NL@%
                    sizeof (PVOID)) ;   // Extra bytes to reserve%@NL@%
%@NL@%
          %@AB@%/*-------------------------%@NL@%
%@AB@%             Create top-level window%@NL@%
%@AB@%            -------------------------*/%@AE@%%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (%@NL@%
                    HWND_DESKTOP,       // Parent window handle%@NL@%
                    WS_VISIBLE,         // Style of frame window%@NL@%
                    &flFrameFlags,      // Pointer to control data%@NL@%
                    szClientClass,      // Client window class name%@NL@%
                    NULL,               // Title bar text%@NL@%
                    0L,                 // Style of client window%@NL@%
                    NULL,               // Module handle for resources%@NL@%
                    0,                  // ID of resources%@NL@%
                    &hwndClient) ;      // Pointer to client window handle%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                      WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                      NULL) ;%@NL@%
%@NL@%
          %@AB@%/*--------------------------%@NL@%
%@AB@%             Create two child windows%@NL@%
%@AB@%            --------------------------*/%@AE@%%@NL@%
%@NL@%
     flFrameFlags &= ~FCF_TASKLIST ;%@NL@%
%@NL@%
     hwndChildFrame1 = WinCreateStdWindow (%@NL@%
                    hwndClient,         // Parent window handle%@NL@%
                    WS_VISIBLE,         // Style of frame window%@NL@%
                    &flFrameFlags,      // Pointer to control data%@NL@%
                    szChildClass,       // Client window class name%@NL@%
                    "Child No. 1",      // Title bar text%@NL@%
                    0L,                 // Style of client window%@NL@%
                    NULL,               // Module handle for resources%@NL@%
                    0,                  // ID of resources%@NL@%
                    &hwndChildClient1) ;// Pointer to client window handle%@NL@%
%@NL@%
     hwndChildFrame2 = WinCreateStdWindow (%@NL@%
                    hwndClient,         // Parent window handle%@NL@%
                    WS_VISIBLE,         // Style of frame window%@NL@%
                    &flFrameFlags,      // Pointer to control data%@NL@%
                    szChildClass,       // Client window class name%@NL@%
                    "Child No. 2",      // Title bar text%@NL@%
                    0L,                 // Style of client window%@NL@%
                    NULL,               // Module handle for resources%@NL@%
                    0,                  // ID of resources%@NL@%
                    &hwndChildClient2) ;// Pointer to client window handle%@NL@%
%@NL@%
     WinSendMsg (hwndChildFrame1, WM_SETICON,%@NL@%
                      WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                      NULL) ;%@NL@%
%@NL@%
     WinSendMsg (hwndChildFrame2, WM_SETICON,%@NL@%
                      WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                      NULL) ;%@NL@%
%@NL@%
          %@AB@%/*-----------------------------------------------------%@NL@%
%@AB@%             Set reserved area of window to text string pointers%@NL@%
%@AB@%            -----------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
     WinSetWindowPtr (hwndChildClient1, QWL_USER, "I'm a child ...") ;%@NL@%
     WinSetWindowPtr (hwndChildClient2, QWL_USER, "... Me too!") ;      %@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     static CHAR szText [] = "I'm the parent of two children" ;%@NL@%
     HPS         hps ;%@NL@%
     RECTL       rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
               WinDrawText (hps, -1, szText, &rcl, CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                            DT_CENTER | DT_VCENTER | DT_ERASERECT) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ChildWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     HPS   hps ;%@NL@%
     RECTL rcl ;%@NL@%
%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_PAINT:%@NL@%
               hps = WinBeginPaint (hwnd, NULL, NULL) ;%@NL@%
%@NL@%
               WinQueryWindowRect (hwnd, &rcl) ;%@NL@%
%@NL@%
               WinDrawText (hps, -1, WinQueryWindowPtr (hwnd, QWL_USER), &rcl,%@NL@%
                            CLR_NEUTRAL, CLR_BACKGROUND,%@NL@%
                            DT_CENTER | DT_VCENTER | DT_ERASERECT) ;%@NL@%
%@NL@%
               WinEndPaint (hps) ;%@NL@%
               return 0 ;%@NL@%
%@NL@%
          case WM_CLOSE:%@NL@%
               WinDestroyWindow (WinQueryWindow (hwnd, QW_PARENT, FALSE)) ;%@NL@%
               return 0 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WELCOME4.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\PROG_PM\CHAP03\WELCOME4.C%@AE@%%@NL@%
%@NL@%
%@AB@%/*-------------------------------------------------------------%@NL@%
%@AB@%   WELCOME4.C -- Creates a Top-Level Window and Three Children%@NL@%
%@AB@%  -------------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
%@AI@%#define %@AE@%INCL_WIN %@NL@%
%@AI@%#include %@AE@%<os2.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%ID_BUTTON 1 %@NL@%
%@AI@%#define %@AE@%ID_SCROLL 2 %@NL@%
%@AI@%#define %@AE@%ID_ENTRY  3 %@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND, USHORT, MPARAM, MPARAM) ;%@NL@%
%@NL@%
int main (void)%@NL@%
     {%@NL@%
     static CHAR  szClientClass [] = "Welcome4" ;%@NL@%
     static ULONG flFrameFlags = FCF_TITLEBAR      | FCF_SYSMENU   |%@NL@%
                                 FCF_BORDER        | FCF_MINBUTTON |%@NL@%
                                 FCF_SHELLPOSITION | FCF_TASKLIST ;%@NL@%
     HAB          hab ;%@NL@%
     HMQ          hmq ;%@NL@%
     HWND         hwndFrame,  hwndClient ;%@NL@%
     QMSG         qmsg ;%@NL@%
     RECTL        rcl ;%@NL@%
%@NL@%
     hab = WinInitialize (0) ;%@NL@%
     hmq = WinCreateMsgQueue (hab, 0) ;%@NL@%
%@NL@%
     WinRegisterClass (%@NL@%
                    hab,                // Anchor block handle%@NL@%
                    szClientClass,      // Name of class being registered%@NL@%
                    ClientWndProc,      // Window procedure for class%@NL@%
                    CS_SIZEREDRAW,      // Class style%@NL@%
                    0) ;                // Extra bytes to reserve%@NL@%
%@NL@%
     hwndFrame = WinCreateStdWindow (%@NL@%
                    HWND_DESKTOP,       // Parent window handle%@NL@%
                    WS_VISIBLE,         // Style of frame window%@NL@%
                    &flFrameFlags,      // Pointer to control data%@NL@%
                    szClientClass,      // Client window class name%@NL@%
                    NULL,               // Title bar text%@NL@%
                    0L,                 // Style of client window%@NL@%
                    NULL,               // Module handle for resources%@NL@%
                    0,                  // ID of resources%@NL@%
                    &hwndClient) ;      // Pointer to client window handle%@NL@%
%@NL@%
     WinSendMsg (hwndFrame, WM_SETICON,%@NL@%
                      WinQuerySysPointer (HWND_DESKTOP, SPTR_APPICON, FALSE),%@NL@%
                      NULL) ;%@NL@%
%@NL@%
          %@AB@%/*--------------------------------------------------------%@NL@%
%@AB@%             Find dimensions of client window for sizes of children%@NL@%
%@AB@%            --------------------------------------------------------*/%@AE@%%@NL@%
%@NL@%
     WinQueryWindowRect (hwndClient, &rcl) ;%@NL@%
     rcl.xRight /= 3 ;                            // divide width in thirds%@NL@%
%@NL@%
          %@AB@%/*---------------------------%@NL@%
%@AB@%             Create push button window%@NL@%
%@AB@%            ---------------------------*/%@AE@%%@NL@%
%@NL@%
     WinCreateWindow (%@NL@%
                    hwndClient,                   // Parent window handle%@NL@%
                    WC_BUTTON,                    // Window class%@NL@%
                    "Big Button",                 // Window text%@NL@%
                    WS_VISIBLE                    // Window style%@NL@%
                         | BS_PUSHBUTTON,%@NL@%
                    10,                           // Window position%@NL@%
                    10,%@NL@%
                    (SHORT) rcl.xRight - 20,      // Window size%@NL@%
                    (SHORT) rcl.yTop - 20,%@NL@%
                    hwndClient,                   // Owner window handle%@NL@%
                    HWND_BOTTOM,                  // Placement window handle%@NL@%
                    ID_BUTTON,                    // Child window ID%@NL@%
                    NULL,                         // Control data%@NL@%
                    NULL) ;                       // Presentation parameters%@NL@%
%@NL@%
          %@AB@%/*--------------------------%@NL@%
%@AB@%             Create scroll bar window%@NL@%
%@AB@%            --------------------------*/%@AE@%%@NL@%
%@NL@%
     WinCreateWindow (%@NL@%
                    hwndClient,                   // Parent window handle%@NL@%
                    WC_SCROLLBAR,                 // Window class%@NL@%
                    NULL,                         // Window text%@NL@%
                    WS_VISIBLE                    // Window style%@NL@%
                         | SBS_VERT,%@NL@%
                    (SHORT) rcl.xRight + 10,      // Window position%@NL@%
                    10,%@NL@%
                    (SHORT) rcl.xRight - 20,      // Window size%@NL@%
                    (SHORT) rcl.yTop - 20,%@NL@%
                    hwndClient,                   // Owner window handle%@NL@%
                    HWND_BOTTOM,                  // Placement window handle%@NL@%
                    ID_SCROLL,                    // Child window ID%@NL@%
                    NULL,                         // Control data%@NL@%
                    NULL) ;                       // Presentation parameters%@NL@%
%@NL@%
          %@AB@%/*---------------------------%@NL@%
%@AB@%             Create entry field window%@NL@%
%@AB@%            ---------------------------*/%@AE@%%@NL@%
%@NL@%
     WinCreateWindow (%@NL@%
                    hwndClient,                   // Parent window handle%@NL@%
                    WC_ENTRYFIELD,                // Window class%@NL@%
                    NULL,                         // Window text%@NL@%
                    WS_VISIBLE                    // Window style%@NL@%
                         | ES_MARGIN%@NL@%
                         | ES_AUTOSCROLL,%@NL@%
                    2 * (SHORT) rcl.xRight + 10,  // Window position%@NL@%
                    10,%@NL@%
                    (SHORT) rcl.xRight - 20,      // Window size%@NL@%
                    (SHORT) rcl.yTop - 20,%@NL@%
                    hwndClient,                   // Owner window handle%@NL@%
                    HWND_BOTTOM,                  // Placement window handle%@NL@%
                    ID_ENTRY,                     // Child window ID%@NL@%
                    NULL,                         // Control data%@NL@%
                    NULL) ;                       // Presentation parameters%@NL@%
%@NL@%
     while (WinGetMsg (hab, &qmsg, NULL, 0, 0))%@NL@%
          WinDispatchMsg (hab, &qmsg) ;%@NL@%
%@NL@%
     WinDestroyWindow (hwndFrame) ;%@NL@%
     WinDestroyMsgQueue (hmq) ;%@NL@%
     WinTerminate (hab) ;%@NL@%
     return 0 ;%@NL@%
     }%@NL@%
%@NL@%
MRESULT EXPENTRY ClientWndProc (HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2)%@NL@%
     {%@NL@%
     switch (msg)%@NL@%
          {%@NL@%
          case WM_COMMAND:%@NL@%
               switch (COMMANDMSG(&msg)->cmd)%@NL@%
                    {%@NL@%
                    case ID_BUTTON:%@NL@%
                         WinAlarm (HWND_DESKTOP, WA_NOTE) ;%@NL@%
                         return 0 ;%@NL@%
                    }%@NL@%
               break ;%@NL@%
%@NL@%
          case WM_ERASEBACKGROUND:%@NL@%
               return 1 ;%@NL@%
          }%@NL@%
     return WinDefWindowProc (hwnd, msg, mp1, mp2) ;%@NL@%
     }%@NL@%
