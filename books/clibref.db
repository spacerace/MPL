%@1@%%@AB@%Microsoft  C - RUN-TIME LIBRARY REFERENCE%@AE@%%@EH@%%@NL@%
                                      %@NL@%
                                      %@NL@%
                                      %@NL@%
                                      %@NL@%
                                      %@NL@%
                                      %@NL@%
                                      %@NL@%

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
                %@AB@%Microsoft (R) C - RUN-TIME LIBRARY REFERENCE%@AE@%%@NL@%
                                      %@NL@%
                             %@AB@%FOR THE MS-DOS (R)
                              %@AB@%OPERATING SYSTEM%@AE@%%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
                                      %@NL@%
                                      %@NL@%
                           MICROSOFT CORPORATION %@NL@%
                                      %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%%@NL@%
%@NL@%


PUBLISHED BY
Microsoft Press
A Division of Microsoft Corporation
One Microsoft Way, Redmond, Washington 98052-6399

Copyright (C)  1990 by Microsoft Press

All rights reserved. No part of the contents of this book may be reproduced
or transmitted in any form or by any means without the written permission of
the publisher.

Library of Congress Cataloging-in-Publication Data

Microsoft C run-time library reference.

Includes  index.
1. C (Computer program language) 2. Microsoft C
(Computer program) 3. Macro instructions (Electronic
computers) I. Microsoft.
QA76.73.C15M52  1990         005.13'3         89-12240
ISBN 1-55615-225-6

Printed and bound in the United States of America.

1 2 3 4 5 6 7 8 9  HCHC 3 2 1 0 9

Distributed to the book trade in Canada by General Publishing Company, Ltd.

Distributed to the book trade outside the United States and Canada by
Penguin
Books  Ltd.

Penguin Books Ltd., Harmondsworth, Middlesex, England
Penguin Books Australia Ltd., Ringwood, Victoria, Australia
Penguin Books N.Z. Ltd., 182-190 Wairau Road, Auckland 10, New Zealand

British Cataloging in Publication Data available.

                                            %@AB@%Sample%@AE@%
%@AB@%Writers:%@AE@%           %@AB@%Editors:%@AE@%                 %@AB@%Programs:%@AE@%
Phil Nelson        Amanda Clark             Bruce McKinney
Terry Ward         Moira Macdonald
                   Marjorie Manwaring
                   Bill Nolan%@NL@%
%@NL@%
Microsoft, the Microsoft logo, MS-DOS, QuickC, and XENIX are
registered trademarks and Windows is a trademark of Microsoft Corporation.%@NL@%
%@NL@%
AT&T and UNIX are registered trademarks of American Telephone
and Telegraph Company.%@NL@%
%@NL@%
Hercules is a registered trademark of Hercules Computer
Technology.%@NL@%
%@NL@%
IBM is a registered trademark of International Business
Machines Corporation.%@NL@%
%@NL@%
Olivetti is a registered trademark of Ing. C. Olivetti.%@NL@%
%@NL@%
Document No. 410840021-520-R00-1088
Part No. 04412%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@1@%%@AB@%Table of Contents%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@NL@%
%@NL@%

%@NL@%
%@AB@%Introduction%@AE@%%@BO:        60e8@%%@NL@%
     About the C Run-Time Library%@BO:        681f@%%@NL@%
            ANSI C Compatibility%@BO:        6ad6@%%@NL@%
            OS/2 and XENIX(R) Programming%@BO:        6ef0@%%@NL@%
            Expanded Graphics Library%@BO:        7195@%%@NL@%
     About This Book%@BO:        7603@%%@NL@%
     Other Books of Interest%@BO:        7cc7@%%@NL@%
     Document Conventions%@BO:        8d75@%%@NL@%
%@NL@%
%@NL@%
%@AB@%PART I%@AE@%%@BO:        9ce2@%  %@AB@%Overview%@AE@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@NL@%
%@NL@%
%@NL@%
%@AB@%Chapter 1%@AE@%%@BO:        9f3e@%  %@AB@%Using C Library Routines%@AE@%%@NL@%
%@NL@%
     1.1%@BO:        a17a@%   Calling Library Routines%@NL@%
     1.2%@BO:        acbb@%   Using Header Files%@NL@%
            1.2.1%@BO:        adcb@%    Including Necessary Definitions%@NL@%
            1.2.2%@BO:        b402@%    Including Function Declarations%@NL@%
     1.3%@BO:        c64f@%   File Names and Path Names%@NL@%
     1.4%@BO:        cd69@%   Choosing Between Functions and Macros%@NL@%
     1.5%@BO:        e2d8@%   Stack Checking on Entry%@NL@%
     1.6%@BO:        e7ec@%   Handling Errors%@NL@%
     1.7%@BO:        f3f7@%   Operating-System Considerations%@NL@%
     1.8%@BO:        ff84@%   Floating-Point Support%@NL@%
     1.9%@BO:       1101b@%   Using Huge Arrays with Library Functions%@NL@%
%@NL@%
%@AB@%Chapter 2%@AE@%%@BO:       117ed@%  %@AB@%Run-Time Routines by Category%@AE@%%@NL@%
%@NL@%
     2.1%@BO:       11d28@%   Buffer Manipulation%@NL@%
     2.2%@BO:       12a93@%   Character Classification and Conversion%@NL@%
     2.3%@BO:       136c7@%   Data Conversion %@NL@%
     2.4%@BO:       14030@%   Directory Control%@NL@%
     2.5%@BO:       1456f@%   File Handling%@NL@%
     2.6%@BO:       1555d@%   Graphics%@NL@%
            2.6.1%@BO:       15786@%    Low-Level Graphics and Character-Font Functions%@NL@%
            2.6.2%@BO:       1afcf@%    Presentation-Graphics Functions%@NL@%
     2.7%@BO:       1cc64@%   Input and Output%@NL@%
            2.7.1%@BO:       1d597@%    Text and Binary Modes%@NL@%
            2.7.2%@BO:       1e13d@%    Stream Routines%@NL@%
            2.7.3%@BO:       221df@%    Low-Level Routines%@NL@%
            2.7.4%@BO:       239df@%    Console and Port I/O%@NL@%
     2.8%@BO:       24c42@%   Internationalization%@NL@%
     2.9%@BO:       250cb@%   Math%@NL@%
     2.10%@BO:       2719e@%  Memory Allocation %@NL@%
            2.10.1%@BO:       28704@%   Near and Far Heaps%@NL@%
            2.10.2%@BO:       28cf2@%   Based Heaps%@NL@%
     2.11%@BO:       29437@%  Process and Environment Control %@NL@%
     2.12%@BO:       2c9a9@%  Searching and Sorting %@NL@%
     2.13%@BO:       2cd6b@%  String Manipulation%@NL@%
     2.14%@BO:       2dde5@%  System Calls%@NL@%
            2.14.1%@BO:       2df7d@%   BIOS Interface %@NL@%
            2.14.2%@BO:       2e68c@%   DOS Interface%@NL@%
     2.15%@BO:       31041@%  Time%@NL@%
     2.16%@BO:       3212e@%  Variable-Length Argument Lists%@NL@%
%@NL@%
%@AB@%Chapter 3%@AE@%%@BO:       325f9@%  %@AB@%Global Variables and Standard Types%@AE@%%@NL@%
%@NL@%
     3.1%@BO:       3283e@%   _amblksiz%@NL@%
     3.2%@BO:       330b2@%   daylight, timezone, tzname%@NL@%
     3.3%@BO:       33a2f@%   _doserrno, errno, sys_errlist, sys_nerr    %@NL@%
     3.4%@BO:       34df1@%   _fmode  %@NL@%
     3.5%@BO:       35126@%   _osmajor, _osminor, _osmode, _osversion    %@NL@%
     3.6%@BO:       358aa@%   environ%@NL@%
     3.7%@BO:       35e51@%   _psp%@NL@%
     3.8%@BO:       36186@%   Standard Types%@NL@%
%@NL@%
%@NL@%
%@AB@%PART II%@AE@%%@BO:       388bb@%  %@AB@%Run-Time Functions%@AE@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@NL@%
%@NL@%
     About the Run-Time Reference%@BO:       38b14@%%@NL@%
            abort%@BO:       3918f@%%@NL@%
            abs%@BO:       39c83@%%@NL@%
            access%@BO:       3a51d@%%@NL@%
            acos Functions%@BO:       3b2f2@%%@NL@%
            alloca%@BO:       3bfb2@%%@NL@%
            _arc Functions%@BO:       3cd40@%%@NL@%
            asctime%@BO:       3dfa0@%%@NL@%
            asin Functions%@BO:       3ef49@%%@NL@%
            assert%@BO:       3fba2@%%@NL@%
            atan Functions%@BO:       40aaa@%%@NL@%
            atexit%@BO:       4182b@%%@NL@%
            atof, atoi, atol, _atold%@BO:       42491@%%@NL@%
            bdos%@BO:       4396d@%%@NL@%
            _beginthread%@BO:       44616@%%@NL@%
            Bessel Functions%@BO:       467cf@%%@NL@%
            _bfreeseg%@BO:       47c82@%%@NL@%
            _bheapseg%@BO:       48b9d@%%@NL@%
            _bios_disk%@BO:       49d7c@%%@NL@%
            _bios_equiplist%@BO:       4c4f3@%%@NL@%
            _bios_keybrd%@BO:       4d003@%%@NL@%
            _bios_memsize%@BO:       4e8f5@%%@NL@%
            _bios_printer%@BO:       4ef09@%%@NL@%
            _bios_serialcom%@BO:       50135@%%@NL@%
            _bios_timeofday%@BO:       51aa3@%%@NL@%
            bsearch%@BO:       526b2@%%@NL@%
            cabs, cabsl%@BO:       53a4b@%%@NL@%
            calloc Functions%@BO:       544f9@%%@NL@%
            ceil, ceill%@BO:       555d7@%%@NL@%
            _cexit, _c_exit%@BO:       5608d@%%@NL@%
            cgets%@BO:       56b23@%%@NL@%
            _chain_intr%@BO:       577bb@%%@NL@%
            chdir%@BO:       585ac@%%@NL@%
            _chdrive%@BO:       593ee@%%@NL@%
            chmod%@BO:       5a293@%%@NL@%
            chsize%@BO:       5b15c@%%@NL@%
            _clear87%@BO:       5bfa2@%%@NL@%
            clearerr%@BO:       5c99b@%%@NL@%
            _clearscreen%@BO:       5d349@%%@NL@%
            clock%@BO:       5dd96@%%@NL@%
            close%@BO:       5ea6b@%%@NL@%
            _control87%@BO:       5f46c@%%@NL@%
            cos Functions%@BO:       608a6@%%@NL@%
            cprintf%@BO:       615fd@%%@NL@%
            cputs%@BO:       62053@%%@NL@%
            creat%@BO:       6275b@%%@NL@%
            cscanf%@BO:       63b00@%%@NL@%
            ctime%@BO:       646ec@%%@NL@%
            cwait%@BO:       65444@%%@NL@%
            dieeetomsbin, dmsbintoieee%@BO:       674ae@%%@NL@%
            difftime%@BO:       67d18@%%@NL@%
            _displaycursor%@BO:       686db@%%@NL@%
            div%@BO:       69024@%%@NL@%
            _dos_allocmem%@BO:       69bf6@%%@NL@%
            _dos_close%@BO:       6a817@%%@NL@%
            _dos_creat Functions%@BO:       6b1ef@%%@NL@%
            _dos_find Functions%@BO:       6c149@%%@NL@%
            _dos_freemem%@BO:       6df3c@%%@NL@%
            _dos_getdate%@BO:       6ea74@%%@NL@%
            _dos_getdiskfree%@BO:       6f474@%%@NL@%
            _dos_getdrive%@BO:       7006a@%%@NL@%
            _dos_getfileattr%@BO:       70a67@%%@NL@%
            _dos_getftime%@BO:       71b5c@%%@NL@%
            _dos_gettime%@BO:       72d14@%%@NL@%
            _dos_getvect%@BO:       736d0@%%@NL@%
            _dos_keep%@BO:       73dbd@%%@NL@%
            _dos_open%@BO:       74998@%%@NL@%
            _dos_read%@BO:       75c4f@%%@NL@%
            _dos_setblock%@BO:       76a0b@%%@NL@%
            _dos_setdate%@BO:       7760e@%%@NL@%
            _dos_setdrive%@BO:       782a0@%%@NL@%
            _dos_setfileattr%@BO:       78e46@%%@NL@%
            _dos_setftime%@BO:       7a046@%%@NL@%
            _dos_settime%@BO:       7b17b@%%@NL@%
            _dos_setvect%@BO:       7bdfd@%%@NL@%
            _dos_write%@BO:       7d825@%%@NL@%
            dosexterr%@BO:       7e534@%%@NL@%
            dup, dup2%@BO:       7f385@%%@NL@%
            ecvt%@BO:       803c0@%%@NL@%
            _ellipse Functions%@BO:       8119d@%%@NL@%
            _enable%@BO:       82278@%%@NL@%
            _endthread%@BO:       825f4@%%@NL@%
            eof%@BO:       82ba1@%%@NL@%
            exec Functions%@BO:       83572@%%@NL@%
            exit, _exit%@BO:       86c0b@%%@NL@%
            exp, expl%@BO:       87c85@%%@NL@%
            _expand Functions%@BO:       88501@%%@NL@%
            fabs, fabsl%@BO:       89b71@%%@NL@%
            fclose, fcloseall%@BO:       8a5c9@%%@NL@%
            fcvt%@BO:       8b384@%%@NL@%
            fdopen%@BO:       8c1f2@%%@NL@%
            feof%@BO:       8d62b@%%@NL@%
            ferror%@BO:       8e0f7@%%@NL@%
            fflush%@BO:       8eb47@%%@NL@%
            fgetc, fgetchar%@BO:       8f6d7@%%@NL@%
            fgetpos%@BO:       903d7@%%@NL@%
            fgets%@BO:       9124b@%%@NL@%
            fieeetomsbin, fmsbintoieee%@BO:       91df3@%%@NL@%
            filelength%@BO:       9260a@%%@NL@%
            fileno%@BO:       92fa7@%%@NL@%
            _floodfill, _floodfill_w%@BO:       937b9@%%@NL@%
            floor, floorl%@BO:       9445a@%%@NL@%
            flushall%@BO:       94ebe@%%@NL@%
            fmod, fmodl%@BO:       956a5@%%@NL@%
            fopen%@BO:       96058@%%@NL@%
            FP_OFF, FP_SEG%@BO:       97d48@%%@NL@%
            _fpreset%@BO:       98566@%%@NL@%
            fprintf%@BO:       99b20@%%@NL@%
            fputc, fputchar%@BO:       9a664@%%@NL@%
            fputs%@BO:       9b19d@%%@NL@%
            fread%@BO:       9b8ea@%%@NL@%
            free Functions%@BO:       9c89a@%%@NL@%
            _freect%@BO:       9dbfa@%%@NL@%
            freopen%@BO:       9e721@%%@NL@%
            frexp, frexpl%@BO:       a0465@%%@NL@%
            fscanf%@BO:       a0f0e@%%@NL@%
            fseek%@BO:       a1cd1@%%@NL@%
            fsetpos%@BO:       a2edd@%%@NL@%
            _fsopen%@BO:       a3d28@%%@NL@%
            fstat%@BO:       a5e7a@%%@NL@%
            ftell%@BO:       a7374@%%@NL@%
            ftime%@BO:       a8370@%%@NL@%
            _fullpath%@BO:       a9207@%%@NL@%
            fwrite%@BO:       aa009@%%@NL@%
            gcvt%@BO:       aae6c@%%@NL@%
            _getactivepage%@BO:       ab89b@%%@NL@%
            _getarcinfo%@BO:       ac314@%%@NL@%
            _getbkcolor%@BO:       accf6@%%@NL@%
            getc, getchar%@BO:       ad644@%%@NL@%
            getch, getche%@BO:       ae25a@%%@NL@%
            _getcolor%@BO:       aebc0@%%@NL@%
            _getcurrentposition Functions%@BO:       af76f@%%@NL@%
            getcwd%@BO:       b069d@%%@NL@%
            _getdcwd%@BO:       b13ae@%%@NL@%
            _getdrive%@BO:       b25f3@%%@NL@%
            getenv%@BO:       b2a78@%%@NL@%
            _getfillmask%@BO:       b3958@%%@NL@%
            _getfontinfo%@BO:       b47b4@%%@NL@%
            _getgtextextent%@BO:       b518c@%%@NL@%
            _getimage Functions%@BO:       b578c@%%@NL@%
            _getlinestyle%@BO:       b6b86@%%@NL@%
            _getphyscoord%@BO:       b79d6@%%@NL@%
            getpid%@BO:       b8070@%%@NL@%
            _getpixel Functions%@BO:       b872a@%%@NL@%
            gets%@BO:       b93d1@%%@NL@%
            _gettextcolor%@BO:       b9c6b@%%@NL@%
            _gettextcursor%@BO:       ba2b6@%%@NL@%
            _gettextposition%@BO:       ba79f@%%@NL@%
            _gettextwindow%@BO:       bb713@%%@NL@%
            _getvideoconfig%@BO:       bbf34@%%@NL@%
            _getviewcoord Functions%@BO:       bdaa1@%%@NL@%
            _getvisualpage%@BO:       be761@%%@NL@%
            getw%@BO:       bed02@%%@NL@%
            _getwindowcoord%@BO:       bf896@%%@NL@%
            _getwritemode%@BO:       bffc1@%%@NL@%
            gmtime%@BO:       c0c44@%%@NL@%
            _grstatus%@BO:       c1b7a@%%@NL@%
            halloc%@BO:       c50a1@%%@NL@%
            _hard Functions%@BO:       c5ae8@%%@NL@%
            _heapadd Functions%@BO:       c8111@%%@NL@%
            _heapchk Functions%@BO:       c986a@%%@NL@%
            _heapmin Functions%@BO:       ca8c3@%%@NL@%
            _heapset Functions%@BO:       cb359@%%@NL@%
            _heapwalk Functions%@BO:       cc691@%%@NL@%
            hfree%@BO:       ce432@%%@NL@%
            hypot, hypotl%@BO:       ced41@%%@NL@%
            _imagesize Functions%@BO:       cf737@%%@NL@%
            inp, inpw%@BO:       d034f@%%@NL@%
            int86%@BO:       d0c38@%%@NL@%
            int86x%@BO:       d1a2f@%%@NL@%
            intdos%@BO:       d2a93@%%@NL@%
            intdosx%@BO:       d37ba@%%@NL@%
            is Functions%@BO:       d467d@%%@NL@%
            isatty%@BO:       d5fa1@%%@NL@%
            itoa%@BO:       d66b5@%%@NL@%
            kbhit%@BO:       d7284@%%@NL@%
            labs%@BO:       d7a47@%%@NL@%
            ldexp, ldexpl%@BO:       d82cd@%%@NL@%
            ldiv%@BO:       d8bf5@%%@NL@%
            lfind%@BO:       d9730@%%@NL@%
            _lineto Functions%@BO:       da6e4@%%@NL@%
            localeconv%@BO:       db323@%%@NL@%
            localtime%@BO:       dd16a@%%@NL@%
            locking%@BO:       de396@%%@NL@%
            log Functions%@BO:       dfccd@%%@NL@%
            long double Functions%@BO:       e08bc@%%@NL@%
            longjmp%@BO:       e14ca@%%@NL@%
            _lrotl, _lrotr%@BO:       e22e1@%%@NL@%
            lsearch%@BO:       e2b64@%%@NL@%
            lseek%@BO:       e37af@%%@NL@%
            ltoa%@BO:       e4a65@%%@NL@%
            _makepath%@BO:       e564b@%%@NL@%
            malloc Functions%@BO:       e6d90@%%@NL@%
            matherr, _matherrl%@BO:       e9184@%%@NL@%
            max%@BO:       ead81@%%@NL@%
            _memavl%@BO:       eb4bb@%%@NL@%
            memccpy, _fmemccpy%@BO:       ebfb6@%%@NL@%
            memchr, _fmemchr%@BO:       eccf2@%%@NL@%
            memcmp, _fmemcmp%@BO:       edb82@%%@NL@%
            memcpy, _fmemcpy%@BO:       eecbb@%%@NL@%
            memicmp, _fmemicmp%@BO:       f019c@%%@NL@%
            _memmax%@BO:       f1163@%%@NL@%
            memmove, _fmemmove%@BO:       f1b64@%%@NL@%
            memset, _fmemset%@BO:       f2e58@%%@NL@%
            min%@BO:       f3a2b@%%@NL@%
            mkdir%@BO:       f4166@%%@NL@%
            mktemp%@BO:       f4dcd@%%@NL@%
            mktime%@BO:       f5f19@%%@NL@%
            modf, modfl%@BO:       f6e15@%%@NL@%
            movedata%@BO:       f7841@%%@NL@%
            _moveto Functions%@BO:       f863b@%%@NL@%
            _msize Functions%@BO:       f93b6@%%@NL@%
            onexit%@BO:       fa55b@%%@NL@%
            open%@BO:       fb0e9@%%@NL@%
            _outgtext%@BO:       fd68e@%%@NL@%
            _outmem%@BO:       fea80@%%@NL@%
            outp, outpw%@BO:       ff351@%%@NL@%
            _outtext%@BO:      10053b@%%@NL@%
            _pclose%@BO:      10126a@%%@NL@%
            perror%@BO:      101a68@%%@NL@%
            _pg_analyzechart Functions%@BO:      102aba@%%@NL@%
            _pg_analyzepie%@BO:      10438e@%%@NL@%
            _pg_analyzescatter Functions%@BO:      104bad@%%@NL@%
            _pg_chart Functions%@BO:      10587e@%%@NL@%
            _pg_chartscatter Functions%@BO:      106ee0@%%@NL@%
            _pg_chartpie%@BO:      107ac6@%%@NL@%
            _pg_defaultchart%@BO:      10849d@%%@NL@%
            _pg_getchardef%@BO:      109371@%%@NL@%
            _pg_getpalette%@BO:      1098dc@%%@NL@%
            _pg_getstyleset%@BO:      10b2f4@%%@NL@%
            _pg_hlabelchart%@BO:      10b7a5@%%@NL@%
            _pg_initchart%@BO:      10bea1@%%@NL@%
            _pg_resetpalette%@BO:      10c693@%%@NL@%
            _pg_resetstyleset%@BO:      10cc89@%%@NL@%
            _pg_setchardef%@BO:      10d100@%%@NL@%
            _pg_setpalette%@BO:      10d692@%%@NL@%
            _pg_setstyleset%@BO:      10dd45@%%@NL@%
            _pg_vlabelchart%@BO:      10e1de@%%@NL@%
            _pie Functions%@BO:      10e8d4@%%@NL@%
            _pipe%@BO:      10fd2d@%%@NL@%
            _polygon Functions%@BO:      111db1@%%@NL@%
            _popen%@BO:      112f74@%%@NL@%
            pow Functions%@BO:      113f34@%%@NL@%
            printf%@BO:      114b08@%%@NL@%
            putc, putchar%@BO:      11afff@%%@NL@%
            putch%@BO:      11ba7c@%%@NL@%
            putenv%@BO:      11c223@%%@NL@%
            _putimage Functions%@BO:      11d544@%%@NL@%
            puts%@BO:      11e6e5@%%@NL@%
            putw%@BO:      11edcd@%%@NL@%
            qsort%@BO:      11f8f4@%%@NL@%
            raise%@BO:      1209b7@%%@NL@%
            rand%@BO:      121769@%%@NL@%
            read%@BO:      121fe1@%%@NL@%
            realloc Functions%@BO:      12321d@%%@NL@%
            _rectangle Functions%@BO:      124988@%%@NL@%
            _registerfonts%@BO:      125b2e@%%@NL@%
            _remapallpalette, _remappalette%@BO:      1265e5@%%@NL@%
            remove%@BO:      129398@%%@NL@%
            rename%@BO:      129be8@%%@NL@%
            rewind%@BO:      12a97e@%%@NL@%
            rmdir%@BO:      12b52b@%%@NL@%
            rmtmp%@BO:      12c0fc@%%@NL@%
            _rotl, _rotr%@BO:      12cabd@%%@NL@%
            scanf%@BO:      12d39b@%%@NL@%
            _scrolltextwindow%@BO:      131185@%%@NL@%
            _searchenv%@BO:      132443@%%@NL@%
            segread%@BO:      133031@%%@NL@%
            _selectpalette%@BO:      1338f3@%%@NL@%
            _setactivepage%@BO:      134f2f@%%@NL@%
            _setbkcolor%@BO:      135d81@%%@NL@%
            setbuf%@BO:      136986@%%@NL@%
            _setcliprgn%@BO:      1375e9@%%@NL@%
            _setcolor%@BO:      137f24@%%@NL@%
            _setfillmask%@BO:      138c65@%%@NL@%
            _setfont%@BO:      139939@%%@NL@%
            _setgtextvector%@BO:      13b65a@%%@NL@%
            setjmp%@BO:      13bff2@%%@NL@%
            _setlinestyle%@BO:      13c8cb@%%@NL@%
            setlocale%@BO:      13cf6e@%%@NL@%
            setmode%@BO:      13e030@%%@NL@%
            _setpixel Functions%@BO:      13efb1@%%@NL@%
            _settextcolor%@BO:      13fbad@%%@NL@%
            _settextcursor%@BO:      140ea8@%%@NL@%
            _settextposition%@BO:      141a4a@%%@NL@%
            _settextrows%@BO:      1428ed@%%@NL@%
            _settextwindow%@BO:      143229@%%@NL@%
            setvbuf%@BO:      143a0b@%%@NL@%
            _setvideomode%@BO:      144bab@%%@NL@%
            _setvideomoderows%@BO:      1471df@%%@NL@%
            _setvieworg%@BO:      147cb4@%%@NL@%
            _setviewport%@BO:      148835@%%@NL@%
            _setvisualpage%@BO:      149155@%%@NL@%
            _setwindow%@BO:      149700@%%@NL@%
            _setwritemode%@BO:      14b303@%%@NL@%
            signal%@BO:      14ba04@%%@NL@%
            sin Functions%@BO:      14fca4@%%@NL@%
            sopen%@BO:      1509fa@%%@NL@%
            spawn Functions%@BO:      1530a2@%%@NL@%
            _splitpath%@BO:      15729e@%%@NL@%
            sprintf%@BO:      1581ec@%%@NL@%
            sqrt, sqrtl%@BO:      158dcd@%%@NL@%
            srand%@BO:      1596bc@%%@NL@%
            sscanf%@BO:      15a07a@%%@NL@%
            stackavail%@BO:      15ac8b@%%@NL@%
            stat%@BO:      15b49e@%%@NL@%
            _status87%@BO:      15c7a1@%%@NL@%
            strcat, _fstrcat%@BO:      15d21c@%%@NL@%
            strchr, _fstrchr%@BO:      15ddf9@%%@NL@%
            strcmp, _fstrcmp%@BO:      15ef39@%%@NL@%
            strcmpi%@BO:      160083@%%@NL@%
            strcoll%@BO:      160916@%%@NL@%
            strcpy, _fstrcpy%@BO:      161199@%%@NL@%
            strcspn, _fstrcspn%@BO:      161d81@%%@NL@%
            _strdate%@BO:      1629b2@%%@NL@%
            strdup Functions%@BO:      16324c@%%@NL@%
            strerror, _strerror%@BO:      1640af@%%@NL@%
            strftime%@BO:      1651ca@%%@NL@%
            stricmp, _fstricmp%@BO:      166454@%%@NL@%
            strlen, _fstrlen%@BO:      166ff9@%%@NL@%
            strlwr, _fstrlwr%@BO:      1678a7@%%@NL@%
            strncat, _fstrncat%@BO:      1682e1@%%@NL@%
            strncmp, _fstrncmp%@BO:      168fa4@%%@NL@%
            strncpy, _fstrncpy%@BO:      16a1c0@%%@NL@%
            strnicmp, _fstrnicmp%@BO:      16aec9@%%@NL@%
            strnset, _fstrnset%@BO:      16b9a8@%%@NL@%
            strpbrk, _fstrpbrk%@BO:      16c426@%%@NL@%
            strrchr, _fstrrchr%@BO:      16d07b@%%@NL@%
            strrev, _fstrrev%@BO:      16e11b@%%@NL@%
            strset, _fstrset%@BO:      16ec0f@%%@NL@%
            strspn, _fstrspn%@BO:      16f56c@%%@NL@%
            strstr, _fstrstr%@BO:      170273@%%@NL@%
            _strtime%@BO:      170fa5@%%@NL@%
            strtod, strtol, _strtold, strtoul%@BO:      1718a0@%%@NL@%
            strtok, _fstrtok%@BO:      1736b8@%%@NL@%
            strupr, _fstrupr%@BO:      17484b@%%@NL@%
            strxfrm%@BO:      175200@%%@NL@%
            swab%@BO:      175c20@%%@NL@%
            system%@BO:      17646b@%%@NL@%
            tan Functions%@BO:      17742e@%%@NL@%
            tell%@BO:      1782fe@%%@NL@%
            tempnam, tmpnam%@BO:      178b8a@%%@NL@%
            time%@BO:      17a158@%%@NL@%
            tmpfile%@BO:      17a9fb@%%@NL@%
            toascii, tolower, toupper Functions%@BO:      17b4c9@%%@NL@%
            tzset%@BO:      17ca1b@%%@NL@%
            ultoa%@BO:      17dd29@%%@NL@%
            umask%@BO:      17e88d@%%@NL@%
            ungetc%@BO:      17f63c@%%@NL@%
            ungetch%@BO:      1805dc@%%@NL@%
            unlink%@BO:      18106f@%%@NL@%
            _unregisterfonts%@BO:      1818e9@%%@NL@%
            utime%@BO:      181e8c@%%@NL@%
            va_arg, va_end, va_start%@BO:      182ded@%%@NL@%
            vfprintf, vprintf, vsprintf%@BO:      185300@%%@NL@%
            wait%@BO:      1869bd@%%@NL@%
            _wrapon%@BO:      18855d@%%@NL@%
            write%@BO:      189031@%%@NL@%

%@AB@%Index%@AE@%%@BO:      18a0ba@%


%@NL@%
%@NL@%
%@CR:C6A-Intro   @%%@1@%%@AB@%Introduction%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
The Microsoft(R) C Run-Time Library is a set of over 500 ready-to-use
functions and macros designed for use in C programs. The run-time library
makes programming easier by providing  %@NL@%
%@NL@%
%@NL@%
  ş   Fast and efficient routines to perform common programming tasks (such
      as string manipulation), sparing you the time and effort needed to
      write such routines%@NL@%
%@NL@%
  ş   Reliable methods of performing operating-system functions (such as
      opening and closing files)%@NL@%
%@NL@%
%@NL@%
The C run-time library is important because it provides basic functions not
provided by the C language itself. These functions include input and output,
memory allocation, process control, graphics, and many others.  %@NL@%
%@NL@%
This book describes the Microsoft C run-time library routines included with
the Microsoft Professional Development System version 6.0. These comprise
all of the routines included with earlier versions of Microsoft C, as well
as many new routines.  %@NL@%
%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
NOTE

%@AI@%Microsoft documentation uses the term "OS/2" to refer to the OS/2
%@AI@%systemsÄMicrosoft Operating System/2 (MS%@AI@%(R)%@AE@%%@AI@% OS/2) and IBM%@AE@%%@AI@%(R)%@AE@%%@AI@% OS/2.
%@AI@%Similarly, the term "DOS" refers to both the MS-DOS%@AE@%%@AI@%(R)%@AE@%%@AI@% %@AE@%%@AI@%and IBM Personal
%@AI@%Computer DOS operating systems. The name of a specific operating system is
%@AI@%used when it is necessary to note features that are unique to that system.%@AE@%%@AE@%%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00000001 @%%@AB@%About the C Run-Time Library%@AE@%%@EH@%%@NL@%
%@NL@%
The Microsoft C run-time library contains a number of new routines and
features which support American National Standards Institute (ANSI) C
compatibility, OS/2 and XENIX(R) programming, and sophisticated graphics
programming.  %@NL@%
%@NL@%
To ease the task of transporting programs from one operating system to
another, the description of each library routine includes compatibility
boxes, which show at a glance whether the routine is compatible with ANSI C,
MS-DOS, OS/2, UNIX(R), and XENIX. (In this book, references to XENIX systems
also encompass UNIX and other UNIX-like systems.)  %@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00000002 @%%@AB@%ANSI C Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
The C run-time library routines are designed for compatibility with the ANSI
C standard, which Microsoft C compilers support. The major innovation of
ANSI C is to permit argument-type lists in function prototypes
(declarations). Given the information in the function prototype, the
compiler can check later references to the function to make sure that the
references use the correct number and type of arguments and the correct
return value.  %@NL@%
%@NL@%
To take advantage of the compiler's type-checking ability, the include files
that accompany the C run-time library have been expanded. In addition to the
definitions and declarations required by library routines, the include files
now contain function declarations with argument-type lists. Several new
include files have also been added. The names of these files are chosen to
maximize compatibility with the ANSI C standard and with XENIX and UNIX
names.%@CR:C6A00000003 @%%@CR:C6A00000004 @%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00000005 @%%@AB@%OS/2 and XENIX(R) Programming%@AE@%%@EH@%%@NL@%
%@NL@%
Microsoft C run-time library routines are designed to maintain maximum
compatibility between MS-DOS, OS/2, and XENIX or UNIX systems. The library
offers a number of operating-system interface routines that allow you to
take advantage of specific DOS and OS/2 features.  %@NL@%
%@NL@%
Most of the functions in the C library for DOS and OS/2 are compatible with
like-named routines in the C library for XENIX. For additional
compatibility, the math library functions have been extended to provide
exception handling in the same manner as the UNIX System V math functions.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00000006 @%%@AB@%Expanded Graphics Library%@AE@%%@EH@%%@NL@%
%@NL@%
The Microsoft C run-time library now contains over one hundred graphics
routines. The core of this library consists of several dozen low-level
graphics routines, which allow your programs to select video modes, set
points, draw lines, change colors, and draw shapes such as rectangles and
ellipses. You can display real-valued data, such as floating-point values,
within windows of different sizes by using various coordinate systems.  %@NL@%
%@NL@%
Recent additions to the graphics library include presentation graphics and
fonts. The presentation-graphics library provides powerful tools for adding
presentation-quality graphics to your programs. These routines can display
data as a variety of graphs, including pie charts, bar and column charts,
line graphs, and scatter diagrams.  %@NL@%
%@NL@%
The fonts library allows your programs to display various styles and sizes
of text in graphics images or charts. You can use font-manipulation routines
with any graphics routines that display text, including presentation
graphics.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00000007 @%%@AB@%About This Book%@AE@%%@EH@%%@NL@%
%@NL@%
This book assumes that you understand the C language and know how to compile
and link programs. If you have questions about these subjects, consult your
compiler documentation.  %@NL@%
%@NL@%
This book has two parts. Part 1, "Overview," introduces the Microsoft C
library. It describes general rules for using the library and summarizes the
main categories of library routines. Part 1 contains the following chapters:
%@NL@%
%@NL@%
%@NL@%
  ş   Chapter 1, "Using C Library Routines," gives general rules for
      understanding and using C library routines and mentions special
      considerations that apply to certain routines. It is recommended that
      you read this chapter before using the run-time library; you may also
      want to turn to Chapter 1 when you have questions about library
      procedures.%@NL@%
%@NL@%
  ş   Chapter 2, "Run-Time Routines by Category," lists the C library
      routines by category and discusses considerations that apply to each
      category. This chapter makes it easy to locate routines by task. Once
      you find the routine you want, turn to the reference page in Part 2
      for a detailed description.%@NL@%
%@NL@%
  ş   Chapter 3, "Global Variables and Standard Types," describes variables
      and types that are used by library routines. Global variables and
      standard types are also described in the reference descriptions of the
      routines that use them.%@NL@%
%@NL@%
%@NL@%
Part 2, "Run-Time Functions," describes the library routines in alphabetical
order. Once you are familiar with the C library rules and procedures, you
will probably use this part most often.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00000008 @%%@AB@%Other Books of Interest%@AE@%%@EH@%%@NL@%
%@NL@%
This book provides a guide to the C run-time library provided with the
Microsoft C Professional Development System version 6.0.  %@NL@%
%@NL@%
The following books cover a variety of topics that you may find useful. They
are listed only for your convenience. With the exception of its own
publications, Microsoft does not endorse these books or recommend them over
others on the same subject.  %@NL@%
%@NL@%
%@NL@%
  ş   Barkakati, Nabajyoti. %@AI@%The Waite Group's Microsoft C Bible%@AE@%.
      Indianapolis, IN: Howard W. Sams, 1988.%@NL@%
%@NL@%
%@STUB@%      A topical guide to the Microsoft C run-time library. A similar volume
      is available for the Microsoft QuickC(R) product.%@NL@%
%@NL@%
  ş   Campbell, Joe. %@AI@%C Programmer's Guide to Serial Communications%@AE@%.
      Indianapolis, IN: Howard W. Sams & Company, 1987.%@NL@%
%@NL@%
%@STUB@%      A comprehensive guide to the specialized area of serial communication
      programming in C.%@NL@%
%@NL@%
  ş   Hansen, Augie. %@AI@%Proficient C: The Microsoft Guide to Intermediate &
%@AI@%      Advanced C Programming%@AE@%. Redmond, WA: Microsoft Press, 1987.%@NL@%
%@NL@%
%@STUB@%      An intermediate-level guide to C programming.%@NL@%
%@NL@%
  ş   Harbison, Samuel P., and Guy L. Steele, Jr. %@AI@%C: A Reference Manual%@AE@%, 2d
      ed. Englewood Cliffs, NJ: Prentice Hall, 1987.%@NL@%
%@NL@%
%@STUB@%      A comprehensive guide to the C language and the standard library.%@NL@%
%@NL@%
  ş   Kernighan, Brian W., and Dennis M. Ritchie. %@AI@%The C Programming
%@AI@%      Language%@AE@%, 2d ed. Englewood Cliffs, NJ: Prentice Hall, 1988.%@NL@%
%@NL@%
%@STUB@%      The first edition of this book is the classic definition of the C
      language. The second edition includes new information on the proposed
      ANSI C standard.%@NL@%
%@NL@%
  ş   Lafore, Robert. %@AI@%Microsoft C Programming for the IBM%@AE@%. Indianapolis, IN:
      Howard W. Sams & Company, 1987.%@NL@%
%@NL@%
%@STUB@%      The first half of this book teaches C. The second half concentrates on
      specifics of the PC environment, such as BIOS calls, memory, and video
      displays.%@NL@%
%@NL@%
  ş   Mark Williams Company. %@AI@%ANSI C: A Lexical Guide%@AE@%. Englewood Cliffs, NJ:
      Prentice Hall, 1988.%@NL@%
%@NL@%
%@STUB@%      A dictionary-style guide to the ANSI C standard.%@NL@%
%@NL@%
  ş   Plauger, P. J., and Jim Brodie. %@AI@%Standard C%@AE@%. Redmond, WA: Microsoft
      Press, 1989.%@NL@%
%@NL@%
%@STUB@%      A quick reference guide to the ANSI C implementation by the secretary
      and chairman of the ANSI-authorized C Programming Language Standards
      Committee.%@NL@%
%@NL@%
  ş   Plum, Thomas. %@AI@%Reliable Data Structures in C%@AE@%. Cardiff, NJ: Plum Hall,
      1985.%@NL@%
%@NL@%
%@STUB@%      An intermediate-level look at data structures using the C language.%@NL@%
%@NL@%
  ş   Plum, Thomas, and Jim Brodie. %@AI@%Efficient C%@AE@%. Cardiff, NJ: Plum Hall,
      1985.%@NL@%
%@NL@%
%@STUB@%      A guide to techniques for increasing the efficiency of C programs.%@NL@%
%@NL@%
  ş   Press, William H., Brian P. Flannery, Saul A. Teukolsky, and William
      T. Vetterling. %@AI@%Numerical Recipes in C: The Art of Scientific
%@AI@%      Computing%@AE@%. New York: Cambridge University Press, 1988.%@NL@%
%@NL@%
%@STUB@%      A comprehensive look at numerical techniques using the C language.%@NL@%
%@NL@%
  ş   Schustack, Steve. %@AI@%Variations in C: Programming Techniques for
%@AI@%      Developing Efficient Professional Applications%@AE@%. Redmond, WA: Microsoft
      Press, 1985.%@NL@%
%@NL@%
%@STUB@%      An intermediate-level guide to developing business applications in C.%@NL@%
%@NL@%
  ş   Ward, Robert. %@AI@%Debugging C%@AE@%. Indianapolis, IN: Que Corporation, 1986.%@NL@%
%@NL@%
%@STUB@%      An advanced guide to the theory and practice of debugging C programs.%@NL@%
%@NL@%
  ş   Wilton, Richard. %@AI@%Programmer's Guide to PC and PS/2 Video
%@AI@%      Systems:Maximum Video Performance from the EGA, VGA, HGC, & MCGA%@AE@%.
      Redmond, WA: Microsoft Press, 1987.%@NL@%
%@NL@%
%@STUB@%      An advanced guide to all the PC and PS/2 video modes.%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00000009 @%%@AB@%Document Conventions%@AE@%%@EH@%%@NL@%
%@NL@%
This book uses the following document conventions :%@CR:C6A00000010 @%  %@NL@%
%@NL@%
%@AB@%Example%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
STDIO.H                           Uppercase letters indicate file names, 
                                  segment names, registers, and terms used
                                  at the operating-system command level. %@CR:C6A00000011 @%

%@AB@%_far%@AE@%                              Boldface letters indicate C keywords, 
                                  operators, language-specific characters,
                                  and library routines. Within discussions
                                  of syntax, bold type indicates that the 
                                  text must be entered exactly as shown. %@CR:C6A00000012 @%

%@AI@%expression%@AE@%                        Words in italics indicate placeholders 
                                  for information you must supply, such as
                                  a file name. Italics are also 
                                  occasionally used for emphasis in the 
                                  text. %@CR:C6A00000013 @%

[[%@AI@%option%@AE@%]]                        Items inside double square brackets are 
                                  optional. %@CR:C6A00000014 @%%@CR:C6A00000015 @%

%@AB@%#pragma pack%@AE@% {%@AB@%1%@AE@%|%@AB@%2%@AE@%}                Braces and a vertical bar indicate a 
                                  choice among two or more items. You must
                                  choose one of these items unless double 
                                  square brackets surround the braces.

%@AS@%#include <io.h>%@AE@%                   This font is used for examples, user 
                                  input, program output, and error 
                                  messages in text. %@CR:C6A00000016 @%

%@AB@%CL%@AE@% %@AI@%options%@AE@% [[%@AI@%files%@AE@%...]]           Three dots following an item indicate 
                                  that more items having the same form may
                                  appear. %@CR:C6A00000017 @%

%@AS@%while()%@AE@%                           A column of three dots tells you that 
%@AS@%{%@AE@%                                 part of the example program has been 
%@AS@%   .%@AE@%                              intentionally omitted. %@CR:C6A00000018 @%
%@AS@%   .%@AE@%                              
%@AS@%   .%@AE@%                              
%@AS@%}%@AE@%                                 

CTRL+ENTER                        Small capital letters are used for the 
                                  names of keys on the keyboard. When you 
                                  see a plus sign (+) between two key 
                                  names, you should hold down the first 
                                  key while pressing the second. %@CR:C6A00000019 @%

                                  The carriage-return key, sometimes 
                                  marked as a bent arrow on the keyboard, 
                                  is called ENTER.

"argument"                        Quotation marks enclose a new term the 
                                  first time it is defined in text. %@CR:C6A00000020 @%

%@AS@%"C string"%@AE@%                        Some C constructs, such as strings, 
                                  require quotation marks. Quotation marks
                                  required by the language have the form %@AS@%"%@AE@%
                                  %@AS@%"%@AE@% and %@AS@%' '%@AE@% rather than " " and ' '.

Color Graphics Adapter (CGA)      The first time an acronym is used, it is
                                  often spelled out.

%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@CR:C6A-Part 01 @%%@1@%%@AB@%PART I  Overview%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
The first part of this book provides an overview of the run-time library
provided with the Microsoft C Professional Development System.  %@NL@%
%@NL@%
Chapter 1 is a general guide to the use of the run-time library routines.  %@NL@%
%@NL@%
Chapter 2 lists the routines by category.  %@NL@%
%@NL@%
Chapter 3 tells how to access global variables and types defined in the
run-time library.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@CR:C6A00010001 @%%@1@%%@AB@%Chapter 1  Using C Library Routines%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
This chapter provides basic information about how to use Microsoft C library
routines. It also describes some special rules, such as file- and path-name
conventions, that apply to particular routines. You should read this chapter
before you begin to use C library routines, and you may also want to refer
back to it if you have questions about library procedures.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00010002 @%%@AB@%1.1  Calling Library Routines%@AE@%%@EH@%%@NL@%
%@NL@%
To use a C library routine, simply call it in your program, just as if it is
defined there. For instance, suppose you write the following program and
name it SAMPLE.C:  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>
%@AS@%  main()
%@AS@%  {
%@AS@%     printf( "Microsoft C" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
The program prints %@AS@% Microsoft C %@AE@% by calling the %@AB@%printf%@AE@% routine, which is
part of the standard C library. Calling a library routine normally involves
two groups of files:  %@NL@%
%@NL@%
%@NL@%
  1.  Header ("include") files that contain declarations and type
      definitions required by library routines %@NL@%
%@NL@%
  2.  Library files that contain the library routines in compiled form%@NL@%
%@NL@%
%@NL@%
Header files and library files are both included with Microsoft C. Header
files are used when compiling, and library files are used when linking.  %@NL@%
%@NL@%
You include the necessary header files in your program source code with
%@AB@%#include%@AE@% directives. The description of each library routine in Part 2,
"Reference," tells you what header file the routine requires. Since %@AB@%printf%@AE@%
requires the STDIO.H header file, the SAMPLE.C program contains the
following line:  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
This line causes the compiler to insert the contents of STDIO.H into the
source file SAMPLE.C.  %@NL@%
%@NL@%
After you compile the source file, you link the resulting object (.OBJ) file
with the appropriate library (.LIB) file to create an executable (.EXE)
file. Your object file contains the name of every routine that your program
calls, including library routines. If a routine is not defined in your
program, the linker searches for its code in a library file and includes
that code in the executable file.  %@NL@%
%@NL@%
Normally, the code for standard library routines is contained in the
"default library" that you create when installing Microsoft C. Since the
linker automatically searches the default library, you do not need to
specify that library's name when linking your program. The following command
links the example program with the default library:  %@NL@%
%@NL@%
%@AS@%  link sample,,,;%@AE@%%@NL@%
%@NL@%
If you call a library routine that is not contained in the default library,
you must give the linker the name of the library file that contains the
routine. For instance, suppose your program uses a Microsoft C graphics
routine and you did not make GRAPHICS.LIB part of your default library when
installing Microsoft C. You would then link the program using a line like
the following:  %@NL@%
%@NL@%
%@AS@%  link sample,,, graphics.lib;%@AE@%%@NL@%
%@NL@%
For more information about libraries and linking, consult the installation
documentation for your compiler.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00010003 @%%@AB@%1.2  Using Header Files%@AE@%%@EH@%%@NL@%
%@NL@%
As stated in the previous section, you should include C header files when
using library routines. This section describes particular reasons why header
files are required.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00010004 @%%@AB@%1.2.1  Including Necessary Definitions%@AE@%%@EH@%%@NL@%
%@NL@%
Many C library routines use constants, type definitions, or macros defined
in a header file. To use the routine, you must include the header file
containing the needed definition(s). The following list gives examples:  %@NL@%
%@NL@%
%@AB@%Definition%@AE@%                        %@AB@%Example%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
Macro                             If a library routine is implemented as a
                                  macro, the macro definition appears in a
                                  header file. For instance, the %@AB@%toupper%@AE@% 
                                  macro is defined in the header file 
                                  CTYPE.H.

Manifest constant                 Many library routines refer to constants
                                  that are defined in header files. For 
                                  instance, the %@AB@%open%@AE@% routine uses 
                                  constants such as %@AB@%O_CREAT%@AE@%, which is 
                                  defined in the header file FCNTL.H.

Type definition                   Some library routines return a structure
                                  or take a structure as an argument. For 
                                  example, stream input/output routines 
                                  use a structure of type %@AB@%FILE%@AE@%, which is 
                                  defined in STDIO.H.

%@NL@%
%@3@%%@CR:C6A00010005 @%%@AB@%1.2.2  Including Function Declarations%@AE@%%@EH@%%@NL@%
%@NL@%
The Microsoft C header files also contain function declarations for every
function in the C library. These declarations are in the style recommended
by the ANSI C standard. Given these declarations, the compiler can perform
"type checking" on every reference to a library function, making sure that
you have used the correct return type and arguments. Function declarations
are sometimes called "prototypes," since the declaration serves as a
prototype or template for every subsequent reference to the function.  %@NL@%
%@NL@%
A function declaration lists the name of the function, its return type, and
the number and type of its arguments. For instance, below is the declaration
of the %@AB@%pow%@AE@% library function from the header file MATH.H:  %@NL@%
%@NL@%
%@AS@%  double pow( double x, double y );%@AE@%%@NL@%
%@NL@%
The example declares that %@AB@%pow%@AE@% returns a value of type %@AB@%double%@AE@% and takes two
arguments of type %@AB@%double%@AE@%. Given this declaration, the compiler can check
every reference to %@AB@%pow%@AE@% in your program to ensure that the reference passes
two %@AB@%double%@AE@% arguments to %@AB@%pow%@AE@% and takes a return value of type %@AB@%double%@AE@%.  %@NL@%
%@NL@%
The compiler can perform type checking only for function references that
appear after the function declaration. Because of this, function
declarations normally appear near the beginning of the source file, prior to
any use of the functions they declare.  %@NL@%
%@NL@%
Function declarations are especially important for functions that return a
value of some type other than %@AB@%int%@AE@%, which is the default. For example, the
%@AB@%pow%@AE@% function returns a %@AB@%double%@AE@% value. If you do not declare such a function,
the compiler treats its return value as %@AB@%int%@AE@%, which can cause unexpected
results.  %@NL@%
%@NL@%
It is also a good practice to provide declarations for functions that you
write. If you do not want to type the declarations by hand, you can generate
them automatically by using the /Zg compiler option. This option causes the
compiler to generate ANSI-standard function declarations for every function
defined in the current source file. Redirect this output to a file, then
insert the file near the beginning of your source file.  %@NL@%
%@NL@%
Your program can contain more than one declaration of the same function, as
long as the declarations do not conflict. This is important if you have old
programs whose function declarations do not contain argument-type lists. For
instance, if your program contains the declaration  %@NL@%
%@NL@%
%@AS@%  char *calloc( );%@AE@%%@NL@%
%@NL@%
you can later include the following declaration:  %@NL@%
%@NL@%
%@AS@%  char *calloc(unsigned, unsigned);%@AE@%%@NL@%
%@NL@%
Because the two declarations are compatible, even though they are not
identical, no conflict occurs. The second declaration simply gives more
information about function arguments than the second. A conflict would
arise, however, if the declarations gave a different number of arguments or
gave arguments of different types.  %@NL@%
%@NL@%
Some library functions can take a variable number of arguments. For
instance, the %@AB@%printf %@AE@%function can take one argument or several. The compiler
can perform only limited type checking on such functions, a factor that
affects the following library functions:  %@NL@%
%@NL@%
%@NL@%
  ş   In calls to %@AB@%cprintf%@AE@%, %@AB@%cscanf%@AE@%, %@AB@%printf%@AE@%, and %@AB@%scanf%@AE@%, only the first
      argument (the format string) is type checked. %@NL@%
%@NL@%
  ş   In calls to %@AB@%fprintf%@AE@%, %@AB@%fscanf%@AE@%, %@AB@%sprintf%@AE@%, and %@AB@%sscanf%@AE@%, only the first two
      arguments (the file or buffer and the format string) are type checked.%@NL@%
%@NL@%
  ş   In calls to %@AB@%open%@AE@%, only the first two arguments (the path name and the
      %@AB@%open%@AE@% flag) are type checked. %@NL@%
%@NL@%
  ş   In calls to %@AB@%sopen%@AE@%, only the first three arguments (the path name, the
      %@AB@%open%@AE@% flag, and the sharing mode) are type checked. %@NL@%
%@NL@%
  ş   In calls to %@AB@%execl%@AE@%, %@AB@%execle%@AE@%, %@AB@%execlp%@AE@%, and %@AB@%execlpe%@AE@%, only the first two
      arguments (the path name and the first argument pointer) are type
      checked.%@NL@%
%@NL@%
  ş   In calls to %@AB@%spawnl%@AE@%, %@AB@%spawnle%@AE@%, %@AB@%spawnlp%@AE@%, and %@AB@%spawnlpe%@AE@%, only the first
      three arguments (the mode flag, the path name, and the first argument
      pointer) are type checked.%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00010006 @%%@AB@%1.3  File Names and Path Names%@AE@%%@EH@%%@NL@%
%@NL@%
Many library routines take strings representing paths and file names as
arguments. If you plan to transport your programs to the XENIX operating
system, you should remember that XENIX uses file- and path-name conventions
that are different from those used by DOS and OS/2. If you do not plan to
transport your programs to XENIX, you can skip this section.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Case Sensitivity%@AE@%%@EH@%%@NL@%
%@NL@%
The DOS and OS/2 operating systems are not case sensitive (they do not
distinguish between uppercase and lowercase letters). Thus, SAMPLE.C and
Sample.C refer to the same file in DOS and OS/2. However, the XENIX
operating system is case sensitive. In XENIX, SAMPLE.C and Sample.C refer to
different files. To transport programs to XENIX, choose file and path names
that work correctly in XENIX, since either case works in DOS and OS/2. For
instance, the following directives are identical in DOS and OS/2, but only
the second works in XENIX:  %@NL@%
%@NL@%
%@AS@%  #include <STDIO.H>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Subdirectory Conventions%@AE@%%@EH@%%@NL@%
%@NL@%
Under XENIX, certain header files are normally placed in a subdirectory
named SYS. Microsoft C follows this convention to ease the process of
transporting programs to XENIX. If you do not plan to transport your
programs, you can place the SYS header files elsewhere.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Path-Name Delimiters%@AE@%%@EH@%%@NL@%
%@NL@%
XENIX uses the slash (%@AB@%/%@AE@%) in path names, while DOS and OS/2 use the backslash
(%@AB@%\%@AE@%). To transport programs to XENIX, it is advantageous to use path-name
delimiters that are compatible with XENIX whenever possible.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00010007 @%%@AB@%1.4  Choosing Between Functions and Macros%@AE@%%@EH@%%@NL@%
%@NL@%
This book uses the words "routine" and "function" interchangeably. However,
the term "routine" actually encompasses both functions and macros. Because
functions and macros have different properties, you should pay attention to
which form you are using. The descriptions in the reference section indicate
whether routines are implemented as functions or as macros.  %@NL@%
%@NL@%
Most routines in the Microsoft C library are functions. They consist of
compiled C code or assembled Microsoft Macro Assembler (MASM) code. However,
a few library routines are implemented as macros that behave like functions.
You can pass arguments to library macros and invoke them in the same way you
invoke functions.  %@NL@%
%@NL@%
The main benefit of using macros is faster execution time. A macro is
expanded (replaced by its definition) during preprocessing, creating in-line
code. Thus, macros do not have the overhead associated with function calls.
On the other hand, each use of a macro inserts the same code in your
program, whereas a function definition occurs only once regardless of how
many times it is called. Functions and macros thus offer a trade-off between
speed and size.  %@NL@%
%@NL@%
Apart from speed and size issues, macros and functions have some other
important differences:  %@NL@%
%@NL@%
%@NL@%
  ş   Some macros treat arguments with side effects incorrectly when the
      macro evaluates its arguments more than once (see the example that
      follows this list). Not every macro has this effect. To determine if a
      macro handles side effects as desired, examine its definition in the
      appropriate header file.%@NL@%
%@NL@%
  ş   A function name evaluates to an address, but a macro name does not.
      Thus, you cannot use a macro name in contexts requiring a function
      pointer. For instance, you can declare a pointer to a function, but
      you cannot declare a pointer to a macro.%@NL@%
%@NL@%
  ş   You can declare functions, but you cannot declare macros. Thus, the
      compiler cannot perform type checking of macro arguments as it does of
      function arguments. However, the compiler can detect when you pass the
      wrong number of arguments to a macro.%@NL@%
%@NL@%
  ş   You must always include the appropriate header file when using a
      library macro. Every library macro is defined with a %@AB@%#define%@AE@% directive
      in a header file. If you do not include the header file, the macro is
      undefined.%@NL@%
%@NL@%
%@NL@%
The following example demonstrates how some macros can produce unwanted side
effects. It uses the %@AB@%toupper%@AE@% routine from the standard C library.  %@NL@%
%@NL@%
%@AS@%  #include <ctype.h>
%@AS@%  
%@AS@%  int a = 'm';
%@AS@%  a = toupper(a++);%@AE@%%@NL@%
%@NL@%
The example increments %@AS@% a %@AE@% when passing it as an argument to the %@AB@%toupper%@AE@%
routine, which is implemented as a macro. It is defined in CTYPE.H:  %@NL@%
%@NL@%
%@AS@%  #define toupper(c)  ( (islower(c)) ? _toupper(c) : (c) )%@AE@%%@NL@%
%@NL@%
The definition uses the conditional operator (%@AB@%? :%@AE@%). The conditional
expression evaluates the argument %@AS@% c %@AE@% twice: once to check if it is
lowercase and again to create the result. This macro evaluates the argument %@AS@%
%@AS@%a++ %@AE@% twice, increasing %@AS@% a %@AE@% by 2 instead of 1. As a result, the value
operated on by %@AB@%islower%@AE@% differs from the value operated on by %@AB@%_toupper%@AE@%.  %@NL@%
%@NL@%
Like some other library routines, %@AB@%toupper%@AE@% is provided in both macro and
function versions. The header file CTYPE.H not only declares the %@AB@%toupper%@AE@%
function but also defines the %@AB@%toupper%@AE@% macro.  %@NL@%
%@NL@%
Choosing between the macro version and function version of such routines is
easy. If you wish to use the macro version, you can simply include the
header file that contains the macro definition. Because the macro definition
of the routine always appears after the function declaration, the macro
definition normally takes precedence. Thus, if your program includes CTYPE.H
and then calls %@AB@%toupper%@AE@%, the compiler uses the %@AB@%toupper%@AE@% macro:  %@NL@%
%@NL@%
%@AS@%  #include <ctype.h>
%@AS@%  
%@AS@%  int a = 'm';
%@AS@%  a = toupper(a);%@AE@%%@NL@%
%@NL@%
You can force the compiler to use the function version of a routine by
enclosing the routine's name in parentheses:  %@NL@%
%@NL@%
%@AS@%  #include <ctype.h>
%@AS@%  
%@AS@%  int a = 'm';
%@AS@%  a = (toupper) (a);%@AE@%%@NL@%
%@NL@%
Because the name %@AB@%toupper%@AE@% is not immediately followed by a left parenthesis,
the compiler cannot interpret it as a macro name. It must use the %@AB@%toupper%@AE@%
function.  %@NL@%
%@NL@%
A second way to do this is to "undefine" the macro definition with the
%@AB@%#undef%@AE@% directive:  %@NL@%
%@NL@%
%@AS@%  #include <ctype.h>
%@AS@%  #undef toupper%@AE@%%@NL@%
%@NL@%
Since the macro definition no longer exists, subsequent references to
%@AB@%toupper%@AE@% use the function version.  %@NL@%
%@NL@%
A third way to make sure the compiler uses the function version is to
declare the function explicitly:  %@NL@%
%@NL@%
%@AS@%  #include <ctype.h>
%@AS@%  int toupper(int _c);%@AE@%%@NL@%
%@NL@%
Since this function declaration appears after the macro definition in
CTYPE.H, it causes the compiler to use the %@AB@%toupper%@AE@% function.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00010008 @%%@AB@%1.5  Stack Checking on Entry%@AE@%%@EH@%%@NL@%
%@NL@%
For certain library routines, the compiler performs stack checking on entry.
(The "stack" is a memory area used for temporary storage.) Upon entry to
such a routine, the stack is checked to determine if it has enough room for
the local variables used by that routine. If it does, space is allocated by
adjusting the stack pointer. Otherwise, a "stack overflow" run-time error
occurs. If stack checking is disabled, the compiler assumes there is enough
stack space; if there is not, you might overwrite memory locations in the
data segment and receive no warning.  %@NL@%
%@NL@%
Typically, stack checking is enabled only for functions with large
local-variable requirements (more than about 150 bytes), since there is
enough free space between the stack and data segments to handle functions
with smaller requirements. If the function is called many times, stack
checking slows execution slightly.  %@NL@%
%@NL@%
Stack checking is enabled for the following library functions:  %@NL@%
%@NL@%
%@AB@%execvp          printf          spawnvpe        system%@AE@%
%@AB@%execvpe         scanf           sprintf         vprintf%@AE@%
%@AB@%fprintf         spawnvp         sscanf          write %@AE@%
%@AB@%fscanf          

%@2@%%@CR:C6A00010009 @%%@AB@%1.6  Handling Errors%@AE@%%@EH@%%@NL@%
%@NL@%
Many library routines return a value that indicates an error condition. To
avoid unexpected results, your code should always check such error values
and handle all of the possible error conditions. The description of each
library routine in the reference section lists the routine's return
value(s).  %@NL@%
%@NL@%
Some library functions do not have a set error return. These include
functions that return nothing and functions whose range of return values
makes it impossible to return a unique error value. To aid in error
handling, some functions in this category set the value of a global variable
named %@AB@%errno%@AE@%.  %@NL@%
%@NL@%
If the reference description of a routine states that it sets the %@AB@%errno%@AE@%
variable, you can use %@AB@%errno%@AE@% in two ways:  %@NL@%
%@NL@%
%@NL@%
  1.  Compare %@AB@%errno%@AE@% to the values defined in the header file ERRNO.H.%@NL@%
%@NL@%
  2.  Handle %@AB@%errno%@AE@% with the %@AB@%perror%@AE@% or %@AB@%strerror%@AE@% library routines. The %@AB@%perror%@AE@%
      routine prints a system error message to the standard error (%@AB@%stderr%@AE@%).
      The %@AB@%strerror%@AE@% routine stores the same information in a string for later
      use.%@NL@%
%@NL@%
%@NL@%
When you use %@AB@%errno%@AE@%, %@AB@%perror%@AE@%, and %@AB@%strerror%@AE@%, remember that the value of %@AB@%errno%@AE@%
reflects the error value for the last call that set %@AB@%errno%@AE@%. To avoid
confusion, you should always test the return value to verify that an error
actually occurred. Once you determine that an error has occurred, use %@AB@%errno%@AE@%
or %@AB@%perror%@AE@% immediately. Otherwise, the value of %@AB@%errno%@AE@% may be changed by
intervening calls.  %@NL@%
%@NL@%
Library math routines set %@AB@%errno%@AE@% by calling the %@AB@%matherr%@AE@% or %@AB@%_matherrl%@AE@% library
routines, which are described in the reference section. If you wish to
handle math errors differently from these routines, you can write your own
routine and name it %@AB@%matherr%@AE@% or %@AB@%_matherrl%@AE@%. Your routine must follow the rules
listed in the %@AB@%matherr%@AE@% reference description.  %@NL@%
%@NL@%
The %@AB@%ferror%@AE@% library routine allows you to check for errors in stream
input/output operations. This routine checks if an error indicator has been
set for a given stream. Closing or rewinding the stream automatically clears
the error indicator. You can also reset the error indicator by calling the
%@AB@%clearerr%@AE@% library routine.  %@NL@%
%@NL@%
The %@AB@%feof%@AE@% library routine tests for end-of-file on a given stream. An
end-of-file condition in low-level input and output can be detected with the
%@AB@%eof%@AE@% routine or when a %@AB@%read%@AE@% operation returns 0 as the number of bytes read.
%@NL@%
%@NL@%
The %@AB@%_grstatus%@AE@% library routine allows you to check for errors after calling
certain graphics library operations. See the reference page on the %@AB@%_grstatus%@AE@%
function for details.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00010010 @%%@AB@%1.7  Operating-System Considerations%@AE@%%@EH@%%@NL@%
%@NL@%
The library routines listed in this section behave differently under
different operating system versions. For more information on an individual
routine, see the description of that routine in the reference section.  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Restrictions%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%locking%@AE@%                           These routines are effective only in 
%@AB@%sopen%@AE@%                             OS/2 and in DOS versions 3.0 and later.
%@AB@%_fsopen%@AE@%                           

%@AB@%dosexterr%@AE@%                         The %@AB@%dosexterr%@AE@% routine provides error 
                                  handling for system call 0x59 (get 
                                  extended error) in DOS versions 3.0 and 
                                  later.

%@AB@%dup%@AE@%                               The %@AB@%dup%@AE@% and %@AB@%dup2%@AE@% routines can cause 
%@AB@%dup2%@AE@%                              unexpected results in DOS versions 
                                  earlier than 3.0. If you use %@AB@%dup%@AE@% or %@AB@%dup2%@AE@%
                                  to create a duplicate file handle for %@AB@%%@AE@%
                                  %@AB@%stdin%@AE@%, %@AB@%stdout%@AE@%, %@AB@%stderr%@AE@%, %@AB@%stdaux%@AE@%, or %@AB@%stdprn%@AE@%
                                  , calling the %@AB@%close%@AE@% function with one 
                                  handle causes errors in later I/O 
                                  operations that use the other handle. 
                                  This anomaly does not occur in OS/2 or 
                                  in DOS versions 3.0 and later.

%@AB@%exec%@AE@%                              When using the %@AB@%exec%@AE@% and %@AB@%spawn%@AE@% families 
%@AB@%spawn%@AE@%                             of functions under DOS versions earlier 
                                  than 3.0, the value of the %@AI@%arg0%@AE@% argument
                                  (or %@AI@%argv%@AE@%[0] to the child process) is not
                                  available to the user; a null string (%@AS@%""%@AE@%
                                  ) is stored in that position instead. In
                                  OS/2, the %@AI@%arg0%@AE@% argument contains the 
                                  command name; in DOS versions 3.0 and 
                                  later, it contains the complete command 
                                  path.

Microsoft C defines global variables that indicate the version of the
current operating system. You can use these to determine the
operating-system version in which a program is executing. See Chapter 3,
"Global Variables and Standard Types," for more information.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00010011 @%%@AB@%1.8  Floating-Point Support%@AE@%%@EH@%%@NL@%
%@NL@%
Microsoft math library routines require floating-point support to perform
calculations with real numbers (numbers that can contain fractions). This
support can be provided by the floating-point libraries that accompany your
compiler software or by an 8087, 80287, or 80387 coprocessor. The names of
the functions that require floating-point support are listed below:  %@NL@%
%@NL@%
%@AB@%acos            cos             fmod            modfl%@AE@%
%@AB@%acosl           cosl            fmodl           pow%@AE@%
%@AB@%asin            cosh            fmsbintoieee    powl%@AE@%
%@AB@%asinl           coshl           _fpreset        sin%@AE@%
%@AB@%atan            dieeetomsbin    frexp           sinl%@AE@%
%@AB@%atanl           difftime        frexpl          sinh%@AE@%
%@AB@%atan2           dmsbintoieee    gcvt            sinhl%@AE@%
%@AB@%atan2l          ecvt            hypot           sqrt%@AE@%
%@AB@%atof            exp             hypotl          sqrtl%@AE@%
%@AB@%_atold          expl            ldexp           _status87%@AE@%
%@AB@%bessel          fabs            ldexpl          strtod%@AE@%
%@AB@%cabs            fabsl           log             _strtold%@AE@%
%@AB@%cabsl           fcvt            logl            tan%@AE@%
%@AB@%ceil            fieeetomsbin    log10           tanl%@AE@%
%@AB@%ceill           floor           log10l          tanh%@AE@%
%@AB@%_clear87        floorl          modf            tanhl%@AE@%
%@AB@%_control87      

Note that the %@AB@%bessel%@AE@% routine does not correspond to a single function, but
to twelve functions named %@AB@%j0%@AE@%, %@AB@%j1%@AE@%, %@AB@%jn%@AE@%, %@AB@%y0%@AE@%, %@AB@%y1%@AE@%, %@AB@%yn%@AE@%, %@AB@%_j0l%@AE@%, %@AB@%_j1l%@AE@%, %@AB@%_jnl%@AE@%, %@AB@%_y0l%@AE@%,
%@AB@%_y1l%@AE@%, and %@AB@%_ynl%@AE@%. Also note that the %@AB@%_clear87%@AE@% and %@AB@%_control87%@AE@% functions are not
available with the /FPa compiler option.  %@NL@%
%@NL@%
Also requiring floating-point support is the %@AB@%printf%@AE@% family of functions
(%@AB@%cprintf%@AE@%, %@AB@%fprintf%@AE@%, %@AB@%printf%@AE@%, %@AB@%sprintf%@AE@%, %@AB@%vfprintf%@AE@%, %@AB@%vprintf%@AE@%, and %@AB@%vsprintf%@AE@%). These
functions require support for floating-point input and output if used to
print floating-point values.  %@NL@%
%@NL@%
The C compiler tries to detect whether floating-point values are used in a
program so that supporting functions are loaded only if required. This
behavior saves a considerable amount of space for programs that do not
require floating-point support.  %@NL@%
%@NL@%
When you use a floating-point type specifier in the format string for a
%@AB@%printf%@AE@% or %@AB@%scanf%@AE@% call, make sure you specify floating-point values or
pointers to floating-point values in the argument list. These must
correspond to any floating-point  %@NL@%
%@NL@%
type specifiers in the format string. The presence of floating-point
arguments allows the compiler to detect that floating-point support code is
required. If a floating-point type specifier is used to print an integer
argument, for example, floating-point values will not be detected because
the compiler does not actually read the format string used in the %@AB@%printf%@AE@% and
%@AB@%scanf%@AE@% functions. For instance, the following program produces an error at
run time:  %@NL@%
%@NL@%
%@AS@%  main( ) /* This example causes an error */
%@AS@%   {
%@AS@%    long f = 10L;
%@AS@%    printf("%f", f);
%@AS@%   }%@AE@%%@NL@%
%@NL@%
In the preceding example, the functions for floating-point support are not
loaded because  %@NL@%
%@NL@%
%@NL@%
  ş   No floating-point arguments are given in the call to %@AB@%printf%@AE@%.%@NL@%
%@NL@%
  ş   No floating-point values are used elsewhere in the program.%@NL@%
%@NL@%
%@NL@%
As a result, the following error occurs:  %@NL@%
%@NL@%
%@AS@%  Floating point not loaded%@AE@%%@NL@%
%@NL@%
Here is a corrected version of the above call to %@AB@%printf%@AE@% in which the long
integer value is cast to %@AB@%double%@AE@%:  %@NL@%
%@NL@%
%@AS@%  main( ) /* This example works correctly */
%@AS@%   {
%@AS@%    long f = 10L;
%@AS@%    printf("%f", (double) f);
%@AS@%   }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00010012 @%%@AB@%1.9  Using Huge Arrays with Library Functions%@AE@%%@EH@%%@NL@%
%@NL@%
In programs that use small, compact, medium, and large memory models,
Microsoft C allows you to use arrays exceeding the 64K (kilobyte) limit of
physical memory in these models by explicitly declaring the arrays as %@AB@%_huge%@AE@%.
However, generally, you cannot pass %@AB@%_huge%@AE@% data items as arguments to C
library functions. In the compact-model library used by compact-model
programs and in the large-model library used by both large-model and
huge-model programs, only the functions listed below use argument arithmetic
that works with %@AB@%_huge%@AE@% items:  %@NL@%
%@NL@%
%@AB@%bsearch         _fmemcmp        _fmemset        lsearch%@AE@%
%@AB@%fread           _fmemcpy        halloc          memccpy%@AE@%
%@AB@%fwrite          _fmemicmp       hfree           memchr%@AE@%
%@AB@%_fmemccpy       _fmemmove       lfind           %@AE@%
%@AB@%_fmemchr        

With this set of functions, you can read from, write to, search, sort, copy,
initialize, compare, or dynamically allocate and free %@AB@%_huge%@AE@% arrays; the
%@AB@%_huge%@AE@% array can be passed without difficulty to any of these functions in a
compact-, large-, or huge-model program. The model-independent routines in
the above list (those beginning with %@AB@%_f%@AE@%) are available in all memory models.
%@NL@%
%@NL@%
The %@AB@%memset%@AE@%, %@AB@%memcpy%@AE@%, and %@AB@%memcmp%@AE@%library routines are available in two
versions: as C functions and as intrinsic (in-line) code. The function
versions of these routines support huge pointers in compact and large memory
models, but the intrinsic versions do not support huge pointers. (The
function version of such routines generates a call to a library function,
whereas the intrinsic version inserts in-line code into your program. Your
compiler documentation explains how to select the intrinsic versions of
library routines.) %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@CR:C6A00020001 @%%@1@%%@AB@%Chapter 2  Run-Time Routines by Category%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
Microsoft C library routines handle various kinds of tasks. If you know the
type of task you need done, but don't know exactly which routine to use, the
categorized lists of routines in this chapter can help.  %@NL@%
%@NL@%
The descriptions here are intended only to give you a brief overview of the
capabilities of the run-time library. For a complete description of the
behavior, syntax, and use of each routine, see Part 2, "Run-Time Functions."
%@NL@%
%@NL@%
The main categories of library routines are  %@NL@%
%@NL@%
%@NL@%
  ş   Buffer manipulation%@NL@%
%@NL@%
  ş   Character classification and conversion%@NL@%
%@NL@%
  ş   Data conversion%@NL@%
%@NL@%
  ş   Directory control%@NL@%
%@NL@%
  ş   File handling%@NL@%
%@NL@%
  ş   Graphics%@NL@%
%@NL@%
  ş   Input and output%@NL@%
%@NL@%
  ş   Internationalization%@NL@%
%@NL@%
  ş   Math%@NL@%
%@NL@%
  ş   Memory allocation%@NL@%
%@NL@%
  ş   Process and environment control%@NL@%
%@NL@%
  ş   Searching and sorting%@NL@%
%@NL@%
  ş   String manipulation%@NL@%
%@NL@%
  ş   System calls%@NL@%
%@NL@%
  ş   Time%@NL@%
%@NL@%
  ş   Variable-length argument lists%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00020002 @%%@AB@%2.1  Buffer Manipulation%@AE@%%@EH@%%@NL@%
%@NL@%
The buffer-manipulation routines are useful for working with areas of memory
on a character-by-character basis. A "buffer" is an array of characters,
similar to a character string. However, unlike strings, buffers are not
usually terminated with a null character (%@AB@%'\0'%@AE@%). Therefore, the
buffer-manipulation routines always take a %@AI@%length%@AE@% or %@AI@%count%@AE@% argument.
Function declarations for the buffermanipulation routines are given in the
include files MEMORY.H and STRING.H, with an exception being the %@AB@%swab%@AE@%
function, which appears in STDLIB.H.%@CR:C6A00020003 @%%@CR:C6A00020004 @%  %@NL@%
%@NL@%
Routines beginning with %@AB@%_f%@AE@%  are model independent; the %@AB@%_f%@AE@%  stands for %@AB@%far%@AE@%.
These routines are useful in writing mixed-model programs because they can
be called from any program, regardless of the memory model being used.%@CR:C6A00020005 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%memccpy%@AE@%,  %@AB@%_fmemccpy%@AE@%               Copy characters from one buffer to 
                                  another until a given character or a 
                                  given number of characters has been 
                                  copied %@CR:C6A00020006 @% %@CR:C6A00020007 @%

%@AB@%memchr%@AE@%,  %@AB@%_fmemchr%@AE@%                 Return a pointer to the first 
                                  occurrence, within a specified number of
                                  characters, of a given character in the 
                                  buffer %@CR:C6A00020008 @% %@CR:C6A00020009 @%

%@AB@%memcmp%@AE@%,  %@AB@%_fmemcmp%@AE@%                 Compare a specified number of characters
                                  from two buffers %@CR:C6A00020010 @% %@CR:C6A00020011 @%

%@AB@%memcpy%@AE@%,  %@AB@%_fmemcpy%@AE@%                 Copy a specified number of characters 
                                  from one buffer to another %@CR:C6A00020012 @% %@CR:C6A00020013 @%

%@AB@%memicmp%@AE@%, %@AB@%_fmemicmp%@AE@%                Compare a specified number of characters
                                  from two buffers without regard to the 
                                  case of the letters (uppercase and 
                                  lowercase treated as equivalent) %@CR:C6A00020014 @% %@CR:C6A00020015 @%

%@AB@%memmove%@AE@%,%@AB@%%@AE@%                          Copy a specified number of characters 
%@AB@%_fmemmove%@AE@%                         from one buffer to another %@CR:C6A00020016 @% %@CR:C6A00020017 @%

%@AB@%memset%@AE@%,  %@AB@%_fmemset%@AE@%                 Use a given character to initialize a 
                                  specified number of bytes in the buffer %@CR:C6A00020018 @%
                                  %@CR:C6A00020019 @%

%@AB@%swab%@AE@%                              Swaps bytes of data and stores them at 
                                  the specified location

When the source and target areas overlap, only the %@AB@%memmove%@AE@% and %@AB@%_fmemmove%@AE@%
functions are guaranteed to copy the full source properly. (The %@AB@%memcpy%@AE@% and
%@AB@%_fmemcpy%@AE@% routines do not always copy the full source in such cases.)  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00020020 @%%@AB@%2.2  Character Classification and Conversion%@AE@%%@EH@%%@NL@%
%@NL@%
The character classification and conversion routines allow you to test
individual characters in a variety of ways and to convert between uppercase
and lowercase characters.  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%isalnum%@AE@%%@CR:C6A00020021 @%%@CR:C6A00020022 @%                           Tests for alphanumeric character

%@AB@%isalpha%@AE@%                           Tests for alphabetic character

%@AB@%isascii%@AE@%                           Tests for ASCII character

%@AB@%iscntrl%@AE@%                           Tests for control character

%@AB@%isdigit%@AE@%                           Tests for decimal digit

%@AB@%isgraph%@AE@%                           Tests for printable character except 
                                  space

%@AB@%islower%@AE@%%@CR:C6A00020023 @%%@CR:C6A00020024 @%                           Tests for lowercase character

%@AB@%isprint%@AE@%%@CR:C6A00020025 @%%@CR:C6A00020026 @%                           Tests for printable character

%@AB@%ispunct%@AE@%%@CR:C6A00020027 @%%@CR:C6A00020028 @%                           Tests for punctuation character

%@AB@%isspace%@AE@%%@CR:C6A00020029 @%%@CR:C6A00020030 @%                           Tests for white-space character

%@AB@%isupper%@AE@%%@CR:C6A00020031 @%                           Tests for uppercase character

%@AB@%isxdigit%@AE@%%@CR:C6A00020032 @%                          Tests for hexadecimal digit

%@AB@%toascii%@AE@% %@CR:C6A00020033 @%%@CR:C6A00020034 @%                          Converts character to ASCII code

%@AB@%tolower%@AE@%%@CR:C6A00020035 @%                           Tests character and converts to 
                                  lowercase if uppercase%@CR:C6A00020036 @%%@CR:C6A00020037 @% %@CR:C6A00020038 @%

%@AB@%_tolower%@AE@%                          Converts character to lowercase 
                                  (unconditional)

%@AB@%toupper%@AE@%                           Tests character and converts to 
                                  uppercase if
                                  lowercase

%@AB@%_toupper%@AE@%                          Converts character to uppercase 
                                  (unconditional)

The classification routines identify characters by finding them in a table
of classification codes. Using these routines to classify characters is
generally faster than writing a test expression such as the following:  %@NL@%
%@NL@%
%@AS@%  if ((c >= 0) || c <= 0x7f))%@AE@%%@NL@%
%@NL@%
All of these routines are implemented in two versions: as functions and as
macros. The function prototypes and macro definitions appear in CTYPE.H.
Section 1.4, "Choosing Between Functions and Macros," explains how to choose
the appropriate version. The %@AB@%toupper%@AE@% and %@AB@%tolower%@AE@% functions are also declared
in the STDLIB.H header file.%@CR:C6A00020039 @%%@CR:C6A00020040 @%%@CR:C6A00020041 @%  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00020042 @%%@AB@%2.3  Data Conversion%@CR:C6A00020043 @% %@CR:C6A00020044 @%%@CR:C6A00020045 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The data-conversion routines convert numbers to strings of ASCII characters
and vice versa. These routines are implemented as functions, all of which
are declared in the include file STDLIB.H. The %@AB@%atof%@AE@% function, which converts
a string to a floating-point value, is also declared in MATH.H.  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%abs%@AE@%                               Finds absolute value of integer

%@AB@%atof%@AE@%%@CR:C6A00020046 @%%@CR:C6A00020047 @%                              Converts string to %@AB@%float%@AE@%

%@AB@%atoi%@AE@%%@CR:C6A00020048 @%                              Converts string to %@AB@%int%@AE@%

%@AB@%atol%@AE@%                              Converts string to %@AB@%long%@AE@%

%@AB@%_atold%@AE@%                            Converts string to %@AB@%long double%@AE@%

%@AB@%ecvt%@AE@%%@CR:C6A00020049 @%%@CR:C6A00020050 @%                              Converts %@AB@%double%@AE@% to string

%@AB@%fcvt%@AE@%%@CR:C6A00020051 @%%@CR:C6A00020052 @%                              Converts %@AB@%double%@AE@% to string

%@AB@%gcvt%@AE@%%@CR:C6A00020053 @%%@CR:C6A00020054 @%                              Converts %@AB@%double%@AE@% to string

%@AB@%itoa%@AE@%%@CR:C6A00020055 @%%@CR:C6A00020056 @%                              Converts %@AB@%int%@AE@% to string

%@AB@%labs%@AE@%                              Finds absolute value of %@AB@%long%@AE@% integer

%@AB@%ltoa%@AE@%%@CR:C6A00020057 @%%@CR:C6A00020058 @%                              Converts %@AB@%long%@AE@% to string

%@AB@%strtod%@AE@%%@CR:C6A00020059 @%                            Converts string to %@AB@%double%@AE@%

%@AB@%strtol%@AE@%%@CR:C6A00020060 @%%@CR:C6A00020061 @%                            Converts string to a %@AB@%long%@AE@% integer

%@AB@%_strtold%@AE@%                          Converts string to %@AB@%long double%@AE@%

%@AB@%strtoul%@AE@%%@CR:C6A00020062 @%                           Converts string to an %@AB@%unsigned long%@AE@% 
                                  integer

%@AB@%ultoa%@AE@%%@CR:C6A00020063 @%%@CR:C6A00020064 @%                             Converts %@AB@%unsigned long%@AE@% to string

%@NL@%
%@2@%%@CR:C6A00020065 @%%@AB@%2.4  Directory Control%@CR:C6A00020066 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The directory-control routines let a program access, modify, and obtain
information about the directory structure. These routines are functions and
are declared in DIRECT.H.%@CR:C6A00020067 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%chdir%@AE@%%@CR:C6A00020068 @%%@CR:C6A00020069 @%%@CR:C6A00020070 @%                             Changes current working directory

%@AB@%_chdrive%@AE@%                          Changes current drive

%@AB@%getcwd%@AE@%%@CR:C6A00020071 @%%@CR:C6A00020072 @%                            Gets current working directory

%@AB@%_getdcwd%@AE@%                          Gets current working directory for the 
                                  specified drive

%@AB@%_getdrive%@AE@%                         Gets the current disk drive

%@AB@%mkdir%@AE@%%@CR:C6A00020073 @%%@CR:C6A00020074 @%                             Makes a new directory

%@AB@%rmdir%@AE@%%@CR:C6A00020075 @%%@CR:C6A00020076 @%                             Removes a directory

%@AB@%_searchenv%@AE@%                        Searches for a given file on specified 
                                  paths

%@NL@%
%@2@%%@CR:C6A00020077 @%%@AB@%2.5  File Handling%@AE@%%@EH@%%@NL@%
%@NL@%
The file-handling routines let you create, manipulate, and delete files.
They also set and check file-access permissions.  %@NL@%
%@NL@%
File-handling routines work on a file designated by a path name or by a
"file handle," an integer assigned by the operating system that identifies
an open file. These routines modify or give information about the designated
file. Most of them are declared in the include file IO.H, with the
exceptions being the %@AB@%fstat%@AE@% and %@AB@%stat%@AE@% functions (declared in SYS\STAT.H), the
%@AB@%_fullpath%@AE@% routine (declared in DIRECT.H), and the %@AB@%remove%@AE@% and %@AB@%rename%@AE@%
functions (also declared in STDIO.H).%@CR:C6A00020078 @%%@CR:C6A00020079 @%%@CR:C6A00020080 @%%@CR:C6A00020081 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%access%@AE@%%@CR:C6A00020082 @%                            Checks file-permission setting

%@AB@%chmod%@AE@%%@CR:C6A00020083 @%%@CR:C6A00020084 @%                             Changes file-permission setting

%@AB@%chsize%@AE@% %@CR:C6A00020085 @%%@CR:C6A00020086 @%                           Changes file size

%@AB@%filelength%@AE@%%@CR:C6A00020087 @%%@CR:C6A00020088 @%                        Gets file length

%@AB@%fstat%@AE@%%@CR:C6A00020089 @%%@CR:C6A00020090 @%                             Gets file-status information on handle

%@AB@%_fullpath%@AE@%                         Makes an absolute path name from a 
                                  relative path name

%@AB@%isatty%@AE@% %@CR:C6A00020091 @%%@CR:C6A00020092 @%                           Checks for character device

%@AB@%locking%@AE@%%@CR:C6A00020093 @%%@CR:C6A00020094 @%                           Locks areas of file (available with OS/2
                                  and
                                  DOS versions 3.0 and later)

%@AB@%_makepath%@AE@%                         Merges path-name components into a 
                                  single, full path name

%@AB@%mktemp%@AE@%%@CR:C6A00020095 @%%@CR:C6A00020096 @%                            Creates unique file name

%@AB@%remove%@AE@%%@CR:C6A00020097 @%%@CR:C6A00020098 @%                            Deletes file

%@AB@%rename%@AE@%%@CR:C6A00020099 @%%@CR:C6A00020100 @%                            Renames file

%@AB@%setmode%@AE@%%@CR:C6A00020101 @%%@CR:C6A00020102 @%                           Sets file-translation mode

%@AB@%_splitpath%@AE@%                        Splits a path name into component pieces

%@AB@%stat%@AE@%%@CR:C6A00020103 @%%@CR:C6A00020104 @%                              Gets file-status information on named 
                                  file

%@AB@%umask%@AE@%%@CR:C6A00020105 @%%@CR:C6A00020106 @%                             Sets default-permission mask

%@AB@%unlink%@AE@%%@CR:C6A00020107 @%%@CR:C6A00020108 @%                            Deletes file

The %@AB@%access%@AE@%, %@AB@%chmod%@AE@%, %@AB@%_fullpath%@AE@%, %@AB@%_makepath%@AE@%, %@AB@%remove%@AE@%, %@AB@%rename%@AE@%, %@AB@%_splitpath%@AE@%, %@AB@%stat%@AE@%,
and %@AB@%unlink%@AE@% routines operate on files specified by a path name or file name.%@CR:C6A00020109 @%
%@NL@%
%@NL@%
The %@AB@%chsize%@AE@%, %@AB@%filelength%@AE@%, %@AB@%fstat%@AE@%,%@AB@% isatty%@AE@%, %@AB@%locking%@AE@%, and %@AB@%setmode%@AE@% routines work
with files designated by a file handle.  %@NL@%
%@NL@%
The %@AB@%mktemp%@AE@% and %@AB@%umask%@AE@% routines have functions that are slightly different
from the other routines. The %@AB@%mktemp%@AE@% routine creates a unique file name, and
the programmer can use %@AB@%mktemp%@AE@% to create unique file names that do not
conflict with the names of existing files. The %@AB@%umask%@AE@% routine sets the
default permission mask for any new files created in a program. The mask can
override the permission setting given in the %@AB@%open%@AE@% or %@AB@%creat%@AE@% call for the new
file.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00020110 @%%@AB@%2.6  Graphics%@AE@%%@EH@%%@NL@%
%@NL@%
Microsoft C graphics routines offer a wide variety of graphics functions,
low-level graphics primitives, font functions, and presentation graphics
(displays such as graphs and pie charts).  %@NL@%
%@NL@%
Graphics functions are supplied in two libraries that must be explicitly
linked with your program. The GRAPHICS.LIB library provides support for
low-level graphics and character-font routines. The library PGCHART.LIB
supports presentation-graphics routines.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00020111 @%%@AB@%2.6.1  Low-Level Graphics and Character-Font Functions%@AE@%%@EH@%%@NL@%
%@NL@%
The low-level graphics and font functions are declared in the include file
GRAPH.H.  %@NL@%
%@NL@%
The library can be divided into the eight categories listed below, which
correspond to the different tasks involved in creating and manipulating
graphic objects.  %@NL@%
%@NL@%
Most graphics routines work only in DOS. Two categories of routines
("configuring mode and environment" and "creating text output") work in OS/2
as well as DOS.  %@NL@%
%@NL@%
%@AB@%Category%@AE@%                          %@AB@%Task%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
Configuring mode and environment  Select the proper display mode for the 
(OS/2 and DOS)                    hardware and establish memory areas for 
                                  writing and displaying of images

Setting coordinates               Specify the logical origin and the 
                                  active display area within the screen

Setting low-level graphics        Specify a palette mapping for low-level 
palettes                          graphics routines

Setting attributes                Specify background and foreground 
                                  colors, fill masks, and line styles for 
                                  low-level graphics routines

Creating graphics                 Draw and fill figures
output                            

Creating text output (OS/2 and    Write text on the screen
DOS)                              

Transferring images               Store images in memory and retrieve them

Displaying fonts                  Display text in character fonts 
                                  compatible with Microsoft Windows(tm) %@CR:C6A00020112 @%

The following sections explain each of these categories.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.6.1.1  Configuring Mode and Environment%@CR:C6A00020113 @% %@CR:C6A00020114 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Routines that configure the mode and environment establish the graphics or
text mode of operation, determine the current graphics environment, and
control the display of the cursor.%@CR:C6A00020115 @%%@CR:C6A00020116 @%%@CR:C6A00020117 @%%@CR:C6A00020118 @%  %@NL@%
%@NL@%
All of the routines listed in this section are available in OS/2 as well as
DOS.%@CR:C6A00020119 @%%@CR:C6A00020120 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_clearscreen%@AE@%                      Erases the screen and fills it with the 
                                  current background color

%@AB@%_getactivepage%@AE@%                    Gets the current active page number

%@AB@%_getbkcolor%@AE@%                       Returns the current background color

%@AB@%_getvideoconfig%@AE@%                   Obtains status of current graphics 
                                  environment

%@AB@%_getvisualpage%@AE@%                    Gets the current visual page number

%@AB@%_grstatus%@AE@%                         Returns the status of the most recent 
                                  graphics function call

%@AB@%_setactivepage%@AE@%                    Sets memory area for the active page for
                                  writing
                                  images

%@AB@%_setbkcolor%@AE@%                       Sets the current background color

%@AB@%_settextrows%@AE@%                      Sets the number of text rows

%@AB@%_setvideomode%@AE@%                     Selects an operating mode for the 
                                  display screen

%@AB@%_setvideomoderows%@AE@%                 Sets the video mode and the number of 
                                  rows for text operations

%@AB@%_setvisualpage%@AE@%                    Sets memory area for the current visual 
                                  page

%@NL@%
%@4@%%@AB@%2.6.1.2  Setting Coordinates%@CR:C6A00020121 @%%@CR:C6A00020122 @%%@CR:C6A00020123 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The "set coordinates" routines set the current text or graphics position and
convert pixel coordinates between the various graphic coordinate systems.%@CR:C6A00020124 @%%@CR:C6A00020125 @%%@CR:C6A00020126 @%%@CR:C6A00020127 @%%@CR:C6A00020128 @%  %@NL@%
%@NL@%
The Microsoft C graphics functions recognize three sets of coordinates:%@CR:C6A00020129 @%%@CR:C6A00020130 @%%@CR:C6A00020131 @%%@CR:C6A00020132 @%%@CR:C6A00020133 @%  %@NL@%
%@NL@%
%@NL@%
  1.  Fixed physical coordinates%@NL@%
%@NL@%
  2.  View coordinates defined by the application%@NL@%
%@NL@%
  3.  Window coordinates that can include floating-point values%@NL@%
%@NL@%
%@NL@%
The functions in this category establish window and view coordinate systems
and translate between physical, view, and window coordinate systems.  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_getcurrentposition%@AE@%               Determines current position in view 
                                  coordinates

%@AB@%_getcurrentposition_w%@AE@%             Determines current position in window 
                                  coordinates

%@AB@%_getphyscoord%@AE@%                     Converts view coordinates to physical 
                                  coordinates

%@AB@%_getviewcoord%@AE@%                     Converts physical coordinates to view 
                                  coordinates

%@AB@%_getviewcoord_w%@AE@%                   Converts window coordinates to view 
                                  coordinates

%@AB@%_getviewcoord_wxy%@AE@%                 Converts window coordinates in %@AB@%_wxycoord%@AE@%
                                  structure to view coordinates

%@AB@%_getwindowcoord%@AE@%                   Converts view coordinates to window 
                                  coordinates

%@AB@%_setcliprgn%@AE@%                       Limits graphic output to a region of the
                                  screen

%@AB@%_setvieworg%@AE@%                       Positions the view-coordinate origin

%@AB@%_setviewport%@AE@%                      Limits graphics output to a region of 
                                  the screen and positions the 
                                  view-coordinate origin to the upper-left
                                  corner of that region

%@AB@%_setwindow%@AE@%                        Defines a floating-point window 
                                  coordinate system

The default view coordinate system is identical to the physical screen
coordinate system. The physical origin (0, 0) is always in the upper-left
corner of the display. The %@AI@%x%@AE@% axis extends in the positive direction left to
right, while the %@AI@%y%@AE@% axis extends in the positive direction top to bottom.  %@NL@%
%@NL@%
The physical horizontal and vertical dimensions depend on the hardware
display configuration and the selected mode. These values are accessible at
run time by examining the %@AB@%numxpixels%@AE@% and %@AB@%numypixels%@AE@% fields of the
%@AB@%videoconfig%@AE@% structure returned by %@AB@%_getvideoconfig%@AE@%. (The %@AB@%_getvideoconfig%@AE@%
routine is listed in the previous section.)  %@NL@%
%@NL@%
The %@AB@%_setvieworg%@AE@% function allows you to move the viewport origin to a new
position relative to the physical screen.  %@NL@%
%@NL@%
Routines that refer to coordinates on the physical screen or viewport
require integer values. However, in real-world graphing applications, you
might wish to use floating-point values, such as stock prices or average
rainfall. The window coordinate system allows you to display graphics using
floating-point values instead of integers.  %@NL@%
%@NL@%
The %@AB@%_getcurrentposition%@AE@% and %@AB@%_getcurrentposition_w%@AE@% routines allow you to
determine the location of the current graphics-output point.  %@NL@%
%@NL@%
The %@AB@%_setcliprgn%@AE@% function defines a restricted active display area on the
screen. The %@AB@%_setviewport%@AE@% function does the same thing and also resets the
viewport origin to the upper-left corner of the restricted active display
area.  %@NL@%
%@NL@%
The physical coordinates of any view-coordinate point can be determined with
the %@AB@%_getphyscoord%@AE@% function, and the view coordinates of any physical point
can be determined with the %@AB@%_getviewcoord%@AE@% function.  %@NL@%
%@NL@%
The view coordinates of any window coordinate can be determined with the
%@AB@%_getviewcoord_w%@AE@% and %@AB@%_getviewcoord_wxy%@AE@% functions. The window coordinates of
any view coordinate can be determined with the %@AB@%_getwindowcoord%@AE@% function.  %@NL@%
%@NL@%
The %@AB@%_setwindow%@AE@% function defines the current viewport as a real-coordinate
window bound by the specified floating-point values.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.6.1.3  Setting Low-Level Graphics Palettes%@CR:C6A00020134 @%%@CR:C6A00020135 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Use the low-level palette routines to select or remap color palettes.%@CR:C6A00020136 @%%@CR:C6A00020137 @%%@CR:C6A00020138 @%%@CR:C6A00020139 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_remapallpalette%@AE@%%@CR:C6A00020140 @%                  Changes all color indexes in the current
                                  palette

%@AB@%_remappalette%@AE@%                     Changes a single color index in the 
                                  current palette

%@AB@%_selectpalette%@AE@%                    Selects a predefined palette

Some video modes support a "color palette," which is a table of the color
values that can be displayed together on the screen at any given time. A
"color value" is a %@AB@%long%@AE@% integer representing a color that can be displayed
on your system.  %@NL@%
%@NL@%
In CGA color graphics modes, you can use the %@AB@%_selectpalette%@AE@% routine to
choose one of several predefined palettes.  %@NL@%
%@NL@%
On EGA and VGA video systems, you can "remap" (change) the palette using the
%@AB@%_remappalette%@AE@% or %@AB@%_remapallpalette%@AE@% routines. For instance, the EGA %@AB@%_ERESCOLOR%@AE@%
mode offers a total of 64 color values, of which 16 can be displayed at a
time. In this mode, the palette contains 16 "color indices," or slots to
which you can assign color values.  %@NL@%
%@NL@%
The %@AB@%_remappalette%@AE@% routine changes a single color index to a specified color
value. The %@AB@%_remapallpalette%@AE@% routine changes all of the available palette
entries simultaneously.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.6.1.4  Setting Attributes%@CR:C6A00020141 @%%@CR:C6A00020142 @% %@CR:C6A00020143 @%%@CR:C6A00020144 @%%@CR:C6A00020145 @% %@CR:C6A00020146 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The low-level output functions that draw lines, arcs, ellipses, and other
basic figures do not specify color or line-style information. Instead, the
low-level graphics functions rely on a set of attributes that are set
independently by the following functions:%@CR:C6A00020147 @%%@CR:C6A00020148 @%%@CR:C6A00020149 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_getarcinfo%@AE@%%@CR:C6A00020150 @%%@CR:C6A00020151 @%%@CR:C6A00020152 @%%@CR:C6A00020153 @%                       Determines the endpoints in viewport 
                                  coordinates of the most recently drawn 
                                  arc or pie

%@AB@%_getcolor%@AE@%                         Gets the current color

%@AB@%_getfillmask%@AE@%                      Gets the current fill mask

%@AB@%_getlinestyle%@AE@%                     Gets the current line-style mask

%@AB@%_getwritemode%@AE@%                     Gets the current logical write mode

%@AB@%_setcolor%@AE@%                         Sets the current color

%@AB@%_setfillmask%@AE@%                      Sets the current fill mask

%@AB@%_setlinestyle%@AE@%                     Sets the current line-style mask

%@AB@%_setwritemode%@AE@%                     Sets logical write mode for line drawing

The %@AB@%_getcolor%@AE@% and %@AB@%_setcolor%@AE@% functions get or set the current color index for
graphics and font output. The %@AB@%_getbkcolor%@AE@% and %@AB@%_setbkcolor%@AE@% functions get or
set the current background color.  %@NL@%
%@NL@%
The %@AB@%_getfillmask%@AE@% and %@AB@%_setfillmask%@AE@% functions get or set the current fill
mask. The mask is an 8-by-8-bit template array, with each bit representing a
pixel. If a bit is 0, the pixel in memory is left untouched, as the mask is
transparent to that pixel. If a bit is 1, the pixel is assigned the current
color value. The template is repeated as necessary over the entire fill
area.  %@NL@%
%@NL@%
The %@AB@%_getlinestyle%@AE@% and %@AB@%_setlinestyle%@AE@% functions get or set the current line
style. The line style is determined by a 16-bit template buffer with each
bit corresponding to a pixel. If a bit is 1, the pixel is set to the current
color. If a bit is 0, the pixel is not changed. The template is repeated for
the length of the line.  %@NL@%
%@NL@%
The %@AB@%_getwritemode%@AE@% and %@AB@%_setwritemode%@AE@% functions get or set the logical write
mode for straight line drawing. The default mode, %@AB@%_GPSET%@AE@%, causes lines to be
drawn in the current graphics color. Other modes combine the current
graphics color and the original screen image using various logical
operations.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.6.1.5  Creating Graphics Output%@AE@%%@EH@%%@NL@%
%@NL@%
The graphics output functions use a set of specified coordinates and draw
various figures. They use the current or default attributes for line-style
mask, fill mask, write mode, background color, and foreground color.%@CR:C6A00020154 @%%@CR:C6A00020155 @%  %@NL@%
%@NL@%
The name of each function announces its task or the figure it draws, as the
following list indicates:%@CR:C6A00020156 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_arc%@AE@%,  %@AB@%_arc_w%@AE@%,  %@AB@%_arc_wxy%@AE@%%@CR:C6A00020157 @%%@CR:C6A00020158 @%          Draw an arc

%@AB@%_ellipse%@AE@%,  %@AB@%_ellipse_w%@AE@%,%@AB@%%@AE@%            Draw an ellipse or circle
%@AB@%_ellipse_wxy%@AE@%                      

%@AB@%_floodfill%@AE@%,  %@AB@%_floodfill_w%@AE@%%@CR:C6A00020159 @%         Flood-fill an area of the screen with 
                                  the current color

%@AB@%_getcurrentposition%@AE@%, %@AB@%%@AE@%             Obtain the current graphic-output 
%@AB@%_getcurrentposition_w%@AE@%%@CR:C6A00020160 @%             position used by %@AB@%_lineto%@AE@% and %@AB@%_outgtext%@AE@%

%@AB@%_getpixel%@AE@%, %@AB@%_getpixel_w%@AE@%%@CR:C6A00020161 @%            Obtain a pixel's color

%@AB@%_lineto%@AE@%,  %@AB@%_lineto_w%@AE@%%@CR:C6A00020162 @% %@CR:C6A00020163 @%%@CR:C6A00020164 @%              Draw a line from the current graphic 
                                  output position to a specified point

%@AB@%_moveto%@AE@%,  %@AB@%_moveto_w%@AE@%%@CR:C6A00020165 @% %@CR:C6A00020166 @%              Move the current graphic-output position
                                  to a specified point

%@AB@%_pie%@AE@%,  %@AB@%_pie_w%@AE@%,  %@AB@%_pie_wxy%@AE@%%@CR:C6A00020167 @%%@CR:C6A00020168 @%          Draw a pie-slice-shaped figure

%@AB@%_polygon%@AE@%,  %@AB@%_polygon_w%@AE@%, %@AB@%%@AE@%           Draw or scan-fill a polygon
%@AB@%_polygon_wxy%@AE@%                      

%@AB@%_rectangle%@AE@%,  %@AB@%_rectangle_w%@AE@%, %@AB@%%@AE@%       Draw or scan-fill a rectangle
%@AB@%_rectangle_wxy%@AE@%%@CR:C6A00020169 @%%@CR:C6A00020170 @%                    

%@AB@%_setpixel%@AE@%,  %@AB@%_setpixel_w%@AE@%%@CR:C6A00020171 @%           Set a pixel's color

Most of these routines are available in several forms, which are indicated
by their names. Output functions without a suffix use the view coordinate
system. Functions that end with %@AB@%_w%@AE@% take %@AB@%double%@AE@% values as arguments and use
the window coordinate system. Functions that end with %@AB@%_wxy%@AE@% use %@AB@%_wxycoord%@AE@%
structures to define the coordinates and use the window coordinate system.  %@NL@%
%@NL@%
Circular figures, such as arcs and ellipses, are centered within a "bounding
rectangle" specified by two points that define the diagonally opposed
corners of the rectangle. The center of the rectangle becomes the center of
the figure, and the rectangle's borders determine the size of the figure.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.6.1.6  Creating Text Output%@AE@%%@EH@%%@NL@%
%@NL@%
The next group of routines provides text output in both graphics and text
modes. Unlike the standard console I/O library routines, these functions
recognize text-window boundaries and use the current text color.%@CR:C6A00020172 @%%@CR:C6A00020173 @%%@CR:C6A00020174 @%%@CR:C6A00020175 @%%@CR:C6A00020176 @%%@CR:C6A00020177 @%%@CR:C6A00020178 @%%@CR:C6A00020179 @%  %@NL@%
%@NL@%
All of the routines listed in this section work in OS/2 as well as DOS.  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_displaycursor%@AE@%                    Sets the cursor on or off upon exit from
                                  a graphics routine

%@AB@%_gettextcolor%@AE@%                     Obtains the current text color

%@AB@%_gettextcursor%@AE@%                    Returns the current cursor attribute 
                                  (text modes only)

%@AB@%_gettextposition%@AE@%                  Obtains the current text-output position

%@AB@%_gettextwindow%@AE@%                    Gets the current text window boundaries

%@AB@%_outmem%@AE@%                           Prints text of a specified length from a
                                  memory
                                  buffer

%@AB@%_outtext%@AE@%                          Outputs a text string to the screen at 
                                  the current text position

%@AB@%_scrolltextwindow%@AE@%                 Scrolls the current text window up or 
                                  down

%@AB@%_settextcolor%@AE@%                     Sets the current text color

%@AB@%_settextcursor%@AE@%                    Sets the current cursor attribute (text 
                                  modes only)

%@AB@%_settextposition%@AE@%                  Relocates the current text position

%@AB@%_settextwindow%@AE@%                    Defines the current text-display window

%@AB@%_wrapon%@AE@%                           Enables or disables line wrap

The %@AB@%_outtext%@AE@% and %@AB@%_outmem%@AE@% routines provide no formatting. If you want to
output integer or floating-point values, you must convert the values into a
string variable (using the %@AB@%sprintf%@AE@% function) before calling these routines.
%@NL@%
%@NL@%
The %@AB@%_outtext%@AE@% routine recognizes the %@AB@%\n%@AE@% (newline character) and %@AB@%\r%@AE@% (carriage
return) sequences. The %@AB@%_outmem%@AE@% routine treats these sequences as printable
graphics characters.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.6.1.7  Transferring Images%@AE@%%@EH@%%@NL@%
%@NL@%
The functions in this category transfer screen images between memory and the
display, using a buffer allocated by the application, or determine the size
in bytes of the buffer needed to store a given image.%@CR:C6A00020180 @%%@CR:C6A00020181 @%%@CR:C6A00020182 @%  %@NL@%
%@NL@%
The functions that end with %@AB@%_w%@AE@% or %@AB@%_wxy%@AE@% use window coordinates; the other
functions in this set use view coordinates.%@CR:C6A00020183 @%%@CR:C6A00020184 @%%@CR:C6A00020185 @%%@CR:C6A00020186 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_getimage%@AE@%,%@AB@%%@AE@%                        Store a screen image in memory
%@AB@%_getimage_w%@AE@%,%@AB@%%@AE@%                      
%@AB@%_getimage_wxy%@AE@%                     

%@AB@%_imagesize%@AE@%,%@AB@%%@AE@%                       Return the size (in bytes) of the buffer
%@AB@%_imagesize_w%@AE@%,%@AB@%%@AE@%                     needed to store the image
%@AB@%_imagesize_wxy%@AE@%                    

%@AB@%_putimage%@AE@%,%@AB@%%@AE@%                        Retrieve an image from memory and 
%@AB@%_putimage_w%@AE@%                       display it

In some cases, the buffer needed to store an image with the %@AB@%_getimage%@AE@%
functions must be larger than 64K (65,535) bytes. Use the %@AB@%halloc%@AE@% routine to
allocate a buffer larger than 64K.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.6.1.8  Displaying Fonts%@AE@%%@EH@%%@NL@%
%@NL@%
The functions listed in this section control the display of font-based
characters on the screen.%@CR:C6A00020187 @%%@CR:C6A00020188 @%%@CR:C6A00020189 @%%@CR:C6A00020190 @%%@CR:C6A00020191 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_getfontinfo%@AE@%                      Obtains the current font characteristics

%@AB@%_getgtextextent%@AE@%                   Determines the width in pixels of 
                                  specified text in the current font

%@AB@%_getgtextvector%@AE@%                   Gets orientation of font text output

%@AB@%_outgtext%@AE@%                         Outputs text in the current font to the 
                                  screen at the specified pixel position

%@AB@%_registerfonts%@AE@%                    Initializes font library

%@AB@%_setfont%@AE@%                          Finds a single font that matches a 
                                  specified set of characteristics and 
                                  makes this font the current font for use
                                  by the %@AB@%_outgtext%@AE@% function

%@AB@%_setgtextvector%@AE@%                   Sets the current orientation for font 
                                  text output

%@AB@%_unregisterfonts%@AE@%                  Frees memory allocated by %@AB@%_registerfonts%@AE@%

%@NL@%
%@3@%%@CR:C6A00020192 @%%@AB@%2.6.2  Presentation-Graphics Functions%@AE@%%@EH@%%@NL@%
%@NL@%
The presentation-graphics functions are declared in the PGCHART.H include
file. The library can be divided into the three categories listed below,
corresponding to the different tasks involved in creating and manipulating
graphic objects:%@CR:C6A00020193 @%  %@NL@%
%@NL@%
%@AB@%Category%@AE@%                          %@AB@%Task%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
Displaying presentation graphics  Initialize video structures for 
                                  presentation graphics and establishes 
                                  the default chart type. Display
                                  presentation-graphics chart: bar, 
                                  column, pie, scatter, or line chart.

Analyzing                         Analyze data (does not display chart).
presentation-graphics data        

Manipulating                      Modify basic chart structures (e.g., 
presentation-graphics structures  palettes, cross-hatching styles). 

%@NL@%
%@4@%%@AB@%2.6.2.1  Displaying Presentation Graphics%@CR:C6A00020194 @% %@CR:C6A00020195 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The functions listed in this section initialize the presentation-graphics
library and display the specified graph type.%@CR:C6A00020196 @%%@CR:C6A00020197 @%%@CR:C6A00020198 @%%@CR:C6A00020199 @%  %@NL@%
%@NL@%
Because the %@AB@%_pg_initchart%@AE@% routine initializes the presentation-graphics
library, it must be called before any other function in the
presentation-graphics library. The %@AB@%_pg_defaultchart%@AE@% function initializes the
variables in the chart environment.%@CR:C6A00020200 @%%@CR:C6A00020201 @%%@CR:C6A00020202 @%  %@NL@%
%@NL@%
The other routines in this category display the specified graph. The
single-series versions plot one set of data, and the multiseries versions
(those ending with an %@AB@%ms%@AE@% suffix) plot several sets of data in the same chart
style.  %@NL@%
%@NL@%
Presentation-graphics programs can display text in different font sizes by
taking advantage of font-based characters (see Section 2.6.1.8, "Displaying
Fonts.") Call the %@AB@%_registerfonts%@AE@% and %@AB@%_setfont%@AE@% routines to select a font
before calling the %@AB@%_pginitchart%@AE@% routine. Subsequent charts use the selected
font. You can later call the %@AB@%_unregisterfonts%@AE@% routine to restore the default
character font and free the memory previously allocated for fonts.  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_pg_chart%@AE@%                         Displays a single-series bar, column, or
                                  line chart

%@AB@%_pg_chartms%@AE@%                       Displays a multiseries bar, column, or 
                                  line chart

%@AB@%_pg_chartpie%@AE@%                      Displays a pie chart

%@AB@%_pg_chartscatter%@AE@%                  Displays a scatter diagram for a single 
                                  series of data

%@AB@%_pg_chartscatterms%@AE@%                Displays a scatter diagram for more than
                                  one series of data

%@AB@%_pg_defaultchart%@AE@%                  Initializes all necessary variables in 
                                  the chart environment for a specified 
                                  chart type

%@AB@%_pg_initchart%@AE@%                     Initializes the presentation-graphics 
                                  library

%@NL@%
%@4@%%@AB@%2.6.2.2  Analyzing Presentation-Graphics Charts%@CR:C6A00020203 @%%@CR:C6A00020204 @% %@CR:C6A00020205 @%%@AE@%%@EH@%%@NL@%
%@NL@%
These routines calculate default values for the specified graph type but do
not display the chart. The single-series versions analyze one set of data,
and the multiseries versions analyze several sets of data in the same chart
style.%@CR:C6A00020206 @%%@CR:C6A00020207 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_pg_analyzechart%@AE@%%@CR:C6A00020208 @%%@CR:C6A00020209 @%                  Analyzes a single series of data for a 
                                  bar, column, or line chart

%@AB@%_pg_analyzechartms%@AE@%                Analyzes a multiseries of data for a 
                                  bar, column, or line chart

%@AB@%_pg_analyzepie%@AE@%                    Analyzes data for a pie chart

%@AB@%_pg_analyzescatter%@AE@%                Analyzes a single series of data for a 
                                  scatter diagram

%@AB@%_pg_analyzescatterms%@AE@%              Analyzes a multiseries of data for a 
                                  scatter diagram 

%@NL@%
%@4@%%@AB@%2.6.2.3  Manipulating Presentation-Graphics Structures%@AE@%%@EH@%%@NL@%
%@NL@%
These functions control low-level aspects of the presentation-graphics
package.%@CR:C6A00020210 @%%@CR:C6A00020211 @%%@CR:C6A00020212 @%%@CR:C6A00020213 @%%@CR:C6A00020214 @%%@CR:C6A00020215 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_pg_hlabelchart%@AE@%%@CR:C6A00020216 @%%@CR:C6A00020217 @%%@CR:C6A00020218 @%%@CR:C6A00020219 @% %@CR:C6A00020220 @%%@CR:C6A00020221 @%                  Writes text horizontally on the screen%@CR:C6A00020222 @%%@CR:C6A00020223 @%%@CR:C6A00020224 @%%@CR:C6A00020225 @% 

%@AB@%_pg_vlabelchart%@AE@%                   Writes text vertically on the screen

%@AB@%_pg_getpalette%@AE@%                    Retrieves current colors, line styles, 
                                  fill patterns, and plot characters for 
                                  all presentation-graphics palettes

%@AB@%_pg_setpalette%@AE@%                    Sets current colors, line styles, fill 
                                  patterns, and plot characters for all 
                                  presentation-graphics palettes

%@AB@%_pg_resetpalette%@AE@%                  Sets current colors, line styles, fill 
                                  patterns, and plot characters to the 
                                  default values for the current screen 
                                  mode

%@AB@%_pg_getstyleset%@AE@%                   Retrieves the contents of the current 
                                  styleset

%@AB@%_pg_setstyleset%@AE@%                   Sets the contents of the current 
                                  styleset

%@AB@%_pg_resetstyleset%@AE@%                 Resets the contents of the current 
                                  styleset to the default value for the 
                                  current screen mode

%@AB@%_pg_getchardef%@AE@% %@CR:C6A00020226 @%                   Retrieves the current 8-by-8-pixel bit 
                                  map for a specified character

%@AB@%_pg_setchardef%@AE@% %@CR:C6A00020227 @%                   Sets the 8-by-8-pixel bit map for a 
                                  specified
                                  character

%@NL@%
%@2@%%@CR:C6A00020228 @%%@AB@%2.7  Input and Output%@AE@%%@EH@%%@NL@%
%@NL@%
The input and output (I/O) routines of the standard C library allow you to
read and write data to and from files and devices. In C, there are no
predefined file structures; all data items are treated as sequences of
bytes. The following three types of I/O functions are available:  %@NL@%
%@NL@%
%@NL@%
  1.  Stream%@NL@%
%@NL@%
  2.  Low-level%@NL@%
%@NL@%
  3.  Console and port%@NL@%
%@NL@%
%@NL@%
The "stream" I/O functions treat data as a stream of individual characters.
By choosing among the many stream functions available, you can process data
in different sizes and formats, from single characters to large data
structures. Stream I/O also provides buffering, which can significantly
improve performance.%@CR:C6A00020229 @%%@CR:C6A00020230 @%  %@NL@%
%@NL@%
The "low-level" I/O routines do not perform buffering and formatting.
Instead, they invoke the operating system's input and output capabilities
directly. These routines let you access files and peripheral devices at a
more basic level than the stream functions.%@CR:C6A00020231 @%  %@NL@%
%@NL@%
The "console and port" I/O routines allow you to read or write directly to a
console (keyboard and screen) or an I/O port (such as a printer port). The
port I/O routines simply read and write data in bytes. With console I/O
routines, some additional options are available, such as detecting whether a
character has been typed at the console. You can also choose between echoing
characters to the screen as they are read or reading characters without
echoing.%@CR:C6A00020232 @%  %@NL@%
%@NL@%
The C library also provides a number of direct DOS I/O system call routines.
These are described in Section 2.14, "System Calls."  %@NL@%
%@NL@%
File I/O operations can be performed in two modes: text or binary. The
following section describes these modes and their use.  %@NL@%
%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
%@AU@%WARNING%@AE@%%@NL@%
%@NL@%
Because stream routines are buffered and low-level routines are not, the two
types of routines are generally incompatible. You should use either stream
or low-level routines consistently for processing a given file.%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00020233 @%%@AB@%2.7.1  Text and Binary Modes%@AE@%%@EH@%%@NL@%
%@NL@%
Many C programs use data files for input and output. Under DOS and OS/2,
data files are normally processed in text mode. In this mode, each
carriage-return-line-feed (CR-LF) combination is translated into a single
line-feed character during input. During output, each line-feed character is
translated into a CR-LF combination.  %@NL@%
%@NL@%
Sometimes you may want to process a file without making those translations.
In these cases you use binary mode, which suppresses CR-LF translations.%@CR:C6A00020234 @%%@CR:C6A00020235 @%  %@NL@%
%@NL@%
You can control the file translation mode in the following ways:  %@NL@%
%@NL@%
%@NL@%
  ş   To process a few selected files in binary mode, while retaining the
      default text mode for most files, you can specify binary mode when you
      open the selected files. The %@AB@%fopen%@AE@% routine opens a file in binary mode
      when you specify the letter %@AB@%b%@AE@% in the access-mode string for the file.
      The %@AB@%open%@AE@% routine opens a file in binary mode when you specify the
      %@AB@%O_BINARY%@AE@% flag in the %@AI@%oflag%@AE@% argument. For more information about %@AB@%fopen%@AE@%
      and %@AB@%open%@AE@%, see the reference description of each routine.%@NL@%
%@NL@%
  ş   To process most or all files in binary mode, you can change the
      default mode to binary. The global variable %@AB@%_fmode%@AE@% controls the
      default translation mode, which is normally text. If you set %@AB@%_fmode%@AE@% to
      %@AB@%O_BINARY%@AE@%, the default mode is binary except for %@AB@%stdaux%@AE@% and %@AB@%stdprn%@AE@%,
      which are opened in binary mode by default.%@NL@%
%@NL@%
%@NL@%
You can change the value of %@AB@%_fmode%@AE@% in two ways:  %@NL@%
%@NL@%
%@NL@%
  1.  Link with the file BINMODE.OBJ (supplied with Microsoft C). This
      changes the initial setting of %@AB@%_fmode%@AE@% to the %@AB@%O_BINARY %@AE@%flag, causing
      all files except%@AB@% stdin%@AE@%, %@AB@%stdout%@AE@%, and %@AB@%stderr%@AE@% to be opened in binary
      mode.%@NL@%
%@NL@%
  2.  Change the value of %@AB@%_fmode%@AE@% directly by setting it to the %@AB@%O_BINARY%@AE@% flag
      in your program. This has the same effect as linking with BINMODE.OBJ.%@NL@%
%@NL@%
%@NL@%
You can still override the default mode (now binary) for a particular file
by opening it in text mode. Specify the letter %@AB@%t%@AE@% when using %@AB@%fopen%@AE@%, or
specify the %@AB@%O_TEXT%@AE@% flag when using %@AB@%open%@AE@%.  %@NL@%
%@NL@%
By default, the %@AB@%stdin%@AE@%, %@AB@%stdout%@AE@%, and %@AB@%stderr%@AE@% files are opened in text mode, and
the %@AB@%stdaux%@AE@% and %@AB@%stdprn%@AE@% files are opened in binary mode. The %@AB@%setmode%@AE@% routine
allows you to change these defaults or change the mode of a file after it
has been opened. See the reference description of %@AB@%setmode%@AE@% for details.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00020236 @%%@AB@%2.7.2  Stream Routines%@AE@%%@EH@%%@NL@%
%@NL@%
Stream I/O functions handle data as a continuous stream of characters. To
use the stream functions, you must include the file STDIO.H in your program.
This file defines constants, types, and structures used in the stream
functions, and contains function declarations and macro definitions for the
stream  routines.%@CR:C6A00020237 @%%@CR:C6A00020238 @%%@CR:C6A00020239 @%%@CR:C6A00020240 @%%@CR:C6A00020241 @%  %@NL@%
%@NL@%
When a file is opened for I/O using the stream functions, the opened file is
associated with a structure of type %@AB@%FILE%@AE@% (defined in STDIO.H) containing
basic information about the file. A pointer to the %@AB@%FILE%@AE@% structure is
returned when the stream is opened. Subsequent operations use this pointer
(also called the "stream pointer," or just "stream") to refer to the file.%@CR:C6A00020242 @%%@CR:C6A00020243 @%  %@NL@%
%@NL@%
The stream functions provide for buffered, formatted, or unformatted input
and output. When a stream is buffered, data that is read from or written to
the stream is collected in an intermediate storage location called a
"buffer". In write operations, the output buffer's contents are written to
the appropriate final location when the buffer is full, the stream is
closed, or the program terminates normally. The buffer is said to be
"flushed" when this occurs. In read operations, a block of data is placed in
the input buffer read from the buffer; when the input buffer is empty, the
next block of data is transferred into the buffer.%@CR:C6A00020244 @%%@CR:C6A00020245 @%  %@NL@%
%@NL@%
Buffering produces efficient I/O because the system can transfer a large
block of data in a single operation rather than performing an I/O operation
each time a data item is read from or written to a stream. However, if a
program terminates abnormally, output buffers may not be flushed, resulting
in loss of data.  %@NL@%
%@NL@%
Some of the constants defined in STDIO.H may be useful in your program. The
manifest constant %@AB@%EOF%@AE@% is defined to be the value returned at end-of-file.
%@AB@%NULL%@AE@% is the null pointer. %@AB@%FILE%@AE@% is the structure that maintains information
about a stream. %@AB@%BUFSIZ%@AE@% defines the default size of stream buffers, in bytes.%@CR:C6A00020246 @%%@CR:C6A00020247 @%%@CR:C6A00020248 @%%@CR:C6A00020249 @%
%@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%clearerr%@AE@%                          Clears the error indicator for a stream %@CR:C6A00020250 @%

%@AB@%fclose%@AE@%                            Closes a stream %@CR:C6A00020251 @%

%@AB@%fcloseall%@AE@%                         Closes all open streams

%@AB@%fdopen%@AE@%                            Associates a stream with an open file 
                                  handle %@CR:C6A00020252 @%

%@AB@%feof%@AE@%                              Tests for end-of-file on a stream %@CR:C6A00020253 @%

%@AB@%ferror%@AE@%                            Tests for error on a stream %@CR:C6A00020254 @%

%@AB@%fflush%@AE@%                            Flushes a stream %@CR:C6A00020255 @%

%@AB@%fgetc%@AE@%                             Reads a character from a stream 
                                  (function version) %@CR:C6A00020256 @%

%@AB@%fgetchar %@AE@%                         Reads a character from %@AB@%stdin%@AE@% (function 
                                  version)

%@AB@%fgetpos%@AE@%                           Gets the position indicator of a stream %@CR:C6A00020257 @%

%@AB@%fgets%@AE@%                             Reads a string from a stream %@CR:C6A00020258 @%

%@AB@%fileno%@AE@%                            Gets the file handle associated with a 
                                  stream %@CR:C6A00020259 @%

%@AB@%flushall%@AE@%                          Flushes all streams %@CR:C6A00020260 @%

%@AB@%fopen%@AE@%                             Opens a stream %@CR:C6A00020261 @%

%@AB@%fprintf%@AE@%                           Writes formatted data to a stream %@CR:C6A00020262 @%

%@AB@%fputc%@AE@%                             Writes a character to a stream (function
                                  version) %@CR:C6A00020263 @%

%@AB@%fputchar%@AE@%                          Writes a character to %@AB@%stdout%@AE@% (function 
                                  version)

%@AB@%fputs%@AE@%                             Writes a string to a stream %@CR:C6A00020264 @%

%@AB@%fread%@AE@%                             Reads unformatted data from a stream %@CR:C6A00020265 @%

%@AB@%freopen%@AE@%                           Reassigns a %@AB@%FILE%@AE@% pointer to a new file%@CR:C6A00020266 @%

%@AB@%fscanf%@AE@%                            Reads formatted data from a stream %@CR:C6A00020267 @%

%@AB@%fseek%@AE@%                             Moves file position to a given location %@CR:C6A00020268 @%

%@AB@%fsetpos%@AE@%                           Sets the position indicator of a stream %@CR:C6A00020269 @%

%@AB@%_fsopen%@AE@%                           Opens a stream with file sharing %@CR:C6A00020270 @%

%@AB@%ftell%@AE@%                             Gets current file position %@CR:C6A00020271 @%

%@AB@%fwrite%@AE@%                            Writes unformatted data items to a 
                                  stream %@CR:C6A00020272 @%

%@AB@%getc%@AE@%                              Reads a character from a stream %@CR:C6A00020273 @%

%@AB@%getchar%@AE@%                           Reads a character from %@AB@%stdin%@AE@%

%@AB@%gets%@AE@%                              Reads a line from %@AB@%stdin%@AE@% %@CR:C6A00020274 @%

%@AB@%getw%@AE@%                              Reads a binary %@AB@%int%@AE@% item from a stream %@CR:C6A00020275 @%

%@AB@%printf%@AE@%                            Writes formatted data to %@AB@%stdout%@AE@% %@CR:C6A00020276 @%

%@AB@%putc%@AE@%                              Writes a character to a stream

%@AB@%putchar%@AE@%                           Writes a character to %@AB@%stdout%@AE@% %@CR:C6A00020277 @%

%@AB@%puts%@AE@%                              Writes a line to a stream %@CR:C6A00020278 @%

%@AB@%putw%@AE@%                              Writes a binary %@AB@%int%@AE@% item to a stream %@CR:C6A00020279 @%

%@AB@%rewind%@AE@%                            Moves file position to beginning of a 
                                  stream %@CR:C6A00020280 @%

%@AB@%rmtmp%@AE@%                             Removes temporary files created by %@AB@%%@AE@%
                                  %@AB@%tmpfile%@AE@% %@CR:C6A00020281 @%

%@AB@%scanf%@AE@%                             Reads formatted data from %@AB@%stdin%@AE@% %@CR:C6A00020282 @%

%@AB@%setbuf%@AE@%                            Controls stream buffering %@CR:C6A00020283 @%

%@AB@%setvbuf%@AE@%                           Controls stream buffering and buffer 
                                  size %@CR:C6A00020284 @%

%@AB@%sprintf%@AE@%                           Writes formatted data to a string

%@AB@%sscanf%@AE@%                            Reads formatted data from a string %@CR:C6A00020285 @%

%@AB@%tempnam%@AE@%                           Generates a temporary file name in given
                                  directory %@CR:C6A00020286 @%

%@AB@%tmpfile%@AE@%                           Creates a temporary file %@CR:C6A00020287 @%

%@AB@%tmpnam%@AE@%                            Generates a temporary file name

%@AB@%ungetc%@AE@%                            Places a character in the buffer %@CR:C6A00020288 @%

%@AB@%vfprintf%@AE@%                          Writes formatted data to a stream %@CR:C6A00020289 @%

%@AB@%vprintf%@AE@%                           Writes formatted data to %@AB@%stdout%@AE@%

%@AB@%vsprintf%@AE@%                          Writes formatted data to a string

%@NL@%
%@4@%%@AB@%2.7.2.1  Opening a Stream%@AE@%%@EH@%%@NL@%
%@NL@%
A stream must be opened using the %@AB@%fdopen%@AE@%, %@AB@%fopen%@AE@%, %@AB@%freopen%@AE@%, or %@AB@%_fsopen%@AE@%
function before input and output can be performed on that stream. When
opening a stream, the named stream can be opened for reading, writing, or
both, and can be opened in either text or binary mode.%@CR:C6A00020290 @%  %@NL@%
%@NL@%
The %@AB@%fdopen%@AE@%, %@AB@%fopen%@AE@%, %@AB@%freopen%@AE@%, and %@AB@%_fsopen%@AE@% functions return a %@AB@%FILE%@AE@% pointer. You
normally assign the pointer value to a variable and use the variable to
refer to the opened stream. For instance, if your program contains the lines
%@NL@%
%@NL@%
%@AS@%  FILE *infile
%@AS@%  infile = fopen ("test.dat", "r");%@AE@%%@NL@%
%@NL@%
you can use the %@AB@%FILE%@AE@% pointer variable %@AS@% infile %@AE@% to refer to the stream.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.7.2.2  Using Predefined Stream Pointers%@AE@%%@EH@%%@NL@%
%@NL@%
When a program begins execution, the C start-up code automatically opens
several streams: standard input, standard output, and standard error. By
default, the standard input, standard output, and standard error streams are
directed to the console (keyboard and screen). This means that when a
program expects input from the "standard input," it receives that input from
the console. Similarly, a program that writes to the "standard output"
prints its data to the console. Error messages generated by the library
routines are sent to the "standard error," meaning that error messages
appear on the user's console.%@CR:C6A00020291 @%%@CR:C6A00020292 @%%@CR:C6A00020293 @%  %@NL@%
%@NL@%
Under DOS, two additional streams are opened: standard auxiliary and
standard print. (These streams are not available in OS/2.) The assignment of
standard auxiliary and standard print depends on the machine configuration.
These streams usually refer to the first serial port and a printer port, but
those ports may not be available on some systems. Be sure to check your
machine configuration before using these streams.%@CR:C6A00020294 @%%@CR:C6A00020295 @%  %@NL@%
%@NL@%
You can refer to the standard streams with the following predefined stream
pointers:  %@NL@%
%@NL@%
%@AB@%Pointer%@AE@%                           %@AB@%Stream%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%stdin%@AE@%                             Standard input

%@AB@%stdout%@AE@%                            Standard output

%@AB@%stderr%@AE@%                            Standard error

%@AB@%stdaux%@AE@%                            Standard auxiliary (DOS only)

%@AB@%stdprn%@AE@%                            Standard print (DOS only)

You can use these pointers in any function that requires a stream pointer as
an argument. Some functions, such as %@AB@%getchar%@AE@% and %@AB@%putchar%@AE@%, are designed to
use %@AB@%stdin%@AE@% or %@AB@%stdout%@AE@% automatically. The pointers %@AB@%stdin%@AE@%, %@AB@%stdout%@AE@%, %@AB@%stderr%@AE@%,
%@AB@%stdaux%@AE@%, and %@AB@%stdprn%@AE@% are constants, not variables; do not try to assign them a
new stream pointer value.  %@NL@%
%@NL@%
DOS and OS/2 allow you to redirect a program's standard input and standard
output at the operating-system command level. OS/2 also allows you to
redirect a program's standard error. See your operating system user's manual
for a complete discussion of redirection.%@CR:C6A00020296 @%  %@NL@%
%@NL@%
Within your program, you can use %@AB@%freopen%@AE@% to redirect %@AB@%stdin%@AE@%, %@AB@%stdout%@AE@%, %@AB@%stderr%@AE@%,
%@AB@%stdaux%@AE@%, or %@AB@%stdprn%@AE@% so that it refers to a disk file or to a device. See the
reference description of %@AB@%freopen%@AE@% for more details.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.7.2.3  Controlling Stream Buffering%@AE@%%@EH@%%@NL@%
%@NL@%
As mentioned earlier, stream routines can use in-memory buffers to speed I/O
operations. Files opened using the stream routines are buffered by default,
except for %@AB@%stdaux%@AE@% and %@AB@%stdprn%@AE@%, which are normally unbuffered. The %@AB@%stdout%@AE@% and
%@AB@%stderr%@AE@% streams are flushed whenever they are full or (if you are writing to
a character device) after each library call.%@CR:C6A00020297 @%%@CR:C6A00020298 @%%@CR:C6A00020299 @%%@CR:C6A00020300 @%%@CR:C6A00020301 @%  %@NL@%
%@NL@%
By using the %@AB@%setbuf%@AE@% or %@AB@%setvbuf%@AE@% function, you can cause a stream to be
unbuffered, or you can associate a buffer with an unbuffered stream. Buffers
allocated by the system are not accessible to you, but buffers allocated
with %@AB@%setbuf%@AE@% or %@AB@% setvbuf%@AE@% refer to arrays in your program and can be
manipulated. Buffers can be any size up to 32,767 bytes. This size is set by
the manifest constant %@AB@%BUFSIZ%@AE@% in STDIO.H if you use%@AB@% seftbuf%@AE@%; if you use
%@AB@%setvbuf%@AE@%, you can set the size of the buffer yourself. (See the descriptions
of %@AB@%setbuf%@AE@% and %@AB@%setvbuf%@AE@% in the reference section for more details.)%@CR:C6A00020302 @%%@CR:C6A00020303 @%  %@NL@%
%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
NOTE

%@AI@%These routines affect only buffers created by C library routines. They have
%@AI@%no effect on buffers created by the operating system.%@AE@%%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%%@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.7.2.4  Closing Streams%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fclose%@AE@% and %@AB@%fcloseall%@AE@% functions close a stream or streams. The %@AB@%fclose%@AE@%
routine closes a single specified stream; %@AB@%fcloseall%@AE@% closes all open streams
except %@AB@%stdin%@AE@%, %@AB@%stdout%@AE@%, %@AB@%stderr%@AE@%, %@AB@%stdaux%@AE@%, and %@AB@%stdprn%@AE@%. If your program does not
explicitly close a stream, the stream is automatically closed when the
program terminates. How-ever, it is a good practice to close a stream when
your program is finished with it, as the number of streams that can be open
at a given time is limited.%@CR:C6A00020304 @%  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.7.2.5  Reading and Writing Data%@AE@%%@EH@%%@NL@%
%@NL@%
The stream functions allow you to transfer data in a variety of ways. You
can read and write binary data (a sequence of bytes), or specify reading and
writing by characters, lines, or more complicated formats.  %@NL@%
%@NL@%
Reading and writing operations on streams always begin at the current
position of the stream, known as the "file pointer" for the stream. The file
pointer is changed to reflect the new position after a read or write
operation takes place. For example, if you read a single character from a
stream, the file pointer is increased by one byte so that the next operation
begins with the first unread character. If a stream is opened for appending,
the file pointer is automatically positioned at the end of the file before
each write operation.%@CR:C6A00020305 @%  %@NL@%
%@NL@%
The %@AB@%fseek%@AE@% and %@AB@%fsetpos%@AE@% functions allow you to position the file pointer
anywhere in a file. The next operation occurs at the position you specified.
The %@AB@%rewind%@AE@% routine positions the file pointer at the beginning of the file.
Use the %@AB@%ftell%@AE@% or %@AB@%fgetpos%@AE@% routine to determine the current position of the
file pointer.  %@NL@%
%@NL@%
The %@AB@%feof%@AE@% macro detects an end-of-file condition on a stream. Once the
end-of-file indicator is set, it remains set until the file is closed, or
until %@AB@%clearerr%@AE@%, %@AB@%fseek%@AE@%, %@AB@%fsetpos%@AE@%, or %@AB@%rewind%@AE@% is called.  %@NL@%
%@NL@%
Streams associated with a character-oriented device (such as a console) do
not have file pointers. Data coming from or going to a console cannot be
accessed randomly. Routines that set or get the file-pointer position (such
as %@AB@%fseek%@AE@%, %@AB@%fgetpos%@AE@%, %@AB@%fsetpos%@AE@%, %@AB@%ftell%@AE@%, or %@AB@%rewind%@AE@%) have undefined results if used
on a stream associated with a character-oriented device.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.7.2.6  Detecting Errors%@AE@%%@EH@%%@NL@%
%@NL@%
When an error occurs in a stream operation, an error indicator for the
stream is set. You can use the %@AB@%ferror%@AE@% macro to test the error indicator and
determine whether an error has occurred. Once an error has occurred, the
error indicator for the stream remains set until the stream is closed, or
until you explicitly clear the error indicator by calling %@AB@%clearerr%@AE@% or
%@AB@%rewind%@AE@%.%@CR:C6A00020306 @%%@CR:C6A00020307 @%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00020308 @%%@AB@%2.7.3  Low-Level Routines%@CR:C6A00020309 @%%@CR:C6A00020310 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Low-level input and output calls do not buffer or format data. Declarations
for the low-level functions are given in the include files IO.H, FCNTL.H,
SYS\TYPES.H, and SYS\STAT.H. Unlike the stream functions, low-level
functions do not require the include file STDIO.H. However, some common
constants are defined in STDIO.H; for example, the end-of-file indicator
(%@AB@%EOF%@AE@%) may be useful. If your program requires these constants, you must
include STDIO.H.%@CR:C6A00020311 @%%@CR:C6A00020312 @%%@CR:C6A00020313 @%%@CR:C6A00020314 @%%@CR:C6A00020315 @%%@CR:C6A00020316 @%%@CR:C6A00020317 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%close%@AE@%%@CR:C6A00020318 @%%@CR:C6A00020319 @% %@CR:C6A00020320 @%%@CR:C6A00020321 @%%@CR:C6A00020322 @%%@CR:C6A00020323 @%%@CR:C6A00020324 @%                            Closes a file

%@AB@%creat%@AE@%%@CR:C6A00020325 @%                             Creates a file

%@AB@%dup%@AE@%%@CR:C6A00020326 @%                               Creates a second handle for a file

%@AB@%dup2%@AE@%                              Reassigns a handle to a file

%@AB@%eof%@AE@%%@CR:C6A00020327 @%                               Tests for end-of-file

%@AB@%lseek%@AE@%%@CR:C6A00020328 @%                             Repositions file pointer to a given 
                                  location

%@AB@%open%@AE@%%@CR:C6A00020329 @%                              Opens a file

%@AB@%read%@AE@%%@CR:C6A00020330 @%                              Reads data from a file

%@AB@%sopen%@AE@%%@CR:C6A00020331 @%                             Opens a file for file sharing

%@AB@%tell%@AE@%                              Gets current file-pointer position

%@AB@%umask%@AE@%                             Sets default file-permission mask

%@AB@%write%@AE@%                             Writes data to a file

%@NL@%
%@4@%%@AB@%2.7.3.1  Opening a File%@AE@%%@EH@%%@NL@%
%@NL@%
You must open a file before performing I/O functions on it. The %@AB@%open%@AE@%
function opens a file; it can also create the file when opening it. In OS/2
and DOS versions 3.0 and later, you can use %@AB@%sopen%@AE@% to open a file with
file-sharing attributes. The %@AB@%creat%@AE@% function can create and open a file.  %@NL@%
%@NL@%
The file can be opened for reading, writing, or both, and opened in either
text or binary mode (see Section 2.7.1, "Text and Binary Modes"). The
include file FCNTL.H must be included when opening a file, as it contains
definitions for flags used in %@AB@%open%@AE@%. In some cases, the files SYS\TYPES.H and
SYS\STAT.H must also be included; for more information, see the reference
description for the %@AB@%open%@AE@% function.%@CR:C6A00020332 @%  %@NL@%
%@NL@%
These functions return a file handle, which is normally assigned to an
integer variable. You use the variable to refer to the opened file.%@CR:C6A00020333 @%  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.7.3.2  Reading and Writing Data%@AE@%%@EH@%%@NL@%
%@NL@%
Use the %@AB@%read%@AE@% and %@AB@%write%@AE@% routines to read and write to files. These operations
begin at the current position in the file. The current position is updated
each time a read or write operation occurs.%@CR:C6A00020334 @%  %@NL@%
%@NL@%
The %@AB@%lseek%@AE@% function allows you to place the file pointer anywhere in the
file. The next operation occurs at the position you specified. The %@AB@%tell%@AE@%
function indicates the current position of the file pointer. The %@AB@%eof%@AE@% routine
tests for the end of the file.  %@NL@%
%@NL@%
Low-level I/O routines set the %@AB@%errno%@AE@% variable when an error occurs. Chapter
3, "Global Variables and Standard Types," describes %@AB@%errno%@AE@%.%@CR:C6A00020335 @%%@CR:C6A00020336 @%  %@NL@%
%@NL@%
Character-oriented devices, such as the console, do not have file pointers.
The %@AB@%lseek%@AE@% and %@AB@%tell%@AE@% routines have undefined results if used on a handle
associated with a device.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.7.3.3  Closing Files%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%close%@AE@% function closes an open file. Open files are automatically closed
when a program terminates. However, it is a good practice to close a file
when your program is finished with it, as there is a limit to the number of
files that can be open at one time.%@CR:C6A00020337 @%  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%2.7.3.4  Using Predefined Handles%@AE@%%@EH@%%@NL@%
%@NL@%
When a program begins execution, three files are automatically opened:
standard input, standard output, and standard error. In DOS, two additional
files are opened: standard auxiliary and standard print. (These files are
not available in OS/2.)%@CR:C6A00020338 @%%@CR:C6A00020339 @%  %@NL@%
%@NL@%
Low-level routines can access these files using the following predefined
handles:%@CR:C6A00020340 @%%@CR:C6A00020341 @%  %@NL@%
%@NL@%
%@AB@%Stream%@AE@%                            %@AB@%Handle%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%stdin%@AE@%                             0

%@AB@%stdout%@AE@%                            1

%@AB@%stderr%@AE@%                            2

%@AB@%stdaux%@AE@% (DOS only)                 3

%@AB@%stdprn%@AE@% (DOS only)                 4

You can use these file handles without previously opening the files. The
files are opened and the handles are assigned when the program starts.  %@NL@%
%@NL@%
The %@AB@%dup%@AE@% and %@AB@%dup2%@AE@% functions allow you to assign multiple handles for the same
file. These functions are typically used to associate the predefined file
handles with different files.%@CR:C6A00020342 @%  %@NL@%
%@NL@%
In DOS and OS/2, you can redirect the standard input and standard output at
the operating-system command level. OS/2 also allows you to redirect the
standard error. See your operating system user's manual for a complete
discussion of redirection.%@CR:C6A00020343 @%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00020344 @%%@AB@%2.7.4  Console and Port I/O%@AE@%%@EH@%%@NL@%
%@NL@%
The console and port I/O routines are implemented as functions and are
declared in the include file CONIO.H. These functions perform reading and
writing operations on your console or on the specified port. The %@AB@%cgets%@AE@%,
%@AB@%cscanf%@AE@%, %@AB@%getch%@AE@%, %@AB@%getche%@AE@%, and %@AB@%kbhit%@AE@% routines take input from the console, while
%@AB@%cprintf%@AE@%, %@AB@%cputs%@AE@%, %@AB@%putch%@AE@%, and %@AB@%ungetch%@AE@% write to the console. The input or output
of these functions can be redirected.%@CR:C6A00020345 @%%@CR:C6A00020346 @%%@CR:C6A00020347 @%%@CR:C6A00020348 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%cgets%@AE@%%@CR:C6A00020349 @%%@CR:C6A00020350 @%                             Reads a string from the console

%@AB@%cprintf%@AE@%%@CR:C6A00020351 @%%@CR:C6A00020352 @%                           Writes formatted data to the console

%@AB@%cputs%@AE@%%@CR:C6A00020353 @%                             Writes a string to the console

%@AB@%cscanf%@AE@%%@CR:C6A00020354 @%%@CR:C6A00020355 @%                            Reads formatted data from the console

%@AB@%getch%@AE@%%@CR:C6A00020356 @%%@CR:C6A00020357 @%                             Reads a character from the console

%@AB@%getche%@AE@%                            Reads a character from the console and 
                                  echoes it

%@AB@%inp%@AE@%%@CR:C6A00020358 @%%@CR:C6A00020359 @%                               Reads one byte from the specified I/O 
                                  port

%@AB@%inpw%@AE@%                              Reads a two-byte word from the specified
                                  I/O port

%@AB@%kbhit%@AE@%%@CR:C6A00020360 @%%@CR:C6A00020361 @%                             Checks for a keystroke at the console

%@AB@%outp%@AE@%%@CR:C6A00020362 @%%@CR:C6A00020363 @%                              Writes one byte to the specified I/O 
                                  port

%@AB@%outpw%@AE@%                             Writes a two-byte word to the specified 
                                  I/O port

%@AB@%putch%@AE@%%@CR:C6A00020364 @%%@CR:C6A00020365 @%                             Writes a character to the console

%@AB@%ungetch%@AE@%%@CR:C6A00020366 @%%@CR:C6A00020367 @%                           "Ungets" the last character read from 
                                  the console so that it becomes the next 
                                  character read

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
NOTE

%@AI@%Programs that need only run under DOS can also use a number of direct DOS
%@AI@%I/O system calls (%@AB@% %@AE@%%@AI@%_dos_open, _dos_read, _dos_close,%@AE@%%@AI@% etc.) These are
%@AI@%described in detail in Section 2.14, "System Calls."%@AE@%%@AE@%%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%%@NL@%
%@NL@%
The console or port does not have to be opened or closed before I/O is
performed, so there are no open or close routines in this category. The port
I/O routines %@AB@%inp%@AE@% and %@AB@%outp%@AE@% read or write one byte at a time from the
specified port. The %@AB@%inpw%@AE@% and %@AB@%outpw%@AE@% routines read and write two-byte words,
respectively.%@CR:C6A00020368 @%%@CR:C6A00020369 @%  %@NL@%
%@NL@%
The console I/O routines allow reading and writing of strings (%@AB@%cgets %@AE@%and
%@AB@%cputs%@AE@%), formatted data (%@AB@%cscanf %@AE@%and %@AB@%cprintf%@AE@%), and characters. Several options
are available when reading and writing characters.  %@NL@%
%@NL@%
The %@AB@%putch%@AE@% routine writes a single character to the console. The %@AB@%getch%@AE@% and
%@AB@%getche%@AE@% routines read a single character from the console; %@AB@%getche%@AE@% echoes the
character back to the console, while %@AB@%getch%@AE@% does not. The %@AB@%ungetch%@AE@% routine
"ungets" the last character read; the next read operation on the console
begins with the "ungotten" character.  %@NL@%
%@NL@%
The %@AB@%kbhit%@AE@% routine determines whether a key has been struck at the console.
This routine allows you to test for keyboard input before you attempt to
read from the console.  %@NL@%
%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
NOTE

%@AI@%The console I/O routines are not compatible with stream or low-level library
%@AI@%routines and should not be used with them.%@AE@%%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00020370 @%%@AB@%2.8  Internationalization%@AE@%%@EH@%%@NL@%
%@NL@%
Internationalization routines are useful for creating different versions of
a program for international markets. These routines are declared in the
header file LOCALE.H, except for %@AB@%strftime%@AE@%, which is declared in TIME.H.  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%localeconv%@AE@%                        Sets a structure with appropriate values
                                  for formatting numeric quantities

%@AB@%setlocale%@AE@%                         Selects the appropriate locale for the 
                                  program

%@AB@%strcoll%@AE@%                           Compares strings using locale-specific 
                                  information

%@AB@%strftime%@AE@%                          Formats a date and time string

%@AB@%strxfrm%@AE@%                           Transforms a string based on 
                                  locale-specific
                                  information

%@NL@%
%@2@%%@CR:C6A00020371 @%%@AB@%2.9  Math%@AE@%%@EH@%%@NL@%
%@NL@%
The math routines allow you to perform common mathematical calculations. All
math routines work with floating-point values and therefore require
floating-point support (see Section 1.8, "Floating-Point Support").%@CR:C6A00020372 @%%@CR:C6A00020373 @%%@CR:C6A00020374 @%%@CR:C6A00020375 @%%@CR:C6A00020376 @%%@CR:C6A00020377 @%%@CR:C6A00020378 @%%@CR:C6A00020379 @%%@CR:C6A00020380 @%
%@CR:C6A00020381 @%%@CR:C6A00020382 @%  %@NL@%
%@NL@%
The math library provides two versions of some routines. The first version
of the routine supports %@AB@%double%@AE@% arguments and return values. The second
version supports an 80-bit data type, allowing the routine to take %@AB@%long
%@AB@%double%@AE@% arguments and return a %@AB@%long double%@AE@% value. The second version usually
has the same name with the suffix %@AB@%l%@AE@%. For instance, the %@AB@%acos%@AE@% routine supports
%@AB@%double%@AE@% arguments and return values, while %@AB@%acosl%@AE@% supports %@AB@%long double%@AE@%
arguments and return values.%@CR:C6A00020383 @%%@CR:C6A00020384 @%%@CR:C6A00020385 @%%@CR:C6A00020386 @%%@CR:C6A00020387 @%%@CR:C6A00020388 @%%@CR:C6A00020389 @%%@CR:C6A00020390 @%%@CR:C6A00020391 @%  %@NL@%
%@NL@%
Routines which support %@AB@%long double%@AE@% values are not available when you compile
with the /Fpa (alternate math) compiler option. The same is true of the
%@AB@%_clear 87%@AE@%,%@AB@% _control87%@AE@%, and %@AB@%_status87%@AE@% routines.%@CR:C6A00020392 @%%@CR:C6A00020393 @%%@CR:C6A00020394 @%%@CR:C6A00020395 @%%@CR:C6A00020396 @%%@CR:C6A00020397 @%%@CR:C6A00020398 @%%@CR:C6A00020399 @%%@CR:C6A00020400 @%
%@CR:C6A00020401 @%%@CR:C6A00020402 @%%@CR:C6A00020403 @%  %@NL@%
%@NL@%
Most math declarations are in the include file MATH.H. However, the
%@AB@%_clear87%@AE@%, %@AB@%_control87%@AE@%, %@AB@%_fpreset%@AE@%, and %@AB@%_status87%@AE@% routines are defined in
FLOAT.H, the%@AB@% abs%@AE@% and %@AB@%labs%@AE@% functions are defined in MATH.H and STDLIB.H, and
the %@AB@%div%@AE@% and %@AB@%ldiv%@AE@% routines are declared in STDLIB.H.%@CR:C6A00020404 @%%@CR:C6A00020405 @%%@CR:C6A00020406 @%%@CR:C6A00020407 @%%@CR:C6A00020408 @%%@CR:C6A00020409 @%%@CR:C6A00020410 @%%@CR:C6A00020411 @%%@CR:C6A00020412 @%
%@CR:C6A00020413 @%%@CR:C6A00020414 @%%@CR:C6A00020415 @%%@CR:C6A00020416 @%%@CR:C6A00020417 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%acos%@AE@%, %@AB@%acosl%@AE@%                       Calculate the arccosine

%@AB@%asin%@AE@%, %@AB@%asinl%@AE@%                       Calculate the arcsine

%@AB@%atan%@AE@%, %@AB@%atanl%@AE@%                       Calculate the arctangent

%@AB@%atan2%@AE@%, %@AB@%atan2l%@AE@%                     Calculate the arctangent

%@AB@%bessel%@AE@%                            Calculates Bessel functions

%@AB@%cabs%@AE@%, %@AB@%cabsl%@AE@%                       Find the absolute value of a complex 
                                  number

%@AB@%ceil%@AE@%, %@AB@%ceill%@AE@%                       Find the integer ceiling

%@AB@%_clear87%@AE@%                          Gets and clears the floating-point 
                                  status word

%@AB@%_control87%@AE@%                        Gets the old floating-point control word
                                  and sets a new control-word value

%@AB@%cos%@AE@%, %@AB@%cosl%@AE@%                         Calculate the cosine

%@AB@%cosh%@AE@%, %@AB@%coshl%@AE@%                       Calculate the hyperbolic cosine

%@AB@%dieeetomsbin%@AE@%                      Converts IEEE double-precision number to
                                  Microsoft (MS) binary format %@CR:C6A00020418 @%

%@AB@%div%@AE@%                               Divides one integer by another, 
                                  returning the quotient and remainder

%@AB@%dmsbintoieee%@AE@%                      Converts Microsoft binary 
                                  double-precision number to IEEE format

%@AB@%exp%@AE@%, %@AB@%expl%@AE@%                         Calculate the exponential function

%@AB@%fabs%@AE@%, %@AB@%fabsl%@AE@%                       Find the absolute value

%@AB@%fieeetomsbin%@AE@%                      Converts IEEE single-precision number to
                                  Microsoft binary format %@CR:C6A00020419 @%

%@AB@%floor%@AE@%, %@AB@%floorl%@AE@%                     Find the largest integer less than or 
                                  equal to the
                                  argument

%@AB@%fmod%@AE@%, %@AB@%fmodl%@AE@%                       Find the floating-point remainder

%@AB@%fmsbintoieee%@AE@%                      Converts Microsoft binary 
                                  single-precision number to IEEE format

%@AB@%_fpreset%@AE@%                          Reinitializes the floating-point-math 
                                  package

%@AB@%frexp%@AE@%, %@AB@%frexpl%@AE@%                     Calculate an exponential value

%@AB@%hypot%@AE@%, %@AB@%hypotl%@AE@%                     Calculate the hypotenuse of right 
                                  triangle

%@AB@%ldexp%@AE@%, %@AB@%ldexpl%@AE@%                     Calculate the product of the argument 
                                  and 2exp

%@AB@%ldiv%@AE@%                              Divides one %@AB@%long%@AE@% integer by another, 
                                  returning the quotient and remainder

%@AB@%log%@AE@%, %@AB@%logl%@AE@%                         Calculate the natural logarithm

%@AB@%log10%@AE@%, %@AB@%log10l%@AE@%                     Calculate the base-10 logarithm

%@AB@%_lrotl%@AE@%,  %@AB@%_lrotr%@AE@%                   Shift an %@AB@%unsigned long int%@AE@% item left ( 
                                  _lrotl) or right ( _lrotr)

%@AB@%matherr%@AE@%,  %@AB@%_matherrl%@AE@%               Handle math errors

%@AB@%max%@AE@%, %@AB@%min%@AE@%                          Return the larger or smaller of two 
                                  values

%@AB@%modf%@AE@%, %@AB@%modfl%@AE@%                       Break down the argument into integer and
                                  fractional parts

%@AB@%pow%@AE@%, %@AB@%powl%@AE@%                         Calculate a value raised to a power

%@AB@%rand%@AE@%                              Gets a pseudorandom number

%@AB@%_rotl%@AE@%,  %@AB@%_rotr%@AE@%                     Shift an %@AB@%unsigned int%@AE@% item left ( _rotl)
                                  or right
                                  ( _rotr)

%@AB@%sin%@AE@%, %@AB@%sinl%@AE@%                         Calculate the sine

%@AB@%sinh%@AE@%, %@AB@%sinhl%@AE@%                       Calculate the hyperbolic sine

%@AB@%sqrt%@AE@%, %@AB@%sqrtl%@AE@%                       Find the square root

%@AB@%srand%@AE@%                             Initializes a pseudorandom series

%@AB@%_status87%@AE@%                         Gets the floating-point status word

%@AB@%tan%@AE@%, %@AB@%tanl%@AE@%                         Calculate the tangent

%@AB@%tanh%@AE@%, %@AB@%tanhl%@AE@%                       Calculate the hyperbolic tangent

The %@AB@%bessel%@AE@% routine does not correspond to a single function, but to twelve
functions named %@AB@%j0%@AE@%, %@AB@%j1%@AE@%, %@AB@%jn%@AE@%, %@AB@%y0%@AE@%, %@AB@%y1%@AE@%, %@AB@%yn%@AE@%,  %@AB@%_j0l%@AE@%,  %@AB@%_j1l%@AE@%,  %@AB@%_jnl%@AE@%,  %@AB@%_y0l%@AE@%,  %@AB@%_y1l%@AE@%,
and  %@AB@%_ynl%@AE@%.  %@NL@%
%@NL@%
The %@AB@%matherr%@AE@% and %@AB@%_matherrl%@AE@% routines are invoked by the math functions when
errors occur. The %@AB@%matherr%@AE@% routine handles functions that return a %@AB@%double%@AE@%
value and %@AB@%_matherrl%@AE@% handles routines that return a %@AB@%long double%@AE@%.  %@NL@%
%@NL@%
These routines are defined in the library, but you can redefine them for
different error-handling. The user-defined function, if given, must follow
the rules given in the reference description of %@AB@%matherr%@AE@% and %@AB@%_matherrl%@AE@%.  %@NL@%
%@NL@%
You are not required to supply a definition for the %@AB@%matherr%@AE@% routines. If no
definition is present, the default error returns for each routine are used.
The reference description of each routine describes that routine's error
returns.%@CR:C6A00020420 @%%@CR:C6A00020421 @%  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00020422 @%%@AB@%2.10  Memory Allocation%@CR:C6A00020423 @% %@CR:C6A00020424 @%%@CR:C6A00020425 @%%@CR:C6A00020426 @%%@CR:C6A00020427 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The memory-allocation routines allow you to allocate, free, and reallocate
blocks of memory. Memory-allocation routines are declared in the include
file MALLOC.H.%@CR:C6A00020428 @%%@CR:C6A00020429 @%%@CR:C6A00020430 @%%@CR:C6A00020431 @%%@CR:C6A00020432 @%%@CR:C6A00020433 @%%@CR:C6A00020434 @%%@CR:C6A00020435 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%alloca%@AE@%                            Allocates a block of memory from the 
                                  program's stack

%@AB@%_bfreeseg%@AE@%                         Frees a based heap

%@AB@%_bheapseg%@AE@%                         Allocates a based heap

%@AB@%calloc%@AE@%, %@AB@% _bcalloc%@AE@%,  %@AB@%_fcalloc%@AE@%,  %@AB@%%@AE@%   Allocate storage for an array
%@AB@%_ncalloc%@AE@%                          

%@AB@%_expand%@AE@%,  %@AB@%_bexpand%@AE@%,  %@AB@%_fexpand%@AE@%, %@AB@%%@AE@%   Expand or shrink a block of memory 
%@AB@%_nexpand%@AE@%                          without moving its location

%@AB@%free%@AE@%,  %@AB@%_bfree%@AE@%,  %@AB@%_ffree%@AE@%,  %@AB@%_nfree%@AE@%%@CR:C6A00020436 @%   Free an allocated block

%@AB@%_freect%@AE@%                           Returns approximate number of items of 
                                  given size that could be allocated in 
                                  the near heap

%@AB@%halloc%@AE@%%@CR:C6A00020437 @%                            Allocates storage for huge array

%@AB@%_heapadd%@AE@%,  %@AB@%_bheapadd%@AE@%              Add memory to a heap

%@AB@%_heapchk%@AE@%,  %@AB@%_bheapchk%@AE@%,  %@AB@%_fheapchk%@AE@%  Check a heap for consistency
, %@AB@%_nheapchk%@AE@%                       

%@AB@%_heapmin%@AE@%,  %@AB@%_bheapmin%@AE@%,%@AB@%%@AE@%             Release unused memory in a heap
%@AB@%_fheapmin%@AE@%,  %@AB@%_nheapmin%@AE@%             

%@AB@%_heapset%@AE@%,  %@AB@%_bheapset%@AE@%,  %@AB@%_fheapset%@AE@%  Fill free heap entries with a specified 
, %@AB@%_nheapset%@AE@%%@CR:C6A00020438 @%%@CR:C6A00020439 @%%@CR:C6A00020440 @%                       value

%@AB@%_heapwalk%@AE@%,  %@AB@%_bheapwalk%@AE@%, %@AB@%%@AE@%          Return information about each entry in a
%@AB@%_fheapwalk%@AE@%, %@AB@%_nheapwalk%@AE@%            heap

%@AB@%hfree%@AE@%%@CR:C6A00020441 @%                             Frees a block allocated by %@AB@%halloc%@AE@%

%@AB@%malloc%@AE@%,  %@AB@%_bmalloc%@AE@%,  %@AB@%_fmalloc%@AE@%, %@AB@%%@AE@%    Allocate a block of memory
%@AB@%_nmalloc%@AE@%%@CR:C6A00020442 @%%@CR:C6A00020443 @%                          

%@AB@%_memavl%@AE@%%@CR:C6A00020444 @%                           Returns approximate number of bytes 
                                  available for allocation in the near 
                                  heap

%@AB@%_memmax%@AE@%%@CR:C6A00020445 @%                           Returns size of largest contiguous free 
                                  block in the near heap

%@AB@%_msize%@AE@%,  %@AB@%_bmsize%@AE@%,  %@AB@%_fmsize%@AE@%, %@AB@%%@AE@%      Return size of an allocated block
%@AB@%_nmsize%@AE@%%@CR:C6A00020446 @%                           

%@AB@%realloc%@AE@%,  %@AB@%_brealloc%@AE@%,  %@AB@%_frealloc%@AE@%,  Reallocate a block to a new size%@CR:C6A00020448 @%
%@AB@%_nrealloc%@AE@%%@CR:C6A00020447 @%                         

%@AB@%stackavail%@AE@%%@CR:C6A00020449 @%                        Returns size of stack space available 
                                  for allocation with %@AB@%alloca%@AE@%

Some memory-management routines, such as %@AB@%malloc%@AE@%, are available in different
versions that begin with %@AB@%_b%@AE@%, %@AB@%_f%@AE@%, or %@AB@%_n%@AE@%. These variations are described in
the following section.  %@NL@%
%@NL@%
The %@AB@%malloc%@AE@% and %@AB@%free%@AE@% routines allocate and free memory space, respectively,
while a program runs. The %@AB@%malloc%@AE@% routine allocates memory from the "heap,"
which is a pool of memory not otherwise used by your program. In tiny-,
small-, and medium-model programs, the heap consists of unused memory in
your program's default data segment. In compact-, large-, and huge-model
programs, it is unused memory outside the default data segment.  %@NL@%
%@NL@%
The %@AB@%malloc%@AE@% and %@AB@%free%@AE@% routines satisfy the memory-allocation requirements of
most programs. More specialized memory-management routines are discussed
below.  %@NL@%
%@NL@%
The %@AB@%realloc%@AE@% and %@AB@%_expand%@AE@% routines can expand or shrink an allocated memory
block. They behave differently in cases in which there is not enough room to
expand the block in its current location. In this case, %@AB@%realloc%@AE@% moves the
block as needed, but %@AB@%_expand%@AE@% does not.  %@NL@%
%@NL@%
The %@AB@%calloc%@AE@% routine allocates memory for an array and initializes every byte
in the allocated block to 0.  %@NL@%
%@NL@%
The %@AB@%halloc%@AE@% routine is similar to %@AB@%calloc%@AE@%, except that it can allocate memory
for a huge array (one that exceeds 64K in size). This routine is useful when
you need a very large data object, or if you need to return allocated memory
to the operating system for subsequent calls to the %@AB@%spawn%@AE@% family of
functions.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00020450 @%%@AB@%2.10.1  Near and Far Heaps%@AE@%%@EH@%%@NL@%
%@NL@%
As mentioned in the previous section, heap memory can reside inside or
outside your program's default data segment, depending on what memory model
your program uses. When it lies inside the default data segment, the heap is
called the "near heap," since it can be accessed with near pointers. The
"far heap" is memory that spans one or more segments outside the default
data segment. The far heap can be accessed only with far pointers.  %@NL@%
%@NL@%
In various memory models, %@AB@%malloc%@AE@% automatically allocates memory from the
near heap or far heap, as appropriate. The C library also includes near and
far versions of %@AB@%malloc%@AE@%, %@AB@%free%@AE@%, and other memory-management routines, which
allow you to specify the near and far heaps explicitly. These have the same
names as standard memory routines, but are preceded by %@AB@%_n%@AE@% (for %@AB@%near%@AE@%) or %@AB@%_f%@AE@%
(for %@AB@%far%@AE@%).  %@NL@%
%@NL@%
For instance, the %@AB@%_nmalloc%@AE@% routine always allocates memory from the near
heap and returns a near pointer, no matter which memory model your program
uses. Use %@AB@%_nfree%@AE@% to release memory allocated with %@AB@%_nmalloc%@AE@%.  %@NL@%
%@NL@%
Similarly, %@AB@%_fmalloc%@AE@% always allocates memory from the far heap and returns a
far pointer, regardless of memory model. Use the %@AB@%_ffree%@AE@% routine to release
memory allocated with %@AB@%_fmalloc%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00020451 @%%@AB@%2.10.2  Based Heaps%@AE@%%@EH@%%@NL@%
%@NL@%
You can also allocate memory from a "based heap," which is a single segment
that lies outside the default data segment. Based-heap routines generally
use the same names as standard memory routines, but begin with %@AB@%_b%@AE@%. For
instance, %@AB@%_bmalloc%@AE@% allocates a memory block from the based heap and %@AB@%_bfree%@AE@%
frees the block.  %@NL@%
%@NL@%
Based heaps offer the following advantages:  %@NL@%
%@NL@%
%@NL@%
  ş   Localized data. Based heaps allow you to group related data in a
      single segment. This can simplify the management of related data. In
      OS/2, based heaps can also minimize the risk of general protection
      faults and improve performance.%@NL@%
%@NL@%
  ş   Faster pointer arithmetic. Although the based heap lies in the far
      data segment, pointers to its data items are the same size as near
      pointers. Thus, pointer arithmetic on items in a based heap is faster
      than pointer arithmetic on items in the far heap.%@NL@%
%@NL@%
%@NL@%
The %@AB@%_bheapseg%@AE@% routine allocates a based heap segment, from which you can
then allocate blocks of memory. You can call %@AB@%_bheapseg%@AE@% more than once to
allocate as many based-heap segments as needed (within the confines of
available memory).  %@NL@%
%@NL@%
The %@AB@%_bfreeseg%@AE@% routine frees a based-heap segment. This routine frees every
block in the based-heap segment, whether or not you previously freed the
blocks individually.  %@NL@%
%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
NOTE
%@AI@%Near- , far- , and based-heap calls are not ANSI compatible and will make
%@AI@%your program less portable.%@AE@%%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00020452 @%%@AB@%2.11  Process and Environment Control%@CR:C6A00020453 @% %@CR:C6A00020454 @%%@CR:C6A00020455 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The process-control routines allow you to start, stop, and manage processes
from within a program. Environment-control routines allow you to get and
change information about the operating-system environment.%@CR:C6A00020456 @%%@CR:C6A00020457 @%%@CR:C6A00020458 @%%@CR:C6A00020459 @%%@CR:C6A00020460 @%%@CR:C6A00020461 @%%@CR:C6A00020462 @%  %@NL@%
%@NL@%
A "process" is a program being executed by the operating system. It consists
of the program's code and data, plus information about the process, such as
the number of open files. Whenever you execute a program at the
operating-system level, you start a process.%@CR:C6A00020463 @%%@CR:C6A00020464 @%%@CR:C6A00020465 @%%@CR:C6A00020466 @%%@CR:C6A00020467 @%%@CR:C6A00020468 @%%@CR:C6A00020469 @%%@CR:C6A00020470 @%%@CR:C6A00020471 @%%@CR:C6A00020472 @%  %@NL@%
%@NL@%
All process-control functions except %@AB@%signal%@AE@% are declared in the include file
PROCESS.H. The %@AB@%signal%@AE@% function is declared in SIGNAL.H. The %@AB@%abort%@AE@%, %@AB@%exit%@AE@%, and
%@AB@%system%@AE@% functions are also declared in the STDLIB.H include file. The
environment-control routines (%@AB@%getenv%@AE@% and %@AB@%putenv%@AE@%) are declared in STDLIB.H.%@CR:C6A00020473 @%%@CR:C6A00020474 @%%@CR:C6A00020475 @%%@CR:C6A00020476 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%abort%@AE@%                             Aborts a process without flushing 
                                  buffers or calling functions registered 
                                  by %@AB@%atexit%@AE@% and %@AB@%onexit%@AE@%

%@AB@%assert%@AE@%                            Tests for logic error

%@AB@%atexit%@AE@%                            Schedules routines for execution at 
                                  program
                                  termination

%@AB@%_beginthread%@AE@%                      Creates an execution thread (OS/2 only)

%@AB@%_cexit%@AE@%                            Performs the %@AB@%exit%@AE@% termination procedures
                                  (such as flushing buffers) and returns 
                                  control to the calling program

%@AB@%_c_exit%@AE@%                           Performs the %@AB@%_exit%@AE@% termination 
                                  procedures and returns control to the 
                                  calling program

%@AB@%cwait%@AE@%                             Suspends the calling process until a 
                                  specified child process terminates (OS/2
                                  only)

%@AB@%_endthread%@AE@%                        Terminates an execution thread (OS/2 
                                  only)

%@AB@%execl%@AE@%                             Executes child process with argument 
                                  list

%@AB@%execle%@AE@%                            Executes child process with argument 
                                  list and given environment

%@AB@%execlp%@AE@%                            Executes child process using PATH 
                                  variable and argument list

%@AB@%execlpe%@AE@%                           Executes child process using PATH 
                                  variable, given environment, and 
                                  argument list

%@AB@%execv%@AE@%                             Executes child process with argument 
                                  array

%@AB@%execve%@AE@%                            Executes child process with argument 
                                  array and given environment

%@AB@%execvp%@AE@%                            Executes child process using PATH 
                                  variable and argument array

%@AB@%execvpe%@AE@%                           Executes child process using PATH 
                                  variable, given environment, and 
                                  argument array

%@AB@%exit%@AE@%                              Calls functions registered by %@AB@%atexit%@AE@% and
                                  %@AB@%onexit%@AE@%, then flushes all buffers and 
                                  closes all open files before terminating
                                  the process

%@AB@%_exit%@AE@%                             Terminates process without processing %@AB@%%@AE@%
                                  %@AB@%atexit%@AE@% or %@AB@%onexit%@AE@% functions or flushing 
                                  buffers

%@AB@%getenv%@AE@%                            Gets the value of an environment 
                                  variable

%@AB@%getpid%@AE@%                            Gets process ID number

%@AB@%longjmp%@AE@%                           Restores a saved stack environment

%@AB@%onexit%@AE@%                            Schedules routines for execution at 
                                  program
                                  termination

%@AB@%_pclose%@AE@%                           Waits for a child command and closes a 
                                  pipe on the associated stream

%@AB@%perror%@AE@%                            Prints error message

%@AB@%_pipe%@AE@%                             Creates a pipe

%@AB@%_popen%@AE@%                            Creates a pipe and asynchronously 
                                  executes a child copy of the command 
                                  processor

%@AB@%putenv%@AE@%                            Adds or changes the value of an 
                                  environment
                                  variable

%@AB@%raise%@AE@%                             Sends a signal to the calling process

%@AB@%setjmp%@AE@%                            Saves a stack environment

%@AB@%signal%@AE@%                            Handles an interrupt signal

%@AB@%spawnl%@AE@%                            Executes child process with argument 
                                  list

%@AB@%spawnle%@AE@%                           Executes child process with argument 
                                  list and given environment

%@AB@%spawnlp%@AE@%                           Executes child process using PATH 
                                  variable and argument list

%@AB@%spawnlpe%@AE@%                          Executes child process using PATH 
                                  variable, given environment, and 
                                  argument list

%@AB@%spawnv%@AE@%                            Executes child process with argument 
                                  array

%@AB@%spawnve%@AE@%                           Executes child process with argument 
                                  array and given environment

%@AB@%spawnvp%@AE@%                           Executes child process using PATH 
                                  variable and argument array

%@AB@%spawnvpe%@AE@%                          Executes child process using PATH 
                                  variable, given environment, and 
                                  argument array

%@AB@%system%@AE@%                            Executes an operating system command

%@AB@%wait%@AE@%                              Suspends the calling process until any 
                                  of the caller's immediate child 
                                  processes terminate (OS/2 only)

The %@AB@%atexit%@AE@% and %@AB@%onexit%@AE@% routines create a list of functions to be executed
when the calling program terminates. The only difference between the two is
that %@AB@%atexit%@AE@% is part of the ANSI standard. The %@AB@%onexit%@AE@% function is offered for
compatibility with previous versions of Microsoft C.  %@NL@%
%@NL@%
The %@AB@%_exit%@AE@% routine terminates a process immediately, whereas %@AB@%exit%@AE@% terminates
the process only after flushing buffers and calling any functions previously
registered by %@AB@%atexit%@AE@% and %@AB@%onexit%@AE@%. The %@AB@%_cexit%@AE@% and %@AB@%_c_exit%@AE@% routines are
identical to %@AB@%exit%@AE@% and %@AB@%_exit%@AE@%, respectively, except that they return control
to the calling program without terminating the process.  %@NL@%
%@NL@%
The %@AB@%setjmp%@AE@% and %@AB@%longjmp%@AE@% routines save and restore a stack environment. These
allow you to execute a nonlocal %@AB@%goto%@AE@%.  %@NL@%
%@NL@%
The %@AB@%exec%@AE@% and %@AB@%spawn%@AE@% routines start a new process called the "child" process.
The difference between the %@AB@%exec%@AE@% and %@AB@%spawn%@AE@% routines is that the %@AB@%spawn%@AE@%
routines are capable of returning control from the child process to its
caller (the "parent" process). Both the parent process and the child process
are present in memory (unless %@AB@%P_OVERLAY%@AE@% is specified). In the %@AB@%exec%@AE@% routines,
the child process overlays the parent process, so returning control to the
parent process is impossible (unless an error occurs when attempting to
start execution of the child process).  %@NL@%
%@NL@%
There are eight forms each of the %@AB@%spawn%@AE@% and %@AB@%exec%@AE@% routines (see Table 2.1).
The differences among the forms involve the method of locating the file to
be executed as the child process, the method for passing arguments to the
child process, and the method of setting the environment.  %@NL@%
%@NL@%
Passing an argument list means that the arguments to the child process are
listed separately in the %@AB@%exec%@AE@% or %@AB@%spawn%@AE@% call. Passing an argument array means
that the arguments are stored in an array, and a pointer to the array is
passed to the child process. The argument-list method is typically used when
the number of arguments is constant or is known at compile time. The
argument-array method is useful when the number of arguments must be
determined at run time.  %@NL@%
%@NL@%
Several process-control routines take advantage of the multitasking
capability of OS/2. The %@AB@%_beginthread%@AE@% and %@AB@%_endthread%@AE@% routines create and
terminate execution threads. The %@AB@%cwait%@AE@% and %@AB@%wait%@AE@% routines suspend the calling
process until one child process terminates. The %@AB@%_pipe%@AE@%, %@AB@%_popen%@AE@%, and %@AB@%_pclose%@AE@%
routines create and manipulate pipes, which link processes for sequential
execution.  %@NL@%
%@NL@%
%@AB@%Table 2.1  Forms of the spawn and exec Routines%@AE@%

%@TH:  42  2708 03 20 19 21 21 @%                                       Argument-Passing     Routines            Locating the File  Convention           Environment                                                             Settings%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%execl%@AE@%, %@AB@%spawnl%@AE@%       Do not use PATH    Argument list        Inherited from                                                             parent%@AB@%execle%@AE@%, %@AB@%spawnle%@AE@%     Do not use PATH    Argument list        Pointer to                                                             environment table                                                             for child process                                                             passed as last                                                             argument%@AB@%execlp%@AE@%, %@AB@%spawnlp%@AE@%     Use PATH           Argument list        Inherited from                                                             parent%@AB@%execlpe%@AE@%, %@AB@%spawnlpe%@AE@%   Use PATH           Argument list        Pointer to                                                             environment table                                                             for child process                                                             passed as last                                                            argument%@AB@%execv%@AE@%, %@AB@%spawnv%@AE@%       Do not use PATH    Argument array       Inherited from                                                             parent%@AB@%execve%@AE@%, %@AB@%spawnve%@AE@%     Do not use PATH    Argument array       Pointer to                                                             environment table                                                             for child process                                                             passed as last                                                            argument%@AB@%execvp%@AE@%, %@AB@%spawnvp%@AE@%     Use PATH           Argument array       Inherited from                                                             parent%@AB@%execvpe%@AE@%, %@AB@%spawnvpe%@AE@%   Use PATH           Argument array       Pointer to                                                             environment table                                                             for child process                                                             passed as last                                                             argument%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  42  2708 03 20 19 21 21 @%

The %@AB@%assert%@AE@% macro is typically used to test for logic errors. It prints a
message when a given "assertion" fails to hold true. Defining the identifier
%@AB@%NDEBUG%@AE@% to any value causes occurrences of %@AB@%assert%@AE@% to be removed from the
source file, thus allowing you to turn off assertion checking without
modifying the source file.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00020477 @%%@AB@%2.12  Searching and Sorting%@CR:C6A00020478 @% %@CR:C6A00020479 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Search and sort routines provide binary-search, linear-search, and
quick-sort capabilities. They are all declared in SEARCH.H.%@CR:C6A00020480 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%bsearch%@AE@%%@CR:C6A00020481 @%%@CR:C6A00020482 @%                           Performs binary search

%@AB@%lfind%@AE@%%@CR:C6A00020483 @%%@CR:C6A00020484 @%                             Performs linear search for given value

%@AB@%lsearch%@AE@%%@CR:C6A00020485 @%                           Performs linear search for given value, 
                                  which is added to array if not found

%@AB@%qsort%@AE@%%@CR:C6A00020486 @%  %@CR:C6A00020487 @%                           Performs quick sort

%@NL@%
%@2@%%@CR:C6A00020488 @%%@AB@%2.13  String Manipulation%@CR:C6A00020489 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The string functions are declared in the include file STRING.H. They allow
you to compare strings, copy them, search for strings and characters, and
perform various other operations.%@CR:C6A00020490 @%%@CR:C6A00020491 @%%@CR:C6A00020492 @%%@CR:C6A00020493 @%%@CR:C6A00020494 @%%@CR:C6A00020495 @%%@CR:C6A00020496 @%%@CR:C6A00020497 @%%@CR:C6A00020498 @%%@CR:C6A00020499 @%%@CR:C6A00020500 @%
%@CR:C6A00020501 @%%@CR:C6A00020502 @%  %@NL@%
%@NL@%
Routines beginning with %@AB@%_f%@AE@% are model-independent versions of the
corresponding routines and are useful in mixed-model programs. These
routines can be called from any point in the program, regardless of which
model is being used.%@CR:C6A00020503 @%%@CR:C6A00020504 @%%@CR:C6A00020505 @%%@CR:C6A00020506 @%%@CR:C6A00020507 @%%@CR:C6A00020508 @%%@CR:C6A00020509 @%%@CR:C6A00020510 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%strcat%@AE@%,   %@AB@%_fstrcat%@AE@%%@CR:C6A00020511 @%                Append one string to another

%@AB@%strchr%@AE@%,  %@AB@%_fstrchr%@AE@%%@CR:C6A00020512 @%                 Find first occurrence of a given 
                                  character in a string

%@AB@%strcmp%@AE@%,  %@AB@%_fstrcmp%@AE@%%@CR:C6A00020513 @%                 Compare two strings

%@AB@%strcpy%@AE@%,  %@AB@%_fstrcpy%@AE@%%@CR:C6A00020514 @%                 Copy one string to another

%@AB@%strcspn%@AE@%,  %@AB@%_fstrcspn%@AE@%               Find first occurrence of a character 
                                  from a given character set in a string

%@AB@%strdup%@AE@%,  %@AB@%_fstrdup%@AE@%, %@AB@%_nstrdup%@AE@%       Duplicate a string

%@AB@%strerror%@AE@%                          Maps an error number to a message string

%@AB@%_strerror%@AE@%                         Maps a user-defined error message to a 
                                  string

%@AB@%stricmp%@AE@%,  %@AB@%_fstricmp%@AE@%               Compare two strings without regard to 
                                  case

%@AB@%strlen%@AE@%,  %@AB@%_fstrlen%@AE@%                 Find length of string

%@AB@%strlwr%@AE@%,  %@AB@%_fstrlwr%@AE@%                 Convert string to lowercase

%@AB@%strncat%@AE@%,  %@AB@%_fstrncat%@AE@%               Append characters of a string

%@AB@%strncmp%@AE@%,  %@AB@%_fstrncmp%@AE@%               Compare characters of two strings

%@AB@%strncpy%@AE@%,  %@AB@%_fstrncpy%@AE@%               Copy characters of one string to another

%@AB@%strnicmp%@AE@%,  %@AB@%_fstrnicmp%@AE@%             Compare characters of two strings 
                                  without regard
                                  to case 

%@AB@%strnset%@AE@%,  %@AB@%_fstrnset%@AE@%               Set characters of a string to a given 
                                  character

%@AB@%strpbrk%@AE@%,  %@AB@%_fstrpbrk%@AE@%               Find first occurrence of a character 
                                  from one string in another

%@AB@%strrchr%@AE@%,  %@AB@%_fstrrchr%@AE@%               Find last occurrence of a given 
                                  character in string

%@AB@%strrev%@AE@%,  %@AB@%_fstrrev%@AE@%                 Reverse string

%@AB@%strset%@AE@%,  %@AB@%_fstrset%@AE@%                 Set all characters of a string to a 
                                  given character

%@AB@%strspn%@AE@%,  %@AB@%_fstrspn%@AE@%                 Find first substring from a given 
                                  character set in a string

%@AB@%strstr%@AE@%,  %@AB@%_fstrstr%@AE@%                 Find first occurrence of a given string 
                                  in another string

%@AB@%strtok%@AE@%,  %@AB@%_fstrtok%@AE@%                 Find next token in a string

%@AB@%strupr%@AE@%,  %@AB@%_fstrupr%@AE@%                 Convert a string to uppercase

All string functions work on null-terminated character strings. When working
with character arrays that do not end with a null character, you can use the
buffer-manipulation routines, described in Section 2.1.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00020515 @%%@AB@%2.14  System Calls%@AE@%%@EH@%%@NL@%
%@NL@%
The following routines give access to IBM-PC BIOS interrupts and DOS system
calls. Except for the %@AB@%FP_OFF%@AE@%, %@AB@%FP_SEG%@AE@%, and %@AB@%segread%@AE@% routines, these routines
are for DOS application programs only; they do not work under OS/2.%@CR:C6A00020516 @%%@CR:C6A00020517 @%%@CR:C6A00020518 @%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00020519 @%%@AB@%2.14.1  BIOS Interface%@CR:C6A00020520 @% %@CR:C6A00020521 @%%@CR:C6A00020522 @%%@CR:C6A00020523 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The functions in this category provide direct access to the BIOS interrupt
services. They are all declared in BIOS.H.  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_bios_disk%@AE@%                        Issues service requests for both hard 
                                  and floppy disks, using INT 0x13

%@AB@%_bios_equiplist%@AE@%                   Performs an equipment check, using INT 
                                  0x11

%@AB@%_bios_keybrd%@AE@%                      Provides access to keyboard services, 
                                  using
                                  INT 0x16

%@AB@%_bios_memsize%@AE@%                     Obtains information about available 
                                  memory, using INT 0x12

%@AB@%_bios_printer%@AE@%                     Performs printer output services, using 
                                  INT 0x17

%@AB@%_bios_serialcom%@AE@%                   Performs serial communications tasks, 
                                  using
                                  INT 0x14

%@AB@%_bios_timeofday%@AE@%                   Provides access to system clock, using 
                                  INT 0x1A

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
NOTE
%@AI@%BIOS routines are hardware dependent. Some of them may not work as expected
%@AI@%on machines whose hardware differs from the IBM PC.%@AE@%%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@CR:C6A00020524 @%%@AB@%2.14.2  DOS Interface%@CR:C6A00020525 @%%@CR:C6A00020526 @%%@CR:C6A00020527 @%%@AE@%%@EH@%%@NL@%
%@NL@%
These routines are implemented as functions and declared in DOS.H.%@CR:C6A00020528 @%%@CR:C6A00020529 @%%@CR:C6A00020530 @%%@CR:C6A00020531 @%%@CR:C6A00020532 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%bdos%@AE@%                              Invokes DOS system call; uses only DX 
                                  and AL registers %@CR:C6A00020533 @%

%@AB@%_chain_intr%@AE@%                       Chains one interrupt handler to another %@CR:C6A00020534 @%

%@AB@%_disable%@AE@%                          Disables interrupts %@CR:C6A00020535 @%

%@AB@%_dos_allocmem%@AE@%                     Allocates a block of memory, using DOS 
                                  system call 0x48 %@CR:C6A00020536 @%

%@AB@%_dos_close%@AE@%                        Closes a file, using DOS system call 
                                  0x3E %@CR:C6A00020537 @%

%@AB@%_dos_creat%@AE@%                        Creates a new file and erases any 
                                  existing file having the same name, 
                                  using DOS system call 0x3C %@CR:C6A00020538 @%

%@AB@%_dos_creatnew%@AE@%                     Creates a new file and returns an error 
                                  if a file having the same name exists, 
                                  using DOS system
                                  call 0x5B %@CR:C6A00020539 @%

%@AB@%_dos_findfirst%@AE@%                    Finds first occurrence of a given file, 
                                  using DOS system call 0x4E %@CR:C6A00020540 @%

%@AB@%_dos_findnext%@AE@%                     Finds subsequent occurrences of a given 
                                  file, using DOS system call 0x4F %@CR:C6A00020541 @%

%@AB@%_dos_freemem%@AE@%                      Frees a block of memory, using DOS 
                                  system
                                  call 0x49 %@CR:C6A00020542 @%

%@AB@%_dos_getdate%@AE@%                      Gets the system date, using DOS system 
                                  call 0x2A %@CR:C6A00020543 @%

%@AB@%_dos_getdiskfree%@AE@%                  Gets information on a disk volume, using
                                  DOS system call 0x36 %@CR:C6A00020544 @%

%@AB@%_dos_getdrive%@AE@%                     Gets the current default drive, using 
                                  DOS system call 0x19 %@CR:C6A00020545 @%

%@AB@%_dos_getfileattr%@AE@%                  Gets current attributes of a file or 
                                  directory, using DOS system call 0x43 %@CR:C6A00020546 @%

%@AB@%_dos_getftime%@AE@%                     Gets the date and time a file was last 
                                  written, using DOS system call 0x57 %@CR:C6A00020547 @%

%@AB@%_dos_gettime%@AE@%                      Gets the current system time, using DOS 
                                  system
                                  call 0x2C %@CR:C6A00020548 @%

%@AB@%_dos_getvect%@AE@%                      Gets the current value of a specified 
                                  interrupt vector, using DOS system call 
                                  0x35 %@CR:C6A00020549 @%

%@AB@%_dos_keep%@AE@%                         Installs terminate-and-stay-resident 
                                  (TSR) programs using DOS system call 
                                  0x31 %@CR:C6A00020550 @%

%@AB@%_dos_open%@AE@%                         Opens an existing file, using DOS system
                                  call 0x3D %@CR:C6A00020551 @%

%@AB@%_dos_read%@AE@%                         Reads a file, using DOS system call 0x3F
                                  %@CR:C6A00020552 @%

%@AB@%_dos_setblock%@AE@%                     Changes the size of a previously 
                                  allocated block, using DOS system call 
                                  0x4A %@CR:C6A00020553 @%

%@AB@%_dos_setdate%@AE@%                      Sets the current system date, using DOS 
                                  system
                                  call 0x2B %@CR:C6A00020554 @%

%@AB@%_dos_setdrive%@AE@%                     Sets the default disk drive, using DOS 
                                  system
                                  call 0x0E %@CR:C6A00020555 @%

%@AB@%_dos_setfileattr%@AE@%                  Sets the current attributes of a file, 
                                  using DOS system call 0x43 %@CR:C6A00020556 @%

%@AB@%_dos_setftime%@AE@%                     Sets the date and time that the 
                                  specified file was last written, using 
                                  DOS system call 0x57 %@CR:C6A00020557 @%

%@AB@%_dos_settime%@AE@%                      Sets the system time, using DOS system 
                                  call 0x2D %@CR:C6A00020558 @%

%@AB@%_dos_setvect%@AE@%                      Sets a new value for the specified 
                                  interrupt vector, using DOS system call 
                                  0x25 %@CR:C6A00020559 @%

%@AB@%_dos_write%@AE@%                        Sends output to a file, using DOS system
                                  call 0x40 %@CR:C6A00020560 @%

%@AB@%dosexterr%@AE@%                         Obtains in-depth error information from 
                                  DOS system call 0x59 %@CR:C6A00020561 @%

%@AB@%_enable%@AE@% %@CR:C6A00020562 @%                          Enables interrupts 

%@AB@%FP_OFF%@AE@%                            Returns offset portion of a far pointer 
                                  (OS/2
                                  and DOS) %@CR:C6A00020563 @%

%@AB@%FP_SEG%@AE@%                            Returns segment portion of a far pointer
                                  (OS/2
                                  and DOS)

%@AB@%_harderr%@AE@%                          Establishes a hardware error handler %@CR:C6A00020564 @%

%@AB@%_hardresume%@AE@%                       Returns to DOS after a hardware error %@CR:C6A00020565 @%

%@AB@%_hardretn%@AE@%                         Returns to the application after a 
                                  hardware error %@CR:C6A00020566 @%

%@AB@%int86%@AE@%                             Invokes DOS interrupts %@CR:C6A00020567 @%

%@AB@%int86x%@AE@%                            Invokes DOS interrupts with segment 
                                  register values %@CR:C6A00020568 @%

%@AB@%intdos%@AE@%                            Invokes DOS system call using registers 
                                  other than DX and AL %@CR:C6A00020569 @%

%@AB@%intdosx%@AE@%                           Invokes DOS system call using registers 
                                  other than DX and AL with segment 
                                  register values %@CR:C6A00020570 @%

%@AB@%segread%@AE@%                           Returns current values of segment 
                                  registers (OS/2 and DOS) %@CR:C6A00020571 @%

The %@AB@%_harderr%@AE@% routine is used to define a hardware-error interrupt handler.
The %@AB@%_hardresume%@AE@% and %@AB@%_hardretn%@AE@% routines are used within a hardware error
handler to define the return from the error.  %@NL@%
%@NL@%
The %@AB@%dosexterr%@AE@% function obtains and stores the error information returned by
DOS system call 0x59 (extended error handling). This function is provided
for use with DOS versions 3.0 and later.%@CR:C6A00020572 @%%@CR:C6A00020573 @%%@CR:C6A00020574 @%  %@NL@%
%@NL@%
The %@AB@%bdos%@AE@% routine is useful for invoking DOS calls that use either or both of
the DX (DH/DL) and AL registers for arguments. However, %@AB@%bdos%@AE@% should not be
used to invoke system calls that return an error code in AX if the carry
flag is set; since your program cannot detect whether the carry flag is set,
it cannot determine whether the value in AX is a legitimate value or an
error value. In this case, the %@AB@%intdos%@AE@% routine should be used instead, since
it allows the program to detect whether the carry flag is set. The %@AB@%intdos%@AE@%
routine can also be used to invoke DOS calls that use registers other than
DX and AL.  %@NL@%
%@NL@%
The %@AB@%intdosx%@AE@% routine is similar to the %@AB@%intdos%@AE@% routine, but is used when ES is
required by the system call, when DS must contain a value other than the
default data segment (for instance, when a far pointer is used), or when
making the system call in a large-model program. When calling %@AB@%intdosx%@AE@%, give
an argument that specifies the segment values to be used in the call.  %@NL@%
%@NL@%
The %@AB@%int86%@AE@% routine can be used to invoke any interrupt. The %@AB@%int86x%@AE@% routine is
similar; however, like the %@AB@%intdosx%@AE@% routine, it is designed to work with
large-model programs and far items, as described in the preceding paragraph.
%@NL@%
%@NL@%
The %@AB@%FP_OFF%@AE@% and %@AB@%FP_SEG%@AE@% routines allow easy access to the segment and offset
portions of a far pointer value. %@AB@%FP_OFF%@AE@% and %@AB@%FP_SEG%@AE@% are implemented as macros
and defined in DOS.H. You can use these macros in OS/2 as well as DOS.%@CR:C6A00020575 @%%@CR:C6A00020576 @%  %@NL@%
%@NL@%
The %@AB@%segread%@AE@% routine returns the current values of the segment registers.
This routine is typically used with the %@AB@%intdosx%@AE@% and %@AB@%int86x%@AE@% routines to
obtain the correct segment values.  %@NL@%
%@NL@%
The %@AB@%_chain_intr%@AE@% routine is useful for chaining interrupt handlers together.
The %@AB@%_enable%@AE@% routine enables interrupts, while the %@AB@%_disable%@AE@% routine disables
interrupts.  %@NL@%
%@NL@%
%@CR:C6A00020577 @%%@CR:C6A00020578 @%The routines prefixed with  %@AB@%_dos_%@AE@%  are all direct system interfaces that use
the system calls noted above. More detailed information on these system
calls can be found in the %@AI@%MS-DOS Encyclopedia %@AE@%(Duncan, ed.; Redmond, WA:
Microsoft Press, 1988)or the%@AI@% Programmer's PC Sourcebook %@AE@%(Hogan; Redmond, WA:
Microsoft Press, 1988)%@AI@%.  %@AE@%%@NL@%
%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
NOTE

%@AI@%The DOS interface I/O routines are generally incompatible with console,
%@AI@%low-level, and stream I/O routines. Do not mix different types of I/O
%@AI@%routines in the same source file.%@AE@%%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00020579 @%%@AB@%2.15  Time%@CR:C6A00020580 @%%@CR:C6A00020581 @%%@CR:C6A00020582 @%%@CR:C6A00020583 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The time functions allow you to obtain the current time, then convert and
store it according to your particular needs. The current time is always
taken from the system time.%@CR:C6A00020584 @%%@CR:C6A00020585 @%%@CR:C6A00020586 @%%@CR:C6A00020587 @%%@CR:C6A00020588 @%%@CR:C6A00020589 @%%@CR:C6A00020590 @%%@CR:C6A00020591 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%asctime%@AE@%                           Converts time from type %@AB@%struct tm%@AE@% to a 
                                  character string

%@AB@%clock%@AE@%                             Returns the elapsed CPU time for a 
                                  process

%@AB@%ctime%@AE@%                             Converts time from a long integer to a 
                                  character string

%@AB@%difftime%@AE@%                          Computes the difference between two 
                                  times

%@AB@%ftime%@AE@%                             Puts current system time in variable of 
                                  type%@AB@%%@AE@%
                                  %@AB@%struct tm%@AE@%

%@AB@%gmtime%@AE@%                            Converts time from integer to %@AB@%struct tm%@AE@%

%@AB@%localtime%@AE@%                         Converts time from integer to %@AB@%struct tm%@AE@% 
                                  with local correction

%@AB@%mktime%@AE@%                            Converts time to a calendar value

%@AB@%_strdate%@AE@%                          Returns the current system date as a 
                                  string

%@AB@%strftime%@AE@%                          Formats a date and time string

%@AB@%_strtime%@AE@%                          Returns the current system time as a 
                                  string

%@AB@%time%@AE@%                              Gets current system time as a long 
                                  integer

%@AB@%tzset%@AE@%                             Sets external time variables from the 
                                  environment time variable

%@AB@%utime%@AE@%                             Sets file-modification time

The %@AB@%time%@AE@% and %@AB@%ftime%@AE@% functions return the current time as the number of
seconds elapsed since midnight Universal Coordinated Time (UTC) on January
1, 1970. This value can be converted, adjusted, and stored in a variety of
ways by using the %@AB@%asctime%@AE@%, %@AB@%ctime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, and %@AB@%mktime%@AE@% functions.
The %@AB@%utime%@AE@% function sets the modification time for a specified file, using
either the current time or a time value stored in a structure.%@CR:C6A00020592 @%%@CR:C6A00020593 @%%@CR:C6A00020594 @%  %@NL@%
%@NL@%
The %@AB@%clock%@AE@% function returns the elapsed CPU time for the calling process.  %@NL@%
%@NL@%
The %@AB@%ftime%@AE@% function requires two files: SYS\TYPES.H and SYS\TIMEB.H. It is
declared in SYS\TIMEB.H. The %@AB@%utime%@AE@% function also requires two include files:
SYS\TYPES.H and SYS\UTIME.H. It is declared in SYS\UTIME.H. The remainder of
the time functions are declared in the include file TIME.H.%@CR:C6A00020595 @%%@CR:C6A00020596 @%%@CR:C6A00020597 @%%@CR:C6A00020598 @%%@CR:C6A00020599 @%  %@NL@%
%@NL@%
When you want to use %@AB@%ftime%@AE@% or %@AB@%localtime%@AE@% to make adjustments for local time,
you must define an environment variable named TZ. Section 3.2, which
describes the global variables %@AB@%daylight%@AE@%, %@AB@%timezone%@AE@%, and %@AB@%tzname%@AE@%, includes a
discussion of the TZ variable. TZ is also described on the %@AB@%tzset%@AE@% reference
page in Part 2 of this book.%@CR:C6A00020600 @%%@CR:C6A00020601 @%  %@NL@%
%@NL@%
The %@AB@%_strdate%@AE@% and %@AB@%_strtime%@AE@% routines return strings containing the current
date and time, respectively, in the DOS and OS/2 date and time format rather
than in the XENIX-style formats.  %@NL@%
%@NL@%
The %@AB@%stfrtime%@AE@% function is useful for creating international versions of a
program. See Section 2.8, "Internationalization."  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00020602 @%%@AB@%2.16  Variable-Length Argument Lists%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%va_arg%@AE@%, %@AB@%va_end%@AE@%, and %@AB@%va_start%@AE@% routines are macros that provide a portable
way to access the arguments to a function when the function takes a variable
number of arguments. Two versions of the macros are available: the macros
defined in the VARARG.H include file, which are compatible with the UNIX
System V definition, and the macros defined in STDARG.H, which conform to
the ANSI C standard.%@CR:C6A00020603 @%%@CR:C6A00020604 @%%@CR:C6A00020605 @%  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%va_arg%@AE@%                            Retrieves argument from list

%@AB@%va_end%@AE@%                            Resets pointer

%@AB@%va_start%@AE@%                          Sets pointer to beginning of argument 
                                  list

For more information on the differences between the two versions and for an
explanation of how to use the macros, see their descriptions in Part 2 of
this book.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@CR:C6A00030001 @%%@1@%%@AB@%Chapter 3  Global Variables and Standard Types%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
The Microsoft C Run-Time Library contains definitions for a number of
variables and standard types used by library routines. You can access these
variables and types by including in your program the files in which they are
declared, or by giving appropriate declarations in your program, as shown in
the following sections.%@CR:C6A00030002 @%%@CR:C6A00030003 @%  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00030004 @%%@AB@%3.1  _amblksiz%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_amblksiz%@AE@% variable controls memory heap granularity.%@CR:C6A00030005 @%%@CR:C6A00030006 @%  %@NL@%
%@NL@%
It is declared in the MALLOC.H include file as follows:  %@NL@%
%@NL@%
%@AS@%  extern unsigned int _amblksiz;%@AE@%%@NL@%
%@NL@%
The %@AB@%_amblksiz%@AE@% variable controls the amount of memory used in the heap for
dynamic memory allocation.%@CR:C6A00030007 @%  %@NL@%
%@NL@%
Memory space is always requested from the operating system in blocks
containing %@AB@%_amblksiz%@AE@% bytes. The first time a program calls a
memory-allocation function such as %@AB@%malloc%@AE@%, the operating system allocates a
block of heap memory. The size of this block is defined by %@AB@%_amblksiz%@AE@%, which
has a default value of 8K (8,192 bytes).  %@NL@%
%@NL@%
Later memory requests are satisfied from the original block. When that block
is exhausted, another block of %@AB@%_amblksiz%@AE@% bytes is allocated. If your C
program allocates a block larger than %@AB@%_amblksiz%@AE@%, multiple blocks that are
each of size %@AB@%_amblksiz%@AE@% are allocated until the request is satisfied.  %@NL@%
%@NL@%
To change the size of the default memory block, assign the desired size to
the %@AB@%_amblksiz%@AE@% variable, as in the following example:  %@NL@%
%@NL@%
%@AS@%  _amblksiz = 2048;%@AE@%%@NL@%
%@NL@%
The heap allocator always rounds the operating-system request to the nearest
power of 2 greater than or equal to %@AB@%_amblksiz%@AE@%. The above statement allocates
memory in multiples of 2K (2,048 bytes).  %@NL@%
%@NL@%
Fewer system calls are required if you set %@AB@%_amblksiz%@AE@% to a large value, but
your program may use more memory than needed. If program speed is important,
set %@AB@%_amblksiz%@AE@% to a large value. If size is important, set %@AB@%_amblksiz%@AE@% to a
smaller value.  %@NL@%
%@NL@%
Note that adjusting the value of %@AB@%_amblksiz%@AE@% affects allocation in the near,
far, and based heaps. The value of %@AB@%_amblksiz%@AE@% has no effect on huge memory
blocks (those allocated with %@AB@%halloc%@AE@% and similar functions).  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00030008 @%%@AB@%3.2  daylight, timezone, tzname%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%daylight%@AE@%, %@AB@%timezone%@AE@%, and %@AB@%tzname%@AE@% variables are global timezone variables
used in time functions.%@CR:C6A00030009 @%%@CR:C6A00030010 @%%@CR:C6A00030011 @%%@CR:C6A00030012 @%%@CR:C6A00030013 @%%@CR:C6A00030014 @%  %@NL@%
%@NL@%
They are declared in the TIME.H include files as follows:  %@NL@%
%@NL@%
%@AS@%  extern int daylight;%@AE@%%@NL@%
%@NL@%
%@AS@%  extern long timezone;%@AE@%%@NL@%
%@NL@%
%@AS@%  extern char *tzname [2];%@AE@%%@NL@%
%@NL@%
Some time and date routines use the %@AB@%daylight%@AE@%, %@AB@%timezone%@AE@%, and %@AB@%tzname%@AE@% variables
to make local-time adjustments. Whenever a program calls the %@AB@%ftime%@AE@%,
%@AB@%localtime%@AE@%, or %@AB@%tzset%@AE@% function, the value of %@AB@%daylight%@AE@%, %@AB@%timezone%@AE@%, and %@AB@%tzname%@AE@% is
determined from the value of the %@AB@%TZ%@AE@% environment variable. If you do not
explicitly set the value of %@AB@%TZ%@AE@%, the default value of PST8PDT is used. The
following list shows each variable and its value:%@CR:C6A00030015 @%%@CR:C6A00030016 @%  %@NL@%
%@NL@%
%@AB@%Variable%@AE@%                          %@AB@%Value%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%daylight%@AE@%                          Nonzero if a daylight-saving-time zone 
                                  (DST) is specified in %@AB@%TZ%@AE@%; otherwise 
                                  zero. Default value is one.

%@AB@%timezone%@AE@%                          Difference in seconds between Greenwich 
                                  mean time and the local time. Default 
                                  value is 28,800.

%@AB@%tzname[0]%@AE@%                         Three-letter time zone name derived from
                                  the %@AB@%TZ%@AE@% environment variable. Default 
                                  value is "PST" (Pacific standard time).

%@AB@%tzname[1]%@AE@%                         Three-letter daylight-saving-time zone 
                                  name derived from the %@AB@%TZ%@AE@% environment 
                                  variable. Default value is PDT. If the 
                                  DST zone is omitted from %@AB@%TZ%@AE@%, %@AB@%tzname[1]%@AE@% 
                                  is an empty string.

%@NL@%
%@2@%%@CR:C6A00030017 @%%@AB@%3.3  _doserrno, errno, sys_errlist, sys_nerr%@CR:C6A00030018 @% %@CR:C6A00030019 @%%@CR:C6A00030020 @%%@CR:C6A00030021 @% %@CR:C6A00030022 @% %@CR:C6A00030023 @%%@CR:C6A00030024 @% %@CR:C6A00030025 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_doserrno%@AE@%, %@AB@%errno%@AE@%, %@AB@%sys_errlist%@AE@%, and %@AB@%sys_nerr%@AE@% variables contain error
codes, and are used by the %@AB@%perror%@AE@% and %@AB@%_strerror%@AE@% routines to print error
information.  %@NL@%
%@NL@%
These variables are declared in the STDLIB.H include file. Manifest
constants for the %@AB@%errno%@AE@% variables are declared in the ERRNO.H include file.
The declarations are as follows:  %@NL@%
%@NL@%
%@AS@%  extern int _doserrno;%@AE@%%@NL@%
%@NL@%
%@AS@%  extern int errno;%@AE@%%@NL@%
%@NL@%
%@AS@%  extern char *sys_errlist[ ];%@AE@%%@NL@%
%@NL@%
%@AS@%  extern int sys_nerr;%@AE@%%@NL@%
%@NL@%
The %@AB@%errno%@AE@% variable is set to an integer value to reflect the type of error
that has occurred in a system-level call. Each %@AB@%errno%@AE@% value is associated
with an error message, which can be printed with the %@AB@%perror%@AE@% routine or
stored in a string with the %@AB@%strerror%@AE@% routine.  %@NL@%
%@NL@%
Note that only some routines set the %@AB@%errno%@AE@% variable. If a routine sets
%@AB@%errno%@AE@%, the description of the routine in the reference section says so
explicitly.  %@NL@%
%@NL@%
The value of %@AB@%errno%@AE@% reflects the error value for the last call that set
%@AB@%errno%@AE@%. However, this value is not necessarily reset by later successful
calls. To avoid confusion, test for errors immediately after a call.  %@NL@%
%@NL@%
The include file ERRNO.H contains the definitions of the %@AB@%errno%@AE@% values.
However, not all of the definitions given in ERRNO.H are used in DOS and
OS/2. Some of the values in ERRNO.H are present to maintain compatibility
with XENIX and UNIX operating systems.  %@NL@%
%@NL@%
The %@AB@%errno%@AE@% values in DOS and OS/2 are a subset of the values for %@AB@%errno%@AE@% in
XENIX systems. Thus, the %@AB@%errno%@AE@% value is not necessarily the same as the
actual error code returned by a DOS or OS/2 system call. To access the
actual DOS and OS/2 error code, use the %@AB@%_doserrno%@AE@% variable, which contains
this value.%@CR:C6A00030026 @%%@CR:C6A00030027 @%  %@NL@%
%@NL@%
In general, you should use %@AB@%_doserrno%@AE@% only for error detection in operations
involving input and output, since the %@AB@%errno%@AE@% values for input and output
errors have DOS and OS/2 error-code equivalents. In other cases, the value
of %@AB@%_doserrno%@AE@% is undefined.  %@NL@%
%@NL@%
The %@AB@%syserrlist%@AE@% variable is an array; the %@AB@%perror%@AE@% and %@AB@%strerror%@AE@% routines use it
to process error information. The %@AB@%sys_nerr%@AE@% variable tells how many elements
the %@AB@%sys_errlist%@AE@% array contains.  %@NL@%
%@NL@%
Table 3.1 gives the %@AB@%errno%@AE@% values for DOS and OS/2, the system error message
for each value, and the value of each constant. Note that only the %@AB@%ERANGE%@AE@%
and %@AB@%EDOM%@AE@% constants are specified in the ANSI standard.  %@NL@%
%@NL@%
%@AB@%Table   3.1 errno Values and Their Meanings%@AE@%

%@TH:  32  1783 02 12 59 07 @%Constant    Meaning                                                    Value%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%E2BIG%@AE@%       Argument list too long %@CR:C6A00030028 @%                                    7%@AB@%EACCES%@AE@%      Permission denied %@CR:C6A00030029 @%                                         13%@AB@%EBADF%@AE@%       Bad file number %@CR:C6A00030030 @%                                           9%@AB@%EDEADLOCK%@AE@%   Resource deadlock would occur %@CR:C6A00030031 @%                             36%@AB@%EDOM%@AE@%        Math argument %@CR:C6A00030032 @%                                             33%@AB@%EEXIST%@AE@%      File exists %@CR:C6A00030033 @%                                               17%@AB@%EINVAL%@AE@%      Invalid argument %@CR:C6A00030034 @%                                          22%@AB@%EMFILE%@AE@%      Too many open files %@CR:C6A00030035 @%                                       24%@AB@%ENOENT%@AE@%      No such file or directory %@CR:C6A00030036 @%                                 2%@AB@%ENOEXEC%@AE@%     Exec format error %@CR:C6A00030037 @%                                         8%@AB@%ENOMEM%@AE@%      Not enough memory %@CR:C6A00030038 @%                                         12%@AB@%ENOSPC%@AE@%      No space left on device %@CR:C6A00030039 @%                                   28%@AB@%ERANGE%@AE@%      Result too large %@CR:C6A00030040 @%                                          34%@AB@%EXDEV%@AE@%       Cross-device link %@CR:C6A00030041 @%                                         18%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  32  1783 02 12 59 07 @%

%@NL@%
%@2@%%@CR:C6A00030042 @%%@AB@%3.4  _fmode%@CR:C6A00030043 @%%@CR:C6A00030044 @% %@CR:C6A00030045 @%%@CR:C6A00030046 @% %@CR:C6A00030047 @%%@CR:C6A00030048 @%%@CR:C6A00030049 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_fmode%@AE@% variable controls the default file-translation mode.  %@NL@%
%@NL@%
It is declared in the STDLIB.H include file as follows:  %@NL@%
%@NL@%
%@AS@%  extern int _fmode;%@AE@%%@NL@%
%@NL@%
By default, the value of %@AB@%_fmode%@AE@% is %@AB@%O_TEXT%@AE@%, causing files to be translated in
text mode (unless specifically opened or set to binary mode). When %@AB@%_fmode%@AE@% is
set to %@AB@%O_BINARY%@AE@%, the default mode is binary. You can set %@AB@%_fmode%@AE@% to the flag
%@AB@%O_BINARY%@AE@% by linking with BINMODE.OBJ or by assigning it the %@AB@%O_BINARY %@AE@%value.
%@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00030050 @%%@AB@%3.5  _osmajor, _osminor, _osmode, _osversion%@CR:C6A00030051 @% %@CR:C6A00030052 @%%@CR:C6A00030053 @% %@CR:C6A00030054 @% %@CR:C6A00030055 @%%@CR:C6A00030056 @% %@CR:C6A00030057 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_osmajor%@AE@%, %@AB@%_osminor%@AE@%, %@AB@%_osmode%@AE@%, and %@AB@%_osversion%@AE@% variables specify the
version number of the operating system or the current mode of operation.  %@NL@%
%@NL@%
They are declared in the STDLIB.H include file as follows:  %@NL@%
%@NL@%
%@AS@%  extern unsigned char _osmajor;%@AE@%%@NL@%
%@NL@%
%@AS@%  extern unsigned char _osminor;%@AE@%%@NL@%
%@NL@%
%@AS@%  extern unsigned char _osmode;%@AE@%%@NL@%
%@NL@%
%@AS@%  extern unsigned char _osversion;%@AE@%%@NL@%
%@NL@%
The %@AB@%_osmajor%@AE@%, %@AB@%_osminor%@AE@%, and %@AB@%_osversion%@AE@% variables specify the version number
of DOS or OS/2 currently in use. The %@AB@%_osmajor%@AE@% variable holds the "major"
version number and the %@AB@%_osminor%@AE@% variable stores the "minor" version number.
Thus, under DOS version 3.20, %@AB@%_osmajor%@AE@% is 3 and %@AB@%_osminor%@AE@% is 20. The %@AB@%
%@AB@%_osversion%@AE@% variable holds both values; its low byte contains the major
version number and its high byte the minor version number.  %@NL@%
%@NL@%
These variables are useful for creating programs that run in different
versions of DOS and OS/2. For example, you can test the %@AB@%_osmajor%@AE@% variable
before making a call to %@AB@%sopen%@AE@%; if the major version number is earlier (less)
than 3, %@AB@%open%@AE@% should be used instead of %@AB@%sopen%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_osmode%@AE@% variable indicates whether the program is in OS/2 protected mode
or in real mode (DOS or OS/2 real mode). An %@AB@%_osmode%@AE@% value of %@AB@%DOS_MODE%@AE@%
indicates real mode operation and a value of %@AB@%OS2_MODE%@AE@% indicates protected
operation.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00030058 @%%@AB@%3.6  environ%@CR:C6A00030059 @%%@CR:C6A00030060 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%environ%@AE@% variable is a pointer to the strings in the process environment.
%@NL@%
%@NL@%
It is declared in the STDLIB.H include file as follows:  %@NL@%
%@NL@%
%@AS@%  extern char *environ [ ];%@AE@%%@NL@%
%@NL@%
The %@AB@%environ%@AE@% variable provides access to memory areas containing
process-specific information.  %@NL@%
%@NL@%
The %@AB@%environ%@AE@% variable is an array of pointers to the strings that constitute
the process environment. The environment consists of one or more entries of
the form%@CR:C6A00030061 @%  %@NL@%
%@NL@%
%@AB@%NAME%@AE@%=%@AI@%string%@AE@%  %@NL@%
%@NL@%
where %@AB@%NAME %@AE@%is the name of an environment variable and %@AI@%string %@AE@%is the value of
that variable. The string may be empty. The initial environment settings are
taken from the operating-system environment at the time of program
execution.  %@NL@%
%@NL@%
The %@AB@%getenv%@AE@% and %@AB@%putenv%@AE@% routines use the %@AB@%environ%@AE@% variable to access and modify
the environment table. When %@AB@%putenv%@AE@% is called to add or delete environment
settings, the environment table changes size; its location in memory may
also change, depending on the program's memory requirements. The %@AB@%environ%@AE@%
variable is adjusted in these cases and always points to the correct table
location.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00030062 @%%@AB@%3.7  _psp%@CR:C6A00030063 @%%@CR:C6A00030064 @%%@CR:C6A00030065 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_psp%@AE@% variable contains the segment address of the program segment prefix
(PSP) for the process.  %@NL@%
%@NL@%
It is declared in the STDLIB.H include file as follows:  %@NL@%
%@NL@%
%@AS@%  extern unsigned int _psp;%@AE@%%@NL@%
%@NL@%
The PSP contains execution information about the process, such as a copy of
the command line that invoked the process and the return address on process
termination or interrupt. The %@AB@%_psp%@AE@% variable can be used to form a long
pointer to the PSP, where %@AB@%_psp%@AE@% is the segment value and 0 is the offset
value.%@CR:C6A00030066 @%  %@NL@%
%@NL@%
Note that the %@AB@%_psp%@AE@% variable is supported only in DOS.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00030067 @%%@AB@%3.8  Standard Types%@AE@%%@EH@%%@NL@%
%@NL@%
A number of library routines use values whose types are defined in include
files. In the following list, these types are described, and the include
file defining each type is given.%@CR:C6A00030068 @%  %@NL@%
%@NL@%
%@AB@%Standard Type%@AE@%                     %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%clock_t%@AE@%                           The %@AB@%clock_t%@AE@% type, defined in TIME.H, 
                                  stores time values. It is used by the %@AB@%%@AE@%
                                  %@AB@%clock%@AE@% function. %@CR:C6A00030069 @%%@CR:C6A00030070 @%

%@AB@%complex%@AE@%                           The %@AB@%complex%@AE@% structure, defined in 
                                  MATH.H, stores the real and imaginary 
                                  parts of complex numbers. It is used by 
                                  the %@AB@%cabs%@AE@% function. %@CR:C6A00030071 @%%@CR:C6A00030072 @%

%@AB@%diskfree_t%@AE@%                        The %@AB@%diskfree_t%@AE@% structure, defined in 
                                  DOS.H, stores disk information used by 
                                  the %@AB@%_dos_getdiskfree%@AE@% routine. %@CR:C6A00030073 @%%@CR:C6A00030074 @%

%@AB@%diskinfo_t%@AE@%                        The %@AB@%diskinfo_t%@AE@% structure, defined in 
                                  BIOS.H, records information about disk 
                                  drives returned by the %@AB@%_bios_disk%@AE@% 
                                  routine. %@CR:C6A00030075 @%%@CR:C6A00030076 @%

%@AB@%div_t%@AE@%, %@AB@%ldiv_t%@AE@%                     The %@AB@%div_t%@AE@% and %@AB@%ldiv_t%@AE@% structures, defined
                                  in STDLIB.H, store the values returned 
                                  by the %@AB@%div%@AE@% and %@AB@%ldiv%@AE@% functions, 
                                  respectively. %@CR:C6A00030077 @%%@CR:C6A00030078 @%%@CR:C6A00030079 @%%@CR:C6A00030080 @%

%@AB@%dosdate_t%@AE@%                         The %@AB@%dosdate_t%@AE@% structure, defined in 
                                  DOS.H, records the current system date 
                                  used in the %@AB@%_dos_getdate%@AE@% and %@AB@%%@AE@%
                                  %@AB@%_dos_setdate%@AE@% routines. %@CR:C6A00030081 @%

%@AB@%dostime_t%@AE@%                         The %@AB@%dostime_t%@AE@% structure, defined in 
                                  DOS.H, records the current system time 
                                  used in the %@AB@%_dos_gettime%@AE@% and %@AB@%%@AE@%
                                  %@AB@%_dos_settime%@AE@% routines. %@CR:C6A00030082 @%%@CR:C6A00030083 @%

%@AB@%DOSERROR%@AE@%                          The %@AB@%DOSERROR%@AE@% structure, defined in 
                                  DOS.H, stores values returned by DOS 
                                  system call 59H (available under DOS 
                                  versions 3.0 and later). %@CR:C6A00030084 @%%@CR:C6A00030085 @%

%@AB@%exception%@AE@%                         The %@AB@%exception%@AE@% structure, defined in 
                                  MATH.H, stores error information for 
                                  math routines. It is used by the %@AB@%matherr%@AE@%
                                  routine. %@CR:C6A00030086 @%%@CR:C6A00030087 @%

%@AB@%FILE%@AE@%                              The %@AB@%FILE%@AE@% structure, defined in STDIO.H, 
                                  is the structure used in all stream 
                                  input and output operations. The fields 
                                  of the %@AB@%FILE%@AE@% structure store information 
                                  about the current state of the stream. %@CR:C6A00030088 @%%@CR:C6A00030089 @%

%@AB@%find_t%@AE@%                            The %@AB@%find_t%@AE@% structure, defined in DOS.H, 
                                  stores file-attribute information 
                                  returned by the %@AB@%_dos_findfirst%@AE@% and %@AB@%%@AE@%
                                  %@AB@%_dos_findnext%@AE@% routines. %@CR:C6A00030090 @%%@CR:C6A00030091 @%

%@AB@%fpos_t%@AE@%                            The %@AB@%fgetpos%@AE@% and %@AB@%fsetpos%@AE@% functions use 
                                  the %@AB@%fpos_t%@AE@% object type, defined in 
                                  STDIO.H, to record all the information 
                                  necessary to uniquely specify every 
                                  position within the file. %@CR:C6A00030092 @%%@CR:C6A00030093 @%

%@AB@%jmp_buf%@AE@%                           The %@AB@%jmp_buf%@AE@% type, defined in SETJMP.H, 
                                  is an array type rather than a structure
                                  type. A buffer of this type is used by 
                                  the %@AB@%setjmp%@AE@% and %@AB@%longjmp%@AE@% routines to save 
                                  and restore the program 
                                  environment. %@CR:C6A00030094 @%%@CR:C6A00030095 @%

%@AB@%lconv%@AE@%                             The %@AB@%lconv%@AE@% type is a structure containing
                                  formatting rules for numeric values in 
                                  different countries. It is defined in 
                                  LOCALE.H.

%@AB@%onexit_t%@AE@%                          The %@AB@%onexit%@AE@% routine is declared as an %@AB@%%@AE@%
                                  %@AB@%onexit_t%@AE@% pointer type, which is defined 
                                  in STDLIB.H.

%@AB@%ptrdiff_t%@AE@%                         The %@AB@%ptrdiff_t%@AE@% type is used for the 
                                  signed integral result of the 
                                  subtraction of two pointers.

%@AB@%REGS%@AE@%                              The %@AB@%REGS %@AE@%union, defined in DOS.H, stores
                                  byte and word register values to be 
                                  passed to and returned from calls to the
                                  DOS interface functions. %@CR:C6A00030096 @%%@CR:C6A00030097 @%

%@AB@%sig_atomic_t%@AE@%                      The %@AB@%sig_atomic_t%@AE@% type, defined in 
                                  SIGNAL.H, is the integral type of an 
                                  object that can be modified as an atomic
                                  entity, even in the presence of 
                                  asynchronous interrupts. It is used in 
                                  conjunction with the %@AB@%signal%@AE@% routine.

%@AB@%size_t%@AE@%                            The %@AB@%size_t%@AE@% type, defined in STDDEF.H and
                                  several other include files, is the 
                                  unsigned integral result of the %@AB@%sizeof%@AE@% 
                                  operator. %@CR:C6A00030098 @%%@CR:C6A00030099 @%

%@AB@%SREGS%@AE@%                             The %@AB@%SREGS%@AE@% structure, defined in DOS.H, 
                                  stores the values of the ES, CS, SS, and
                                  DS registers. This structure is used by 
                                  the DOS interface functions that require
                                  segment register values (%@AB@%int86x%@AE@%, %@AB@%intdosx%@AE@%
                                  , and %@AB@%segread%@AE@%). %@CR:C6A00030100 @%%@CR:C6A00030101 @%

%@AB@%stat%@AE@%                              The %@AB@%stat%@AE@% structure, defined in 
                                  SYS\STAT.H, contains file-status 
                                  information returned by the %@AB@%stat%@AE@% and %@AB@%%@AE@%
                                  %@AB@%fstat%@AE@% routines. %@CR:C6A00030102 @%

%@AB@%time_t%@AE@%                            The %@AB@%time_t%@AE@% type, defined in TIME.H, 
                                  represents time values in the %@AB@%mktime%@AE@% and
                                  %@AB@%time%@AE@% routines. %@CR:C6A00030103 @%%@CR:C6A00030104 @%

%@AB@%timeb%@AE@%                             The %@AB@%timeb%@AE@% structure, defined in 
                                  SYS\TIMEB.H, is used by the %@AB@%ftime%@AE@% 
                                  routine to store the current system 
                                  time. %@CR:C6A00030105 @%%@CR:C6A00030106 @%

%@AB@%tm%@AE@%                                The %@AB@%tm%@AE@% structure, defined in TIME.H, is 
                                  used by the %@AB@%asctime%@AE@%, %@AB@%gmtime%@AE@%, and %@AB@%%@AE@%
                                  %@AB@%localtime%@AE@% functions to store and 
                                  retrieve time information. %@CR:C6A00030107 @%%@CR:C6A00030108 @%

%@AB@%utimbuf%@AE@%                           The %@AB@%utimbuf%@AE@% structure, defined in 
                                  SYS\UTIME.H, stores file access and 
                                  modification times used by the %@AB@%utime%@AE@% 
                                  function to change file-modification 
                                  dates. %@CR:C6A00030109 @%%@CR:C6A00030110 @%

%@AB@%va_list%@AE@%                           The %@AB@%va_list%@AE@% array type, defined in 
                                  STDARG.H, is used to hold information 
                                  needed by the %@AB@%va_arg%@AE@% macro and the %@AB@%%@AE@%
                                  %@AB@%va_end%@AE@% routine. The called function 
                                  declares a variable of type %@AB@%va_list%@AE@%, 
                                  which may be passed as an argument to 
                                  another function. %@CR:C6A00030111 @%%@CR:C6A00030112 @% 

%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@CR:C6A-Part 02 @%%@1@%%@AB@%PART II  Run-Time Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
The second part of this book is the reference section. It describes, in
alphabetical order, each function of the run-time library provided with the
Microsoft C Professional Development System.  %@NL@%
%@NL@%
Each reference entry gives syntax, return values, and other useful
information about the library functions. Information on compatibility is
supplied to assist you in writing portable programs.  %@NL@%
%@NL@%
%@NL@%
%@2@%%@CR:C6A00030113 @%%@AB@%About the Run-Time Reference%@AE@%%@EH@%%@NL@%
%@NL@%
The following pages describe, in alphabetical order, the more than 400
functions in the Microsoft run-time library. In some cases, related routines
are clustered in the same description. For example, the based, near, and far
versions of %@AB@%_heapwalk %@AE@%are in the same discussion, as are the regular and
long double versions of the math functions, such as %@AB@%acos%@AE@% and %@AB@%atan%@AE@%.
Differences are noted where appropriate. Refer to Chapter 2, "Run-Time
Routines by Category," or to the index to locate any function that does not
appear in the expected position within the alphabetical reference.  %@NL@%
%@NL@%
The discussion of each function (or group of functions) is divided into the
following sections:  %@NL@%
%@NL@%
%@NL@%
  ş   %@AB@%%@AE@%%@AI@%Description%@AE@%. Summarizes the routine's effect, names the include
      file(s) containing its declaration, illustrates the syntax, and
      briefly describes the arguments.%@NL@%
%@NL@%
  ş   %@AB@%%@AE@%%@AI@%Remarks%@AE@%. Gives a more detailed description of the routine and how it
      is used.%@NL@%
%@NL@%
  ş   %@AB@%%@AE@%%@AI@%Return Value%@AE@%. Describes the value returned by the routine.%@NL@%
%@NL@%
  ş   %@AB@%%@AE@%%@AI@%Compatibility.%@AE@% Tells whether the routine is compatible with ANSI C,
      MS-DOS, OS/2, UNIX, and XENIX.%@NL@%
%@NL@%
  ş   %@AB@%%@AE@%%@AI@%See Also%@AE@%. Names related routines.%@NL@%
%@NL@%
  ş   %@AB@%%@AE@%%@AI@%Example%@AE@%. Gives a complete program showing the use of the routine. %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:abort@%%@NL@%
%@2@%%@CR:C6A00050114 @%%@AB@%abort%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00050115 @%%@CR:C6A00050116 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Aborts the current process and returns an error code.  %@NL@%
%@NL@%
%@AB@%#include <process.h>%@AE@%              Required only for function declarations;
%@AB@%#include <stdlib.h>%@AE@%               use either PROCESS.H or STDLIB.H

%@AS@%  void abort( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%abort%@AE@% function prints the message  %@NL@%
%@NL@%
%@AS@%  abnormal program termination%@AE@%%@NL@%
%@NL@%
to %@AB@%stderr%@AE@%, then calls %@AB@%raise(SIGABRT)%@AE@%. The action taken in response to the
%@AB@%SIGABRT%@AE@% signal depends on what action has been defined for that signal in a
prior call to the %@AB@%signal%@AE@% function. The default %@AB@%SIGABRT%@AE@% action is for the
calling process to terminate with exit code 3, returning control to the
parent process or operating system.  %@NL@%
%@NL@%
The %@AB@%abort%@AE@% function does not flush stream buffers or do %@AB@%atexit%@AE@%/%@AB@%onexit%@AE@%
processing.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%abort%@AE@% function does not return control to the caller. Rather, it
terminates the process and, by default, returns an exit code of 3 to the
parent process.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
In multithread libraries, the %@AB@%abort %@AE@%function does not call %@AB@%raise%@AE@%(%@AB@%SIGABRT)%@AE@%.
Instead, it simply terminates the process with exit code 3.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%exec%@AE@% functions, %@AB@%exit%@AE@%, %@AB@%_exit%@AE@%, %@AB@%raise%@AE@%, %@AB@%signal%@AE@%, %@AB@%spawn%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ABORT.C:  This tries to open a file and aborts if the attempt fails. */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%  
%@AS@%     FILE *stream;
%@AS@%  
%@AS@%     if( (stream = fopen( "NOSUCHF.ILE", "r" )) == NULL )
%@AS@%     {
%@AS@%        perror( "Couldn't open file" );
%@AS@%        abort();
%@AS@%     }
%@AS@%     else
%@AS@%        fclose( stream );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Couldn't open file: No such file or directory
%@AS@%  
%@AS@%  abnormal program termination
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:abs@%%@NL@%
%@2@%%@CR:C6A00060117 @%%@AB@%abs%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00060118 @%%@CR:C6A00060119 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculates the absolute value.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%%@AB@%%@AE@%               Required only for function declarations;
%@AB@%#include <math.h>%@AE@%                 use either STDLIB.H or MATH.H

%@AS@%  int abs( int n );%@AE@%%@NL@%
%@NL@%
%@AI@%n%@AE@%                                 Integer value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%abs%@AE@% function returns the absolute value of its integer argument %@AI@%n%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%abs%@AE@% function returns the absolute value of its argument. There is no
error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cabs%@AE@%, %@AB@%fabs%@AE@%, %@AB@%labs%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ABS.C: This program computes and displays the absolute values of
%@AS@%   * several numbers.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <math.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int    ix = -4, iy;
%@AS@%     long   lx = -41567L, ly;
%@AS@%     double dx = -3.141593, dy;
%@AS@%  
%@AS@%     iy = abs( ix );
%@AS@%     printf( "The absolute value of %d is %d\n", ix, iy);
%@AS@%  
%@AS@%     ly = labs( lx );
%@AS@%     printf( "The absolute value of %ld is %ld\n", lx, ly);
%@AS@%  
%@AS@%     dy = fabs( dx );
%@AS@%     printf( "The absolute value of %f is %f\n", dx, dy );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The absolute value of -4 is 4
%@AS@%  The absolute value of -41567 is 41567
%@AS@%  The absolute value of -3.141593 is 3.141593 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:access@%%@NL@%
%@2@%%@CR:C6A00070120 @%%@AB@%access%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00070121 @%%@CR:C6A00070122 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Determines file-access permission.  %@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AB@%#include <errno.h>%@AE@%                Required for definition of %@AB@%errno%@AE@% 
                                  constants

%@AS@%  int access( char *pathname, int mode );%@AE@%%@NL@%
%@NL@%
%@AI@%pathname%@AE@%                          File or directory path name

%@AI@%mode%@AE@%                              Permission setting

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
With files, the %@AB@%access%@AE@% function determines whether the specified file exists
and can be accessed in %@AI@%mode%@AE@%. The possible mode values and their meanings in
the %@AB@%access%@AE@% call are as follows: %@CR:C6A00070123 @%  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
00                                Check for existence only

02                                Check for write permission

04                                Check for read permission

06                                Check for read and write permission

With directories, %@AB@%access%@AE@% determines only whether the specified directory
exists; under DOS and OS/2, all directories have read and write access.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%access%@AE@% function returns the value 0 if the file has the given mode. A
return value of -1 indicates that the named file does not exist or is not
accessible in the given mode, and %@AB@%errno%@AE@% is set to one of the following
values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Access denied: the file's permission 
                                  setting does not allow the specified 
                                  access.

%@AB@%ENOENT%@AE@%                            File or path name not found.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%chmod%@AE@%, %@AB@%fstat%@AE@%, %@AB@%open%@AE@%, %@AB@%stat%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ACCESS.C: This example uses access to check the file named "data"
%@AS@%   * to see if it exists and if writing is allowed.
%@AS@%   */
%@AS@%  
%@AS@%  #include <io.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Check for existence */
%@AS@%     if( (access( "access.c", 0 )) != -1 )
%@AS@%     {
%@AS@%        printf( "File exists\n" );
%@AS@%  
%@AS@%        /* Check for write permission */
%@AS@%        if( (access( "access.c", 2 )) != -1 )
%@AS@%           printf( "File has write permission\n" );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  File exists
%@AS@%  File has write permission%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:acos@%%@NL@%
%@2@%%@CR:C6A00080124 @%%@AB@%acos Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00080125 @%%@CR:C6A00080126 @% %@CR:C6A00080127 @%%@CR:C6A00080128 @%%@CR:C6A00080129 @%%@CR:C6A00080130 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate the arccosine.  %@NL@%
%@NL@%
%@AB@%#include <math.h>%@AE@%  %@NL@%
%@NL@%
%@AB@%#include <errno.h>%@AE@%                Required for definition of %@AB@%errno%@AE@% 
                                  constant

%@AS@%  double acos( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double acosl( long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Value whose arccosine is to be 
                                  calculated

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%acos%@AE@% functions return the arccosine of %@AI@%x%@AE@% in the range 0 to ã radians.
The value of %@AI@%x%@AE@% must be between -1 and 1. The %@AB@%acosl%@AE@% function is the 80-bit
counterpart, which uses an 80-bit, 10-byte coprocessor form of arguments and
return values. See the reference page on the long double functions for more
details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%acos%@AE@% functions return the arccosine result. If %@AI@%x%@AE@% is less than -1 or
greater than 1, the function sets %@AB@%errno%@AE@% to %@AB@%EDOM%@AE@%, prints a %@AB@%DOMAIN %@AE@%error
message to %@AB@%stderr%@AE@%, and returns 0. Error handling can be modified with the
%@AB@%matherr%@AE@% (or %@AB@%_matherrl%@AE@%) routine.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%acos%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%acosl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asin%@AE@% functions, %@AB@%atan%@AE@% functions, %@AB@%cos%@AE@% functions, %@AB@%matherr%@AE@%, %@AB@%sin%@AE@% functions, %@AB@%tan%@AE@%
functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ASINCOS.C: This program prompts for a value in the range -1 to 1.
%@AS@%   * Input values outside this range will produce DOMAIN error messages.
%@AS@%   * If a valid value is entered, the program prints the arcsine and the
%@AS@%   * arccosine of that value.
%@AS@%   */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <errno.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     double x, y;
%@AS@%  
%@AS@%     printf( "Enter a real number between -1 and 1: " );
%@AS@%     scanf( "%lf", &x );
%@AS@%     y = asin( x );
%@AS@%     printf( "Arcsine of %f = %f\n", x, y );
%@AS@%     y = acos( x );
%@AS@%     printf( "Arccosine of %f = %f\n", x, y );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Enter a real number between -1 and 1: .32696
%@AS@%  Arcsine of 0.326960 = 0.333085
%@AS@%  Arccosine of 0.326960 = 1.237711%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:alloca@%%@NL@%
%@2@%%@CR:C6A00090131 @%%@AB@%alloca%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00090132 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Allocates memory on the stack.  %@NL@%
%@NL@%
%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  void *alloca( size_t size );%@AE@%%@NL@%
%@NL@%
%@AI@%size%@AE@%                              Bytes to be allocated from stack

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%alloca%@AE@% routine allocates %@AI@%size%@AE@% bytes from the program's stack. The
allocated space is automatically freed when the calling function is exited.
%@NL@%
%@NL@%
When you compile with optimization on (either by default or by using one of
the /O options), the stack pointer may not be restored properly in functions
that have no local variables and that also reference the %@AB@%alloca%@AE@% function.
The following program demonstrates the problem:  %@NL@%
%@NL@%
%@AS@%  /* Compile with CL /Lp /AM /Ox /Fc */
%@AS@%  #include <malloc.h>
%@AS@%  
%@AS@%  void main( void )
%@AS@%  {
%@AS@%     func( 10 );
%@AS@%  }
%@AS@%  void func( register int i )
%@AS@%  {
%@AS@%     alloca( i );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
To ensure that the stack pointer is properly restored, make sure that any
function referencing %@AB@%alloca%@AE@% declares at least one local variable.  %@NL@%
%@NL@%
The pointer value returned by %@AB@%alloca%@AE@% should never be passed as an argument
to %@AB@%free%@AE@%, nor should %@AB@%alloca%@AE@% be used in an expression that is an argument to a
function.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%alloca%@AE@% routine returns a %@AB@%void%@AE@% pointer to the allocated space, which is
guaranteed to be suitably aligned for storage of any type of object. To get
a pointer to a type other than %@AB@%char%@AE@%, use a type cast on the return value.
The return value is %@AB@%NULL%@AE@% if the space cannot be allocated.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%calloc%@AE@% functions, %@AB@%malloc%@AE@% functions, %@AB@%realloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ALLOCA.C: This program checks the stack space available before
%@AS@%   * and after using the alloca function to allocate space on the stack.
%@AS@%   */
%@AS@%  
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *buffer;
%@AS@%  
%@AS@%     printf( "Bytes available on stack: %u\n", stackavail() );
%@AS@%  
%@AS@%     /* Allocate memory for string. */
%@AS@%     buffer = alloca( 120 * sizeof( char ) );
%@AS@%     printf( "Enter a string: " );
%@AS@%     gets( buffer );
%@AS@%     printf( "You entered: %s\n", buffer );
%@AS@%  
%@AS@%     printf( "Bytes available on stack: %u\n", stackavail() );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Bytes available on stack: 2028
%@AS@%  Enter a string: How much stack space will this string take?
%@AS@%  You entered: How much stack space will this string take?
%@AS@%  Bytes available on stack: 1902%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_arc@%%@NL@%
%@2@%%@CR:C6A00100133 @%%@AB@%_arc Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00100134 @%%@CR:C6A00100135 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Draw elliptical arcs.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _arc( short x1, short y1, short x2, short y2, short x3, 
%@AS@%    short y3, short x4, short y4 );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _arc_w( double x1, double y1, double x2, double y2, double x3, 
%@AS@%    double y3, double x4, double y4 );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _arc_wxy( struct _wxycoord _far *pwxy1, 
%@AS@%    struct _wxycoord _far *pwxy2, 
%@AS@%    struct _wxycoord _far *pwxy3, struct _wxycoord _far *pwxy4);%@AE@%%@NL@%
%@NL@%
%@AI@%x1%@AE@%, %@AI@%y1%@AE@%                            Upper-left corner of bounding rectangle

%@AI@%x2%@AE@%, %@AI@%y2%@AE@%                            Lower-right corner of bounding rectangle

%@AI@%x3%@AE@%, %@AI@%y3%@AE@%                            Second point of start vector (center of 
                                  bounding rectangle is first point)

%@AI@%x4%@AE@%, %@AI@%y4%@AE@%                            Second point of end vector (center of 
                                  bounding rectangle is first point)

%@AI@%pwxy1%@AE@%                             Upper-left corner of bounding rectangle

%@AI@%pwxy2%@AE@%                             Lower-right corner of bounding rectangle

%@AI@%pwxy3%@AE@%                             Second point of start vector (center of 
                                  bounding rectangle is first point)

%@AI@%pwxy4%@AE@%                             Second point of end vector (center of 
                                  bounding rectangle is first point)

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_arc%@AE@% functions draw elliptical arcs. The center of the arc is the center
of the bounding rectangle, which is defined by points (%@AI@%x1%@AE@%, %@AI@%y1%@AE@%) and (%@AI@%x2%@AE@%,%@AI@% y2%@AE@%)
for%@AB@% _arc%@AE@% and %@AB@%_arc_w%@AE@% and by points%@AB@% %@AE@%%@AI@%pwxy1%@AE@% and %@AI@%pwxy2%@AE@% for%@AB@% _arc_wxy%@AE@%. The arc
starts where it intersects an imaginary line extending from the center of
the arc through (%@AI@%x3%@AE@%,%@AI@% y3%@AE@%) for %@AB@%_arc%@AE@% and%@AB@% _arc_w%@AE@% and through %@AI@%pwxy3%@AE@% for %@AB@%_arc_wxy%@AE@%.
It is drawn counterclockwise about the center of the arc, ending where it
intersects an imaginary line extending from the center of the arc through
(%@AI@%x4%@AE@%,%@AI@% y4%@AE@%) for %@AB@%_arc %@AE@% and %@AB@%_arc_w%@AE@% and through %@AI@%pwxy4%@AE@% for %@AB@%_arc_wxy%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_arc%@AE@% routine uses the view coordinate system. The %@AB@%_arc_w%@AE@% and %@AB@%_arc_wxy%@AE@%
functions use the real-valued window coordinate system.  %@NL@%
%@NL@%
In each case, the arc is drawn using the current color. Since an arc does
not define a closed area, it is not filled.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return a nonzero value if the arc is successfully drawn;
otherwise, they return 0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_ellipse%@AE@% functions, %@AB@% _lineto%@AE@% functions, %@AB@% _pie%@AE@% functions, %@AB@% _rectangle%@AE@%
functions,  %@AB@%_setcolor%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ARC.C: This program draws a simple arc. */
%@AS@%  
%@AS@%  #include <graph.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <conio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short x, y;
%@AS@%     struct xycoord xystart, xyend, xyfill;
%@AS@%  
%@AS@%     /* Find a valid graphics mode */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     /* Draw arcs         */
%@AS@%     x = 100; y = 100;
%@AS@%     _arc( x - 60, y - 60, x, y, x - 30, y - 60, x - 60, y - 30 );
%@AS@%     _arc( x + 60, y + 60, x, y, x,      y + 30, x + 30, y );
%@AS@%  
%@AS@%     /* Get endpoints of second arc and enclose the figure, then fill it. */
%@AS@%     _getarcinfo( &xystart, &xyend, &xyfill );
%@AS@%     _moveto( xystart.xcoord, xystart.ycoord );
%@AS@%     _lineto( xyend.xcoord,   xyend.ycoord );
%@AS@%     _floodfill( xyfill.xcoord, xyfill.ycoord, _getcolor() );
%@AS@%  
%@AS@%     getch();
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:asctime@%%@NL@%
%@2@%%@CR:C6A00110136 @%%@AB@%asctime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00110137 @%%@CR:C6A00110138 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Converts a %@AB@%tm%@AE@% time structure to a character string.  %@NL@%
%@NL@%
%@AS@%  #include <time.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char *asctime( const struct tm *timeptr );%@AE@%%@NL@%
%@NL@%
%@AI@%timeptr%@AE@%                           Time/date structure

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%asctime%@AE@% function converts a time stored as a structure to a character
string. The %@AI@%timeptr%@AE@% value is usually obtained from a call to %@AB@%gmtime%@AE@% or
%@AB@%localtime%@AE@%, both of which return a pointer to a %@AB@%tm%@AE@% structure, defined in
TIME.H. (See %@AB@%gmtime%@AE@% for a complete description of the %@AB@%tm%@AE@% structure fields.) %@CR:C6A00110139 @%
%@NL@%
%@NL@%
The %@AB@%tm%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%int tm_sec%@AE@%                        Seconds after the minute (0 -59)

%@AB@%int tm_min%@AE@%                        Minutes after the hour (0 -59)

%@AB@%int%@AE@% %@AB@%tm_hour%@AE@%                       Hours since midnight (0 -23)

%@AB@%int%@AE@% %@AB@%tm_mday%@AE@%                       Day of the month (0 -31)

%@AB@%int tm_mon%@AE@%                        Months since January (0 -11)

%@AB@%int tm_year%@AE@%                       Years since 1900

%@AB@%int tm_wday%@AE@%                       Days since Sunday (0 - 6)

%@AB@%int%@AE@% %@AB@%tm_yday%@AE@%                       Days since January 1 (0 -365)

%@AB@%int tm_isdst%@AE@%                      Daylight-saving-time flag

The string result produced by %@AB@%asctime%@AE@% contains exactly 26 characters and has
the form of the following example:  %@NL@%
%@NL@%
%@AS@%  Wed Jan 02 02:03:55 1980\n\0%@AE@%%@NL@%
%@NL@%
A 24-hour clock is used. All fields have a constant width. The newline
character (%@AB@%\n%@AE@%) and the null character (%@AB@%'\0'%@AE@%) occupy the last two positions
of the string. The %@AB@%asctime%@AE@% function uses a single statically allocated
buffer to hold the return string. Each call to this routine destroys the
result of the previous call.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%asctime%@AE@% function returns a pointer to the character string result. There
is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%ctime%@AE@%, %@AB@%ftime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%time%@AE@%, %@AB@%tzset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ASCTIME.C: This program places the system time in the long integer
%@AS@%  aclock,
%@AS@%   * translates it into the structure newtime and then converts it to
%@AS@%   * string form for output, using the asctime function.
%@AS@%   */
%@AS@%  
%@AS@%  #include <time.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  struct tm *newtime;
%@AS@%  time_t aclock;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     time( &aclock );                    /* Get time in seconds */
%@AS@%  
%@AS@%     newtime = localtime( &aclock );     /* Convert time to struct tm form
%@AS@%*/
%@AS@%  
%@AS@%     /* Print local time as a string */
%@AS@%     printf( "The current date and time are: %s\n", asctime( newtime ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The current date and time are: Thu Jun 15 06:57:59 1989%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:asin@%%@NL@%
%@2@%%@CR:C6A00120140 @%%@AB@%asin Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00120141 @%%@CR:C6A00120142 @% %@CR:C6A00120143 @%%@CR:C6A00120144 @%%@CR:C6A00120145 @%%@CR:C6A00120146 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate the arcsine.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <errno.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double asin( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double asinl( long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Value whose arcsine is to be calculated

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%asin%@AE@% functions calculate the arcsine of %@AI@%x%@AE@% in the range -ã/2 to ã/2
radians. The value of %@AI@%x%@AE@% must be between -1 and 1. The %@AB@%asinl%@AE@% function is the
80-bit counterpart, which uses an 80-bit, 10-byte coprocessor form of
arguments and return values. See the reference page on the long double
functions for more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%asin%@AE@% functions return the arcsine result. If %@AI@%x%@AE@% is less than -1 or
greater than 1, %@AB@%asin%@AE@% sets %@AB@%errno%@AE@% to %@AB@%EDOM%@AE@%, prints a %@AB@%DOMAIN%@AE@% error message to
%@AB@%stderr%@AE@%, and returns 0.  %@NL@%
%@NL@%
Error handling can be modified by using the %@AB@%matherr%@AE@% (or %@AB@%_matherrl%@AE@%) routine.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asin%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%asinl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%acos%@AE@% functions, %@AB@%atan%@AE@% functions, %@AB@%cos%@AE@% functions, %@AB@%matherr%@AE@%, %@AB@%sin%@AE@% functions,%@AB@% tan%@AE@%
functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ASINCOS.C: This program prompts for a value in the range -1 to 1.
%@AS@%   * Input values outside this range will produce DOMAIN error messages.
%@AS@%   * If a valid value is entered, the program prints the arcsine and the
%@AS@%   * arccosine of that value.
%@AS@%   */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <errno.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     double x, y;
%@AS@%  
%@AS@%     printf( "Enter a real number between -1 and 1: " );
%@AS@%     scanf( "%lf", &x );
%@AS@%     y = asin( x );
%@AS@%     printf( "Arcsine of %f = %f\n", x, y );
%@AS@%     y = acos( x );
%@AS@%     printf( "Arccosine of %f = %f\n", x, y );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Enter a real number between -1 and 1: .32696
%@AS@%  Arcsine of 0.326960 = 0.333085
%@AS@%  Arccosine of 0.326960 = 1.237711%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:assert@%%@NL@%
%@2@%%@CR:C6A00130147 @%%@AB@%assert%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00130148 @%%@CR:C6A00130149 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Prints an error message and aborts the program.  %@NL@%
%@NL@%
%@AB@%#include <assert.h>%@AE@%               

%@AB@%#include <stdio.h>%@AE@%                

%@AS@%  void assert( int expression );%@AE@%%@NL@%
%@NL@%
%@AI@%expression%@AE@%                        C expression specifying assertion being 
                                  tested

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%assert%@AE@% routine prints a diagnostic message and calls the %@AB@%abort%@AE@% routine
if %@AI@%expression%@AE@% is false (0). The diagnostic message has the form   %@CR:C6A00130150 @%  %@NL@%
%@NL@%
%@AS@%  Assertion failed: expression, file filename, line linenumber%@AE@%%@NL@%
%@NL@%
where %@AI@%filename%@AE@% is the name of the source file and %@AI@%linenumber%@AE@% is the line
number of the assertion that failed in the source file. No action is taken
if %@AI@%expression%@AE@% is true (nonzero).  %@NL@%
%@NL@%
The %@AB@%assert%@AE@% routine is typically used in program development to identify
program logic errors. The given expression should be chosen so that it holds
true only if the program is operating as intended. After a program has been
debugged, the special "no debug" identifier %@AB@%NDEBUG%@AE@% can be used to remove
%@AB@%assert%@AE@% calls from the program. If %@AB@%NDEBUG%@AE@% is defined (by any value) with a /D
command-line option or with a %@AB@%#define%@AE@% directive, the C preprocessor removes
all %@AB@%assert%@AE@% calls from the program source.%@CR:C6A00130151 @%%@CR:C6A00130152 @%  %@NL@%
%@NL@%
The %@AB@%assert%@AE@% routine is implemented as a macro.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%abort%@AE@%, %@AB@%raise%@AE@%, %@AB@%signal%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ASSERT.C: In this program, the analyze_string function uses the
%@AS@%   * assert function to test several conditions related to string and
%@AS@%   * length. If any of the conditions fails, the program prints a
%@AS@%   * message indicating what caused the failure.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <assert.h>
%@AS@%  #include <string.h>
%@AS@%  
%@AS@%  void analyze_string( char *string );   /* Prototype */
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char  test1[] = "abc", *test2 = NULL, test3[] = "";
%@AS@%  
%@AS@%     printf ( "Analyzing string '%s'\n", test1 );
%@AS@%     analyze_string( test1 );
%@AS@%     printf ( "Analyzing string '%s'\n", test2 );
%@AS@%     analyze_string( test2 );
%@AS@%     printf ( "Analyzing string '%s'\n", test3 );
%@AS@%     analyze_string( test3 );
%@AS@%  }
%@AS@%  
%@AS@%  /* Tests a string to see if it is NULL, empty, or longer than 0 characters
%@AS@%*/
%@AS@%  void analyze_string( char * string )
%@AS@%  {
%@AS@%     assert( string != NULL );        /* Cannot be NULL */
%@AS@%     assert( *string != '\0' );       /* Cannot be empty */
%@AS@%     assert( strlen( string ) > 2 );  /* Length must be greater than 2 */
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Analyzing string 'abc'
%@AS@%  Analyzing string '(null)'
%@AS@%  Assertion failed: string != NULL, file assert.c, line 28
%@AS@%  
%@AS@%  abnormal program termination %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:atan@%%@NL@%
%@2@%%@CR:C6A00140153 @%%@AB@%atan Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00140154 @%%@CR:C6A00140155 @% %@CR:C6A00140156 @%%@CR:C6A00140157 @% %@CR:C6A00140158 @%%@CR:C6A00140159 @%%@CR:C6A00140160 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate the arctangent of %@AI@%x%@AE@% (%@AB@%atan%@AE@% and %@AB@%atanl%@AE@%) and the arctangent of %@AI@%y/x%@AE@%
(%@AB@%atan2%@AE@% and %@AB@%atan2l%@AE@%).  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double atan( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  double atan2( double y, double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double atanl( long double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double atan2l( long double y, long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              Any number

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%atan%@AE@% family of functions calculates the arctangent of %@AI@%x%@AE@%, and the %@AB@%atan2%@AE@%
family of functions calculates the arctangent of %@AI@%y%@AE@%/%@AI@%x%@AE@%. The %@AB@%atan%@AE@% group returns
a value in the range -ã/2 to ã/2 radians, and the %@AB@%atan2%@AE@% group returns a
value in the range -ã toã radians. The %@AB@%atan2%@AE@% functions use the signs of both
arguments to determine the quadrant of the return value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%atan%@AE@% family of functions returns the arctangent result. If both
arguments of %@AB@%atan2%@AE@% or %@AB@%atan2l%@AE@% are 0, the function sets %@AB@%errno%@AE@% to %@AB@%EDOM%@AE@%, prints
a %@AB@%DOMAIN%@AE@% error message to %@AB@%stderr%@AE@%, and returns 0.  %@NL@%
%@NL@%
Error handling can be modified by using the %@AB@%matherr%@AE@% (or %@AB@%_matherrl%@AE@%) routine.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%atan%@AE@%, %@AB@%atan2%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%atanl%@AE@%, %@AB@%atan2l%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%acos%@AE@% functions, %@AB@%asin%@AE@% functions, %@AB@%cos %@AE@%functions, %@AB@%matherr%@AE@%, %@AB@%sin%@AE@% functions, %@AB@%tan%@AE@%
functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ATAN.C: This program calculates the arctangent of 1 and -1. */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <errno.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     double x1, x2, y;
%@AS@%  
%@AS@%     printf( "Enter a real number: " );
%@AS@%     scanf( "%lf", &x1 );
%@AS@%     y = atan( x1 );
%@AS@%     printf( "Arctangent of %f: %f\n", x1, y );
%@AS@%     printf( "Enter a second real number: " );
%@AS@%     scanf( "%lf", &x2 );
%@AS@%     y = atan2( x1, x2 );
%@AS@%     printf( "Arctangent of %f / %f: %f\n", x1, x2, y );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Enter a real number: -862.42
%@AS@%  Arctangent of -862.420000: -1.569637
%@AS@%  Enter a second real number: 78.5149
%@AS@%  Arctangent of -862.420000 / 78.514900: -1.480006 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:atexit@%%@NL@%
%@2@%%@CR:C6A00150161 @%%@AB@%atexit%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00150162 @%%@CR:C6A00150163 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Processes the specified function at exit.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AS@%  int atexit( void ( *func )( void ) );%@AE@%%@NL@%
%@NL@%
%@AI@%func%@AE@%                              Function to be called

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%atexit%@AE@% function is passed the address of a function (%@AI@%func%@AE@%) to be called
when the program terminates normally. Successive calls to %@AB@%atexit%@AE@% create a
register of functions that are executed in LIFO (last-in-first-out) order.
No more than 32 functions can be registered with %@AB@%atexit%@AE@% or %@AB@%onexit%@AE@%. The
functions passed to %@AB@%atexit%@AE@% cannot take parameters.  %@NL@%
%@NL@%
All routines passed to %@AB@%atexit%@AE@% should have the %@AB@%_loadds%@AE@% attribute if used in
multithread dynamic-link libraries.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%atexit%@AE@% function returns 0 if it is successful, or a nonzero value if an
error occurs (e.g., if there are already 32 exit functions defined).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
Use the ANSI-standard %@AB@%atexit%@AE@% function (rather than the similar %@AB@%onexit%@AE@%
function) whenever ANSI portability is desired.  %@NL@%
%@NL@%
In the OS/2 environment, the %@AB@%atexit%@AE@% function calls the OS/2 function
%@AB@%DosExitList%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%abort%@AE@%, %@AB@%exit%@AE@%, %@AB@%_exit%@AE@%, %@AB@%onexit%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ATEXIT.C: This program pushes four functions onto the stack of
%@AS@%  functions
%@AS@%   * to be executed when atexit is called. When the program exits, these
%@AS@%   * programs are executed on a "last in, first out" basis.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void fn1( void ), fn2( void ), fn3( void ), fn4( void );
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     atexit( fn1 );
%@AS@%     atexit( fn2 );
%@AS@%     atexit( fn3 );
%@AS@%     atexit( fn4 );
%@AS@%     printf( "This is executed first.\n" );
%@AS@%  }
%@AS@%  
%@AS@%  void fn1()
%@AS@%  {
%@AS@%     printf( "next.\n" );
%@AS@%  }
%@AS@%  
%@AS@%  void fn2()
%@AS@%  {
%@AS@%     printf( "executed " );
%@AS@%  }
%@AS@%  
%@AS@%  void fn3()
%@AS@%  {
%@AS@%     printf( "is " );
%@AS@%  }
%@AS@%  
%@AS@%  void fn4()
%@AS@%  {
%@AS@%     printf( "This " );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  This is executed first.
%@AS@%  This is executed next. %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:atof@%%@QR:atoi@%%@QR:atol@%%@QR:_atold@%%@NL@%
%@2@%%@CR:C6A00160164 @%%@AB@%atof, atoi, atol, _atold%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00160165 @% %@CR:C6A00160166 @%%@CR:C6A00160167 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Convert strings to double (%@AB@%atof%@AE@%), long double (%@AB@%_atold%@AE@%) integer %@AB@%(atoi%@AE@%), or
long (%@AB@%atol%@AE@%).  %@NL@%
%@NL@%
%@AB@%#include <math.h>%@AE@%                 %@AB@%atof%@AE@%,%@AB@% _atold%@AE@%

%@AB@%#include <stdlib.h>%@AE@%               %@AB@%atof%@AE@%, %@AB@%_atold%@AE@%, %@AB@%atoi%@AE@%, %@AB@%atol%@AE@%

%@AS@%  double atof( const char *string );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double _atold( const char *string );%@AE@%%@NL@%
%@NL@%
%@AS@%  int atoi( const char *string );%@AE@%%@NL@%
%@NL@%
%@AS@%  long atol( const char *string );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            String to be converted

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
These functions convert a character string to a double-precision
floating-point value (%@AB@%atof%@AE@%), an integer value (%@AB@%atoi%@AE@%), a long integer value
(%@AB@%atol%@AE@%), or a long double value (%@AB@%_atold%@AE@%). The input string is a sequence of
characters that can be interpreted as a numerical value of the specified
type.%@CR:C6A00160168 @%%@CR:C6A00160169 @%  %@NL@%
%@NL@%
The string size that can be handled by the %@AB@%atof%@AE@% or %@AB@%_atold %@AE@%function is
limited to 100 characters. %@AB@%  %@AE@%%@NL@%
%@NL@%
The function stops reading the input string at the first character that it
cannot recognize as part of a number. This character may be the null
character (%@AB@%'\0'%@AE@%) terminating the string.  %@NL@%
%@NL@%
The %@AB@%atof%@AE@% and %@AB@%_atold%@AE@% functions expect %@AI@%string%@AE@% to have the following form:  %@NL@%
%@NL@%
%@AS@%  [[whitespace]] [[{sign}]] [[ IK0digits]] [[.digits]] 
%@AS@%  [[{d| D | e | E}[[sign]digits]]%@AE@%%@NL@%
%@NL@%
A %@AI@%whitespace%@AE@% consists of space and/or tab characters, which are ignored;
%@AI@%sign%@AE@% is either plus (+) or minus (-); and %@AI@%digits%@AE@% are one or more decimal
digits. If no digits appear before the decimal point, at least one must
appear after the decimal point. The decimal digits may be followed by an
exponent, which consists of an introductory letter (%@AB@%d%@AE@%, %@AB@%D%@AE@%, %@AB@%e%@AE@%, or %@AB@%E%@AE@%) and an
optionally signed decimal integer.  %@NL@%
%@NL@%
The %@AB@%atoi%@AE@% and %@AB@%atol%@AE@% functions do not recognize decimal points or exponents.
The %@AI@%string%@AE@% argument for these functions has the form  %@NL@%
%@NL@%
%@AS@%  [[whitespace]] [[sign]]digits %@AE@%%@NL@%
%@NL@%
where %@AI@%whitespace%@AE@%, %@AI@%sign%@AE@%, and %@AI@%digits%@AE@% are exactly as described above for %@AB@%atof%@AE@%.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
Each function returns the %@AB@%double%@AE@%, %@AB@%long double%@AE@%, %@AB@%int%@AE@%, or %@AB@%long%@AE@% value produced
by interpreting the input characters as a number. The return value is 0 (for
%@AB@%atoi%@AE@%), 0L (for %@AB@%atol%@AE@%), and 0.0 (for %@AB@%atof%@AE@% and %@AB@%_atold%@AE@%) if the input cannot be
converted to a value of that type. The return value is undefined in case of
overflow.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%atof%@AE@%,%@AB@% atoi%@AE@%, %@AB@%atol%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_atold%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%ecvt%@AE@%, %@AB@%fcvt%@AE@%, %@AB@%gcvt%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ATOF.C: This program shows how numbers stored as strings can be
%@AS@%   * converted to numeric values using the atof, atoi, and atol functions.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *s; double x; int i; long l;
%@AS@%  
%@AS@%     s = "  -2309.12E-15";    /* Test of atof */
%@AS@%     x = atof( s );
%@AS@%     printf( "atof test:  ASCII string: %s\tfloat:     %e\n", s, x );
%@AS@%  
%@AS@%     s = "7.8912654773d210";  /* Test of atof */
%@AS@%     x = atof( s );
%@AS@%     printf( "atof test:  ASCII string: %s\tfloat:     %e\n", s, x );
%@AS@%  
%@AS@%     s = "  -9885 pigs";      /* Test of atoi */
%@AS@%     i = atoi( s );
%@AS@%     printf( "atoi test:  ASCII string: %s\t\tinteger: %d\n", s, i );
%@AS@%  
%@AS@%     s = "98854 dollars";     /* Test of atol */
%@AS@%     l = atol( s );
%@AS@%     printf( "atol test:  ASCII string: %s\t\tlong:    %ld\n", s, l );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  atof test:  ASCII string:   -2309.12E-15        float:     -2.309120e-012
%@AS@%  atof test:  ASCII string: 7.8912654773d210      float:     7.891265e+210
%@AS@%  atoi test:  ASCII string:   -9885 pigs          integer: -9885
%@AS@%  atol test:  ASCII string: 98854 dollars         long:    98854 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:bdos@%%@NL@%
%@2@%%@CR:C6A00170170 @%%@AB@%bdos%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00170171 @%%@CR:C6A00170172 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Invokes the DOS system call.  %@NL@%
%@NL@%
%@AB@%#include <dos.h>%@AE@%  %@NL@%
%@NL@%
%@AS@%  int bdos( int dosfunc, unsigned int dosdx, unsigned int dosal );%@AE@%%@NL@%
%@NL@%
%@AI@%dosfunc%@AE@%                           Function number

%@AI@%dosdx%@AE@%                             DX register value

%@AI@%dosal%@AE@%                             AL register value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%bdos%@AE@% function invokes the DOS system call specified by %@AI@%dosfunc%@AE@% after
placing the values specified by %@AI@%dosdx%@AE@% and %@AI@%dosal%@AE@% in the DX and AL registers,
respectively. The %@AB@%bdos%@AE@% function executes an INT 21H instruction to invoke
the system call. When the system call is complete, %@AB@%bdos%@AE@% returns the contents
of the AX register. %@CR:C6A00170173 @%  %@NL@%
%@NL@%
The %@AB@%bdos%@AE@% function is intended to be used to invoke DOS system calls that
either take no arguments or take arguments only in the DX (DH, DL) and/or AL
registers.  %@NL@%
%@NL@%
Do not use the %@AB@%bdos%@AE@% function to call interrupts that modify the DS register.
Instead, use the %@AB@%intdosx%@AE@% or %@AB@%int86x%@AE@% function. The %@AB@%intdosx%@AE@% and %@AB@%int86x%@AE@%
functions load the DS and ES registers from the %@AI@%segregs%@AE@% parameter and also
store the DS and ES registers into %@AI@%segregs%@AE@% after the function call.  %@NL@%
%@NL@%
This call should not be used to invoke system calls that indicate errors by
setting the carry flag. Since C programs do not have access to this flag,
your program cannot determine whether the return value is an error code. The
%@AB@%intdos%@AE@% function should be used in these cases.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%bdos%@AE@% function returns the value of the AX register after the system call
has completed.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%intdos%@AE@%, %@AB@%intdosx%@AE@%%@CR:C6A00170174 @%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BDOS.C: This example calls DOS function 0x9 (display string)
%@AS@%   * to display a $-terminated string.
%@AS@%   */
%@AS@%  
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Function 0x09 assumes that DS will contain segment of the string.
%@AS@%   * This will be true for all memory models if the string is declared near.
%@AS@%   */
%@AS@%  char _near str[] = "Hello world!\r\n$";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Offset of string must be in DX, segment in DS. AL is not needed,
%@AS@%      * so 0 is used.
%@AS@%      */
%@AS@%     bdos( 0x09, (int)str, 0 );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Hello world! %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_beginthread@%%@NL@%
%@2@%%@CR:C6A00180175 @%%@AB@%_beginthread%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00180176 @% %@CR:C6A00180177 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Begins thread in OS/2 process.  %@NL@%
%@NL@%
%@AB@%#include <process.h>%@AE@%              Multithread version of PROCESS.H

%@AB@%#include <stddef.h>%@AE@%               Declaration of %@AI@%threadid%@AE@% variable

%@AS@%  int _far  _beginthread( void( _far *start_address )( void _far * ), 
%@AS@%  void  _far *stack_bottom, unsigned stack_size, void  _far *arglist );%@AE@%%@NL@%
%@NL@%
%@AI@%start_address%@AE@%                     Starting address

%@AI@%stack_bottom%@AE@%                      Address of the thread stack

%@AI@%stack_size%@AE@%                        Stack size for thread

%@AI@%arglist%@AE@%                           Argument list for thread

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_beginthread%@AE@% function creates a thread that begins execution of a far
routine at %@AI@%start_address%@AE@%. When the thread returns from that far routine, it
is terminated automatically. The user can also terminate the thread by
calling %@AB@%_endthread%@AE@%.  %@NL@%
%@NL@%
The address of the thread stack is given by %@AI@%stack_bottom%@AE@%. If %@AI@%stack_bottom%@AE@% is
set to %@AB@%NULL%@AE@%, the run-time library code will allocate and deallocate the
thread stack as needed. Since the %@AB@%_beginthread%@AE@% function can determine the
current status of all thread IDs, it can free the old stack and allocate a
new stack whenever a thread is reused.  %@NL@%
%@NL@%
If it is not %@AB@%NULL%@AE@%, the %@AI@%stack_bottom%@AE@% argument must specify a word address,
and the stack must be at least as long as specified by the %@AI@%stack_size%@AE@%
argument. Usually this memory is either a global array or memory returned by
%@AB@%malloc%@AE@% or %@AB@%_fmalloc%@AE@%.  %@NL@%
%@NL@%
The %@AI@%stack_size%@AE@% argument must be even and nonzero.  %@NL@%
%@NL@%
If you are writing multithread programs that make C run-time calls from
child threads, be sure to allocate a sufficiently large stack. For example,
the C function %@AB@%printf%@AE@% requires more than 500 bytes of stack space. To be
safe, allocate at least 2,048 bytes for a thread's stack. (If your child
thread makes no run-time calls, stack space is generally not a problem.)  %@NL@%
%@NL@%
As a general rule, you should have 2K of stack space free when calling any
API (Applications Program Interface) routine (e.g., OS/2 system calls).  %@NL@%
%@NL@%
The %@AI@%arglist%@AE@% is a parameter, the size of a far pointer, to be passed to the
newly created thread. Typically it is the address of a data item, such as a
character string, to be passed to the new thread. The %@AI@%arglist%@AE@% may be %@AB@%NULL%@AE@% if
not needed, but %@AB@%_beginthread%@AE@% should be provided with some value to pass to
the child thread.  %@NL@%
%@NL@%
All threads will be terminated if any thread calls %@AB@%abort%@AE@%, %@AB@%exit%@AE@%, %@AB@%_exit%@AE@%, or
%@AB@%DosExit%@AE@%. A good practice in multithread programming is to make the first
thread the main thread and wait until other threads have terminated before
exiting the program.  %@NL@%
%@NL@%
The OS/2 function %@AB@%DosCreateThread%@AE@% should not be called directly to create
threads. The %@AB@%_beginthread%@AE@% function performs initialization procedures
required to call other C run-time library functions safely.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the thread identification number of the new thread, if
successful. A return value of -1 indicates an error, and %@AB@%errno%@AE@% is set to one
of the following values:  %@NL@%
%@NL@%
%@AB@%Value %@AE@%                            %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EAGAIN%@AE@%                            Too many threads

%@AB@%EINVAL%@AE@%                            Invalid argument, "bad stack"

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_endthread%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BEGTHRD.C illustrates multiple threads using functions:
%@AS@%   *      _beginthread            _endthread
%@AS@%   *
%@AS@%   * Also the global variable:
%@AS@%   *      _threadid
%@AS@%   *
%@AS@%   * This program requires the multithread library. For example, compile
%@AS@%   * with the following command line:
%@AS@%   *      CL /MT THREADS.C
%@AS@%   */
%@AS@%  
%@AS@%  #define INCL_NOCOMMON
%@AS@%  #define INCL_NOPM
%@AS@%  #define INCL_DOSPROCESS
%@AS@%  #define INCL_VIO
%@AS@%  #include <os2.h>
%@AS@%  #include <process.h>    /* _beginthread, _endthread */
%@AS@%  #include <stddef.h>     /* _threadid                */
%@AS@%  #include <stdlib.h>
%@AS@%  #include <conio.h>
%@AS@%  
%@AS@%  void Bounce( int c );       /* Prototypes */
%@AS@%  void CheckKey( void *dummy );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* GetRandom returns a random integer between min and max. */
%@AS@%  #define GetRandom( min, max ) ((rand() % (int)(((max) + 1) - (min))) +
%@AS@%(min))
%@AS@%  
%@AS@%  #define STACK_SIZE   4096
%@AS@%  
%@AS@%  BOOL repeat = TRUE;         /* Global repeat flag and video variable */
%@AS@%  VIOMODEINFO vmi = { sizeof( VIOMODEINFO ) };
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%      PCHAR   stack;
%@AS@%      CHAR    ch = 'A';
%@AS@%  
%@AS@%      /* Get display screen's text row and column information. */
%@AS@%      VioGetMode( &vmi, 0 );
%@AS@%  
%@AS@%      /* Launch CheckKey thread to check for terminating keystroke. */
%@AS@%      _beginthread( CheckKey, NULL, STACK_SIZE, NULL );
%@AS@%  
%@AS@%      /* Loop until CheckKey terminates program. */
%@AS@%      while( repeat )
%@AS@%      {
%@AS@%          /* On first loops, launch character threads. */
%@AS@%          _beginthread( Bounce, NULL, STACK_SIZE, (void *)ch++ );
%@AS@%  
%@AS@%          /* Wait one second between loops. */
%@AS@%          DosSleep( 1000L );
%@AS@%      }
%@AS@%  }
%@AS@%  
%@AS@%  /* CheckKey - Thread to wait for a keystroke, then clear repeat flag. */
%@AS@%  void CheckKey( void *dummy )
%@AS@%  {
%@AS@%      getch();
%@AS@%      repeat = 0;      /* _endthread implied */
%@AS@%  }
%@AS@%  
%@AS@%  /* Bounce - Thread to create and control a colored letter that moves
%@AS@%   * around on the screen.
%@AS@%   *
%@AS@%   * Params: ch - the letter to be moved
%@AS@%   */
%@AS@%  void Bounce( int ch )
%@AS@%  {
%@AS@%      /* Generate letter and color attribute from thread argument. */
%@AS@%      char      blankcell[2] = { 0x20, 0x07 };
%@AS@%      char      blockcell[2] = { ch , (ch % 16) + 1 };
%@AS@%      int       xold, xcur, yold, ycur;
%@AS@%      BOOL      first = TRUE;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Seed random number generator and get initial location. */
%@AS@%      srand( *_threadid );
%@AS@%      xcur = GetRandom( 0, vmi.col - 1 );
%@AS@%      ycur = GetRandom( 0, vmi.row - 1 );
%@AS@%      while( repeat )
%@AS@%      {
%@AS@%          /* Pause between loops. */
%@AS@%          DosSleep( 100L );
%@AS@%  
%@AS@%          /* Blank out our old position on the screen, and draw new letter.
%@AS@%*/
%@AS@%          if( first )
%@AS@%              first = FALSE;
%@AS@%          else
%@AS@%              VioWrtCellStr( blankcell, 2, yold, xold, 0 );
%@AS@%          VioWrtCellStr( blockcell, 2, ycur, xcur, 0 );
%@AS@%  
%@AS@%          /* Increment the coordinate for next placement of the block. */
%@AS@%          xold = xcur;
%@AS@%          yold = ycur;
%@AS@%          xcur += GetRandom( -1, 1 );
%@AS@%          ycur += GetRandom( -1, 1 );
%@AS@%  
%@AS@%          /* Correct placement (and beep) if about to go off the screen. */
%@AS@%          if( xcur < 0 )
%@AS@%              xcur = 1;
%@AS@%          else if( xcur == vmi.col )
%@AS@%              xcur = vmi.col - 2;
%@AS@%          else if( ycur < 0 )
%@AS@%              ycur = 1;
%@AS@%          else if( ycur == vmi.row )
%@AS@%              ycur = vmi.row - 2;
%@AS@%  
%@AS@%          /* If not at screen border, continue, otherwise beep. */
%@AS@%          else
%@AS@%              continue;
%@AS@%          DosBeep( (ch - 'A') * 100, 175 );
%@AS@%      }
%@AS@%      /* _endthread given (but not really needed) to terminate. */
%@AS@%      _endthread();
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:Bessel@%%@NL@%
%@2@%%@CR:C6A00190178 @%%@AB@%Bessel Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00190179 @%%@CR:C6A00190180 @% %@CR:C6A00190181 @%%@CR:C6A00190182 @% %@CR:C6A00190183 @% %@CR:C6A00190184 @%%@CR:C6A00190185 @%%@CR:C6A00190186 @% %@CR:C6A00190187 @%%@CR:C6A00190188 @%%@CR:C6A00190189 @%%@CR:C6A00190190 @%%@EH@%
%@AB@%%@AE@%%@NL@%
%@NL@%
Compute the Bessel function.  %@NL@%
%@NL@%
%@AB@%#include <math.h>%@AE@%  %@NL@%
%@NL@%
%@AS@%  double j0( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  double j1( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  double jn( int n, double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  double y0( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  double y1( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  double yn( int n, double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double _j0l( long double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double _jnl( int n, long double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double _j1l( long double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double _y0l( long double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double _y1l( long double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double _ynl( int n, long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Floating-point value

%@AI@%n%@AE@%                                 Integer order

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%j0%@AE@%, %@AB@%j1%@AE@%, and %@AB@%jn%@AE@% routines return Bessel functions of the first kindÄorders
0, 1, and %@AI@%n%@AE@%, respectively.  %@NL@%
%@NL@%
The %@AB@%y0%@AE@%, %@AB@%y1%@AE@%, and %@AB@%yn%@AE@% routines return Bessel functions of the second
kindÄorders 0, 1, and %@AI@%n%@AE@%, respectively. The argument %@AI@%x%@AE@% must be positive.  %@NL@%
%@NL@%
The long double versions of these functions are the 80-bit counterparts and
use the 80-bit, 10-byte coprocessor form of arguments and return values. See
the reference page on the long double functions for more details on this
data type.  %@NL@%
%@NL@%
The Bessel functions are explained more fully in most mathematics reference
books, such as the %@AI@%Handbook of Mathematical Functions%@AE@% (Abramowitz and
Stegun; Washington: U.S. Government Printing Office, 1964). These functions
are commonly used in the mathematics of electromagnetic wave theory.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return the result of a Bessel function of %@AI@%x%@AE@%.  %@NL@%
%@NL@%
For %@AB@%y0%@AE@%, %@AB@%y1%@AE@%, or %@AB@%yn%@AE@%, if %@AI@%x%@AE@% is negative, the routine sets %@AB@%errno%@AE@% to %@AB@%EDOM%@AE@%, prints
a %@AB@%DOMAIN%@AE@% error message to %@AB@%stderr%@AE@%, and returns %@AB@%-HUGE_VAL%@AE@%.  %@NL@%
%@NL@%
Error handling can be modified by using the %@AB@%matherr%@AE@% (or %@AB@%_matherrl%@AE@%) routine.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%j0%@AE@%, %@AB@%j1%@AE@%, %@AB@%jn%@AE@%, %@AB@%y0%@AE@%, %@AB@%y1%@AE@%, %@AB@%yn%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_j0l%@AE@%,  %@AB@%_j1l%@AE@%,  %@AB@%_jnl%@AE@%,  %@AB@%_y0l%@AE@%,  %@AB@%_y1l%@AE@%,  %@AB@%_ynl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%matherr%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BESSEL.C: This program illustrates Bessel functions, including:
%@AS@%   *      j0          j1          jn          y0          y1          yn
%@AS@%   */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%      double x = 2.387;
%@AS@%      int n = 3, c;
%@AS@%  
%@AS@%      printf( "Bessel functions for x = %f:\n", x );
%@AS@%      printf( "  Kind\t\tOrder\t\Function\tResult\n\n" );
%@AS@%      printf( "  First\t\t0\tj0( x )\t\t%f\n", j0( x ) );
%@AS@%      printf( "  First\t\t1\tj1( x )\t\t%f\n", j1( x ) );
%@AS@%      for( c = 2; c < 5; c++ )
%@AS@%          printf( "  First\t\t%d\tjn( n, x )\t%f\n", c, jn( c, x ) );
%@AS@%  
%@AS@%      printf( "  Second\t0\ty0( x )\t\t%f\n", y0( x ) );
%@AS@%      printf( "  Second\t1\ty1( x )\t\t%f\n", y1( x ) );
%@AS@%      for( c = 2; c < 5; c++ )
%@AS@%          printf( "  Second\t%d\tyn( n, x )\t%f\n", c, yn( c, x ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Bessel functions for x = 2.387000:
%@AS@%    Kind          Order   Function        Result
%@AS@%  
%@AS@%    First         0       j0( x )         0.009288
%@AS@%    First         1       j1( x )         0.522941
%@AS@%    First         2       jn( n, x )      0.428870
%@AS@%    First         3       jn( n, x )      0.195734
%@AS@%    First         4       jn( n, x )      0.063131
%@AS@%    Second        0       y0( x )         0.511681
%@AS@%    Second        1       y1( x )         0.094374
%@AS@%    Second        2       yn( n, x )      -0.432608
%@AS@%    Second        3       yn( n, x )      -0.819314
%@AS@%    Second        4       yn( n, x )      -1.626833%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_bfreeseg@%%@NL@%
%@2@%%@CR:C6A00200191 @%%@AB@%_bfreeseg%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00200192 @% %@CR:C6A00200193 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Frees a specified based heap.  %@NL@%
%@NL@%
%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  int _bfreeseg( _segment seg );%@AE@%%@NL@%
%@NL@%
%@AI@%seg%@AE@%                               Segment selected

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bfreeseg%@AE@% function frees a based heap. The %@AI@%seg%@AE@% argument is a based heap
returned by an earlier call to %@AB@%_bheapseg%@AE@%. It specifies the based heap to be
freed.  %@NL@%
%@NL@%
The number of bytes freed is the number of bytes specified when the block
was allocated. After the call, the freed heap is again available for
allocation.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bfreeseg%@AE@% function returns 0 if successful and -1 in the case of an
error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_bheapseg%@AE@%, %@AB@%calloc%@AE@% functions, %@AB@%free%@AE@% functions,%@AB@% malloc%@AE@% functions, %@AB@%realloc%@AE@%
functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BHEAPSEG.C: This program C illustrates dynamic allocation of based
%@AS@%   * memory using functions _bheapseg, _bfreeseg, _bmalloc, and _bfree.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <string.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%      _segment seg;
%@AS@%      char _based( seg ) *outstr, _based( seg ) *instr;
%@AS@%      char _based( seg ) *pout,   _based( seg ) *pin;
%@AS@%      char tmpstr[80];
%@AS@%      int  len;
%@AS@%  
%@AS@%      printf( "Enter a string: " );
%@AS@%      gets( tmpstr );
%@AS@%  
%@AS@%      /* Request a based heap. Use based so that memory won't be taken from
%@AS@%       * near heap.
%@AS@%       */
%@AS@%      if( (seg = _bheapseg( 1000 )) == _NULLSEG )
%@AS@%          exit( 1 );
%@AS@%  
%@AS@%      /* Allocate based memory for two strings. */
%@AS@%      len = strlen( tmpstr );
%@AS@%      if( ((instr  = _bmalloc( seg, len + 1 )) == _NULLOFF) ||
%@AS@%          ((outstr = _bmalloc( seg, len + 1 )) == _NULLOFF) )
%@AS@%          exit( 1 );
%@AS@%  
%@AS@%      /* Copy a lowercased string to dynamic memory. The based memory is
%@AS@%       * far when addressed as a whole.
%@AS@%       */
%@AS@%      _fstrlwr( _fstrcpy( (char _far *)instr, (char _far *)tmpstr ) );
%@AS@%  
%@AS@%      /* Copy input string to output string in reversed order. When reading
%@AS@%       * and writing individual characters from a based heap, the compiler
%@AS@%will
%@AS@%       * try to process them as near, thus speeding up the processing.
%@AS@%       */
%@AS@%      for( pin = instr + len - 1, pout = outstr;
%@AS@%                  pout < outstr + len; pin--, pout++ )
%@AS@%          *pout = *pin;
%@AS@%      *pout = '\0';
%@AS@%  
%@AS@%      /* Display strings. Again strings as a whole are far. */
%@AS@%      printf( "Input:  %Fs\n", (char _far *)instr );
%@AS@%      printf( "Output: %Fs\n", (char _far *)outstr );
%@AS@%  
%@AS@%      /* Free blocks and release based heap. */
%@AS@%      _bfree( seg, instr );
%@AS@%      _bfree( seg, outstr );
%@AS@%      _bfreeseg( seg );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Enter a string: Was I god
%@AS@%  Input:  was i god
%@AS@%  Output: dog i saw%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_bheapseg@%%@NL@%
%@2@%%@CR:C6A00210194 @%%@AB@%_bheapseg%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00210195 @% %@CR:C6A00210196 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Allocates a based heap.  %@NL@%
%@NL@%
%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  _segment _bheapseg( size_t size );%@AE@%%@NL@%
%@NL@%
%@AI@%size%@AE@%                              Segment size to allocate

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bheapseg%@AE@% function allocates a based-heap segment of at least %@AI@%size%@AE@%
bytes. (The block may be larger than %@AI@%size%@AE@% bytes because of space required
for alignment and for maintenance information.)  %@NL@%
%@NL@%
The heap code will try to enlarge the heap as necessary. If the original
block of memory is depleted (e.g., by calls to %@AB@%_bmalloc%@AE@% and %@AB@%_brealloc%@AE@%), the
run-time code will try to enlarge the heap as necessary.  %@NL@%
%@NL@%
The value returned by %@AB@%_bheapseg%@AE@% is the identifier of the based-heap segment.
This value should be saved and used in subsequent calls to other based-heap
functions.  %@NL@%
%@NL@%
The %@AB@%_bheapseg%@AE@% function can be called repeatedly. For each call, the C
library will allocate a new based-heap segment.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bheapseg%@AE@% function returns the newly allocated segment selector that the
user must save for use in subsequent based-heap functions. A return value of
-1 indicates failure.  %@NL@%
%@NL@%
Always check the return from the %@AB@%_bheapseg%@AE@% function (especially when it is
used in real mode), even if the amount of memory requested is small.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%calloc%@AE@% functions, %@AB@%free%@AE@% functions, %@AB@%malloc%@AE@% functions, %@AB@%realloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BHEAPSEG.C: This program C illustrates dynamic allocation of based
%@AS@%   * memory using functions _bheapseg, _bfreeseg, _bmalloc, and _bfree.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <string.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%      _segment seg;
%@AS@%      char _based( seg ) *outstr, _based( seg ) *instr;
%@AS@%      char _based( seg ) *pout,   _based( seg ) *pin;
%@AS@%      char tmpstr[80];
%@AS@%      int  len;
%@AS@%  
%@AS@%      printf( "Enter a string: " );
%@AS@%      gets( tmpstr );
%@AS@%  
%@AS@%      /* Request a based heap. Use based so that memory won't be taken from
%@AS@%       * near heap.
%@AS@%       */
%@AS@%      if( (seg = _bheapseg( 1000 )) == _NULLSEG )
%@AS@%          exit( 1 );
%@AS@%  
%@AS@%      /* Allocate based memory for two strings. */
%@AS@%      len = strlen( tmpstr );
%@AS@%      if( ((instr  = _bmalloc( seg, len + 1 )) == _NULLOFF) ||
%@AS@%          ((outstr = _bmalloc( seg, len + 1 )) == _NULLOFF) )
%@AS@%          exit( 1 );
%@AS@%  
%@AS@%      /* Copy a lowercased string to dynamic memory. The based memory is
%@AS@%       * far when addressed as a whole.
%@AS@%       */
%@AS@%      _fstrlwr( _fstrcpy( (char _far *)instr, (char _far *)tmpstr ) );
%@AS@%  
%@AS@%      /* Copy input string to output string in reversed order. When reading
%@AS@%       * and writing individual characters from a based heap, the compiler
%@AS@%will
%@AS@%       * try to process them as near, thus speeding up the processing.
%@AS@%       */
%@AS@%      for( pin = instr + len - 1, pout = outstr;
%@AS@%                  pout < outstr + len; pin--, pout++ )
%@AS@%          *pout = *pin;
%@AS@%      *pout = '\0';
%@AS@%  
%@AS@%      /* Display strings. Again, strings as a whole are far. */
%@AS@%      printf( "Input:  %Fs\n", (char _far *)instr );
%@AS@%      printf( "Output: %Fs\n", (char _far *)outstr );
%@AS@%  
%@AS@%      /* Free blocks and release based heap. */
%@AS@%      _bfree( seg, instr );
%@AS@%      _bfree( seg, outstr );
%@AS@%      _bfreeseg( seg );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Enter a string: Was I god
%@AS@%  Input:  was i god
%@AS@%  Output: dog i saw%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_bios_disk@%%@NL@%
%@2@%%@CR:C6A00220197 @%%@AB@%_bios_disk%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00220198 @% %@CR:C6A00220199 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calls BIOS disk services using system call INT 0x13.  %@NL@%
%@NL@%
%@AB@%#include <bios.h>%@AE@%  %@NL@%
%@NL@%
%@AS@%  unsigned _bios_disk( unsigned service, struct diskinfo_t  *diskinfo );%@AE@%%@NL@%
%@NL@%
%@AI@%service%@AE@%                           Disk function desired

%@AI@%diskinfo%@AE@%                          Disk parameters

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bios_disk%@AE@% routine uses system call INT 0x13 to provide several
disk-access functions. The %@AI@%service%@AE@% parameter selects the function desired,
while the %@AI@%diskinfo%@AE@% structure provides the necessary parameters. Note that
the low-level disk operations allowed by the %@AB@%_bios_disk%@AE@% routine are very
dangerous to use because they allow direct manipulation of the disk.  %@NL@%
%@NL@%
The %@AI@%diskinfo%@AE@% structure provides the following parameters:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%unsigned drive%@AE@%                    Drive number

%@AB@%unsigned head%@AE@%                     Head number

%@AB@%unsigned track%@AE@%                    Track number

%@AB@%unsigned sector%@AE@%                   Starting sector number

%@AB@%unsigned nsectors%@AE@%                 Number of sectors to read, write, or 
                                  compare

%@AB@%void far *buffer%@AE@%                  Memory location to write to, read from, 
                                  or compare

The %@AI@%service%@AE@% argument can be set to one of the following manifest constants:
%@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Function%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_DISK_FORMAT%@AE@%                      Formats the track specified by %@AI@%diskinfo%@AE@%.
                                  The %@AI@%head%@AE@% and %@AI@%track%@AE@% fields indicate the 
                                  track to format. Only one track can be 
                                  formatted in a single call. The %@AI@%buffer%@AE@% 
                                  field points to a set of sector markers.
                                  The format of the markers depends on the
                                  type of disk drive; see a technical 
                                  reference to the PC BIOS to determine 
                                  the marker format. There is no return 
                                  value.

%@AB@%_DISK_READ%@AE@%                        Reads one or more disk sectors into 
                                  memory. This service uses all fields of 
                                  the structure pointed to by %@AI@%diskinfo%@AE@%, as
                                  defined earlier in this section. If no 
                                  error occurs, the function returns 0 in 
                                  the high-order byte and the number of 
                                  sectors read in the low-order byte. If 
                                  there is an error, the high-order byte 
                                  will contain a set of status flags. If 
                                  there is an error, the high-order byte 
                                  will contain a set of status flags, as 
                                  defined under %@AB@%_DISK_READ%@AE@%. Status is 
                                  returned in the 8 high-order bits of the
                                  return value, as listed below: 

                                  %@AB@%Bits%@AE@%          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
                                  0x01**        Invalid request or a bad 
                                  command

                                  0x02**        Address mark not found

                                  0x04**        Sector not found

                                  0x05**        Reset failed

                                  0x07**        Drive parameter activity 
                                  failed

                                  0x09**        Direct Memory Access (DMA)
                                  overrun

                                  0x0A**        Bad sector flag detected

                                  0x10**        Data read (ECC) error

                                  0x11**        Corrected data read (ECC) 
                                  error

                                  0x20**        Controller failure

                                  0x40**        Seek error

                                  0x80**        Disk timed out or failed 
                                  to respond

                                  0xAA**        Drive not ready

                                  0xBB**        Undefined error

                                  0xCC**        Write fault on drive

                                  0xE0**        Status error

%@AB@%_DISK_RESET%@AE@%                       Forces the disk controller to do a hard 
                                  reset, preparing for floppy-disk I/O. 
                                  This is useful after an error occurs in 
                                  another operation, such as a read. If 
                                  this service is specified, the%@AI@%%@AE@%
                                  %@AI@%diskinfo%@AE@% argument is ignored.

%@AB@%_DISK_STATUS%@AE@%                      Obtains the status of the last disk 
                                  operation. If this service is specified,
                                  the %@AI@%diskinfo%@AE@% argument is ignored. 

%@AB@%_DISK_VERIFY%@AE@%                      Checks the disk to be sure the specified
                                  sectors exist and can be read. It also 
                                  runs a CRC (cyclic redundancy check) 
                                  test. This service uses all fields 
                                  (except %@AI@%buffer%@AE@%) of the structure pointed
                                  to by %@AI@%diskinfo%@AE@%, as defined earlier in 
                                  this section. If no error occurs, the 
                                  function returns 0 in the high-order 
                                  byte and the number of sectors compared 
                                  in the low-order byte. If there is an 
                                  error, the high-order byte will contain 
                                  a set of status flags, as defined under %@AB@%%@AE@%
                                  %@AB@%_DISK_READ%@AE@% (above).

%@AB@%_DISK_WRITE%@AE@%                       Writes data from memory to one or more 
                                  disk sectors. This service uses all 
                                  fields of the structure pointed to by %@AI@%%@AE@%
                                  %@AI@%diskinfo%@AE@%, as defined earlier in this 
                                  section. If no error occurs, the 
                                  function returns 0 in the high-order 
                                  byte and the number of sectors written 
                                  in the low-order byte. If there is an 
                                  error, the high-order byte will contain 
                                  a set of status flags, as defined under %@AB@%%@AE@%
                                  %@AB@%_DISK_READ%@AE@% (above).

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bios_disk%@AE@% function returns the value in the AX register after the BIOS
interrupt.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BDISK.C: This program first attempts to verify a disk by using an
%@AS@%   * invalid disk head number. After printing the return value error code,
%@AS@%   * the program verifies the disk by using a valid disk head code.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <bios.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned status = 0;
%@AS@%     struct diskinfo_t disk_info;
%@AS@%  
%@AS@%     disk_info.drive    = 0;
%@AS@%     disk_info.head     = 10;   /* Invalid head number */
%@AS@%     disk_info.track    = 1;
%@AS@%     disk_info.sector   = 2;
%@AS@%     disk_info.nsectors = 8;%@AE@%%@NL@%
%@NL@%
%@AS@%  printf( "Insert disk in drive A: and press any key\n" );
%@AS@%     getch();
%@AS@%     status = _bios_disk( _DISK_VERIFY, &disk_info );
%@AS@%     printf( "Return value: 0x%.4x\n", status );
%@AS@%     if( status & 0xff00 )      /* Error if high byte is 0 */
%@AS@%        printf( "Seek error\n" );
%@AS@%     else
%@AS@%        printf( "No seek error\n" );
%@AS@%  
%@AS@%     printf( "Press any key\n" );
%@AS@%     getch();
%@AS@%     disk_info.head = 0;        /* Valid head number */
%@AS@%     status = _bios_disk( _DISK_VERIFY, &disk_info );
%@AS@%     printf( "Return value: 0x%.4x\n", status );
%@AS@%     if( status & 0xff00 )      /* Error if high byte is 0 */
%@AS@%        printf( "Seek error\n" );
%@AS@%     else
%@AS@%        printf( "No seek error\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Insert disk in drive A: and press any key
%@AS@%  Return value: 0x0400
%@AS@%  Seek error
%@AS@%  Press any key
%@AS@%  Return value: 0x0008
%@AS@%  No seek error %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_bios_equiplist@%%@NL@%
%@2@%%@CR:C6A00230200 @%%@AB@%_bios_equiplist%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00230201 @% %@CR:C6A00230202 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calls BIOS equipment-list service, using system call INT 0x11.  %@NL@%
%@NL@%
%@AB@%#include <bios.h>%@AE@%  %@NL@%
%@NL@%
%@AS@%  unsigned _bios_equiplist( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bios_equiplist%@AE@% routine uses system call INT 0x11 to determine what
hardware and peripherals are currently installed on the machine.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns a set of bits indicating what is installed, as defined
below:  %@NL@%
%@NL@%
%@AB@%Bits%@AE@%                              %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
0                                 Any disk drive installed if true

1                                 True (1) if math coprocessor installed

2 -3                              System RAM in 16K blocks (16-64K)

4 -5                              Initial video mode

6 -7                              Number of floppy-disk drives installed 
                                  (00 = 1,  01 = 2, etc.)

8                                 False (0) if and only if a Direct Memory
                                  Access (DMA) chip is installed

9 -11                             Number of RS232 serial ports installed

12                                True (1) if and only if a game adapter 
                                  is installed

13                                True (1) if and only if an internal 
                                  modem is installed

14 -15                            Number of printers installed

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BEQUIPLI.C: This program checks for the presence of diskettes. */
%@AS@%  
%@AS@%  #include <bios.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned equipment;
%@AS@%  
%@AS@%     equipment = _bios_equiplist();
%@AS@%     printf( "Equipment bits: 0x%.4x\n", equipment );
%@AS@%     if( equipment & 0x1000 )      /* Check for game adapter bit */
%@AS@%        printf( "Game adapter installed\n" );
%@AS@%     else
%@AS@%        printf( "No game adapter installed\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Equipment bits: 0x4061
%@AS@%  No game adapter installed%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_bios_keybrd@%%@NL@%
%@2@%%@CR:C6A00240203 @%%@AB@%_bios_keybrd%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00240204 @% %@CR:C6A00240205 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calls BIOS keyboard services, using INT 0x16.  %@NL@%
%@NL@%
%@AB@%#include <bios.h>%@AE@%  %@NL@%
%@NL@%
%@AS@%  unsigned _bios_keybrd( unsigned service );%@AE@%%@NL@%
%@NL@%
%@AI@%service%@AE@%                           Keyboard function desired

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bios_keybrd%@AE@% routine uses system call INT 0x16 to access the keyboard
services. The %@AI@%service%@AE@% argument can be any of the following manifest
constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_KEYBRD_READ%@AE@%,%@AB@%%@AE@%                     Reads the next character from the 
%@AB@%_NKEYBRD_READ%@AE@%                     keyboard. If no character has been 
                                  typed, the call will wait for one. If 
                                  the low-order byte of the return value 
                                  is nonzero, the call contains the ASCII 
                                  value of the character typed. The 
                                  high-order byte contains the keyboard 
                                  scan code for the character. The %@AB@%%@AE@%
                                  %@AB@%_NKEYBRD_READ%@AE@% constant is used with 
                                  enhanced keyboards to obtain the scan 
                                  codes for function keys F11 and F12 and 
                                  the cursor control keys. 

%@AB@%_KEYBRD_READY%@AE@%,%@AB@%%@AE@%                    Checks whether a keystroke is waiting to
%@AB@%_NKEYBRD_READY%@AE@%                    be read and, if so, reads it. The return
                                  value is 0 if no keystroke is waiting, 
                                  or it is the character waiting to be 
                                  read, in the same format as the %@AB@%%@AE@%
                                  %@AB@%_KEYBRD_READ%@AE@% or  %@AB@%_NKEYBRD_READY%@AE@% return. 
                                  This service does not remove the waiting
                                  character from the input buffer, as does
                                  the%@AB@% _KEYBRD_READ%@AE@% or %@AB@%_NKEYBRD_READ%@AE@% 
                                  service.  The %@AB@%_NKEYBRD_READY%@AE@% constant is
                                  used with enhanced keyboards to obtain 
                                  the scan codes for function keys F11 and
                                  F12 and the cursor control keys.

%@AB@%_KEYBRD_SHIFTSTATUS%@AE@%, %@AB@%%@AE@%             Returns the current SHIFT-key status. 
%@AB@%_NKEYBRD_SHIFTSTATUS%@AE@%              Only the low-order byte of the return 
                                  value is affected. The %@AB@%%@AE@%
                                  %@AB@%_NKEYBRD_SHIFTSTATUS%@AE@% constant is used to
                                  get a full 16-bit status value. Any 
                                  combination of the following bits may be
                                  set:

                                  %@AB@%Bit%@AE@%         %@AB@%Meaning%@AE@% %@AB@%if%@AE@% %@AB@%True%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
                                  00H         Rightmost SHIFT key pressed

                                  01H         Leftmost SHIFT key pressed

                                  02H         Either CTRL key pressed

                                  3H          Either ALT key pressed

                                  04H         SCROLL LOCK on

                                  05H         NUM LOCK on

                                  06H         CAPS LOCK on

                                  07H         In insert mode (INS)

                                  08H         Left CTRL key pressed

                                  09H         Left ALT key pressed

                                  0AH         Right CTRL key pressed

                                  0BH         Right ALT key pressed

                                  0CH         SCROLL LOCK key pressed

                                  0DH         NUM LOCK key pressed

                                  0EH         CAPS LOCK key pressed

                                  0FH         SYS REQ key pressed

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
With the %@AB@%...READ%@AE@% and %@AB@%...SHIFTSTATUS%@AE@% arguments, the %@AB@%_bios_keybrd%@AE@% function
returns the contents of the AX register after the BIOS call.  %@NL@%
%@NL@%
With the %@AB@%...READY%@AE@% argument, %@AB@%_bios_keybrd%@AE@% returns 0 if there is no key. If
there is a key, %@AB@%_bios_keybrd%@AE@% returns the key waiting to be read (i.e. the
same value as %@AB@%_KEYBRD_READ%@AE@%).  %@NL@%
%@NL@%
With the %@AB@%...READ%@AE@% and the %@AB@%...READY%@AE@% arguments, the %@AB@%_bios_keybrd%@AE@% function
returns -1 if CTRL+BREAK has been pressed and is the next keystroke to be
read.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BKEYBRD.C: This program prints a message on the screen until the
%@AS@%   * right SHIFT key is pressed.
%@AS@%   */
%@AS@%  
%@AS@%  #include <bios.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     while( !(_bios_keybrd( _KEYBRD_SHIFTSTATUS ) & 0001) )
%@AS@%        printf( "Use the right SHIFT key to stop this message\n" );
%@AS@%     printf( "Right SHIFT key pressed\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Use the right SHIFT key to stop this message
%@AS@%  Use the right SHIFT key to stop this message
%@AS@%  Use the right SHIFT key to stop this message
%@AS@%  Use the right SHIFT key to stop this message
%@AS@%  Right SHIFT key pressed%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_bios_memsize@%%@NL@%
%@2@%%@CR:C6A00250206 @%%@AB@%_bios_memsize%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00250207 @% %@CR:C6A00250208 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calls the BIOS memory-size service, using system call INT 0x12.  %@NL@%
%@NL@%
%@AB@%#include <bios.h>%@AE@%  %@NL@%
%@NL@%
%@AS@%  unsigned _bios_memsize( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bios_memsize%@AE@% routine uses system call INT 0x12 to determine the total
amount of main memory installed.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The routine returns the total amount of installed memory in 1K blocks. The
maximum return value is 640, representing 640K of main memory.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BMEMSIZE.C: This program displays the amount of memory installed. */
%@AS@%  
%@AS@%  #include <bios.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned memory;
%@AS@%  
%@AS@%     memory = _bios_memsize();
%@AS@%     printf ( "The amount of memory installed is: %dK\n", memory );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The amount of memory installed is: 639K%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_bios_printer@%%@NL@%
%@2@%%@CR:C6A00260209 @%%@AB@%_bios_printer%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00260210 @% %@CR:C6A00260211 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calls BIOS printer services using system call INT 0x17.  %@NL@%
%@NL@%
%@AB@%#include <bios.h>%@AE@%  %@NL@%
%@NL@%
%@AS@%  unsigned _bios_printer( unsigned service, unsigned printer, unsigned data
%@AS@%  );%@AE@%%@NL@%
%@NL@%
%@AI@%service%@AE@%                           Printer function desired

%@AI@%printer%@AE@%                           Target printer port

%@AI@%data%@AE@%                              Output data

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bios_printer%@AE@% routine uses system call INT 0x17 to perform printer
output services for parallel printers. The %@AI@%printer%@AE@% argument specifies the
affected printer, where 0 is LPT1, 1 is LPT2, and so forth.  %@NL@%
%@NL@%
Some printers do not support the full set of signals. As a result, the "Out
of Paper" condition, for example, may not be returned to your program.  %@NL@%
%@NL@%
The %@AI@%service%@AE@% argument can be any of the following manifest constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_PRINTER_INIT%@AE@%                     Initializes the selected printer. The %@AI@%%@AE@%
                                  %@AI@%data%@AE@% argument is ignored. The return 
                                  value is the low-order status byte 
                                  defined below.

%@AB@%_PRINTER_STATUS%@AE@%                   Returns the printer status in the 
                                  low-order status byte defined below. The%@AI@%%@AE@%
                                  %@AI@%data%@AE@% argument is ignored.

%@AB@%_PRINTER_WRITE%@AE@%                    Sends the low-order byte of %@AI@%data%@AE@% to the 
                                  printer specified by %@AI@%printer%@AE@%. The 
                                  low-order byte of the return value 
                                  indicates the printer status after the 
                                  operation, as defined below:%@AI@%%@AE@%

                                  %@AB@%Bit%@AE@%      %@AB@%Meaning%@AE@% %@AB@%if%@AE@% %@AB@%True%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
                                  0         Printer timed out

                                  1         Not used

                                  2         Not used

                                  3         I/O error

                                  4         Printer selected

                                  5         Out of paper

                                  6         Acknowledge

                                  7         Printer not busy

%@AB@%%@AE@%

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bios_printer%@AE@% function returns the value in the AX register after the
BIOS interrupt.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BPRINTER.C: This program checks the status of the printer attached to
%@AS@%   * LPT1 when it is off line, then initializes the printer.
%@AS@%   */
%@AS@%  
%@AS@%  #include <bios.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  #define LPT1 0
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned status;
%@AS@%  
%@AS@%     printf ( "Place printer off line and press any key\n" );
%@AS@%     getch();
%@AS@%  
%@AS@%     status = _bios_printer( _PRINTER_STATUS, LPT1, 0 );
%@AS@%     printf( "Status with printer off line: 0x%.4x\n\n", status );
%@AS@%     printf( "Put the printer on line and then\n" );
%@AS@%     printf( "Press any key to initialize printer\n" );
%@AS@%     getch();
%@AS@%  
%@AS@%     status = _bios_printer( _PRINTER_INIT, LPT1, 0 );
%@AS@%     printf( "Status after printer initialized: 0x%.4x\n", status );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Place printer off line and press any key
%@AS@%  Status with printer off line: 0x0018
%@AS@%  
%@AS@%  Put the printer on line and then
%@AS@%  Press any key to initialize printer
%@AS@%  Status after printer initialized: 0x0090%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_bios_serialcom@%%@NL@%
%@2@%%@CR:C6A00270212 @%%@AB@%_bios_serialcom%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00270213 @% %@CR:C6A00270214 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calls BIOS communications services, using system call INT 0x14.  %@NL@%
%@NL@%
%@AB@%#include <bios.h>%@AE@%  %@NL@%
%@NL@%
%@AS@%  unsigned _bios_serialcom( unsigned service, unsigned serial_port, unsigned
%@AS@%  data );%@AE@%%@NL@%
%@NL@%
%@AI@%service%@AE@%                           Communications service

%@AI@%serial_port%@AE@%                       Serial port to use

%@AI@%data%@AE@%                              Port configuration bits

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bios_serialcom%@AE@% routine uses system call INT 0x14 to provide serial
communications services. The %@AI@%serial_port%@AE@% argument is set to 0 for COM1, to 1
for COM2, and so on.  %@NL@%
%@NL@%
The %@AB@%_bios_serialcom%@AE@% routine may not be able to establish reliable
communications at baud rates in excess of 1,200 baud ( %@AB@%_COM_1200%@AE@%) due to the
overhead associated with servicing computer interrupts. Faster data
communication rates are possible with more direct programming of serial-port
controllers. See %@AI@%C Programmer's Guide to Serial Communications%@AE@% for more
details on serial-communications programming in C.  %@NL@%
%@NL@%
The %@AI@%service%@AE@% argument can be set to one of the following manifest constants:
%@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Service%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_COM_INIT%@AE@%                         Sets the port to the parameters 
                                  specified in the %@AI@%data%@AE@% argument

%@AB@%_COM_SEND%@AE@%                         Transmits the %@AI@%data%@AE@% characters over the 
                                  selected serial port

%@AB@%_COM_RECEIVE%@AE@%                      Accepts an input character from the 
                                  selected serial port

%@AB@%_COM_STATUS%@AE@%                       Returns the current status of the 
                                  selected serial port

The %@AI@%data%@AE@% argument is ignored if %@AI@%service%@AE@% is set to %@AB@%_COM_RECEIVE%@AE@% or
%@AB@%_COM_STATUS.%@AE@% The %@AI@%data%@AE@% argument for %@AB@%_COM_INIT%@AE@% is created by combining (with
the OR operator) one or more of the following constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_COM_CHR7 %@AE@%                        7 data bits

%@AB@%_COM_CHR8%@AE@%                         8 data bits

%@AB@%_COM_STOP1%@AE@%                        1 stop bit

%@AB@%_COM_STOP2%@AE@%                        2 stop bits

%@AB@%_COM_NOPARITY%@AE@%                     No parity

%@AB@%_COM_EVENPARITY%@AE@%                   Even parity

%@AB@%_COM_ODDPARITY%@AE@%                    Odd parity

%@AB@%_COM_110%@AE@%                          110 baud

%@AB@%_COM_150%@AE@%                          150 baud

%@AB@%_COM_300%@AE@%                          300 baud

%@AB@%_COM_600%@AE@%                          600 baud

%@AB@%_COM_1200%@AE@%                         1,200 baud

%@AB@%_COM_2400%@AE@%                         2,400 baud

%@AB@%_COM_4800%@AE@%                         4,800 baud

%@AB@%_COM_9600%@AE@%                         9,600 baud

The default value of %@AI@%data%@AE@% is 1 stop bit, no parity, and 110 baud.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns a 16-bit integer whose high-order byte contains status
bits. The meaning of the low-order byte varies, depending on the %@AI@%service%@AE@%
value. The high-order bits have the following meanings:  %@NL@%
%@NL@%
%@AB@%Bit%@AE@%                               %@AB@%Meaning if Set%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
15                                Timed out

14                                Transmission-shift register empty

13                                Transmission-hold register empty

12                                Break detected

11                                Framing error

10                                Parity error

9                                 Overrun error

8                                 Data ready

When %@AI@%service%@AE@% is%@AB@% _COM_SEND%@AE@%, bit 15 will be set if %@AI@%data%@AE@% could not be sent.  %@NL@%
%@NL@%
When %@AI@%service%@AE@% is %@AB@%_COM_RECEIVE%@AE@%, the byte read will be returned in the
low-order bits if the call is successful. If an error occurs, any of the
bits 9, 10, 11, or 15 will be set.  %@NL@%
%@NL@%
When %@AI@%service%@AE@% is %@AB@%_COM_INIT%@AE@% or %@AB@%_COM_STATUS%@AE@%, the low-order bits are defined as
follows:  %@NL@%
%@NL@%
%@AB@%Bit%@AE@%                               %@AB@%Meaning if Set%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
7                                 Receive-line signal detected

6                                 Ring indicator

5                                 Data set ready

4                                 Clear to send

3                                 Change in receive-line signal detected

2                                 Trailing-edge ring indicator

1                                 Change in data-set-ready status

0                                 Change in clear-to-send status

Note that this function works only with IBM personal computers and true
compatibles.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BSERIALC.C: This program checks the status of serial port COM1. */
%@AS@%  
%@AS@%  #include <bios.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned com1_status;
%@AS@%  
%@AS@%     com1_status =  _bios_serialcom( _COM_STATUS, 0, 0 );
%@AS@%     printf ( "COM1 status: 0x%.4x\n", com1_status );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  COM1 status: 0x6000%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_bios_timeofday@%%@NL@%
%@2@%%@CR:C6A00280215 @%%@AB@%_bios_timeofday%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00280216 @% %@CR:C6A00280217 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calls BIOS time and date services, using system call INT 0x1A.  %@NL@%
%@NL@%
%@AB@%#include <bios.h>%@AE@%  %@NL@%
%@NL@%
%@AS@%  unsigned _bios_timeofday( unsigned service, long *timeval );%@AE@%%@NL@%
%@NL@%
%@AI@%service%@AE@%                           Time function desired

%@AI@%timeval%@AE@%                           Clock count

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bios_timeofday%@AE@% routine uses system call INT 0x1A to get or set the
clock count. The %@AI@%service%@AE@% argument can be either of the following manifest
constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_TIME_GETCLOCK%@AE@%                    Copies the current value of the clock 
                                  count to the location pointed to by %@AI@%%@AE@%
                                  %@AI@%timeval%@AE@%. If midnight has not passed 
                                  since the last time the system clock was
                                  read or set, the function returns 0; 
                                  otherwise, the function returns 1.

%@AB@%_TIME_SETCLOCK%@AE@%                    Sets the current value of the system 
                                  clock to the value in the location 
                                  pointed to by %@AI@%timeval%@AE@%. There is no 
                                  return value.

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_bios_timeofday%@AE@% function returns the value in the AX register after the
BIOS interrupt.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BTIMEOFD.C: This program gets the current system clock count before and
%@AS@%  after
%@AS@%   * a "do-nothing" loop and displays the difference.
%@AS@%   */
%@AS@%  
%@AS@%  #include <bios.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     long i, begin_tick, end_tick;
%@AS@%  
%@AS@%     _bios_timeofday( _TIME_GETCLOCK, &begin_tick );
%@AS@%     printf( "Beginning tick count: %lu\n", begin_tick );
%@AS@%     for( i = 1; i <= 900000; i++ )
%@AS@%        ;
%@AS@%     _bios_timeofday( _TIME_GETCLOCK, &end_tick );
%@AS@%     printf( "Ending tick count:    %lu\n", end_tick );
%@AS@%     printf( "Elapsed ticks:        %lu\n", end_tick - begin_tick );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Beginning tick count: 1114255
%@AS@%  Ending tick count:    1114287
%@AS@%  Elapsed ticks:        32 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:bsearch@%%@NL@%
%@2@%%@CR:C6A00290218 @%%@AB@%bsearch%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00290219 @%%@CR:C6A00290220 @%%@CR:C6A00290221 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Performs binary search of a sorted array.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required for ANSI compatibility

%@AB@%#include <search.h>%@AE@%               Required only for function declarations

%@AS@%  void *bsearch( const void *key, const void *base, size_t num, size_t
%@AS@%  width, 
%@AS@%  int ( *compare )( const void *elem1, const void *elem2 ) );%@AE@%%@NL@%
%@NL@%
%@AI@%key%@AE@%                               Object to search for

%@AI@%base%@AE@%                              Pointer to base of search data

%@AI@%num%@AE@%                               Number of elements

%@AI@%width%@AE@%                             Width of elements

%@AI@%compare%@AE@%                           Function that compares two elements:  %@AI@%%@AE@%
                                  %@AI@%elem1%@AE@% and %@AI@%elem2%@AE@%

%@AI@%elem1%@AE@%                             Pointer to the key for the search

%@AI@%elem2%@AE@%                             Pointer to the array element to be 
                                  compared with the key

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%bsearch%@AE@% function performs a binary search of a sorted array of %@AI@%num%@AE@%
elements, each of %@AI@%width%@AE@% bytes in size. The %@AI@%base%@AE@% value is a pointer to the
base of the array to be searched, and %@AI@%key%@AE@% is the value being sought.  %@NL@%
%@NL@%
The %@AI@%compare%@AE@% argument is a pointer to a user-supplied routine that compares
two array elements and returns a value specifying their relationship. The
%@AB@%bsearch%@AE@% function calls the %@AI@%compare%@AE@% routine one or more times during the
search, passing pointers to two array elements on each call. The routine
compares the elements, then returns one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
< 0                               %@AI@%elem1%@AE@% less than %@AI@%elem2%@AE@%

= 0                               %@AI@%elem1%@AE@% identical to %@AI@%elem2%@AE@%

> 0                               %@AI@%elem1%@AE@% greater than %@AI@%elem2%@AE@%

If the array you are searching is not in ascending sort order, %@AB@%bsearch%@AE@% does
not work properly. If the array contains duplicate records with identical
keys, there is no way to predict which of the duplicate records will be
located by %@AB@%bsearch%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%bsearch%@AE@% function returns a pointer to the first occurrence of %@AI@%key%@AE@% in the
array pointed to by %@AI@%base%@AE@%. If %@AI@%key%@AE@% is not found, the function returns %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%lfind%@AE@%, %@AB@%lsearch%@AE@%, %@AB@%qsort%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* BSEARCH.C: This program reads the command-line arguments, sorting them
%@AS@%   * with qsort, and then uses bsearch to find the word "cat."
%@AS@%   */
%@AS@%  
%@AS@%  #include <search.h>
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  int compare( char **arg1, char **arg2 );  /* Declare a function for
%@AS@%compare */
%@AS@%  
%@AS@%  void main( int argc, char **argv )
%@AS@%  {
%@AS@%  
%@AS@%     char **result;
%@AS@%     char *key = "cat";
%@AS@%     int i;
%@AS@%  
%@AS@%     /* Sort using Quicksort algorithm: */
%@AS@%     qsort( (char *)argv, argc, sizeof( char * ), compare );
%@AS@%  
%@AS@%     for( i = 0; i < argc; ++i )        /* Output sorted list */
%@AS@%        printf( "%s ", argv[i] );
%@AS@%  
%@AS@%     /*  Find the word "cat" using a binary search algorithm: */
%@AS@%     result = (char **)bsearch( (char *) &key, (char *)argv, argc,
%@AS@%                                sizeof( char * ), compare );
%@AS@%     if( result )
%@AS@%        printf( "\n%s found at %Fp\n", *result, result );
%@AS@%     else
%@AS@%        printf( "\nCat not found!\n" );
%@AS@%  }
%@AS@%  
%@AS@%  int compare( char **arg1, char **arg2 )
%@AS@%  {
%@AS@%     /* Compare all of both strings: */
%@AS@%     return strcmpi( *arg1, *arg2 );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  [C:\LIBREF] bsearch dog pig horse cat human rat cow goat
%@AS@%  bsearch cat cow dog goat horse human pig rat
%@AS@%  cat found at 0292:0FD0 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:cabs@%%@QR:cabsl@%%@NL@%
%@2@%%@CR:C6A00300222 @%%@AB@%cabs, cabsl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00300223 @%%@CR:C6A00300224 @%%@CR:C6A00300225 @% %@CR:C6A00300226 @%%@CR:C6A00300227 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate absolute value of a complex number.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double cabs( struct complex z );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double cabsl( struct _complexl z );%@AE@%%@NL@%
%@NL@%
%@AI@%z%@AE@%                                 Complex number

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%cabs%@AE@% and %@AB@%cabsl%@AE@% functions calculate the absolute value of a complex
number, which must be a structure of type %@AB@%complex%@AE@% (or %@AB@%_complexl%@AE@%). The
structure %@AI@%z%@AE@% is composed of a real component %@AI@%x%@AE@% and an imaginary component %@AI@%y%@AE@%.
A call to one of the %@AB@%cabs%@AE@% routines is equivalent to the following:  %@NL@%
%@NL@%
%@AS@%  
%@AS@%  sqrt( z.x*z.x + z.y*z.y )%@AE@%%@NL@%
%@NL@%
The %@AB@%cabsl%@AE@% function is the 80-bit counterpart and it uses the 80-bit, 10-byte
coprocessor form of arguments and return values. See the reference page on
the long double functions for more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
On overflow, these functions call %@AB@%matherr%@AE@% or %@AB@%_matherrl%@AE@%, return %@AB@%HUGE_VAL%@AE@%, and
set %@AB@%errno%@AE@% to %@AB@%ERANGE%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  cabs%@AE@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AS@%  cabsl%@AE@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%abs%@AE@%, %@AB@%fabs%@AE@%, %@AB@%labs%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CABS.C: Using cabs, this program calculates the absolute value of
%@AS@%   * a complex number.
%@AS@%   */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct complex number = { 3.0, 4.0 };
%@AS@%     double d;
%@AS@%  
%@AS@%     d = cabs( number );
%@AS@%     printf( "The absolute value of %f + %fi is %f\n",
%@AS@%             number.x, number.y, d );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The absolute value of 3.000000 + 4.000000i is 5.000000 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:calloc@%%@NL@%
%@2@%%@CR:C6A00310228 @%%@AB@%calloc Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00310229 @%%@CR:C6A00310230 @%%@CR:C6A00310231 @% %@CR:C6A00310232 @%%@CR:C6A00310233 @% %@CR:C6A00310234 @%%@CR:C6A00310235 @% %@CR:C6A00310236 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Allocate an array in memory with elements initialized to 0.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               For ANSI compatibility (%@AB@%calloc%@AE@% only) 

%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  void *calloc( size_t num, size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _based( void ) *_bcalloc( _segment seg, size_t num, size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far *_fcalloc( size_t num, size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _near *_ncalloc( size_t num, size_t size );%@AE@%%@NL@%
%@NL@%
%@AI@%num%@AE@%                               Number of elements

%@AI@%size%@AE@%                              Length in bytes of each element

%@AI@%seg%@AE@%                               Segment selector

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%calloc%@AE@% family of functions allocates storage space for an array of %@AI@%num%@AE@%
elements, each of length %@AI@%size%@AE@% bytes. Each element is initialized to 0.  %@NL@%
%@NL@%
In large data models (compact-, large-, and huge-model programs), %@AB@%calloc%@AE@%
maps to %@AB@% _fcalloc%@AE@%. In small data models (tiny-, small-, and medium-model
programs), %@AB@%calloc%@AE@% maps to %@AB@%_ncalloc%@AE@%.  %@NL@%
%@NL@%
The various %@AB@%calloc%@AE@% functions allocate storage space in the data segments
shown in the list below:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Data Segment%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%calloc%@AE@%                            Depends on data model of program

%@AB@%_bcalloc%@AE@%                          Based heap, specified by %@AI@%seg%@AE@% segment 
                                  selector

%@AB@%_fcalloc%@AE@%                          Far heap (outside default data segment)

%@AB@%_ncalloc%@AE@%                          Near heap (inside default data segment)

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%calloc%@AE@% functions return a pointer to the allocated space. The storage
space pointed to by the return value is guaranteed to be suitably aligned
for storage of any type of object. To get a pointer to a type other than
%@AB@%void%@AE@%, use a type cast on the return value.  %@NL@%
%@NL@%
The %@AB@%_fcalloc%@AE@% and %@AB@%_ncalloc%@AE@% functions return %@AB@%NULL%@AE@% if there is insufficient
memory available or if %@AI@%num%@AE@% or %@AI@%size%@AE@% is 0. The %@AB@%_bcalloc%@AE@% function returns
%@AB@%_NULLOFF%@AE@% in this case.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  calloc%@AE@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_bcalloc%@AE@%, %@AB@%_fcalloc%@AE@%, %@AB@%_ncalloc%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%free %@AE@%functions, %@AB@%halloc%@AE@%, %@AB@%hfree%@AE@%, %@AB@%malloc %@AE@%functions, %@AB@%realloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CALLOC.C: This program uses calloc to allocate space for 40 long
%@AS@%  integers.
%@AS@%   * It initializes each element to zero.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <malloc.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     long *buffer;
%@AS@%  
%@AS@%     buffer = (long *)calloc( 40, sizeof( long ) );
%@AS@%     if( buffer != NULL )
%@AS@%        printf( "Allocated 40 long integers\n" );
%@AS@%     else
%@AS@%        printf( "Can't allocate memory\n" );
%@AS@%     free( buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Allocated 40 long integers %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ceil@%%@QR:ceill@%%@NL@%
%@2@%%@CR:C6A00320237 @%%@AB@%ceil, ceill%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00320238 @%%@CR:C6A00320239 @%%@CR:C6A00320240 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate the ceiling of a value.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double ceil( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double ceill( long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Floating-point value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ceil%@AE@% and %@AB@%ceill%@AE@% functions return a %@AB@%double%@AE@% (or %@AB@%long double%@AE@%) value
representing the smallest integer that is greater than or equal to %@AI@%x%@AE@%.  %@NL@%
%@NL@%
The %@AB@%ceill%@AE@% function is the 80-bit counterpart and it uses the 80-bit, 10-byte
coprocessor form of arguments and return values. See the reference page on
the long double functions for more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return the %@AB@%double%@AE@% or %@AB@%long double%@AE@% result. There is no error
return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  ceil%@AE@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AS@%  ceill%@AE@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%floor%@AE@%, %@AB@%fmod%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FLOOR.C: This example displays the largest integers less than or equal
%@AS@%   * to the floating-point values 2.8 and -2.8. It then shows the smallest
%@AS@%   * integers greater than or equal to 2.8 and -2.8.
%@AS@%   */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     double y;
%@AS@%  
%@AS@%     y = floor( 2.8 );
%@AS@%     printf( "The floor of 2.8 is %f\n", y );
%@AS@%     y = floor( -2.8 );
%@AS@%     printf( "The floor of -2.8 is %f\n", y );
%@AS@%  
%@AS@%     y = ceil( 2.8 );
%@AS@%     printf( "The ceil of 2.8 is %f\n", y );
%@AS@%     y = ceil( -2.8 );
%@AS@%     printf( "The ceil of -2.8 is %f\n", y );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The floor of 2.8 is 2.000000
%@AS@%  The floor of -2.8 is -3.000000
%@AS@%  The ceil of 2.8 is 3.000000
%@AS@%  The ceil of -2.8 is -2.000000 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_cexit@%%@QR:_c_exit@%%@NL@%
%@2@%%@CR:C6A00330241 @%%@AB@%_cexit, _c_exit%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Perform clean-up operations and return without terminating the process.  %@NL@%
%@NL@%
%@CR:C6A00330242 @%%@CR:C6A00330243 @%%@AS@%  #include <process.h>       %@AE@%%@NL@%
%@NL@%
%@AS@%  void _cexit( void ); %@AE@%%@NL@%
%@NL@%
%@AS@%  void _c_exit( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_cexit%@AE@% function calls, in LIFO ("last in, first out") order, the
functions registered by %@AB@%atexit%@AE@% and %@AB@%onexit%@AE@%. Then the %@AB@%_cexit%@AE@% function flushes
all I/O buffers and closes all open files before returning.  %@NL@%
%@NL@%
The %@AB@%_c_exit%@AE@% function returns to the calling process without processing
%@AB@%atexit%@AE@% or %@AB@%onexit%@AE@% functions or flushing stream buffers.  %@NL@%
%@NL@%
The behavior of the %@AB@%exit%@AE@%, %@AB@%_exit%@AE@%, %@AB@%_cexit%@AE@%, and %@AB@%_c_exit%@AE@% functions is described
in the following list:  %@NL@%
%@NL@%
%@AB@%Function %@AE@%                         %@AB@%Action%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%exit%@AE@%                              Performs complete C library termination 
                                  procedures, terminates the process, and 
                                  exits with the supplied status code

%@AB@%_exit%@AE@%                             Performs "quick" C library termination 
                                  procedures, terminates the process, and 
                                  exits with the supplied status code

%@AB@%_cexit%@AE@%                            Performs complete C library termination 
                                  procedures and returns to caller, but 
                                  does not terminate the process

%@AB@%_c_exit%@AE@%                           Performs "quick" C library termination 
                                  procedures and returns to caller, but 
                                  does not terminate the process

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%abort%@AE@%, %@AB@%atexit%@AE@%, %@AB@%exec%@AE@% functions, %@AB@%exit%@AE@%, %@AB@%onexit%@AE@%, %@AB@%spawn%@AE@% functions, %@AB@%system%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:cgets@%%@NL@%
%@2@%%@CR:C6A00340244 @%%@AB@%cgets%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00340245 @% %@CR:C6A00340246 @% %@CR:C6A00340247 @%%@CR:C6A00340248 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets a character string from the console.  %@NL@%
%@NL@%
%@AB@%#include <conio.h>%@AE@%                Required only for function declarations

%@AS@%  char *cgets( char *buffer );%@AE@%%@NL@%
%@NL@%
%@AI@%buffer%@AE@%                            Storage location for data

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%cgets%@AE@% function reads a string of characters directly from the console
and stores the string and its length in the location pointed to by %@AI@%buffer%@AE@%.
The %@AI@%buffer%@AE@% argument must be a pointer to a character array. The first
element of the array, %@AI@%buffer%@AE@%[0], must contain the maximum length (in
characters) of the string to be read. The array must contain enough elements
to hold the string, a terminating null character (%@AB@%'\0'%@AE@%), and two additional
bytes.  %@NL@%
%@NL@%
The %@AB@%cgets%@AE@% function continues to read characters until a
carriage-return-line-feed (CR-LF) combination is read, or the specified
number of characters is read. The string is stored starting at %@AI@%str%@AE@%[2]. If a
CR-LF combination is read, it is replaced with a null character (%@AB@%'\0'%@AE@%)
before being stored. The %@AB@%cgets%@AE@% function then stores the actual length of the
string in the second array element, %@AI@%buffer%@AE@%[1].  %@NL@%
%@NL@%
Because all DOS editing keys are active when you call %@AB@%cgets%@AE@%, pressing F3
repeats the last entry.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%cgets%@AE@% function returns a pointer to the start of the string, at
%@AI@%buffer%@AE@%[2]. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%getch%@AE@%, %@AB@%getche%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CGETS.C: This program creates a buffer and initializes the first byte
%@AS@%   * to the size of the buffer - 2. Next, the program accepts an input
%@AS@%string
%@AS@%   * using cgets and displays the size and text of that string.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[82] = { 80 };  /* Maximum characters in first byte */
%@AS@%     char *result;
%@AS@%  
%@AS@%     printf( "Input line of text, followed by carriage return:\n");
%@AS@%     result = cgets( buffer );  /* Input a line of text */
%@AS@%     printf( "\nLine length = %d\nText = %s\n", buffer[1], result );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Input line of text, followed by carriage return:
%@AS@%  This is some text
%@AS@%  Line length = 17
%@AS@%  Text = This is some text %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_chain_intr@%%@NL@%
%@2@%%@CR:C6A00350249 @%%@AB@%_chain_intr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00350250 @% %@CR:C6A00350251 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Chains an interrupt from one handler to another.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _chain_intr( void( _interrupt _far *target )());%@AE@%%@NL@%
%@NL@%
%@AI@%target%@AE@%                            Target interrupt routine

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_chain_intr%@AE@% routine passes control from one interrupt handler to
another. The stack and the registers of the first routine are passed to the
second, allowing the second routine to return as if it had been called
directly.  %@NL@%
%@NL@%
The %@AB@%_chain_intr%@AE@% routine is generally used when a user-defined interrupt
handler begins processing, then chains to the original interrupt handler to
finish processing.  %@NL@%
%@NL@%
Chaining is one of two techniques, listed below, that can be used to
transfer control from a new interrupt routine to an old one:  %@NL@%
%@NL@%
%@NL@%
  1.  Call %@AB@%_chain_intr%@AE@% with the interrupt routine as an argument. Do this if
      your routine is finished and you want the second interrupt routine to
      terminate the interrupt call.
%@NL@%
%@AS@%      void _interrupt new_int( unsigned _es, unsigned _ds,
%@AS@%         unsigned _di, unsigned _si,... )
%@AS@%      {
%@AS@%          ++_di;                  /* Initial processing here  */
%@AS@%          _chain_intr( old_int ); /* New DI passed to old_int */
%@AS@%          --_di;                  /* This is never executed   */
%@AS@%      }%@AE@%%@NL@%
%@NL@%
%@NL@%
  2.  Call the interrupt routine (after casting it to an interrupt function
      if necessary). Do this if you need to do further processing after the
      second interrupt routine finishes.
%@NL@%
%@AS@%      void _interrupt new_int( unsigned _es, unsigned _ds,
%@AS@%         unsigned _di, unsigned _si,... )
%@AS@%      {
%@AS@%          ++_di;                   /* Initial processing here  */
%@AS@%          (*old_int)();            /* New DI passed to old_int */
%@AS@%          _asm mov _di, di         /* Put real DI from old_int */
%@AS@%                                   /*   into _di for return    */
%@AS@%      }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
Note that the real registers set by the old interrupt function are not
automatically set to the pseudoregisters of the new routine.  %@NL@%
%@NL@%
Use the %@AB@%_chain_intr%@AE@% function when you do not want to replace the default
interrupt handler, but you do need to see its input. An example is a TSR
(terminate-and-stay-resident) program that checks all keyboard input for a
particular "hot key" sequence.  %@NL@%
%@NL@%
The %@AB@%_chain_intr%@AE@% function should be used only with C functions that have been
declared with type %@AB@%_interrupt%@AE@%. The %@AB@%_interrupt%@AE@% declaration ensures that the
procedure's entry/exit sequence is appropriate for an interrupt handler.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_chain_intr%@AE@% function does not return to the caller.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_getvect%@AE@%,  %@AB@%_dos_keep%@AE@%,  %@AB@%_dos_setvect%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:chdir@%%@NL@%
%@2@%%@CR:C6A00360252 @%%@AB@%chdir%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00360253 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Changes the current working directory.  %@NL@%
%@NL@%
%@AB@%#include <direct.h%@AE@%>               Required only for function declarations

%@AB@%#include <errno.h>%@AE@%                Required for %@AB@%errno%@AE@% constants

%@AS@%  int chdir( char *dirname );%@AE@%%@NL@%
%@NL@%
%@AI@%dirname%@AE@%                           Path name of new working directory

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%chdir%@AE@% function changes the current working directory to the directory
specified by %@AI@% dirname%@AE@%. The %@AI@%dirname%@AE@% argument must refer to an existing
directory.  %@NL@%
%@NL@%
This function can change the current working directory on any drive; it
cannot be used to change the default drive itself. For example, if A: is the
default drive and \BIN is the current working directory, the following call
changes the current working directory for drive C:  %@NL@%
%@NL@%
%@AS@%  chdir("c:\\temp");%@AE@%%@NL@%
%@NL@%
Notice that you must place two backslashes ( \\ ) in a C string in order to
represent a single backslash ( \ ); the backslash is the escape character
for C strings and therefore requires special handling.  %@NL@%
%@NL@%
This function call has no apparent immediate effect. However, when the
%@AB@%_chdrive%@AE@% function is called to change the default drive to C:, the current
working directory becomes C:\TEMP.  %@NL@%
%@NL@%
In OS/2 protected mode, the current working directory is local to a process
rather than system-wide. When a process terminates, the current working
directory is restored to its original value. Under DOS, the new directory
set by the program becomes the new current working directory.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%chdir%@AE@% function returns a value of 0 if the working directory is
successfully changed. A return value of -1 indicates an error, in which case
%@AB@%errno%@AE@% is set to %@AB@%ENOENT%@AE@%, indicating that the specified path name could not be
found.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_setdrive%@AE@%, %@AB@%mkdir%@AE@%, %@AB@%rmdir%@AE@%, %@AB@%system%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CHGDIR.C: This program uses the chdir function to verify that a
%@AS@%   * given directory exists. Under real mode that directory also becomes
%@AS@%   * the current directory. Under protected mode, it is only the default
%@AS@%   * directory for the current process.
%@AS@%   */
%@AS@%  
%@AS@%  #include <direct.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main( int argc, char *argv[] )
%@AS@%  {
%@AS@%     if( chdir( argv[1] )   )
%@AS@%        printf( "Unable to locate the directory: %s\n", argv[1] );
%@AS@%     else
%@AS@%        system( "dir *.c" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  [C:\LIBREF] chgdir \tmp
%@AS@%  
%@AS@%   The volume label in drive C is OS2.
%@AS@%   Directory of C:\TMP
%@AS@%  
%@AS@%  DUP      C        232   4-18-89  11:18a
%@AS@%  TEST     C        713   4-07-88   2:49p
%@AS@%       2 File(s)   14155776 bytes free %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_chdrive@%%@NL@%
%@2@%%@CR:C6A00370254 @%%@AB@%_chdrive%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00370255 @%%@CR:C6A00370256 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Changes the current working drive.  %@NL@%
%@NL@%
%@AB@%#include <direct.h>%@AE@%               Required only for function declarations

%@AS@%  int _chdrive( int drive );%@AE@%%@NL@%
%@NL@%
%@AI@%drive%@AE@%                             Number of new working drive

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_chdrive%@AE@% function changes the current working drive to the drive
specified by %@AI@%drive%@AE@%. The %@AI@%drive%@AE@% argument uses an integer to specify the new
working drive (1=A, 2=B, etc.).  %@NL@%
%@NL@%
This function changes only the working drive; the %@AB@%chdir%@AE@% function changes the
working directory.  %@NL@%
%@NL@%
In OS/2 protected mode, the working drive is local to a process rather than
system-wide. When a process terminates, the working drive is restored to its
original value. Under DOS, the new drive set by the program becomes the new
working drive.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_chdrive%@AE@% function returns a value of 0 if the working drive is
successfully changed. A return value of -1 indicates an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%chdir%@AE@%,  %@AB@%_dos_setdrive%@AE@%,  %@AB@%_fullpath%@AE@%, %@AB@% _getcwd%@AE@%, %@AB@% _getdrive%@AE@%, %@AB@%mkdir%@AE@%, %@AB@%rmdir%@AE@%,
%@AB@%system%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GETDRIVE.C illustrates drive functions including:
%@AS@%   *      _getdrive       _chdrive        _getdcwd
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <direct.h>
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     int ch, drive, curdrive;
%@AS@%     static char path[_MAX_PATH];
%@AS@%  
%@AS@%     /* Save current drive. */
%@AS@%     curdrive = _getdrive();
%@AS@%  
%@AS@%     printf( "Available drives are: \n" );
%@AS@%  
%@AS@%     /* If we can switch to the drive, it exists. */
%@AS@%     for( drive = 1; drive <= 26; drive++ )
%@AS@%        if( !_chdrive( drive ) )
%@AS@%           printf( "%c: ", drive + 'A' - 1 );
%@AS@%  
%@AS@%     while( 1 )
%@AS@%     {
%@AS@%        printf( "\nType drive letter to check or ESC to quit: " );
%@AS@%        ch = getch();
%@AS@%        if( ch == 27 )
%@AS@%           break;
%@AS@%        if( isalpha( ch ) )
%@AS@%           putch( ch );
%@AS@%        if( _getdcwd( toupper( ch ) - 'A' + 1, path, _MAX_PATH ) != NULL )
%@AS@%           printf( "\nCurrent directory on that drive is %s\n", path );
%@AS@%     }
%@AS@%  
%@AS@%     /* Restore original drive. This is only necessary for DOS. Under OS/2
%@AS@%      * the current drive of the calling process is always restored.
%@AS@%      */
%@AS@%     _chdrive( curdrive );
%@AS@%     printf( "\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Available drives are:
%@AS@%  A: B: C:
%@AS@%  Type drive letter to check or ESC to quit: q
%@AS@%  Type drive letter to check or ESC to quit: a
%@AS@%  Current directory on that drive is A:\
%@AS@%  
%@AS@%  Type drive letter to check or ESC to quit: c
%@AS@%  Current directory on that drive is C:\LIBREF
%@AS@%  
%@AS@%  Type drive letter to check or ESC to quit:%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:chmod@%%@NL@%
%@2@%%@CR:C6A00380257 @%%@AB@%chmod%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00380258 @%%@CR:C6A00380259 @% %@CR:C6A00380260 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Changes the file-permission settings.  %@NL@%
%@NL@%
%@AB@%#include <sys\types.h>%@AE@%            

%@AB@%#include <sys\stat.h>%@AE@%             

%@AB@%#include <errno.h>%@AE@%                

%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  int chmod( char *filename, int pmode );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          Path name of existing file

%@AI@%pmode%@AE@%                             Permission setting for file

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%chmod%@AE@% function changes the permission setting of the file specified by
%@AI@%filename.%@AE@% The permission setting controls read and write access to the file.
The constant expression %@AI@%pmode%@AE@% contains one or both of the manifest constants
%@AB@%S_IWRITE%@AE@% and %@AB@%S_IREAD%@AE@%, defined in SYS\STAT.H. Any other values for %@AI@%pmode%@AE@% are
ignored. When both constants are given, they are joined with the bitwise-OR
operator ( | ). The meaning of the %@AI@%pmode%@AE@% argument is as follows:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%S_IWRITE%@AE@%                          Writing permitted

%@AB@%S_IREAD%@AE@%                           Reading permitted

%@AB@%S_IREAD%@AE@% |  %@AB@%S_IWRITE%@AE@%               Reading and writing permitted

If write permission is not given, the file is read-only. Under DOS and OS/2,
all files are readable; it is not possible to give write-only permission.
Thus the modes %@AB@%S_IWRITE%@AE@% and %@AB@%S_IREAD%@AE@%  |  %@AB@%S_IWRITE%@AE@% are equivalent.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%chmod%@AE@% function returns the value 0 if the permission setting is
successfully changed. A return value of -1 indicates an error; in this case,
%@AB@%errno%@AE@% is set to %@AB@%ENOENT%@AE@%, indicating that the specified file could not be
found.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%access%@AE@%, %@AB@%creat%@AE@%, %@AB@%fstat%@AE@%, %@AB@%open%@AE@%, %@AB@%stat%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CHMOD.C: This program uses chmod to change the mode of a file to
%@AS@%   * read-only. It then attempts to modify the file.
%@AS@%   */
%@AS@%  
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  #include <io.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Make file read-only: */
%@AS@%     if( chmod( "CHMOD.C", S_IREAD ) == -1 )
%@AS@%        perror( "File not found\n" );
%@AS@%     else
%@AS@%        printf( "Mode changed to read-only\n" );
%@AS@%     system( "echo /* End of file */ >> CHMOD.C" );
%@AS@%  
%@AS@%     /* Change back to read/write: */
%@AS@%     if( chmod( "CHMOD.C", S_IWRITE ) == -1 )
%@AS@%        perror( "File not found\n" );
%@AS@%     else
%@AS@%        printf( "Mode changed to read/write\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Mode changed to read-only
%@AS@%  Access denied
%@AS@%  Mode changed to read/write %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:chsize@%%@NL@%
%@2@%%@CR:C6A00390261 @%%@AB@%chsize%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00390262 @%%@CR:C6A00390263 @%%@CR:C6A00390264 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Changes the file size.  %@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AB@%#include <errno.h>%@AE@%                

%@AS@%  int chsize( int handle, long size );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Handle referring to open file

%@AI@%size%@AE@%                              New length of file in bytes

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%chsize%@AE@% function extends or truncates the file associated with %@AI@%handle%@AE@% to
the length specified by %@AI@%size%@AE@%. The file must be open in a mode that permits
writing. Null characters (%@AB@%'\0'%@AE@%) are appended if the file is extended. If the
file is truncated, all data from the end of the shortened file to the
original length of the file is lost.  %@NL@%
%@NL@%
In DOS, the directory update is done when a file is closed. Consequently,
while a program is running, requests to determine the amount of free disk
space may receive inaccurate results.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%chsize%@AE@% function returns the value 0 if the file size is successfully
changed. A return value of -1 indicates an error, and %@AB@%errno%@AE@% is set to one of
the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Specified file is locked against access 
                                  (OS/2 and DOS versions 3.0 and later 
                                  only).

%@AB@%EBADF%@AE@%                             Specified file is read-only or an 
                                  invalid file handle.

%@AB@%ENOSPC%@AE@%                            No space is left on device.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%close%@AE@%, %@AB@%creat%@AE@%, %@AB@%open%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CHSIZE.C: This program uses filelength to report the size of a
%@AS@%   * file before and after modifying it with chsize.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <io.h>
%@AS@%  #include <fcntl.h>
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh, result;
%@AS@%     unsigned int nbytes = BUFSIZ;
%@AS@%  
%@AS@%     /* Open a file */
%@AS@%     if( (fh = open( "data", O_RDWR | O_CREAT, S_IREAD | S_IWRITE )) != -1 )
%@AS@%     {
%@AS@%        printf( "File length before: %ld\n", filelength( fh ) );
%@AS@%        if( chsize( fh, 329678 ) == 0 )
%@AS@%           printf( "Size successfully changed\n" );
%@AS@%        else
%@AS@%           printf( "Problem in changing the size\n" );
%@AS@%        printf( "File length after:  %ld\n", filelength( fh ) );
%@AS@%        close( fh );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  File length before: 0
%@AS@%  Size successfully changed
%@AS@%  File length after:  329678%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_clear87@%%@NL@%
%@2@%%@CR:C6A00400265 @%%@AB@%_clear87%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00400266 @%%@CR:C6A00400267 @% %@CR:C6A00400268 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets and clears the floating-point status word.  %@NL@%
%@NL@%
%@AS@%  #include <float.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned int _clear87( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_clear87%@AE@% function gets and clears the floating-point status word. The
floating-point status word is a combination of the 8087/80287 status word
and other conditions detected by the 8087/80287 exception handler, such as
floating-point stack overflow and underflow.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The bits in the value returned indicate the floating-point status. See the
FLOAT.H include file for a complete definition of the bits returned by
%@AB@%_clear87%@AE@%.  %@NL@%
%@NL@%
Many of the math library functions modify the 8087/80287 status word, with
unpredictable results. Return values from %@AB@%_clear87%@AE@% and %@AB@%_status87%@AE@% become more
reliable as fewer floating-point operations are performed between known
states of the floating-point status word.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_control87%@AE@%, %@AB@%_status87%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CLEAR87.C: This program creates various floating-point problems,
%@AS@%   * then uses _clear87 to report on these problems.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <float.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     double a = 1e-40, b;
%@AS@%     float x, y;
%@AS@%  
%@AS@%     printf( "Status: %.4x - clear\n", _clear87()  );
%@AS@%  
%@AS@%     /* Store into y is inexact and underflows: */
%@AS@%     y = a;
%@AS@%     printf( "Status: %.4x - inexact, underflow\n", _clear87() );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* y is denormal: */
%@AS@%     b = y;
%@AS@%     printf( "Status: %.4x - denormal\n", _clear87() );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Status: 0000 - clear
%@AS@%  Status: 0030 - inexact, underflow
%@AS@%  Status: 0002 - denormal %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:clearerr@%%@NL@%
%@2@%%@CR:C6A00410269 @%%@AB@%clearerr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00410270 @%%@CR:C6A00410271 @% %@CR:C6A00410272 @%%@CR:C6A00410273 @% %@CR:C6A00410274 @%%@CR:C6A00410275 @% %@CR:C6A00410276 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Resets the error indicator for a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void clearerr( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to%@AB@% FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%clearerr%@AE@% function resets the error indicator and end-of-file indicator
for %@AI@%stream%@AE@%. Error indicators are not automatically cleared; once the error
indicator for a specified stream is set, operations on that stream continue
to return an error value until %@AB@%clearerr%@AE@%,%@AB@% fseek%@AE@%,%@AB@% fsetpos%@AE@%,%@AB@% %@AE@%or %@AB@%rewind%@AE@% is
called.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%eof%@AE@%, %@AB@%feof%@AE@%, %@AB@%ferror%@AE@%, %@AB@%perror%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CLEARERR.C: This program creates an error on the standard input
%@AS@%   * stream, then clears it so that future reads won't fail.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int c;
%@AS@%  
%@AS@%     /* Create an error by writing to standard input. */
%@AS@%     putc( 'c', stdin );
%@AS@%     if( ferror( stdin ) )
%@AS@%     {
%@AS@%        perror( "Write error" );
%@AS@%        clearerr( stdin );
%@AS@%     }%@AE@%%@NL@%
%@NL@%
%@AS@%  /* See if read causes an error. */
%@AS@%     printf( "Will input cause an error? " );
%@AS@%     c = getc( stdin );
%@AS@%     if( ferror( stdin ) )
%@AS@%     {
%@AS@%        perror( "Read error" );
%@AS@%        clearerr( stdin );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Write error: Error 0
%@AS@%  Will input cause an error? n%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_clearscreen@%%@NL@%
%@2@%%@CR:C6A00420277 @%%@AB@%_clearscreen%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00420278 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Clears the specified area of the screen.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _clearscreen( short area );%@AE@%%@NL@%
%@NL@%
%@AI@%area%@AE@%                              Target area

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_clearscreen%@AE@% function erases the target area, filling it with the
current background color. The %@AI@%area%@AE@% parameter can be one of the following
manifest constants (defined in GRAPH.H):  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Action%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_GCLEARSCREEN%@AE@%                     Clears and fills the entire screen

%@AB@%_GVIEWPORT%@AE@%                        Clears and fills only within the current
                                  view port

%@AB@%_GWINDOW%@AE@%                          Clears and fills only within the current
                                  text window

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getbkcolor%@AE@%, %@AB@% _setbkcolor%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CLRSCRN.C */
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short xhalf, yhalf, xquar, yquar;
%@AS@%     struct videoconfig vc;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     _getvideoconfig( &vc );
%@AS@%  
%@AS@%     xhalf = vc.numxpixels / 2;
%@AS@%     yhalf = vc.numypixels / 2;
%@AS@%     xquar = xhalf / 2;
%@AS@%     yquar = yhalf / 2;
%@AS@%  
%@AS@%     _setviewport( 0, 0, xhalf - 1, yhalf - 1 );
%@AS@%     _rectangle( _GBORDER, 0,  0, xhalf - 1, yhalf - 1 );
%@AS@%     _ellipse( _GFILLINTERIOR, xquar / 4, yquar / 4,
%@AS@%                         xhalf - (xquar / 4), yhalf - (yquar / 4) );
%@AS@%     getch();
%@AS@%     _clearscreen( _GVIEWPORT );
%@AS@%  
%@AS@%     getch();
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:clock@%%@NL@%
%@2@%%@CR:C6A00430279 @%%@AB@%clock%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00430280 @%%@CR:C6A00430281 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculates the time used by the calling process.  %@NL@%
%@NL@%
%@AS@%  #include <time.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  clock_t clock( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%clock%@AE@% function tells how much processor time has been used by the
calling process. The time in seconds is approximated by dividing the %@AB@%clock%@AE@%
return value by the value of the %@AB@%CLOCKS_PER_SEC%@AE@% constant.  %@NL@%
%@NL@%
In other words, the %@AB@%clock%@AE@% function returns the number of processor timer
ticks that have elapsed. A timer tick is approximately equal to
1/%@AB@%CLOCKS_PER_SEC%@AE@% seconds.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%clock%@AE@% function returns the product of the time in seconds and the value
of the %@AB@%CLOCKS_PER_SEC%@AE@% constant. If the processor time is not available, the
function returns the value -1, cast as %@AB@%clock_t%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
In both DOS and OS/2, %@AB@%clock%@AE@% returns the time elapsed since the process
started. This may not be equal to the actual processor time used by the
process.  %@NL@%
%@NL@%
In previous versions of Microsoft C, the %@AB@%CLOCKS_PER_SEC%@AE@% constant was called
%@AB@%CLK_TCK%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%difftime%@AE@%, %@AB@%time%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CLOCK.C: This example prompts for how long the program is to run and
%@AS@%   * then continuously displays the elapsed time for that period.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <time.h>
%@AS@%  
%@AS@%  void sleep( clock_t wait );
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     long    i = 600000L;
%@AS@%     clock_t start, finish;
%@AS@%     double  duration;
%@AS@%  
%@AS@%     /* Delay for a specified time. */
%@AS@%     printf( "Delay for three seconds\n" );
%@AS@%     sleep( (clock_t)3 * CLOCKS_PER_SEC );
%@AS@%     printf( "Done!\n" );
%@AS@%  
%@AS@%     /* Measure the duration of an event. */
%@AS@%     printf( "Time to do %ld empty loops is ", i );
%@AS@%     start = clock();
%@AS@%     while( i-- )
%@AS@%        ;
%@AS@%     finish = clock();
%@AS@%     duration = (double)(finish - start) / CLOCKS_PER_SEC;
%@AS@%     printf( "%2.1f seconds\n", duration );
%@AS@%  }
%@AS@%  
%@AS@%  /* Pauses for a specified number of microseconds. */
%@AS@%  void sleep( clock_t wait )
%@AS@%  {
%@AS@%      clock_t goal;
%@AS@%  
%@AS@%      goal = wait + clock();
%@AS@%      while( goal > clock() )
%@AS@%          ;
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Delay for five seconds
%@AS@%  Done!
%@AS@%  Time to do 900000 empty loops is 2.0 seconds%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:close@%%@NL@%
%@2@%%@CR:C6A00440282 @%%@AB@%close%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00440283 @%%@CR:C6A00440284 @%%@CR:C6A00440285 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Closes a file.  %@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AB@%#include <errno.h>%@AE@%                

%@AS@%  int close( int handle );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Handle referring to open file

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%close%@AE@% function closes the file associated with %@AI@%handle%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%close%@AE@% function returns 0 if the file was successfully closed. A return
value of -1 indicates an error, and %@AB@%errno%@AE@% is set to %@AB@%EBADF%@AE@%, indicating an
invalid file-handle argument.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%chsize%@AE@%, %@AB@%creat%@AE@%, %@AB@%dup%@AE@%, %@AB@%dup2%@AE@%, %@AB@%open%@AE@%, %@AB@%unlink%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* OPEN.C: This program uses open to open a file named OPEN.C for input
%@AS@%   * and a file named OPEN.OUT for output. The files are then closed.
%@AS@%   */
%@AS@%  
%@AS@%  #include <fcntl.h>
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  #include <io.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh1, fh2;
%@AS@%     fh1 = open( "OPEN.C", O_RDONLY );
%@AS@%     if( fh1 == -1 )
%@AS@%        perror( "open failed on input file" );
%@AS@%     else
%@AS@%     {
%@AS@%        printf( "open succeeded on input file\n" );
%@AS@%        close( fh1 );
%@AS@%     }%@AE@%%@NL@%
%@NL@%
%@AS@%  fh2 = open( "OPEN.OUT", O_WRONLY | O_CREAT, S_IREAD | S_IWRITE );
%@AS@%     if( fh2 == -1 )
%@AS@%        perror( "open failed on output file" );
%@AS@%     else
%@AS@%     {
%@AS@%        printf( "open succeeded on output file\n" );
%@AS@%        close( fh2 );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  open succeeded on input file
%@AS@%  open succeeded on output file%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_control87@%%@NL@%
%@2@%%@CR:C6A00450286 @%%@AB@%_control87%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00450287 @% %@CR:C6A00450288 @%%@CR:C6A00450289 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets and sets the floating-point control word.  %@NL@%
%@NL@%
%@AS@%  #include <float.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned int _control87( unsigned int new, unsigned int mask );%@AE@%%@NL@%
%@NL@%
%@AI@%new%@AE@%                               New control-word bit values

%@AI@%mask%@AE@%                              Mask for new control-word bits to set

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_control87%@AE@% function gets and sets the floating-point control word. The
floating-point control word allows the program to change the precision,
rounding, and infinity modes in the floating-point-math package.
Floating-point exceptions can also be masked or unmasked using the
%@AB@%_control87%@AE@% function.  %@NL@%
%@NL@%
If the value for %@AI@%mask%@AE@% is equal to 0, then %@AB@%_control87%@AE@% gets the floating-point
control word. If %@AI@%mask%@AE@% is nonzero, then a new value for the control word is
set in the following manner: for any bit that is on (equal to 1) in %@AI@%mask%@AE@%,
the corresponding bit in %@AI@%new%@AE@% is used to update the control word. To put it
another way,  %@NL@%
%@NL@%
%@AS@%  fpcntrl = ((fpcntrl & ~mask) | (new & mask))%@AE@%%@NL@%
%@NL@%
where %@AS@% fpcntrl %@AE@% is the floating-point control word.  %@NL@%
%@NL@%
The possible values for the mask constant (%@AI@%mask%@AE@%) and new control values
(%@AI@%new%@AE@%) are shown in Table R.1.  %@NL@%
%@NL@%
%@AB@%Table   R.1 Hex Values%@AE@%

%@TH:  56  1588 02 13 11 17 35 @%Mask         Hex Value  Constant         Hex Value%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%MCW_EM       0x003F     (Interrupt              exception)                                      %@AB@%EM_INVALID%@AE@%       0x0001                         %@AB@%EM_DENORMAL%@AE@%      0x0002                         %@AB@%EM_ZERODIVIDE%@AE@%    0x0004                         %@AB@%EM_OVERFLOW%@AE@%      0x0008                         %@AB@%EM_UNDERFLOW%@AE@%     0x0010                         %@AB@%EM_INEXACT%@AE@%       0x0020                         MCW_IC       0x1000     (Infinity               control)                                        %@AB@%IC_AFFINE%@AE@%        0x1000                         %@AB@%IC_PROJECTIVE%@AE@%    0x0000                         MCW_RC       0x0C00     (Rounding               control)                                        %@AB@%RC_CHOP%@AE@%          0x0C00                         %@AB@%RC_UP%@AE@%            0x0800                         %@AB@%RC_DOWN%@AE@%          0x0400                         %@AB@%RC_NEAR%@AE@%          0x0000                         MCW_PC       0x0300     (Precision              control)                                        %@AB@%PC_24 (24 bits)%@AE@%  0x0000                         %@AB@%PC_53 (53 bits)%@AE@%  0x0200                         %@AB@%PC_64 (64 bits)%@AE@%  0x0300 %@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  56  1588 02 13 11 17 35 @%

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The bits in the value returned indicate the floating-point control state.
See the FLOAT.H include file for a complete definition of the bits returned
by %@AB@%_control87%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_clear87%@AE@%, %@AB@% _status87%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CNTRL87.C: This program uses _control87 to output the control word,
%@AS@%   * set the precision to 24 bits, and reset the status to the default.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <float.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     double a = 0.1;
%@AS@%  
%@AS@%     /* Show original control word and do calculation. */
%@AS@%     printf( "Original: 0x%.4x\n", _control87( 0, 0 ) );
%@AS@%     printf( "%1.1f * %1.1f = %.15e\n", a, a, a * a );
%@AS@%  
%@AS@%     /* Set precision to 24 bits and recalculate. */
%@AS@%     printf( "24-bit:   0x%.4x\n", _control87( PC_24, MCW_PC ) );
%@AS@%     printf( "%1.1f * %1.1f = %.15e\n", a, a, a * a );
%@AS@%  
%@AS@%     /* Restore to default and recalculate. */
%@AS@%     printf( "Default:  0x%.4x\n", _control87( CW_DEFAULT, 0xffff ) );
%@AS@%     printf( "%1.1f * %1.1f = %.15e\n", a, a, a * a );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Original: 0x1332
%@AS@%  0.1 * 0.1 = 1.000000000000000e-002
%@AS@%  24-bit:   0x1332
%@AS@%  0.1 * 0.1 = 9.999999776482582e-003
%@AS@%  Default:  0x1032
%@AS@%  0.1 * 0.1 = 1.000000000000000e-002%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:cos@%%@NL@%
%@2@%%@CR:C6A00460290 @%%@AB@%cos Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00460291 @%%@CR:C6A00460292 @%%@CR:C6A00460293 @% %@CR:C6A00460294 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate the cosine (%@AB@%cos%@AE@% and %@AB@%cosl%@AE@%) or hyperbolic cosine (%@AB@%cosh%@AE@% and %@AB@%coshl%@AE@%).  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double cos( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  double cosh( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double cosl( long double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double coshl( long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Angle in radians

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%cos%@AE@% and %@AB@%cosh%@AE@% functions return the cosine and hyperbolic cosine,
respectively, of %@AI@%x%@AE@%.  %@NL@%
%@NL@%
The %@AB@%cosl%@AE@% and %@AB@%coshl%@AE@% functions are the 80-bit counterparts and use the 80-bit,
10-byte coprocessor form of arguments and return values. See the reference
page on the long double functions for more details on this data type.%@AB@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If %@AI@%x%@AE@% is large, a partial loss of significance in the result may occur in a
call to %@AB@%cos%@AE@%, in which case the function generates a %@AB@%PLOSS%@AE@% error. If %@AI@%x%@AE@% is so
large that significance is completely lost, %@AB@%cos%@AE@% prints a %@AB@%TLOSS%@AE@% message to
%@AB@%stderr%@AE@% and returns 0. In both cases, %@AB@%errno%@AE@% is set to %@AB@%ERANGE.%@AE@%  %@NL@%
%@NL@%
If the result is too large in a %@AB@%cosh%@AE@% call, the function returns %@AB@%HUGE_VAL%@AE@% and
sets %@AB@%errno%@AE@% to %@AB@%ERANGE%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cos%@AE@%,%@AB@% cosh%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%cosl%@AE@%, %@AB@%coshl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%acos %@AE@%functions, %@AB@%asin %@AE@%functions, %@AB@%atan%@AE@% functions, %@AB@%matherr%@AE@%, %@AB@%sin%@AE@% functions, %@AB@%tan%@AE@%
functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SINCOS.C: This program displays the sine, hyperbolic sine, cosine,
%@AS@%   * and hyperbolic cosine of pi / 2.
%@AS@%   */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     double pi = 3.1415926535;
%@AS@%     double x, y;
%@AS@%  
%@AS@%     x = pi / 2;
%@AS@%     y = sin( x );
%@AS@%     printf( "sin( %f ) = %f\n", x, y );
%@AS@%     y = sinh( x );
%@AS@%     printf( "sinh( %f ) = %f\n",x, y );
%@AS@%     y = cos( x );
%@AS@%     printf( "cos( %f ) = %f\n", x, y );
%@AS@%     y = cosh( x );
%@AS@%     printf( "cosh( %f ) = %f\n",x, y );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  sin( 1.570796 ) = 1.000000
%@AS@%  sinh( 1.570796 ) = 2.301299
%@AS@%  cos( 1.570796 ) = 0.000000
%@AS@%  cosh( 1.570796 ) = 2.509178 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:cprintf@%%@NL@%
%@2@%%@CR:C6A00470295 @%%@AB@%cprintf%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00470296 @%%@CR:C6A00470297 @% %@CR:C6A00470298 @%%@CR:C6A00470299 @% %@CR:C6A00470300 @%%@CR:C6A00470301 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Formats and prints to the console.  %@NL@%
%@NL@%
%@AB@%#include <conio.h>%@AE@%                Required only for function declarations

%@AS@%  int cprintf( char *format [[, argument]] ... );%@AE@%%@NL@%
%@NL@%
%@AI@%format%@AE@%                            Format control string

%@AI@%argument%@AE@%                          Optional arguments

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%cprintf%@AE@% function formats and prints a series of characters and values
directly to the console, using the %@AB@%putch%@AE@% function to output characters. Each
%@AI@%argument%@AE@% (if any) is converted and output according to the corresponding
format specification in %@AI@%format%@AE@%. The format has the same form and function as
the %@AI@%format%@AE@% argument for the %@AB@%printf%@AE@% function; see %@AB@%printf%@AE@% for a description of
the format and arguments.  %@NL@%
%@NL@%
Note that unlike the %@AB@%fprintf%@AE@%, %@AB@%printf%@AE@%, and %@AB@%sprintf%@AE@% functions, %@AB@%cprintf%@AE@% does
not translate line-feed characters into carriage-return-line-feed
combinations on output.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%cprintf%@AE@% function returns the number of characters printed.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cscanf, fprintf%@AE@%, %@AB@%printf%@AE@%, %@AB@%sprintf%@AE@%, %@AB@%vprintf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CPRINTF.C: This program displays some variables to the console. */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int      i = -16, h = 29;
%@AS@%     unsigned u = 62511;
%@AS@%     char     c = 'A';
%@AS@%     char     s[] = "Test";%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Note that console output does not translate \n as
%@AS@%      * standard output does. Use \r\n instead.
%@AS@%      */
%@AS@%     cprintf( "%d  %.4x  %u  %c %s\r\n", i, h, u, c, s );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  -16  001d  62511  A Test%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:cputs@%%@NL@%
%@2@%%@CR:C6A00480302 @%%@AB@%cputs%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00480303 @%%@CR:C6A00480304 @% %@CR:C6A00480305 @%%@CR:C6A00480306 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Puts a string to the console.  %@NL@%
%@NL@%
%@AB@%#include <conio.h>%@AE@%                Required only for function declarations

%@AS@%  int cputs( char *string );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            Output string

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%cputs%@AE@% function writes the null-terminated string pointed to by %@AI@%string%@AE@%
directly to the console. Note that a carriage-return-line-feed (CR-LF)
combination is not automatically appended to the string.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, %@AB@%cputs%@AE@% returns a 0. If the function fails, it returns a
nonzero value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%putch%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CPUTS.C: This program first displays a string to the console. */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* String to print at console. Note the \r (return) character. */
%@AS@%     char *buffer = "Hello world (courtesy of cputs)!\r\n";
%@AS@%  
%@AS@%     cputs( buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Hello world (courtesy of cputs)! %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:creat@%%@NL@%
%@2@%%@CR:C6A00490307 @%%@AB@%creat%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00490308 @%%@CR:C6A00490309 @%%@CR:C6A00490310 @% %@CR:C6A00490311 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Creates a new file.  %@NL@%
%@NL@%
%@AB@%#include <sys\types.h>%@AE@%            

%@AB@%#include <sys\stat.h>%@AE@%             

%@AB@%#include <errno.h>%@AE@%                

%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  int creat( char *filename, int pmode );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          Path name of new file

%@AI@%pmode%@AE@%                             Permission setting

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%creat%@AE@% function either creates a new file or opens and truncates an
existing file. If the file specified by %@AI@%filename%@AE@% does not exist, a new file
is created with the given permission setting and is opened for writing. If
the file already exists and its permission setting allows writing, %@AB@%creat%@AE@%
truncates the file to length 0, destroying the previous contents, and opens
it for writing.  %@NL@%
%@NL@%
The permission setting, %@AI@%pmode%@AE@%, applies to newly created files only. The new
file receives the specified permission setting after it is closed for the
first time. The integer expression %@AI@%pmode%@AE@% contains one or both of the
manifest constants %@AB@%S_IWRITE%@AE@% and%@AB@% S_IREAD%@AE@%, defined in SYS\STAT.H. When both of
the constants are given, they are joined with the bitwise-OR operator ( | ).
The %@AI@%pmode%@AE@% argument is set to one of the following values: %@CR:C6A00490312 @%  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%S_IWRITE%@AE@%                          Writing permitted

%@AB@%S_IREAD%@AE@%                           Reading permitted

%@AB@%S_IREAD%@AE@% | %@AB@%S_IWRITE%@AE@%                Reading and writing permitted

If write permission is not given, the file is read-only. Under DOS and OS/2,
it is not possible to give write-only permission. Thus, the %@AB@%S_IWRITE%@AE@% and
%@AB@%S_IREAD%@AE@% | %@AB@%S_IWRITE%@AE@% modes are equivalent. Under DOS versions 3.0 and later,
files opened using %@AB@%creat%@AE@% are always opened in compatibility mode (see%@AB@%
%@AB@%sopen%@AE@%).  %@NL@%
%@NL@%
The %@AB@%creat%@AE@% function applies the current file-permission mask to %@AI@%pmode%@AE@% before
setting the permissions (see %@AB@%umask%@AE@%).  %@NL@%
%@NL@%
Note that the %@AB@%creat%@AE@% routine is provided primarily for compatibility with
previous libraries. A call to %@AB@%open%@AE@% with %@AB@%O_CREAT%@AE@% and %@AB@%O_TRUNC%@AE@% in the %@AI@%oflag
%@AI@%%@AE@%argument is equivalent to %@AB@%creat%@AE@% and is preferable for new code.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, %@AB@%creat%@AE@% returns a handle for the created file. Otherwise, it
returns -1 and sets %@AB@%errno%@AE@% to one of the following constants:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Path name specifies an existing 
                                  read-only file or specifies a directory 
                                  instead of a file

%@AB@%EMFILE %@AE@%                           No more handles available (too many open
                                  files)

%@AB@%ENOENT%@AE@%                            Path name not found

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%chmod%@AE@%, %@AB@%chsize%@AE@%, %@AB@%close%@AE@%, %@AB@%dup%@AE@%, %@AB@%dup2%@AE@%, %@AB@%open%@AE@%, %@AB@%sopen%@AE@%, %@AB@%umask%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CREAT.C: This program uses creat to create the file (or truncate the
%@AS@%   * existing file) named data and open it for writing.
%@AS@%   */
%@AS@%  
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  #include <io.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh;
%@AS@%  
%@AS@%     fh = creat( "data", S_IREAD | S_IWRITE );
%@AS@%     if( fh == -1 )
%@AS@%        perror( "Couldn't create data file" );
%@AS@%     else
%@AS@%     {
%@AS@%        printf( "Created data file.\n" );
%@AS@%        close( fh );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Created data file.%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:cscanf@%%@NL@%
%@2@%%@CR:C6A00500313 @%%@AB@%cscanf%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00500314 @%%@CR:C6A00500315 @% %@CR:C6A00500316 @%%@CR:C6A00500317 @% %@CR:C6A00500318 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Reads formatted data from the console.  %@NL@%
%@NL@%
%@AB@%#include <conio.h>%@AE@%                Required only for function declarations

%@AS@%  int cscanf( char *format [[, argument]] ... );%@AE@%%@NL@%
%@NL@%
%@AI@%format%@AE@%                            Format-control string

%@AI@%argument%@AE@%                          Optional arguments

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%cscanf%@AE@% function reads data directly from the console into the locations
given by %@AI@%argument%@AE@%. The %@AB@%getche%@AE@% function is used to read characters. Each
optional argument must be a pointer to a variable with a type that
corresponds to a type specifier in %@AI@%format%@AE@%. The format controls the
interpretation of the input fields and has the same form and function as the
%@AI@%format%@AE@% argument for the %@AB@%scanf%@AE@% function; see %@AB@%scanf%@AE@% for a description of
%@AI@%format%@AE@%.  %@NL@%
%@NL@%
While %@AB@%cscanf%@AE@% normally echoes the input character, it will not do so if the
last call was to %@AB@%ungetch%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%cscanf%@AE@% function returns the number of fields that were successfully
converted and assigned. The return value does not include fields that were
read but not assigned.  %@NL@%
%@NL@%
The return value is %@AB@%EOF%@AE@% for an attempt to read at end-of-file. This may
occur when keyboard input is redirected at the operating system command-line
level. A return value of 0 means that no fields were assigned.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cprintf, fscanf, scanf, sscanf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CSCANF.C: This program prompts for a string and uses cscanf to read
%@AS@%   * in the response. Then cscanf returns the number of items matched,
%@AS@%   * and the program displays that number.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <conio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     int   result, i[3];
%@AS@%  
%@AS@%     cprintf( "Enter three integers: ");
%@AS@%     result = cscanf( "%i %i %i", &i[0], &i[1], &i[2] );
%@AS@%     cprintf( "\r\nYou entered " );
%@AS@%     while( result-- )
%@AS@%        cprintf( "%i ", i[result] );
%@AS@%     cprintf( "\r\n" );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Enter three integers: 34 43 987k
%@AS@%  You entered 987 43 34 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ctime@%%@NL@%
%@2@%%@CR:C6A00510319 @%%@AB@%ctime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00510320 @%%@CR:C6A00510321 @% %@CR:C6A00510322 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Converts a time stored as a %@AB@%time_t%@AE@% value to a character string.  %@NL@%
%@NL@%
%@AB@%#include <time.h>%@AE@%                 Required only for function declarations

%@AS@%  char *ctime( const time_t *timer );%@AE@%%@NL@%
%@NL@%
%@AI@%timer%@AE@%                             Pointer to stored time

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ctime%@AE@% function converts a time stored as a %@AB@%time_t%@AE@% value to a character
string. The %@AI@%timer%@AE@% value is usually obtained from a call to %@AB@%time%@AE@%, which
returns the number of seconds elapsed since 00:00:00 Greenwich mean time,
January 1, 1970.  %@NL@%
%@NL@%
The string result produced by %@AB@%ctime%@AE@% contains exactly 26 characters and has
the form of the following example:  %@NL@%
%@NL@%
%@AS@%  Wed Jan 02 02:03:55 1980\n\0%@AE@%%@NL@%
%@NL@%
A 24-hour clock is used. All fields have a constant width. The newline
character (%@AB@%\n%@AE@%)%@AB@% %@AE@%and the null character (%@AB@%'\0'%@AE@%) occupy the last two positions
of the string.  %@NL@%
%@NL@%
Calls to the %@AB@%ctime%@AE@% function modify the single statically allocated buffer
used by the %@AB@%gmtime%@AE@% and the %@AB@%localtime%@AE@% functions. Each call to one of these
routines destroys the result of the previous call. The %@AB@%ctime%@AE@% function also
shares a static buffer with the %@AB@%asctime%@AE@% function. Thus, a call to %@AB@%ctime%@AE@%
destroys the results of any previous call to%@AB@% asctime%@AE@%, %@AB@%localtime%@AE@%, or %@AB@%gmtime%@AE@%.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ctime%@AE@% function returns a pointer to the character string result. If %@AI@%time%@AE@%
represents a date before 1980, %@AB@%ctime%@AE@% returns %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asctime%@AE@%, %@AB@%ftime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%time%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ASCTIME.C: This program places the system time in the long integer
%@AS@%  aclock,
%@AS@%   * translates it into the structure newtime and then converts it to
%@AS@%   * string form for output, using the asctime function.
%@AS@%   */
%@AS@%  
%@AS@%  #include <time.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct tm *newtime;
%@AS@%  time_t aclock;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     time( &aclock );                    /* Get time in seconds. */
%@AS@%  
%@AS@%     newtime = localtime( &aclock );     /* Convert time to struct tm form.
%@AS@%*/
%@AS@%  
%@AS@%     /* Print local time as a string. */
%@AS@%     printf( "The current date and time are: %s\n", asctime( newtime ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The current date and time are: Thu Jun 15 06:57:59 1989%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:cwait@%%@NL@%
%@2@%%@CR:C6A00520323 @%%@AB@%cwait%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00520324 @%%@CR:C6A00520325 @% %@CR:C6A00520326 @%%@CR:C6A00520327 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Waits until the child process terminates.  %@NL@%
%@NL@%
%@AS@%  #include <process.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int cwait( int *termstat, int procid, int action );%@AE@%%@NL@%
%@NL@%
%@AI@%termstat%@AE@%                          Address for termination status code

%@AI@%procid%@AE@%                            Process ID of child

%@AI@%action%@AE@%                            Action code

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%cwait%@AE@% function suspends the calling process until the specified child
process terminates.  %@NL@%
%@NL@%
If not %@AB@%NULL%@AE@%, %@AI@%termstat%@AE@% points to a buffer where %@AB@%cwait%@AE@% will place the
termination-status word and the return code of the terminated child process.
%@NL@%
%@NL@%
The termination-status word indicates whether or not the child process
terminated normally by calling the OS/2 %@AB@%DosExit%@AE@% function. (Programs that
terminate with %@AB@%exit%@AE@% or by "falling off the end of main" use %@AB@%DosExit%@AE@%
internally.) If the process did terminate normally, the low-order and
high-order bytes of the termination-status word are as follows:  %@NL@%
%@NL@%
%@AB@%Byte%@AE@%                              %@AB@%Contents%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
High order                        Contains the low-order byte of the 
                                  result code that the child code passed 
                                  to %@AB@%DosExit%@AE@%. The%@AB@% DosExit%@AE@% function is 
                                  called if the child process called %@AB@%exit%@AE@% 
                                  or %@AB@%_exit%@AE@%, returned from %@AB@%main%@AE@%, or reached
                                  the end of %@AB@%main%@AE@%. The low-order byte of 
                                  the result code is either the low-order 
                                  byte of the argument to %@AB@%_exit%@AE@% or %@AB@%exit%@AE@%, 
                                  the low-order byte of the return value 
                                  from %@AB@%main%@AE@%, or a random value if the 
                                  child process reached the end of %@AB@%main%@AE@%.

Low order                         0 (normal termination).

If the child process terminates without calling %@AB@%DosExit%@AE@%, the high-order and
low-order bytes of the termination-status word are as follows:  %@NL@%
%@NL@%
%@AB@%Byte%@AE@%                              %@AB@%Contents%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
High order                        0

Low order                         Termination code from %@AB@%DosCWait%@AE@%:

                                  %@AB@%Code%@AE@%        %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
                                  1           Hard-error abort

                                  2           Trap operation

                                  3           %@AB@%SIGTERM%@AE@% signal not 
                                              intercepted

The %@AI@%procid%@AE@% argument specifies which child-process termination to wait for.
This value is returned by the call to the %@AB@%spawn%@AE@% function that started the
child process. If the specified child process terminates before %@AB@%cwait%@AE@% is
called, the function returns immediately.  %@NL@%
%@NL@%
The %@AI@%action%@AE@% argument specifies when the parent process resumes execution, as
shown in the following list:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%WAIT_CHILD%@AE@%                        The parent process waits until the 
                                  specified child process has ended.

%@AB@%WAIT_GRANDCHILD%@AE@%                   The parent process waits until the 
                                  specified child process and all child 
                                  processes of that child process have 
                                  ended.

The %@AB@%WAIT_CHILD%@AE@% and %@AB@%WAIT_GRANDCHILD%@AE@% action codes are defined in PROCESS.H.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If the %@AB@%cwait%@AE@% function returns after normal termination of the child process,
it returns the child's process ID.  %@NL@%
%@NL@%
If the %@AB@%cwait%@AE@% function returns after abnormal termination of the child
process, it returns -1 and sets %@AB@%errno%@AE@% to%@AB@% EINTR%@AE@%.  %@NL@%
%@NL@%
Otherwise, the %@AB@%cwait%@AE@% function returns -1 immediately and sets %@AB@%errno%@AE@% to one
of the following error codes:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%ECHILD%@AE@%                            No child process exists, or invalid 
                                  process ID

%@AB@%EINVAL%@AE@%                            Invalid action code

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
Note that the OS/2 %@AB@%DosExit%@AE@% function allows programs to return a 16-bit
result code. However, the %@AB@%wait%@AE@% and %@AB@%cwait%@AE@% functions return only the low-order
byte of that result code.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%exit%@AE@%, %@AB@%_exit%@AE@%, %@AB@%spawn %@AE@%functions, %@AB@%wait%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CWAIT.C: This program launches several child processes and waits
%@AS@%   * for a specified process to finish.
%@AS@%   */
%@AS@%  
%@AS@%  #define INCL_NOPM
%@AS@%  #define INCL_NOCOMMON
%@AS@%  #define INCL_DOSPROCESS
%@AS@%  #include <os2.h>        /* DosSleep */
%@AS@%  #include <process.h>    /* cwait    */
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <time.h>
%@AS@%  
%@AS@%  /* Macro to get a random integer within a specified range */
%@AS@%  #define getrandom( min, max ) ((rand() % (int)(((max) + 1) - (min))) +
%@AS@%(min))
%@AS@%  
%@AS@%  struct  CHILD
%@AS@%  {
%@AS@%      int     pid;
%@AS@%      char    name[10];
%@AS@%  } child[4] = { { 0, "Ann" }, { 0, "Beth"  }, { 0, "Carl" }, { 0, "Dave" }
%@AS@%};
%@AS@%  
%@AS@%  void main( int argc, char *argv[] )
%@AS@%  {
%@AS@%      int     termstat, pid, c, tmp;
%@AS@%  
%@AS@%      srand( (unsigned)time( NULL ) );               /* Seed randomizer */
%@AS@%      /* If no arguments, this is the parent. */
%@AS@%      if( argc == 1 )
%@AS@%      {
%@AS@%          /* Spawn children in numeric order. */
%@AS@%          for( c = 0; c < 4; c++ )
%@AS@%              child[c].pid = spawnl( P_NOWAIT, argv[0], argv[0],
%@AS@%                                     child[c].name, NULL );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Wait for randomly specified child, and respond when done. */
%@AS@%          c = getrandom( 0, 3 );
%@AS@%          printf( "Come here, %s\n", child[c].name );
%@AS@%          cwait( &termstat, child[c].pid, WAIT_CHILD );
%@AS@%          printf( "Thank you, %s\n", child[c].name );
%@AS@%      }
%@AS@%  
%@AS@%      /* If there are arguments, this must be a child. */
%@AS@%      else
%@AS@%      {
%@AS@%          /* Delay for a period determined by process number. */
%@AS@%          DosSleep( (argv[1][0] - 'A' + 1) * 1000L );
%@AS@%          printf( "Hi, dad. It's %s.\n", argv[1] );
%@AS@%      }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Come here, Carl
%@AS@%  Hi, dad. It's Ann.
%@AS@%  Hi, dad. It's Beth.
%@AS@%  Hi, dad. It's Carl.
%@AS@%  Thank you, Carl
%@AS@%  Hi, dad. It's Dave. %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:dieeetomsbin@%%@QR:dmsbintoieee@%%@NL@%
%@2@%%@CR:C6A00530328 @%%@AB@%dieeetomsbin, dmsbintoieee%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description %@CR:C6A00530329 @% %@CR:C6A00530330 @% %@CR:C6A00530331 @% %@CR:C6A00530332 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Convert between IEEE double value and Microsoft (MS) binary double value.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int dieeetomsbin( double *src8, double *dst8 );%@AE@%%@NL@%
%@NL@%
%@AS@%  int dmsbintoieee( double *src8, double *dst8 );%@AE@%%@NL@%
%@NL@%
%@AI@%src8%@AE@%                              Buffer containing value to convert

%@AI@%dst8%@AE@%                              Buffer to store converted value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%dieeetomsbin%@AE@% routine converts a double-precision number in IEEE
(Institute of Electrical and Electronic Engineers) format to Microsoft (MS)
binary format. The routine %@AB@%dmsbintoieee%@AE@% converts a double-precision number
in MS binary format to IEEE format.  %@NL@%
%@NL@%
These routines allow C programs (which store floating-point numbers in the
IEEE format) to use numeric data in random-access data files created with
those versions of Microsoft BASIC that store floating-point numbers in MS
binary format, and vice versa.  %@NL@%
%@NL@%
The argument %@AI@%src8%@AE@% is a pointer to the %@AB@%double%@AE@% value to be converted. The
result is stored at the location given by %@AI@%dst8%@AE@%.  %@NL@%
%@NL@%
These routines do not handle IEEE NANs ("not a number") and infinities. IEEE
denormals are treated as 0 in the conversions.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return 0 if the conversion is successful and 1 if the
conversion causes an overflow.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fieeetomsbin%@AE@%, %@AB@%fmsbintoieee%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:difftime@%%@NL@%
%@2@%%@CR:C6A00540333 @%%@AB@%difftime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00540334 @%%@CR:C6A00540335 @%%@CR:C6A00540336 @% %@CR:C6A00540337 @%%@CR:C6A00540338 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Finds the difference between two times.  %@NL@%
%@NL@%
%@AB@%#include <time.h>%@AE@%                 Required only for function declarations

%@AS@%  double difftime( time_t timer1, time_t timer0 );%@AE@%%@NL@%
%@NL@%
%@AI@%timer0%@AE@%                            Beginning time

%@AI@%timer1%@AE@%                            Ending time

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%difftime%@AE@% function computes the difference between the supplied time
values, %@AI@%timer0 %@AE@%and%@AI@% timer1%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%difftime%@AE@% function returns, in seconds, the elapsed time from %@AI@%timer0%@AE@% to
%@AI@%timer1%@AE@%. The value returned is a double-precision number.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%time%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DIFFTIME.C: This program calculates the amount of time needed to
%@AS@%   * do a floating-point multiply 50000 times.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <time.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     time_t   start, finish;
%@AS@%     unsigned loop;
%@AS@%     double   result, elapsed_time;
%@AS@%  
%@AS@%     printf( "This program will do a floating point multiply 50000 times\n"
%@AS@%);
%@AS@%     printf( "Working...\n" );
%@AS@%  
%@AS@%     time( &start );
%@AS@%     for( loop = 0; loop < 50000L; loop++ )
%@AS@%        result = 3.63 * 5.27;
%@AS@%     time( &finish );%@AE@%%@NL@%
%@NL@%
%@AS@%  elapsed_time = difftime( finish, start );
%@AS@%     printf( "\nProgram takes %6.2f seconds.\n", elapsed_time );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  This program will do a floating point multiply 50000 times
%@AS@%  Working...
%@AS@%  
%@AS@%  Program takes   4.00 seconds. %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_displaycursor@%%@NL@%
%@2@%%@CR:C6A00550339 @%%@AB@%_displaycursor%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00550340 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the cursor toggle for graphics functions.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _displaycursor( short toggle );%@AE@%%@NL@%
%@NL@%
%@AI@%toggle%@AE@%                            Cursor state

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
Upon entry into each graphic routine, the screen cursor is turned off. The
%@AB@%_displaycursor%@AE@% function determines whether the cursor will be turned back on
when programs exit graphic routines. If %@AI@%toggle%@AE@% is set to %@AB@%_GCURSORON,%@AE@% the
cursor will be restored on exit. If %@AI@%toggle%@AE@% is set to %@AB@%_GCURSOROFF,%@AE@% the cursor
will be left off.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the previous value of %@AI@%toggle%@AE@%. There is no error return.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_gettextcursor%@AE@%, %@AB@%_settextcursor%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DISCURS.C: This program changes the cursor shape using _gettextcursor
%@AS@%   * and _settextcursor, and hides the cursor using _displaycursor.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short oldcursor;
%@AS@%     short newcursor = 0x007;        /* Full block cursor */
%@AS@%  
%@AS@%     /* Save old cursor shape and make sure cursor is on */
%@AS@%     oldcursor = _gettextcursor();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%     _displaycursor( _GCURSORON );
%@AS@%     _outtext( "\nOld cursor shape: " );
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Change cursor shape */
%@AS@%     _outtext( "\nNew cursor shape: " );
%@AS@%     _settextcursor( newcursor );
%@AS@%     getch();%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Restore original cursor shape */
%@AS@%     _outtext( "\n" );
%@AS@%     _settextcursor( oldcursor );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:div@%%@NL@%
%@2@%%@CR:C6A00560341 @%%@AB@%div%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00560342 @%%@CR:C6A00560343 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Computes the quotient and the remainder of two integer values.  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  div_t div( int numer, int denom );%@AE@%%@NL@%
%@NL@%
%@AI@%numer%@AE@%                             Numerator

%@AI@%denom%@AE@%                             Denominator

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%div%@AE@% function divides %@AI@%numer%@AE@% by %@AI@%denom%@AE@%, computing the quotient and the
remainder. The %@AB@%div_t%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%int quot%@AE@%                          Quotient

%@AB@%int rem%@AE@%                           Remainder

The sign of the quotient is the same as that of the mathematical quotient.
Its absolute value is the largest integer that is less than the absolute
value of the mathematical quotient. If the denominator is 0, the program
will terminate with an error message.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%div%@AE@% function returns a structure of type %@AB@%div_t%@AE@%, comprising both the
quotient and the remainder. The structure is defined in STDLIB.H.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%ldiv%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DIV.C: This example takes two integers as command-line arguments and
%@AS@%   * displays the results of the integer division. This program accepts
%@AS@%   * two arguments on the command line following the program name, then
%@AS@%   * calls div to divide the first argument by the second. Finally,
%@AS@%   * it prints the structure members quot and rem.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main( int argc, char *argv[] )
%@AS@%  {
%@AS@%     int x,y;
%@AS@%     div_t div_result;
%@AS@%  
%@AS@%     x = atoi( argv[1] );
%@AS@%     y = atoi( argv[2] );
%@AS@%  
%@AS@%     printf( "x is %d, y is %d\n", x, y );
%@AS@%     div_result = div( x, y );
%@AS@%     printf( "The quotient is %d, and the remainder is %d\n",
%@AS@%             div_result.quot, div_result.rem );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  [C:\LIBREF] div 876 13
%@AS@%  x is 876, y is 13
%@AS@%  The quotient is 67, and the remainder is 5 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_allocmem@%%@NL@%
%@2@%%@CR:C6A00570344 @%%@AB@%_dos_allocmem%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00570345 @% %@CR:C6A00570346 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Allocates a block of memory, using DOS service 0x48.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <errno.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_allocmem( unsigned size, unsigned *seg );%@AE@%%@NL@%
%@NL@%
%@AI@%size%@AE@%                              Block size to allocate

%@AI@%seg%@AE@%                               Return buffer for segment descriptor

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_allocmem%@AE@% function uses DOS service 0x48 to allocate a block of
memory %@AI@%size%@AE@% paragraphs long. (A paragraph is 16 bytes.) Allocated blocks are
always paragraph aligned. The segment descriptor for the initial segment of
the new block is returned in the word that %@AI@%seg%@AE@% points to. If the request
cannot be satisfied, the maximum possible size (in paragraphs) is returned
in this word instead.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the %@AB@%_dos_allocmem%@AE@% returns 0. Otherwise, it returns the DOS
error code and sets %@AB@%errno%@AE@% to %@AB@%ENOMEM%@AE@%, indicating insufficient memory or
invalid arena (memory area) headers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%alloca%@AE@%, %@AB@%calloc%@AE@% functions, %@AB@%_dos_freemem%@AE@%, %@AB@%_dos_setblock%@AE@%, %@AB@%halloc%@AE@%, %@AB@%malloc%@AE@%
functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DALOCMEM.C: This program allocates 20 paragraphs of memory, increases
%@AS@%   * the allocation to 40 paragraphs, and then frees the memory space.
%@AS@%   */
%@AS@%  
%@AS@%  #include <dos.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned segment;
%@AS@%     unsigned maxsize;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Allocate 20 paragraphs */
%@AS@%     if( _dos_allocmem( 20, &segment ) != 0 )
%@AS@%        printf( "allocation failed\n" );
%@AS@%     else
%@AS@%        printf( "allocation successful\n" );
%@AS@%  
%@AS@%     /* Increase allocation to 40 paragraphs */
%@AS@%     if( _dos_setblock( 40, segment, &maxsize ) != 0 )
%@AS@%        printf( "allocation increase failed\n" );
%@AS@%     else
%@AS@%        printf( "allocation increase successful\n" );
%@AS@%  
%@AS@%     /* free memory */
%@AS@%     if( _dos_freemem( segment ) != 0 )
%@AS@%        printf( "free memory failed\n" );
%@AS@%     else
%@AS@%        printf( "free memory successful\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  allocation successful
%@AS@%  allocation increase successful
%@AS@%  free memory successful %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_close@%%@NL@%
%@2@%%@CR:C6A00580347 @%%@AB@%_dos_close%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00580348 @% %@CR:C6A00580349 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Closes a file using system call INT 0x3E.  %@NL@%
%@NL@%
%@AB@%#include <dos.h>%@AE@%                  

%@AB@%#include <errno.h>%@AE@%                

%@AS@%  unsigned _dos_close( int handle );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Target file handle

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_close%@AE@% function uses system call 0x3E to close the file indicated by
%@AI@%handle%@AE@%. The file's %@AI@%handle%@AE@% argument is returned by the call that created or
last opened the file.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns 0 if successful. Otherwise, it returns the DOS error
code and sets %@AB@%errno%@AE@% to %@AB@%EBADF%@AE@%, indicating an invalid file handle.  %@NL@%
%@NL@%
Do not use the DOS interface I/O routines with the console, low-level, or
stream I/O routines.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%close%@AE@%,%@AB@% creat%@AE@%, %@AB@% _dos_creat%@AE@% functions, %@AB@% _dos_open%@AE@%, %@AB@% _dos_read%@AE@%, %@AB@% _dos_write%@AE@%,
%@AB@%dup%@AE@%, %@AB@%open%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DOPEN.C: This program uses DOS I/O functions to open and close a file.
%@AS@%  */
%@AS@%  
%@AS@%  #include <fcntl.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh;
%@AS@%  
%@AS@%     /* Open file with _dos_open function */
%@AS@%     if( _dos_open( "data1", O_RDONLY, &fh ) != 0 )
%@AS@%        perror( "Open failed on input file\n" );
%@AS@%     else
%@AS@%        printf( "Open succeeded on input file\n" );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Close file with _dos_close function */
%@AS@%     if( _dos_close( fh ) != 0 )
%@AS@%        perror( "Close failed\n" );
%@AS@%     else
%@AS@%        printf( "File successfully closed\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Open succeeded on input file
%@AS@%  File successfully closed %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_creat@%%@NL@%
%@2@%%@CR:C6A00590350 @%%@AB@%_dos_creat Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00590351 @%%@CR:C6A00590352 @% %@CR:C6A00590353 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Create a new file.  %@NL@%
%@NL@%
%@AB@%#include <dos.h>%@AE@%                  

%@AB@%#include <errno.h>%@AE@%                

%@AS@%  unsigned _dos_creat( char *filename, unsigned attrib, int *handle );%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_creatnew( char *filename, unsigned attrib, int *handle );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          File path name

%@AI@%attrib%@AE@%                            File attributes

%@AI@%handle%@AE@%                            Handle return buffer

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_creat%@AE@% and %@AB@%_dos_creatnew%@AE@% routines create and open a new file named
%@AI@%filename%@AE@%; this new file has the access attributes specified in the %@AI@%attrib%@AE@%
argument. The new file's handle is copied into the integer location pointed
to by %@AI@%handle%@AE@%. The file is opened for both read and write access. If file
sharing is installed, the file is opened in compatibility mode.  %@NL@%
%@NL@%
The %@AB@%_dos_creat%@AE@% routine uses system call INT 0x3C, and the %@AB@%_dos_creatnew%@AE@%
routine uses system call INT 0x5B. If the file already exists, %@AB@%_dos_creat%@AE@%
erases its contents and leaves its attributes unchanged; however, the
%@AB@%_dos_creatnew%@AE@% routine fails if the file already exists.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, both routines return 0. Otherwise, they return the DOS error
code and set %@AB@%errno%@AE@% to one of the following values:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Access denied because the directory is 
                                  full or, for %@AB@%_dos_creat%@AE@% only, the file 
                                  exists and cannot be overwritten

%@AB@%EEXIST%@AE@%                            File already exists (%@AB@%_dos_creatnew%@AE@% only)

%@AB@%EMFILE%@AE@%                            Too many open file handles

%@AB@%ENOENT%@AE@%                            Path or file not found

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DCREAT.C: This program creates a file using the _dos_creat function.
%@AS@%  The
%@AS@%   * program cannot create a new file using the _dos_creatnew function
%@AS@%   * because it already exists.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh1, fh2;
%@AS@%     int result;
%@AS@%  
%@AS@%     if( _dos_creat( "data", _A_NORMAL, &fh1 ) != 0 )
%@AS@%        printf( "Couldn't create data file\n" );
%@AS@%     else
%@AS@%     {
%@AS@%        printf( "Created data file.\n" );
%@AS@%  
%@AS@%        /* If _dos_creat is successful, the _dos_creatnew call
%@AS@%         * will fail since the file exists
%@AS@%         */
%@AS@%        if( _dos_creatnew( "data", _A_RDONLY, &fh2 ) != 0 )
%@AS@%           printf( "Couldn't create data file\n" );
%@AS@%        else
%@AS@%        {
%@AS@%           printf( "Created data file.\n" );
%@AS@%           _dos_close( fh2 );
%@AS@%        }
%@AS@%        _dos_close( fh1 );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Created data file.
%@AS@%  Couldn't create data file %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_find@%%@NL@%
%@2@%%@CR:C6A00600354 @%%@AB@%_dos_find Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00600355 @% %@CR:C6A00600356 @% %@CR:C6A00600357 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Find the file with the specified attributes or find the next file with the
specified attributes.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <errno.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_findfirst( char *filename, unsigned attrib, struct find_t
%@AS@%  *fileinfo );%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_findnext( struct find_t *fileinfo );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          Target file name

%@AI@%attrib%@AE@%                            Target attributes

%@AI@%fileinfo%@AE@%                          File-information buffer

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_findfirst%@AE@% routine uses system call INT 0x4E to return information
about the first instance of a file whose name and attributes match %@AI@%filename%@AE@%
and %@AI@%attrib%@AE@%.  %@NL@%
%@NL@%
The %@AI@%filename%@AE@% argument may use wildcards (%@AB@%*%@AE@% and %@AB@%?%@AE@%). The %@AI@%attrib%@AE@% argument can
be any of the following manifest constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_A_ARCH%@AE@%                           Archive. Set whenever the file is 
                                  changed, and cleared by the DOS BACKUP 
                                  command.

%@AB@%_A_HIDDEN%@AE@%                         Hidden file. Cannot be found with the 
                                  DOS DIR command. Returns information 
                                  about normal files as well as about 
                                  files with this attribute.

%@AB@%_A_NORMAL%@AE@%                         Normal. File can be read or written 
                                  without restriction.

%@AB@%_A_RDONLY%@AE@%                         Read-only. File cannot be opened for 
                                  writing, and a file with the same name 
                                  cannot be created. Returns information 
                                  about normal files as well as about 
                                  files with this attribute.

%@AB@%_A_SUBDIR%@AE@%                         Subdirectory. Returns information about 
                                  normal files as well as about files with
                                  this attribute.

%@AB@%_A_SYSTEM%@AE@%                         System file. Cannot be found with the 
                                  DOS DIR command. Returns information 
                                  about normal files as well as about 
                                  files with this attribute.

%@AB@%_A_VOLID%@AE@%                          Volume ID. Only one file can have this 
                                  attribute, and it must be in the root 
                                  directory.

Multiple constants can be combined (with the OR operator), using the
vertical-bar ( | ) character.  %@NL@%
%@NL@%
If the %@AI@%attributes %@AE@%argument to either of these functions is %@AB@%_A_RDONLY%@AE@%,%@AB@%
%@AB@%%@AE@%_A_HIDDEN,%@AB@% _A_SYSTEM%@AE@%, or %@AB@%_A_SUBDIR%@AE@%, the function also returns any normal
attribute files that match the %@AI@%filename%@AE@% argument. That is, a normal file
does not have a read-only, hidden, system, or directory attribute.  %@NL@%
%@NL@%
Information is returned in a %@AB@%find_t%@AE@% structure, defined in DOS.H. The %@AB@%find_t%@AE@%
structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%char reserved[21]%@AE@%                 Reserved for use by DOS

%@AB@%char attrib%@AE@%                       Attribute byte for matched path

%@AB@%unsigned wr_time%@AE@%                  Time of last write to file

%@AB@%unsigned wr_date%@AE@%                  Date of last write to file

%@AB@%long size%@AE@%                         Length of file in bytes

%@AB@%char name[13]%@AE@%                     Null-terminated name of matched 
                                  file/directory, without
                                  the path

The formats for the %@AB@%wr_time%@AE@% and %@AB@%wr_date%@AE@% elements are in DOS format and are
not usable by any other C run-time function. The time format is shown below:
%@NL@%
%@NL@%
%@AB@%Bits%@AE@%                              %@AB@%Contents%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
0 - 4                             Number of 2-second increments (0 - 29)

5 -10                             Minutes (0 - 59)

11-15                             Hours (0 - 23)

The date format is shown below:  %@NL@%
%@NL@%
%@AB@%Bits%@AE@%                              %@AB@%Contents%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
0 - 4                             Day of month (1-31)

5 - 8                             Month (1-12)

9 -15                             Year (relative to 1980)

Do not alter the contents of the buffer between a call to %@AB@%_dos_findfirst%@AE@% and
a subsequent call to the %@AB@%_dos_findnext%@AE@% function. Also, the buffer should not
be altered between calls to %@AB@%_dos_findnext%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_dos_findnext%@AE@% routine uses system call 0x4F to find the next name, if
any, that matches the %@AI@%filename%@AE@% and %@AI@%attrib%@AE@% arguments specified in a prior
call to %@AB@%_dos_findfirst%@AE@%. The %@AI@%fileinfo%@AE@% argument must point to a structure
initialized by a previous call to %@AB@%_dos_findfirst%@AE@%. The contents of the
structure will be altered as described above if a match is found.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, both functions return 0. Otherwise, they return the DOS error
code and set %@AB@%errno%@AE@% to %@AB@%ENOENT%@AE@%, indicating that %@AI@% filename%@AE@% could not be
matched.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DFIND.C: This program finds and prints all files in the current
%@AS@%  directory with
%@AS@%   * the .c extension.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  main()
%@AS@%  {
%@AS@%     struct find_t  c_file;
%@AS@%  
%@AS@%     /* find first .c file in current directory */
%@AS@%     _dos_findfirst( "*.c", _A_NORMAL, &c_file );
%@AS@%  
%@AS@%     printf( "Listing of .c files\n\n" );
%@AS@%     printf( "File: %s is %ld bytes\n", c_file.name, c_file.size );
%@AS@%  
%@AS@%     /* find the rest of the .c files */
%@AS@%     while( _dos_findnext( &c_file ) == 0 )
%@AS@%        printf( "File: %s is %ld bytes\n", c_file.name, c_file.size );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Listing of .c files
%@AS@%  
%@AS@%  File: CHDIR.C is 524 bytes
%@AS@%  File: SIGFP.C is 2674 bytes
%@AS@%  File: MAX.C is 258 bytes
%@AS@%  File: CGETS.C is 577 bytes
%@AS@%  File: FWRITE.C is 1123 bytes %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_freemem@%%@NL@%
%@2@%%@CR:C6A00610358 @%%@AB@%_dos_freemem%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00610359 @% %@CR:C6A00610360 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Releases a block of memory (INT 0x49).  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <errno.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_freemem( unsigned seg );%@AE@%%@NL@%
%@NL@%
%@AI@%seg%@AE@%                               Block to be released

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_freemem%@AE@% function uses system call 0x49 to release a block of memory
previously allocated by %@AB@%_dos_allocmem%@AE@%. The %@AI@%seg%@AE@% argument is a value returned
by a previous call to %@AB@%_dos_allocmem%@AE@%. The freed memory may no longer be used
by the application program.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, %@AB@%_dos_freemem%@AE@% returns 0. Otherwise, it returns the DOS error
code and sets %@AB@%errno%@AE@% to %@AB@%ENOMEM%@AE@%, indicating a bad segment value (one that does
not correspond to a segment returned by a previous %@AB@%_dos_allocmem%@AE@% call) or
invalid arena headers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_allocmem%@AE@%, %@AB@% _dos_setblock%@AE@%, %@AB@%free%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DALOCMEM.C: This program allocates 20 paragraphs of memory, increases
%@AS@%   * the allocation to 40 paragraphs, and then frees the memory space.
%@AS@%   */
%@AS@%  
%@AS@%  #include <dos.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned segment;
%@AS@%     unsigned maxsize;
%@AS@%  
%@AS@%     /* Allocate 20 paragraphs */
%@AS@%     if( _dos_allocmem( 20, &segment ) != 0 )
%@AS@%        printf( "allocation failed\n" );
%@AS@%     else
%@AS@%        printf( "allocation successful\n" );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Increase allocation to 40 paragraphs */
%@AS@%     if( _dos_setblock( 40, segment, &maxsize ) != 0 )
%@AS@%        printf( "allocation increase failed\n" );
%@AS@%     else
%@AS@%        printf( "allocation increase successful\n" );
%@AS@%  
%@AS@%     /* Free memory */
%@AS@%     if( _dos_freemem( segment ) != 0 )
%@AS@%        printf( "free memory failed\n" );
%@AS@%     else
%@AS@%        printf( "free memory successful\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  allocation successful
%@AS@%  allocation increase successful
%@AS@%  free memory successful %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_getdate@%%@NL@%
%@2@%%@CR:C6A00620361 @%%@AB@%_dos_getdate%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00620362 @% %@CR:C6A00620363 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets current system date using system call INT 0x2A.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _dos_getdate( struct dosdate_t *date );%@AE@%%@NL@%
%@NL@%
%@AI@%date%@AE@%                              Current system date

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_getdate%@AE@% routine uses system call 0x2A to obtain the current system
date. The date is returned in a %@AB@%dosdate_t%@AE@% structure, defined in DOS.H.  %@NL@%
%@NL@%
The %@AB@%dosdate_t%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%unsigned char day%@AE@%                 1-31

%@AB@%unsigned char month%@AE@%               1-12

%@AB@%unsigned int year%@AE@%                 1980 - 2099

%@AB@%unsigned char dayofweek%@AE@%           0 - 6 (0 = Sunday)

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_gettime%@AE@%, %@AB@% _dos_setdate%@AE@%, %@AB@% _dos_settime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%mktime%@AE@%, %@AB@%
%@AB@%_strdate%@AE@%, %@AB@%_strtime%@AE@%, %@AB@%time%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DGTIME.C: This program gets and displays current date and time values.
%@AS@%  */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct dosdate_t date;
%@AS@%     struct dostime_t time;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Get current date and time values */
%@AS@%  
%@AS@%     _dos_getdate( &date );
%@AS@%     _dos_gettime( &time );
%@AS@%  
%@AS@%     printf( "Today's date is %d-%d-%d\n", date.month, date.day, date.year
%@AS@%);
%@AS@%     printf( "The time is %02d:%02d\n", time.hour, time.minute );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Today's date is 6-15-1989
%@AS@%  The time is 18:07 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_getdiskfree@%%@NL@%
%@2@%%@CR:C6A00630364 @%%@AB@%_dos_getdiskfree%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00630365 @% %@CR:C6A00630366 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets disk information using system call INT 0x36.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <errno.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_getdiskfree( unsigned drive, struct diskfree_t *diskspace );%@AE@%%@NL@%
%@NL@%
%@AI@%drive%@AE@%                             Drive number (default is 0)

%@AI@%diskspace%@AE@%                         Buffer to hold disk information

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_getdiskfree%@AE@% routine uses system call 0x36 to obtain information on
the disk drive specified by %@AI@%drive%@AE@%. The default drive is 0, drive A is 1,
drive B is 2, and so on. Information is returned in the %@AB@%diskfree_t%@AE@% structure
(defined in DOS.H) pointed to by %@AI@%diskspace%@AE@%.  %@NL@%
%@NL@%
The %@AB@%struct diskfree_t%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%unsigned total_clusters%@AE@%           Total clusters on disk

%@AB@%unsigned avail_clusters%@AE@%           Available clusters on disk

%@AB@%unsigned sectors_per_cluster%@AE@%      Sectors per cluster

%@AB@%unsigned bytes_per_sector%@AE@%         Bytes per sector

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the function returns 0. Otherwise, it returns a nonzero value
and sets %@AB@%errno%@AE@% to %@AB@%EINVAL%@AE@%, indicating that an invalid drive was specified.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_getdrive%@AE@%, %@AB@%_dos_setdrive%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DGDISKFR.C: This program displays information about the default disk
%@AS@%  drive. */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  main()
%@AS@%  {
%@AS@%     struct diskfree_t drive;
%@AS@%  
%@AS@%     /* Get information on default disk drive 0 */
%@AS@%  
%@AS@%     _dos_getdiskfree( 0, &drive );
%@AS@%     printf( "total clusters: %d\n", drive.total_clusters );
%@AS@%     printf( "available clusters: %d\n", drive.avail_clusters );
%@AS@%     printf( "sectors per cluster: %d\n", drive.sectors_per_cluster );
%@AS@%     printf( "bytes per sector: %d\n", drive.bytes_per_sector );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  total clusters: 9013
%@AS@%  available clusters: 6030
%@AS@%  sectors per cluster: 4
%@AS@%  bytes per sector: 512%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_getdrive@%%@NL@%
%@2@%%@CR:C6A00640367 @%%@AB@%_dos_getdrive%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00640368 @% %@CR:C6A00640369 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current disk drive using system call INT 0x19.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _dos_getdrive( unsigned *drive );%@AE@%%@NL@%
%@NL@%
%@AI@%drive%@AE@%                             Current-drive return buffer

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_getdrive%@AE@% routine uses system call 0x19 to obtain the current disk
drive. The current drive is returned in the word that %@AI@%drive%@AE@% points to: 1 =
drive A, 2 = drive B, and so on.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_getdiskfree%@AE@%, %@AB@% _dos_setdrive%@AE@%, %@AB@% _getdrive%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DGDRIVE.C: This program prints the letter of the current drive,
%@AS@%   * changes the default drive to A, then returns the number of disk drives.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned olddrive, newdrive;
%@AS@%     unsigned number_of_drives;
%@AS@%  
%@AS@%     /* Print current default drive information */
%@AS@%     _dos_getdrive( &olddrive );
%@AS@%     printf( "The current drive is: %c\n", 'A' + olddrive1 );
%@AS@%  
%@AS@%     /* Set default drive to be drive A */
%@AS@%     printf( "Changing default drive to A\n");
%@AS@%     _dos_setdrive( 1, &number_of_drives );
%@AS@%  
%@AS@%     /* Get new default drive information and total number of drives */
%@AS@%     _dos_getdrive( &newdrive );
%@AS@%     printf( "The current drive is: %c\n", 'A' + newdrive1 );
%@AS@%     printf( "Number of logical drives: %d\n", number_of_drives );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Restore default drive */
%@AS@%     _dos_setdrive( olddrive, &number_of_drives );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The current drive is: C
%@AS@%  Changing default drive to A
%@AS@%  The current drive is: A
%@AS@%  Number of logical drives: 26 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_getfileattr@%%@NL@%
%@2@%%@CR:C6A00650370 @%%@AB@%_dos_getfileattr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00650371 @% %@CR:C6A00650372 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current attributes of a file or directory, using system call INT
0x43.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <errno.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_getfileattr( char *pathname, unsigned *attrib );%@AE@%%@NL@%
%@NL@%
%@AI@%pathname%@AE@%                          Full path of target file/directory

%@AI@%attrib%@AE@%                            Word to store attributes in

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_getfileattr%@AE@% routine uses system call 0x43 to obtain the current
attributes of the file or directory pointed to by %@AI@%pathname%@AE@% . The attributes
are copied to the low-order byte of the %@AI@%attrib%@AE@% word. Attributes are
represented by manifest constants, as described below:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_A_ARCH%@AE@%                           Archive. Set whenever the file is 
                                  changed, or cleared by the DOS BACKUP 
                                  command.

%@AB@%_A_HIDDEN%@AE@%                         Hidden file. Cannot be found by a 
                                  directory search.

%@AB@%_A_NORMAL%@AE@%                         Normal. File can be read or written 
                                  without restriction.

%@AB@%_A_RDONLY%@AE@%                         Read-only. File cannot be opened for a 
                                  write, and a file with the same name 
                                  cannot be created.

%@AB@%_A_SUBDIR%@AE@%                         Subdirectory.

%@AB@%_A_SYSTEM%@AE@%                         System file. Cannot be found by a 
                                  directory search.

%@AB@%_A_VOLID%@AE@%                          Volume ID. Only one file can have this 
                                  attribute, and it must be in the root 
                                  directory.

%@AB@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the function returns 0. Otherwise, it returns the DOS error
code and sets %@AB@%errno%@AE@% to %@AB@%ENOENT%@AE@%, indicating that the target file or directory
could be found.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%access%@AE@%, %@AB@%chmod%@AE@%, %@AB@%_dos_setfileattr%@AE@%, %@AB@%umask%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DGFILEAT.C: This program creates a file with the specified attributes,
%@AS@%   * then prints this information before changing the file attributes back 
%@AS@%   * to normal.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned oldattrib, newattrib;
%@AS@%     int fh;
%@AS@%  
%@AS@%     /* Get and display file attribute */
%@AS@%     _dos_getfileattr( "DGFILEAT.C", &oldattrib );
%@AS@%     printf( "Attribute: 0x%.4x\n", oldattrib );
%@AS@%     if( ( oldattrib & _A_RDONLY ) != 0 )
%@AS@%        printf( "Read only file\n" );
%@AS@%     else
%@AS@%        printf( "Not a read only file.\n" );
%@AS@%  
%@AS@%     /* Reset file attribute to normal file */
%@AS@%     _dos_setfileattr( "DGFILEAT.C", _A_RDONLY );
%@AS@%     _dos_getfileattr( "DGFILEAT.C", &newattrib );
%@AS@%     printf( "Attribute: 0x%.4x\n", newattrib );
%@AS@%  
%@AS@%     /* Restore file attribute */
%@AS@%     _dos_setfileattr( "DGFILEAT.C", oldattrib );
%@AS@%     _dos_getfileattr( "DGFILEAT.C", &newattrib );
%@AS@%     printf( "Attribute: 0x%.4x\n", newattrib );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Attribute: 0x0020
%@AS@%  Not a read only file.
%@AS@%  Attribute: 0x0001
%@AS@%  Attribute: 0x0020 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_getftime@%%@NL@%
%@2@%%@CR:C6A00660373 @%%@AB@%_dos_getftime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00660374 @% %@CR:C6A00660375 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the date and time a file was last written, using system call INT 0x57.
%@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <errno.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_getftime( int handle, unsigned *date, unsigned *time );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Target file

%@AI@%date%@AE@%                              Date-return buffer

%@AI@%time%@AE@%                              Time-return buffer

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_getftime%@AE@% routine uses system call 0x57 to get the date and time
that the specified file was last written. The file must have been opened
with a call to %@AB@%_dos_open%@AE@% or %@AB@%_dos_creat%@AE@% prior to calling %@AB@%_dos_getftime%@AE@%. The
date and time are returned in the words pointed to by %@AI@%date%@AE@% and %@AI@%time%@AE@%. The
values appear in the DOS date and time format:  %@NL@%
%@NL@%
%@AB@%Time Bits%@AE@%                         %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
0 - 4                             Number of 2-second increments (0 -29)

5 -10                             Minutes (0 -59)

11-15                             Hours (0 -23)

%@AB@%Date Bits%@AE@%                         %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
0 - 4                             Day (1-31)

5 - 8                             Month (1-12)

9 -15                             Year (1980 -2099)

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the function returns 0. Otherwise, it returns the DOS error
code and sets %@AB@%errno%@AE@% to%@AB@% EBADF%@AE@%, indicating that an invalid file handle was
passed.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_setftime%@AE@%, %@AB@%fstat%@AE@%, %@AB@%stat%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DGFTIME.C: This program displays and modifies the date and time
%@AS@%   * fields of a file.
%@AS@%   */
%@AS@%  
%@AS@%  #include <fcntl.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%                                   /* FEDC BA98 7654 3210          */
%@AS@%     unsigned new_date = 0x184f;   /* 0001 1000 0100 1111  2/15/92 */
%@AS@%     unsigned new_time = 0x48e0;   /* 0100 1000 1110 0000  9:07 AM */
%@AS@%     unsigned old_date, old_time;
%@AS@%  
%@AS@%     int fh;
%@AS@%  
%@AS@%     /* Open file with _dos_open function */
%@AS@%     if( _dos_open( "dgftime.obj", O_RDONLY, &fh ) != 0 )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     /* Get file date and time */
%@AS@%     _dos_getftime( fh, &old_date, &old_time );
%@AS@%     printf( "Old date field: 0x%.4x\n", old_date );
%@AS@%     printf( "Old time field: 0x%.4x\n", old_time );
%@AS@%     system( "dir dgftime.obj" );
%@AS@%  
%@AS@%     /* Modify file date and time */
%@AS@%     if( !_dos_setftime( fh, new_date, new_time ) )
%@AS@%     {
%@AS@%        _dos_getftime( fh, &new_date, &new_time );
%@AS@%        printf( "New date field: 0x%.4x\n", new_date );
%@AS@%        printf( "New time field: 0x%.4x\n", new_time );
%@AS@%        system( "dir dgftime.obj" );
%@AS@%  
%@AS@%        /* Restore date and time */
%@AS@%        _dos_setftime( fh, old_date, old_time );
%@AS@%     }
%@AS@%     _dos_close( fh );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Old date field: 0x12cf
%@AS@%  Old time field: 0x94bb
%@AS@%  
%@AS@%   Volume in drive C is OS2
%@AS@%   Directory of  C:\LIBREF
%@AS@%  
%@AS@%  DGFTIME  OBJ     3923   6-15-89   6:37p
%@AS@%          1 File(s)  13676544 bytes free
%@AS@%  
%@AS@%  New date field: 0x184f
%@AS@%  New time field: 0x48e0
%@AS@%  
%@AS@%   Volume in drive C is OS2
%@AS@%   Directory of  C:\LIBREF
%@AS@%  
%@AS@%  DGFTIME  OBJ     3923   2-15-92   9:07a
%@AS@%          1 File(s)  13676544 bytes free %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_gettime@%%@NL@%
%@2@%%@CR:C6A00670376 @%%@AB@%_dos_gettime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00670377 @% %@CR:C6A00670378 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current system time, using system call INT 0x2C.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _dos_gettime( struct dostime_t *time );%@AE@%%@NL@%
%@NL@%
%@AI@%time%@AE@%                              Current system time

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_gettime%@AE@% routine uses system call 0x2C to obtain the current system
time. The time is returned in a %@AB@%dostime_t%@AE@% structure, defined in DOS.H.  %@NL@%
%@NL@%
The %@AB@%dostime_t%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%unsigned char hour%@AE@%                0 -23

%@AB@%unsigned char minute%@AE@%              0 -59

%@AB@%unsigned char second%@AE@%              0 -59

%@AB@%unsigned char hsecond%@AE@%             1/100 second; 0 -99

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_getdate%@AE@%, %@AB@% _dos_setdate%@AE@%, %@AB@% _dos_settime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@% _strtime%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DGTIME.C: This program gets and displays current date and time values.
%@AS@%  */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct dosdate_t date;
%@AS@%     struct dostime_t time;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Get current date and time values */
%@AS@%  
%@AS@%     _dos_getdate( &date );
%@AS@%     _dos_gettime( &time );
%@AS@%  
%@AS@%     printf( "Today's date is %d-%d-%d\n", date.month, date.day, date.year
%@AS@%);
%@AS@%     printf( "The time is %02d:%02d\n", time.hour, time.minute );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Today's date is 6-15-1989
%@AS@%  The time is 18:07 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_getvect@%%@NL@%
%@2@%%@CR:C6A00680379 @%%@AB@%_dos_getvect%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00680380 @% %@CR:C6A00680381 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current value of the interrupt vector, using system call INT 0x35.
%@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void ( _interrupt _far *_dos_getvect( unsigned intnum))();%@AE@%%@NL@%
%@NL@%
%@AI@%intnum%@AE@%                            Target interrupt vector

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_getvect%@AE@% routine uses system call INT 0x35 to get the current value
of the interrupt vector specified by %@AI@%intnum%@AE@%.  %@NL@%
%@NL@%
This routine is typically used in conjunction with the %@AB@%_dos_setvect%@AE@%
function. To replace an interrupt vector, first save the current vector of
the interrupt using %@AB@%_dos_getvect%@AE@%. Then set the vector to your own interrupt
routine with %@AB@%_dos_setvect%@AE@%. The saved vector can later be restored, if
necessary, using %@AB@%_dos_setvect%@AE@%. The user-defined routine may also need the
original vector in order to call that vector or chain to it with
%@AB@%_chain_intr%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns a far pointer for the %@AI@%intnum%@AE@% interrupt to the current
handler, if there is one.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_chain_intr%@AE@%, %@AB@% _dos_keep%@AE@%, %@AB@% _dos_setvect%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_keep@%%@NL@%
%@2@%%@CR:C6A00690382 @%%@AB@%_dos_keep%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00690383 @% %@CR:C6A00690384 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Installs TSR (terminate-and-stay-resident) programs in memory, using system
call INT 0x31.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _dos_keep( unsigned retcode, unsigned memsize );%@AE@%%@NL@%
%@NL@%
%@AI@%retcode%@AE@%                           Exit status code

%@AI@%memsize%@AE@%                           Allocated resident memory (in 16-byte 
                                  paragraphs)

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_keep%@AE@% routine installs TSRs (terminate-and-stay-resident programs)
in memory, using system call INT 0x31.  %@NL@%
%@NL@%
The routine first exits the calling process, leaving it in memory. It then
returns the low-order byte of %@AI@%retcode%@AE@% to the parent of the calling process.
Before returning execution to the parent process, %@AB@%_dos_keep%@AE@% sets the
allocated memory for the now-resident process to %@AI@%memsize%@AE@% 16-byte paragraphs.
Any excess memory is returned to the system.  %@NL@%
%@NL@%
The %@AB@%_dos_keep%@AE@% function calls the same internal routines called by %@AB@%exit%@AE@%. It
therefore takes the following actions:  %@NL@%
%@NL@%
%@NL@%
  ş   Calls %@AB@%atexit%@AE@% and %@AB@%onexit%@AE@% if defined.%@NL@%
%@NL@%
  ş   Flushes all file buffers.%@NL@%
%@NL@%
  ş   Restores interrupt vectors replaced by the C start-up code. The
      primary one is interrupt 0 (divide by zero). If the emulator math
      library is used and there is no coprocessor, interrupts 0x34 through
      0x3D are restored. If there is a coprocessor, interrupt 2 is restored.%@NL@%
%@NL@%
%@NL@%
The %@AB@%_dos_keep%@AE@% function does not automatically close files; you should do
this specifically unless you want files opened by the TSR installation code
to remain open for the TSR.  %@NL@%
%@NL@%
Do not use the emulator math library in TSRs unless you are familiar with
the C start-up code and the coprocessor. Use the alternate math package (not
supplied with Microsoft QuickC) if the TSR must do floating-point math.  %@NL@%
%@NL@%
Do not run programs that use %@AB@%_dos_keep%@AE@% from inside the Microsoft
Programmer's WorkBench environment, since doing so causes subsequent memory
problems. The %@AB@%_dos_keep%@AE@% function terminates the program when executed in the
Programmer's WorkBench environment.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_cexit%@AE@%,%@AB@%  _chain_intr%@AE@%, %@AB@% _dos_getvect%@AE@%, %@AB@% _dos_setvect%@AE@%, %@AB@% _exit %@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_open@%%@NL@%
%@2@%%@CR:C6A00700385 @%%@AB@%_dos_open%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00700386 @% %@CR:C6A00700387 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Opens a file, using system call INT 0x3D.  %@NL@%
%@NL@%
%@AB@%#include <dos.h>%@AE@%                  

%@AB@%#include <errno.h>%@AE@%                

%@AB@%#include <fcntl.h>%@AE@%                Access mode constants

%@AB@%#include <share.h>%@AE@%                Sharing mode constants

%@AS@%  unsigned _dos_open( char *filename, unsigned mode, int *handle );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          Path to an existing file

%@AI@%mode%@AE@%                              Permissions

%@AI@%handle%@AE@%                            Pointer to integer

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_open%@AE@% routine uses system call INT 0x3D to open the existing file
pointed to by %@AI@%filename%@AE@%. The handle for the opened file is copied into the
integer pointed to by %@AI@%handle%@AE@%. The %@AI@%mode%@AE@% argument specifies the file's access,
sharing, and inheritance modes by combining (with the OR operator) manifest
constants from the three groups shown below. At most, one access mode and
one sharing mode can be specified at a time.  %@NL@%
%@NL@%
%@TH:  21   950 02 14 33 33 @%%@AB@%Constant%@AE@%      %@AB@%Mode%@AE@%                             %@AB@%Meaning%@AE@%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%O_RDONLY%@AE@%      Access                           Read-only%@AB@%O_WRONLY%@AE@%      Access                           Write-only%@AB@%O_RDWR%@AE@%        Access                           Both read and write%@AB@%SH_COMPAT%@AE@%     Sharing                          Compatibility%@AB@%SH_DENYRW%@AE@%     Sharing                          Deny reading and writing%@AB@%SH_DENYWR%@AE@%     Sharing                          Deny writing%@AB@%SH_DENYRD%@AE@%     Sharing                          Deny reading%@AB@%SH_DENYNO%@AE@%     Sharing                          Deny neither%@AB@%O_NOINHERIT%@AE@%   Inheritance by the child         File is not inherited              process                          %@TE:  21   950 02 14 33 33 @%

Do not use the DOS interface I/O routines in conjunction with the console,
low-level, or stream I/O routines.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the function returns 0. Otherwise, it returns the DOS error
code and sets %@AB@%errno%@AE@% to one of the following manifest constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Access denied (possible reasons include 
                                  specifying a directory or volume ID for %@AI@%%@AE@%
                                  %@AI@%filename%@AE@%, or opening a read-only file 
                                  for write access)

%@AB@%EINVAL%@AE@%                            Sharing mode specified when file sharing
                                  not installed, or
                                  access-mode value is invalid

%@AB@%%@AE@%%@AB@%EMFILE%@AE@%                            Too many open file handles

%@AB@%%@AE@%%@AB@%ENOENT%@AE@%                            Path or file not found

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_close%@AE@%, %@AB@% _dos_read%@AE@%,  %@AB@%_dos_write%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DOPEN.C: This program uses DOS I/O functions to open and close a file.
%@AS@%  */
%@AS@%  
%@AS@%  #include <fcntl.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh;
%@AS@%  
%@AS@%     /* Open file with _dos_open function */
%@AS@%     if( _dos_open( "data1", O_RDONLY, &fh ) != 0 )
%@AS@%        perror( "Open failed on input file\n" );
%@AS@%     else
%@AS@%        printf( "Open succeeded on input file\n" );
%@AS@%  
%@AS@%     /* Close file with _dos_close function */
%@AS@%     if( _dos_close( fh ) != 0 )
%@AS@%        perror( "Close failed\n" );
%@AS@%     else
%@AS@%        printf( "File successfully closed\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Open succeeded on input file
%@AS@%  File successfully closed %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_read@%%@NL@%
%@2@%%@CR:C6A00710388 @%%@AB@%_dos_read%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00710389 @% %@CR:C6A00710390 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Reads data from a file, using system call INT 0x3F.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_read( int handle, void _far *buffer, unsigned count, 
%@AS@%  unsigned *numread );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            File to read

%@AI@%buffer%@AE@%                            Buffer to write to

%@AI@%count%@AE@%                             Number of bytes to read

%@AI@%numread%@AE@%                           Number of bytes actually read

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_read%@AE@% routine uses system call INT 0x3F to read %@AI@%count%@AE@% bytes of data
from the file specified by %@AI@%handle%@AE@%. The routine then copies the data to the
buffer pointed to by %@AI@%buffer%@AE@%. The integer pointed to by %@AI@%numread%@AE@% will show the
number of bytes actually read, which may be less than the number requested
in %@AI@%count%@AE@%. If the number of bytes actually read is 0, it means the routine
tried to read at end-of-file.  %@NL@%
%@NL@%
Do not use the DOS interface I/O routines in conjunction with the console,
low-level, or stream I/O routines.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the function returns 0. Otherwise, it returns the DOS error
code and sets %@AB@%errno%@AE@% to one of the following constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Access denied (%@AI@%handle%@AE@% is not open for 
                                  read access)

%@AB@%EBADF%@AE@%                             File handle is invalid

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_close%@AE@%, %@AB@% _dos_open%@AE@%, %@AB@% _dos_write%@AE@%, %@AB@%read%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DREAD.C: This program uses the DOS I/O operations to read the contents
%@AS@%   * of a file.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <fcntl.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh;
%@AS@%     char buffer[50];
%@AS@%     unsigned number_read;
%@AS@%  
%@AS@%     /* Open file with _dos_open function */
%@AS@%     if( _dos_open( "dread.c", O_RDONLY, &fh ) != 0 )
%@AS@%        perror( "Open failed on input file\n" );
%@AS@%     else
%@AS@%        printf( "Open succeeded on input file\n" );
%@AS@%  
%@AS@%     /* Read data with _dos_read function */
%@AS@%     _dos_read( fh, buffer, 50, &number_read );
%@AS@%     printf( "First 40 characters are: %.40s\n\n", buffer );
%@AS@%  
%@AS@%     /* Close file with _dos_close function */
%@AS@%     _dos_close( fh );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Open succeeded on input file
%@AS@%  First 40 characters are: /* DREAD.C: This program uses the DOS I/ %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_setblock@%%@NL@%
%@2@%%@CR:C6A00720391 @%%@AB@%_dos_setblock%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00720392 @% %@CR:C6A00720393 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Changes the size of a memory segment, using system call INT 0x4A.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_setblock( unsigned size, unsigned seg, unsigned *maxsize );%@AE@%%@NL@%
%@NL@%
%@AI@%size%@AE@%                              New segment size

%@AI@%seg%@AE@%                               Target segment

%@AI@%maxsize%@AE@%                           Maximum-size buffer

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_setblock%@AE@% routine uses system call INT 0x4A to change the size of
%@AI@%seg%@AE@%, previously allocated by %@AB@%_dos_allocmem%@AE@%, to %@AI@%size%@AE@% paragraphs. If the
request cannot be satisfied, the maximum possible segment size is copied to
the buffer pointed to by %@AI@%maxsize%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns 0 if successful. If the call fails, it returns the DOS
error code and sets %@AB@%errno%@AE@% to %@AB@%ENOMEM%@AE@%, indicating a bad segment value was
passed. A bad segment value is one that does not correspond to a segment
returned from a previous %@AB@%_dos_allocmem%@AE@% call, or one that contains invalid
arena headers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_allocmem%@AE@%, %@AB@% _dos_freemem%@AE@%, %@AB@%realloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DALOCMEM.C: This program allocates 20 paragraphs of memory, increases
%@AS@%   * the allocation to 40 paragraphs, and then frees the memory space.
%@AS@%   */
%@AS@%  
%@AS@%  #include <dos.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned segment;
%@AS@%     unsigned maxsize;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Allocate 20 paragraphs */
%@AS@%     if( _dos_allocmem( 20, &segment ) != 0 )
%@AS@%        printf( "allocation failed\n" );
%@AS@%     else
%@AS@%        printf( "allocation successful\n" );
%@AS@%  
%@AS@%     /* Increase allocation to 40 paragraphs */
%@AS@%     if( _dos_setblock( 40, segment, &maxsize ) != 0 )
%@AS@%        printf( "allocation increase failed\n" );
%@AS@%     else
%@AS@%        printf( "allocation increase successful\n" );
%@AS@%  
%@AS@%     /* Free memory */
%@AS@%     if( _dos_freemem( segment ) != 0 )
%@AS@%        printf( "free memory failed\n" );
%@AS@%     else
%@AS@%        printf( "free memory successful\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  allocation successful
%@AS@%  allocation increase successful
%@AS@%  free memory successful %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_setdate@%%@NL@%
%@2@%%@CR:C6A00730394 @%%@AB@%_dos_setdate%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00730395 @% %@CR:C6A00730396 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the current system date, using system call INT 0x2B.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_setdate( struct dosdate_t *date );%@AE@%%@NL@%
%@NL@%
%@AI@%date%@AE@%                              New system date

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_setdate%@AE@% routine uses system call INT 0x2B to set the current system
date. The date is stored in the %@AB@%dosdate_t%@AE@% structure pointed to by %@AI@%date%@AE@%,
defined in DOS.H. The %@AB@%dosdate_t%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%unsigned char day%@AE@%                 1 -31

%@AB@%unsigned char month%@AE@%               1 -12

%@AB@%unsigned int year%@AE@%                 1980 - 2099

%@AB@%unsigned char dayofweek%@AE@%           0 - 6 (0 = Sunday)

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the function returns 0. Otherwise, it returns a nonzero value
and sets %@AB@%errno%@AE@% to %@AB@%EINVAL%@AE@%, indicating an invalid date was specified.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_gettime%@AE@%, %@AB@% _dos_setdate%@AE@%, %@AB@% _dos_settime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%mktime%@AE@%, %@AB@%
%@AB@%_strdate%@AE@%, %@AB@%_strtime%@AE@%, %@AB@%time%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DSTIME.C: This program changes the time and date values and displays
%@AS@%  the
%@AS@%   * new date and time values.
%@AS@%   */
%@AS@%  
%@AS@%  #include <dos.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <time.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct dosdate_t olddate, newdate = { { 4 }, { 7 }, { 1984 } };
%@AS@%     struct dostime_t oldtime, newtime = { { 3 }, { 45 }, { 30 }, { 0 } };
%@AS@%     char   datebuf[40], timebuf[40];
%@AS@%  
%@AS@%     /* Get current date and time values */
%@AS@%     _dos_getdate( &olddate );
%@AS@%     _dos_gettime( &oldtime );
%@AS@%     printf( "%s    %s\n" , _strdate( datebuf ), _strtime( timebuf ) );
%@AS@%  
%@AS@%     /* Modify date and time structures */
%@AS@%     _dos_setdate( &newdate );
%@AS@%     _dos_settime( &newtime );
%@AS@%     printf( "%s    %s\n" , _strdate( datebuf ), _strtime( timebuf ) );
%@AS@%  
%@AS@%     /* Restore old date and time */
%@AS@%     _dos_setdate( &olddate );
%@AS@%     _dos_settime( &oldtime );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  06/15/89    18:26:09
%@AS@%  07/04/84    03:45:30 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_setdrive@%%@NL@%
%@2@%%@CR:C6A00740397 @%%@AB@%_dos_setdrive%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00740398 @% %@CR:C6A00740399 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the default drive, using system call INT 0x0E.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _dos_setdrive( unsigned drive, unsigned *numdrives );%@AE@%%@NL@%
%@NL@%
%@AI@%drive%@AE@%                             New default drive

%@AI@%numdrives%@AE@%                         Total drives available

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_setdrive%@AE@% routine uses system call INT 0x0E to set the current
default drive to the %@AI@%drive%@AE@% argument: 1 = drive A, 2 = drive B, and so on.
The %@AI@%numdrives%@AE@% argument indicates the total number of drives in the system.
If this value is 4, for example, it does not mean the drives are designated
A, B, C, and D; it means only that four drives are in the system.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
There is no return value. If an invalid drive number is passed, the function
fails without indication. Use the %@AB@%_dos_getdrive%@AE@% routine to verify whether
the desired drive has been set.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_getdiskfree%@AE@%, %@AB@% _dos_getdrive%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DGDRIVE.C: This program prints the letter of the current drive,
%@AS@%   * changes the default drive to A, then returns the number of disk drives.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned olddrive, newdrive;
%@AS@%     unsigned number_of_drives;
%@AS@%  
%@AS@%     /* Print current default drive information */
%@AS@%     _dos_getdrive( &olddrive );
%@AS@%     printf( "The current drive is: %c\n", 'A' + olddrive1 );
%@AS@%  
%@AS@%     /* Set default drive to be drive A */
%@AS@%     printf( "Changing default drive to A\n");
%@AS@%     _dos_setdrive( 1, &number_of_drives );
%@AS@%  
%@AS@%     /* Get new default drive information and total number of drives */
%@AS@%     _dos_getdrive( &newdrive );
%@AS@%     printf( "The current drive is: %c\n", 'A' + newdrive1 );
%@AS@%     printf( "Number of logical drives: %d\n", number_of_drives );
%@AS@%  
%@AS@%     /* Restore default drive */
%@AS@%     _dos_setdrive( olddrive, &number_of_drives );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The current drive is: C
%@AS@%  Changing default drive to A
%@AS@%  The current drive is: A
%@AS@%  Number of logical drives: 26 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_setfileattr@%%@NL@%
%@2@%%@CR:C6A00750400 @%%@AB@%_dos_setfileattr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00750401 @% %@CR:C6A00750402 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the attributes of the file or directory, using system call INT 0x43.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_setfileattr( char *pathname, unsigned attrib );%@AE@%%@NL@%
%@NL@%
%@AI@%pathname%@AE@%                          Full path of target file/directory

%@AI@%attrib%@AE@%                            New attributes

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_setfileattr%@AE@% routine uses system call INT 0x43 to set the attributes
of the file or directory pointed to by %@AI@%pathname%@AE@%. The actual attributes are
contained in the low-order byte of the %@AI@%attrib%@AE@% word. Attributes are
represented by manifest constants, as described below:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_A_ARCH%@AE@%                           Archive. Set whenever the file is 
                                  changed, or cleared by the DOS BACKUP 
                                  command.

%@AB@%_A_HIDDEN%@AE@%                         Hidden file. Cannot be found by a 
                                  directory search.

%@AB@%_A_NORMAL%@AE@%                         Normal. File can be read or written to 
                                  without restriction.

%@AB@%_A_RDONLY%@AE@%                         Read-only. File cannot be opened for 
                                  writing, and a file with the same name 
                                  cannot be created.

%@AB@%_A_SUBDIR%@AE@%                         Subdirectory.

%@AB@%_A_SYSTEM%@AE@%                         System file. Cannot be found by a 
                                  directory search.

%@AB@%_A_VOLID%@AE@%                          Volume ID. Only one file can have this 
                                  attribute, and it must be in the root 
                                  directory.

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns 0 if successful. Otherwise, it returns the DOS error
code and sets %@AB@%errno%@AE@% to one of the following:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Access denied; cannot change the volume 
                                  ID or the
                                  subdirectory.

%@AB@%ENOENT%@AE@%                            No file or directory matching the target
                                  was found.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_getfileattr%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DGFILEAT.C: This program creates a file with the specified attributes,
%@AS@%   * then prints this information before changing the file attributes back 
%@AS@%   * to normal.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned oldattrib, newattrib;
%@AS@%     int fh;
%@AS@%  
%@AS@%     /* Get and display file attribute */
%@AS@%     _dos_getfileattr( "DGFILEAT.C", &oldattrib );
%@AS@%     printf( "Attribute: 0x%.4x\n", oldattrib );
%@AS@%     if( ( oldattrib & _A_RDONLY ) != 0 )
%@AS@%        printf( "Read only file\n" );
%@AS@%     else
%@AS@%        printf( "Not a read only file.\n" );
%@AS@%  
%@AS@%     /* Reset file attribute to normal file */
%@AS@%     _dos_setfileattr( "DGFILEAT.C", _A_RDONLY );
%@AS@%     _dos_getfileattr( "DGFILEAT.C", &newattrib );
%@AS@%     printf( "Attribute: 0x%.4x\n", newattrib );
%@AS@%  
%@AS@%     /* Restore file attribute */
%@AS@%     _dos_setfileattr( "DGFILEAT.C", oldattrib );
%@AS@%     _dos_getfileattr( "DGFILEAT.C", &newattrib );
%@AS@%     printf( "Attribute: 0x%.4x\n", newattrib );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Attribute: 0x0020
%@AS@%  Not a read only file.
%@AS@%  Attribute: 0x0001
%@AS@%  Attribute: 0x0020 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_setftime@%%@NL@%
%@2@%%@CR:C6A00760403 @%%@AB@%_dos_setftime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00760404 @% %@CR:C6A00760405 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the date and time for a file, using system call INT 0x57.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_setftime( int handle, unsigned date, unsigned time );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Target file

%@AI@%date%@AE@%                              Date of last write

%@AI@%time%@AE@%                              Time of last write

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_setftime%@AE@% routine uses system call INT 0x57 to set the %@AI@%date%@AE@% and %@AI@%time%@AE@%
at which the file identified by %@AI@%handle%@AE@% was last written to. These values
appear in the DOS date and time format, described in the following lists:  %@NL@%
%@NL@%
%@AB@%Time Bits%@AE@%                         %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
0 - 4                             Number of two-second increments (0 -29)

5 - 10                            Minutes (0 -59)

11-15                             Hours (0 -23)

%@AB@%Date Bits%@AE@%                         %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
0 - 4                             Day (1-31)

5 -8                              Month (1-12)

9 -15                             Year since 1980 (for example, 1989 is 
                                  stored as 9)

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the function returns 0. Otherwise, it returns the DOS error
code and sets %@AB@%errno%@AE@% to %@AB@%EBADF%@AE@%, indicating that an invalid file handle was
passed.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_getftime%@AE@%, %@AB@%fstat%@AE@%, %@AB@%stat%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DGFTIME.C: This program displays and modifies the date and time
%@AS@%   * fields of a file.
%@AS@%   */
%@AS@%  
%@AS@%  #include <fcntl.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%                                   /* FEDC BA98 7654 3210          */
%@AS@%     unsigned new_date = 0x184f;   /* 0001 1000 0100 1111  2/15/92 */
%@AS@%     unsigned new_time = 0x48e0;   /* 0100 1000 1110 0000  9:07 AM */
%@AS@%     unsigned old_date, old_time;
%@AS@%  
%@AS@%     int fh;
%@AS@%  
%@AS@%     /* Open file with _dos_open function */
%@AS@%     if( _dos_open( "dgftime.obj", O_RDONLY, &fh ) != 0 )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     /* Get file date and time */
%@AS@%     _dos_getftime( fh, &old_date, &old_time );
%@AS@%     printf( "Old date field: 0x%.4x\n", old_date );
%@AS@%     printf( "Old time field: 0x%.4x\n", old_time );
%@AS@%     system( "dir dgftime.obj" );
%@AS@%  
%@AS@%     /* Modify file date and time */
%@AS@%     if( !_dos_setftime( fh, new_date, new_time ) )
%@AS@%     {
%@AS@%        _dos_getftime( fh, &new_date, &new_time );
%@AS@%        printf( "New date field: 0x%.4x\n", new_date );
%@AS@%        printf( "New time field: 0x%.4x\n", new_time );
%@AS@%        system( "dir dgftime.obj" );
%@AS@%  
%@AS@%        /* Restore date and time */
%@AS@%        _dos_setftime( fh, old_date, old_time );
%@AS@%     }
%@AS@%     _dos_close( fh );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Old date field: 0x12cf
%@AS@%  Old time field: 0x94bb
%@AS@%  
%@AS@%   Volume in drive C is OS2
%@AS@%   Directory of  C:\LIBREF
%@AS@%  
%@AS@%  DGFTIME  OBJ     3923   6-15-89   6:37p
%@AS@%          1 File(s)  13676544 bytes free
%@AS@%  
%@AS@%  New date field: 0x184f
%@AS@%  New time field: 0x48e0
%@AS@%  
%@AS@%   Volume in drive C is OS2
%@AS@%   Directory of  C:\LIBREF
%@AS@%  
%@AS@%  DGFTIME  OBJ     3923   2-15-92   9:07a
%@AS@%          1 File(s)  13676544 bytes free %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_settime@%%@NL@%
%@2@%%@CR:C6A00770406 @%%@AB@%_dos_settime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00770407 @% %@CR:C6A00770408 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the current system time, using system call INT 0x2D.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_settime( struct dostime_t *time );%@AE@%%@NL@%
%@NL@%
%@AI@%time%@AE@%                              New system time

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_settime%@AE@% routine uses system call INT 0x2D to set the current system
time to the value stored in the %@AB@%dostime_t%@AE@% structure that %@AI@%time%@AE@% points to, as
defined in DOS.H. The %@AB@%dostime_t%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%unsigned char hour%@AE@%                0 -23

%@AB@%unsigned char minute%@AE@%              0 -59

%@AB@%unsigned char second%@AE@%              0 -59

%@AB@%unsigned char hsecond%@AE@%             Hundredths of a second; 0 -99

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the function returns 0. Otherwise, it returns a nonzero value
and sets %@AB@%errno%@AE@% to %@AB@%EINVAL%@AE@%, indicating an invalid time was specified.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_getdate%@AE@%, %@AB@% _dos_gettime%@AE@%, %@AB@% _dos_setdate%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%mktime%@AE@%,
%@AB@%_strdate%@AE@%, %@AB@% _strtime%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DSTIME.C: This program changes the time and date values and displays
%@AS@%  the
%@AS@%   * new date and time values.
%@AS@%   */
%@AS@%  
%@AS@%  #include <dos.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <time.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct dosdate_t olddate, newdate = { { 4 }, { 7 }, { 1984 } };
%@AS@%     struct dostime_t oldtime, newtime = { { 3 }, { 45 }, { 30 }, { 0 } };
%@AS@%     char   datebuf[40], timebuf[40];
%@AS@%  
%@AS@%     /* Get current date and time values */
%@AS@%     _dos_getdate( &olddate );
%@AS@%     _dos_gettime( &oldtime );
%@AS@%     printf( "%s    %s\n" , _strdate( datebuf ), _strtime( timebuf ) );
%@AS@%  
%@AS@%     /* Modify date and time structures */
%@AS@%     _dos_setdate( &newdate );
%@AS@%     _dos_settime( &newtime );
%@AS@%     printf( "%s    %s\n" , _strdate( datebuf ), _strtime( timebuf ) );
%@AS@%  
%@AS@%     /* Restore old date and time */
%@AS@%     _dos_setdate( &olddate );
%@AS@%     _dos_settime( &oldtime );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  06/15/89    18:26:09
%@AS@%  07/04/84    03:45:30 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_setvect@%%@NL@%
%@2@%%@CR:C6A00780409 @%%@AB@%_dos_setvect%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00780410 @% %@CR:C6A00780411 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the current value of the interrupt vector, using system call INT 0x25.
%@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _dos_setvect( unsigned intnum, void( _interrupt _far *handler)( ));%@AE@%%@NL@%
%@NL@%
%@AI@%intnum%@AE@%                            Target-interrupt vector

%@AI@%handler%@AE@%                           Interrupt handler for which to assign %@AI@%%@AE@%
                                  %@AI@%intnum%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_setvect%@AE@% routine uses system call INT 0x25 to set the current value
of the interrupt vector %@AI@%intnum%@AE@% to the function pointed to by %@AI@%handler%@AE@%.
Subsequently, whenever the %@AI@%intnum%@AE@% interrupt is generated, the %@AI@%handler%@AE@%
routine will be called. If %@AI@%handler%@AE@% is a C function, it must have been
previously declared with the %@AB@%interrupt%@AE@% attribute. Otherwise, you must make
sure that the function satisfies the requirements for an interrupt-handling
routine. For example, if %@AI@%handler%@AE@% is an assembler function, it must be a %@AB@%far%@AE@%
routine that returns with an %@AB@%IRET %@AE@%instead of a%@AB@% RET%@AE@%.  %@NL@%
%@NL@%
The %@AB@%interrupt%@AE@% attribute indicates that the function is an interrupt handler.
The compiler generates appropriate entry and exit sequences for the
interrupt-handling function, including saving and restoring all registers
and executing an %@AB@%IRET%@AE@% instruction to return.  %@NL@%
%@NL@%
The %@AB@%_dos_setvect%@AE@% routine is generally used with the %@AB@%_dos_getvect%@AE@% function.
To replace an interrupt vector, first save the current vector of the
interrupt using %@AB@%_dos_getvect%@AE@%. Then set the vector to your own interrupt
routine with %@AB@%_dos_setvect%@AE@%. The saved vector can later be restored, if
necessary, using %@AB@%_dos_setvect%@AE@%. The user-defined routine may also need the
original vector in order to call it or to chain to it with %@AB@%_chain_intr%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Registers and Interrupt Functions%@AE@%%@EH@%%@NL@%
%@NL@%
When you call an interrupt function, the DS register is initialized to the C
data segment. This allows you to access global variables from within an
interrupt function.  %@NL@%
%@NL@%
In addition, all registers except SS are saved on the stack. You can access
these registers within the function if you declare a function parameter list
containing a formal parameter for each saved register. The following example
illustrates such a declaration:  %@NL@%
%@NL@%
%@AS@%  void _interrupt _far int_handler( unsigned _es, unsigned _ds,
%@AS@%                                    unsigned _di, unsigned _si, 
%@AS@%                                    unsigned _bp, unsigned _sp,
%@AS@%                                    unsigned _bx, unsigned _dx, 
%@AS@%                                   unsigned _cx, unsigned _ax,
%@AS@%                                    unsigned _ip, unsigned _cs, 
%@AS@%                                   unsigned _flags )
%@AS@%  {
%@AS@%  .
%@AS@%  .
%@AS@%  .
%@AS@%  }%@AE@%%@NL@%
%@NL@%
The formal parameters must appear in the opposite order from which they are
pushed onto the stack. You can omit parameters from the end of the list in a
declaration, but not from the beginning. For example, if your handler needs
to use only DI and SI, you must still provide ES and DS, but not necessarily
BX or DX.  %@NL@%
%@NL@%
You can pass additional arguments if your interrupt handler will be called
directly from C rather than by an INT instruction. To do this, you must
declare all register parameters and then declare your parameter at the end
of the list.  %@NL@%
%@NL@%
The compiler always saves and restores registers in the same, fixed order.
Thus, no matter what names you use in the formal parameter list, the first
parameter in the list refers to ES, the second refers to DS, and so on. If
your interrupt routines will use in-line assembler, you should distinguish
the parameter names so that they will not be the same as the real register
names.  %@NL@%
%@NL@%
If you change any of the register parameters of an interrupt function while
the function is executing, the corresponding register contains the changed
value when the function returns. For example:  %@NL@%
%@NL@%
%@AS@%  void _interrupt _far int_handler( unsigned _es, unsigned _ds,
%@AS@%                                   unsigned _di, unsigned _si )
%@AS@%  {
%@AS@%      _di = -1;
%@AS@%  }%@AE@%%@NL@%
%@NL@%
This code causes the DI register to contain -1 when the %@AI@%handler%@AE@% function
returns. It is not a good idea to modify the values of the parameters
representing the IP and CS registers in interrupt functions. If you must
modify a particular flag (such as the carry flag for certain DOS and BIOS
interrupt routines), use the OR operator ( | ) so that other bits in the
flag register are not changed.  %@NL@%
%@NL@%
When an interrupt function is called by an INT instruction, the
interrupt-enable flag is cleared. If your interrupt function needs to do
significant processing, you should use the %@AB@%_enable%@AE@% function to set the
interrupt flag so that interrupts can be handled.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Precautions for Interrupt Functions%@AE@%%@EH@%%@NL@%
%@NL@%
Since DOS is not reentrant (a DOS interrupt cannot be called from inside a
DOS interrupt), it is usually not safe to call from inside an interrupt
function any standard library function that calls DOS INT 21H. Similar
precautions apply to many BIOS functions. Functions that rely on INT 21H
calls include I/O functions and the %@AB@%_dos%@AE@% family of functions. Functions that
rely on the machine's BIOS include graphics functions and the %@AB@%_bios%@AE@% family
of functions. It is usually safe to use functions that do not rely on INT
21H or BIOS, such as string-handling functions. Before using a standard
library function in an interrupt function, be sure that you are familiar
with the action of the library function.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_chain_intr%@AE@%, %@AB@% _dos_getvect%@AE@%, %@AB@% _dos_keep%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_dos_write@%%@NL@%
%@2@%%@CR:C6A00790412 @%%@AB@%_dos_write%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00790413 @% %@CR:C6A00790414 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Writes a buffer to a file, using system call INT 0x40.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned _dos_write( int handle, void _far *buffer, unsigned count, 
%@AS@%  unsigned *numwrt );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            File to write to

%@AI@%buffer%@AE@%                            Buffer to write from

%@AI@%count%@AE@%                             Number of bytes to write

%@AI@%numwrt%@AE@%                            Number of bytes actually written

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_dos_write%@AE@% routine uses system call INT 0x40 to write data to the file
that %@AI@%handle%@AE@% references; %@AI@%count%@AE@% bytes of data from the buffer to which %@AI@%buffer%@AE@%
points are written to the file. The integer pointed to by %@AI@%numwrt %@AE@%will be the
number of bytes actually written, which may be less than the number
requested.%@AI@%  %@AE@%%@NL@%
%@NL@%
Do not use the DOS interface routines with the console, low-level, or stream
I/O routines.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the function returns 0. Otherwise, it returns the DOS error
code and sets %@AB@%errno%@AE@% to one of the following manifest constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Access denied (%@AI@%handle%@AE@% references a file 
                                  not open for write
                                  access)

%@AB@%EBADF%@AE@%                             Invalid file handle

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_dos_close%@AE@%, %@AB@% _dos_open%@AE@%, %@AB@% _dos_read%@AE@%, %@AB@%write%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DWRITE.C: This program uses DOS I/O functions to write to a file. */
%@AS@%  
%@AS@%  #include <fcntl.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char out_buffer[] = "Hello";
%@AS@%     int  fh;
%@AS@%     unsigned n_written;
%@AS@%  
%@AS@%     /* Open file with _dos_creat function */
%@AS@%     if( _dos_creat( "data", _A_NORMAL, &fh ) == 0 )
%@AS@%     {
%@AS@%        /* Write data with _dos_write function */
%@AS@%        _dos_write( fh, out_buffer, 5, &n_written );
%@AS@%        printf( "Number of characters written: %d\n", n_written );
%@AS@%  
%@AS@%        _dos_close( fh );
%@AS@%        printf( "Contents of file are:\n" );
%@AS@%        system( "type data" );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Number of characters written: 5
%@AS@%  Contents of file are:
%@AS@%  Hello %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:dosexterr@%%@NL@%
%@2@%%@CR:C6A00800415 @%%@AB@%dosexterr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00800416 @%%@CR:C6A00800417 @% %@CR:C6A00800418 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets register values returned by INT 0x59.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int dosexterr( struct DOSERROR *errorinfo );%@AE@%%@NL@%
%@NL@%
%@AI@%errorinfo%@AE@%                         Extended DOS error information

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%dosexterr%@AE@% function obtains the extended error information returned by
the DOS system call INT 0x59 and stores the values in the structure pointed
to by %@AI@%errorinfo%@AE@%. This function is useful when making system calls under DOS
versions 3.0 or later, which offer extended error handling. %@CR:C6A00800419 @%%@CR:C6A00800420 @%  %@NL@%
%@NL@%
The structure type %@AB@%DOSERROR %@AE@%is defined in DOS.H. The %@AB@%DOSERROR%@AE@% structure
contains the following elements:%@CR:C6A00800421 @%%@CR:C6A00800422 @%  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%int exterror%@AE@%                      AX register contents

%@AB@%char class%@AE@%                        BH register contents

%@AB@%char action%@AE@%                       BL register contents

%@AB@%char locus%@AE@%                        CH register contents

Giving a %@AB@%NULL%@AE@% pointer argument causes %@AB@%dosexterr%@AE@% to return the value in AX
without filling in the structure fields. See %@AI@%MS-DOS Encyclopedia %@AE@% (Duncan,
ed.; Redmond, WA: Microsoft Press, 1988) or %@AI@%Programmer's PC Sourcebook%@AE@%
(Hogan; Redmond, WA: Microsoft Press, 1988) for more information on the
register contents.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%dosexterr%@AE@% function returns the value in the AX register (identical to
the value in the %@AB@%exterror%@AE@% structure field).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
The %@AB@%dosexterr%@AE@% function should be used only under DOS versions 3.0 or later.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%perror%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DOSEXERR.C: This program tries to open the file test.dat. If the
%@AS@%   * attempted open operation fails, the program uses dosexterr to display
%@AS@%   * extended error information.
%@AS@%   */
%@AS@%  
%@AS@%  #include <dos.h>
%@AS@%  #include <io.h>
%@AS@%  #include <fcntl.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct DOSERROR doserror;
%@AS@%     int fd;
%@AS@%  
%@AS@%     /* Attempt to open a non-existent file */
%@AS@%     if( (fd = open( "NOSUCHF.ILE", O_RDONLY )) == -1 )
%@AS@%     {
%@AS@%        dosexterr( &doserror );
%@AS@%        printf( "Error: %d  Class: %d  Action: %d  Locus: %d\n",
%@AS@%                doserror.exterror, doserror.class,
%@AS@%                doserror.action,   doserror.locus );
%@AS@%     }
%@AS@%     else
%@AS@%     {
%@AS@%        printf( "Open succeeded so no extended information printed\n" );
%@AS@%        close( fd );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Error: 2  Class: 8  Action: 3  Locus: 2 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:dup@%%@QR:dup2@%%@NL@%
%@2@%%@CR:C6A00810423 @%%@AB@%dup, dup2%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00810424 @%%@CR:C6A00810425 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Create a second handle for an open file (%@AB@%dup%@AE@%), or reassign a file handle
(%@AB@%dup2%@AE@%).  %@NL@%
%@NL@%
%@AB@%#include <io.h%@AE@%                    Required only for function declarations

%@AS@%  int dup( int handle );%@AE@%%@NL@%
%@NL@%
%@AS@%  int dup2( int handle1, int handle2 );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%, %@AI@%handle1%@AE@%                   Handle referring to open file

%@AI@%handle2%@AE@%                           Any handle value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%dup%@AE@% and %@AB@%dup2%@AE@% functions cause a second file handle to be associated with
a currently open file. Operations on the file can be carried out using
either file handle. The type of access allowed for the file is unaffected by
the creation of a new handle.%@CR:C6A00810426 @%  %@NL@%
%@NL@%
The %@AB@%dup%@AE@% function returns the next available file handle for the given file.
The %@AB@%dup2%@AE@% function forces %@AI@%handle2%@AE@% to refer to the same file as %@AI@%handle1%@AE@%. If
%@AI@%handle2%@AE@% is associated with an open file at the time of the call, that file
is closed.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%dup%@AE@% function returns a new file handle. The %@AB@%dup2%@AE@% function returns 0 to
indicate success. Both functions return -1 if an error occurs and set %@AB@%errno%@AE@%
to one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EBADF%@AE@%                             Invalid file handle

%@AB@%EMFILE%@AE@%                            No more file handles available (too many
                                  open files)

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%close%@AE@%, %@AB@%creat%@AE@%, %@AB@%open%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DUP.C: This program uses the variable old to save the original stdout.
%@AS@%   * It then opens a new file named new and forces stdout to refer
%@AS@%   * to it. Finally, it restores stdout to its original state.
%@AS@%   */
%@AS@%  
%@AS@%  #include <io.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  void main()
%@AS@%  {
%@AS@%     int old;
%@AS@%     FILE *new;
%@AS@%  
%@AS@%     old = dup( 1 );   /* "old" now refers to "stdout" */
%@AS@%                       /* Note:  file handle 1 == "stdout" */
%@AS@%     if( old == -1 )
%@AS@%     {
%@AS@%        perror( "dup( 1 ) failure" );
%@AS@%        exit( 1 );
%@AS@%     }
%@AS@%     write( old, "This goes to stdout first\r\n", 27 );
%@AS@%     if( ( new = fopen( "data", "w" ) ) == NULL )
%@AS@%     {
%@AS@%        puts( "Can't open file 'data'\n" );
%@AS@%        exit( 1 );
%@AS@%     }
%@AS@%  
%@AS@%     /* stdout now refers to file "data" */
%@AS@%     if( -1 == dup2( fileno( new ), 1 ) )
%@AS@%     {
%@AS@%        perror( "Can't dup2 stdout" );
%@AS@%        exit( 1 );
%@AS@%     }
%@AS@%     puts( "This goes to file 'data'\r\n" );
%@AS@%  
%@AS@%     /* Flush stdout stream buffer so it goes to correct file */
%@AS@%     fflush( stdout );
%@AS@%     fclose( new );
%@AS@%  
%@AS@%     /* Restore original stdout */
%@AS@%     dup2( old, 1 );
%@AS@%     puts( "This goes to stdout\n" );
%@AS@%     puts( "The file 'data' contains:" );
%@AS@%     system( "type data" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  This goes to stdout first
%@AS@%  This goes to stdout
%@AS@%  
%@AS@%  The file 'data' contains:
%@AS@%  This goes to file 'data' %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ecvt@%%@NL@%
%@2@%%@CR:C6A00820427 @%%@AB@%ecvt%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Converts a %@AB@%double%@AE@% number to a string.  %@NL@%
%@NL@%
%@CR:C6A00820428 @%%@CR:C6A00820429 @%%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AS@%  char *ecvt( double value, int count, int *dec, int *sign );%@AE@%%@NL@%
%@NL@%
%@AI@%value%@AE@%                             Number to be converted

%@AI@%count%@AE@%                             Number of digits stored

%@AI@%dec%@AE@%                               Stored decimal-point position

%@AI@%sign%@AE@%                              Sign of converted number

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ecvt%@AE@% function converts a floating-point number to a character string.
The %@AI@%value%@AE@% argument is the floating-point number to be converted. The %@AB@%ecvt%@AE@%
function stores up to %@AI@%count%@AE@% digits of %@AI@%value%@AE@% as a string and appends a null
character (%@AB@%'\0'%@AE@%). If the number of digits in %@AI@%value%@AE@% exceeds %@AI@%count,%@AE@% the
low-order digit is rounded. If there are fewer than %@AI@%count%@AE@% digits, the string
is padded with zeros. %@CR:C6A00820430 @%%@CR:C6A00820431 @%  %@NL@%
%@NL@%
Only digits are stored in the string. The position of the decimal point and
the sign of %@AI@%value%@AE@% can be obtained from %@AI@%dec%@AE@% and %@AI@%sign%@AE@% after the call. The %@AI@%dec%@AE@%
argument points to an integer value giving the position of the decimal point
with respect to the beginning of the string. A 0 or negative integer value
indicates that the decimal point lies to the left of the first digit. The
%@AI@%sign%@AE@% argument points to an integer indicating the sign of the converted
number. If the integer value is 0, the number is positive. Otherwise, the
number is negative.  %@NL@%
%@NL@%
The %@AB@%ecvt%@AE@% and %@AB@%fcvt%@AE@% functions use a single statically allocated buffer for the
conversion. Each call to one of these routines destroys the result of the
previous call.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ecvt%@AE@% function returns a pointer to the string of digits. There is no
error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%atof%@AE@%, %@AB@%atoi%@AE@%, %@AB@%atol%@AE@%, %@AB@%fcvt%@AE@%, %@AB@%gcvt%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ECVT.C: This program uses ecvt to convert a floating-point
%@AS@%   * number to a character string.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int     decimal, sign;
%@AS@%     char    *buffer;
%@AS@%     int     precision = 10;
%@AS@%     double  source = 3.1415926535;
%@AS@%  
%@AS@%     buffer = ecvt( source, precision, &decimal, &sign );
%@AS@%     printf( "source: %2.10f   buffer: '%s'  decimal: %d   sign: %d\n",
%@AS@%             source, buffer, decimal, sign );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  source: 3.1415926535   buffer: '3141592654'  decimal: 1   sign: 0 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_ellipse@%%@NL@%
%@2@%%@CR:C6A00830432 @%%@AB@%_ellipse Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00830433 @% %@CR:C6A00830434 @% %@CR:C6A00830435 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Draw ellipses.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _ellipse( short control, short x1, short y1, short x2, short y2
%@AS@%  );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _ellipse_w( short control, double wx1, double wy1, double wx2, 
%@AS@%  double wy2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _ellipse_wxy( short control, struct _wxycoord _far *pwxy1, 
%@AS@%  struct _wxycoord _far *pwxy2 );%@AE@%%@NL@%
%@NL@%
%@AI@%control%@AE@%                           Fill flag

%@AI@%x1%@AE@%, %@AI@%y1%@AE@%                            Upper-left corner of bounding rectangle

%@AI@%x2%@AE@%, %@AI@%y2%@AE@%                            Lower-right corner of bounding rectangle

%@AI@%wx1%@AE@%, %@AI@%wy1%@AE@%                          Upper-left corner of bounding rectangle

%@AI@%wx2%@AE@%, %@AI@%wy2%@AE@%                          Lower-right corner of bounding rectangle

%@AI@%pwxy1%@AE@%                             Upper-left corner of bounding rectangle

%@AI@%pwxy2%@AE@%                             Lower-right corner of bounding rectangle

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_ellipse%@AE@% functions draw ellipses or circles. The borders are drawn in
the current color. In the %@AB@%_ellipse%@AE@% function, the center of the ellipse is
the center of the bounding rectangle defined by the view-coordinate points
(%@AI@%x1%@AE@%, %@AI@%y1%@AE@%) and (%@AI@%x2%@AE@%, %@AI@%y2%@AE@%).  %@NL@%
%@NL@%
In the %@AB@%_ellipse_w%@AE@% function, the center of the ellipse is the center of the
bounding rectangle defined by the window-coordinate points (%@AI@%wx1%@AE@%, %@AI@%wy1%@AE@%) and
(%@AI@%wx2%@AE@%, %@AI@%wy2%@AE@%).  %@NL@%
%@NL@%
In the %@AB@%_ellipse_wxy%@AE@% function, the center of the ellipse is the center of the
bounding rectangle defined by the window-coordinate pairs (%@AI@%pwxy1%@AE@%) and
(%@AI@%pwxy2%@AE@%).  %@NL@%
%@NL@%
If the bounding-rectangle arguments define a point or a vertical or
horizontal line, no figure is drawn.  %@NL@%
%@NL@%
The %@AI@%control%@AE@% argument can be one of the following manifest constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Action%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_GFILLINTERIOR%@AE@%                    Fills the ellipse using the current fill
                                  mask

%@AB@%_GBORDER%@AE@%                          Does not fill the ellipse

The control option given by %@AB@%_GFILLINTERIOR%@AE@% is equivalent to a subsequent
call to the %@AB@%_floodfill%@AE@% function, using the center of the ellipse as the
starting point and the current color (set by %@AB@%_setcolor%@AE@%) as the boundary
color.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_ellipse%@AE@% functions return a nonzero value if the ellipse is drawn
successfully; otherwise, they return 0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_arc%@AE@% functions,  %@AB@%_floodfill%@AE@%,  %@AB@%_grstatus%@AE@%,  %@AB@%_lineto%@AE@% functions,  %@AB@%_pie%@AE@%
functions, %@AB@%_polygon%@AE@% functions,  %@AB@%_rectangle%@AE@% functions,  %@AB@%_setcolor%@AE@%,%@AB@% %@AE@%
%@AB@%_setfillmask%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ELLIPSE.C: This program draws a simple ellipse. */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     _ellipse( _GFILLINTERIOR, 80, 50, 240, 150 );
%@AS@%  
%@AS@%     /* Strike any key to clear screen. */
%@AS@%     getch();
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_enable@%%@NL@%
%@2@%%@CR:C6A00840436 @%%@AB@%_enable%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Enables interrupts.  %@NL@%
%@NL@%
%@CR:C6A00840437 @%%@CR:C6A00840438 @%%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _enable( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_enable%@AE@% routine enables interrupts by executing an 8086 %@AB@%STI%@AE@% machine
instruction.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_disable%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_endthread@%%@NL@%
%@2@%%@CR:C6A00850439 @%%@AB@%_endthread%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Terminates an OS/2 thread.  %@NL@%
%@NL@%
%@CR:C6A00850440 @%%@CR:C6A00850441 @%%@AB@%#include <process.h>%@AE@%              Multithread version of PROCESS.H

%@AS@%  void _far _endthread( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_endthread%@AE@% function terminates a thread created by %@AB@%_beginthread%@AE@%.  %@NL@%
%@NL@%
Because threads terminate automatically, the%@AB@% _endthread%@AE@% function is normally
not required. It is used to terminate a thread conditionally.  %@NL@%
%@NL@%
The OS/2 function %@AB@%DosExit%@AE@% should not be used to terminate threads created by
the %@AB@%_beginthread%@AE@% function. If %@AB@%DosExit%@AE@% is used, the results are
unpredictable.%@CR:C6A00850442 @%%@CR:C6A00850443 @%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_beginthread%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_beginthread%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:eof@%%@NL@%
%@2@%%@CR:C6A00860444 @%%@AB@%eof%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Tests for end-of-file.  %@NL@%
%@NL@%
%@CR:C6A00860445 @%%@CR:C6A00860446 @%%@CR:C6A00860447 @%%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  int eof( int handle );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Handle referring to open file

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%eof%@AE@% function determines whether the end of the file associated with
%@AI@%handle%@AE@% has been reached.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%eof%@AE@% function returns the value 1 if the current position is end-of-file,
or 0 if it is not. A return value of -1 indicates an error; in this case,
%@AB@%errno%@AE@% is set to %@AB@%EBADF%@AE@%, indicating an invalid file handle.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%clearerr%@AE@%, %@AB@%feof%@AE@%, %@AB@%ferror%@AE@%, %@AB@%perror%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* EOF.C: This program reads data from a file ten bytes at a time
%@AS@%   * until the end of the file is reached or an error is encountered.
%@AS@%   */
%@AS@%  
%@AS@%  #include <io.h>
%@AS@%  #include <fcntl.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int  fh, count, total = 0;
%@AS@%     char buf[10];
%@AS@%  
%@AS@%     if( (fh = open( "eof.c", O_RDONLY )) == - 1 )
%@AS@%        exit( 1 );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Cycle until end of file reached: */
%@AS@%     while( !eof( fh ) )
%@AS@%     {
%@AS@%        /* Attempt to read in 10 bytes: */
%@AS@%        if( (count = read( fh, buf, 10 )) == -1 )
%@AS@%        {
%@AS@%           perror( "Read error" );
%@AS@%           break;
%@AS@%        }
%@AS@%  
%@AS@%        /* Total up actual bytes read */
%@AS@%        total += count;
%@AS@%     }
%@AS@%     printf( "Number of bytes read = %d\n", total );
%@AS@%     close( fh );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Number of bytes read = 715 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:exec@%%@NL@%
%@2@%%@CR:C6A00870448 @%%@AB@%exec Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Load and execute new child processes.  %@NL@%
%@NL@%
%@CR:C6A00870449 @%%@CR:C6A00870450 @%%@CR:C6A00870451 @%%@AB@%#include <process.h>%@AE@%              Required only for function declarations

%@AS@%  int execl( char *cmdname, char *arg0, ... char *argn, NULL );%@AE@%%@NL@%
%@NL@%
%@AS@%  int execle( char *cmdname, char *arg0, ... char *argn, NULL, 
%@AS@%  char **envp );%@AE@%%@NL@%
%@NL@%
%@AS@%  int execlp( char *cmdname, char *arg0, ... char *argn, NULL  );%@AE@%%@NL@%
%@NL@%
%@AS@%  int execlpe( char *cmdname, char *arg0, ... char *argn, NULL, 
%@AS@%  char **envp  );%@AE@%%@NL@%
%@NL@%
%@AS@%  int execv( char *cmdname, char **argv );%@AE@%%@NL@%
%@NL@%
%@AS@%  int execve( char *cmdname, char **argv, char **envp );%@AE@%%@NL@%
%@NL@%
%@AS@%  int execvp( char *cmdname, char **argv );%@AE@%%@NL@%
%@NL@%
%@AS@%  int execvpe( char *cmdname, char **argv, char **envp );%@AE@%%@NL@%
%@NL@%
%@AI@%cmdname%@AE@%                           Path name of file to be executed

%@AI@%arg0, ... argn%@AE@%                    List of pointers to arguments

%@AI@%argv%@AE@%                              Array of pointers to arguments

%@AI@%envp%@AE@%                              Array of pointers to environment 
                                  settings

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%exec%@AE@% functions load and execute new child processes. When the call is
successful in DOS, the child process is placed in the memory previously
occupied by the calling process. Under OS/2, calling an %@AB@%exec%@AE@% function is
equivalent to calling the corresponding function with the %@AB@%P_NOWAITO%@AE@% argument
specified, followed by a call to the %@AB@%exit%@AE@% function. Sufficient memory must
be available for loading and executing the child process.  %@NL@%
%@NL@%
All of the %@AB@%exec%@AE@% functions use the same operating system function. The
letter(s) at the end of the function name determine the specific variation,
as shown in the following list:  %@NL@%
%@NL@%
%@AB@%Letter%@AE@%                            %@AB@%Variation%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%e%@AE@%                                 An array of pointers to environment 
                                  arguments is explicitly passed to the 
                                  child process.

%@AB@%l%@AE@%                                 Command-line arguments are passed 
                                  individually to the %@AB@%exec%@AE@% function.

%@AB@%p%@AE@%                                 Uses the PATH environment variable to 
                                  find the file to be 
                                  executed.

%@AB@%v%@AE@%                                 Command-line arguments are passed to the
                                  %@AB@%exec%@AE@% function as an array of pointers.

The %@AI@%cmdname%@AE@% argument specifies the file to be executed as the child process.
It can specify a full path (from the root), a partial path (from the current
working directory), or just a file name. If %@AI@%cmdname%@AE@% does not have a
file-name extension or does not end with a period (.), the %@AB@%exec%@AE@% function
searches for the named file; if the search is unsuccessful, it tries the
same base name, first with the extension .COM, then with the extension .EXE.
If %@AI@%cmdname%@AE@% has an extension, only that extension is used in the search. If
%@AI@%cmdname%@AE@% ends with a period, the %@AB@%exec%@AE@% calls search for %@AI@%cmdname%@AE@% with no
extension. The %@AB@%execlp%@AE@%, %@AB@%execlpe%@AE@%, %@AB@%execvp%@AE@%, and %@AB@%execvpe%@AE@% routines search for
%@AI@%cmdname%@AE@% (using the same procedures) in the directories specified by the PATH
environment variable.  %@NL@%
%@NL@%
If %@AI@%cmdname%@AE@% contains a drive specifier or any slashes (i.e., if it is a
relative path name), the %@AB@%exec%@AE@% call searches only for the specified file and
no path searching is done.  %@NL@%
%@NL@%
Arguments are passed to the new process by giving one or more pointers to
character strings as arguments in the %@AB@%exec%@AE@% call. These character strings
form the argument list for the child process. The combined length of the
strings forming the argument list for the new process must not exceed 128
bytes (in real mode only). The terminating null character (%@AB@%'\0'%@AE@%) for each
string is not included in the count, but space characters (inserted
automatically to separate the arguments) are counted.  %@NL@%
%@NL@%
The argument pointers can be passed as separate arguments (%@AB@%execl%@AE@%, %@AB@%execle%@AE@%,
%@AB@%execlp%@AE@%, and %@AB@%execlpe%@AE@%) or as an array of pointers (%@AB@%execv%@AE@%, %@AB@%execve%@AE@%, %@AB@%execvp%@AE@%, and
%@AB@%execvpe%@AE@%). At least one argument, %@AI@%arg0%@AE@%, must be passed to the child process;
this argument is %@AI@%argv%@AE@%[0] of the child process. Usually, this argument is a
copy of the %@AI@%cmdname%@AE@% argument. (A different value will not produce an error.)
Under versions of DOS earlier than 3.0, the passed value of %@AI@%arg0%@AE@% is not
available for use in the child process. However, under OS/2 and under DOS
versions 3.0 and later, %@AI@%cmdname%@AE@% is available as %@AI@%arg0%@AE@%.  %@NL@%
%@NL@%
The %@AB@%execl%@AE@%, %@AB@%execle%@AE@%, %@AB@%execlp%@AE@%, and %@AB@%execlpe%@AE@% calls are typically used when the
number of arguments is known in advance. The argument %@AI@%arg0%@AE@% is usually a
pointer to %@AI@%cmdname%@AE@%. The arguments %@AI@%arg1%@AE@% through %@AI@%argn%@AE@% point to the character
strings forming the new argument list. A null pointer must follow %@AI@%argn%@AE@% to
mark the end of the argument list.  %@NL@%
%@NL@%
The %@AB@%execv%@AE@%, %@AB@%execve%@AE@%, %@AB@%execvp%@AE@%, and %@AB@%execvpe%@AE@% calls are useful when the number of
arguments to the new process is variable. Pointers to the arguments are
passed as an array, %@AI@%argv%@AE@%. The argument %@AI@%argv%@AE@%[0] is usually a pointer to
%@AI@%cmdname%@AE@%. The arguments %@AI@%argv%@AE@%[1] through %@AI@%argv%@AE@%[%@AI@%n%@AE@%] point to the character
strings forming the new argument list. The argument %@AI@%argv%@AE@%[%@AI@%n%@AE@%+1] must be a %@AB@%NULL
%@AB@%%@AE@%pointer to mark the end of the argument list.  %@NL@%
%@NL@%
Files that are open when an %@AB@%exec%@AE@% call is made remain open in the new
process. In the %@AB@%execl%@AE@%, %@AB@%execlp%@AE@%, %@AB@%execv%@AE@%, and %@AB@%execvp%@AE@% calls, the child process
inherits the environment of the parent. The %@AB@%execle%@AE@%, %@AB@%execlpe%@AE@%, %@AB@%execve%@AE@%, and
%@AB@%execvpe%@AE@% calls allow the user to alter the environment for the child process
by passing a list of environment settings through the %@AI@%envp%@AE@% argument. The
argument %@AI@%envp%@AE@% is an array of character pointers, each element of which
(except for the final element) points to a null-terminated string defining
an environment variable. Such a string usually has the form  %@NL@%
%@NL@%
%@AB@%NAME%@AE@%=%@AI@%value%@AE@%  %@NL@%
%@NL@%
where %@AB@%NAME%@AE@% is the name of an environment variable and %@AI@%value%@AE@% is the string
value to which that variable is set. (Note that %@AI@%value%@AE@% is not enclosed in
double quotation marks.) The final element of the %@AI@%envp%@AE@% array should be %@AB@%NULL%@AE@%.
When %@AI@%envp%@AE@% itself is %@AB@%NULL%@AE@%, the child process inherits the environment
settings of the parent process.  %@NL@%
%@NL@%
A program executed with one of the %@AB@%exec%@AE@% family of functions is always loaded
into memory as if the "maximum allocation" field in the program's .EXE file
header is set to the default value of 0FFFFH. You can use the EXEMOD utility
to change the maximum allocation field of a program; however, such a program
invoked with one of the %@AB@%exec%@AE@% functions may behave differently from a program
invoked directly from the operating-system command line or with one of the
%@AB@%spawn%@AE@% functions.  %@NL@%
%@NL@%
The %@AB@%exec%@AE@% calls do not preserve the translation modes of open files. If the
child process must use files inherited from the parent, the %@AB@%setmode%@AE@% routine
should be used to set the translation mode of these files to the desired
mode.  %@NL@%
%@NL@%
You must explicitly flush (using %@AB@%fflush%@AE@% or %@AB@%flushall%@AE@%) or close any stream
prior to the %@AB@%exec%@AE@% function call.  %@NL@%
%@NL@%
Signal settings are not preserved in child processes that are created by
calls to %@AB@%exec%@AE@% routines. The signal settings are reset to the default in the
child process.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%exec%@AE@% functions do not normally return to the calling process. If an %@AB@%exec%@AE@%
function returns, an error has occurred and the return value is -1. The
%@AB@%errno%@AE@% variable is set to one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%E2BIG%@AE@%                             The argument list exceeds 128 bytes, or 
                                  the space required for the environment 
                                  information exceeds 32K.

%@AB@%EACCES%@AE@%                            The specified file has a locking or 
                                  sharing violation
                                  (OS/2, and DOS versions 3.0 or later).

%@AB@%EMFILE%@AE@%                            Too many files open (the specified file 
                                  must be opened to determine whether it 
                                  is executable).

%@AB@%ENOENT%@AE@%                            File or path name not found.

%@AB@%ENOEXEC%@AE@%                           The specified file is not executable or 
                                  has an invalid
                                  executable-file format.

%@AB@%ENOMEM%@AE@%                            Not enough memory is available to 
                                  execute the child process; or the 
                                  available memory has been corrupted; or 
                                  an invalid block exists, indicating that
                                  the parent process was not allocated 
                                  properly.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
Because of differences in DOS versions 2.0 and 2.1, child processes
generated by the %@AB@%exec%@AE@% family of functions (or by the equivalent %@AB@%spawn%@AE@%
functions with the %@AB@%P_OVERLAY%@AE@% argument) may cause fatal system errors when
they exit. If you are running DOS 2.0 or 2.1, you must upgrade to DOS
version 3.0 or later to use these functions.  %@NL@%
%@NL@%
Bound programs cannot use the %@AB@%exec%@AE@% family of functions in real mode.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%abort%@AE@%, %@AB@%atexit%@AE@%, %@AB@%exit%@AE@%, %@AB@%_exit%@AE@%, %@AB@%onexit%@AE@%, %@AB@%spawn%@AE@% functions, %@AB@%system%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* EXEC.C: This program accepts a number in the range 1 through 8 from the
%@AS@%   * command line. Based on the number it receives, it executes one of the
%@AS@%   * eight different procedures that spawn the process named child. For
%@AS@%   * some of these procedures, the child.exe file must be in the same
%@AS@%   * directory; for others, it need only be in the same path.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <process.h>
%@AS@%  
%@AS@%  char *my_env[] = {
%@AS@%                "THIS=environment will be",
%@AS@%                "PASSED=to child.exe by the",
%@AS@%                "EXECLE=and",
%@AS@%                "EXECLPE=and",
%@AS@%                "EXECVE=and",
%@AS@%                "EXECVPE=functions",
%@AS@%                NULL
%@AS@%                };
%@AS@%  
%@AS@%  void main( int argc, char *argv[] )
%@AS@%  {
%@AS@%     char *args[4];
%@AS@%     int result;
%@AS@%  
%@AS@%     args[0] = "child";     /* Set up parameters to send */
%@AS@%     args[1] = "execv??";
%@AS@%     args[2] = "two";
%@AS@%     args[3] = NULL;%@AE@%%@NL@%
%@NL@%
%@AS@%  switch( argv[1][0] )   /* Based on first letter of argument */
%@AS@%     {
%@AS@%        case '1':
%@AS@%           execl( argv[2], argv[2], "execl", "two", NULL );
%@AS@%           break;
%@AS@%        case '2':
%@AS@%           execle( argv[2], argv[2], "execle", "two", NULL, my_env );
%@AS@%           break;
%@AS@%        case '3':
%@AS@%           execlp( argv[2], argv[2], "execlp", "two", NULL );
%@AS@%           break;
%@AS@%        case '4':
%@AS@%           execlpe( argv[2], argv[2], "execlpe", "two", NULL, my_env );
%@AS@%           break;
%@AS@%        case '5':
%@AS@%           execv( argv[2], args );
%@AS@%           break;
%@AS@%        case '6':
%@AS@%           execve( argv[2], args, my_env );
%@AS@%           break;
%@AS@%        case '7':
%@AS@%           execvp( argv[2], args );
%@AS@%           break;
%@AS@%        case '8':
%@AS@%           execvpe( argv[2], args, my_env );
%@AS@%           break;
%@AS@%        default:
%@AS@%           printf( "SYNTAX: EXEC <1-8> <childprogram>\n" );
%@AS@%           exit( 1 );
%@AS@%     }
%@AS@%     printf( "Process was not spawned.\n" );
%@AS@%     printf( "Program 'child' was not found." );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:exit@%%@QR:_exit@%%@NL@%
%@2@%%@CR:C6A00880452 @%%@AB@%exit, _exit%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Terminate the calling process after cleanup (%@AB@%exit%@AE@%) or immediately (%@AB@% _exit%@AE@%).
%@NL@%
%@NL@%
%@CR:C6A00880453 @%%@CR:C6A00880454 @%%@AB@%#include <process.h>%@AE@%              Required only for function declarations

%@AB@%#include <stdlib.h>%@AE@%               Use either PROCESS.H or STDLIB.H

%@AS@%  void exit( int status );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _exit( int status );%@AE@%%@NL@%
%@NL@%
%@AI@%status%@AE@%                            Exit status

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%exit%@AE@% and %@AB@%_exit%@AE@% functions terminate the calling process. The %@AB@%exit%@AE@%
function first calls, in LIFO (last-in-first-out) order, the functions
registered by %@AB@%atexit%@AE@% and %@AB@%onexit%@AE@%, then flushes all file buffers before
terminating the process. The %@AB@%_exit%@AE@% function terminates the process without
processing %@AB@%atexit%@AE@% or %@AB@%onexit%@AE@% functions or flushing stream buffers. The %@AI@%status%@AE@%
value is typically set to 0 to indicate a normal exit and set to some other
value to indicate an error.%@CR:C6A00880455 @%  %@NL@%
%@NL@%
Although the %@AB@%exit%@AE@% and %@AB@%_exit%@AE@% calls do not return a value, the low-order byte
of %@AI@%status%@AE@% is made available to the waiting parent process, if one exists,
after the calling process exits. The %@AI@%status%@AE@% value is available to the
operating-system batch command ERRORLEVEL.  %@NL@%
%@NL@%
The behavior of the %@AB@%exit%@AE@%, %@AB@%_exit%@AE@%, %@AB@%_cexit%@AE@%, and %@AB@%_c_exit%@AE@% functions is as
follows:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Action%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%exit%@AE@%                              Performs complete C library termination 
                                  procedures, terminates the process, and 
                                  exits with the supplied status code.

%@AB@%_exit%@AE@%                             Performs "quick" C library termination 
                                  procedures, terminates the process, and 
                                  exits with the supplied status code.

%@AB@%_cexit%@AE@%                            Performs complete C library termination 
                                  procedures and returns to caller, but 
                                  does not terminate the process.

%@AB@%_c_exit%@AE@%                           Performs "quick" C library termination 
                                  procedures and returns to caller, but 
                                  does not terminate the process.

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%exit%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_exit%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%abort%@AE@%, %@AB@%atexit%@AE@%, %@AB@%_cexit%@AE@%, %@AB@%exec%@AE@% functions, %@AB@%onexit%@AE@%, %@AB@%spawn%@AE@% functions, %@AB@%system%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* EXITER.C: This program prompts the user for a yes or no and returns
%@AS@%   * a DOS error code of 1 if the user answers Y or y; otherwise it
%@AS@%   * returns 0. The error code could be tested in a batch file.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char  ch;
%@AS@%  
%@AS@%     cputs( "Yes or no? " );
%@AS@%     ch = getch();
%@AS@%     cputs( "\r\n" );
%@AS@%     if( toupper( ch ) == 'Y' )
%@AS@%        exit( 1 );
%@AS@%     else
%@AS@%        exit( 0 );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:exp@%%@QR:expl@%%@NL@%
%@2@%%@CR:C6A00890456 @%%@AB@%exp, expl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00890457 @%%@CR:C6A00890458 @%%@CR:C6A00890459 @% %@CR:C6A00890460 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate the exponential.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double exp( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double expl( long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Floating-point value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%exp%@AE@% and %@AB@%expl%@AE@% functions return the exponential function of their
floating-point arguments (%@AI@%x%@AE@%).  %@NL@%
%@NL@%
The %@AB@%expl%@AE@% function is the 80-bit counterpart; it uses an 80-bit, 10-byte
coprocessor form of arguments and return values. See the reference page on
the long double functions for more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return ex%@AI@%.%@AE@% The functions return %@AB@%HUGE_VAL%@AE@% on overflow and set
%@AB@%errno%@AE@% to %@AB@%ERANGE%@AE@%; on underflow, they return 0 but do not set %@AB@%errno%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%exp%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%expl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%log%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* EXP.C */
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     double x = 2.302585093, y;
%@AS@%  
%@AS@%     y = exp( x );
%@AS@%     printf( "exp( %f ) = %f\n", x, y );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  exp( 2.302585 ) = 10.000000%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_expand@%%@NL@%
%@2@%%@CR:C6A00900461 @%%@AB@%_expand Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00900462 @%%@CR:C6A00900463 @% %@CR:C6A00900464 @%%@CR:C6A00900465 @%%@CR:C6A00900466 @%%@CR:C6A00900467 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Changes the size of a memory block.  %@NL@%
%@NL@%
%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  void *_expand( void *memblock, size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _based( void ) *_bexpand( _segment seg, void _based( void )
%@AS@%  *memblock, 
%@AS@%  size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far *_fexpand( void _far *memblock, size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _near *_nexpand( void _near *memblock, size_t size );%@AE@%%@NL@%
%@NL@%
%@AI@%memblock%@AE@%                          Pointer to previously allocated memory 
                                  block

%@AI@%size%@AE@%                              New size in bytes

%@AI@%seg%@AE@%                               Value of base segment

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_expand%@AE@% family of functions changes the size of a previously allocated
memory block by attempting to expand or contract the block without moving
its location in the heap. The %@AI@%memblock%@AE@% argument points to the beginning of
the block. The %@AI@%size%@AE@% argument gives the new size of the block, in bytes. The
contents of the block are unchanged up to the shorter of the new and old
sizes.  %@NL@%
%@NL@%
The %@AI@%memblock%@AE@% argument can also point to a block that has been freed, as long
as there has been no intervening call to %@AB@%calloc%@AE@%, %@AB@%_expand%@AE@%, %@AB@%malloc%@AE@%, or
%@AB@%realloc%@AE@%. If %@AI@%memblock%@AE@% points to a freed block, the block remains free after a
call to one of the %@AB@%_expand%@AE@% functions.  %@NL@%
%@NL@%
The %@AI@%seg%@AE@% argument is the segment address of the %@AB@%_based%@AE@% heap.  %@NL@%
%@NL@%
In large data models (compact-, large-, and huge-model programs), %@AB@%_expand%@AE@%
maps to %@AB@%_fexpand%@AE@%. In small data models ( tiny-, small-, and medium-model
programs), %@AB@%expand%@AE@% maps to %@AB@%_nexpand%@AE@%.  %@NL@%
%@NL@%
The various %@AB@%_expand%@AE@% functions change the size of the storage block in the
data segments shown in the list below:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Data Segment%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_expand%@AE@%                           Depends on data model of program

%@AB@%_bexpand%@AE@%                          Based heap specified by %@AI@%seg%@AE@%, or in all 
                                  based heaps if %@AI@%seg%@AE@%
                                  is zero

%@AB@%_fexpand%@AE@%                          Far heap (outside default data segment)

%@AB@%_nexpand%@AE@%                          Near heap (inside default data segment)

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_expand%@AE@% family of functions returns a %@AB@%void%@AE@% pointer to the reallocated
memory block. Unlike %@AB@%realloc%@AE@%, %@AB@%_expand%@AE@% cannot move a block to change its
size. This means the %@AI@%memblock%@AE@% argument to %@AB@%_expand%@AE@% is the same as the return
value if there is sufficient memory available to expand the block without
moving it.  %@NL@%
%@NL@%
With the exception of the %@AB@%_bexpand%@AE@% function, these functions return %@AB@%NULL%@AE@% if
there is insufficient memory available to expand the block to the given size
without moving it. The %@AB@%_bexpand%@AE@% function returns %@AB@%_NULLOFF%@AE@% if insufficient
memory is available. The item pointed to by %@AI@%memblock%@AE@% will have been expanded
as much as possible in its current location.  %@NL@%
%@NL@%
The storage space pointed to by the return value is guaranteed to be
suitably aligned for storage of any type of object. The new size of the item
can be checked with the %@AB@%_msize%@AE@% function. To get a pointer to a type other
than %@AB@%void%@AE@%, use a type cast on the return value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%calloc%@AE@% functions, %@AB@%free%@AE@% functions, %@AB@%malloc%@AE@% functions, %@AB@%_msize%@AE@% functions,
%@AB@%realloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* EXPAND.C */
%@AS@%  #include <stdio.h>
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *bufchar;
%@AS@%  
%@AS@%     printf( "Allocate a 512 element buffer\n" );
%@AS@%     if( (bufchar = (char *)calloc( 512, sizeof( char ) )) == NULL )
%@AS@%        exit( 1 );
%@AS@%     printf( "Allocated %d bytes at %Fp\n",
%@AS@%           _msize( bufchar ), (void _far *)bufchar );
%@AS@%  
%@AS@%     if( (bufchar = (char *)_expand( bufchar, 1024 )) == NULL )
%@AS@%        printf( "Can't expand" );
%@AS@%     else
%@AS@%        printf( "Expanded block to %d bytes at %Fp\n",
%@AS@%              _msize( bufchar ), (void _far *)bufchar );
%@AS@%  
%@AS@%     /* Free memory */
%@AS@%     free( bufchar );
%@AS@%     exit( 0 );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Allocate a 512 element buffer
%@AS@%  Allocated 512 bytes at 0067:142A
%@AS@%  Expanded block to 1024 bytes at 0067:142A%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fabs@%%@QR:fabsl@%%@NL@%
%@2@%%@CR:C6A00910468 @%%@AB@%fabs, fabsl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00910469 @%%@CR:C6A00910470 @%%@CR:C6A00910471 @% %@CR:C6A00910472 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate the absolute value of their floating-point arguments.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double fabs( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double fabsl( long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Floating-point value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fabs%@AE@% and %@AB@%fabsl%@AE@% functions calculate the absolute value of their
floating-point arguments.  %@NL@%
%@NL@%
The %@AB@%fabsl%@AE@% function is the 80-bit counterpart; it uses an 80-bit, 10-byte
coprocessor form of arguments and return values. See the reference page on
the long double functions for more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return the absolute value of their arguments. There is no
error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fabs%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%fabsl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%abs%@AE@%, %@AB@%cabs%@AE@%, %@AB@%labs%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ABS.C: This program computes and displays the absolute values of
%@AS@%   * several numbers.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <math.h>
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     int    ix = -4, iy;
%@AS@%     long   lx = -41567L, ly;
%@AS@%     double dx = -3.141593, dy;
%@AS@%  
%@AS@%     iy = abs( ix );
%@AS@%     printf( "The absolute value of %d is %d\n", ix, iy);
%@AS@%  
%@AS@%     ly = labs( lx );
%@AS@%     printf( "The absolute value of %ld is %ld\n", lx, ly);
%@AS@%  
%@AS@%     dy = fabs( dx );
%@AS@%     printf( "The absolute value of %f is %f\n", dx, dy );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The absolute value of -4 is 4
%@AS@%  The absolute value of -41567 is 41567
%@AS@%  The absolute value of -3.141593 is 3.141593%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fclose@%%@QR:fcloseall@%%@NL@%
%@2@%%@CR:C6A00920473 @%%@AB@%fclose, fcloseall%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00920474 @%%@CR:C6A00920475 @% %@CR:C6A00920476 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Closes a stream (%@AB@%fclose%@AE@%) or closes all open streams (%@AB@%fcloseall%@AE@%).  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fclose( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AS@%  int fcloseall( void );%@AE@%%@NL@%
%@NL@%
%@AI@%stream %@AE@%                           Pointer to %@AB@%FILE%@AE@% structure

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fclose%@AE@% function closes %@AI@%stream%@AE@%. The %@AB@%fcloseall%@AE@% function closes all open
streams except %@AB@%stdin%@AE@%, %@AB@%stdout%@AE@%, %@AB@%stderr%@AE@% (and in DOS,%@AB@% stdaux%@AE@% and%@AB@% stdprn%@AE@%). It
also closes and deletes any temporary files created by %@AB@%tmpfile%@AE@%.  %@NL@%
%@NL@%
In both functions, all buffers associated with the stream are flushed prior
to closing. System-allocated buffers are released when the stream is closed.
Buffers assigned by the user with %@AB@%setbuf%@AE@% and %@AB@%setvbuf%@AE@% are not automatically
released.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fclose%@AE@% function returns 0 if the stream is successfully closed. The
%@AB@%fcloseall%@AE@% function returns the total number of streams closed. Both
functions return %@AB@%EOF%@AE@% to indicate an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fclose%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%fcloseall  %@AE@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%close%@AE@%, %@AB@%fdopen%@AE@%, %@AB@%fflush%@AE@%, %@AB@%fopen%@AE@%, %@AB@%freopen%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FOPEN.C: This program opens files named "data" and "data2". It uses
%@AS@%   * fclose to close "data" and fcloseall to close all remaining files.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  FILE *stream, *stream2;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int numclosed;
%@AS@%  
%@AS@%     /* Open for read (will fail if 'data does not exist) */
%@AS@%     if( (stream  = fopen( "data", "r" )) == NULL )
%@AS@%        printf( "The file 'data' was not opened\n" );
%@AS@%     else
%@AS@%        printf( "The file 'data' was opened\n" );
%@AS@%  
%@AS@%     /* Open for write */
%@AS@%     if( (stream2 = fopen( "data2", "w+" )) == NULL )
%@AS@%        printf( "The file 'data2' was not opened\n" );
%@AS@%     else
%@AS@%        printf( "The file 'data2' was opened\n" );
%@AS@%  
%@AS@%     /* Close stream */
%@AS@%     if( fclose( stream ) )
%@AS@%        printf( "The file 'data' was not closed\n" );
%@AS@%  
%@AS@%     /* All other files are closed: */
%@AS@%     numclosed = fcloseall( );
%@AS@%     printf( "Number of files closed by fcloseall: %u\n", numclosed );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The file 'data' was opened
%@AS@%  The file 'data2' was opened
%@AS@%  Number of files closed by fcloseall: 1%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fcvt@%%@NL@%
%@2@%%@CR:C6A00930477 @%%@AB@%fcvt%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00930478 @%%@CR:C6A00930479 @% %@CR:C6A00930480 @% %@CR:C6A00930481 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Converts a floating-point number to a string.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AS@%  char *fcvt( double value, int count, int *dec, int *sign );%@AE@%%@NL@%
%@NL@%
%@AI@%value%@AE@%                             Number to be converted

%@AI@%count%@AE@%                             Number of digits after decimal point

%@AI@%dec%@AE@%                               Pointer to stored decimal-point position

%@AI@%sign%@AE@%                              Pointer to stored sign indicator

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fcvt%@AE@% function converts a floating-point number to a null-terminated
character string. The %@AI@%value%@AE@% argument is the floating-point number to be
converted. The %@AB@%fcvt%@AE@% function stores the digits of %@AI@%value%@AE@% as a string and
appends a null character (%@AB@%'\0'%@AE@%). The %@AI@%count%@AE@% argument specifies the number of
digits to be stored after the decimal point. Excess digits are rounded off
to %@AI@%count%@AE@% places. If there are fewer than %@AI@%count%@AE@% digits of precision, the
string is padded with zeros.  %@NL@%
%@NL@%
Only digits are stored in the string. The position of the decimal point and
the sign of %@AI@%value%@AE@% can be obtained from %@AI@%dec%@AE@% and %@AI@%sign %@AE@%after the call. The %@AI@%dec
%@AI@%%@AE@%argument points to an integer value; this integer value gives the position
of the decimal point with respect to the beginning of the string. A zero or
negative integer value indicates that the decimal point lies to the left of
the first digit. The argument %@AI@%sign%@AE@% points to an integer indicating the sign
of %@AI@%value%@AE@%. The integer is set to 0 if %@AI@%value%@AE@% is positive and is set to a
nonzero number if %@AI@%value%@AE@% is negative.  %@NL@%
%@NL@%
The %@AB@%ecvt %@AE@%and %@AB@%fcvt %@AE@%functions use a single statically allocated buffer for the
conversion. Each call to one of these routines destroys the results of the
previous call.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fcvt%@AE@% function returns a pointer to the string of digits. There is no
error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%atof%@AE@%, %@AB@%atoi%@AE@%, %@AB@%atol%@AE@%, %@AB@%ecvt%@AE@%, %@AB@%gcvt%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FCVT.C: This program converts the constant 3.1415926535 to a string and
%@AS@%   * sets the pointer *buffer to point to that string.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int  decimal, sign;
%@AS@%     char *buffer;
%@AS@%     double source = 3.1415926535;
%@AS@%  
%@AS@%     buffer = fcvt( source, 7, &decimal, &sign );
%@AS@%     printf( "source: %2.10f   buffer: '%s'   decimal: %d   sign: %d\n",
%@AS@%             source, buffer, decimal, sign );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  source: 3.1415926535   buffer: '31415927'   decimal: 1   sign: 0%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fdopen@%%@NL@%
%@2@%%@CR:C6A00940482 @%%@AB@%fdopen%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00940483 @%%@CR:C6A00940484 @%%@CR:C6A00940485 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Opens a stream using a handle.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  FILE *fdopen( int handle, char *mode );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Handle referring to open file

%@AI@%mode%@AE@%                              Type of access permitted

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fdopen%@AE@% function associates an input/output stream with the file
identified by %@AI@%handle%@AE@%, thus allowing a file opened for "low-level" I/O to be
buffered and formatted. (See Section 2.7, "Input and Output," for an
explanation of stream I/O and low-level I/O.) The %@AI@%mode%@AE@% character string
specifies the type of access requested for the file, as shown below. The
following list gives the %@AI@%mode %@AE@%string used in the %@AB@%fopen%@AE@% and %@AB@%fdopen%@AE@% functions
and the corresponding %@AI@%oflag%@AE@% arguments used in the %@AB@%open%@AE@% and %@AB@%sopen%@AE@% functions.
A complete description of the %@AI@%mode%@AE@% string argument is given in the remarks
section of the %@AB@%fopen%@AE@% function. %@CR:C6A00940486 @%  %@NL@%
%@NL@%
%@AB@%Type String%@AE@%                       %@AB@%Equivalent Value for open/sopen%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%"r"%@AE@%                               %@AB@%O_RDONLY%@AE@%

%@AB@%"w"%@AE@%                               %@AB@%O_WRONLY%@AE@% (usually %@AB@%O_WRONLY | O_CREAT | %@AE@%
                                  %@AB@%O_TRUNC%@AE@%)

%@AB@%"a"%@AE@%                               %@AB@%O_WRONLY | O_APPEND%@AE@% (usually %@AB@%O_WRONLY | %@AE@%
                                  %@AB@%O_CREAT | O_APPEND%@AE@%)

%@AB@%"r+"%@AE@%                              %@AB@%O_RDWR%@AE@%

%@AB@%"w+"%@AE@%                              %@AB@%O_RDWR%@AE@% (usually %@AB@%O_RDWR | O_CREAT | %@AE@%
                                  %@AB@%O_TRUNC%@AE@%)

%@AB@%"a+"%@AE@%                              %@AB@%O_RDWR | O_APPEND%@AE@% (usually %@AB@%O_RDWR | %@AE@%
                                  %@AB@%O_APPEND | O_CREAT %@AE@%)

In addition to the values listed above, one of the following characters can
be included in the %@AI@%mode%@AE@% string to specify the translation mode for newlines.
These characters correspond to the constants used in the %@AB@%open%@AE@% and %@AB@%sopen%@AE@%
functions, as shown below: %@CR:C6A00940487 @%%@CR:C6A00940488 @%   %@NL@%
%@NL@%
%@AB@%Mode%@AE@%                              %@AB@%Equivalent Value for open/sopen%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%t%@AE@%                                 %@AB@%O_TEXT%@AE@%

%@AB@%b%@AE@%                                 %@AB@%O_BINARY%@AE@%

If %@AB@%t%@AE@% or %@AB@%b%@AE@% is not given in the %@AI@%mode%@AE@% string, the translation mode is defined
by the default-mode variable %@AB@%_fmode%@AE@%.  %@NL@%
%@NL@%
The %@AB@%t%@AE@% option is not part of the ANSI standard for %@AB@%fopen%@AE@% and %@AB@%fpopen%@AE@%, but is
instead a Microsoft extension and should not be used where ANSI portability
is desired.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fdopen%@AE@% function returns a pointer to the open stream. A null pointer
value indicates an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%dup%@AE@%, %@AB@%dup2%@AE@%, %@AB@%fclose%@AE@%, %@AB@%fcloseall%@AE@%, %@AB@%fopen%@AE@%, %@AB@%freopen%@AE@%, %@AB@%open%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FDOPEN.C: This program opens a file using low-level I/O, then uses
%@AS@%   * fdopen to switch to stream access. It counts the lines in the file.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <fcntl.h>
%@AS@%  #include <io.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE *stream;
%@AS@%     int  fh, count = 0;
%@AS@%     char inbuf[128];
%@AS@%  
%@AS@%     /* Open a file handle. */
%@AS@%     if( (fh = open( "fdopen.c", O_RDONLY )) == -1 )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     /* Change handle access to stream access. */
%@AS@%     if( (stream = fdopen( fh, "r" )) == NULL )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     while( fgets( inbuf, 128, stream ) != NULL )
%@AS@%        count++;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* After fdopen, close with fclose, not close. */
%@AS@%     fclose( stream );
%@AS@%  
%@AS@%     printf( "Lines in file: %d\n", count );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Lines in file: 31%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:feof@%%@NL@%
%@2@%%@CR:C6A00950489 @%%@AB@%feof%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00950490 @%%@CR:C6A00950491 @% %@CR:C6A00950492 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Tests for end-of-file on a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int feof( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to%@AB@% FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%feof%@AE@% routine (implemented as a macro) determines whether the end of
%@AI@%stream%@AE@% has been reached. Once the end of the file is reached, read
operations return an end-of-file indicator until the stream is closed or
until %@AB@%rewind%@AE@%, %@AB@%fsetpos%@AE@%, %@AB@%fseek%@AE@%, or %@AB@%clearerr%@AE@% is called against it.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%feof%@AE@% function returns a nonzero value after the first read operation
that attempts to read past the end of the file. It returns 0 if the current
position is not end-of-file. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%clearerr%@AE@%, %@AB@%eof%@AE@%, %@AB@%ferror%@AE@%, %@AB@%perror%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FEOF.C: This program uses feof to indicate when it reaches the end
%@AS@%   * of the file FEOF.C. It also checks for errors with ferror.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int  count, total = 0;
%@AS@%     char buffer[100];
%@AS@%     FILE *stream;
%@AS@%  
%@AS@%     if( (stream = fopen( "feof.c", "r" )) == NULL )
%@AS@%        exit( 1 );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Cycle until end of file reached: */
%@AS@%     while( !feof( stream ) )
%@AS@%     {
%@AS@%        /* Attempt to read in 10 bytes: */
%@AS@%        count = fread( buffer, sizeof( char ), 100, stream );
%@AS@%        if( ferror( stream ) )
%@AS@%        {
%@AS@%           perror( "Read error" );
%@AS@%           break;
%@AS@%        }
%@AS@%  
%@AS@%        /* Total up actual bytes read */
%@AS@%        total += count;
%@AS@%     }
%@AS@%     printf( "Number of bytes read = %d\n", total );
%@AS@%     fclose( stream );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Number of bytes read = 697%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ferror@%%@NL@%
%@2@%%@CR:C6A00960493 @%%@AB@%ferror%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00960494 @%%@CR:C6A00960495 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Tests for an error on a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int ferror( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to%@AB@% FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ferror%@AE@% routine (implemented as a macro) tests for a reading or writing
error on the file associated with %@AI@%stream%@AE@%. If an error has occurred, the
error indicator for the stream remains set until the stream is closed or
rewound, or until %@AB@%clearerr%@AE@% is called against it. %@CR:C6A00960496 @%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If no error has occurred on %@AI@%stream%@AE@%, %@AB@%ferror%@AE@% returns 0. Otherwise, it returns
a nonzero value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%clearerr%@AE@%, %@AB@%eof%@AE@%, %@AB@%feof%@AE@%, %@AB@%fopen%@AE@%, %@AB@%perror%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FEOF.C: This program uses feof to indicate when it reaches the end
%@AS@%   * of the file FEOF.C. It also checks for errors with ferror.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int  count, total = 0;
%@AS@%     char buffer[100];
%@AS@%     FILE *stream;
%@AS@%  
%@AS@%     if( (stream = fopen( "feof.c", "r" )) == NULL )
%@AS@%        exit( 1 );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Cycle until end of file reached: */
%@AS@%     while( !feof( stream ) )
%@AS@%     {
%@AS@%        /* Attempt to read in 10 bytes: */
%@AS@%        count = fread( buffer, sizeof( char ), 100, stream );
%@AS@%        if( ferror( stream ) )
%@AS@%        {
%@AS@%           perror( "Read error" );
%@AS@%           break;
%@AS@%        }
%@AS@%  
%@AS@%        /* Total up actual bytes read */
%@AS@%        total += count;
%@AS@%     }
%@AS@%     printf( "Number of bytes read = %d\n", total );
%@AS@%     fclose( stream );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Number of bytes read = 697%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fflush@%%@NL@%
%@2@%%@CR:C6A00970497 @%%@AB@%fflush%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00970498 @%%@CR:C6A00970499 @%%@CR:C6A00970500 @% %@CR:C6A00970501 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Flushes a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fflush( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to%@AB@% FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
If the file associated with %@AI@%stream%@AE@% is open for output, %@AB@%fflush%@AE@% writes to that
file the contents of the buffer associated with the stream. If the stream is
open for input, %@AB@%fflush%@AE@% clears the contents of the buffer. The %@AB@%fflush%@AE@%
function negates the effect of any prior call to %@AB@%ungetc%@AE@% against %@AI@%stream%@AE@%.  %@NL@%
%@NL@%
Buffers are automatically flushed when they are full, when the stream is
closed, or when a program terminates normally without closing the stream.  %@NL@%
%@NL@%
The stream remains open after the call. The %@AB@%fflush%@AE@% function has no effect on
an unbuffered stream.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fflush%@AE@% function returns the value 0 if the buffer was successfully
flushed. The value 0 is also returned in cases in which the specified stream
has no buffer or is open for reading only. A return value of %@AB@%EOF%@AE@% indicates
an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fclose%@AE@%, %@AB@%flushall%@AE@%, %@AB@%setbuf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FFLUSH.C */
%@AS@%  #include <stdio.h>
%@AS@%  #include <conio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int integer;
%@AS@%     char string[81];%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Read each word as a string. */
%@AS@%     printf( "Enter a sentence of four words with scanf: " );
%@AS@%     for( integer = 0; integer < 4; integer++ )
%@AS@%     {
%@AS@%        scanf( "%s", string );
%@AS@%        printf( "%s\n", string );
%@AS@%     }
%@AS@%  
%@AS@%     /* You must flush the input buffer before using gets. */
%@AS@%     fflush( stdin );
%@AS@%     printf( "Enter the same sentence with gets: " );
%@AS@%     gets( string );
%@AS@%     printf( "%s\n", string );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Enter a sentence of four words with scanf: This is a test
%@AS@%  This
%@AS@%  is
%@AS@%  a
%@AS@%  test
%@AS@%  Enter the same sentence with gets: This is a test
%@AS@%  This is a test%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fgetc@%%@QR:fgetchar@%%@NL@%
%@2@%%@CR:C6A00980502 @%%@AB@%fgetc, fgetchar%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00980503 @%%@CR:C6A00980504 @% %@CR:C6A00980505 @% %@CR:C6A00980506 @% %@CR:C6A00980507 @%%@CR:C6A00980508 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Read a character from a stream (%@AB@%fgetc%@AE@%) or %@AB@%stdin (fgetchar%@AE@%).  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fgetc( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AS@%  int fgetchar( void ); %@AE@%%@NL@%
%@NL@%
%@AI@%stream %@AE@%                           Pointer to %@AB@%FILE%@AE@% structure

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fgetc%@AE@% function reads a single character from the current position of the
file associated with %@AI@%stream%@AE@%. The character is converted and returned as an%@AB@%
%@AB@%int%@AE@%. The function then increments the associated file pointer (if any) to
point to the next character. The %@AB@%fgetchar%@AE@% function is equivalent to
%@AB@%fgetc(stdin)%@AE@%.  %@NL@%
%@NL@%
The %@AB@%fgetc%@AE@% and %@AB@%fgetchar%@AE@% routines are identical to %@AB@%getc%@AE@% and %@AB@%getchar%@AE@%, but they
are functions rather than macros.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fgetc%@AE@% and %@AB@%fgetchar%@AE@% functions return the character read. They return %@AB@%EOF%@AE@%
to indicate an error or end-of-file. Use %@AB@%feof%@AE@% or %@AB@%ferror%@AE@% to distinguish
between an error and an end-of-file condition.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fgetc%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%fgetchar%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fputc%@AE@%, %@AB@%fputchar%@AE@%, %@AB@%getc%@AE@%, %@AB@%getchar%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FGETC.C: This program uses getc to read the first 80 input characters
%@AS@%   * (or until the end of input) and place them into a string named buffer.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE *stream;
%@AS@%     char buffer[81];
%@AS@%     int  i, ch;
%@AS@%  
%@AS@%     /* Open file to read line from: */
%@AS@%     if( (stream = fopen( "fgetc.c", "r" )) == NULL )
%@AS@%        exit( 0 );
%@AS@%  
%@AS@%     /* Read in first 80 characters and place them in "buffer": */
%@AS@%     ch = fgetc( stream );
%@AS@%     for( i=0; (i < 80 ) && ( feof( stream ) == 0 ); i++ )
%@AS@%     {
%@AS@%        buffer[i] = ch;
%@AS@%        ch = fgetc( stream );
%@AS@%     }
%@AS@%     /* Add null to end string */
%@AS@%     buffer[i] = '\0';
%@AS@%     printf( "%s\n", buffer );
%@AS@%     fclose( stream );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  /* FGETC.C: This program uses getc to read the first 80 input characters
%@AS@%  /* (or%@AE@%%@NL@%
%@NL@%
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fgetpos@%%@NL@%
%@2@%%@CR:C6A00990509 @%%@AB@%fgetpos%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A00990510 @%%@CR:C6A00990511 @% %@CR:C6A00990512 @%%@CR:C6A00990513 @% %@CR:C6A00990514 @%%@CR:C6A00990515 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets a stream's file-position indicator.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fgetpos( FILE *stream, fpos_t *pos );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Target stream

%@AI@%pos%@AE@%                               Position-indicator storage

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fgetpos%@AE@% function gets the current value of the %@AI@%stream%@AE@% argument's
file-position indicator and stores it in the object pointed to by %@AI@%pos%@AE@%. The
%@AB@%fsetpos%@AE@% function can later use information stored in %@AI@%pos%@AE@% to reset the %@AI@%stream%@AE@%
argument's pointer to its position at the time %@AB@%fgetpos%@AE@% was called.  %@NL@%
%@NL@%
The %@AI@%pos %@AE@%value is stored in an internal format and is intended for use only
by the %@AB@%fgetpos%@AE@% and %@AB@%fsetpos%@AE@% functions.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the %@AB@%fgetpos%@AE@% function returns 0. On failure, it returns a
nonzero value and sets %@AB@%errno%@AE@% to one of the following manifest constants
(defined in STDIO.H):  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EBADF%@AE@%                             The specified stream is not a valid file
                                  handle or is not 
                                  accessible.

%@AB@%EINVAL%@AE@%                            The %@AI@%stream%@AE@% value is invalid.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fsetpos%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FGETPOS.C: This program opens a file and reads bytes at several
%@AS@%   * different locations.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE   *stream;
%@AS@%     fpos_t pos;
%@AS@%     int    val;
%@AS@%     char   buffer[20];
%@AS@%  
%@AS@%     if( (stream = fopen( "fgetpos.c", "rb" )) == NULL )
%@AS@%        printf( "Trouble opening file\n" );
%@AS@%     else
%@AS@%     {
%@AS@%        /* Read some data and then check the position. */
%@AS@%        fread( buffer, sizeof( char ), 10, stream );
%@AS@%        if( fgetpos( stream, &pos ) != 0 )
%@AS@%           perror( "fgetpos error" );
%@AS@%        else
%@AS@%        {
%@AS@%           fread( buffer, sizeof( char ), 10, stream );
%@AS@%           printf( "10 bytes at byte %ld: %.10s\n", pos, buffer );
%@AS@%        }
%@AS@%  
%@AS@%        /* Set a new position and read more data */
%@AS@%        pos = 140;
%@AS@%        if( fsetpos( stream, &pos ) != 0 )
%@AS@%           perror( "fsetpos error" );
%@AS@%  
%@AS@%        fread( buffer, sizeof( char ), 10, stream );
%@AS@%           printf( "10 bytes at byte %ld: %.10s\n", pos, buffer );
%@AS@%  
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  10 bytes at byte 10: .C: This p
%@AS@%  10 bytes at byte 140:   FILE   *%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fgets@%%@NL@%
%@2@%%@CR:C6A01000516 @%%@AB@%fgets%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01000517 @%%@CR:C6A01000518 @% %@CR:C6A01000519 @%%@CR:C6A01000520 @%%@CR:C6A01000521 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets a string from a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char *fgets( char *string, int n, FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            Storage location for data

%@AI@%n%@AE@%                                 Number of characters stored

%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE %@AE@%structure

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fgets%@AE@% function reads a string from the input %@AI@%stream%@AE@% argument and stores
it in %@AI@%string%@AE@%. Characters are read from the current stream position up to and
including the first newline character (%@AB@%'\n'%@AE@%), up to the end of the stream,
or until the number of characters read is equal to %@AI@%n%@AE@% - 1, whichever comes
first. The result is stored in %@AI@%string%@AE@%, and a null character (%@AB@%'\0'%@AE@%) is
appended. The newline character, if read, is included in the string. If %@AI@%n%@AE@% is
equal to 1, %@AI@%string%@AE@% is empty (""). The %@AB@%fgets%@AE@% function is similar to the %@AB@%gets%@AE@%
function; however, %@AB@%gets%@AE@% replaces the newline character with %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the %@AB@%fgets%@AE@% function returns %@AI@%string%@AE@%. It returns %@AB@%NULL%@AE@% to
indicate either an error or end-of-file condition. Use %@AB@%feof%@AE@% or %@AB@%ferror%@AE@% to
determine whether an error occurred.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fputs%@AE@%, %@AB@%gets%@AE@%, %@AB@%puts%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FGETS.C: This program uses fgets to display a line from a file on the
%@AS@%   * screen.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  FILE *stream;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char line[100], *result;%@AE@%%@NL@%
%@NL@%
%@AS@%  if( (stream = fopen( "fgets.c", "r" )) != NULL )
%@AS@%     {
%@AS@%        if( fgets( line, 100, stream ) == NULL)
%@AS@%           printf( "fgets error\n" );
%@AS@%        else
%@AS@%           printf( "%s", line);
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  /* FGETS.C: This program uses fgets to display a line from a file on the%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fieeetomsbin@%%@QR:fmsbintoieee@%%@NL@%
%@2@%%@CR:C6A01010522 @%%@AB@%fieeetomsbin, fmsbintoieee%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Convert floating-point numbers between IEEE and Microsoft binary formats.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fieeetomsbin( float *src4,  float *dst4 );%@AE@%%@NL@%
%@NL@%
%@AS@%  int fmsbintoieee(  float *src4,  float *dst4 );%@AE@%%@NL@%
%@NL@%
%@AI@%scr4 %@AE@%                             Value to be converted

%@AI@%dst4 %@AE@%                             Converted value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fieeetomsbin%@AE@% routine converts a single-precision floating-point number
in IEEE (Institute of Electrical and Electronic Engineers) format to
Microsoft (MS) binary format.  %@NL@%
%@NL@%
The %@AB@%fmsbintoieee%@AE@% routine converts a floating-point number in Microsoft
binary format to IEEE format.  %@NL@%
%@NL@%
These routines allow C programs (which store floating-point numbers in the
IEEE format) to use numeric data in random-access data files created with
Microsoft BASIC (which stores floating-point numbers in the Microsoft binary
format), and vice versa.  %@NL@%
%@NL@%
The argument %@AI@%src4%@AE@% points to the %@AB@%float%@AE@% value to be converted. The result is
stored at the location given by %@AI@%dst4%@AE@%.  %@NL@%
%@NL@%
These routines do not handle IEEE NANs ("not a number") and infinities. IEEE
denormals are treated as 0 in the conversions.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return 0 if the conversion is successful and 1 if the
conversion causes an overflow.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%dieeetomsbin%@AE@%, %@AB@%dmsbintoieee%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:filelength@%%@NL@%
%@2@%%@CR:C6A01020523 @%%@AB@%filelength%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01020524 @%%@CR:C6A01020525 @% %@CR:C6A01020526 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the length of a file.  %@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  long filelength( int handle );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Target file handle

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%filelength%@AE@% function returns the length, in bytes, of the target file
associated with %@AI@%handle.%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%filelength%@AE@% function returns the file length in bytes. A return value of
-1L indicates an error, and an invalid handle sets %@AB@%errno%@AE@% to %@AB@%EBADF%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%chsize%@AE@%, %@AB@%fileno%@AE@%, %@AB@%fstat%@AE@%, %@AB@%stat%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CHSIZE.C: This program uses filelength to report the size of a
%@AS@%   * file before and after modifying it with chsize.
%@AS@%   */
%@AS@%  
%@AS@%  #include <io.h>
%@AS@%  #include <fcntl.h>
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh, result;
%@AS@%     unsigned int nbytes = BUFSIZ;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Open a file */
%@AS@%     if( (fh = open( "data", O_RDWR | O_CREAT, S_IREAD | S_IWRITE )) != -1 )
%@AS@%     {
%@AS@%        printf( "File length before: %ld\n", filelength( fh ) );
%@AS@%        if( chsize( fh, 329678 ) == 0 )
%@AS@%           printf( "Size successfully changed\n" );
%@AS@%        else
%@AS@%           printf( "Problem in changing the size\n" );
%@AS@%        printf( "File length after:  %ld\n", filelength( fh ) );
%@AS@%        close( fh );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  File length before: 0
%@AS@%  Size successfully changed
%@AS@%  File length after:  329678%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fileno@%%@NL@%
%@2@%%@CR:C6A01030527 @%%@AB@%fileno%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01030528 @%%@CR:C6A01030529 @%%@CR:C6A01030530 @% %@CR:C6A01030531 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the file handle associated with a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fileno( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fileno%@AE@% routine returns the file handle currently associated with %@AI@%stream%@AE@%.
This routine is implemented as a macro.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fileno%@AE@% routine returns the file handle. There is no error return. The
result is undefined if %@AI@%stream%@AE@% does not specify an open file.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fdopen%@AE@%, %@AB@%filelength%@AE@%, %@AB@%fopen%@AE@%, %@AB@%freopen%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FILENO.C: This program uses fileno to obtain the file handle for
%@AS@%   * some standard C streams.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     printf( "The file handle for stdin is %d\n", fileno( stdin ) );
%@AS@%     printf( "The file handle for stdout is %d\n", fileno( stdout ) );
%@AS@%     printf( "The file handle for stderr is %d\n", fileno( stderr ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The file handle for stdin is 0
%@AS@%  The file handle for stdout is 1
%@AS@%  The file handle for stderr is 2%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_floodfill@%%@QR:_floodfill_w@%%@NL@%
%@2@%%@CR:C6A01040532 @%%@AB@%_floodfill, _floodfill_w%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01040533 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Fill an area of a display using the current color and fill mask  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _floodfill( short x, short y, short boundary );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _floodfill_w( double wx, double wy, short boundary );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              Start point

%@AI@%wx%@AE@%, %@AI@%wy%@AE@%                            Start point

%@AI@%boundary%@AE@%                          Boundary color of area to be filled

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The functions in the %@AB@%_floodfill%@AE@% family fill an area of the display, using
the current color and fill mask. The %@AB@%_floodfill%@AE@% routine begins filling at
the view-coordinate point (%@AI@%x%@AE@%, %@AI@%y%@AE@%). The %@AB@%_floodfill_w%@AE@% routine begins filling at
the window-coordinate point (%@AI@%wx%@AE@%, %@AI@%wy%@AE@%).  %@NL@%
%@NL@%
If this point lies inside the figure, the interior is filled; if it lies
outside the figure, the background is filled. The point must be inside or
outside the figure to be filled, not on the figure boundary itself. Filling
occurs in all directions, stopping at the color of %@AI@%boundary%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_floodfill%@AE@% functions return a nonzero value if the fill is successful.
It returns 0 if the fill could not be completed, the starting point lies on
the %@AI@%boundary%@AE@% color, or the start point lies outside the clipping region.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_ellipse%@AE@% functions, %@AB@% _getcolor%@AE@%, %@AB@% _getfillmask%@AE@%, %@AB@% _grstatus%@AE@%,%@AB@%  _pie%@AE@% functions, %@AB@%
%@AB@%_setfillmask%@AE@%, %@AB@%_setcliprgn%@AE@%, %@AB@% _setcolor%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FLOODFIL.C: This program draws a series of nested rectangles in
%@AS@%   * different colors, constantly changing the background color.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     int loop;
%@AS@%     int xvar, yvar;
%@AS@%  
%@AS@%     /* find a valid graphics mode */
%@AS@%     if( !_setvideomode( _MAXCOLORMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     for( xvar = 163, loop = 0; xvar < 320; loop++, xvar += 3 )
%@AS@%     {
%@AS@%        _setcolor( loop % 16 );
%@AS@%        yvar = xvar * 5 / 8;
%@AS@%        _rectangle( _GBORDER, 320-xvar, 200-yvar, xvar, yvar );
%@AS@%        _setcolor( rand() % 16 );
%@AS@%        _floodfill( 0, 0, loop % 16 );
%@AS@%     }
%@AS@%     getch();
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:floor@%%@QR:floorl@%%@NL@%
%@2@%%@CR:C6A01050534 @%%@AB@%floor, floorl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01050535 @%%@CR:C6A01050536 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate the floor of a value.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double floor( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double floorl( long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Floating-point value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%floor%@AE@% and %@AB@%floorl%@AE@% functions return a floating-point value representing
the largest integer that is less than or equal to%@AB@% %@AE@%%@AI@%x%@AE@%.  %@NL@%
%@NL@%
The %@AB@%floorl%@AE@% function is the 80-bit counterpart, and it uses the 80-bit,
10-byte coprocessor form of arguments and return values. See the reference
page on the long double functions for more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return the floating-point result. There is no error return.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%floor%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%floorl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%ceil%@AE@%, %@AB@%fmod%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FLOOR.C: This example displays the largest integers less than or equal
%@AS@%   * to the floating-point values 2.8 and -2.8. It then shows the smallest
%@AS@%   * integers greater than or equal to 2.8 and -2.8.
%@AS@%   */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     double y;
%@AS@%  
%@AS@%     y = floor( 2.8 );
%@AS@%     printf( "The floor of 2.8 is %f\n", y );
%@AS@%     y = floor( -2.8 );
%@AS@%     printf( "The floor of -2.8 is %f\n", y );
%@AS@%  
%@AS@%     y = ceil( 2.8 );
%@AS@%     printf( "The ceil of 2.8 is %f\n", y );
%@AS@%     y = ceil( -2.8 );
%@AS@%     printf( "The ceil of -2.8 is %f\n", y );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The floor of 2.8 is 2.000000
%@AS@%  The floor of -2.8 is -3.000000
%@AS@%  The ceil of 2.8 is 3.000000
%@AS@%  The ceil of -2.8 is -2.000000%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:flushall@%%@NL@%
%@2@%%@CR:C6A01060537 @%%@AB@%flushall%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01060538 @%%@CR:C6A01060539 @%%@CR:C6A01060540 @% %@CR:C6A01060541 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Flushes all streams; clears all buffers.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int flushall( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%flushall%@AE@% function writes to its associated files the contents of all
buffers associated with open output streams. All buffers associated with
open input streams are cleared of their current contents. The next read
operation (if there is one) then reads new data from the input files into
the buffers.  %@NL@%
%@NL@%
Buffers are automatically flushed when they are full, when streams are
closed, or when a program terminates normally without closing streams.  %@NL@%
%@NL@%
All streams remain open after the call to %@AB@%flushall%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%flushall%@AE@% function returns the number of open streams (input and output).
There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fflush%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FLUSHALL.C: This program uses flushall to flush all open buffers. */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int numflushed;
%@AS@%  
%@AS@%     numflushed = flushall();
%@AS@%     printf( "There were %d streams flushed\n", numflushed );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  There were 3 streams flushed%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fmod@%%@QR:fmodl@%%@NL@%
%@2@%%@CR:C6A01070542 @%%@AB@%fmod, fmodl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01070543 @%%@CR:C6A01070544 @%%@CR:C6A01070545 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculates the floating-point remainder.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double fmod( double x, double y );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double fmodl( long double x, long double y );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              Floating-point values

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fmod%@AE@% and %@AB@%fmodl%@AE@% functions calculate the floating-point remainder %@AI@%f%@AE@% of %@AI@%x%@AE@% /
%@AI@%y %@AE@% such that %@AI@%x%@AE@% = %@AI@%i %@AE@%* y + %@AI@%f%@AE@%, where %@AI@%i%@AE@% is an integer,  %@AI@%f%@AE@%  has the same sign as
%@AI@%x%@AE@%, and the absolute value of %@AI@% f%@AE@%  is less than the absolute value of %@AI@%y%@AE@%.  %@NL@%
%@NL@%
The %@AB@%fmodl%@AE@% function is the 80-bit counterpart; it uses the 80-bit, 10-byte
coprocessor form of arguments and return values. See the discussion of the
long double functions for more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return the floating-point remainder. If %@AI@%y%@AE@% is 0, the function
returns 0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fmod%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%fmodl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%ceil%@AE@%, %@AB@%fabs%@AE@%, %@AB@%floor%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FMOD.C: This program displays a floating-point remainder. */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     double x = -10.0, y = 3.0, z;
%@AS@%  
%@AS@%     z = fmod( x, y );
%@AS@%     printf( "The remainder of %.2f / %.2f is %f\n", x, y, z );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The remainder of -10.00 / 3.00 is -1.000000%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fopen@%%@NL@%
%@2@%%@CR:C6A01080546 @%%@AB@%fopen%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01080547 @%%@CR:C6A01080548 @%%@CR:C6A01080549 @% %@CR:C6A01080550 @%%@CR:C6A01080551 @%%@CR:C6A01080552 @%%@CR:C6A01080553 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Opens a file.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  FILE *fopen( const char *filename, const char *mode );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          Path name of file

%@AI@%mode%@AE@%                              Type of access permitted

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fopen%@AE@% function opens the file specified by %@AI@%filename%@AE@%. The character
string %@AI@%mode%@AE@% specifies the type of access requested for the file, as follows:
%@NL@%
%@NL@%
%@AB@%Type%@AE@%                              %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%"r"%@AE@%                               Opens for reading. If the file does not 
                                  exist or cannot be found, the %@AB@%fopen%@AE@% call
                                  will fail.

%@AB@%"w"%@AE@%                               Opens an empty file for writing. If the 
                                  given file exists, its contents are 
                                  destroyed. 

%@AB@%"a"%@AE@%                               Opens for writing at the end of the file
                                  (appending); creates the file first if 
                                  it doesn't exist.

%@AB@%"r+"%@AE@%                              Opens for both reading and writing. (The
                                  file must exist.)

%@AB@%"w+"%@AE@%                              Opens an empty file for both reading and
                                  writing. If the given file exists, its 
                                  contents are destroyed.

%@AB@%"a+"%@AE@%                              Opens for reading and appending; creates
                                  the file first if it doesn't exist.

When a file is opened with the %@AB@%"a"%@AE@% or %@AB@%"a+"%@AE@% access type, all write operations
occur at the end of the file. Although the file pointer can be repositioned
using %@AB@%fseek%@AE@% or%@AB@% rewind%@AE@%, the file pointer is always moved back to the end of
the file before any write operation is carried out. Thus, existing data
cannot be overwritten.  %@NL@%
%@NL@%
When the %@AB@%"r+"%@AE@%, %@AB@%"w+"%@AE@%, or %@AB@%"a+" %@AE@%access type is specified, both reading and
writing are allowed (the file is said to be open for "update"). However,
when you switch between reading and writing, there must be an intervening
%@AB@%fsetpos%@AE@%, %@AB@%fseek%@AE@%, or %@AB@%rewind%@AE@% operation. The current position can be specified
for the %@AB@%fsetpos%@AE@% or %@AB@%fseek%@AE@% operation, if desired.  %@NL@%
%@NL@%
In addition to the values listed above, one of the following characters can
be included in %@AI@%mode%@AE@% to specify the translation mode for newline characters: %@CR:C6A01080554 @%%@CR:C6A01080555 @%%@CR:C6A01080556 @%
%@NL@%
%@NL@%
%@AB@%Mode%@AE@%                              %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%t%@AE@%                                 Open in text (translated) mode. In this 
                                  mode, carriage-return-line-feed (CR-LF) 
                                  combinations are translated into single 
                                  line feeds (LF) on input and LF 
                                  characters are translated to CR-LF 
                                  combinations on output. Also, CTRL+Z is 
                                  interpreted as an end-of-file character 
                                  on input. In files opened for reading or
                                  for reading/writing, %@AB@%fopen%@AE@% checks for a 
                                  CTRL+Z at the end of the file and 
                                  removes it, if possible. This is done 
                                  because using the %@AB@%fseek%@AE@% and %@AB@%ftell%@AE@% 
                                  functions to move within a file that 
                                  ends with a CTRL+Z may cause %@AB@%fseek%@AE@% to 
                                  behave improperly near the end of the 
                                  file.

%@AB@%b%@AE@%                                 Open in binary (untranslated) mode; the 
                                  above translations are suppressed.

If %@AB@%t%@AE@% or %@AB@%b%@AE@% is not given in %@AI@%mode%@AE@%, the translation mode is defined by the
default-mode variable %@AB@%_fmode%@AE@%. If %@AB@%t%@AE@% or %@AB@%b%@AE@% is prefixed to the argument, the
function will fail and return %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
See Section 2.7, "Input and Output," for a discussion of text and binary
modes.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fopen%@AE@% function returns a pointer to the open file. A null pointer value
indicates an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
Note that the %@AB@%t%@AE@% option is not part of the ANSI standard for %@AB@%fopen%@AE@%; it is a
Microsoft extension and should not be used where ANSI portability is
desired.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fclose%@AE@%, %@AB@%fcloseall%@AE@%, %@AB@%fdopen%@AE@%, %@AB@%ferror%@AE@%, %@AB@%fileno%@AE@%, %@AB@%freopen%@AE@%, %@AB@%open%@AE@%, %@AB@%setmode%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FOPEN.C: This program opens files named "data" and "data2". It uses
%@AS@%   * fclose to close "data" and fcloseall to close all remaining files.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  FILE *stream, *stream2;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int numclosed;
%@AS@%  
%@AS@%     /* Open for read (will fail if 'data' does not exist) */
%@AS@%     if( (stream  = fopen( "data", "r" )) == NULL )
%@AS@%        printf( "The file 'data' was not opened\n" );
%@AS@%     else
%@AS@%        printf( "The file 'data' was opened\n" );
%@AS@%  
%@AS@%     /* Open for write */
%@AS@%     if( (stream2 = fopen( "data2", "w+" )) == NULL )
%@AS@%        printf( "The file 'data2' was not opened\n" );
%@AS@%     else
%@AS@%        printf( "The file 'data2' was opened\n" );
%@AS@%  
%@AS@%     /* Close stream */
%@AS@%     if( fclose( stream ) )
%@AS@%        printf( "The file 'data' was not closed\n" );
%@AS@%  
%@AS@%     /* All other files are closed: */
%@AS@%     numclosed = fcloseall( );
%@AS@%     printf( "Number of files closed by fcloseall: %u\n", numclosed );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The file 'data' was opened
%@AS@%  The file 'data2' was opened
%@AS@%  Number of files closed by fcloseall: 1%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:FP_OFF@%%@QR:FP_SEG@%%@NL@%
%@2@%%@CR:C6A01090557 @%%@AB@%FP_OFF, FP_SEG%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01090558 @%%@CR:C6A01090559 @%%@CR:C6A01090560 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Get or set a far-pointer offset (%@AB@%FP_OFF%@AE@%) or a far-pointer segment (%@AB@%FP_SEG%@AE@%).
%@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned FP_OFF( void _far *address );%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned FP_SEG( void _far *address );%@AE@%%@NL@%
%@NL@%
%@AI@%address%@AE@%                           Far pointer to memory address

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%FP_OFF%@AE@% and %@AB@%FP_SEG%@AE@% macros can be used to set or get the offset and
segment, respectively, of the far pointer at %@AI@%address%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%FP_OFF%@AE@% macro returns an offset. The %@AB@%FP_SEG%@AE@% macro returns a segment
address.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FP_SEG.C: This program uses FP_SEG and FP_OFF to obtain
%@AS@%   * the segment and offset of the long pointer p.
%@AS@%   */
%@AS@%  
%@AS@%  #include <dos.h>
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     void _far *p;
%@AS@%     unsigned int seg_val;
%@AS@%     unsigned int off_val;
%@AS@%  
%@AS@%     p = _fmalloc( 100 );        /* Points pointer at something */
%@AS@%  
%@AS@%     seg_val = FP_SEG( p );      /* Gets address pointed to */
%@AS@%     off_val = FP_OFF( p );
%@AS@%  
%@AS@%     printf( "Segment is %.4X; Offset is %.4X\n", seg_val, off_val );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Segment is 00C7; Offset is 0016%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_fpreset@%%@NL@%
%@2@%%@CR:C6A01100561 @%%@AB@%_fpreset%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01100562 @%%@CR:C6A01100563 @% %@CR:C6A01100564 @%%@CR:C6A01100565 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Resets the floating-point package.  %@NL@%
%@NL@%
%@AS@%  #include <float.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _fpreset( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_fpreset%@AE@% function reinitializes the floating-point-math package. This
function is usually used in conjunction with %@AB@%signal%@AE@%, %@AB@%system%@AE@%, or the %@AB@%exec%@AE@% or
%@AB@%spawn%@AE@% functions.  %@NL@%
%@NL@%
If a program traps floating-point error signals (%@AB@%SIGFPE%@AE@%) with %@AB@%signal%@AE@%, it can
safely recover from floating-point errors by invoking %@AB@%_fpreset%@AE@% and using
%@AB@%longjmp%@AE@%.  %@NL@%
%@NL@%
In DOS versions prior to 3.0, a child process executed by %@AB@%exec%@AE@%, %@AB@%spawn%@AE@%, or
%@AB@%system%@AE@% may affect the floating-point state of the parent process if an 8087
or 80287 coprocessor is used. If you are using either coprocessor, the
following precautions are recommended:%@CR:C6A01100566 @%  %@NL@%
%@NL@%
%@NL@%
  ş   The %@AB@%exec%@AE@%, %@AB@%spawn%@AE@%, and %@AB@%system%@AE@% functions should not be called during the
      evaluation of a floating-point expression.%@NL@%
%@NL@%
  ş   The %@AB@%_fpreset%@AE@% function should be called after these routines if there
      is a possibility of the child process performing any floating-point
      operations.%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%exec%@AE@% functions, %@AB@%signal%@AE@%, %@AB@%spawn%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FPRESET.C: This program uses signal to set up a routine for handling
%@AS@%   * floating-point errors.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <signal.h>
%@AS@%  #include <setjmp.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <float.h>
%@AS@%  #include <math.h>
%@AS@%  #include <string.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  jmp_buf mark;                       /* Address for long jump to jump to */
%@AS@%  int  fperr;                         /* Global error number */
%@AS@%  
%@AS@%  void fphandler( int sig, int num ); /* Prototypes */
%@AS@%  void fpcheck( void );
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%      double n1, n2, r;
%@AS@%      int jmpret;
%@AS@%  
%@AS@%      /* Set up floating point error handler. */
%@AS@%      if( signal( SIGFPE, fphandler ) == SIG_ERR )
%@AS@%      {
%@AS@%          fprintf( stderr, "Couldn't set SIGFPE\n" );
%@AS@%          abort();
%@AS@%      }
%@AS@%  
%@AS@%      /* Save stack environment for return in case of error. First time
%@AS@%       * through, jmpret is 0, so true conditional is executed. If an
%@AS@%       * error occurs, jmpret will be set to -1 and false conditional
%@AS@%       * will be executed.
%@AS@%       */
%@AS@%      jmpret = setjmp( mark );
%@AS@%      if( jmpret == 0 )
%@AS@%      {
%@AS@%          printf( "Test for invalid operation - " );
%@AS@%          printf( "enter two numbers: " );
%@AS@%          scanf( "%lf %lf", &n1, &n2 );
%@AS@%  
%@AS@%          r = n1 / n2;
%@AS@%          /* This won't be reached if error occurs. */
%@AS@%          printf( "\n\n%4.3g / %4.3g = %4.3g\n", n1, n2, r );
%@AS@%  
%@AS@%          r = n1 * n2;
%@AS@%          /* This won't be reached if error occurs. */
%@AS@%          printf( "\n\n%4.3g * %4.3g = %4.3g\n", n1, n2, r );
%@AS@%      }
%@AS@%      else
%@AS@%          fpcheck();
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Handles SIGFPE (floating point error) interrupt. */
%@AS@%  void fphandler( int sig, int num )
%@AS@%  {
%@AS@%      /* Set global for outside check since we don't want to do I/O in the
%@AS@%       * handler.
%@AS@%       */
%@AS@%      fperr = num;
%@AS@%  
%@AS@%      /* Initialize floating-point package. */
%@AS@%      _fpreset();
%@AS@%  
%@AS@%      /* Restore calling environment and jump back to setjmp. Return -1
%@AS@%       * so that setjmp will return false for conditional test.
%@AS@%       */
%@AS@%      longjmp( mark, -1 );
%@AS@%  }
%@AS@%  
%@AS@%  void fpcheck()
%@AS@%  {
%@AS@%      char fpstr[30];
%@AS@%  
%@AS@%      switch( fperr )
%@AS@%      {
%@AS@%          case FPE_INVALID:
%@AS@%              strcpy( fpstr, "Invalid number" );
%@AS@%              break;
%@AS@%  
%@AS@%          case FPE_OVERFLOW:
%@AS@%              strcpy( fpstr, "Overflow" );
%@AS@%              break;
%@AS@%  
%@AS@%          case FPE_UNDERFLOW:
%@AS@%              strcpy( fpstr, "Underflow" );
%@AS@%              break;
%@AS@%  
%@AS@%          case FPE_ZERODIVIDE:
%@AS@%              strcpy( fpstr, "Divide by zero" );
%@AS@%              break;
%@AS@%  
%@AS@%          default:
%@AS@%              strcpy( fpstr, "Other floating point error" );
%@AS@%              break;
%@AS@%      }
%@AS@%      printf( "Error %d: %s\n", fperr, fpstr );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Test for invalid operation - enter two numbers: 5 0
%@AS@%  Error 131: Divide by zero%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fprintf@%%@NL@%
%@2@%%@CR:C6A01110567 @%%@AB@%fprintf%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01110568 @%%@CR:C6A01110569 @% %@CR:C6A01110570 @%%@CR:C6A01110571 @% %@CR:C6A01110572 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Prints formatted data to a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fprintf( FILE *stream, const char *format [[, argument]]... );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@AI@%format%@AE@%                            Format-control string

%@AI@%argument%@AE@%                          Optional arguments

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fprintf%@AE@% function formats and prints a series of characters and values to
the output %@AI@%stream%@AE@%. Each %@AI@%argument%@AE@% (if any) is converted and output according
to the corresponding format specification in %@AI@%format%@AE@%.  %@NL@%
%@NL@%
The %@AI@%format%@AE@% argument has the same form and function that it does for the
%@AB@%printf%@AE@% function; see the Remarks section for the %@AB@%printf%@AE@% function for more
information on %@AI@%format%@AE@% and %@AI@%argument%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fprintf%@AE@% function returns the number of characters printed, or a negative
value in the case of an output error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cprintf%@AE@%, %@AB@%fscanf%@AE@%, %@AB@%printf%@AE@%, %@AB@%sprintf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FPRINTF.C: This program uses fprintf to format various data and
%@AS@%   * print them to the file named FPRINTF.OUT. It then displays
%@AS@%   * FPRINTF.OUT on the screen using the system function to invoke
%@AS@%   * the DOS TYPE command.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <process.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  FILE *stream;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int    i = 10;
%@AS@%     double fp = 1.5;
%@AS@%     char   s[] = "this is a string";
%@AS@%     char   c = '\n';
%@AS@%  
%@AS@%     stream = fopen( "fprintf.out", "w" );
%@AS@%     fprintf( stream, "%s%c", s, c );
%@AS@%     fprintf( stream, "%d\n", i );
%@AS@%     fprintf( stream, "%f\n", fp );
%@AS@%     fclose( stream );
%@AS@%     system( "type fprintf.out" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  this is a string
%@AS@%  10
%@AS@%  1.500000 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fputc@%%@QR:fputchar@%%@NL@%
%@2@%%@CR:C6A01120573 @%%@AB@%fputc, fputchar%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01120574 @%%@CR:C6A01120575 @% %@CR:C6A01120576 @% %@CR:C6A01120577 @%%@CR:C6A01120578 @% %@CR:C6A01120579 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Write a character to a stream (%@AB@%fputc%@AE@%) or to %@AB@%stdout %@AE@%(%@AB@%fputchar%@AE@%).  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fputc( int c, FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AS@%  int fputchar( int c );%@AE@%%@NL@%
%@NL@%
%@AI@%c%@AE@%                                 Character to be written

%@AI@%stream %@AE@%                           Pointer to %@AB@%FILE %@AE@%structure

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fputc%@AE@% function writes the single character %@AI@%c%@AE@% to the output %@AI@%stream%@AE@% at the
current position. The %@AB@%fputchar%@AE@% function is equivalent to %@AB@%fputc(%@AE@%%@AI@%c%@AE@%,%@AB@% stdout)%@AE@%.  %@NL@%
%@NL@%
The %@AB@%fputc%@AE@% and %@AB@%fputchar%@AE@% routines are similar to %@AB@%putc%@AE@% and %@AB@%putchar%@AE@%, but are
functions rather than macros.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fputc%@AE@% and %@AB@%fputchar%@AE@% functions return the character written. A return
value of %@AB@%EOF%@AE@% indicates an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fputc%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%fputchar%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fgetc%@AE@%, %@AB@%fgetchar%@AE@%, %@AB@%putc%@AE@%, %@AB@%putchar%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FPUTC.C: This program uses fputc and fputchar to send a character
%@AS@%   * array to stdout.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char strptr1[] = "This is a test of fputc!!\n";
%@AS@%     char strptr2[] = "This is a test of fputchar!!\n";
%@AS@%     char *p;
%@AS@%  
%@AS@%     /* Print line to stream using fputc. */
%@AS@%     p = strptr1;
%@AS@%     while( (*p != '\0') && fputc( *(p++), stdout ) != EOF )
%@AS@%        ;
%@AS@%  
%@AS@%     /* Print line to stream using fputchar. */
%@AS@%     p = strptr2;
%@AS@%     while( (*p != '\0') && fputchar( *(p++) ) != EOF )
%@AS@%        ;
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  This is a test of fputc!!
%@AS@%  This is a test of fputchar!! %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fputs@%%@NL@%
%@2@%%@CR:C6A01130580 @%%@AB@%fputs%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01130581 @%%@CR:C6A01130582 @% %@CR:C6A01130583 @%%@CR:C6A01130584 @% %@CR:C6A01130585 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Writes a string to a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fputs( const char *string, FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            String to be output

%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fputs%@AE@% function copies %@AI@%string%@AE@% to the output %@AI@%stream%@AE@% at the current
position. The terminating null character (%@AB@%'\0'%@AE@%) is not copied.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fputs%@AE@% function returns a nonnegative value if it is successful. If an
error occurs, it returns %@AB@%EOF%@AE@%.%@CR:C6A01130586 @%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fgets%@AE@%, %@AB@%gets%@AE@%, %@AB@%puts%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FPUTS.C: This program uses fputs to write a single line to the
%@AS@%   * stdout stream.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     fputs( "Hello world from fputs.\n", stdout );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Hello world from fputs. %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fread@%%@NL@%
%@2@%%@CR:C6A01140587 @%%@AB@%fread%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01140588 @%%@CR:C6A01140589 @%%@CR:C6A01140590 @% %@CR:C6A01140591 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Reads data from a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  size_t fread( void *buffer, size_t size, size_t count, FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%buffer%@AE@%                            Storage location for data

%@AI@%size%@AE@%                              Item size in bytes

%@AI@%count%@AE@%                             Maximum number of items to be read

%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fread%@AE@% function reads up to %@AI@%count%@AE@% items of %@AI@%size%@AE@% bytes from the input
%@AI@%stream%@AE@% and stores them in %@AI@%buffer%@AE@%. The file pointer associated with %@AI@%stream%@AE@%
(if there is one) is increased by the number of bytes actually read.  %@NL@%
%@NL@%
If the given stream is opened in text mode, carriage-return-line-feed pairs
are replaced with single line-feed characters. The replacement has no effect
on the file pointer or the return value.  %@NL@%
%@NL@%
The file-pointer position is indeterminate if an error occurs. The value of
a partially read item cannot be determined.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fread%@AE@% function returns the number of full items actually read, which may
be less than %@AI@%count%@AE@% if an error occurs or if the file end is encountered
before reaching %@AI@%count%@AE@%.  %@NL@%
%@NL@%
The %@AB@%feof%@AE@% or %@AB@%ferror%@AE@% function should be used to distinguish a read error from
an end-of-file condition. If %@AI@%size%@AE@% or %@AI@%count%@AE@% is 0, %@AB@%fread%@AE@% returns 0 and the
buffer contents are unchanged.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fwrite%@AE@%, %@AB@%read%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FREAD.C: This program opens a file named FREAD.OUT and writes 25
%@AS@%   * characters to the file. It then tries to open FREAD.OUT and
%@AS@%   * read in 25 characters. If the attempt succeeds, the program
%@AS@%   * displays the number of actual items read.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE *stream;
%@AS@%     char list[30];
%@AS@%     int  i, numread, numwritten;
%@AS@%  
%@AS@%     /* Open file in text mode: */
%@AS@%     if( (stream = fopen( "fread.out", "w+t" )) != NULL )
%@AS@%     {
%@AS@%        for ( i = 0; i < 25; i++ )
%@AS@%           list[i] = 'z' - i;
%@AS@%        /* Write 25 characters to stream */
%@AS@%        numwritten = fwrite( list, sizeof( char ), 25, stream );
%@AS@%        printf( "Wrote %d items\n", numwritten );
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%     else
%@AS@%        printf( "Problem opening the file\n" );
%@AS@%  
%@AS@%     if( (stream = fopen( "fread.out", "r+t" )) != NULL )
%@AS@%     {
%@AS@%        /* Attempt to read in 25 characters */
%@AS@%        numread = fread( list, sizeof( char ), 25, stream );
%@AS@%        printf( "Number of items read = %d\n", numread );
%@AS@%        printf( "Contents of buffer = %.25s\n", list );
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%     else
%@AS@%        printf( "Was not able to open the file\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Wrote 25 items
%@AS@%  Number of items read = 25
%@AS@%  Contents of buffer = zyxwvutsrqponmlkjihgfedcb %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:free@%%@NL@%
%@2@%%@CR:C6A01150592 @%%@AB@%free Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01150593 @%%@CR:C6A01150594 @%%@CR:C6A01150595 @% %@CR:C6A01150596 @%%@CR:C6A01150597 @% %@CR:C6A01150598 @%%@CR:C6A01150599 @%%@CR:C6A01150600 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Deallocate a memory block.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               For ANSI compatibility (%@AB@%free%@AE@% only)

%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  void free( void *memblock );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _bfree( _segment seg, void _based( void ) *memblock );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _ffree( void _far *memblock );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _nfree( void _near *memblock );%@AE@%%@NL@%
%@NL@%
%@AI@%memblock%@AE@%                          Allocated memory block

%@AI@%seg%@AE@%                               Based-heap segment selector

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%free%@AE@% family of functions deallocates a memory block. The argument
%@AI@%memblock%@AE@% points to a memory block previously allocated through a call to
%@AB@%calloc%@AE@%, %@AB@%malloc%@AE@%, or %@AB@%realloc%@AE@%. The number of bytes freed is the number of bytes
specified when the block was allocated (or reallocated, in the case of
%@AB@%realloc%@AE@%). After the call, the freed block is available for allocation.  %@NL@%
%@NL@%
The %@AI@%seg%@AE@% argument specifies the based heap containing the memory block to be
freed by the %@AB@%_bfree%@AE@% function.  %@NL@%
%@NL@%
Attempting to free an invalid pointer may affect subsequent allocation and
cause errors. An invalid pointer is one not allocated with the appropriate
call.  %@NL@%
%@NL@%
The following restrictions apply to use of the %@AB@%free%@AE@%, %@AB@%_bfree%@AE@%, %@AB@%_ffree%@AE@%, and
%@AB@%_nfree%@AE@% functions:  %@NL@%
%@NL@%
%@AB@%Blocks allocated with:%@AE@%            %@AB@%Should be freed with:%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%calloc%@AE@%, %@AB@%malloc%@AE@%, %@AB@%realloc%@AE@%           %@AB@%free%@AE@%

%@AB@%_bcalloc%@AE@%,%@AB@% _bmalloc%@AE@%,%@AB@% _brealloc%@AE@%     %@AB@%_bfree%@AE@%

%@AB@%_fcalloc%@AE@%, %@AB@%_fmalloc%@AE@%, %@AB@%_frealloc%@AE@%     %@AB@%_ffree%@AE@%

%@AB@%_ncalloc%@AE@%,%@AB@% _nmalloc%@AE@%,%@AB@% _nrealloc%@AE@%     %@AB@%_nfree%@AE@%

A%@AB@% NULL%@AE@% pointer argument is ignored.  %@NL@%
%@NL@%
In large data models (compact-, large-, and huge-model programs), %@AB@%free%@AE@% maps
to %@AB@%_ffree%@AE@%. In small data models (tiny-, small-, and medium-model programs),
%@AB@%free%@AE@% maps to %@AB@%_nfree%@AE@%.  %@NL@%
%@NL@%
The various %@AB@%free%@AE@% functions deallocate a memory block in the segments shown
in the list below:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Data Segment%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%free%@AE@%                              Depends on data model of program

%@AB@%_bfree%@AE@%                            Based heap specified by %@AI@%seg%@AE@% value

%@AB@%_ffree%@AE@%                            Far heap (outside default data segment)

%@AB@%_nfree%@AE@%                            Near heap (inside default data segment)

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%free%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_bfree, _ffree, _nfree%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%calloc %@AE@%functions, %@AB@%malloc%@AE@% functions, %@AB@%realloc %@AE@%functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MALLOC.C: This program allocates memory with malloc, then frees
%@AS@%   * the memory with free.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>         /* Definition of _MAX_PATH */
%@AS@%  #include <stdio.h>
%@AS@%  #include <malloc.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *string;
%@AS@%  
%@AS@%     /* Allocate space for a path name */
%@AS@%     string = malloc( _MAX_PATH );
%@AS@%     if( string == NULL )
%@AS@%        printf( "Insufficient memory available\n" );
%@AS@%     else
%@AS@%        printf( "Memory space allocated for path name\n" );
%@AS@%     free( string );
%@AS@%     printf( "Memory freed\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Memory space allocated for path name
%@AS@%  Memory freed %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_freect@%%@NL@%
%@2@%%@CR:C6A01160601 @%%@AB@%_freect%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01160602 @%%@CR:C6A01160603 @% %@CR:C6A01160604 @%%@CR:C6A01160605 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Returns the amount of memory available for memory allocation.  %@NL@%
%@NL@%
%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  unsigned int _freect( size_t size );%@AE@%%@NL@%
%@NL@%
%@AI@%size%@AE@%                              Item size in bytes

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_freect%@AE@% function tells you how much memory is available for dynamic
memory allocation in the near heap. It does so by returning the approximate
number of times your program can call%@AB@% _nmalloc%@AE@% (or %@AB@%malloc%@AE@% in small data
models) to allocate an item %@AI@%size%@AE@% bytes long in the near heap (default data
segment).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_freect%@AE@% function returns the number of calls as an unsigned integer.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%calloc%@AE@% functions,%@AB@% _expand%@AE@% functions, %@AB@%malloc%@AE@% functions, %@AB@%_memavl%@AE@%, %@AB@%_msize%@AE@%
functions, %@AB@% realloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FREECT.C: This program determines how much free space is available for
%@AS@%   * integers in the default data segment. Then it allocates space for
%@AS@%   * 1,000 integers and checks the space again, using _freect.
%@AS@%   */
%@AS@%  
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int i;
%@AS@%  
%@AS@%     /* First report on the free space: */
%@AS@%     printf( "Integers (approximate) available on heap: %u\n\n",
%@AS@%             _freect( sizeof( int ) ) );
%@AS@%  
%@AS@%     /* Allocate space for 1000 integers: */
%@AS@%     for( i = 0; i < 1000; ++i )
%@AS@%        malloc( sizeof( int ) );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Report again on the free space: */
%@AS@%     printf( "After allocating space for 1000 integers:\n" );
%@AS@%     printf( "Integers (approximate) available on heap: %u\n\n",
%@AS@%             _freect( sizeof( int ) ) );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Integers (approximate) available on heap: 15212
%@AS@%  
%@AS@%  After allocating space for 1000 integers:
%@AS@%  Integers (approximate) available on heap: 14084 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:freopen@%%@NL@%
%@2@%%@CR:C6A01170606 @%%@AB@%freopen%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01170607 @%%@CR:C6A01170608 @%%@CR:C6A01170609 @% %@CR:C6A01170610 @%%@CR:C6A01170611 @%%@CR:C6A01170612 @%%@CR:C6A01170613 @% %@CR:C6A01170614 @%%@CR:C6A01170615 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Reassigns a file pointer.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  FILE *freopen( const char *filename, const char *mode, FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          Path name of new file

%@AI@%mode%@AE@%                              Type of access permitted

%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%freopen%@AE@% function closes the file currently associated with %@AI@%stream%@AE@% and
reassigns %@AI@%stream%@AE@% to the file specified by %@AI@%filename%@AE@%. The %@AB@%freopen%@AE@% function is
typically used to redirect the pre-opened files %@AB@%stdin%@AE@%, %@AB@%stdout%@AE@%, and %@AB@%stderr %@AE@%to
files specified by the user. The new file associated with%@AB@% %@AE@%%@AI@%stream%@AE@% is opened
with %@AI@%mode%@AE@%, which is a character string specifying the type of access
requested for the file, as follows: %@CR:C6A01170616 @%  %@NL@%
%@NL@%
%@AB@%Type%@AE@%                              %@AB@%Description %@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%"r"%@AE@%                               Opens for reading. If the file does not 
                                  exist or cannot be found, the %@AB@%freopen%@AE@% 
                                  call fails. 

%@AB@%"w"%@AE@%                               Opens an empty file for writing. If the 
                                  given file exists, its contents are 
                                  destroyed. 

%@AB@%"a"%@AE@%                               Opens for writing at the end of the file
                                  (appending); creates the file first if 
                                  it does not exist.

%@AB@%"r+"%@AE@%                              Opens for both reading and writing. (The
                                  file must exist.)

%@AB@%"w+"%@AE@%                              Opens an empty file for both reading and
                                  writing. If the given file exists, its 
                                  contents are destroyed.

%@AB@%"a+"%@AE@%                              Opens for reading and appending; creates
                                  the file first if it does not exist.

Use the %@AB@%"w" %@AE@%and%@AB@% "w+" %@AE@%types with care, as they can destroy existing files.  %@NL@%
%@NL@%
When a file is opened with the %@AB@%"a"%@AE@% or %@AB@%"a+"%@AE@% access type, all write operations
take place at the end of the file. Although the file pointer can be
repositioned using %@AB@%fseek%@AE@% or %@AB@%rewind%@AE@%, the file pointer is always moved back to
the end of the file before any write operation is carried out. Thus,
existing data cannot be overwritten.  %@NL@%
%@NL@%
When the %@AB@%"r+"%@AE@%, %@AB@%"w+"%@AE@%, or %@AB@%"a+"%@AE@% access type is specified, both reading and
writing are allowed (the file is said to be open for "update"). However,
when you switch between reading and writing, there must be an intervening
%@AB@%fsetpos%@AE@%, %@AB@%fseek%@AE@%, or %@AB@%rewind%@AE@% operation. The current position can be specified
for the %@AB@%fsetpos%@AE@% or %@AB@%fseek%@AE@% operation, if desired.  %@NL@%
%@NL@%
In addition to the values listed above, one of the following characters may
be included in the %@AI@%mode%@AE@% string to specify the translation mode for newlines.%@CR:C6A01170617 @%
%@NL@%
%@NL@%
%@AB@%Mode%@AE@%                              %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%t%@AE@%                                 Open in text (translated) mode; 
                                  carriage-return-line-feed
                                  (CR-LF) combinations are translated into
                                  single line-feed (LF) characters on 
                                  input; LF characters are translated to 
                                  CR-LF combinations on output. Also, 
                                  CTRL+Z is interpreted as an end-of-file 
                                  character on input. In files opened for 
                                  reading, or writing and reading, the 
                                  run-time library checks for a CTRL+Z at 
                                  the end of the file and removes it, if 
                                  possible. This is done because using the
                                  %@AB@%fseek%@AE@% and %@AB@%ftell%@AE@% functions to move within
                                  a file may cause %@AB@%fseek%@AE@% to behave 
                                  improperly near the end of the file.

%@AB@%b%@AE@%                                 Open in binary (untranslated) mode; the 
                                  above translations are suppressed.

If %@AB@%t%@AE@% or %@AB@%b%@AE@% is not given in the %@AI@%mode%@AE@% string, the translation mode is defined
by the default mode variable %@AB@%_fmode%@AE@%.  %@NL@%
%@NL@%
See Section 2.7, "Input and Output," for a discussion of text and binary
modes.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%freopen%@AE@% function returns a pointer to the newly opened file. If an error
occurs, the original file is closed and the function returns a %@AB@%NULL%@AE@% pointer
value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
The %@AB@%t%@AE@% option is not part of the ANSI standard for %@AB@%freopen%@AE@%; it is a Microsoft
extension that should not be used where ANSI portability is desired.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fclose%@AE@%, %@AB@%fcloseall%@AE@%, %@AB@%fdopen%@AE@%, %@AB@%fileno%@AE@%, %@AB@%fopen%@AE@%, %@AB@%open%@AE@%, %@AB@%setmode%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FREOPEN.C: This program reassigns stdaux to the file
%@AS@%   * named FREOPEN.OUT and writes a line to that file.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  FILE *stream;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%  
%@AS@%     /* Reassign "stdaux" to "freopen.out": */
%@AS@%     stream = freopen( "freopen.out", "w", stdaux );
%@AS@%  
%@AS@%     if( stream == NULL )
%@AS@%        fprintf( stdout, "error on freopen\n" );
%@AS@%     else
%@AS@%     {
%@AS@%        fprintf( stream, "This will go to the file 'freopen.out'\n" );
%@AS@%        fprintf( stdout, "successfully reassigned\n" );
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%     system( "type freopen.out" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  successfully reassigned
%@AS@%  This will go to the file 'freopen.out' %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:frexp@%%@QR:frexpl@%%@NL@%
%@2@%%@CR:C6A01180618 @%%@AB@%frexp, frexpl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01180619 @%%@CR:C6A01180620 @%%@CR:C6A01180621 @% %@CR:C6A01180622 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Get the mantissa and exponent of a floating-point number.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double frexp( double x, int *expptr );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double frexpl( long double x, int *expptr );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Floating-point value

%@AI@%expptr%@AE@%                            Pointer to stored integer exponent

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%frexp%@AE@% and %@AB@%frexpl%@AE@% functions break down the floating-point value (%@AI@%x%@AE@%) into
a mantissa (%@AI@%m%@AE@%) and an exponent (%@AI@%n%@AE@%), such that the absolute value of %@AI@%m%@AE@% is
greater than or equal to 0.5 and less than 1.0, and %@AI@%x%@AE@% = %@AI@%m%@AE@%%@AB@%*%@AE@%2n. The integer
exponent %@AI@%n%@AE@% is stored at the location pointed to by %@AI@%expptr%@AE@%.  %@NL@%
%@NL@%
The %@AB@%frexpl%@AE@% function is the 80-bit counterpart and uses an 80-bit, 10-byte
coprocessor form of arguments and return values. See the reference page on
the long double functions for more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return the mantissa. If %@AI@%x%@AE@% is 0, the function returns 0 for
both the mantissa and the exponent. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%frexp%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%frexpl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%ldexp%@AE@% functions, %@AB@%modf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FREXP.C: This program calculates frexp( 16.4, &n ), then displays y
%@AS@%   * and n.
%@AS@%   */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     double x, y;
%@AS@%     int n;
%@AS@%  
%@AS@%     x = 16.4;
%@AS@%     y = frexp( x, &n );
%@AS@%     printf( "frexp( %f, &n ) = %f, n = %d\n", x, y, n );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  frexp( 16.400000, &n ) = 0.512500, n = 5 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fscanf@%%@NL@%
%@2@%%@CR:C6A01190623 @%%@AB@%fscanf%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01190624 @%%@CR:C6A01190625 @% %@CR:C6A01190626 @%%@CR:C6A01190627 @% %@CR:C6A01190628 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Reads formatted data from a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fscanf( FILE *stream, const char *format [[, argument]]...  )%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@AI@%format%@AE@%                            Format-control string

%@AI@%argument%@AE@%                          Optional arguments

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fscanf%@AE@% function reads data from the current position of %@AI@%stream%@AE@% into the
locations given by %@AI@%argument%@AE@% (if any). Each argument must be a pointer to a
variable with a type that corresponds to a type specifier in %@AI@%format%@AE@%. The
format controls the interpretation of the input fields and has the same form
and function as the %@AI@%format%@AE@% argument for the %@AB@%scanf%@AE@% function; see %@AB@%scanf%@AE@% for a
description of %@AI@%format%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fscanf%@AE@% function returns the number of fields that were successfully
converted and assigned. The return value does not include fields that were
read but not assigned.  %@NL@%
%@NL@%
The return value is %@AB@%EOF%@AE@% for an error or end-of-file on %@AI@%stream%@AE@% before the
first conversion. A return value of 0 means that no fields were assigned.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cscanf%@AE@%, %@AB@%fprintf%@AE@%, %@AB@%scanf%@AE@%, %@AB@%sscanf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FSCANF.C: This program writes formatted data to a file. It
%@AS@%   * then uses fscanf to read the various data back from the file.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  FILE *stream;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     long l;
%@AS@%     float fp;
%@AS@%     char s[81];
%@AS@%     char c;
%@AS@%     int result;
%@AS@%  
%@AS@%     stream = fopen( "fscanf.out", "w+" );
%@AS@%     if( stream == NULL )
%@AS@%        printf( "The file fscanf.out was not opened\n" );
%@AS@%     else
%@AS@%     {
%@AS@%        fprintf( stream, "%s %ld %f%c", "a-string", 65000, 3.14159, 'x' );
%@AS@%  
%@AS@%        /* Set pointer to beginning of file: */
%@AS@%        fseek( stream, 0L, SEEK_SET );
%@AS@%  
%@AS@%        /* Read data back from file: */
%@AS@%        fscanf( stream, "%s", s );
%@AS@%        fscanf( stream, "%ld", &l );
%@AS@%        fscanf( stream, "%f", &fp );
%@AS@%        fscanf( stream, "%c", &c );
%@AS@%  
%@AS@%        /* Output data read: */
%@AS@%        printf( "%s\n", s );
%@AS@%        printf( "%ld\n", l );
%@AS@%        printf( "%f\n", fp );
%@AS@%        printf( "%c\n", c );
%@AS@%  
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  a-string
%@AS@%  65000
%@AS@%  3.141590
%@AS@%  x %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fseek@%%@NL@%
%@2@%%@CR:C6A01200629 @%%@AB@%fseek%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01200630 @%%@CR:C6A01200631 @% %@CR:C6A01200632 @%%@CR:C6A01200633 @% %@CR:C6A01200634 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Moves the file pointer to a specified location.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fseek( FILE *stream, long offset, int origin );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@AI@%offset%@AE@%                            Number of bytes from %@AI@%origin%@AE@%

%@AI@%origin%@AE@%                            Initial position

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fseek%@AE@% function moves the file pointer (if any) associated with %@AI@%stream%@AE@% to
a new location that is %@AI@%offset%@AE@% bytes from %@AI@%origin%@AE@%. The next operation on the
stream takes place at the new location. On a stream open for update, the
next operation can be either a read or a write.  %@NL@%
%@NL@%
The argument %@AI@%origin%@AE@% must be one of the following constants defined in
STDIO.H:  %@NL@%
%@NL@%
%@AB@%Origin%@AE@%                            %@AB@%Definition%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%SEEK_CUR%@AE@%                          Current position of file pointer

%@AB@%SEEK_END%@AE@%                          End of file

%@AB@%SEEK_SET%@AE@%                          Beginning of file

The %@AB@%fseek%@AE@% function can be used to reposition the pointer anywhere in a file.
The pointer can also be positioned beyond the end of the file. However, an
attempt to position the pointer in front of the beginning of the file causes
an error.  %@NL@%
%@NL@%
The %@AB@%fseek%@AE@% function clears the end-of-file indicator and negates the effect
of any prior %@AB@%ungetc%@AE@% calls against %@AI@%stream%@AE@%.  %@NL@%
%@NL@%
When a file is opened for appending data, the current file position is
determined by the last I/O operation, not by where the next write would
occur. If no I/O operation has yet occurred on a file opened for appending,
the file position is the start of the file.  %@NL@%
%@NL@%
For streams opened in text mode, %@AB@%fseek%@AE@% has limited use because
carriage-return-line-feed translations can cause %@AB@%fseek%@AE@% to produce unexpected
results. The only %@AB@%fseek%@AE@% operations guaranteed to work on streams opened in
text mode are the following:  %@NL@%
%@NL@%
%@NL@%
  ş   Seeking with an offset of 0 relative to any of the %@AI@%origin%@AE@% values%@NL@%
%@NL@%
  ş   Seeking from the beginning of the file with an offset value returned
      from a call to %@AB@%ftell%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, %@AB@%fseek%@AE@% returns 0. Otherwise, it returns a nonzero value. On
devices incapable of seeking, the return value is undefined.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%ftell%@AE@%, %@AB@%lseek%@AE@%, %@AB@%rewind%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FSEEK.C: This program opens the file FSEEK.OUT and
%@AS@%   * moves the pointer to the file's beginning.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE *stream;
%@AS@%     char line[81];
%@AS@%     int  result;
%@AS@%  
%@AS@%     stream = fopen( "fseek.out", "w+" );
%@AS@%     if( stream == NULL )
%@AS@%        printf( "The file fseek.out was not opened\n" );
%@AS@%     else
%@AS@%     {
%@AS@%        fprintf( stream, "The fseek begins here: "
%@AS@%                         "This is the file 'fseek.out'.\n" );
%@AS@%        result = fseek( stream, 23L, SEEK_SET);
%@AS@%        if( result )
%@AS@%           perror( "Fseek failed" );
%@AS@%        else
%@AS@%        {
%@AS@%           printf( "File pointer is set to middle of first line.\n" );
%@AS@%           fgets( line, 80, stream );
%@AS@%           printf( "%s", line );
%@AS@%        }
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  File pointer is set to middle of first line.
%@AS@%  This is the file 'fseek.out'. %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fsetpos@%%@NL@%
%@2@%%@CR:C6A01210635 @%%@AB@%fsetpos%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01210636 @%%@CR:C6A01210637 @% %@CR:C6A01210638 @%%@CR:C6A01210639 @% %@CR:C6A01210640 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the stream-position indicator.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fsetpos( FILE *stream, const fpos_t *pos ) ;%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Target stream

%@AI@%pos%@AE@%                               Position-indicator storage

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fsetpos%@AE@% function sets the file-position indicator for %@AI@%stream%@AE@% to the
value of %@AI@%pos%@AE@%, which is obtained in a prior call to %@AB@%fgetpos%@AE@% against %@AI@%stream%@AE@%.  %@NL@%
%@NL@%
The function clears the end-of-file indicator and undoes any effects of the
%@AB@%ungetc%@AE@% function on %@AI@%stream%@AE@%. After calling %@AB@%fsetpos%@AE@%, the next operation on
%@AI@%stream%@AE@% may be either input or output.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the %@AB@%fsetpos%@AE@% function returns 0. On failure, the function
returns a nonzero value and sets %@AB@%errno%@AE@% to one of the following manifest
constants (defined in ERRNO.H):  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EBADF%@AE@%                             The object that %@AI@%stream%@AE@% points to is not 
                                  a valid file handle, or the file is not 
                                  accessible.

%@AB@%EINVAL%@AE@%                            An invalid %@AI@%stream%@AE@% value was passed.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fgetpos%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FGETPOS.C: This program opens a file and reads bytes at several
%@AS@%   * different locations.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE   *stream;
%@AS@%     fpos_t pos;
%@AS@%     int    val;
%@AS@%     char   buffer[20];
%@AS@%  
%@AS@%     if( (stream = fopen( "fgetpos.c", "rb" )) == NULL )
%@AS@%        printf( "Trouble opening file\n" );
%@AS@%     else
%@AS@%     {
%@AS@%        /* Read some data and then check the position. */
%@AS@%        fread( buffer, sizeof( char ), 10, stream );
%@AS@%        if( fgetpos( stream, &pos ) != 0 )
%@AS@%           perror( "fgetpos error" );
%@AS@%        else
%@AS@%        {
%@AS@%           fread( buffer, sizeof( char ), 10, stream );
%@AS@%           printf( "10 bytes at byte %ld: %.10s\n", pos, buffer );
%@AS@%        }
%@AS@%  
%@AS@%        /* Set a new position and read more data. */
%@AS@%        pos = 140;
%@AS@%        if( fsetpos( stream, &pos ) != 0 )
%@AS@%           perror( "fsetpos error" );
%@AS@%  
%@AS@%        fread( buffer, sizeof( char ), 10, stream );
%@AS@%           printf( "10 bytes at byte %ld: %.10s\n", pos, buffer );
%@AS@%  
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  10 bytes at byte 10: .C: This p
%@AS@%  10 bytes at byte 140:   FILE   * %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_fsopen@%%@NL@%
%@2@%%@CR:C6A01220641 @%%@AB@%_fsopen%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01220642 @%%@CR:C6A01220643 @% %@CR:C6A01220644 @%%@CR:C6A01220645 @%%@CR:C6A01220646 @%%@CR:C6A01220647 @% %@CR:C6A01220648 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Opens a stream with file sharing.  %@NL@%
%@NL@%
%@AB@%#include <stdio.h>%@AE@%                

%@AB@%#include <share.h>%@AE@%                %@AI@%shflag%@AE@% constants

%@AS@%  FILE *_fsopen( const char *filename, const char *mode, int shflag );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          File name to open

%@AI@%mode%@AE@%                              Type of access permitted

%@AI@%shflag%@AE@%                            Type of sharing allowed

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_fsopen%@AE@% function opens the file specified by %@AI@%filename%@AE@% as a stream and
prepares the file for subsequent shared reading or writing, as defined by
the %@AI@%mode%@AE@% and %@AI@%shflag%@AE@% arguments.  %@NL@%
%@NL@%
The character string %@AI@%mode%@AE@% specifies the type of access requested for the
file, as follows:  %@NL@%
%@NL@%
%@AB@%Type%@AE@%                              %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%"r"%@AE@%                               Opens for reading. If the file does not 
                                  exist or cannot be found, the %@AB@%_fsopen%@AE@% 
                                  call will fail.

%@AB@%"w"%@AE@%                               Opens an empty file for writing. If the 
                                  given file exists, its contents are 
                                  destroyed. 

%@AB@%"a"%@AE@%                               Opens for writing at the end of the file
                                  (appending); creates the file first if 
                                  it does not exist.

%@AB@%"r+"%@AE@%                              Opens for both reading and writing. (The
                                  file must exist.)

%@AB@%"w+"%@AE@%                              Opens an empty file for both reading and
                                  writing. If the given file exists, its 
                                  contents are destroyed.

%@AB@%"a+"%@AE@%                              Opens for reading and appending; creates
                                  the file first if it does not exist.

Use the %@AB@%"w"%@AE@% and %@AB@%"w+"%@AE@% types with care, as they can destroy existing files.  %@NL@%
%@NL@%
When a file is opened with the %@AB@%"a"%@AE@% or %@AB@%"a+"%@AE@% access type, all write operations
occur at the end of the file. Although the file pointer can be repositioned
using %@AB@%fseek%@AE@% or%@AB@% rewind%@AE@%, the file pointer is always moved back to the end of
the file before any write operation is carried out. Thus, existing data
cannot be overwritten.  %@NL@%
%@NL@%
When the %@AB@%"r+"%@AE@%, %@AB@%"w+"%@AE@%, or %@AB@%"a+" %@AE@% access type is specified, both reading and
writing are allowed (the file is said to be open for "update"). However,
when switching between reading and writing, there must be an intervening
%@AB@%fsetpos%@AE@%, %@AB@%fseek%@AE@%, or %@AB@%rewind%@AE@% operation. The current position can be specified
for the %@AB@%fsetpos%@AE@% or %@AB@%fseek%@AE@% operation, if desired.  %@NL@%
%@NL@%
In addition to the values listed above, one of the following characters can
be included in %@AI@%mode%@AE@% to specify the translation mode for newlines: %@CR:C6A01220649 @%%@CR:C6A01220650 @%%@CR:C6A01220651 @%%@CR:C6A01220652 @%  %@NL@%
%@NL@%
%@AB@%Mode%@AE@%                              %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%t%@AE@%                                 Open in text (translated) mode. In this 
                                  mode, carriage-return-line-feed (CR-LF) 
                                  combinations are translated into single 
                                  line feeds (LF) on input and LF 
                                  characters are translated to CR-LF 
                                  combinations on output. Also, CTRL+Z is 
                                  interpreted as an end-of-file character 
                                  on input. In files opened for reading or
                                  reading/writing, %@AB@%_fsopen%@AE@% checks for a 
                                  CTRL+Z at the end of the file and 
                                  removes it, if possible. This is done 
                                  because using the %@AB@%fseek%@AE@% and %@AB@%ftell%@AE@% 
                                  functions to move within a file that 
                                  ends with a CTRL+Z may cause %@AB@%fseek%@AE@% to 
                                  behave improperly near the end of the 
                                  file.

%@AB@%b%@AE@%                                 Open in binary (untranslated) mode; the 
                                  above translations are suppressed.

If %@AB@%t%@AE@% or %@AB@%b%@AE@% is not given in %@AI@%mode%@AE@%, the translation mode is defined by the
default-mode variable %@AB@%_fmode%@AE@%. If %@AB@%t%@AE@% or %@AB@%b%@AE@% is prefixed to the argument, the
function will fail and will return %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
See Section 2.7, "Input and Output," for a discussion of text and binary
modes.  %@NL@%
%@NL@%
The argument %@AI@%shflag%@AE@% is a constant expression consisting of one of the
following manifest constants, defined in SHARE.H.  If SHARE.COM Äor
SHARE.EXE for some versions of DOSÄ is not installed, DOS ignores the
sharing mode. (See your system documentation for detailed information about
sharing modes.)  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%SH_COMPAT%@AE@%                         Sets compatibility mode (not available 
                                  in OS/2)

%@AB@%SH_DENYNO%@AE@%                         Permits read and write access

%@AB@%SH_DENYRD%@AE@%                         Denies read access to file

%@AB@%SH_DENYRW%@AE@%                         Denies read and write access to file

%@AB@%SH_DENYWR%@AE@%                         Denies write access to file

The %@AB@%_fsopen%@AE@% function should be used only under OS/2 and DOS versions 3.0 and
later. Under earlier versions of DOS, the %@AI@%shflag%@AE@% argument is ignored.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_fsopen%@AE@% function returns a pointer to the stream. A %@AB@%NULL%@AE@% pointer value
indicates an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fclose%@AE@%, %@AB@%fcloseall%@AE@%, %@AB@%fdopen%@AE@%, %@AB@%ferror%@AE@%, %@AB@%fileno%@AE@%, %@AB@%fopen%@AE@%, %@AB@%freopen%@AE@%, %@AB@%open%@AE@%, %@AB@%setmode%@AE@%,
%@AB@%sopen%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FSOPEN.C: This program opens files named "data" and "data2". It uses
%@AS@%   * fclose to close "data" and fcloseall to close all remaining files.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <share.h>
%@AS@%  
%@AS@%  FILE *stream;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE *stream;
%@AS@%  
%@AS@%     /* Open output file for writing. Using _fsopen allows us to ensure
%@AS@%      * that no one else writes to the file while we are writing to it.
%@AS@%      */
%@AS@%     if( (stream = _fsopen( "outfile", "wt", SH_DENYWR )) != NULL )
%@AS@%     {
%@AS@%        fprintf( stream, "No one else in the network can write "
%@AS@%                         "to this file until we are done.\n" );
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%     /* Now others can write to the file while we read it. */
%@AS@%     system( "type outfile" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  No one else in the network can write to this file until we are done. %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fstat@%%@NL@%
%@2@%%@CR:C6A01230653 @%%@AB@%fstat%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01230654 @%%@CR:C6A01230655 @%%@CR:C6A01230656 @% %@CR:C6A01230657 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets information about an open file.  %@NL@%
%@NL@%
%@AS@%  #include <sys\types.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <sys\stat.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int fstat( int handle, struct stat *buffer );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Handle of open file

%@AI@%buffer%@AE@%                            Pointer to structure to store results

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fstat%@AE@% function obtains information about the open file associated with
%@AI@%handle%@AE@% and stores it in the structure pointed to by %@AI@%buffer%@AE@%. The structure,
whose type %@AB@%stat%@AE@% is defined in SYS\STAT.H, contains the following fields:   %@CR:C6A01230658 @%
%@NL@%
%@NL@%
%@AB@%Field%@AE@%                             %@AB@%Value%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%st_atime%@AE@%                          Time of last modification of file (same 
                                  as %@AB@%st_mtime%@AE@% and %@AB@%st_ctime%@AE@%).

%@AB@%st_ctime%@AE@%                          Time of last modification of file (same 
                                  as %@AB@%st_atime%@AE@% and %@AB@%st_mtime%@AE@%).

%@AB@%st_dev%@AE@%                            Either the drive number of the disk 
                                  containing the file, or %@AI@%handle%@AE@% in the 
                                  case of a device (same as %@AB@%st_rdev%@AE@%).

%@AB@%st_mode%@AE@%                           Bit mask for file-mode information. The %@AB@%%@AE@%
                                  %@AB@%S_IFCHR%@AE@% bit is set if%@AI@%%@AE@%
                                  %@AI@%handle%@AE@% refers to a device. The %@AB@%S_IFREG%@AE@% 
                                  bit is set if %@AI@%handle%@AE@% refers to an 
                                  ordinary file. The read/write bits are 
                                  set according to the file's permission 
                                  mode. (%@AB@%S_IFCHR%@AE@% and other constants are 
                                  defined in SYS\ STAT.H.)

%@AB@%st_mtime%@AE@%                          Time of last modification of file (same 
                                  as %@AB@%st_atime%@AE@% and %@AB@%st_ctime%@AE@%).

%@AB@%st_nlink%@AE@%                          Always 1.

%@AB@%st_rdev%@AE@%                           Either the drive number of the disk 
                                  containing the file, or %@AI@%handle%@AE@% in the 
                                  case of a device (same as %@AB@%st_dev%@AE@%).

%@AB@%st_size%@AE@%                           Size of the file in bytes.

If %@AI@%handle%@AE@% refers to a device, the size and time fields in the %@AB@%stat %@AE@%structure
are not meaningful.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fstat%@AE@% function returns the value 0 if the file-status information is
obtained. A return value of -1 indicates an error; in this case, %@AB@%errno%@AE@% is
set to %@AB@%EBADF%@AE@%, indicating an invalid file handle.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
In OS/2, the %@AB@%st_dev%@AE@% field does not contain meaningful information. In fact,
it is set to zero. OS/2 provides no way to recover the host drive from just
the open file handle.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%access, chmod, filelength%@AE@%, %@AB@%stat%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FSTAT.C: This program uses fstat to report the size of a file
%@AS@%   * named FSTAT.OUT.
%@AS@%   */
%@AS@%  
%@AS@%  #include <io.h>
%@AS@%  #include <fcntl.h>
%@AS@%  #include <time.h>
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <string.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct stat buf;
%@AS@%     int fh, result;
%@AS@%     char buffer[] = "A line to output";
%@AS@%  
%@AS@%     if( (fh = open( "fstat.out", O_CREAT | O_WRONLY | O_TRUNC )) == -1 )
%@AS@%        exit( 1 );
%@AS@%     write( fh, buffer, strlen( buffer ) );
%@AS@%  
%@AS@%     /* Get data associated with "fh": */
%@AS@%  
%@AS@%     result = fstat( fh, &buf );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Check if statistics are valid: */
%@AS@%     if( result != 0 )
%@AS@%        printf( "Bad file handle\n" );
%@AS@%     else
%@AS@%     {
%@AS@%        printf( "File size     : %ld\n", buf.st_size );
%@AS@%        printf( "Drive number  : %d\n", buf.st_dev );
%@AS@%        printf( "Time modified : %s", ctime( &buf.st_atime ) );
%@AS@%     }
%@AS@%     close( fh );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  File size     : 16
%@AS@%  Drive number  : 0
%@AS@%  Time modified : Thu Jun 15 21:38:46 1989 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ftell@%%@NL@%
%@2@%%@CR:C6A01240659 @%%@AB@%ftell%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01240660 @%%@CR:C6A01240661 @% %@CR:C6A01240662 @%%@CR:C6A01240663 @% %@CR:C6A01240664 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current position of a file pointer.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  long ftell( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Target %@AB@%FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ftell%@AE@% function gets the current position of the file pointer (if any)
associated with %@AI@%stream%@AE@%. The position is expressed as an offset relative to
the beginning of the stream.  %@NL@%
%@NL@%
Note that when a file is opened for appending data, the current file
position is determined by the last I/O operation, not by where the next
write would occur. For example, if a file is opened for an append and the
last operation was a read, the file position is the point where the next
read operation would start, not where the next write would start. (When a
file is opened for appending, the file position is moved to end-of-file
before any write operation.) If no I/O operation has yet occurred on a file
opened for appending, the file position is the beginning of the file.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ftell%@AE@% function returns the current file position. The value returned by
%@AB@%ftell%@AE@% may not reflect the physical byte offset for streams opened in text
mode, since text mode causes carriage-return-line-feed translation. Use
%@AB@%ftell%@AE@% in conjunction with the %@AB@%fseek%@AE@% function to return to file locations
correctly. On error, the function returns -1L and %@AB@%errno%@AE@% is set to one of the
following constants, defined in ERRNO.H:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EBADF%@AE@%                             Bad file number. The %@AI@%stream%@AE@% argument is 
                                  not a valid file-handle value or does 
                                  not refer to an open file.

%@AB@%EINVAL%@AE@%                            Invalid argument. An invalid %@AI@%stream%@AE@% 
                                  argument was passed to the function.

On devices incapable of seeking (such as terminals and printers), or when
%@AI@%stream%@AE@% does not refer to an open file, the return value is undefined.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fgetpos%@AE@%, %@AB@%fseek%@AE@%, %@AB@%lseek%@AE@%, %@AB@%tell%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FTELL.C: This program opens a file named FTELL.C for reading and
%@AS@%   * tries to read 100 characters. It then uses ftell to determine the
%@AS@%   * position of the file pointer and displays this position.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  FILE *stream;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     long position;
%@AS@%     char list[100];
%@AS@%  
%@AS@%     if( (stream = fopen( "ftell.c", "rb" )) != NULL )
%@AS@%     {
%@AS@%        /* Move the pointer by reading data: */
%@AS@%        fread( list, sizeof( char ), 100, stream );
%@AS@%  
%@AS@%        /* Get position after read: */
%@AS@%        position = ftell( stream );
%@AS@%        printf( "Position after trying to read 100 bytes: %ld\n", position
%@AS@%);
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Position after trying to read 100 bytes: 100 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ftime@%%@NL@%
%@2@%%@CR:C6A01250665 @%%@AB@%ftime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01250666 @%%@CR:C6A01250667 @%%@CR:C6A01250668 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current time.  %@NL@%
%@NL@%
%@AS@%  #include <sys\types.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <sys\timeb.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void ftime( struct timeb *timeptr );%@AE@%%@NL@%
%@NL@%
%@AI@%timeptr%@AE@%                           Pointer to structure defined in 
                                  SYS\TIMEB.H

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ftime%@AE@% function gets the current time and stores it in the structure
pointed to by %@AI@%timeptr%@AE@%. The %@AB@%timeb%@AE@% structure is defined in SYS\TIMEB.H. It
contains four fields (%@AB@%dstflag%@AE@%, %@AB@%millitm%@AE@%, %@AB@%time%@AE@%, and %@AB@%timezone%@AE@%), which have the
following values: %@CR:C6A01250669 @%%@CR:C6A01250670 @%  %@NL@%
%@NL@%
%@AB@%Field%@AE@%                             %@AB@%Value%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%dstflag%@AE@%                           Nonzero if daylight saving time is 
                                  currently in effect for the local time 
                                  zone. (See %@AB@%tzset%@AE@% for an explanation of 
                                  how daylight saving time is determined.)

%@AB@%millitm%@AE@%                           Fraction of a second in milliseconds. 
                                  The last digit is always 0 since %@AB@%millitm%@AE@%
                                  is incremented to the nearest 
                                  one-hundredth of a second.

%@AB@%time%@AE@%                              Time in seconds since 00:00:00 Greenwich
                                  mean time, January 1, 1970.

%@AB@%timezone%@AE@%                          Difference in minutes, moving westward, 
                                  between Greenwich mean time and local 
                                  time. The value of %@AB@%timezone%@AE@% is set from 
                                  the value of the global variable %@AB@%%@AE@%
                                  %@AB@%timezone%@AE@% (see %@AB@%tzset%@AE@%).

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ftime%@AE@% function gives values to the fields in the structure pointed to by
%@AI@%timeptr%@AE@%. It does not return a value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asctime%@AE@%, %@AB@%ctime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%time%@AE@%, %@AB@%tzset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FTIME.C: This program uses ftime to obtain the current time
%@AS@%   * and then stores this time in timebuffer.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <sys\timeb.h>
%@AS@%  #include <time.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%  
%@AS@%     struct timeb timebuffer;
%@AS@%     char *timeline;
%@AS@%  
%@AS@%     ftime( &timebuffer );
%@AS@%     timeline = ctime( & ( timebuffer.time ) );
%@AS@%  
%@AS@%     printf( "The time is %.19s.%hu %s",
%@AS@%             timeline, timebuffer.millitm, &timeline[20] );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The time is Thu Jun 15 21:40:34.870 1989 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_fullpath@%%@NL@%
%@2@%%@CR:C6A01260671 @%%@AB@%_fullpath%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01260672 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Makes an absolute path name from a relative path name.  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char *_fullpath( char *buffer, const char *pathname, size_t maxlen );%@AE@%%@NL@%
%@NL@%
%@AI@%buffer%@AE@%                            Full path-name buffer

%@AI@%pathname%@AE@%                          Relative path name

%@AI@%maxlen%@AE@%                            Length of the buffer pointed to by %@AI@%%@AE@%
                                  %@AI@%buffer%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_fullpath%@AE@% routine converts the partial path stored in %@AI@%pathname%@AE@% to a
fully qualified path that is stored in %@AI@%buffer%@AE@%. Unlike %@AB@%_makepath%@AE@%, the
%@AB@%_fullpath%@AE@% routine can be used with %@AB@%.\%@AE@% and %@AB@%..\%@AE@% in the path.  %@NL@%
%@NL@%
If the length of the fully qualified path is greater than the value of
%@AI@%maxlen%@AE@%, then %@AB@%NULL%@AE@% is returned; otherwise, the address of %@AI@%buffer%@AE@% is returned.
%@NL@%
%@NL@%
If the %@AI@%buffer%@AE@% is %@AB@%NULL%@AE@%, %@AB@%_fullpath%@AE@% will allocate a buffer of %@AB@%MAX_PATH%@AE@% size and
the %@AI@%maxlen%@AE@% argument is ignored.  %@NL@%
%@NL@%
If the %@AI@%pathname%@AE@% argument specifies a disk drive, the current directory of
this drive is combined with the path. If the drive is not valid, %@AB@%_fullpath%@AE@%
returns %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_fullpath%@AE@% function returns a pointer to the buffer containing the
absolute path (%@AI@%buffer%@AE@%). If there is an error, %@AB@%_fullpath%@AE@% returns %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%getcwd%@AE@%, %@AB@% _getdcwd%@AE@%, %@AB@% _makepath%@AE@%,  %@AB@%_splitpath%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FULLPATH.C: This program demonstrates how _fullpath creates a full
%@AS@%   * path from a partial path.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <direct.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char full[_MAX_PATH], part[_MAX_PATH];
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%      while( 1 )
%@AS@%      {
%@AS@%          printf( "Enter partial path or ENTER to quit: " );
%@AS@%          gets( part );
%@AS@%          if( part[0] == 0 )
%@AS@%              break;
%@AS@%  
%@AS@%          if( _fullpath( full, part, _MAX_PATH ) != NULL )
%@AS@%              printf( "Full path is: %s\n", full );
%@AS@%          else
%@AS@%              printf( "Invalid path\n" );
%@AS@%      }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Enter partial path or ENTER to quit: ..
%@AS@%  Full path is: C:\
%@AS@%  Enter partial path or ENTER to quit: ..\include
%@AS@%  Full path is: C:\include
%@AS@%  Enter partial path or ENTER to quit: p:
%@AS@%  Full path is: P:\
%@AS@%  Enter partial path or ENTER to quit: fullpath.c
%@AS@%  Full path is: C:\LIBREF\fullpath.c
%@AS@%  Enter partial path or ENTER to quit: %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:fwrite@%%@NL@%
%@2@%%@CR:C6A01270673 @%%@AB@%fwrite%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01270674 @%%@CR:C6A01270675 @% %@CR:C6A01270676 @%%@CR:C6A01270677 @% %@CR:C6A01270678 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Writes data to a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream
%@AS@%  );%@AE@%%@NL@%
%@NL@%
%@AI@%buffer%@AE@%                            Pointer to data to be written

%@AI@%size%@AE@%                              Item size in bytes

%@AI@%count%@AE@%                             Maximum number of items to be written

%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fwrite%@AE@% function writes up to %@AI@%count%@AE@% items, of length %@AI@%size%@AE@% each, from
%@AI@%buffer%@AE@% to the output %@AI@%stream%@AE@%. The file pointer associated with %@AI@%stream%@AE@% (if
there is one) is incremented by the number of bytes actually written.  %@NL@%
%@NL@%
If %@AI@%stream%@AE@% is opened in text mode, each carriage return is replaced with a
carriage-return-line-feed pair. The replacement has no effect on the return
value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%fwrite%@AE@% function returns the number of full items actually written, which
may be less than %@AI@%count%@AE@% if an error occurs. Also, if an error occurs, the
file-position indicator cannot be determined.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fread%@AE@%, %@AB@%write%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* FREAD.C: This program opens a file named FREAD.OUT and writes 25
%@AS@%   * characters to the file. It then tries to open FREAD.OUT and
%@AS@%   * read in 25 characters. If the attempt succeeds, the program
%@AS@%   * displays the number of actual items read.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE *stream;
%@AS@%     char list[30];
%@AS@%     int  i, numread, numwritten;
%@AS@%  
%@AS@%     /* Open file in text mode: */
%@AS@%     if( (stream = fopen( "fread.out", "w+t" )) != NULL )
%@AS@%     {
%@AS@%        for ( i = 0; i < 25; i++ )
%@AS@%           list[i] = 'z' - i;
%@AS@%        /* Write 25 characters to stream */
%@AS@%        numwritten = fwrite( list, sizeof( char ), 25, stream );
%@AS@%        printf( "Wrote %d items\n", numwritten );
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%     else
%@AS@%        printf( "Problem opening the file\n" );
%@AS@%  
%@AS@%     if( (stream = fopen( "fread.out", "r+t" )) != NULL )
%@AS@%     {
%@AS@%        /* Attempt to read in 25 characters */
%@AS@%        numread = fread( list, sizeof( char ), 25, stream );
%@AS@%        printf( "Number of items read = %d\n", numread );
%@AS@%        printf( "Contents of buffer = %.25s\n", list );
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%     else
%@AS@%        printf( "Was not able to open the file\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Wrote 25 items
%@AS@%  Number of items read = 25
%@AS@%  Contents of buffer = zyxwvutsrqponmlkjihgfedcb %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:gcvt@%%@NL@%
%@2@%%@CR:C6A01280679 @%%@AB@%gcvt%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01280680 @%%@CR:C6A01280681 @% %@CR:C6A01280682 @% %@CR:C6A01280683 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Converts a floating-point value to a string, which it stores in a buffer.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AS@%  char *gcvt( double value, int digits, char *buffer );%@AE@%%@NL@%
%@NL@%
%@AI@%value%@AE@%                             Value to be converted

%@AI@%digits%@AE@%                            Number of significant digits stored

%@AI@%buffer%@AE@%                            Storage location for result

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%gcvt%@AE@% function converts a floating-point %@AI@%value%@AE@% to a character string and
stores the string in %@AI@%buffer%@AE@%. The %@AI@%buffer%@AE@% should be large enough to
accommodate the converted value plus a terminating null character (%@AB@%'\0'%@AE@%),
which is appended automatically. There is no provision for overflow.  %@NL@%
%@NL@%
The %@AB@%gcvt%@AE@% function attempts to produce %@AI@%digits%@AE@% significant digits in decimal
format. If this is not possible, it produces %@AI@%digits%@AE@% significant digits in
exponential format. Trailing zeros may be suppressed in the conversion.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%gcvt%@AE@% function returns a pointer to the string of digits. There is no
error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%atof%@AE@%, %@AB@%atoi%@AE@%, %@AB@%atol%@AE@%, %@AB@%ecvt%@AE@%, %@AB@%fcvt%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GCVT.C: This program converts -3.1415e5 to its string representation.
%@AS@%  */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[50];
%@AS@%     double source = -3.1415e5;
%@AS@%  
%@AS@%     gcvt( source, 7, buffer );
%@AS@%     printf( "source: %f  buffer: '%s'\n", source, buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  source: -314150.000000  buffer: '-314150.' %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getactivepage@%%@NL@%
%@2@%%@CR:C6A01290684 @%%@AB@%_getactivepage%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current active page number.  %@NL@%
%@NL@%
%@CR:C6A01290685 @%%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _getactivepage( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getactivepage%@AE@% function returns the number of the current active page.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the number of the current active page. All hardware
combinations support at least one page (page number 0). In OS/2, only page 0
is valid.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getactivepage%@AE@%,  %@AB@%_getvideoconfig%@AE@%,  %@AB@%_getvisualpage%@AE@%,  %@AB@%_grstatus%@AE@%,
%@AB@%_setactivepage%@AE@%, %@AB@%_setvideomode%@AE@%,  %@AB@%_setvisualpage%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PAGE.C illustrates video page functions including:
%@AS@%   *      _getactivepage  _getvisualpage  _setactivepage  _setvisualpage
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short  oldvpage, oldapage, page, row, col, line;
%@AS@%     struct videoconfig vc;
%@AS@%     char   buf[80];
%@AS@%  
%@AS@%     _getvideoconfig( &vc );
%@AS@%     if( vc.numvideopages < 4 )
%@AS@%         exit( 1 );              /* Fail for OS/2 or monochrome. */
%@AS@%     oldapage  = _getactivepage();
%@AS@%     oldvpage  = _getvisualpage();
%@AS@%     _displaycursor( _GCURSOROFF );
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  /* Draw arrows in different place on each page. */
%@AS@%     for( page = 1; page < 4; page++ )
%@AS@%     {
%@AS@%        _setactivepage( page );
%@AS@%        _settextposition( 12, 16 * page );
%@AS@%        _outtext( ">>>>>>>>" );
%@AS@%     }
%@AS@%  
%@AS@%     while( !kbhit() )
%@AS@%        /* Cycle through pages 1 to 3 to show moving image. */
%@AS@%        for( page = 1; page < 4; page++ )
%@AS@%            _setvisualpage( page );
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Restore original page (normally 0) to restore screen. */
%@AS@%     _setactivepage( oldapage );
%@AS@%     _setvisualpage( oldvpage );
%@AS@%     _displaycursor( _GCURSORON );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getarcinfo@%%@NL@%
%@2@%%@CR:C6A01300686 @%%@AB@%_getarcinfo%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01300687 @% %@CR:C6A01300688 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Determines the endpoints in viewport coordinates of the most recently drawn
arc or pie.  %@NL@%
%@NL@%
%@AS@%  #include  <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _getarcinfo( struct xycoord _far *start, struct xycoord _far
%@AS@%  *end, 
%@AS@%  struct xycoord _far *fillpoint );%@AE@%%@NL@%
%@NL@%
%@AI@%start%@AE@%                             Starting point of arc

%@AI@%end%@AE@%                               Ending point of arc

%@AI@%fillpoint%@AE@%                         Point at which pie fill will begin

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getarcinfo%@AE@% function determines the endpoints in viewport coordinates of
the most recently drawn arc or pie.  %@NL@%
%@NL@%
If successful, the %@AB@%_getarcinfo%@AE@% function updates the %@AI@%start%@AE@% and %@AI@%end%@AE@% %@AB@%xycoord%@AE@%
structures to contain the endpoints (in viewport coordinates) of the arc
drawn by the most recent call to one of the %@AB@%_arc%@AE@% or %@AB@%_pie%@AE@% functions.  %@NL@%
%@NL@%
In addition, %@AI@%fillpoint%@AE@% specifies a point from which a pie can be filled.
This is useful for filling a pie in a color different from the border color.
After a call to %@AB@%_getarcinfo%@AE@%, change colors using the %@AB@%_setcolor %@AE@%function. Use
the color, along with the coordinates in %@AI@%fillpoint%@AE@%, as arguments for the
%@AI@%floodfill%@AE@% function.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getarcinfo%@AE@% function returns a nonzero value if successful. If neither
the %@AB@%_arc%@AE@% nor the %@AB@%_pie%@AE@% function has been successfully called since the last
time the screen was cleared or a new graphics mode or viewport was selected,
the %@AB@%_getarcinfo%@AE@% function returns 0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_arc%@AE@% functions,  %@AB@%_floodfill%@AE@%,  %@AB@%_getvideoconfig%@AE@%,  %@AB@%_grstatus%@AE@%,  %@AB@%_pie%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_arc%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getbkcolor@%%@NL@%
%@2@%%@CR:C6A01310689 @%%@AB@%_getbkcolor%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current background color.  %@NL@%
%@NL@%
%@CR:C6A01310690 @%%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  long _far _getbkcolor( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getbkcolor%@AE@% function returns the current background color. The default
is 0.  %@NL@%
%@NL@%
In a color text mode such as %@AB@%_TEXTC80%@AE@%, %@AB@%_setbkcolor%@AE@% accepts, and %@AB@%_getbkcolor%@AE@%
returns, a color index. For example, %@AB@%_setbkcolor(2L)%@AE@% sets the background
color to color index 2. The actual color displayed depends on the palette
mapping for color index 2. The default for color index 2 is green in a color
text mode.  %@NL@%
%@NL@%
In a color graphics mode such as %@AB@%_ERESCOLOR%@AE@%, %@AB@%_setbkcolor%@AE@% accepts and
%@AB@%_getbkcolor%@AE@% returns a color value (as used in %@AB@%_remappalette%@AE@%). The value for
the simplest background colors is given by the manifest constants defined in
the GRAPH.H include file. For example, %@AB@%_setbkcolor( _GREEN)%@AE@% sets the
background color in a graphics mode to green. These manifest constants are
provided as a convenience in defining and manipulating the most common
colors. In general, the actual range of colors is much greater.  %@NL@%
%@NL@%
In most cases, whenever an argument is long, it refers to a color value, and
whenever it is short, it refers to a color index. The two exceptions are
%@AB@%_setbkcolor%@AE@% and %@AB@%_getbkcolor%@AE@%, described above. For a more complete discussion
of colors, see %@AB@%_remappalette%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the current background color value. There is no error
return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_remappalette%@AE@%,  %@AB@%_setbkcolor%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_getcolor%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:getc@%%@QR:getchar@%%@NL@%
%@2@%%@CR:C6A01320691 @%%@AB@%getc, getchar%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Reads a character from a stream (%@AB@%getc%@AE@%), or gets a character from %@AB@%stdin%@AE@%
(%@AB@%getchar%@AE@%).%@CR:C6A01320692 @%%@CR:C6A01320693 @%%@CR:C6A01320694 @%%@CR:C6A01320695 @%%@CR:C6A01320696 @%%@CR:C6A01320697 @%  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int getc( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AS@%  int getchar( void );%@AE@%%@NL@%
%@NL@%
%@AI@%stream %@AE@%                           Current stream

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getc%@AE@% macro reads a single character from the %@AI@%stream%@AE@% position and
increments the associated file pointer (if there is one) to point to the
next character. The %@AB@%getchar%@AE@% macro is identical to %@AB@%getc%@AE@%(%@AB@%stdin%@AE@%).  %@NL@%
%@NL@%
The %@AB@%getc%@AE@% and %@AB@%getchar%@AE@% routines are similar to %@AB@%fgetc%@AE@% and %@AB@%fgetchar%@AE@%,
respectively, but are macros rather than functions.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getc%@AE@% and %@AB@%getchar%@AE@% macros return the character read. A return value of %@AB@%EOF%@AE@%
indicates an error or end-of-file condition. Use %@AB@%ferror%@AE@% or %@AB@%feof%@AE@% to determine
whether an error or end-of-file occurred.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%getc%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%getchar%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fgetc%@AE@%, %@AB@%fgetchar%@AE@%, %@AB@%getch%@AE@%, %@AB@%getche%@AE@%, %@AB@%putc%@AE@%, %@AB@%putchar%@AE@%, %@AB@%ungetc%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GETC.C: This program uses getchar to read a single line of input
%@AS@%   * from stdin, places this input in buffer, then terminates the
%@AS@%   * string before printing it to the screen.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[81];
%@AS@%     int i, ch;
%@AS@%  
%@AS@%     printf( "Enter a line: " );
%@AS@%  
%@AS@%     /* Read in single line from "stdin": */
%@AS@%     for( i = 0; (i < 80) &&  ((ch = getchar()) != EOF) && (ch != '\n'); i++
%@AS@%)
%@AS@%        buffer[i] = ch;
%@AS@%  
%@AS@%     /* Terminate string with null character: */
%@AS@%     buffer[i] = '\0';
%@AS@%     printf( "%s\n", buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Enter a line: This is a line of text.
%@AS@%  This is a line of text. %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:getch@%%@QR:getche@%%@NL@%
%@2@%%@CR:C6A01330698 @%%@AB@%getch, getche%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Get a character from the console without echo (%@AB@%getch%@AE@%) or with echo (%@AB@%getche%@AE@%).
%@NL@%
%@NL@%
%@CR:C6A01330699 @%%@CR:C6A01330700 @%%@CR:C6A01330701 @%%@CR:C6A01330702 @%  %@NL@%
%@NL@%
%@AB@%#include <conio.h> %@AE@%               Required only for function declarations

%@AS@%  int getch( void );%@AE@%%@NL@%
%@NL@%
%@AS@%  int getche( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getch%@AE@% function reads a single character from the console without
echoing. The %@AB@%getche%@AE@% function reads a single character from the console and
echoes the character read. Neither function can be used to read CTRL+C.  %@NL@%
%@NL@%
When reading a function key or cursor-moving key, the %@AB@%getch%@AE@% and %@AB@%getche%@AE@%
functions must be called twice; the first call returns 0 or 0xE0, and the
second call returns the actual key code.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getch%@AE@% function returns the character read. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cgets%@AE@%, %@AB@%getchar%@AE@%, %@AB@%ungetch%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GETCH.C: This program reads characters from the keyboard until it
%@AS@%   * receives a 'Y' or 'y'.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <ctype.h>
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     int ch;
%@AS@%  
%@AS@%     cputs( "Type 'Y' when finished typing keys: " );
%@AS@%     do
%@AS@%     {
%@AS@%        ch = getch();
%@AS@%        ch = toupper( ch );
%@AS@%     } while( ch != 'Y' );
%@AS@%  
%@AS@%     putch( ch );
%@AS@%     putch( '\r' );    /* Carriage return */
%@AS@%     putch( '\n' );    /* Line feed       */
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Type 'Y' when finished typing keys: Y%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getcolor@%%@NL@%
%@2@%%@CR:C6A01340703 @%%@AB@%_getcolor%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current color.  %@NL@%
%@NL@%
%@CR:C6A01340704 @%%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _getcolor( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getcolor%@AE@% function returns the current graphics color index. The default
is the highest legal value of the current palette.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getcolor%@AE@% function returns the current color index.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_setcolor%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* OUTTXT.C: This example illustrates text output functions:
%@AS@%   *    _gettextcolor   _getbkcolor   _gettextposition   _outtext
%@AS@%   *    _settextcolor   _setbkcolor   _settextposition
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  char buffer [80];
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%  
%@AS@%     /* Save original foreground, background, and text position. */
%@AS@%     short blink, fgd, oldfgd;
%@AS@%     long  bgd, oldbgd;
%@AS@%     struct rccoord oldpos;
%@AS@%  
%@AS@%     /* Save original foreground, background, and text position. */
%@AS@%     oldfgd = _gettextcolor();
%@AS@%     oldbgd = _getbkcolor();
%@AS@%     oldpos = _gettextposition();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  /* First time no blink, second time blinking. */
%@AS@%     for( blink = 0; blink <= 16; blink += 16 )
%@AS@%     {
%@AS@%        /* Loop through 8 background colors. */
%@AS@%        for( bgd = 0; bgd < 8; bgd++ )
%@AS@%        {
%@AS@%           _setbkcolor( bgd );
%@AS@%           _settextposition( (short)bgd + ((blink / 16) * 9) + 3, 1 );
%@AS@%           _settextcolor( 7 );
%@AS@%           sprintf(buffer, "Back: %d Fore:", bgd );
%@AS@%           _outtext( buffer );
%@AS@%  
%@AS@%           /* Loop through 16 foreground colors. */
%@AS@%           for( fgd = 0; fgd < 16; fgd++ )
%@AS@%           {
%@AS@%              _settextcolor( fgd + blink );
%@AS@%              sprintf( buffer, " %2d ", fgd + blink );
%@AS@%              _outtext( buffer );
%@AS@%           }
%@AS@%        }
%@AS@%     }
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Restore original foreground, background, and text position. */
%@AS@%     _settextcolor( oldfgd );
%@AS@%     _setbkcolor( oldbgd );
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%     _settextposition( oldpos.row, oldpos.col );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getcurrentposition@%%@NL@%
%@2@%%@CR:C6A01350705 @%%@AB@%_getcurrentposition Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description %@CR:C6A01350706 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Get the current position and return it as a structure.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct xycoord _far _getcurrentposition( void );%@AE@%%@NL@%
%@NL@%
%@AS@%  struct _wxycoord _far _getcurrentposition_w( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getcurrentposition%@AE@% functions return the coordinates of the current
graphics output position. The %@AB@%_getcurrentposition%@AE@% function returns the
position as an %@AB@%xycoord%@AE@% structure, defined in GRAPH.H.  %@NL@%
%@NL@%
The %@AB@%xycoord%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%short xcoord%@AE@%                      %@AI@%x%@AE@% coordinate

%@AB@%short ycoord%@AE@%                      %@AI@%y%@AE@% coordinate

The %@AB@%_getcurrentposition_w%@AE@% function returns the position as an %@AB@%_wxycoord%@AE@%
structure, defined in GRAPH.H.  %@NL@%
%@NL@%
The %@AB@%_wxycoord%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%double wx%@AE@%                         window%@AI@% x%@AE@% coordinate

%@AB@%double wy%@AE@%                         window%@AI@% y%@AE@% coordinate

The current position can be changed by the %@AB@%_lineto%@AE@%, %@AB@%_moveto%@AE@%, and %@AB@%_outgtext%@AE@%
functions.  %@NL@%
%@NL@%
The default position, set by %@AB@%_setvideomode%@AE@%, %@AB@%_setvideomoderows%@AE@%, or
%@AB@%_setviewport%@AE@%, is the center of the viewport.  %@NL@%
%@NL@%
Only graphics output starts at the current position; these functions do not
affect text output, which begins at the current text position. (See
%@AB@%_settextposition%@AE@% for more information.)  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getcurrentposition%@AE@% function returns the coordinates of the current
graphics output position. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_grstatus%@AE@%,  %@AB@%_lineto%@AE@% functions,  %@AB@%_moveto%@AE@% functions,  %@AB@%_outgtext%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GCURPOS.C: This program sets a random current location, then gets that
%@AS@%   * location with _getcurrentposition.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  char   buffer[255];
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct videoconfig vc;
%@AS@%     struct xycoord position;
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%     _getvideoconfig( &vc );
%@AS@%  
%@AS@%     /* Move to random location and report that location. */
%@AS@%     _moveto( rand() % vc.numxpixels, rand() % vc.numypixels );
%@AS@%     position = _getcurrentposition();
%@AS@%     sprintf( buffer, "x = %d, y = %d", position.xcoord, position.ycoord );
%@AS@%     _settextposition( 1, 1 );
%@AS@%     _outtext( buffer );
%@AS@%  
%@AS@%     getch();
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:getcwd@%%@NL@%
%@2@%%@CR:C6A01360707 @%%@AB@%getcwd%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01360708 @%%@CR:C6A01360709 @% %@CR:C6A01360710 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current working directory.  %@NL@%
%@NL@%
%@AB@%#include <direct.h>%@AE@%               Required only for function declarations

%@AS@%  char *getcwd( char *buffer, int maxlen );%@AE@%%@NL@%
%@NL@%
%@AI@%buffer%@AE@%                            Storage location for path name

%@AI@%maxlen%@AE@%                            Maximum length of path name

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getcwd%@AE@% function gets the full path name of the current working directory
and stores it at %@AI@%buffer%@AE@%. The integer argument %@AI@%maxlen%@AE@% specifies the maximum
length for the path name. An error occurs if the length of the path name
(including the terminating null character) exceeds %@AI@%maxlen.%@AE@%  %@NL@%
%@NL@%
The %@AI@%buffer%@AE@% argument can be %@AB@%NULL%@AE@%; a buffer of at least size %@AI@%maxlen%@AE@% (more only
if necessary) will automatically be allocated, using %@AB@%malloc%@AE@%, to store the
path name. This buffer can later be freed by calling %@AB@%free%@AE@% and passing it the
%@AB@%getcwd%@AE@% return value (a pointer to the allocated buffer).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getcwd%@AE@% function returns a pointer to %@AI@%buffer%@AE@%. A %@AB@%NULL%@AE@% return value
indicates an error, and %@AB@%errno%@AE@% is set to one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%ENOMEM%@AE@%                            Insufficient memory to allocate %@AI@%maxlen%@AE@% 
                                  bytes (when a %@AB@%NULL%@AE@% argument is given as %@AI@%%@AE@%
                                  %@AI@%buffer%@AE@%)

%@AB@%ERANGE%@AE@%                            Path name longer than %@AI@%maxlen%@AE@% characters

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%chdir%@AE@%, %@AB@%mkdir%@AE@%, %@AB@%rmdir%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* This program places the name of the current directory in the buffer
%@AS@%   * array, then displays the name of the current directory on the screen.
%@AS@%   * Specifying a length of _MAX_DIR leaves room for the longest legal
%@AS@%   * directory name.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <direct.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[_MAX_DIR];
%@AS@%  
%@AS@%     /* Get the current working directory: */
%@AS@%     if( getcwd( buffer, _MAX_DIR ) == NULL )
%@AS@%        perror( "getcwd error" );
%@AS@%     else
%@AS@%        printf( "%s\n", buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  C:\LIBREF %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getdcwd@%%@NL@%
%@2@%%@CR:C6A01370711 @%%@AB@%_getdcwd%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01370712 @%%@CR:C6A01370713 @% %@CR:C6A01370714 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets full path name of current working directory, including disk drive.  %@NL@%
%@NL@%
%@AB@%#include <direct.h>%@AE@%               Required only for function declarations

%@AS@%  char *_getdcwd( int drive, char *buffer, int maxlen );%@AE@%%@NL@%
%@NL@%
%@AI@%drive%@AE@%                             Disk drive

%@AI@%buffer%@AE@%                            Storage location for path name

%@AI@%maxlen%@AE@%                            Maximum length of path name

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getdcwd%@AE@% function gets the full path name of the current working
directory, including disk drive specification, and stores it at %@AI@%buffer%@AE@%. The
argument %@AI@%maxlen%@AE@% specifies the maximum length for the path name. An error
occurs if the length of the path name (including the terminating null
character) exceeds %@AI@%maxlen%@AE@%.  %@NL@%
%@NL@%
The %@AI@%drive%@AE@% argument specifies the drive (0 = default drive, 1=A, 2=B, etc.).
The %@AI@%buffer%@AE@% argument can be %@AB@%NULL%@AE@%; a buffer of at least size %@AI@%maxlen%@AE@% (more only
if necessary) will automatically be allocated, using %@AB@%malloc%@AE@%, to store the
path name. This buffer can later be freed by calling %@AB@%free%@AE@% and passing it the
%@AB@%_getdcwd%@AE@% return value (a pointer to the allocated buffer).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getdcwd%@AE@% function returns %@AI@%buffer%@AE@%. A %@AB@%NULL%@AE@% return value indicates an
error, and %@AB@%errno%@AE@% is set to one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%ENOMEM%@AE@%                            Insufficient memory to allocate %@AI@%maxlen%@AE@% 
                                  bytes (when a %@AB@%NULL%@AE@% argument is given as %@AI@%%@AE@%
                                  %@AI@%buffer%@AE@%)

%@AB@%ERANGE%@AE@%                            Path name longer than %@AI@%maxlen%@AE@% characters

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%chdir%@AE@%, %@AB@%getcwd%@AE@%, %@AB@%_getdrive%@AE@%,%@AB@% mkdir%@AE@%, %@AB@%rmdir%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GETDRIVE.C illustrates drive functions including:
%@AS@%   *      _getdrive       _chdrive        _getdcwd
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <stdio.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <direct.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int ch, drive, curdrive;
%@AS@%     static char path[_MAX_PATH];
%@AS@%  
%@AS@%     /* Save current drive. */
%@AS@%     curdrive = _getdrive();
%@AS@%  
%@AS@%     printf( "Available drives are: \n" );
%@AS@%  
%@AS@%     /* If we can switch to the drive, it exists. */
%@AS@%     for( drive = 1; drive <= 26; drive++ )
%@AS@%        if( !_chdrive( drive ) )
%@AS@%           printf( "%c: ", drive + 'A' - 1 );
%@AS@%  
%@AS@%     while( 1 )
%@AS@%     {
%@AS@%        printf( "\nType drive letter to check or ESC to quit: " );
%@AS@%        ch = getch();
%@AS@%        if( ch == 27 )
%@AS@%           break;
%@AS@%        if( isalpha( ch ) )
%@AS@%           putch( ch );
%@AS@%        if( _getdcwd( toupper( ch ) - 'A' + 1, path, _MAX_PATH ) != NULL )
%@AS@%           printf( "\nCurrent directory on that drive is %s\n", path );
%@AS@%     }
%@AS@%  
%@AS@%     /* Restore original drive. This is only necessary for DOS. Under OS/2
%@AS@%      * the current drive of the calling process is always restored.
%@AS@%      */
%@AS@%     _chdrive( curdrive );
%@AS@%     printf( "\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Available drives are:
%@AS@%  A: B: C:
%@AS@%  Type drive letter to check or ESC to quit: q
%@AS@%  Type drive letter to check or ESC to quit: a
%@AS@%  Current directory on that drive is A:\
%@AS@%  
%@AS@%  Type drive letter to check or ESC to quit: c
%@AS@%  Current directory on that drive is C:\LIBREF
%@AS@%  
%@AS@%  Type drive letter to check or ESC to quit: %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getdrive@%%@NL@%
%@2@%%@CR:C6A01380715 @%%@AB@%_getdrive%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01380716 @% %@CR:C6A01380717 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current disk drive.  %@NL@%
%@NL@%
%@AS@%  #include <direct.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int _getdrive( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getdrive%@AE@% function returns the current working drive (1=A, 2=B, etc.).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return value is stated above. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_chdrive%@AE@%,  %@AB@%_dos_getdrive%@AE@%,  %@AB@%_dos_setdrive%@AE@%,  %@AB@%_getcwd%@AE@%,  %@AB@%_getdcwd%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_getdcwd%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:getenv@%%@NL@%
%@2@%%@CR:C6A01390718 @%%@AB@%getenv%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01390719 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets a value from the environment table.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AS@%  char *getenv( const char *varname );%@AE@%%@NL@%
%@NL@%
%@AI@%varname%@AE@%                           Name of environment variable

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getenv%@AE@% function searches the list of environment variables for an entry
corresponding to %@AI@%varname%@AE@%. Environment variables define the environment in
which a process executes. (For example, the LIB environment variable defines
the default search path for libraries to be linked with a program.) Because
the %@AB@%getenv%@AE@% function is case sensitive, the %@AI@%varname%@AE@% variable should match the
case of the environment variable. %@CR:C6A01390720 @%  %@NL@%
%@NL@%
The %@AB@%getenv%@AE@% function returns a pointer to an entry in the environment table.
It is, however, only safe to retrieve the value of the environment variable
using the returned pointer. To modify the value of an environmental
variable, use the %@AB@%putenv%@AE@% function.  %@NL@%
%@NL@%
The %@AB@%getenv%@AE@% and %@AB@%putenv%@AE@% functions use the copy of the environment contained in
the global variable %@AB@%environ%@AE@% to access the environment. Programs that use the
%@AI@%envp%@AE@% argument to %@AB@%main%@AE@% and the %@AB@%putenv%@AE@% function may retrieve invalid
information. The safest programming practice is to use %@AB@%getenv%@AE@% and %@AB@%putenv%@AE@%.%@CR:C6A01390721 @%%@CR:C6A01390722 @%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getenv%@AE@% function returns a pointer to the environment table entry
containing the current string value of %@AI@%varname%@AE@%. The return value is %@AB@%NULL%@AE@% if
the given variable is not currently defined.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
The %@AB@%getenv%@AE@% function operates only on the data structures accessible to the
run-time library and not on the environment "segment" created for a process
by DOS or OS/2.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%putenv%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GETENV.C: This program uses getenv to retrieve the LIB environment
%@AS@%   * variable and then uses putenv to change it to a new value.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  main()
%@AS@%  {
%@AS@%     char *libvar;
%@AS@%  
%@AS@%     /* Get the value of the LIB environment variable. */
%@AS@%     libvar = getenv( "LIB" );
%@AS@%     if( libvar != NULL )
%@AS@%        printf( "Original LIB variable is: %s\n", libvar );
%@AS@%  
%@AS@%     /* Attempt to change path. Note that this only affects the environment
%@AS@%      * variable of the current process. The command processor's environment
%@AS@%      * is not changed.
%@AS@%      */
%@AS@%     putenv( "LIB=c:\\mylib;c:\\yourlib" );
%@AS@%  
%@AS@%     /* Get new value. */
%@AS@%     libvar = getenv( "LIB" );
%@AS@%     if( libvar != NULL )
%@AS@%        printf( "New LIB variable is: %s\n", libvar );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Original LIB variable is: C:\LIB
%@AS@%  New LIB variable is: c:\mylib;c:\yourlib %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getfillmask@%%@NL@%
%@2@%%@CR:C6A01400723 @%%@AB@%_getfillmask%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01400724 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current fill mask for some graphics routines.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned char _far * _far _getfillmask( unsigned char _far *mask );%@AE@%%@NL@%
%@NL@%
%@AI@%mask%@AE@%                              Mask array

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
Some graphics routines (%@AB@%_ellipse%@AE@%, %@AB@%_floodfill%@AE@%, %@AB@%_pie%@AE@%, %@AB@%_polygon%@AE@%, and%@AB@%
%@AB@%_rectangle%@AE@%) can fill part or all of the screen with the current color or
background color. The fill mask controls the pattern used for filling.  %@NL@%
%@NL@%
The %@AB@%_getfillmask%@AE@% function returns the current fill mask. The mask is an
8-by-8-bit array, in which each bit represents a pixel. If the bit is 1, the
corresponding pixel is set to the current color; if the bit is 0, the pixel
is left unchanged. The mask is repeated over the entire fill area. If no
fill mask is set, or if %@AI@%mask%@AE@% is %@AB@%NULL%@AE@%, a solid (unpatterned) fill is
performed using the current color.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If no mask is set, the function returns %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_ellipse%@AE@% functions,  %@AB@%_floodfill%@AE@%,  %@AB@%_pie%@AE@% functions,  %@AB@%_polygon%@AE@% functions,
%@AB@%_rectangle%@AE@% functions, %@AB@%_setfillmask%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GFILLMSK.C: This program illustrates _getfillmask and _setfillmask. */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  void ellipsemask( short x1, short y1, short x2, short y2, char _far
%@AS@%  *newmask );
%@AS@%  
%@AS@%  unsigned char mask1[8] = { 0x43, 0x23, 0x7c, 0xf7, 0x8a, 0x4d, 0x78, 0x39
%@AS@%};
%@AS@%  unsigned char mask2[8] = { 0x18, 0xad, 0xc0, 0x79, 0xf6, 0xc4, 0xa8, 0x23
%@AS@%};
%@AS@%  char oldmask[8];
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int loop;
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     /* Set first fill mask and draw rectangle. */
%@AS@%     _setfillmask( mask1 );
%@AS@%     _rectangle( _GFILLINTERIOR, 20, 20, 100, 100 );
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Call routine that saves and restores mask. */
%@AS@%     ellipsemask( 60, 60, 150, 150, mask2 );
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Back to original mask. */
%@AS@%     _rectangle( _GFILLINTERIOR, 120, 120, 190, 190 );
%@AS@%     getch();
%@AS@%  
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }
%@AS@%  
%@AS@%  /* Draw an ellipse with a specified fill mask. */
%@AS@%  void ellipsemask( short x1, short y1, short x2, short y2, char _far
%@AS@%*newmask )
%@AS@%  {
%@AS@%     unsigned char savemask[8];
%@AS@%  
%@AS@%     _getfillmask( savemask );                    /* Save mask         */
%@AS@%     _setfillmask( newmask );                     /* Set new mask      */
%@AS@%     _ellipse( _GFILLINTERIOR, x1, y1, x2, y2 );  /* Use new mask      */
%@AS@%     _setfillmask( savemask );                    /* Restore original  */
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getfontinfo@%%@NL@%
%@2@%%@CR:C6A01410725 @%%@AB@%_getfontinfo%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01410726 @% %@CR:C6A01410727 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current font characteristics.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _getfontinfo( struct _fontinfo _far *fontbuffer );%@AE@%%@NL@%
%@NL@%
%@AI@%fontbuffer%@AE@%                        Buffer to hold font information

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getfontinfo%@AE@% function gets the current font characteristics and stores
them in a%@AB@% _fontinfo%@AE@% structure, defined in GRAPH.H.  %@NL@%
%@NL@%
The %@AB@%_fontinfo%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Contents%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%int type%@AE@%                          Specifies vector (1) or bit-mapped (0) 
                                  font

%@AB@%int ascent%@AE@%                        Specifies pixel distance from top to 
                                  baseline

%@AB@%int pixwidth%@AE@%                      Specifies the character width in pixels;
                                  0 indicates a proportional font 

%@AB@%int pixheight%@AE@%                     Specifies the character height in pixels

%@AB@%int avgwidth%@AE@%                      Specifies the average character width in
                                  pixels

%@AB@%char filename [81]%@AE@%                Specifies the file name, including the 
                                  path

%@AB@%char facename%@AE@% %@AB@%[32]%@AE@%                Specifies the font name

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getfontinfo%@AE@% function returns a negative number if a font has not been
registered or loaded.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getgtextextent%@AE@%,  %@AB@%_outgtext%@AE@%,  %@AB@%_registerfonts%@AE@%,  %@AB@%_setfont%@AE@%,  %@AB@%_setgtextvector%@AE@%,
%@AB@%_unregisterfonts%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_outgtext%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getgtextextent@%%@NL@%
%@2@%%@CR:C6A01420728 @%%@AB@%_getgtextextent%@CR:C6A01420729 @%%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the width in pixels of font-based text.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _getgtextextent( unsigned char _far *text );%@AE@%%@NL@%
%@NL@%
%@AI@%text%@AE@%                              Text to be analyzed

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getgtextextent%@AE@% function returns the width in pixels that would be
required to print the %@AI@%text%@AE@% string using %@AB@%_outgtext %@AE@%with the current font.  %@NL@%
%@NL@%
This function is particularly useful for determining the size of text that
uses proportionally spaced fonts.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getgtextextent%@AE@% function returns the width in pixels. It returns -1 if a
font has not been registered.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getfontinfo%@AE@%,  %@AB@%_outgtext%@AE@%,%@AB@%  _registerfonts%@AE@%,  %@AB@%_setfont%@AE@%, %@AB@% _unregisterfonts  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_outgtext%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getimage@%%@NL@%
%@2@%%@CR:C6A01430730 @%%@AB@%_getimage Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01430731 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Store images in buffers.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _getimage( short x1, short y1, short x2, short y2, char _huge
%@AS@%  *image );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _getimage_w( double wx1, double wy1, double wx2, double wy2, 
%@AS@%  char _huge *image );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _getimage_wxy( struct_wxycoord _far *pwxy1,
%@AS@%  struct_wxycoord _far *pwxy2, char _huge *image );%@AE@%%@NL@%
%@NL@%
%@AI@%x1%@AE@%, %@AI@%y1%@AE@%                            Upper-left corner of bounding rectangle

%@AI@%x2%@AE@%, %@AI@%y2%@AE@%                            Lower-right corner of bounding rectangle

%@AI@%wx1%@AE@%, %@AI@%wy1%@AE@%                          Upper-left corner of bounding rectangle

%@AI@%wx2%@AE@%, %@AI@%wy2%@AE@%                          Lower-right corner of bounding rectangle

%@AI@%pwxy1%@AE@%                             Upper-left corner of bounding rectangle

%@AI@%pwxy2%@AE@%                             Lower-right corner of bounding rectangle

%@AI@%image%@AE@%                             Storage buffer for screen image

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getimage%@AE@% functions store the screen image defined by a specified
bounding rectangle into the buffer pointed to by %@AI@%image%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_getimage%@AE@% function defines the bounding rectangle with the view
coordinates (%@AI@%x1%@AE@%, %@AI@%y1%@AE@%) and (%@AI@%x2%@AE@%, %@AI@%y2%@AE@%).  %@NL@%
%@NL@%
The %@AB@%_getimage_w%@AE@% function defines the bounding rectangle with the window
coordinates (%@AI@%wx1%@AE@%, %@AI@%wy1%@AE@%) and (%@AI@%wx2%@AE@%, %@AI@%wy2%@AE@%).  %@NL@%
%@NL@%
The %@AB@%_getimage_wxy%@AE@% function defines the bounding rectangle with the
window-coordinate pairs %@AI@%pwxy1%@AE@% and %@AI@%pwxy2%@AE@%.  %@NL@%
%@NL@%
The buffer must be large enough to hold the image. You can determine the
size by calling the appropriate %@AB@%_imagesize%@AE@% function at run time, or by using
the formula described on the %@AB@%_imagesize%@AE@% reference page.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None. Use %@AB@%_grstatus%@AE@% to check success.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_grstatus%@AE@%,  %@AB@%_imagesize%@AE@% functions,  %@AB@%_putimage%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GIMAGE.C: This example illustrates animation routines including:
%@AS@%   *          _imagesize     _getimage     _putimage
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stddef.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <malloc.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  short action[5]  = { _GPSET,   _GPRESET, _GXOR,    _GOR,     _GAND     };
%@AS@%  char *descrip[5] = {  "PSET  ", "PRESET", "XOR   ", "OR    ", "AND   " };
%@AS@%  
%@AS@%  void exitfree( char _huge *buffer );
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%      char  _huge *buffer;   /* Far pointer (with _fmalloc) could be used.
%@AS@%*/
%@AS@%      long  imsize;
%@AS@%      short i, x, y = 30;
%@AS@%  
%@AS@%      if( !_setvideomode( _MAXRESMODE ) )
%@AS@%          exit( 1 );
%@AS@%  
%@AS@%      /* Measure the image to be drawn and allocate memory for it. */
%@AS@%      imsize = (size_t)_imagesize( -16, -16, +16, +16 );
%@AS@%      buffer = halloc( imsize, sizeof( char ) );
%@AS@%      if ( buffer == (char _far *)NULL )
%@AS@%          exit( 1 );
%@AS@%  
%@AS@%      _setcolor( 3 );
%@AS@%      for ( i = 0; i < 5; i++ )
%@AS@%      {
%@AS@%          /* Draw ellipse at new position and get a copy of it. */
%@AS@%          x = 50; y += 40;
%@AS@%          _ellipse( _GFILLINTERIOR, x - 15, y - 15, x + 15, y + 15 );
%@AS@%          _getimage( x - 16, y - 16, x + 16, y + 16, buffer );
%@AS@%          if( _grstatus() )
%@AS@%              exitfree( buffer );        /* Quit on error
%@AS@%*/
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  /* Display action type and copy a row of ellipses with that type. */
%@AS@%          _settextposition( 1, 1 );
%@AS@%          _outtext( descrip[i] );
%@AS@%          while( x < 260 )
%@AS@%          {
%@AS@%              x += 5;
%@AS@%              _putimage( x - 16, y - 16, buffer, action[i] );
%@AS@%              if( _grstatus() < 0 )      /* Ignore warnings, quit on errors.
%@AS@%*/
%@AS@%                  exitfree( buffer );
%@AS@%          }
%@AS@%          getch();
%@AS@%      }
%@AS@%      exitfree( buffer );
%@AS@%  }
%@AS@%  
%@AS@%  void exitfree( char _huge *buffer )
%@AS@%  {
%@AS@%      hfree( buffer );
%@AS@%      exit( !_setvideomode( _DEFAULTMODE ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getlinestyle@%%@NL@%
%@2@%%@CR:C6A01440732 @%%@AB@%_getlinestyle%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01440733 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current line style.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned short _far _getlinestyle( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
Some graphics routines ( _lineto, %@AB@%_polygon%@AE@%, and %@AB@%_rectangle%@AE@%) output straight
lines to the screen. The type of line can be controlled with the current
line-style mask.  %@NL@%
%@NL@%
The %@AB@%_getlinestyle%@AE@% function returns the current line-style mask. The mask is
a 16-bit array in which each bit represents a pixel in the line being drawn.
If the bit is 1, the corresponding pixel is set to the color of the line
(the current color). If the bit is 0, the corresponding pixel is left
unchanged. The mask is repeated over the length of the line. The default
mask is 0xFFFF (a solid line).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If no mask has been set, %@AB@%_getlinestyle%@AE@% returns the default mask.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_lineto%@AE@% functions,  %@AB@%_polygon%@AE@% functions,  %@AB@%_rectangle%@AE@% functions,
%@AB@%_setlinestyle%@AE@%, %@AB@%_setwritemode%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GLINESTY.C: This program illustrates _setlinestyle and _getlinestyle.
%@AS@%  */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void zigzag( short x1, short y1, short size );
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXCOLORMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     /* Set line style and draw rectangle. */
%@AS@%     _setlinestyle( 0x4d );
%@AS@%     _rectangle( _GBORDER, 10, 10, 60, 60 );
%@AS@%     getch();%@AE@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%     /* Draw figure with function that changes and restores line style. */
%@AS@%     zigzag( 100, 100, 90 );
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Original style reused. */
%@AS@%     _rectangle( _GBORDER, 190, 190, 130, 130 );
%@AS@%     getch();
%@AS@%  
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }
%@AS@%  
%@AS@%  /* Draw box with changing line styles. Restore original style. */
%@AS@%  void zigzag( short x1, short y1, short size )
%@AS@%  {
%@AS@%     short x, y, oldcolor;
%@AS@%     unsigned short oldstyle;
%@AS@%     unsigned short style[16] = { 0x0001, 0x0003, 0x0007, 0x000f,
%@AS@%                                  0x001f, 0x003f, 0x007f, 0x00ff,
%@AS@%                                  0x01ff, 0x03ff, 0x07ff, 0x0fff,
%@AS@%                                  0x1fff, 0x3fff, 0x7fff, 0xffff };
%@AS@%  
%@AS@%     oldcolor = _getcolor();
%@AS@%     oldstyle = _getlinestyle();            /* Save old line style.
%@AS@%*/
%@AS@%     for( x = 3, y = 3; x < size; x += 3, y += 3 )
%@AS@%     {
%@AS@%        _setcolor( x % 16 );
%@AS@%        _setlinestyle( style[x % 16] );     /* Set and use new line styles
%@AS@%*/
%@AS@%        _rectangle( _GBORDER, x1 - x, y1 - y, x1 + x, y1 + y );
%@AS@%     }
%@AS@%     _setlinestyle( oldstyle );             /* Restore old line style.
%@AS@%*/
%@AS@%     _setcolor( oldcolor );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getphyscoord@%%@NL@%
%@2@%%@CR:C6A01450734 @%%@AB@%_getphyscoord%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01450735 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets physical coordinates.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct xycoord _far _getphyscoord( short x, short y );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              View coordinates to translate

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getphyscoord%@AE@% function translates the view coordinates (%@AI@%x%@AE@%, %@AI@%y%@AE@%) to
physical coordinates and returns them in an %@AB@%xycoord%@AE@% structure, defined in
GRAPH.H.  %@NL@%
%@NL@%
The %@AB@%xycoord%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%short xcoord%@AE@%                      %@AI@%x %@AE@%coordinate

%@AB@%short ycoord%@AE@%                      %@AI@%y %@AE@%coordinate

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getviewcoord%@AE@% functions,  %@AB@%_grstatus%@AE@%,  %@AB@%_setvieworg%@AE@%,  %@AB@%_setviewport%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_setwindow%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:getpid@%%@NL@%
%@2@%%@CR:C6A01460736 @%%@AB@%getpid%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01460737 @%%@CR:C6A01460738 @%%@CR:C6A01460739 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the process identification.  %@NL@%
%@NL@%
%@AB@%#include <process.h>%@AE@%              Required only for function declarations

%@AS@%  int getpid( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getpid%@AE@% function returns the process ID, an integer that uniquely
identifies the calling process.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getpid%@AE@% function returns the process ID. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%mktemp%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GETPID.C: This program uses getpid to obtain the process ID and
%@AS@%   * then prints the ID.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <process.h>
%@AS@%  
%@AS@%  void main( )
%@AS@%  {
%@AS@%     /* If run from DOS, shows different ID for DOS than for DOS shell.
%@AS@%      * If execed or spawned, shows ID of parent.
%@AS@%      */
%@AS@%     printf( "\nProcess id of parent: %d\n", getpid() );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  
%@AS@%  Process id of parent: 828%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getpixel@%%@NL@%
%@2@%%@CR:C6A01470740 @%%@AB@%_getpixel Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01470741 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Get pixel values.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _getpixel( short x, short y );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _getpixel_w( double wx, double wy );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              Pixel position

%@AI@%wx%@AE@%, %@AI@%wy %@AE@%                           Pixel position

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The functions in the %@AB@%_getpixel%@AE@% family return the pixel value (a color index)
at a specified location. The %@AB@%_getpixel%@AE@% function uses the view coordinate (%@AI@%x%@AE@%,
%@AI@%y%@AE@%). The %@AB@%_getpixel_w%@AE@% function uses the window coordinate (%@AI@%wx%@AE@%, %@AI@%wy%@AE@%). The range
of possible pixel values is determined by the current video mode. The color
translation of pixel values is determined by the current palette.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the function returns the color index. If the function fails
(for example, the point lies outside the clipping region, or the program is
in a text mode), it returns -1.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getvideoconfig%@AE@%,  %@AB@%_grstatus%@AE@%,  %@AB@%_remapallpalette%@AE@%,  %@AB@%_remappalette%@AE@%,
%@AB@%_selectpalette%@AE@%, %@AB@% _setpixel%@AE@% functions,  %@AB@%_setvideomode%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GPIXEL.C: This program assigns different colors to randomly
%@AS@%   * selected pixels.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short xvar, yvar;
%@AS@%     struct videoconfig vc;
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXCOLORMODE ) )
%@AS@%        exit( 1 );
%@AS@%     _getvideoconfig( &vc );
%@AS@%  
%@AS@%     /* Draw filled ellipse to turn on certain pixels. */
%@AS@%     _ellipse( _GFILLINTERIOR, vc.numxpixels / 6, vc.numypixels / 6,
%@AS@%                               vc.numxpixels / 6 * 5, vc.numypixels / 6 * 5
%@AS@%                                             );
%@AS@%  
%@AS@%     /* Draw random pixels in random colors... */
%@AS@%     while( !kbhit() )
%@AS@%     {
%@AS@%        /* ...but only if they are already on (inside the ellipse). */
%@AS@%        xvar = rand() % vc.numxpixels;
%@AS@%        yvar = rand() % vc.numypixels;
%@AS@%        if( _getpixel( xvar, yvar ) != 0 )
%@AS@%        {
%@AS@%           _setcolor( rand() % 16 );
%@AS@%           _setpixel( xvar, yvar );
%@AS@%        }
%@AS@%     }
%@AS@%  
%@AS@%     getch();          /* Throw away the keystroke. */
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:gets@%%@NL@%
%@2@%%@CR:C6A01480742 @%%@AB@%gets%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01480743 @%%@CR:C6A01480744 @% %@CR:C6A01480745 @%%@CR:C6A01480746 @%%@CR:C6A01480747 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets a line from the %@AB@%stdin %@AE@%stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char *gets( char *buffer );%@AE@%%@NL@%
%@NL@%
%@AI@%buffer%@AE@%                            Storage location for input string

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%gets%@AE@% function reads a line from the standard input stream %@AB@%stdin%@AE@% and
stores it in %@AI@%buffer%@AE@%. The line consists of all characters up to and including
the first newline character (%@AB@%\n%@AE@%). The %@AB@%gets%@AE@% function then replaces the
newline character with a null character (%@AB@%'\0'%@AE@%) before returning the line. In
contrast, the %@AB@%fgets%@AE@% function retains the newline character.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the %@AB@%gets%@AE@% function returns its argument. A %@AB@%NULL%@AE@% pointer
indicates an error or end-of-file condition. Use %@AB@%ferror%@AE@% or %@AB@%feof%@AE@% to determine
which one has occurred.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fgets%@AE@%, %@AB@%fputs%@AE@%, %@AB@%puts%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GETS.C */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char line[81];
%@AS@%  
%@AS@%     printf( "Input a string: " );
%@AS@%     gets( line );
%@AS@%     printf( "The line entered was: %s\n", line );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Input a string: This is a string
%@AS@%  The line entered was: This is a string %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_gettextcolor@%%@NL@%
%@2@%%@CR:C6A01490748 @%%@AB@%_gettextcolor%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01490749 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current text color.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _gettextcolor( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_gettextcolor%@AE@% function returns the color index of the current text
color. The text color is set by the %@AB@%_settextcolor%@AE@% function and affects text
output with the %@AB@%_outtext%@AE@% and %@AB@%_outmem%@AE@% functions only. The %@AB@%_setcolor%@AE@% function
sets the color for font text output using the %@AB@% _outgtext%@AE@% function.  %@NL@%
%@NL@%
The default is 7 in test modes; it is the highest legal color index of the
current palette in graphics modes.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_gettextcolor%@AE@% function returns the color index of the current text
color.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getvideoconfig%@AE@%,  %@AB@%_remappalette%@AE@%,  %@AB@%_selectpalette%@AE@%,  %@AB@%_setcolor%@AE@%,  %@AB@%_settextcolor%@AE@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_gettextposition%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_gettextcursor@%%@NL@%
%@2@%%@CR:C6A01500750 @%%@AB@%_gettextcursor%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01500751 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current cursor attribute.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _gettextcursor( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_gettextcursor%@AE@% function returns the current cursor attribute (i.e., the
shape). This function works only in text video modes.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the current cursor attribute, or -1 if an error occurs
(such as a call to the function in a graphics mode).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_displaycursor%@AE@%,  %@AB@%_grstatus%@AE@%,  %@AB@%_settextcursor%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_settextcursor%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_gettextposition@%%@NL@%
%@2@%%@CR:C6A01510752 @%%@AB@%_gettextposition%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01510753 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current text position.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct rccoord _far _gettextposition( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_gettextposition%@AE@% function returns the current text position as an
%@AB@%rccoord%@AE@% structure, defined in GRAPH.H.  %@NL@%
%@NL@%
The %@AB@%rccoord%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%short row%@AE@%                         Row coordinate

%@AB@%short col%@AE@%                         Column coordinate

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The text position given by the coordinates (1,1) is defined as the
upper-left corner of the text window.  %@NL@%
%@NL@%
Text output from the %@AB@%_outtext%@AE@% and %@AB@%_outmem%@AE@% functions begins at the current
text position. Font text is not affected by the current text position. Font
text output begins at the current graphics output position, which is a
separate position.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getcurrentposition%@AE@% functions,  %@AB@%_moveto%@AE@% functions,  %@AB@%_outmem%@AE@%,%@AB@%  _outtext%@AE@%,
%@AB@%_settextposition%@AE@%,  %@AB@%_settextwindow%@AE@%,  %@AB@%_wrapon%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* OUTTXT.C: This example illustrates text output functions:
%@AS@%   *    _gettextcolor   _getbkcolor   _gettextposition   _outtext
%@AS@%   *    _settextcolor   _setbkcolor   _settextposition
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char buffer [80];
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%  
%@AS@%     /* Save original foreground, background, and text position. */
%@AS@%     short blink, fgd, oldfgd;
%@AS@%     long  bgd, oldbgd;
%@AS@%     struct rccoord oldpos;
%@AS@%  
%@AS@%     /* Save original foreground, background, and text position. */
%@AS@%     oldfgd = _gettextcolor();
%@AS@%     oldbgd = _getbkcolor();
%@AS@%     oldpos = _gettextposition();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%  
%@AS@%     /* First time no blink, second time blinking. */
%@AS@%     for( blink = 0; blink <= 16; blink += 16 )
%@AS@%     {
%@AS@%        /* Loop through 8 background colors. */
%@AS@%        for( bgd = 0; bgd < 8; bgd++ )
%@AS@%        {
%@AS@%           _setbkcolor( bgd );
%@AS@%           _settextposition( (short)bgd + ((blink / 16) * 9) + 3, 1 );
%@AS@%           _settextcolor( 7 );
%@AS@%           sprintf(buffer, "Back: %d Fore:", bgd );
%@AS@%           _outtext( buffer );
%@AS@%  
%@AS@%           /* Loop through 16 foreground colors. */
%@AS@%           for( fgd = 0; fgd < 16; fgd++ )
%@AS@%           {
%@AS@%              _settextcolor( fgd + blink );
%@AS@%              sprintf( buffer, " %2d ", fgd + blink );
%@AS@%              _outtext( buffer );
%@AS@%           }
%@AS@%        }
%@AS@%     }
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Restore original foreground, background, and text position. */
%@AS@%     _settextcolor( oldfgd );
%@AS@%     _setbkcolor( oldbgd );
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%     _settextposition( oldpos.row, oldpos.col );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_gettextwindow@%%@NL@%
%@2@%%@CR:C6A01520754 @%%@AB@%_gettextwindow%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01520755 @% %@CR:C6A01520756 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the boundaries of the current text window.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _gettextwindow( short _far *r1, short _far *c1, short _far *r2, 
%@AS@%  short _far *c2 );%@AE@%%@NL@%
%@NL@%
%@AI@%r1%@AE@%                                Top row of current text window

%@AI@%c1%@AE@%                                Leftmost column of current text window

%@AI@%r2%@AE@%                                Bottom row of current text window

%@AI@%c2%@AE@%                                Rightmost column of current text window

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_gettextwindow%@AE@% function finds the boundaries of the current text window.
The text window is the region of the screen to which output from the
%@AB@%_outtext%@AE@% and %@AB@%_outmem%@AE@% functions is limited. By default, this is the entire
screen, unless it has been redefined by the %@AB@%_settextwindow%@AE@% function.  %@NL@%
%@NL@%
The window defined by %@AB@%_settextwindow %@AE@%has no effect on output from the%@AB@%
%@AB@%_outgtext%@AE@% function. Text displayed with %@AB@%_outgtext%@AE@% is limited to the current
viewport.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_gettextposition%@AE@%,  %@AB@%_outmem%@AE@%,  %@AB@%_outtext%@AE@%,  %@AB@%_scrolltextwindow%@AE@%,
%@AB@%_settextposition%@AE@%, %@AB@%_settextwindow%@AE@%,  %@AB@%_wrapon%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_scrolltextwindow%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getvideoconfig@%%@NL@%
%@2@%%@CR:C6A01530757 @%%@AB@%_getvideoconfig%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01530758 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets graphics video configuration information.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct videoconfig _far * _far _getvideoconfig( struct videoconfig _far
%@AS@%  *config );%@AE@%%@NL@%
%@NL@%
%@AI@%config%@AE@%                            Configuration information

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getvideoconfig%@AE@% function returns the current graphics environment
configuration in a %@AB@%videoconfig%@AE@% structure, defined in GRAPH.H.  %@NL@%
%@NL@%
The values returned reflect the currently active video adapter and monitor,
as well as the current video mode.  %@NL@%
%@NL@%
The %@AB@%videoconfig%@AE@% structure contains the following members, each of which is
of type %@AB@%short%@AE@%:  %@NL@%
%@NL@%
%@AB@%Member%@AE@%                            %@AB@%Contents%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%adapter%@AE@%                           Active display adapter

%@AB@%bitsperpixel%@AE@%                      Number of bits per pixel

%@AB@%memory%@AE@%                            Adapter video memory in kilobytes

%@AB@%mode%@AE@%                              Current video mode

%@AB@%monitor%@AE@%                           Active display monitor

%@AB@%numcolors%@AE@%                         Number of color indices

%@AB@%numtextcols%@AE@%                       Number of text columns available

%@AB@%numtextrows%@AE@%                       Number of text rows available

%@AB@%numvideopages%@AE@%                     Number of available video pages

%@AB@%numxpixels%@AE@%                        Number of pixels on the %@AI@%x%@AE@% axis

%@AB@%numypixels%@AE@%                        Number of pixels on the %@AI@%y%@AE@% axis

%@AB@%  %@AE@%%@NL@%
%@NL@%
The values for the %@AB@%adapter%@AE@% member of the %@AB@%videoconfig%@AE@% structure are given by
the manifest constants shown in the list below. For any applicable adapter (
%@AB@%_CGA%@AE@%, %@AB@%_EGA%@AE@%, or %@AB@%_VGA%@AE@%), the corresponding Olivetti(R) adapter ( %@AB@%_OCGA%@AE@%, %@AB@%_OEGA%@AE@%,
or %@AB@%_OVGA%@AE@%) represents a superset of graphics capabilities.  %@NL@%
%@NL@%
%@AB@%Adapter Constant%@AE@%                  %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_CGA%@AE@%                              Color Graphics Adapter

%@AB@%_EGA%@AE@%                              Enhanced Graphics Adapter

%@AB@%_HGC%@AE@%                              Hercules(R) Graphics Card

%@AB@%_MCGA%@AE@%                             Multicolor Graphics Array

%@AB@%_MDPA%@AE@%                             Monochrome Display Printer Adapter

%@AB@%_OCGA%@AE@%                             Olivetti (AT&T(R)) Color Graphics 
                                  Adapter

%@AB@%_OEGA%@AE@%                             Olivetti (AT&T) Enhanced Graphics 
                                  Adapter

%@AB@%_OVGA%@AE@%                             Olivetti (AT&T) Video Graphics Array

%@AB@%_VGA%@AE@%                              Video Graphics Array

The values for the %@AB@%monitor%@AE@% member of the %@AB@%videoconfig%@AE@% structure are given by
the manifest constants listed below:  %@NL@%
%@NL@%
%@AB@%Monitor Constant%@AE@%                  %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_ANALOG%@AE@%                           Analog monochrome and color

%@AB@%_ANALOGCOLOR%@AE@%                      Analog color only

%@AB@%_ANALOGMONO%@AE@%                       Analog monochrome only

%@AB@%_COLOR%@AE@%                            Color (or enhanced monitor emulating a 
                                  color monitor)

%@AB@%_ENHCOLOR%@AE@%                         Enhanced color

%@AB@%_MONO%@AE@%                             Monochrome monitor

In every text mode, including monochrome, the %@AB@%_getvideoconfig%@AE@% function
returns the value 32 for the number of available colors. The value 32
indicates the range of values (0 -31) accepted by the %@AB@%_settextcolor%@AE@%
function. This includes 16 normal colors (0 -15) and 16 blinking colors (16
-31). Blinking is selected by adding 16 to the normal color index. Because
monochrome text mode has fewer unique display attributes, some color indices
are redundant. However, because blinking is selected in the same manner,
monochrome text mode has the same range (0 -31) as other text modes.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getvideoconfig%@AE@% function returns the video configuration information in
a structure, as noted above. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_setvideomode%@AE@%,  %@AB@%_setvideomoderows%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GVIDCFG.C: This program displays information about the current
%@AS@%   * video configuration.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct videoconfig vc;
%@AS@%     short  c;
%@AS@%     char   b[500];                        /* Buffer for string */
%@AS@%  
%@AS@%     _getvideoconfig( &vc );
%@AS@%  
%@AS@%     /* Write all information to a string, then output string. */
%@AS@%     c  = sprintf( b,     "X pixels:     %d\n", vc.numxpixels );
%@AS@%     c += sprintf( b + c, "Y pixels:     %d\n", vc.numypixels );
%@AS@%     c += sprintf( b + c, "Text columns: %d\n", vc.numtextcols );
%@AS@%     c += sprintf( b + c, "Text rows:    %d\n", vc.numtextrows );
%@AS@%     c += sprintf( b + c, "Colors:       %d\n", vc.numcolors );
%@AS@%     c += sprintf( b + c, "Bits/pixel:   %d\n", vc.bitsperpixel );
%@AS@%     c += sprintf( b + c, "Video pages:  %d\n", vc.numvideopages );
%@AS@%     c += sprintf( b + c, "Mode:         %d\n", vc.mode );
%@AS@%     c += sprintf( b + c, "Adapter:      %d\n", vc.adapter );
%@AS@%     c += sprintf( b + c, "Monitor:      %d\n", vc.monitor );
%@AS@%     c += sprintf( b + c, "Memory:       %d\n", vc.memory );
%@AS@%     _outtext( b );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  X pixels:     0
%@AS@%  Y pixels:     0
%@AS@%  Text columns: 80
%@AS@%  Text rows:    25
%@AS@%  Colors:       32
%@AS@%  Bits/pixel:   0
%@AS@%  Video pages:  1
%@AS@%  Mode:         3
%@AS@%  Adapter:      8
%@AS@%  Monitor:      24
%@AS@%  Memory:       256%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getviewcoord@%%@NL@%
%@2@%%@CR:C6A01540759 @%%@AB@%_getviewcoord Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description %@CR:C6A01540760 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Translate coordinates to view coordinates.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct xycoord _far _getviewcoord( short x, short y );%@AE@%%@NL@%
%@NL@%
%@AS@%  struct xycoord _far _getviewcoord_w( double wx, double wy );%@AE@%%@NL@%
%@NL@%
%@AS@%  struct xycoord _far _getviewcoord_wxy( struct _wxycoord _far *pwxy1 );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              Physical point to translate

%@AI@%wx%@AE@%, %@AI@%wy%@AE@%                            Window point to translate

%@AI@%pwxy1%@AE@%                             Window point to translate

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getviewcoord%@AE@% routines translate the specified coordinates (%@AI@%x%@AE@%, %@AI@%y%@AE@%) from
one coordinate system to view coordinates and then return them in an %@AB@%xycoord%@AE@%
structure, defined in GRAPH.H. The %@AB@%xycoord %@AE@%structure contains the following
elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%short xcoord%@AE@%                      %@AI@%x%@AE@% coordinate

%@AB@%short ycoord%@AE@%                      %@AI@%y%@AE@% coordinate

The various %@AB@%_getviewcoord%@AE@% routines translate in the following manner:  %@NL@%
%@NL@%
%@AB@%Routine%@AE@%                           %@AB@%Translation%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_getviewcoord%@AE@%                     Physical coordinates (%@AI@%x%@AE@%, %@AI@%y%@AE@%) to view 
                                  coordinates

%@AB@%_getviewcoord_w%@AE@%                   Window coordinates (%@AI@%wx%@AE@%, %@AI@%wy%@AE@%) to view 
                                  coordinates

%@AB@%_getviewcoord_wxy%@AE@%                 Window coordinates structure (%@AI@%pwxy1%@AE@%) to 
                                  view coordinates

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
C 5.1 Version Difference
%@AI@%%@AI@%In Microsoft C version 5.1, the function %@AE@%%@AI@%%@AB@%_getviewcoord%@AE@%%@AE@%%@AI@% was called %@AE@%%@AI@%%@AB@%
%@AB@%_getlogcoord%@AE@%%@AE@%%@AI@%.%@AE@%%@AE@%%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getviewcoord%@AE@% function returns the coordinates as noted above. There is
no error  return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getphyscoord%@AE@%,  %@AB@%_getwindowcoord,  _grstatus  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_setwindow%@AE@%.%@AB@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getvisualpage@%%@NL@%
%@2@%%@CR:C6A01550761 @%%@AB@%_getvisualpage%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01550762 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current visual page number.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _getvisualpage( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getvisualpage%@AE@% function returns the current visual page number.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the number of the current visual page. All hardware
combinations support at least one page (page number 0). In OS/2, only page 0
is available.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getactivepage%@AE@%,  %@AB@%_gettextcolor%@AE@%,  %@AB@%_gettextposition%@AE@%,  %@AB@%_outtext%@AE@%,
%@AB@%_setactivepage%@AE@%, %@AB@%_settextcolor%@AE@%,  %@AB@%_settextposition%@AE@%, %@AB@% _settextwindow%@AE@%,
%@AB@%_setvideomode%@AE@%, %@AB@%_setvisualpage%@AE@%,  %@AB@%_wrapon%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_getactivepage%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:getw@%%@NL@%
%@2@%%@CR:C6A01560763 @%%@AB@%getw%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01560764 @%%@CR:C6A01560765 @% %@CR:C6A01560766 @%%@CR:C6A01560767 @% %@CR:C6A01560768 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets an integer from a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int getw( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getw%@AE@% function reads the next binary value of type %@AB@%int%@AE@% from the file
associated with %@AI@%stream%@AE@% and increments the associated file pointer (if there
is one) to point to the next unread character. The %@AB@%getw%@AE@% function does not
assume any special alignment of items in the stream.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%getw%@AE@% function returns the integer value read. A return value of %@AB@%EOF may
%@AB@%indicate an error or end-of-file. However, since the EOF valu%@AE@%e is also a
legitimate integer value, %@AB@%feof%@AE@% or %@AB@%ferror%@AE@% should be used to verify an
end-of-file or error condition.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
The %@AB@%getw%@AE@% function is provided primarily for compatibility with previous
libraries. Note that portability problems may occur with %@AB@%getw%@AE@%, since the
size of the %@AB@%int%@AE@% type and the ordering of bytes within the %@AB@%int%@AE@% type differ
across systems.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%putw%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GETW.C: This program uses getw to read a word from a stream,
%@AS@%   * then performs an error check.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%  
%@AS@%     FILE *stream;
%@AS@%     int i;
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  if( (stream = fopen( "getw.c", "rb" )) == NULL )
%@AS@%        printf( "Couldn't open file\n" );
%@AS@%     else
%@AS@%     {
%@AS@%        /* Read a word from the stream: */
%@AS@%        i = getw( stream );
%@AS@%  
%@AS@%        /* If there is an error... */
%@AS@%        if( ferror( stream ) )
%@AS@%        {
%@AS@%           printf( "getw failed\n" );
%@AS@%           clearerr( stream );
%@AS@%        }
%@AS@%        else
%@AS@%           printf( "First data word in file: 0x%.4x\n", i );
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  First data word in file: 0x2a2f %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getwindowcoord@%%@NL@%
%@2@%%@CR:C6A01570769 @%%@AB@%_getwindowcoord%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01570770 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Translates view coordinates to window coordinates.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct _wxycoord _far _getwindowcoord( short x, short y );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              Physical point to translate

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getwindowcoord%@AE@% function translates the view coordinates (%@AI@%x%@AE@%, %@AI@%y%@AE@%) to
window coordinates and returns them in the %@AB@%_wxycoord%@AE@% structure, defined in
GRAPH.H.  %@NL@%
%@NL@%
The %@AB@%_wxycoord %@AE@%structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%double wx%@AE@%                         %@AI@%x%@AE@% coordinate

%@AB@%double wy%@AE@%                         %@AI@%y%@AE@% coordinate

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the coordinates in the %@AB@%_wxycoord%@AE@% structure. There is no
error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getphyscoord%@AE@%,  %@AB@%_getviewcoord%@AE@% functions, %@AB@% _moveto%@AE@% functions,  %@AB@%_setwindow%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_setwindow%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_getwritemode@%%@NL@%
%@2@%%@CR:C6A01580771 @%%@AB@%_getwritemode%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01580772 @% %@CR:C6A01580773 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current logical mode for line drawing.  %@NL@%
%@NL@%
%@AS@%  #include  <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _getwritemode( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getwritemode%@AE@% function returns the current logical write mode, which is
used when drawing lines with the %@AB@%_lineto%@AE@%,%@AB@% _polygon%@AE@%, and%@AB@% _rectangle%@AE@%
functions.  %@NL@%
%@NL@%
The default value is %@AB@%_GPSET%@AE@%, which causes lines to be drawn in the current
graphics color. The other possible return values are %@AB@%_GXOR%@AE@%, %@AB@%_GAND%@AE@%, %@AB@%_GOR%@AE@%, and
%@AB@%_GPRESET%@AE@%. See %@AB@%_putimage%@AE@% for more details on these manifest constants.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_getwritemode%@AE@% function returns the current logical write mode, or -1 if
not in graphics mode.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_grstatus%@AE@%,  %@AB@%_lineto%@AE@% functions,  %@AB@%_putimage%@AE@% functions,  %@AB@%_rectangle%@AE@% functions,
%@AB@%_setcolor%@AE@%,  %@AB@%_setlinestyle%@AE@%,  %@AB@%_setwritemode%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GWRMODE.C: This program illustrates _getwritemode and _setwritemode. */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  short wmodes[5]  = { _GPSET,   _GPRESET, _GXOR,    _GOR,     _GAND    };
%@AS@%  char *wmstr[5]   = { "PSET  ", "PRESET", "XOR   ", "OR    ", "AND   " };
%@AS@%  
%@AS@%  void box( short x, short y, short size, short writemode, short fillmode );
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short i, x, y;
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXCOLORMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     x = y = 70;
%@AS@%     box( x, y, 50, _GPSET, _GFILLINTERIOR );
%@AS@%     _setcolor( 2 );
%@AS@%     box( x, y, 40, _GPSET, _GFILLINTERIOR );
%@AS@%     for( i = 0; i < 5; i++ )
%@AS@%     {
%@AS@%        _settextposition( 1, 1 );
%@AS@%        _outtext( wmstr[i] );
%@AS@%        box( x += 12, y += 12, 50, wmodes[i], _GBORDER );
%@AS@%        getch();
%@AS@%     }
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }
%@AS@%  
%@AS@%  void box( short x, short y, short size, short writemode, short fillmode )
%@AS@%  {
%@AS@%      short wm, side;
%@AS@%  
%@AS@%      wm = _getwritemode();           /* Save write mode and set new. */
%@AS@%      _setwritemode( writemode );
%@AS@%      _rectangle( fillmode, x - size, y - size, x + size, y + size );
%@AS@%      _setwritemode( wm );            /* Restore original write mode. */
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:gmtime@%%@NL@%
%@2@%%@CR:C6A01590774 @%%@AB@%gmtime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01590775 @%%@CR:C6A01590776 @%%@CR:C6A01590777 @% %@CR:C6A01590778 @%%@CR:C6A01590779 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Converts a time value to a structure.  %@NL@%
%@NL@%
%@AS@%  #include <time.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct tm *gmtime( const time_t *timer );%@AE@%%@NL@%
%@NL@%
%@AI@%timer%@AE@%                             Pointer to stored time

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%gmtime%@AE@% function converts the %@AI@%timer%@AE@% value to a structure. The %@AI@%timer%@AE@%
argument represents the seconds elapsed since 00:00:00, January 1, 1970,
Greenwich mean time. This value is usually obtained from a call to the %@AB@%timer
%@AB@%%@AE@%function.%@AB@%  %@AE@%%@NL@%
%@NL@%
The %@AB@%gmtime%@AE@% function breaks down the %@AI@%timer%@AE@% value and stores it in a structure
of type %@AB@%tm%@AE@%, defined in TIME.H. (See %@AB@%asctime%@AE@% for a description of the
structure members.) The structure result reflects Greenwich mean time, not
local time.  %@NL@%
%@NL@%
The fields of the structure type %@AB@%tm%@AE@% store the following values, each of
which is an %@AB@%int%@AE@%:  %@NL@%
%@NL@%
%@AB@%Field%@AE@%                             %@AB@%Value Stored%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%tm_sec%@AE@%                            Seconds

%@AB@%tm_min%@AE@%                            Minutes

%@AB@%tm_hour%@AE@%                           Hours (0-24)

%@AB@%tm_mday%@AE@%                           Day of month (1-31)

%@AB@%tm_mon%@AE@%                            Month (0-11; January = 0)

%@AB@%tm_year%@AE@%                           Year (current year minus 1900)

%@AB@%tm_wday%@AE@%                           Day of week (0-6; Sunday = 0)

%@AB@%tm_yday%@AE@%                           Day of year (0-365; January 1 = 0)

%@AB@%tm_isdst%@AE@%                          Always 0 for %@AB@%gmtime%@AE@%

The %@AB@%gmtime, mktime, %@AE@%and%@AB@% localtime%@AE@% functions use a single statically
allocated structure to hold the result. Each call to one of these routines
destroys the result of any previous call.  %@NL@%
%@NL@%
DOS and OS/2 do not accommodate dates prior to 1980. If %@AI@%timer%@AE@% represents a
date prior to 1980, %@AB@%gmtime%@AE@% returns %@AB@%NULL%@AE@%.    %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%gmtime%@AE@% function returns a pointer to the structure result. There is no
error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asctime%@AE@%, %@AB@%ctime%@AE@%, %@AB@%ftime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%time  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GMTIME.C: This program uses gmtime to convert a long-integer
%@AS@%   * representation of Greenwich mean time to a structure named newtime,
%@AS@%   * then uses asctime to convert this structure to an output string.
%@AS@%   */
%@AS@%  
%@AS@%  #include <time.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct tm *newtime;
%@AS@%     long ltime;
%@AS@%  
%@AS@%     time( &ltime );
%@AS@%  
%@AS@%     /* Obtain Greenwich mean time: */
%@AS@%     newtime = gmtime( &ltime );
%@AS@%     printf( "Greenwich mean time is %s\n", asctime( newtime ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Greenwich mean time is Fri Jun 16 16:37:53 1989 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_grstatus@%%@NL@%
%@2@%%@CR:C6A01600780 @%%@AB@%_grstatus%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01600781 @% %@CR:C6A01600782 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Returns the status of the most recent graphics function call.  %@NL@%
%@NL@%
%@AS@%  #include  <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _grstatus( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_grstatus%@AE@% function returns the status of the most recently used graphics
function. The %@AB@%_grstatus%@AE@% function can be used immediately following a call to
a graphics routine to determine if errors or warnings were generated. Return
values less than 0 are errors, and values greater than 0 are warnings.  %@NL@%
%@NL@%
The following manifest constants are defined in the GRAPH.H header file for
use with the %@AB@%_grstatus%@AE@% function:  %@NL@%
%@NL@%
%@TH:  34  1511 02 07 23 48 @%%@AB@%Value%@AE@%  %@AB@%Constant%@AE@%               %@AB@%Meaning%@AE@%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%0      %@AB@%_GROK%@AE@%                  Success-1     %@AB@%_GRERROR%@AE@%               Graphics error-2     %@AB@%_GRMODENOTSUPPORTED%@AE@%    Requested video mode not supported-3     %@AB@%_GRNOTINPROPERMODE%@AE@%     Requested routine only works in certain video                               modes-4     %@AB@%_GRINVALIDPARAMETER%@AE@%    One or more parameters invalid-5     %@AB@%_GRFONTFILENOTFOUND%@AE@%    No matching font file found-6     %@AB@%_GRINVALIDFONTFILE%@AE@%     One or more font files invalid-7     %@AB@%_GRCORRUPTEDFONTFILE%@AE@%   One or more font files inconsistent-8     %@AB@%_GRINSUFFICIENTMEMORY%@AE@%  Not enough memory to allocate buffer or to                               complete a %@AB@%_floodfill%@AE@% operation-9     %@AB@%_GRINVALIDIMAGEBUFFER%@AE@%  Image buffer data inconsistent1      %@AB@%_GRMOOUTPUT%@AE@%            No action taken2      %@AB@%_GRCLIPPED%@AE@%             Output was clipped to viewport3      %@AB@%_GRPARAMETERALTERED%@AE@%    One or more input parameters was altered to be                              within range, or pairs of parameters were                               interchanged to be in the proper order%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  34  1511 02 07 23 48 @%

After a graphics call, use an %@AB@%if %@AE@%statement to compare the return value of
%@AB@%_grstatus%@AE@% to %@AB@%_GROK%@AE@%. For example:  %@NL@%
%@NL@%
%@AS@%  if( _grstatus < _GROK )
%@AS@%      /*handle graphics error*/ ;%@AE@%%@NL@%
%@NL@%
The functions listed below cannot cause errors, and they all set %@AB@%_grstatus%@AE@%
to %@AB@%GROK%@AE@%:  %@NL@%
%@NL@%
%@TH:   9   456 01 17 18 41 @%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%_displaycursor%@AE@%   %@AB@%_gettextposition%@AE@%  %@AB@%_outmem%@AE@%%@AB@%_getactivepage%@AE@%   %@AB@%_gettextwindow%@AE@%    %@AB@%_outtext%@AE@%%@AB@%_getgtextvector%@AE@%  %@AB@%_getvideoconfig%@AE@%   %@AB@%_unregisterfonts%@AE@%%@AB@%_gettextcolor%@AE@%    %@AB@%_getvisualpage%@AE@%    %@AB@%_wrapon%@AE@%%@TE:   9   456 01 17 18 41 @%

 See the list below for the graphics functions that affect %@AB@%_grstatus%@AE@%. The
list shows error or warning messages that can be set by the graphics
function. In addition to the error codes listed, all of these functions can
produce the %@AB@%_GRERROR%@AE@% error code.  %@NL@%
%@NL@%
%@TH: 126  9075 03 36 83 33 @%%@AB@%Function%@AE@%                            Possible _grstatus                                                                 %@AB@%Possible _grstatus%@AE@%%@AB@%G%@AE@%                                   Error Codes                                                                        %@AB@%Warning Codes%@AE@%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%_arc%@AE@% functions                      %@AB@%_GRNOTINPROPERMODE,%@AE@%                                                                %@AB@%_GRNOOUTPUT,%@AE@%                                    %@AB@%_GRINVALIDPARAMETER%@AE@%                                                                %@AB@%_GRCLIPPED%@AE@%%@AB@%_clearscreen%@AE@%                        %@AB@%_GRNOTINPROPERMODE,%@AE@%                                    %@AB@%_GRINVALIDPARAMETER%@AE@%%@AB@%_ellipse%@AE@% functions                  %@AB@%_GRNOTINPROPERMODE,%@AE@%                                                                %@AB@%_GRNOOUTPUT,%@AE@%                                    %@AB@%_GRINVALIDPARAMETER,%@AE@%                                                               %@AB@%_GRCLIPPED%@AE@%                                    %@AB@%_GRINSUFFICIENTMEMORY%@AE@%                                                              %@AB@%_getarcinfo %@AE@%                        %@AB@%_GRNOTINPROPERMODE%@AE@%%@AB@%_getcurrentposition%@AE@%                 %@AB@%_GRNOTINPROPERMODE%@AE@%functions                           %@AB@%_getfontinfo%@AE@%                        (%@AB@% _GRERROR%@AE@% only)%@AB@%_getgtextextent%@AE@%                     (%@AB@% _GRERROR%@AE@% only)%@AB@%_getgtextvector%@AE@%                     %@AB@%_GRPARAMETERALTERED%@AE@%%@AB@%_getimage%@AE@%                           %@AB@%_GRNOTINPROPERMODE%@AE@%                                                                 %@AB@%_GRPARAMETERALTERED%@AE@%%@AB@%_getphyscoord%@AE@%                       %@AB@%_GRNOTINPROPERMODE%@AE@%%@AB@%_getpixel%@AE@%                           %@AB@%_GRNOTINPROPERMODE%@AE@%%@AB@%_gettextcursor%@AE@%                      %@AB@%_GRNOTINPROPERMODE%@AE@%%@AB@%_getviewcoord %@AE@%functions             %@AB@%_GRNOTINPROPERMODE%@AE@%%@AI@%Continued on next page%@AE@%              %@AB@%_getwindowcoord %@AE@%                    %@AB@%_GRNOTINPROPERMODE%@AE@%%@AB@%_getwritemode%@AE@%                       %@AB@%_GRNOTINPROPERMODE%@AE@%%@AB@%_imagesize%@AE@% functions                %@AB@%_GRNOTINPROPERMODE%@AE@%%@AB@%_lineto%@AE@% functions                   %@AB@%_GRNOTINPROPERMODE%@AE@%                                                                 %@AB@%_GRNOOUTPUT,%@AE@%                                                                                                                       %@AB@%_GRCLIPPED%@AE@%%@AB@%_moveto%@AE@% functions                   %@AB@%_GRNOTINPROPERMODE%@AE@%%@AB@%_outgtex%@AE@%t                           %@AB@%_GRNOTINPROPERMODE%@AE@%                                                                 %@AB@%_GRCLIPPED,%@AE@%                                                                                                                       %@AB@%_GRNOOUTPUT%@AE@%%@AB@%_pie%@AE@% functions                      %@AB@%_GRNOTINPROPERMODE,%@AE@%                                                                %@AB@%_GRNOOUTPUT,%@AE@%                                    %@AB@%_GRINVALIDPARAMETER,%@AE@%                                                               %@AB@%_GRCLIPPED%@AE@%                                    %@AB@%_GRINSUFFICIENTMEMORY%@AE@%                                                              %@AB@%_polygon%@AE@% functions                  %@AB@%_GRNOTINPROPERMODE,%@AE@%                                                                %@AB@%_GRNOOUTPUT,%@AE@%                                    %@AB@%_GRINVALIDPARAMETER,%@AE@%                                                               %@AB@%_GRCLIPPED%@AE@%                                    %@AB@%_GRINSUFFICIENTMEMORY%@AE@%                                                              %@AB@%_putimage%@AE@% functions                 %@AB@%_GRERROR,%@AE@%                                                                          %@AB@%_GRPARAMETERALTERED,%@AE@%                                    %@AB@%_GRNOTINPROPERMODE,%@AE@%                                                                %@AB@%_GRNOOUTPUT%@AE@%                                    %@AB@%_GRINVALIDPARAMETER,%@AE@%                                                                                                   %@AB@%_GRINVALIDIMAGEBUFFER%@AE@%                                                              %@AB@%_rectangle%@AE@% functions                %@AB@%_GRNOTINPROPERMODE,%@AE@%                                                                %@AB@%_GRNOOUTPUT,%@AE@%                                    %@AB@%_GRINVALIDPARAMETER,%@AE@%                                                               %@AB@%_GRCLIPPED%@AE@%                                    %@AB@%_GRINSUFFICIENTMEMORY%@AE@%                                                              %@AB@%_registerfonts%@AE@%                      %@AB@%_GRCORRUPTEDFONTFILE,%@AE@%                                    %@AB@%_GRFONTFILENOTFOUND,%@AE@%                                    %@AB@%_GRINSUFFICIENTMEMORY,%@AE@%                                    %@AB@%_GRINVALIDFONTFILE%@AE@%%@AB@%_scrolltextwindow%@AE@%                                                                                                      %@AB@%_GRNOOUTPUT%@AE@%%@AB@%_selectpalette%@AE@%                      %@AB@%_GRNOTINPROPERMODE,%@AE@%                                    %@AB@%_GRINVALIDPARAMETER%@AE@%%@AB@%_setactivepage%@AE@%                      %@AB@%_GRINVALIDPARAMETER%@AE@%%@AB@%_setbkcolor%@AE@%                         %@AB@%_GRINVALIDPARAMETER%@AE@%                                                                %@AB@%_GRPARAMETERALTERED%@AE@%%@AB@%_setcliprgn%@AE@%                         %@AB@%_GRNOTINPROPERMODE%@AE@%                                                                 %@AB@%_GRPARAMETERALTERED%@AE@%%@AB@%_setcolor%@AE@%                           %@AB@%_GRNOTINPROPERMODE%@AE@%                                                                 %@AB@%_GRPARAMETERALTERED%@AE@%%@AB@%_setfont%@AE@%                            %@AB@%_GRERROR,%@AE@%                                    %@AB@%_GRFONTFILENOTFOUND,%@AE@%                                    %@AB@%_GRINSUFFICIENTMEMORY,%@AE@%                                    %@AB@%_GRPARAMETERALTERED%@AE@%%@AI@%Continued on next page%@AE@%              %@AB@%_setgtextvector%@AE@%                     %@AB@%_GRPARAMETERALTERED%@AE@%%@AB@%_settextcolor%@AE@%                                                                                                          %@AB@%_GRPARAMETERALTERED%@AE@%%@AB@%_settextcursor%@AE@%                      %@AB@%_GRNOTINPROPERMODE%@AE@%%@AB@%_settextposition%@AE@%                                                                                                       %@AB@%_GRPARAMETERALTERED%@AE@%%@AB@%_settextrows%@AE@%                        %@AB@%_GRINVALIDPARAMETER%@AE@%                                                                %@AB@%_GRPARAMETERALTERED%@AE@%%@AB@%_settextwindow%@AE@%                                                                                                         %@AB@%_GRPARAMETERALTERED%@AE@%%@AB@%_setvideomode%@AE@%                       %@AB@%_GRERROR,%@AE@%                                    %@AB@%_GRMODENOTSUPPORTED,%@AE@%                                    %@AB@%_GRINVALIDPARAMETER%@AE@%%@AB@%_setvideomoderows%@AE@%                   %@AB@%_GRERROR,%@AE@%                                    %@AB@%_GRMODENOTSUPPORTED,%@AE@%                                    %@AB@%_GRINVALIDPARAMETER%@AE@%%@AB@%_setvieworg%@AE@%                         %@AB@%_GRNOTINPROPERMODE%@AE@%%@AB@%_setviewport%@AE@%                        %@AB@%_GRNOTINPROPERMODE%@AE@%                                                                 %@AB@%_GRPARAMETERALTERED%@AE@%%@AB@%_setvisualpage%@AE@%                      %@AB@%_GRINVALIDPARAMETER%@AE@%%@AB@%_setwindow%@AE@%                          %@AB@%_GRNOTINPROPERMODE,%@AE@%                                                                %@AB@%_GRPARAMETERALTERED%@AE@%                                    %@AB@%_GRINVALIDPARAMETER%@AE@%                                                                %@AB@%_setwritemode%@AE@%                       %@AB@%_GRNOTINPROPERMODE,%@AE@%                                    %@AB@%_GRINVALIDPARAMETER%@AE@%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE: 126  9075 03 36 83 33 @%

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_grstatus%@AE@% function returns the status of the most recently used graphics
function.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_arc%@AE@% functions,  %@AB@%_ellipse%@AE@% functions,  %@AB@%_floodfill%@AE@%,  %@AB@%_lineto%@AE@% functions,  %@AB@%_pie%@AE@%
functions, %@AB@%_remapallpalette%@AE@%,  %@AB@%_setactivepage%@AE@%,  %@AB@%_setbkcolor%@AE@%,  %@AB@%_setcolor%@AE@%,
%@AB@%_setpixel%@AE@% functions, %@AB@%_settextcolor%@AE@%,  %@AB@%_settextcursor%@AE@%,  %@AB@%_setvisualpage%@AE@%,
%@AB@%_setwindow%@AE@%,  %@AB@%_setwritemode%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:halloc@%%@NL@%
%@2@%%@CR:C6A01610783 @%%@AB@%halloc%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01610784 @%%@CR:C6A01610785 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Allocates a huge memory block.  %@NL@%
%@NL@%
%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  void _huge *halloc( long num, size_t size );%@AE@%%@NL@%
%@NL@%
%@AI@%num%@AE@%                               Number of elements

%@AI@%size%@AE@%                              Length in bytes of each element

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%halloc%@AE@% function allocates a huge array from the operating system
consisting of %@AI@%num%@AE@% elements, each of which is %@AI@%size%@AE@% bytes long. Each element
is initialized to 0. If the size of the array is greater than 128K (131,072
bytes), the size of an array element must then be a power of 2.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%halloc%@AE@% function returns a %@AB@%void huge%@AE@% pointer to the allocated space,
which is guaranteed to be suitably aligned for storage of any type of
object. To get a pointer to a type other than %@AB@%void huge%@AE@%, use a type cast on
the return value. If the request cannot be satisfied, the return value is
%@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%calloc%@AE@% functions, %@AB@%free%@AE@% functions, %@AB@%hfree%@AE@%, %@AB@%malloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* HALLOC.C: This program uses halloc to allocate space for 30,000 long
%@AS@%   * integers, then uses hfree to deallocate the memory.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <malloc.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     long _huge *hbuf;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Allocate huge buffer */
%@AS@%     hbuf = (long _huge *)halloc( 30000L, sizeof( long ) );
%@AS@%     if ( hbuf == NULL )
%@AS@%        printf( "Insufficient memory available\n" );
%@AS@%     else
%@AS@%        printf( "Memory successfully allocated\n" );
%@AS@%  
%@AS@%     /* Free huge buffer */
%@AS@%     hfree( hbuf );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Memory successfully allocated %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_hard@%%@NL@%
%@2@%%@CR:C6A01620786 @%%@AB@%_hard Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Handle critical error conditions.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _harderr( void( _far *handler )());%@AE@%%@NL@%
%@NL@%
%@AS@%  void _hardresume( int result );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _hardretn( int error );%@AE@%%@NL@%
%@NL@%
%@AI@%handler %@AE@%%@AB@%( )%@AE@%                       New INT 0x24 handler

%@AI@%result %@AE@%                           Handler return parameter

%@AI@%error%@AE@%                             Error to return from

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
These three functions are used to handle critical error conditions that use
DOS interrupt 0x24. The %@AB@%_harderr%@AE@% function installs a new critical-error
handler for interrupt 0x24.  %@NL@%
%@NL@%
The %@AB@%_hardresume%@AE@% and %@AB@%_hardreturn%@AE@% functions control how the program will
return from the new critical-error handler installed by %@AB@%_harderr%@AE@%. The
%@AB@%_hardresume%@AE@% function returns to DOS from a user-installed critical-error
handler, and the %@AB@%_hardreturn%@AE@% function returns directly to the application
program from a user-installed critical-error handler.  %@NL@%
%@NL@%
The %@AB@%_harderr%@AE@% function does not directly install the handler pointed to by
%@AI@%handler%@AE@%; instead, %@AB@%_harderr%@AE@% installs a handler that calls the function
referenced by %@AI@%handler%@AE@%. The handler calls the function with the following
parameters:   %@NL@%
%@NL@%
%@AS@%  handler(unsigned deverror, unsigned errcode, unsigned far *devhdr);
%@AS@%   %@AE@%%@NL@%
%@NL@%
The %@AI@%deverror%@AE@% argument is the device error code. It contains the AX register
value passed by DOS to the INT 0x24 handler. The %@AI@%errcode%@AE@% argument is the DI
register value that DOS passes to the handler. The low-order byte of %@AI@%errcode%@AE@%
can be one of the following values:  %@NL@%
%@NL@%
%@AB@%Code%@AE@%                              %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%0%@AE@%                                 Attempt to write to a write-protected 
                                  disk

%@AB@%1%@AE@%                                 Unknown unit

%@AB@%2%@AE@%                                 Drive not ready

%@AB@%3%@AE@%                                 Unknown command

%@AB@%4%@AE@%                                 Cyclic-redundancy-check error in data

%@AB@%5%@AE@%                                 Bad drive-request structure length

%@AB@%6%@AE@%                                 Seek error

%@AB@%7%@AE@%                                 Unknown media type

%@AB@%8%@AE@%                                 Sector not found

%@AB@%9%@AE@%                                 Printer out of paper

%@AB@%10%@AE@%                                Write fault

%@AB@%11%@AE@%                                Read fault

%@AB@%12%@AE@%                                General failure

The %@AI@%devhdr%@AE@% argument is a far pointer to a device header that contains
descriptive information about the device on which the error occurred. The
user-defined handler must not change the information in the device-header
control block.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Errors on Disk Devices%@AE@%%@EH@%%@NL@%
%@NL@%
If the error occurred on a disk device, the high-order bit (bit 15) of the
%@AI@%deverror%@AE@% argument will be set to 0, and the %@AI@%deverror%@AE@% argument will indicate
the following:  %@NL@%
%@NL@%
%@AB@%Bit%@AE@%                               %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%15%@AE@%                                Disk error if false (0).

%@AB@%14%@AE@%                                Not used.

%@AB@%13%@AE@%                                "Ignore" response not allowed if false 
                                  (0).

%@AB@%12%@AE@%                                "Retry" response not allowed if false 
                                  (0).

%@AB@%11%@AE@%                                "Fail" response not allowed if false 
                                  (0). Note that DOS changes "fail" to 
                                  "abort".

%@AB@%10, 9%@AE@%

                                  %@AB@%Code%@AE@%      %@AB@%Location%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
                                  %@AB@%00%@AE@%          DOS

                                  %@AB@%01%@AE@%          File allocation table

                                  %@AB@%10%@AE@%          Directory

                                  %@AB@%11%@AE@%          Data area

%@AB@%%@AE@%                                  
%@AB@%8%@AE@%                                 Read error if false; write error if 
                                  true.

The low-order byte of %@AI@%deverror%@AE@% indicates the drive in which the error
occurred (0 = drive A, 1 = drive B, etc.).  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Errors on Other Devices%@AE@%%@EH@%%@NL@%
%@NL@%
If the error occurs on a device other than a disk drive, the high-order bit
(bit 15) of the %@AI@%deverror%@AE@% argument is 1. The attribute word located at offset
4 in the device-header block indicates the type of device that had the
error. If bit 15 of the attribute word is 0, the error is a bad memory image
of the file allocation table. If the bit is 1, the error occurred on a
character device and bits 0-3 of the attribute word indicate the type of
device, as shown in the following list:  %@NL@%
%@NL@%
%@AB@%Bit%@AE@%                               %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%0%@AE@%                                 Current standard input

%@AB@%1%@AE@%                                 Current standard output

%@AB@%2%@AE@%                                 Current null device

%@AB@%3%@AE@%                                 Current clock device

%@NL@%
%@4@%%@AB@%Restrictions on Handler Functions%@AE@%%@EH@%%@NL@%
%@NL@%
The user-defined handler function can issue only system calls 0x01 through
0x0C, or 0x59. Thus, many of the standard C run-time functions (such as
stream I/O and low-level I/O) cannot be used in a hardware error handler.
Function 0x59 can be used to obtain further information about the error that
occurred.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Using _hardresume and _harderr%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%If the handler returns, it can do so%@AE@% - %@NL@%
  1.  From the %@AB@%return%@AE@% statement%@NL@%
%@NL@%
  2.  From the %@AB@%_hardresume%@AE@% function%@NL@%
%@NL@%
  3.  From the %@AB@%_hardretn%@AE@% function%@NL@%
%@NL@%
%@NL@%

If the handler returns from %@AB@%_hardresume%@AE@% or from a %@AB@%return%@AE@% statement, the
handler returns to DOS.  %@NL@%
%@NL@%
The %@AB@%_hardresume%@AE@% function should be called only from within the user-defined
hardware error-handler function. The result supplied to %@AB@%_hardresume%@AE@% must be
one of the following constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Action%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_HARDERR_ABORT%@AE@%                    Abort the program by issuing INT 0x23

%@AB@%_HARDERR_FAIL%@AE@%                     Fail the system call that is in progress
                                  (this is not supported on DOS 2. x)

%@AB@%_HARDERR_IGNORE%@AE@%                   Ignore the error

%@AB@%_HARDERR_RETRY%@AE@%                    Retry the operation

The %@AB@%_hardretn%@AE@% function allows the user-defined hardware error handler to
return directly to the application program rather than returning to DOS. The
application resumes at the point just after the failing I/O function
request. The %@AB@%_hardretn%@AE@% function should be called only from within a
user-defined hardware error-handler function.  %@NL@%
%@NL@%
The error parameter of %@AB@%_hardretn%@AE@% should be a DOS error code, as opposed to
the XENIX-style error code that is available in %@AB@%errno%@AE@%. Refer to %@AI@%MS-DOS
%@AI@%Encyclopedia%@AE@% (Duncan, ed.; Redmond, Wa.: Microsoft Press, 1988) or%@AI@%
%@AI@%Programmer's PC Sourcebook%@AE@% (Hogan; Redmond, Wa.: Microsoft Press, 1988) for
information about the DOS error codes that may be returned by a given DOS
function call.  %@NL@%
%@NL@%
If the failing I/O function request is an INT 0x21 function greater than or
equal to function 0x38, %@AB@%_hardretn%@AE@% will then return to the application with
the carry flag set and the AX register set to the %@AB@%_hardretn%@AE@% %@AI@%error%@AE@% parameter.
If the failing INT 0x21 function request is less than function 0x38 and the
function can return an error, the AL register will be set to 0xFF on return
to the application. If the failing INT 0x21 does not have a way of returning
an error condition (which is true of certain INT 0x21 functions below 0x38),
the error parameter of %@AB@%_hardretn%@AE@% is not used, and no error code is returned
to the application.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_chain_intr%@AE@%, %@AB@% _dos_getvect%@AE@%, %@AB@% _dos_setvect%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_heapadd@%%@NL@%
%@2@%%@CR:C6A01630787 @%%@AB@%_heapadd Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01630788 @%%@CR:C6A01630789 @% %@CR:C6A01630790 @% %@CR:C6A01630791 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Add memory to the heap %@AB@%(_heapadd)%@AE@% or to the based heap %@AB@%(_bheapadd)%@AE@%.  %@NL@%
%@NL@%
%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  int _heapadd( void _far *memblock, size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _bheapadd( _segment seg, void _based (void) *memblock, size_t size );%@AE@%%@NL@%
%@NL@%
%@AI@%seg%@AE@%                               Based-heap segment selector

%@AI@%buffer%@AE@%                            Pointer to heap memory

%@AI@%size%@AE@%                              Size in bytes of memory to add

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_heapadd%@AE@% and %@AB@%_bheapadd%@AE@% functions add an unused piece of memory to the
heap. The %@AB@%_bheapadd%@AE@% function adds the memory to the based heap specified by
%@AI@%seg%@AE@%. The %@AB@%_heapadd%@AE@% function looks at the segment value and, if it is DGROUP,
adds the memory to the near heap. Otherwise, %@AB@%_heapadd%@AE@% adds the memory to the
far heap.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return 0 if successful, or -1 if an error occurred.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%free%@AE@% functions, %@AB@%halloc%@AE@%, %@AB@%hfree%@AE@%, %@AB@%malloc%@AE@% functions, %@AB@%realloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* HEAPMIN.C: This program illustrates heap management using
%@AS@%   * _heapadd and _heapmin.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <process.h>
%@AS@%  #include <malloc.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void heapdump( char *msg );     /* Prototype */
%@AS@%  
%@AS@%  char s1[] = { "Here are some strings that we use at first, then don't\n"
%@AS@%};
%@AS@%  char s2[] = { "need any more. We'll give their space to the heap.\n" };
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%      int *p[3], i;
%@AS@%  
%@AS@%      printf( "%s%s", s1, s2 );
%@AS@%      heapdump( "Initial heap" );
%@AS@%  
%@AS@%      /* Give space of used strings to heap. */
%@AS@%      _heapadd( s1, sizeof( s1 ) );
%@AS@%      _heapadd( s2, sizeof( s2 ) );
%@AS@%      heapdump( "After adding used strings" );
%@AS@%  
%@AS@%      /* Allocate some blocks. Some may use string blocks from _heapadd. */
%@AS@%      for( i = 0; i < 2; i++ )
%@AS@%          if( (p[i] = (int *)calloc( 10 * (i + 1), sizeof( int ) )) == NULL
%@AS@%)
%@AS@%          {
%@AS@%              --i;
%@AS@%              break;
%@AS@%          }
%@AS@%      heapdump( "After allocating memory" );
%@AS@%  
%@AS@%      /* Free some of the blocks. */
%@AS@%      free( p[1] );
%@AS@%      free( p[2] );
%@AS@%      heapdump( "After freeing memory" );
%@AS@%  
%@AS@%      /* Minimize heap. */
%@AS@%      _heapmin();
%@AS@%      heapdump( "After compacting heap" );
%@AS@%  }
%@AS@%  
%@AS@%  /* Walk through heap entries, displaying information about each block. */
%@AS@%  void heapdump( char *msg )
%@AS@%  {
%@AS@%      struct _heapinfo hi;
%@AS@%  
%@AS@%      printf( "%s\n", msg );
%@AS@%      hi._pentry = NULL;
%@AS@%      while( _heapwalk( &hi ) == _HEAPOK )
%@AS@%          printf( "\t%s block at %Fp of size %u\t\n",
%@AS@%                  hi._useflag == _USEDENTRY ? "USED" : "FREE",
%@AS@%                  hi._pentry,
%@AS@%                  hi._size );
%@AS@%      getch();
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Here are some strings that we use at first, then don't
%@AS@%  need any more. We'll give their space to the heap.
%@AS@%  Initial heap
%@AS@%     USED block at 2D39:0E9C of size 364   
%@AS@%     USED block at 2D39:100A of size 36   
%@AS@%     USED block at 2D39:1030 of size 512   
%@AS@%     FREE block at 2D39:1232 of size 460   
%@AS@%  After adding used strings
%@AS@%     FREE block at 2D39:0044 of size 52   
%@AS@%     FREE block at 2D39:007A of size 50   
%@AS@%     USED block at 2D39:00AE of size 3564   
%@AS@%     USED block at 2D39:0E9C of size 364   
%@AS@%     USED block at 2D39:100A of size 36   
%@AS@%     USED block at 2D39:1030 of size 512   
%@AS@%     FREE block at 2D39:1232 of size 460   
%@AS@%  After allocating memory
%@AS@%     USED block at 2D39:0044 of size 20   
%@AS@%     USED block at 2D39:005A of size 40   
%@AS@%     FREE block at 2D39:0084 of size 40   
%@AS@%     USED block at 2D39:00AE of size 3564   
%@AS@%     USED block at 2D39:0E9C of size 364   
%@AS@%     USED block at 2D39:100A of size 36   
%@AS@%     USED block at 2D39:1030 of size 512   
%@AS@%     FREE block at 2D39:1232 of size 460   
%@AS@%  After freeing memory
%@AS@%     USED block at 2D39:0044 of size 20   
%@AS@%     FREE block at 2D39:005A of size 40   
%@AS@%     FREE block at 2D39:0084 of size 40   
%@AS@%     USED block at 2D39:00AE of size 3564   
%@AS@%     USED block at 2D39:0E9C of size 364   
%@AS@%     USED block at 2D39:100A of size 36   
%@AS@%     USED block at 2D39:1030 of size 512   
%@AS@%     FREE block at 2D39:1232 of size 460   
%@AS@%  After compacting heap
%@AS@%     USED block at 2D39:0044 of size 20   
%@AS@%     FREE block at 2D39:005A of size 82   
%@AS@%     USED block at 2D39:00AE of size 3564   
%@AS@%     USED block at 2D39:0E9C of size 364   
%@AS@%     USED block at 2D39:100A of size 36   
%@AS@%     USED block at 2D39:1030 of size 512   
%@AS@%     FREE block at 2D39:1232 of size 12   %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_heapchk@%%@NL@%
%@2@%%@CR:C6A01640792 @%%@AB@%_heapchk Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01640793 @%%@CR:C6A01640794 @% %@CR:C6A01640795 @% %@CR:C6A01640796 @% %@CR:C6A01640797 @% %@CR:C6A01640798 @% %@CR:C6A01640799 @%%@CR:C6A01640800 @% %@CR:C6A01640801 @% %@CR:C6A01640802 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Run consistency checks on the heap.  %@NL@%
%@NL@%
%@AS@%  #include <malloc.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int _heapchk( void );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _bheapchk( _segment seg );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _fheapchk( void );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _nheapchk( void );%@AE@%%@NL@%
%@NL@%
%@AI@%seg %@AE@%                              Specified base heap

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_heapchk%@AE@% routines help to debug heap-related problems by checking for
minimal consistency of the heap.  %@NL@%
%@NL@%
Each function checks a particular heap, as listed below:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Heap Checked%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_heapchk%@AE@%                          Depends on data model of program

%@AB@%_bheapchk%@AE@%                         Based heap specified by %@AI@%seg%@AE@% value

%@AB@%_fheapchk%@AE@%                         Far heap (outside the default data 
                                  segment)

%@AB@%_nheapchk%@AE@%                         Near heap (inside the default data 
                                  segment)

In large data models (that is, compact-, large-, and huge-model programs),
%@AB@%_heapchk%@AE@% maps to %@AB@%_fheapchk%@AE@%. In small data models (tiny-, small-, and
medium-model programs), %@AB@%_heapchk%@AE@% maps to %@AB@%_nheapchk%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
All four routines return an integer value that is one of the following
manifest constants (defined in MALLOC.H):  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_HEAPBADBEGIN%@AE@%                     Initial header information cannot be 
                                  found, or it is bad

%@AB@%_HEAPBADNODE%@AE@%                      Bad node has been found, or the heap is 
                                  damaged

%@AB@%_HEAPEMPTY%@AE@%                        Heap has not been initialized

%@AB@%_HEAPOK%@AE@%                           Heap appears to be consistent

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_heapset%@AE@% functions,  %@AB@%_heapwalk%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* HEAPCHK.C: This program checks the heap for consistency
%@AS@%   * and prints an appropriate message.
%@AS@%   */
%@AS@%  
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int  heapstatus;
%@AS@%     char *buffer;
%@AS@%  
%@AS@%     /* Allocate and deallocate some memory */
%@AS@%     if( (buffer = (char *)malloc( 100 )) != NULL )
%@AS@%        free( buffer );
%@AS@%  
%@AS@%     /* Check heap status */
%@AS@%     heapstatus = _heapchk();
%@AS@%     switch( heapstatus )
%@AS@%     {
%@AS@%        case _HEAPOK:
%@AS@%           printf(" OK - heap is fine\n" );
%@AS@%           break;
%@AS@%        case _HEAPEMPTY:
%@AS@%           printf(" OK - heap is empty\n" );
%@AS@%           break;
%@AS@%        case _HEAPBADBEGIN:
%@AS@%           printf( "ERROR - bad start of heap\n" );
%@AS@%           break;
%@AS@%        case _HEAPBADNODE:
%@AS@%           printf( "ERROR - bad node in heap\n" );
%@AS@%           break;
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%   OK - heap is fine %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_heapmin@%%@NL@%
%@2@%%@CR:C6A01650803 @%%@AB@%_heapmin Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01650804 @%%@CR:C6A01650805 @% %@CR:C6A01650806 @% %@CR:C6A01650807 @% %@CR:C6A01650808 @% %@CR:C6A01650809 @% %@CR:C6A01650810 @% %@CR:C6A01650811 @%%@CR:C6A01650812 @% %@CR:C6A01650813 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Release unused heap memory to the operating system.  %@NL@%
%@NL@%
%@AS@%  #include <malloc.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int _heapmin( void );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _bheapmin( _segment seg )%@AE@%%@NL@%
%@NL@%
%@AS@%  int _fheapmin( void );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _nheapmin( void );%@AE@%%@NL@%
%@NL@%
%@AI@%seg%@AE@%                               Specified based-heap selector

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_heapmin%@AE@% functions minimize the heap by releasing unused heap memory to
the operating system.  %@NL@%
%@NL@%
The various %@AB@%_heapmin%@AE@% functions release unused memory in these heaps:  %@NL@%
%@NL@%
%@AB@%Function %@AE@%                         %@AB@%Heap Minimized%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_heapmin%@AE@%                          Depends on data model of program

%@AB@%_bheapmin%@AE@%                         Based heap specified by %@AI@%seg%@AE@% value; %@AB@%%@AE@%
                                  %@AB@%_NULLSEG%@AE@% specifies all based heaps

%@AB@%_fheapmin%@AE@%                         Far heap (outside default data segment)

%@AB@%_nheapmin%@AE@%                         Near heap (inside default data segment)

In large data models (that is, compact-, large-, and huge-model programs),
%@AB@%_heapmin%@AE@% maps to %@AB@%_fheapmin%@AE@%. In small data models (tiny-, small-, and
medium-model programs), %@AB@%_heapmin%@AE@% maps to %@AB@%_nheapmin%@AE@%.  %@NL@%
%@NL@%
Based-heap segments are never freed (i.e., unlinked from the based heap list
and released back to the operating system) by the %@AB@%_bheapmin%@AE@% function. The
%@AB@%_bfreeseg%@AE@% function is used for that purpose.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_heapmin%@AE@% functions return 0 if the function completed successfully, or
-1 in the case of an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_bfreeseg%@AE@%, %@AB@%free%@AE@% functions, %@AB@%malloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_heapset@%%@NL@%
%@2@%%@CR:C6A01660814 @%%@AB@%_heapset Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01660815 @% %@CR:C6A01660816 @% %@CR:C6A01660817 @%%@CR:C6A01660818 @% %@CR:C6A01660819 @%%@CR:C6A01660820 @% %@CR:C6A01660821 @%%@CR:C6A01660822 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Check heaps for minimal consistency and set the free entries to a specified
value.  %@NL@%
%@NL@%
%@AS@%  #include <malloc.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int _heapset( unsigned int fill );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _bheapset( _segment seg, unsigned int fill );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _fheapset( unsigned int fill );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _nheapset( unsigned int fill );%@AE@%%@NL@%
%@NL@%
%@AI@%fill%@AE@%                              Fill character

%@AI@%seg%@AE@%                               Specified based-heap segment selector

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_heapset%@AE@% family of routines helps debug heap-related problems in
programs by showing free memory locations or nodes unintentionally
overwritten.  %@NL@%
%@NL@%
The %@AB@%_heapset%@AE@% routines first check for minimal consistency on the heap in a
manner identical to that of the %@AB@%_heapchk%@AE@% functions. After the consistency
check, the %@AB@%_heapset%@AE@% functions set each byte of the heap's free entries to
the %@AI@%fill%@AE@% value. This known value shows which memory locations of the heap
contain free nodes and which locations contain data that were
unintentionally written to freed memory.  %@NL@%
%@NL@%
The various %@AB@%_heapset%@AE@% functions check and fill these heaps:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Heap Filled%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_heapset%@AE@%                          Depends on data model of program

%@AB@%_bheapset%@AE@%                         Based heap specified by %@AI@%seg%@AE@% value; %@AB@%%@AE@%
                                  %@AB@%_NULLSEG %@AE@%specifies all based heaps

%@AB@%_fheapset%@AE@%                         Far heap (outside default data segment)

%@AB@%_nheapset%@AE@%                         Near heap (inside default data segment)

In large data models (that is, compact-, large-, and huge-model programs),
%@AB@%_heapset%@AE@% maps to %@AB@%_fheapset%@AE@%. In small data models (tiny-, small-, and
medium-model programs), %@AB@%_heapset%@AE@% maps to %@AB@%_nheapset%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
All four routines return an %@AB@%int%@AE@% whose value is one of the following manifest
constants (defined in MALLOC.H):  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_HEAPBADBEGIN%@AE@%                     Initial header information cannot be 
                                  found, or it is invalid 

%@AB@%_HEAPBADNODE%@AE@%                      Bad node has been found, or the heap is 
                                  damaged

%@AB@%_HEAPEMPTY%@AE@%                        Heap has not been initialized 

%@AB@%_HEAPOK%@AE@%                           Heap appears to be consistent

%@AB@%%@AE@%

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_heapchk%@AE@% functions,  %@AB@%_heapwalk%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* HEAPSET.C: This program checks the heap and fills in free entries
%@AS@%   * with the character 'Z'.
%@AS@%   */
%@AS@%  
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int heapstatus;
%@AS@%     char *buffer;%@AE@%%@NL@%
%@NL@%
%@AS@%  if( (buffer = malloc( 1 )) == NULL )   /* Make sure heap is initialized */
%@AS@%        exit( 0 );
%@AS@%     heapstatus = _heapset( 'Z' );          /* Fill in free entries */
%@AS@%     switch( heapstatus )
%@AS@%     {
%@AS@%        case _HEAPOK:
%@AS@%           printf( "OK - heap is fine\n" );
%@AS@%           break;
%@AS@%        case _HEAPEMPTY:
%@AS@%           printf( "OK - heap is empty\n" );
%@AS@%           break;
%@AS@%        case _HEAPBADBEGIN:
%@AS@%           printf( "ERROR - bad start of heap\n" );
%@AS@%           break;
%@AS@%        case _HEAPBADNODE:
%@AS@%           printf( "ERROR - bad node in heap\n" );
%@AS@%           break;
%@AS@%     }
%@AS@%     free( buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  OK - heap is fine %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_heapwalk@%%@NL@%
%@2@%%@CR:C6A01670823 @%%@AB@%_heapwalk Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01670824 @%%@CR:C6A01670825 @% %@CR:C6A01670826 @%%@CR:C6A01670827 @% %@CR:C6A01670828 @% %@CR:C6A01670829 @%%@CR:C6A01670830 @% %@CR:C6A01670831 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Traverse the heap and return information about the next entry.  %@NL@%
%@NL@%
%@AS@%  include <malloc.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int _heapwalk( _HEAPINFO *entryinfo );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _bheapwalk( _segment seg, _HEAPINFO *entryinfo );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _fheapwalk( _HEAPINFO *entryinfo );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _nheapwalk(_HEAPINFO *entryinfo);%@AE@%%@NL@%
%@NL@%
%@AI@%entryinfo%@AE@%                         Buffer to contain heap information

%@AI@%seg%@AE@%                               Based-heap segment selector

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_heapwalk%@AE@% family of routines helps debug heap-related problems in
programs.  %@NL@%
%@NL@%
The %@AB@%_heapwalk%@AE@% routines walk through the heap, traversing one entry per call,
and return a pointer to a %@AB@%_heapinfo%@AE@% structure that contains information
about the next heap entry. The %@AB@%_heapinfo%@AE@% structure, defined in MALLOC.H,
contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%int far *_pentry%@AE@%                  Heap entry pointer

%@AB@%size_t  _size%@AE@%                     Size of heap entry

%@AB@%int _useflag%@AE@%                      Entry "in use" flag

A call to %@AB@%_heapwalk%@AE@% that returns %@AB@%_HEAPOK%@AE@% stores the size of the entry in the
%@AB@%_size%@AE@% field and sets the %@AB@%_useflag%@AE@% field to either %@AB@%_FREEENTRY%@AE@% or %@AB@%_USEDENTRY%@AE@%
(both are constants defined in MALLOC.H). To obtain this information about
the first entry in the heap, pass the %@AB@%_heapwalk%@AE@% routine a pointer to a
%@AB@%_heapinfo%@AE@% structure whose %@AB@%_pentry%@AE@% field is %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
The various %@AB@%_heapwalk%@AE@% functions walk through and gather information on these
heaps:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Heap Walked%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_heapwalk%@AE@%                         Depends on data model of program

%@AB@%_bheapwalk%@AE@%                        Based heap specified by %@AI@%seg%@AE@% value; %@AB@%%@AE@%
                                  %@AB@%_NULLSEG%@AE@% specifies all based heaps

%@AB@%_fheapwalk%@AE@%                        Far heap (outside default data segment)

%@AB@%_nheapwalk%@AE@%                        Near heap (inside default data segment)

In large data models (that is, compact-, large-, and huge-model programs),
%@AB@%_heapwalk%@AE@% maps to %@AB@%_fheapwalk%@AE@%. In small data models (tiny-, small-, and
medium-model programs), %@AB@%_heapwalk%@AE@% maps to %@AB@%_nheapwalk%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
All three routines return one of the following manifest constants (defined
in MALLOC.H):  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_HEAPBADBEGIN%@AE@%                     The initial header information cannot be
                                  found, or it is invalid.

%@AB@%_HEAPBADNODE%@AE@%                      A bad node has been found, or the heap 
                                  is damaged.

%@AB@%_HEAPBADPTR%@AE@%                       The %@AB@%_pentry%@AE@% field of the %@AB@%_heapinfo%@AE@% 
                                  structure does not contain a valid 
                                  pointer into the heap.

%@AB@%_HEAPEND%@AE@%                          The end of the heap has been reached 
                                  successfully.

%@AB@%_HEAPEMPTY%@AE@%                        The heap has not been initialized.

%@AB@%_HEAPOK%@AE@%                           No errors so far; the %@AB@%_heapinfo%@AE@% 
                                  structure contains information about the
                                  next entry.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_heapchk%@AE@% functions,  %@AB@%_heapset%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* HEAPWALK.C: This program "walks" the heap, starting at the beginning
%@AS@%   * (_pentry = NULL). It prints out each heap entry's use, location,
%@AS@%   * and size. It also prints out information about the overall state
%@AS@%   * of the heap as soon as _heapwalk returns a value other than _HEAPOK.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <malloc.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void heapdump( void );
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *buffer;
%@AS@%  
%@AS@%     heapdump();
%@AS@%     if( (buffer = malloc( 59 )) != NULL )
%@AS@%     {
%@AS@%        heapdump();
%@AS@%        free( buffer );
%@AS@%     }
%@AS@%     heapdump();
%@AS@%  }
%@AS@%  
%@AS@%  void heapdump( void )
%@AS@%  {
%@AS@%     struct _heapinfo hinfo;
%@AS@%     int heapstatus;
%@AS@%  
%@AS@%     hinfo._pentry = NULL;
%@AS@%     while( ( heapstatus = _heapwalk( &hinfo ) ) == _HEAPOK )
%@AS@%     {
%@AS@%        printf( "%6s block at %Fp of size %4.4X\n",
%@AS@%           ( hinfo._useflag == _USEDENTRY ? "USED" : "FREE" ),
%@AS@%           hinfo._pentry, hinfo._size );
%@AS@%     }
%@AS@%  
%@AS@%     switch( heapstatus )
%@AS@%     {
%@AS@%        case _HEAPEMPTY:
%@AS@%           printf( "OK - empty heap\n" );
%@AS@%           break;
%@AS@%        case _HEAPEND:
%@AS@%           printf( "OK - end of heap\n" );
%@AS@%           break;
%@AS@%        case _HEAPBADPTR:
%@AS@%           printf( "ERROR - bad pointer to heap\n" );
%@AS@%           break;
%@AS@%        case _HEAPBADBEGIN:
%@AS@%           printf( "ERROR - bad start of heap\n" );
%@AS@%           break;
%@AS@%        case _HEAPBADNODE:
%@AS@%           printf( "ERROR - bad node in heap\n" );
%@AS@%           break;
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%    USED block at 0067:103E of size 000E
%@AS@%    USED block at 0067:104E of size 01F4
%@AS@%    USED block at 0067:1244 of size 0026
%@AS@%    USED block at 0067:126C of size 0200
%@AS@%    FREE block at 0067:146E of size 0B90
%@AS@%  OK - end of heap
%@AS@%    USED block at 0067:103E of size 000E
%@AS@%    USED block at 0067:104E of size 01F4
%@AS@%    USED block at 0067:1244 of size 0026
%@AS@%    USED block at 0067:126C of size 0200
%@AS@%    USED block at 0067:146E of size 003C
%@AS@%    FREE block at 0067:14AC of size 0B52
%@AS@%  OK - end of heap
%@AS@%    USED block at 0067:103E of size 000E
%@AS@%    USED block at 0067:104E of size 01F4
%@AS@%    USED block at 0067:1244 of size 0026
%@AS@%    USED block at 0067:126C of size 0200
%@AS@%    FREE block at 0067:146E of size 003C
%@AS@%    FREE block at 0067:14AC of size 0B52
%@AS@%  OK - end of heap %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:hfree@%%@NL@%
%@2@%%@CR:C6A01680832 @%%@AB@%hfree%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01680833 @%%@CR:C6A01680834 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Frees a huge memory block.  %@NL@%
%@NL@%
%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  void hfree( void _huge *memblock );%@AE@%%@NL@%
%@NL@%
%@AI@%memblock%@AE@%                          Pointer to allocated memory block

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%hfree%@AE@% function deallocates a memory block; the freed memory is returned
to the operating system. The %@AI@%memblock%@AE@% argument points to a memory block
previously allocated through a call to %@AB@%halloc%@AE@%. The number of bytes freed is
the number of bytes specified when the block was allocated.  %@NL@%
%@NL@%
Note that attempting to free an invalid %@AI@%memblock%@AE@% argument (one not allocated
with %@AB@%halloc%@AE@%) may affect subsequent allocation and cause errors.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%halloc%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* HALLOC.C: This program uses halloc to allocate space for 30,000 long
%@AS@%   * integers, then uses hfree to deallocate the memory.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <malloc.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     long _huge *hbuf;
%@AS@%  
%@AS@%     /* Allocate huge buffer */
%@AS@%     hbuf = (long _huge *)halloc( 30000L, sizeof( long ) );
%@AS@%     if ( hbuf == NULL )
%@AS@%        printf( "Insufficient memory available\n" );
%@AS@%     else
%@AS@%        printf( "Memory successfully allocated\n" );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Free huge buffer */
%@AS@%     hfree( hbuf );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Memory successfully allocated %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:hypot@%%@QR:hypotl@%%@NL@%
%@2@%%@CR:C6A01690835 @%%@AB@%hypot, hypotl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01690836 @%%@CR:C6A01690837 @%%@CR:C6A01690838 @% %@CR:C6A01690839 @%%@CR:C6A01690840 @% %@CR:C6A01690841 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate the hypotenuse.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double hypot( double x, double y );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double hypotl( long double x, long double y );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              Floating-point values

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%hypot%@AE@% and %@AB@%hypotl%@AE@% functions calculate the length of the hypotenuse of a
right triangle, given the length of the two sides %@AI@%x%@AE@% and %@AI@%y%@AE@% (or %@AI@%xl%@AE@% and %@AI@%yl%@AE@%). A
call to %@AB@%hypot%@AE@% is equivalent to the following:   %@NL@%
%@NL@%
%@AS@%  sqrt(x*x + y*y);
%@AS@%   %@AE@%%@NL@%
%@NL@%
The %@AB@%hypotl%@AE@% function uses the 80-bit, 10-byte coprocessor form of arguments
and return values. See the reference page on the long double functions for
more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The functions return the length of the hypotenuse. If an overflow results,
the functions return %@AB@%HUGE_VAL%@AE@% and set %@AB@%errno%@AE@% to %@AB@%ERANGE.%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%hypot%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%hypotl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cabs%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* HYPOT.C: This program prints the hypotenuse of a right triangle. */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     double x = 3.0, y = 4.0;
%@AS@%  
%@AS@%     printf( "If a right triangle has sides %2.1f and %2.1f, "
%@AS@%             "its hypotenuse is %2.1f\n", x, y, hypot( x, y ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  If a right triangle has sides 3.0 and 4.0, its hypotenuse is 5.0%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_imagesize@%%@NL@%
%@2@%%@CR:C6A01700842 @%%@AB@%_imagesize Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01700843 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Get amount of memory required to store graphics images.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  long _far _imagesize( short x1, short y1, short x2, short y2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  long _far _imagesize_w( double wx1, double wy1, double wx2, double wy2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  long _far _imagesize_wxy( struct _wxycoord _far *pwxy1, 
%@AS@%  struct _wxycoord _far *pwxy2 );%@AE@%%@NL@%
%@NL@%
%@AI@%x1%@AE@%, %@AI@%y1%@AE@%                            Upper-left corner of bounding rectangle

%@AI@%x2%@AE@%, %@AI@%y2%@AE@%                            Lower-right corner of bounding rectangle

%@AI@%wx1%@AE@%, %@AI@%wy1%@AE@%                          Upper-left corner of bounding rectangle

%@AI@%wx2%@AE@%, %@AI@%wy2%@AE@%                          Lower-right corner of bounding rectangle

%@AI@%pwxy1%@AE@%                             Upper-left corner of bounding rectangle

%@AI@%pwxy2%@AE@%                             Lower-right corner of bounding rectangle

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The functions in the %@AB@%_imagesize%@AE@% family return the number of bytes needed to
store the image defined by the bounding rectangle and specified by the
coordinates given in the function call.  %@NL@%
%@NL@%
The %@AB@%_imagesize%@AE@% function defines the bounding rectangle in terms of
view-coordinate points (%@AI@%x1%@AE@%, %@AI@%y1%@AE@%) and (%@AI@%x2%@AE@%, %@AI@%y2%@AE@%).  %@NL@%
%@NL@%
The %@AB@%_imagesize_w%@AE@% function defines the bounding rectangle in terms of
window-coordinate points (%@AI@%x1%@AE@%, %@AI@%y1%@AE@%) and (%@AI@%x2%@AE@%, %@AI@%y2%@AE@%).  %@NL@%
%@NL@%
The %@AB@%_imagesize_wxy%@AE@% function defines the bounding rectangle in terms of the
window-coordinate pairs %@AI@%pwxy1%@AE@% and %@AI@%pwxy2%@AE@%.  %@NL@%
%@NL@%
The number of bytes needed to store the image is determined by the following
formula:  %@NL@%
%@NL@%
%@AS@%  xwid = abs(x1-x2)+1;
%@AS@%  ywid = abs(y1-y2)+1;
%@AS@%  size = 4+((long)((xwid*bits_per_pixel+7)/8)*(long)ywid);%@AE@%%@NL@%
%@NL@%
A call to %@AB@%_getvideoconfig%@AE@% stores the %@AS@% bits_per_pixel %@AE@% information in the
%@AB@%bitsperpixel%@AE@% field of a %@AB@%videoconfig%@AE@% structure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the storage size of the image in bytes. There is no
error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getimage %@AE@%functions,  %@AB@%_getvideoconfig%@AE@%,  %@AB@%_putimage%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_getimage%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:inp@%%@QR:inpw@%%@NL@%
%@2@%%@CR:C6A01710844 @%%@AB@%inp, inpw%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01710845 @%%@CR:C6A01710846 @% %@CR:C6A01710847 @%%@CR:C6A01710848 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Input a byte (%@AB@%inp%@AE@%) or a word (%@AB@%inpw%@AE@%) from a port.  %@NL@%
%@NL@%
%@AB@%#include <conio.h>%@AE@%                Required only for function declarations

%@AS@%  int inp( unsigned port );%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned inpw( unsigned port );%@AE@%%@NL@%
%@NL@%
%@AI@%port%@AE@%                              Port number

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%inp%@AE@% and %@AB@%inpw%@AE@% functions read a byte and a word, respectively, from the
specified input port. The input value can be any unsigned integer in the
range 0 - 65,535.  %@NL@%
%@NL@%
To use %@AB@%inp%@AE@% and %@AB@%inpw%@AE@% in OS/2 protected mode, you must use a .DEF file to
declare the IOSEG segment that the run-time library uses to perform
input/output on the port. In addition, the intrinsic (/Oi) versions of these
functions do not work unless you put the code in a segment that is marked
with the %@AB@%IOPL%@AE@% keyword in the .DEF file.  %@NL@%
%@NL@%
Because you cannot do IOPL from a regular code segment, the run-time library
declares a separate code segment called %@AB@%_IOSEG%@AE@%. In order to use %@AB@%inp%@AE@%, %@AB@%inpw%@AE@%,
%@AB@%outp%@AE@%, or %@AB@%outpw%@AE@% in any of the protected-mode run-time libraries (?LIBCP,
LLIBCDLL, LLIBCMT, or CDLLOBJS-based DLL), you must have a .DEF file
containing this line:  %@NL@%
%@NL@%
%@AS@%  SEGMENTS _IOSEG CLASS 'IOSEG_CODE' IOPL%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The functions return the byte or word read from %@AI@%port%@AE@%. There is no error
return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%outp%@AE@%, %@AB@%outpw%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%outp%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:int86@%%@NL@%
%@2@%%@CR:C6A01720849 @%%@AB@%int86%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01720850 @%%@CR:C6A01720851 @% %@CR:C6A01720852 @% %@CR:C6A01720853 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Executes the 8086 interrupt.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int int86( int intnum, union REGS *inregs, union REGS *outregs );%@AE@%%@NL@%
%@NL@%
%@AI@%intnum%@AE@%                            Interrupt number

%@AI@%inregs%@AE@%                            Register values on call

%@AI@%outregs%@AE@%                           Register values on return

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%int86%@AE@% function executes the 8086-processor-family interrupt specified by
the interrupt number %@AI@%intnum%@AE@%. Before executing the interrupt, %@AB@%int86%@AE@% copies
the contents of %@AI@%inregs%@AE@% to the corresponding registers. After the interrupt
returns, the function copies the current register values to %@AI@%outregs%@AE@%. It also
copies the status of the system carry flag to the %@AB@%cflag%@AE@% field in the %@AI@%outregs%@AE@%
argument. The %@AI@%inregs%@AE@% and %@AI@%outregs%@AE@% arguments are unions of type %@AB@%REGS%@AE@%. The
union type is defined in the include file DOS.H.  %@NL@%
%@NL@%
Do not use the %@AB@%int86%@AE@% function to call interrupts that modify the DS
register. Instead, use the %@AB@%int86x%@AE@% function. The %@AB@%int86x%@AE@% function loads the DS
and ES registers from the %@AI@%segregs%@AE@% parameter and also stores the DS and ES
registers into %@AI@%segregs%@AE@% after the function call.  %@NL@%
%@NL@%
The %@AB@%REGS%@AE@% type is defined in the include file DOS.H.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return value is the value in the AX register after the interrupt
returns. If the %@AB@%cflag%@AE@% field in %@AI@%outregs%@AE@% is nonzero, an error has occurred; in
such cases, the %@AB@%_doserrno%@AE@% variable is also set to the corresponding error
code.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%bdos%@AE@%, %@AB@%int86x%@AE@%,%@AB@% intdos%@AE@%, %@AB@%intdosx%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* INT86.C: This program uses int86 to call the BIOS video service
%@AS@%   * (INT 10H) to get information about the cursor.
%@AS@%   */
%@AS@%  
%@AS@%  #include <dos.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     union REGS inregs, outregs;
%@AS@%  
%@AS@%     /* Set up to get cursor information. */
%@AS@%     inregs.h.ah = 3;       /* Get Cursor Position function */
%@AS@%     inregs.h.bh = 0;       /* Page 0 */
%@AS@%  
%@AS@%     /* Execute video interrupt: */
%@AS@%     int86( 0x10, &inregs, &outregs );
%@AS@%  
%@AS@%     /* Display results. */
%@AS@%     printf( "Cursor position\n\tRow: %d\n\tColumn: %d\n",
%@AS@%             outregs.h.dh, outregs.h.dl );
%@AS@%     printf( "Cursor shape\n\tStart: %d\n\tEnd: %d\n",
%@AS@%             outregs.h.ch, outregs.h.cl );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Cursor position
%@AS@%          Row: 2
%@AS@%          Column: 0
%@AS@%  Cursor shape
%@AS@%          Start: 6
%@AS@%          End: 7%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:int86x@%%@NL@%
%@2@%%@CR:C6A01730854 @%%@AB@%int86x%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01730855 @%%@CR:C6A01730856 @% %@CR:C6A01730857 @%%@CR:C6A01730858 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Executes the 8086 interrupt; accepts segment-register values.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int int86x( int intnum, union REGS *inregs, union REGS *outregs, 
%@AS@%  struct SREGS *segregs );%@AE@%%@NL@%
%@NL@%
%@AI@%intnum%@AE@%                            Interrupt number

%@AI@%inregs%@AE@%                            Register values on call

%@AI@%outregs%@AE@%                           Register values on return

%@AI@%segregs%@AE@%                           Segment-register values on call

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%int86x%@AE@% function executes the 8086-processor-family interrupt specified
by the interrupt number %@AI@%intnum%@AE@%. Unlike the %@AB@%int86%@AE@% function, %@AB@%int86x%@AE@% accepts
segment-register values in %@AI@%segregs%@AE@%, enabling programs that use large-model
data segments or far pointers to specify which segment or pointer should be
used during the system call.  %@NL@%
%@NL@%
Before executing the specified interrupt, %@AB@%int86x%@AE@% copies the contents of
%@AI@%inregs%@AE@% and %@AI@%segregs%@AE@% to the corresponding registers. Only the DS and ES
register values in %@AI@%segregs%@AE@% are used. After the interrupt returns, the
function copies the current register values to %@AI@%outregs%@AE@%, cop-ies the current
ES and DS values to %@AI@%segregs%@AE@%, and restores DS. It also copies the status of
the system carry flag to the %@AB@%cflag%@AE@% field in %@AI@%outregs%@AE@%.  %@NL@%
%@NL@%
The %@AB@%REGS%@AE@% and %@AB@%SREGS%@AE@% types are defined in the include file DOS.H.  %@NL@%
%@NL@%
Segment values for the %@AI@%segregs%@AE@% argument can be obtained by using either the
%@AB@%segread%@AE@% function or the %@AB@%FP_SEG%@AE@% macro.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return value is the value in the AX register after the interrupt
returns. If the %@AB@%cflag%@AE@% field in %@AI@%outregs%@AE@% is nonzero, an error has occurred; in
such cases, the %@AB@%_doserrno%@AE@% variable is also set to the corresponding error
code.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%bdos, FP_SEG%@AE@%, %@AB@%int86%@AE@%,%@AB@% intdos%@AE@%, %@AB@%intdosx%@AE@%, %@AB@%segread%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* INT86X.C: In this program, int86x executes an INT 21H instruction
%@AS@%   * to invoke DOS system call 43H (change file attributes). The program
%@AS@%   * uses int86x because the file, which is referenced with a far pointer,
%@AS@%   * may be in a segment other than the default data segment. Thus, the
%@AS@%   * program must explicitly set the DS register with the SREGS structure.
%@AS@%   */
%@AS@%  
%@AS@%  #include <signal.h>
%@AS@%  #include <dos.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <process.h>
%@AS@%  
%@AS@%  char _far *filename = "int86x.c";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     union  REGS inregs, outregs;
%@AS@%     struct SREGS segregs;
%@AS@%     int    result;
%@AS@%  
%@AS@%     inregs.h.ah = 0x43;      /* DOS function to change attributes    */
%@AS@%     inregs.h.al = 0;         /* Subfunction 0 to get attributes)     */
%@AS@%     inregs.x.dx = FP_OFF( filename );   /* DS:DX points to file name */
%@AS@%     segregs.ds  = FP_SEG( filename );
%@AS@%     result = int86x( 0x21, &inregs, &outregs, &segregs );
%@AS@%     if( outregs.x.cflag )
%@AS@%        printf( "Can't get file attributes; error no. %d\n", result);
%@AS@%     else
%@AS@%        printf( "Attribs = 0x%.4x\n", outregs.x.cx );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Attribs = 0x0020%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:intdos@%%@NL@%
%@2@%%@CR:C6A01740859 @%%@AB@%intdos%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01740860 @%%@CR:C6A01740861 @% %@CR:C6A01740862 @%%@CR:C6A01740863 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Executes the DOS system call.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int intdos( union REGS *inregs, union REGS *outregs );%@AE@%%@NL@%
%@NL@%
%@AI@%inregs%@AE@%                            Register values on call

%@AI@%outregs%@AE@%                           Register values on return

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%intdos%@AE@% function invokes the DOS system call specified by register values
defined in %@AI@%inregs%@AE@% and returns the effect of the system call in %@AI@%outregs%@AE@%. The
%@AI@%inregs%@AE@% and %@AI@%outregs%@AE@% arguments are unions of type %@AB@%REGS%@AE@%. The %@AB@%REGS %@AE@%type is
defined in the include file DOS.H.  %@NL@%
%@NL@%
To invoke a system call, %@AB@%intdos%@AE@% executes an INT 21H instruction. Before
executing the instruction, the function copies the contents of %@AI@%inregs%@AE@% to the
corresponding registers. After the INT instruction returns, %@AB@%intdos%@AE@% copies
the current register values to %@AI@%outregs%@AE@%. It also copies the status of the
system carry flag to the %@AB@%cflag%@AE@% field in %@AI@%outregs%@AE@%. A nonzero %@AB@%cflag%@AE@% field
indicates the flag was set by the system call and also indicates an error
condition.  %@NL@%
%@NL@%
The %@AB@%intdos%@AE@% function is used to invoke DOS system calls that take arguments
for input or output in registers other than DX (DH/DL) and AL. The %@AB@%intdos%@AE@%
function is also used to invoke system calls that indicate errors by setting
the carry flag. Under any other conditions, the %@AB@%bdos%@AE@% function can be used.  %@NL@%
%@NL@%
Do not use the %@AB@%intdos%@AE@% function to call interrupts that modify the DS
register. Instead, use the %@AB@%intdosx%@AE@% or %@AB@%int86x%@AE@% function.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%intdos%@AE@% function returns the value of the AX register after the system
call is completed. If the %@AB@%cflag%@AE@% field in %@AI@%outregs%@AE@% is nonzero, an error has
occurred and %@AB@%_doserrno%@AE@% is also set to the corresponding error code.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%bdos%@AE@%, %@AB@%intdosx%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* INTDOS.C: This program uses intdos to invoke DOS system call 2AH
%@AS@%   * (gets the current date).
%@AS@%   */
%@AS@%  
%@AS@%  #include <dos.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     union REGS inregs, outregs;
%@AS@%  
%@AS@%     inregs.h.ah = 0x2a;           /* DOS Get Date function: */
%@AS@%     intdos( &inregs, &outregs );
%@AS@%     printf( "Date: %d/%d/%d\n", outregs.h.dh, outregs.h.dl, outregs.x.cx );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Date: 6/16/1989%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:intdosx@%%@NL@%
%@2@%%@CR:C6A01750864 @%%@AB@%intdosx%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01750865 @%%@CR:C6A01750866 @% %@CR:C6A01750867 @%%@CR:C6A01750868 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Executes the DOS system call; accepts segment-register values.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int intdosx( union REGS *inregs, union REGS *outregs, struct SREGS
%@AS@%  *segregs );%@AE@%%@NL@%
%@NL@%
%@AI@%inregs%@AE@%                            Register values on call

%@AI@%outregs%@AE@%                           Register values on return

%@AI@%segregs%@AE@%                           Segment-register values on call

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%intdosx%@AE@% function invokes the DOS system call specified by register
values defined in %@AI@%inregs%@AE@% and returns the results of the system call in
%@AI@%outregs%@AE@%. Unlike the %@AB@%intdos%@AE@% function, %@AB@%intdosx%@AE@% accepts segment-register values
in %@AI@%segregs%@AE@%, enabling programs that use large-model data segments or far
pointers to specify which segment or pointer should be used during the
system call. The %@AB@%REGS%@AE@% and %@AB@%SREGS%@AE@% types are defined in the include file DOS.H.
%@NL@%
%@NL@%
To invoke a system call, %@AB@%intdosx%@AE@% executes an INT 21H instruction. Before
executing the instruction, the function copies the contents of %@AI@%inregs%@AE@% and
%@AI@%segregs%@AE@% to the corresponding registers. Only the DS and ES register values
in %@AI@%segregs%@AE@% are used. After the INT instruction returns, %@AB@%intdosx%@AE@% copies the
current register values to %@AI@%outregs%@AE@% and restores DS. It also copies the
status of the system carry flag to the %@AB@%cflag%@AE@% field in %@AI@%outregs%@AE@%. A nonzero
%@AB@%cflag%@AE@% field indicates the flag was set by the system call and also indicates
an error condition.  %@NL@%
%@NL@%
The %@AB@%intdosx%@AE@% function is used to invoke DOS system calls that take an
argument in the ES register or that take a DS register value different from
the default data segment.  %@NL@%
%@NL@%
Segment values for the %@AI@%segregs%@AE@% argument can be obtained by using either the
%@AB@%segread %@AE@%function or the %@AB@%FP_SEG%@AE@% macro.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%intdosx%@AE@% function returns the value of the AX register after the system
call is completed. If the %@AB@%cflag%@AE@% field in %@AI@%outregs%@AE@% is nonzero, an error has
occurred; in such cases, %@AB@%_doserrno%@AE@% is also set to the corresponding error
code.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%bdos%@AE@%, %@AB@%FP_SEG%@AE@%, %@AB@%intdos%@AE@%, %@AB@%segread%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* INTDOSX.C */
%@AS@%  #include <dos.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far *buffer = "Dollar-sign terminated string\n\r\n\r$";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     union  REGS inregs, outregs;
%@AS@%     struct SREGS segregs;
%@AS@%  
%@AS@%     /* Print a $-terminated string on the screen using DOS function 0x09.
%@AS@%*/
%@AS@%     inregs.h.ah = 0x9;
%@AS@%     inregs.x.dx = FP_OFF( buffer );
%@AS@%     segregs.ds  = FP_SEG( buffer );
%@AS@%     intdosx( &inregs, &outregs, &segregs );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Dollar-sign terminated string%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:is@%%@NL@%
%@2@%%@CR:C6A01760869 @%%@AB@%is Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01760870 @%%@CR:C6A01760871 @% %@CR:C6A01760872 @% %@CR:C6A01760873 @%%@CR:C6A01760874 @%%@CR:C6A01760875 @%%@CR:C6A01760876 @% %@CR:C6A01760877 @%%@CR:C6A01760878 @% %@CR:C6A01760879 @% %@CR:C6A01760880 @% %@EH@%
%@AB@%%@CR:C6A01760881 @% %@CR:C6A01760882 @% %@CR:C6A01760883 @% %@CR:C6A01760884 @% %@CR:C6A01760885 @%%@CR:C6A01760886 @%%@AE@%%@NL@%
%@NL@%
Test characters for specified conditions.  %@NL@%
%@NL@%
%@AS@%  #include <ctype.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int isalnum( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int isalpha( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int isascii( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int iscntrl( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int isdigit( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int isgraph( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int islower( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int isprint( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int ispunct( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int isspace( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int isupper( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int isxdigit( int c );%@AE@%%@NL@%
%@NL@%
%@AI@%c%@AE@%                                 Integer to be tested

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
Each function in the %@AB@%is%@AE@% family tests a given integer value, returning a
nonzero value if the integer satisfies the test condition and 0 if it does
not. The ASCII character set is assumed.  %@NL@%
%@NL@%
The %@AB@%is%@AE@% functions and their test conditions are listed below:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Test Condition%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%isalnum%@AE@%                           Alphanumeric ('A'-'Z', 'a'-'z', or 
                                  '0'-'9')

%@AB@%isalpha%@AE@%                           Letter ('A'-'Z' or 'a'-'z')

%@AB@%isascii%@AE@%                           ASCII character (0x00 - 0x7F)

%@AB@%iscntrl%@AE@%                           Control character (0x00 - 0x1F or 0x7F)

%@AB@%isdigit%@AE@%                           Digit ('0'-'9')

%@AB@%isgraph%@AE@%                           Printable character except space (' ')

%@AB@%islower%@AE@%                           Lowercase letter ('a'-'z')

%@AB@%isprint%@AE@%                           Printable character (0x20 - 0x7E)

%@AB@%ispunct%@AE@%                           Punctuation character

%@AB@%isspace%@AE@%                           White-space character (0x09 - 0x0D or 
                                  0x20)

%@AB@%isupper%@AE@%                           Uppercase letter ('A'-'Z')

%@AB@%isxdigit%@AE@%                          Hexadecimal digit ('A'-'F','a'-'f', or 
                                  '0'-'9')

The %@AB@%isascii%@AE@% routine produces meaningful results for all integer values.
However, the remaining routines produce a defined result only for integer
values corresponding to the ASCII character set (that is, only where %@AB@%isascii%@AE@%
holds true) or for the non-ASCII value %@AB@%EOF%@AE@% (defined in STDIO.H).  %@NL@%
%@NL@%
These routines are implemented both as functions and as macros. For details
on choosing a function or a macro implementation, see Section 1.4, "Choosing
Between Functions and Macros."  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These routines return a nonzero value if the integer satisfies the test
condition and 0 if it does not.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%isalnum%@AE@%,%@AB@% isalpha%@AE@%, %@AB@%iscntrl%@AE@%, %@AB@%isdigit%@AE@%, %@AB@%isgraph%@AE@%, %@AB@%islower%@AE@%, %@AB@%isprint%@AE@%, %@AB@%ispunct%@AE@%,
%@AB@%isspace%@AE@%, %@AB@%isupper%@AE@%, %@AB@%isxdigit%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%isascii%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%toascii%@AE@%, %@AB@%tolower%@AE@%,%@AB@% toupper %@AE@%functions%@AB@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ISFAM.C: This program tests all characters between 0x0 and 0x7F,
%@AS@%   * then displays each character with abbreviations for the character-type
%@AS@%   * codes that apply.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <ctype.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     int ch;
%@AS@%     for( ch = 0; ch <= 0x7F; ch++ )
%@AS@%     {
%@AS@%        printf( "%.2x ", ch );
%@AS@%        printf( " %c", isprint( ch )  ? ch   : '\0' );
%@AS@%        printf( "%4s", isalnum( ch )  ? "AN" : "" );
%@AS@%        printf( "%3s", isalpha( ch )  ? "A"  : "" );
%@AS@%        printf( "%3s", isascii( ch )  ? "AS" : "" );
%@AS@%        printf( "%3s", iscntrl( ch )  ? "C"  : "" );
%@AS@%        printf( "%3s", isdigit( ch )  ? "D"  : "" );
%@AS@%        printf( "%3s", isgraph( ch )  ? "G"  : "" );
%@AS@%        printf( "%3s", islower( ch )  ? "L"  : "" );
%@AS@%        printf( "%3s", ispunct( ch )  ? "PU" : "" );
%@AS@%        printf( "%3s", isspace( ch )  ? "S"  : "" );
%@AS@%        printf( "%3s", isprint( ch )  ? "PR" : "" );
%@AS@%        printf( "%3s", isupper( ch )  ? "U"  : "" );
%@AS@%        printf( "%3s", isxdigit( ch ) ? "X"  : "" );
%@AS@%        printf( "\n" );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  00          AS  C
%@AS@%  01          AS  C
%@AS@%  02          AS  C
%@AS@%  .
%@AS@%  .
%@AS@%  .
%@AS@%  38  8  AN    AS     D  G          PR     X
%@AS@%  39  9  AN    AS     D  G          PR     X
%@AS@%  3a  :        AS        G    PU    PR
%@AS@%  3b  ;        AS        G    PU    PR
%@AS@%  3c  <        AS        G    PU    PR
%@AS@%  3d  =        AS        G    PU    PR
%@AS@%  3e  >        AS        G    PU    PR
%@AS@%  3f  ?        AS        G    PU    PR
%@AS@%  40  @        AS        G    PU    PR
%@AS@%  41  A  AN  A AS        G          PR  U  X
%@AS@%  42  B  AN  A AS        G          PR  U  X
%@AS@%  .
%@AS@%  .
%@AS@%  .%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:isatty@%%@NL@%
%@2@%%@CR:C6A01770887 @%%@AB@%isatty%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01770888 @%%@CR:C6A01770889 @%%@CR:C6A01770890 @% %@CR:C6A01770891 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Checks for a character device.  %@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  int isatty( int handle );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Handle referring to device to be tested

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%isatty%@AE@% function determines whether %@AI@%handle%@AE@% is associated with a character
device (a terminal, console, printer, or serial port).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%isatty%@AE@% function returns a nonzero value if the device is a character
device. Otherwise, the return value is 0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ISATTY.C: This program checks to see whether stdout has been
%@AS@%   * redirected to a file.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <io.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     if( isatty( fileno( stdout ) ) )
%@AS@%        printf( "stdout has not been redirected to a file\n" );
%@AS@%     else
%@AS@%        printf( "stdout has been redirected to a file\n");
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  stdout has not been redirected to a file%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:itoa@%%@NL@%
%@2@%%@CR:C6A01780892 @%%@AB@%itoa%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01780893 @%%@CR:C6A01780894 @% %@CR:C6A01780895 @%%@CR:C6A01780896 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Converts an integer to a string.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AS@%  char *itoa( int value, char *string, int radix );%@AE@%%@NL@%
%@NL@%
%@AI@%value%@AE@%                             Number to be converted

%@AI@%string%@AE@%                            String result

%@AI@%radix%@AE@%                             Base of %@AI@%value%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%itoa%@AE@% function converts the digits of the given %@AI@%value%@AE@% argument to a
null-terminated character string and stores the result (up to 17 bytes) in
%@AI@%string.%@AE@% The %@AI@%radix%@AE@% argument specifies the base of %@AI@%value%@AE@%; it must be in the
range 2-36. If %@AI@%radix%@AE@% equals 10 and %@AI@%value%@AE@% is negative, the first character of
the stored string is the minus sign (-).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%itoa%@AE@% function returns a pointer to %@AI@%string%@AE@%. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%ltoa%@AE@%, %@AB@%ultoa%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ITOA.C: This program converts integers of various sizes to strings
%@AS@%   * in various radixes.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[20];
%@AS@%     int  i = 3445;
%@AS@%     long l = -344115L;
%@AS@%     unsigned long ul = 1234567890UL;%@AE@%%@NL@%
%@NL@%
%@AS@%  itoa( i, buffer, 10 );
%@AS@%     printf( "String of integer %d (radix 10): %s\n", i, buffer );
%@AS@%     itoa( i, buffer, 16 );
%@AS@%     printf( "String of integer %d (radix 16): 0x%s\n", i, buffer );
%@AS@%     itoa( i, buffer, 2  );
%@AS@%     printf( "String of integer %d (radix 2): %s\n", i, buffer );
%@AS@%  
%@AS@%     ltoa( l, buffer, 16 );
%@AS@%     printf( "String of long int %ld (radix 16): 0x%s\n", l, buffer );
%@AS@%  
%@AS@%     ultoa( ul, buffer, 16 );
%@AS@%     printf( "String of unsigned long %lu (radix 16): 0x%s\n", ul, buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  String of integer 3445 (radix 10): 3445
%@AS@%  String of integer 3445 (radix 16): 0xd75
%@AS@%  String of integer 3445 (radix 2): 110101110101
%@AS@%  String of long int -344115 (radix 16): 0xfffabfcd
%@AS@%  String of unsigned long 1234567890 (radix 16): 0x499602d2%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:kbhit@%%@NL@%
%@2@%%@CR:C6A01790897 @%%@AB@%kbhit%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description %@CR:C6A01790898 @%%@CR:C6A01790899 @% %@CR:C6A01790900 @% %@CR:C6A01790901 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Checks the console for keyboard input.  %@NL@%
%@NL@%
%@AB@%#include <conio.h>%@AE@%                Required only for function declarations

%@AS@%  int kbhit( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%kbhit%@AE@% function checks the console for a recent keystroke. If the
function returns a nonzero value, a keystroke is waiting in the buffer. The
program can then call %@AB@%getch%@AE@% or %@AB@%getche%@AE@% to get the keystroke.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%kbhit%@AE@% function returns a nonzero value if a key has been pressed.
Otherwise, it re-turns 0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* KBHIT.C: This program loops until the user presses a key.
%@AS@%   * If kbhit returns nonzero, a keystroke is waiting in the buffer.
%@AS@%   * The program can call getch or getche to get the keystroke.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Display message until key is pressed. */
%@AS@%     while( !kbhit() )
%@AS@%        cputs( "Hit me!! " );
%@AS@%  
%@AS@%     /* Use getch to throw key away. */
%@AS@%     printf( "\nKey struck was '%c'\n", getch() );
%@AS@%     getch();
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Hit me!! Hit me!! Hit me!! Hit me!! Hit me!! Hit me!! Hit me!!
%@AS@%  Key struck was 'k'%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:labs@%%@NL@%
%@2@%%@CR:C6A01800902 @%%@AB@%labs%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01800903 @%%@CR:C6A01800904 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculates the absolute value of a long integer.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AB@%#include <math.h>%@AE@%                 

%@AS@%  long labs( long n );%@AE@%%@NL@%
%@NL@%
%@AI@%n%@AE@%                                 Long-integer value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%labs%@AE@% function produces the absolute value of its long-integer argument
%@AI@%n%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%labs%@AE@% function returns the absolute value of its argument. There is no
error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%abs%@AE@%, %@AB@%cabs%@AE@%, %@AB@%fabs%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ABS.C: This program computes and displays the absolute values of
%@AS@%   * several numbers.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <math.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int    ix = -4, iy;
%@AS@%     long   lx = -41567L, ly;
%@AS@%     double dx = -3.141593, dy;
%@AS@%  
%@AS@%     iy = abs( ix );
%@AS@%     printf( "The absolute value of %d is %d\n", ix, iy);
%@AS@%  
%@AS@%     ly = labs( lx );
%@AS@%     printf( "The absolute value of %ld is %ld\n", lx, ly);
%@AS@%  
%@AS@%     dy = fabs( dx );
%@AS@%     printf( "The absolute value of %f is %f\n", dx, dy );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The absolute value of -4 is 4
%@AS@%  The absolute value of -41567 is 41567
%@AS@%  The absolute value of -3.141593 is 3.141593%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ldexp@%%@QR:ldexpl@%%@NL@%
%@2@%%@CR:C6A01810905 @%%@AB@%ldexp, ldexpl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01810906 @%%@CR:C6A01810907 @%%@CR:C6A01810908 @% %@CR:C6A01810909 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Compute a real number from the mantissa and exponent.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double ldexp( double x, int exp );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double ldexpl( long double x, int exp );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Floating-point value

%@AI@%exp%@AE@%                               Integer exponent

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ldexp%@AE@% and %@AB@%ldexpl%@AE@% functions calculate the value of %@AI@%x%@AE@% * 2exp.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ldexp%@AE@% and %@AB@%ldexpl%@AE@% functions return %@AI@%x *%@AE@% 2exp. If an overflow results, the
functions return ñ HUGE_VAL (depending on the sign of %@AI@%x%@AE@%) and set%@AB@% errno%@AE@% to
%@AB@%ERANGE%@AE@%.  %@NL@%
%@NL@%
The %@AB@%ldexpl %@AE@%function uses the 80-bit, 10-byte coprocessor form of arguments
and return values. See the reference page on the long double functions for
more details on this data type. %@AB@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%ldexp%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%ldexpl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%frexp%@AE@%, %@AB@%modf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* LDEXP.C */
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     double x = 4.0, y;
%@AS@%     int p = 3;
%@AS@%  
%@AS@%     y = ldexp( x, p );
%@AS@%     printf( "%2.1f times two to the power of %d is %2.1f\n", x, p, y );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  4.0 times two to the power of 3 is 32.0 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ldiv@%%@NL@%
%@2@%%@CR:C6A01820910 @%%@AB@%ldiv%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01820911 @%%@CR:C6A01820912 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Computes the quotient and remainder of a long integer.  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  ldiv_t ldiv ( long int numer, long int denom );%@AE@%%@NL@%
%@NL@%
%@AI@%numer%@AE@%                             Numerator

%@AI@%denom%@AE@%                             Denominator

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ldiv%@AE@% function divides %@AI@%numer%@AE@% by %@AI@%denom%@AE@%, computing the quotient and the
remainder. The sign of the quotient is the same as that of the mathematical
quotient. Its absolute value is the largest integer that is less than the
absolute value of the mathematical quotient. If the denominator is 0, the
program will terminate with an error message.  %@NL@%
%@NL@%
The %@AB@%ldiv%@AE@% function is similar to the %@AB@%div%@AE@% function, with the difference being
that the arguments and the members of the returned structure are all of type
%@AB@%long int%@AE@%.  %@NL@%
%@NL@%
The %@AB@%ldiv_t%@AE@% structure, defined in STDLIB.H, contains the following elements:
%@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%long int quot%@AE@%                     Quotient

%@AB@%long int rem%@AE@%                      Remainder

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ldiv%@AE@% function returns a structure of type %@AB@%ldiv_t%@AE@%, comprising both the
quotient and the remainder.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%div%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* LDIV.C: This program takes two long integers as command-line
%@AS@%   * arguments and displays the results of the integer division.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     long x = 5149627, y = 234879;
%@AS@%     ldiv_t div_result;
%@AS@%  
%@AS@%     div_result = ldiv( x, y );
%@AS@%     printf( "For %ld / %ld, the quotient is %ld, and the remainder is
%@AS@%%ld\n",
%@AS@%             x, y, div_result.quot, div_result.rem );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  For 5149627 / 234879, the quotient is 21, and the remainder is 217168%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:lfind@%%@NL@%
%@2@%%@CR:C6A01830913 @%%@AB@%lfind%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01830914 @%%@CR:C6A01830915 @%%@CR:C6A01830916 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Performs a linear search for the specified key.  %@NL@%
%@NL@%
%@AB@%#include <search.h>%@AE@%               Required only for function declarations

%@AS@%  char *lfind( const void *key, const void *base, unsigned int *num,
%@AS@%  unsigned int width, 
%@AS@%  int ( *compare )( const void *elem1, const void *elem2 ) );%@AE@%%@NL@%
%@NL@%
%@AI@%key%@AE@%                               Object to search for

%@AI@%base%@AE@%                              Pointer to base of search data

%@AI@%num%@AE@%                               Number of array elements

%@AI@%width%@AE@%                             Width of array elements

%@AI@%compare%@AE@%%@AB@%(%@AE@% %@AB@%)%@AE@%                        Pointer to comparison routine

%@AI@%elem1%@AE@%                             Pointer to the key for the search

%@AI@%elem2%@AE@%                             Pointer to the array element to be 
                                  compared with the key

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%lfind%@AE@% function performs a linear search for the value %@AI@%key%@AE@% in an array of
%@AI@%num%@AE@% elements; each element is %@AI@%width%@AE@% bytes in size. (Unlike %@AB@%bsearch%@AE@%, %@AB@%lfind%@AE@%
does not require the array to be sorted.) The%@AI@% base%@AE@% argument is a pointer to
the base of the array to be searched.  %@NL@%
%@NL@%
The%@AI@% compare %@AE@%argument is a pointer to a user-supplied routine that compares
two array elements and then returns a value specifying their relationship.
The %@AB@%lfind%@AE@% function calls the %@AI@%compare%@AE@% routine one or more times during the
search, passing pointers to two array elements on each call. This routine
must compare the elements, then return one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
Nonzero                           Elements are different

0                                 Elements are identical

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If the key is found, %@AB@%lfind%@AE@% returns a pointer to the element of the array at
%@AI@%base%@AE@% that matches %@AI@%key%@AE@%. If the key is not found, %@AB@%lfind%@AE@% returns %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%bsearch%@AE@%, %@AB@%lsearch%@AE@%, %@AB@%qsort%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* LFIND.C: This program uses lfind to search for the word "hello"
%@AS@%   * in the command-line arguments.
%@AS@%   */
%@AS@%  
%@AS@%  #include <search.h>
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  int compare( char **arg1, char **arg2 );
%@AS@%  
%@AS@%  void main( int argc, char **argv )
%@AS@%  {
%@AS@%     char **result;
%@AS@%     char *key = "hello";
%@AS@%  
%@AS@%     result = (char **)lfind( (char *)&key, (char *)argv,
%@AS@%                              &argc, sizeof( char * ), compare );
%@AS@%     if( result )
%@AS@%        printf( "%s found\n", *result );
%@AS@%     else
%@AS@%        printf( "hello not found!\n" );
%@AS@%  }
%@AS@%  
%@AS@%  int compare(char ** arg1, char **arg2 )
%@AS@%  {
%@AS@%     return( strcmpi( *arg1, *arg2 ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  [C:\LIBREF] lfind What if I said Hello world
%@AS@%  Hello found%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_lineto@%%@NL@%
%@2@%%@CR:C6A01840917 @%%@AB@%_lineto Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01840918 @%%@CR:C6A01840919 @%%@CR:C6A01840920 @% %@CR:C6A01840921 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Draw lines to specified points.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _lineto( short x, short y );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _lineto_w( double wx, double wy );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              End point

%@AI@%wx%@AE@%, %@AI@%wy%@AE@%                            End point

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The functions in the %@AB@%_lineto%@AE@% family draw a line from the current graphics
position up to and including the destination point. The destination point
for the %@AB@%_lineto%@AE@% function is given by the view-coordinate point (%@AI@%x%@AE@%, %@AI@%y%@AE@%). The
destination point for the %@AB@%_lineto_w%@AE@% function is given by the
window-coordinate point (%@AI@%wx%@AE@%, %@AI@%wy%@AE@%).  %@NL@%
%@NL@%
The line is drawn using the current color, logical write mode, and line
style. If no error occurs, %@AB@%_lineto%@AE@% sets the current graphics position to the
view-coordinate point (%@AI@%x%@AE@%, %@AI@%y%@AE@%); %@AB@%_lineto_w%@AE@% sets the current position to the
window-coordinate point (%@AI@%wx%@AE@%, %@AI@%wy%@AE@%).  %@NL@%
%@NL@%
If you use%@AB@% _floodfill%@AE@% to fill in a closed figure drawn with %@AB@%_lineto%@AE@% calls,
the figure must be%@AI@% %@AE@%drawn with a solid line-style pattern.%@AI@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_lineto%@AE@% and %@AB@%_lineto_w%@AE@% routines return a nonzero value if anything is
drawn; otherwise, they return 0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getcurrentposition%@AE@% functions,  %@AB@%_moveto%@AE@% functions,  %@AB@%_setlinestyle%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MOVETO.C: This program draws line segments of different colors. */
%@AS@%  
%@AS@%  #include <graph.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <conio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     short x, y, xinc, yinc, color = 1;
%@AS@%     struct videoconfig v;
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXCOLORMODE ) )
%@AS@%        exit( 1 );
%@AS@%     _getvideoconfig( &v );
%@AS@%     xinc = v.numxpixels / 50;
%@AS@%     yinc = v.numypixels / 50;
%@AS@%  
%@AS@%     for( x = 0, y = v.numypixels - 1; x < v.numxpixels; x += xinc, y -=
%@AS@%yinc )
%@AS@%     {
%@AS@%        _setcolor( color++ % 16 );
%@AS@%        _moveto( x, 0 );
%@AS@%        _lineto( 0, y );
%@AS@%     }
%@AS@%     getch();
%@AS@%  
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:localeconv@%%@NL@%
%@2@%%@CR:C6A01850922 @%%@AB@%localeconv%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01850923 @%%@CR:C6A01850924 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets detailed information on locale settings.  %@NL@%
%@NL@%
%@AS@%  #include <locale.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct lconv *localeconv( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%localeconv%@AE@% function gets detailed information on the locale-specific
settings for numeric formatting of the program's current locale. This
information is stored in a structure of type %@AB@%lconv%@AE@%.  %@NL@%
%@NL@%
The %@AB@%lconv%@AE@% structure, defined in LOCALE.H, contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%char *decimal_point%@AE@%               Decimal-point character for nonmonetary 
                                  quantities.

%@AB@%char *thousands_sep%@AE@%               Character used to separate groups of 
                                  digits to the left of the decimal point 
                                  for non-monetary quantities.

%@AB@%char *grouping%@AE@%                    Size of each group of digits in 
                                  non-monetary quantities.

%@AB@%char *int_curr_symbol%@AE@%             International currency symbol for the 
                                  current locale. The first three 
                                  characters specify the alphabetic 
                                  international currency symbol as defined
                                  in the %@AI@%ISO 4217 Codes for the %@AE@%
                                  %@AI@%Representation of Currency and Funds%@AE@% 
                                  standard. The fourth character 
                                  (immediately preceding the null 
                                  character) is used to separate the 
                                  international currency symbol from the 
                                  monetary quantity.

%@AB@%char *currency_symbol%@AE@%             Local currency symbol for the current
                                  locale.

%@AB@%char *mon_decimal_point%@AE@%           Decimal-point character for monetary 
                                  quantities.

%@AB@%char *mon_thousands_sep%@AE@%           Separator for groups of digits to the 
                                  left of the decimal place in monetary 
                                  quantities.

%@AB@%char *mon_grouping%@AE@%                Size of each group of digits in monetary
                                  quantities.

%@AB@%char *positive_sign%@AE@%               String denoting sign for nonnegative 
                                  monetary quantities.

%@AB@%char *negative_sign%@AE@%               String denoting sign for negative 
                                  monetary
                                  quantities.

%@AB@%char int_frac_digits%@AE@%              Number of digits to the right of the 
                                  decimal point in internationally 
                                  formatted
                                  monetary quantities.

%@AB@%char frac_digits%@AE@%                  Number of digits to the right of the 
                                  decimal point in formatted monetary
                                  quantities.

%@AB@%char p_cs_precedes%@AE@%                Set to 1 if the currency symbol precedes
                                  the value for a nonnegative formatted 
                                  monetary quantity. Set to 0 if the 
                                  symbol follows the value.

%@AB@%char p_sep_by_space%@AE@%               Set to 1 if the currency symbol is 
                                  separated by a space from the value for 
                                  a non-negative formatted monetary 
                                  quantity. Set to 0 if there is no space 
                                  separation.

%@AB@%char n_cs_precedes%@AE@%                Set to 1 if the currency symbol precedes
                                  the value for a negative formatted 
                                  monetary quantity. Set to 0 if the 
                                  symbol succeeds the value.

%@AB@%char n_sep_by_space%@AE@%               Set to 1 if the currency symbol is 
                                  separated by a space from the value for 
                                  a negative formatted monetary quantity. 
                                  Set to 0 if there is no space 
                                  separation.

%@AB@%char p_sign_posn%@AE@%                  Position of positive sign in nonnegative
                                  formatted monetary quantities.

%@AB@%char n_sign_posn%@AE@%                  Position of positive sign in negative 
                                  formatted monetary quantities.

The elements of %@AB@%grouping%@AE@% and %@AB@%mon%@AE@%_%@AB@%grouping%@AE@% are interpreted according to the
following rules:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Interpretation%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%CHAR_MAX%@AE@%                          No further grouping is to be performed.

0                                 The previous element is to be repeatedly
                                  used for the remainder of the digits.

%@AI@%n%@AE@%                                 The integer value %@AI@%n%@AE@% is the number of 
                                  digits that make up the current group. 
                                  The next element is examined to 
                                  determine the size of the next group of 
                                  digits before the current group.

The values for %@AB@%p_sign_posn%@AE@% and %@AB@%n_sign_posn%@AE@% are interpreted according to the
following rules:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Interpretation%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
0                                 Parentheses surround the quantity and 
                                  currency symbol

1                                 Sign string precedes the quantity and 
                                  currency symbol

2                                 Sign string follows the quantity and 
                                  currency symbol

3                                 Sign string immediately precedes the 
                                  currency symbol

4                                 Sign string immediately follows the 
                                  currency symbol

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%localeconv%@AE@% function returns a pointer to a structure of %@AB@%lconv%@AE@% type.
Calls to the %@AB@%setlocale%@AE@% function with %@AI@%category%@AE@% values of %@AB@%LC_ALL%@AE@%, %@AB@%LC_MONETARY,%@AE@%
or %@AB@%LC_NUMERIC%@AE@% will overwrite the contents of the structure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%setlocale%@AE@%, %@AB@%strcoll%@AE@%, %@AB@%strftime%@AE@%, %@AB@%strxfrm%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:localtime@%%@NL@%
%@2@%%@CR:C6A01860925 @%%@AB@%localtime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01860926 @%%@CR:C6A01860927 @% %@CR:C6A01860928 @%%@CR:C6A01860929 @% %@CR:C6A01860930 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Converts a time value and corrects for the local time zone.  %@NL@%
%@NL@%
%@AS@%  #include <time.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct tm *localtime( const time_t *timer );%@AE@%%@NL@%
%@NL@%
%@AI@%timer%@AE@%                             Pointer to stored time

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%localtime%@AE@% function converts a time stored as a %@AB@%time_t%@AE@% value and stores
the result in a structure of type %@AB@%tm%@AE@%. The %@AB@%long%@AE@% value %@AI@%timer%@AE@% represents the
seconds elapsed since 00:00:00, January 1, 1970, Greenwich mean time; this
value is usually obtained from the %@AB@%time%@AE@% function.  %@NL@%
%@NL@%
The fields of the structure type %@AB@%tm%@AE@% store the following values:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Value Stored%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%int tm_sec%@AE@%                        Seconds

%@AB@%int tm_min%@AE@%                        Minutes

%@AB@%int tm_hour%@AE@%                       Hours (0 -24)

%@AB@%int tm_mday%@AE@%                       Day of month (1-31)

%@AB@%int tm_mon%@AE@%                        Month (0 -11; January = 0)

%@AB@%int tm_year%@AE@%                       Year (current year minus 1900)

%@AB@%int tm_wday%@AE@%                       Day of week (0 - 6; Sunday = 0)

%@AB@%int tm_yday%@AE@%                       Day of year (0 -365; January 1 = 0)

%@AB@%int tm_isdst%@AE@%                      Nonzero if daylight saving time is in 
                                  effect, otherwise 0

Note that the %@AB@%gmtime, mktime, %@AE@%and%@AB@% localtime%@AE@% functions use a single
statically allocated %@AB@%tm%@AE@% structure for the conversion. Each call to one of
these routines destroys the result of the previous call.  %@NL@%
%@NL@%
The %@AB@%localtime%@AE@% function makes corrections for the local time zone if the user
first sets the environment variable TZ. When TZ is set, three other
environment variables (%@AB@%timezone%@AE@%, %@AB@%daylight%@AE@%, and %@AB@%tzname%@AE@%) are automatically set
as well. See %@AB@%tzset%@AE@% for a description of these variables.%@CR:C6A01860931 @%  %@NL@%
%@NL@%
The TZ variable is not part of the ANSI standard definition of %@AB@%localtime%@AE@% but
is a Microsoft extension.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%localtime%@AE@% function returns a pointer to the structure result. DOS and
OS/2 do not accommodate dates prior to 1980. If the value in %@AI@%timer%@AE@%
represents a date prior to January 1, 1980, the function returns %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asctime%@AE@%, %@AB@%ctime%@AE@%, %@AB@%ftime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%time%@AE@%, %@AB@%tzset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* LOCALTIM.C: This program uses time to get the current time and
%@AS@%   * then uses localtime to convert this time to a structure representing 
%@AS@%   * the local time. The program converts the result from a 24-hour clock
%@AS@%   * to a 12-hour clock and determines the proper extension (AM or PM).
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <string.h>
%@AS@%  #include <time.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct tm *newtime;
%@AS@%     char  am_pm[] = "AM";
%@AS@%     time_t long_time;
%@AS@%  
%@AS@%     time( &long_time );                 /* Get time as long integer. */
%@AS@%     newtime = localtime( &long_time );  /* Convert to local time. */
%@AS@%  
%@AS@%     if( newtime->tm_hour < 12 )         /* Set up extension. */
%@AS@%        strcpy( am_pm, "AM" );
%@AS@%     if( newtime->tm_hour > 12 )         /* Convert from 24-hour */
%@AS@%        newtime->tm_hour -=12;           /*   to 12-hour clock.  */
%@AS@%  
%@AS@%     printf( "%.19s %s\n", asctime( newtime ), am_pm );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Fri Jun 16 06:27:02 AM %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:locking@%%@NL@%
%@2@%%@CR:C6A01870932 @%%@AB@%locking%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01870933 @%%@CR:C6A01870934 @%%@CR:C6A01870935 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Locks or unlocks bytes of a file.  %@NL@%
%@NL@%
%@AS@%  #include <sys\locking.h>%@AE@%%@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  int locking( int handle, int mode, long nbytes );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            File handle

%@AI@%mode%@AE@%                              File-locking mode

%@AI@%nbytes%@AE@%                            Number of bytes to lock

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The%@AB@% locking%@AE@% function locks or unlocks %@AI@%nbytes%@AE@% bytes of the file specified by
%@AI@%handle%@AE@%. Locking bytes in a file prevents access to those bytes by other
processes. All locking or unlocking begins at the current position of the
file pointer and proceeds for the next %@AI@%nbytes%@AE@% bytes. It is possible to lock
bytes past the end of the file.  %@NL@%
%@NL@%
The %@AI@%mode%@AE@% argument specifies the locking action to be performed. It must be
one of the following manifest constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Action%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%LK_LOCK%@AE@%                           Locks the specified bytes. If the bytes 
                                  cannot be locked, immediately tries 
                                  again after 1 second. If, after 10 
                                  attempts, the bytes cannot be locked, 
                                  returns an error.

%@AB@%LK_NBLCK%@AE@%                          Locks the specified bytes. If bytes 
                                  cannot be locked, returns an error.

%@AB@%LK_NBRLCK%@AE@%                         Same as %@AB@%LK_NBLCK%@AE@%.

%@AB@%LK_RLCK%@AE@%                           Same as%@AB@% LK_LOCK%@AE@%.

%@AB@%LK_UNLCK%@AE@%                          Unlocks the specified bytes. (The bytes 
                                  must have been previously locked.)

More than one region of a file can be locked, but no overlapping regions are
allowed.  %@NL@%
%@NL@%
When a region of a file is being unlocked, it must correspond to a region
that was previously locked. The %@AB@%locking%@AE@% function does not merge adjacent
regions; if two locked regions are adjacent, each region must be unlocked
separately.  %@NL@%
%@NL@%
Regions should be locked only briefly and should be unlocked before closing
a file or exiting the program.  %@NL@%
%@NL@%
The %@AB@%locking%@AE@% function should be used only under OS/2 or under DOS versions
3.0 and later; it has no effect under earlier versions of DOS. Also, file
sharing must be loaded to use the %@AB@%locking %@AE@%function. Note that under DOS
versions 3.0 and 3.1, the files locked by parent processes may become
unlocked when child processes exit.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%locking%@AE@% function returns 0 if successful. A return value of -1 indicates
failure, and %@AB@%errno%@AE@% is set to one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Locking violation (file already locked 
                                  or unlocked).

%@AB@%EBADF%@AE@%                             Invalid file handle.

%@AB@%EDEADLOCK%@AE@%                         Locking violation. This is returned when
                                  the %@AB@%LK_LOCK%@AE@% or %@AB@%LK_RLCK%@AE@% flag is specified
                                  and the file cannot be locked after 10 
                                  attempts.

%@AB@%EINVAL%@AE@%                            An invalid argument was given to the 
                                  function.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%creat%@AE@%, %@AB@%open%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* LOCKING.C: This program opens a file with sharing. It locks some
%@AS@%   * bytes before reading them, then unlocks them. Note that the program
%@AS@%   * works correctly only if the following conditions are met:
%@AS@%   *     - The file exists
%@AS@%   *     - The program is run under OS/2, under DOS 3.0 or later
%@AS@%   *       with file sharing installed (SHARE.COM or SHARE.EXE), or 
%@AS@%   *       if a Microsoft Networks compatible network is running
%@AS@%   */
%@AS@%  
%@AS@%  #include <io.h>
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  #include <sys\locking.h>
%@AS@%  #include <share.h>
%@AS@%  #include <fcntl.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     int  fh, numread;
%@AS@%     long pos, result;
%@AS@%     char buffer[40];
%@AS@%  
%@AS@%     /* Quit if can't open file or DOS version doesn't support sharing. */
%@AS@%     fh = sopen( "locking.c", O_RDWR, SH_DENYNO, S_IREAD | S_IWRITE );
%@AS@%     if( (fh == -1) || (_osmajor < 3) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     /* Lock some bytes and read them. Then unlock. */
%@AS@%     if( locking( fh, LK_NBLCK, 30L ) != -1 )
%@AS@%     {
%@AS@%        printf( "No one can change these bytes while I'm reading them\n" );
%@AS@%        numread = read( fh, buffer, 30 );
%@AS@%        printf( "%d bytes read: %.30s\n", numread, buffer );
%@AS@%        locking( fh, LK_UNLCK, 30L );
%@AS@%        printf( "Now I'm done. Do what you will with them\n" );
%@AS@%     }
%@AS@%     else
%@AS@%        perror( "Locking failed\n" );
%@AS@%  
%@AS@%     close( fh );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  No one can change these bytes while I'm reading them
%@AS@%  30 bytes read: /* LOCKING.C: This program ope
%@AS@%  Now I'm done. Do what you will with them %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:log@%%@NL@%
%@2@%%@CR:C6A01880936 @%%@AB@%log Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01880937 @%%@CR:C6A01880938 @% %@CR:C6A01880939 @%%@CR:C6A01880940 @% %@CR:C6A01880941 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate logarithms.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double log( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  double log10( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double logl( long double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double log10l( long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Value whose logarithm is to be found

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%log%@AE@% and %@AB@%log10%@AE@% functions calculate the natural logarithm and the base-10
logarithm, respectively, of %@AI@%x%@AE@%. The %@AB@%logl%@AE@% and %@AB@%log10l%@AE@% functions are the 80-bit
counterparts and use the 80-bit, 10-byte coprocessor form of arguments and
return values. See the reference page on the long double functions for more
details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The%@AB@% log%@AE@% functions return the logarithm of the argument %@AI@%x%@AE@%. If %@AI@%x%@AE@% is negative,
the functions print a %@AB@%DOMAIN%@AE@% error message to %@AB@%stderr%@AE@%, return the value
-%@AB@%HUGE_VAL%@AE@%, and set %@AB@%errno%@AE@% to %@AB@%EDOM%@AE@%. If %@AI@%x%@AE@% is 0, the functions print a%@AB@% SING%@AE@%
error message to %@AB@%stderr%@AE@%, return the value -%@AB@%HUGE_VAL%@AE@%, and set %@AB@%errno%@AE@% to
%@AB@%ERANGE.%@AE@%  %@NL@%
%@NL@%
Error handling can be modified by using the %@AB@%matherr%@AE@% or %@AB@%_matherrl%@AE@% routine.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%log%@AE@%, %@AB@%log10%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%logl%@AE@%, %@AB@%log10l%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%exp%@AE@%,%@AB@% matherr%@AE@%,%@AB@% pow%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* LOG.C: This program uses log and log10 to calculate the natural
%@AS@%   * logarithm and the base-10 logarithm of 9,000.
%@AS@%   */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     double x = 9000.0;
%@AS@%     double y;
%@AS@%  
%@AS@%     y = log( x );
%@AS@%     printf( "log( %.2f ) = %f\n", x, y );
%@AS@%     y = log10( x );
%@AS@%     printf( "log10( %.2f ) = %f\n", x, y );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  log( 9000.00 ) = 9.104980
%@AS@%  log10( 9000.00 ) = 3.954243%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:long@%%@QR:double@%%@NL@%
%@2@%%@CR:C6A01890942 @%%@AB@%long double Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
The 8087 family of numeric coprocessor chips supports the 80-bit precision
floating-point data type. In Microsoft C, version 6.0, the long double
functions, whose names end with%@AB@% l%@AE@%, map the C %@AB@%long double%@AE@% type into this
80-bit, 10-byte form. Unlike the regular floating-point functions (such as
%@AB@%acos%@AE@%), which return values of type %@AB@%double%@AE@%, these long double functions (such
as %@AB@%acosl%@AE@%) return values of type %@AB@%long double%@AE@%. The long double functions also
return their values on the coprocessor stack for all calling conventions.  %@NL@%
%@NL@%
The long double type is also supported by the addition of the "L" prefix for
a floating-point format specification in the %@AB@%printf%@AE@% and %@AB@%scanf%@AE@% family of
functions.  %@NL@%
%@NL@%
The long double versions are described on the reference pages for their
regular counterparts. These are the regular C run-time math functions with
corresponding long double equivalents:  %@NL@%
%@NL@%
%@AB@%Regular Function%@AE@%                  %@AB@%Long Double Form%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%acos%@AE@%                              %@AB@%acosl%@AE@%

%@AB@%asin%@AE@%                              %@AB@%asinl%@AE@%

%@AB@%atan%@AE@%                              %@AB@%atanl%@AE@%

%@AB@%atan2%@AE@%                             %@AB@%atan2l%@AE@%

%@AB@%atof%@AE@%                              %@AB@%_atold%@AE@%

%@AB@%cabs%@AE@%                              %@AB@%cabsl%@AE@%

%@AB@%ceil%@AE@%                              %@AB@%ceill%@AE@%

%@AB@%cos%@AE@%                               %@AB@%cosl%@AE@%

%@AB@%cosh%@AE@%                              %@AB@%coshl%@AE@%

%@AB@%exp%@AE@%                               %@AB@%expl%@AE@%

%@AB@%fabs%@AE@%                              %@AB@%fabsl%@AE@%

%@AB@%floor%@AE@%                             %@AB@%floorl%@AE@%

%@AB@%fmod%@AE@%                              %@AB@%fmodl%@AE@%

%@AB@%frexp%@AE@%                             %@AB@%frexpl%@AE@%

%@AB@%hypot%@AE@%                             %@AB@%hypotl%@AE@%

%@AB@%ldexp%@AE@%                             %@AB@%ldexpl%@AE@%

%@AB@%log%@AE@%                               %@AB@%logl%@AE@%

%@AB@%log10%@AE@%                             %@AB@%log10l%@AE@%

%@AB@%matherr%@AE@%                           %@AB@%_matherrl%@AE@%

%@AB@%modf%@AE@%                              %@AB@%modfl%@AE@%

%@AB@%pow%@AE@%                               %@AB@%powl%@AE@%

%@AB@%sin%@AE@%                               %@AB@%sinl%@AE@%

%@AB@%sinh%@AE@%                              %@AB@%sinhl%@AE@%

%@AB@%sqrt%@AE@%                              %@AB@%sqrtl%@AE@%

%@AB@%tan%@AE@%                               %@AB@%tanl%@AE@%

%@AB@%tanh%@AE@%                              %@AB@%tanhl%@AE@%

%@NL@%
%@NL@%
%@NL@%
%@QR:longjmp@%%@NL@%
%@2@%%@CR:C6A01900943 @%%@AB@%longjmp%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01900944 @%%@CR:C6A01900945 @%%@CR:C6A01900946 @% %@CR:C6A01900947 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Restores stack environment and execution locale.  %@NL@%
%@NL@%
%@AS@%  #include <setjmp.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void longjmp( jmp_buf env, int value );%@AE@%%@NL@%
%@NL@%
%@AI@%env%@AE@%                               Variable in which environment is stored

%@AI@%value%@AE@%                             Value to be returned to %@AB@%setjmp%@AE@% call

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%longjmp%@AE@% function restores a stack environment and execution locale
previously saved in %@AI@%env%@AE@% by %@AB@%setjmp%@AE@%. The %@AB@%setjmp%@AE@% and %@AB@%longjmp%@AE@% functions provide
a way to execute a nonlocal %@AB@%goto%@AE@%; they are typically used to pass execution
control to error handling or recovery code in a previously called routine
without using the normal call and return conventions.  %@NL@%
%@NL@%
A call to %@AB@%setjmp%@AE@% causes the current stack environment to be saved in %@AI@%env.%@AE@% A
subsequent call to %@AB@%longjmp%@AE@% restores the saved environment and returns
control to the point immediately following the corresponding %@AB@%setjmp%@AE@% call.
Execution resumes as if %@AI@%value%@AE@% had just been returned by the %@AB@%setjmp%@AE@% call. The
values of all variables (except register variables) that are accessible to
the routine receiving control contain the values they had when %@AB@%longjmp%@AE@% was
called. The values of register variables are unpredictable.  %@NL@%
%@NL@%
The %@AB@%longjmp%@AE@% function must be called before the function that called %@AB@%setjmp%@AE@%
returns. If %@AB@%longjmp%@AE@% is called after the function calling %@AB@%setjmp%@AE@% returns,
unpredictable program behavior results.  %@NL@%
%@NL@%
The value returned by %@AB@%setjmp%@AE@% must be nonzero. If %@AI@%value%@AE@% is passed as 0, the
value 1 is substituted in the actual return.  %@NL@%
%@NL@%
Observe the following three restrictions when using %@AB@%longjmp%@AE@%:  %@NL@%
%@NL@%
%@NL@%
  1.  Do not assume that the values of the register variables will remain
      the same. The values of register variables in the routine calling
      %@AB@%setjmp%@AE@% may not be restored to the proper values after %@AB@%longjmp%@AE@% is
      executed.%@NL@%
%@NL@%
  2.  Do not use %@AB@%longjmp%@AE@% to transfer control from within one overlay to
      within another. The overlay manager keeps the overlay in memory after
      a call to %@AB@%longjmp%@AE@%.%@NL@%
%@NL@%
  3.  Do not use %@AB@%longjmp%@AE@% to transfer control out of an interrupt-handling
      routine unless the interrupt is caused by a floating-point exception.
      In this case, a program may return from an interrupt handler via
      %@AB@%longjmp%@AE@% if it first reinitializes the floating-point math package by
      calling %@AB@%_fpreset%@AE@%.%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%setjmp%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_fpreset%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_lrotl@%%@QR:_lrotr@%%@NL@%
%@2@%%@CR:C6A01910948 @%%@AB@%_lrotl, _lrotr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description %@CR:C6A01910949 @%%@CR:C6A01910950 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Rotate bits to the left (%@AB@%_lrotl%@AE@%) or right (%@AB@%_lrotr%@AE@%).  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned long _lrotl( unsigned long value, int shift );%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned long _lrotr( unsigned long value, int shift );%@AE@%%@NL@%
%@NL@%
%@AI@%value%@AE@%                             Value to be rotated

%@AI@%shift%@AE@%                             Number of bits to shift

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_lrotl%@AE@% and %@AB@%_lrotr%@AE@% functions rotate %@AI@%value%@AE@% by %@AI@%shift%@AE@% bits. The %@AB@%_lrotl%@AE@%
function rotates the value left. The %@AB@%_lrotr%@AE@% function rotates the value
right. Both functions "wrap" bits rotated off one end of %@AI@%value%@AE@% to the other
end.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
Both functions return the rotated value. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_rotl%@AE@%,  %@AB@%_rotr%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* LROT.C */
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned long val = 0x0fac35791;
%@AS@%  
%@AS@%     printf( "0x%8.8lx rotated left eight times is 0x%8.8lx\n",
%@AS@%             val, _lrotl( val, 8 ) );
%@AS@%     printf( "0x%8.8lx rotated right four times is 0x%8.8lx\n",
%@AS@%             val, _lrotr( val, 4 ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  0xfac35791 rotated left eight times is 0xc35791fa
%@AS@%  0xfac35791 rotated right four times is 0x1fac3579 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:lsearch@%%@NL@%
%@2@%%@CR:C6A01920951 @%%@AB@%lsearch%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01920952 @%%@CR:C6A01920953 @%%@CR:C6A01920954 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Performs a linear search for a value; adds to end of list if not found.  %@NL@%
%@NL@%
%@AB@%#include <search.h>%@AE@%               Required only for function declarations

%@AS@%  char *lsearch( const void *key, const void *base, unsigned int *num, 
%@AS@%  unsigned int width, int ( *compare )( const void *elem1, const void *elem2
%@AS@%) );%@AE@%%@NL@%
%@NL@%
%@AI@%key%@AE@%                               Object to search for

%@AI@%base%@AE@%                              Pointer to base of search data

%@AI@%num%@AE@%                               Number of elements

%@AI@%width%@AE@%                             Width of elements

%@AI@%compare%@AE@%                           Pointer to comparison routine

%@AI@%elem1%@AE@%                             Pointer to the key for the search

%@AI@%elem2%@AE@%                             Pointer to the array element to be 
                                  compared with the key

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%lsearch%@AE@% function performs a linear search for the value %@AI@%key%@AE@% in an array
of %@AI@%num%@AE@% elements, each of %@AI@%width%@AE@% bytes in size. (Unlike %@AB@%bsearch%@AE@%, %@AB@%lsearch%@AE@% does
not require the array to be sorted.) The %@AI@%base%@AE@% argument is a pointer to the
base of the array to be searched.  %@NL@%
%@NL@%
If %@AI@%key%@AE@% is not found, %@AB@%lsearch%@AE@% adds it to the end of the array.  %@NL@%
%@NL@%
The %@AI@%compare%@AE@% argument is a pointer to a user-supplied routine that compares
two array elements and returns a value specifying their relationship. The
%@AB@%lsearch%@AE@% function calls the %@AI@%compare%@AE@% routine one or more times during the
search, passing pointers to two array elements on each call. This routine
must compare the elements, then return one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
Nonzero                           Elements are different

0                                 Elements are identical

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If the key is found, %@AB@%lsearch%@AE@% returns a pointer to the element of the array
at %@AI@%base%@AE@% that matches %@AI@%key%@AE@%. If the key is not found, %@AB@%lsearch%@AE@% returns a pointer
to the newly added item at the end of the array.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%bsearch%@AE@%, %@AB@%lfind%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%lfind%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:lseek@%%@NL@%
%@2@%%@CR:C6A01930955 @%%@AB@%lseek%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01930956 @%%@CR:C6A01930957 @% %@CR:C6A01930958 @%%@CR:C6A01930959 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Moves a file pointer to the specified location.  %@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AB@%#include <stdio.h>%@AE@%                

%@AS@%  long lseek( int handle, long offset, int origin );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Handle referring to open file

%@AI@%offset%@AE@%                            Number of bytes from %@AI@%origin%@AE@%

%@AI@%origin%@AE@%                            Initial position

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%lseek%@AE@% function moves the file pointer associated with %@AI@%handle%@AE@% to a new
location that is %@AI@%offset%@AE@% bytes from %@AI@%origin%@AE@%. The next operation on the file
occurs at the new location. The %@AI@%origin%@AE@% argument must be one of the following
constants, which are defined in STDIO.H:  %@NL@%
%@NL@%
%@AB@%Origin%@AE@%                            %@AB@%Definition%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%SEEK_SET%@AE@%                          Beginning of file

%@AB@%SEEK_CUR%@AE@%                          Current position of file pointer

%@AB@%SEEK_END%@AE@%                          End of file

The %@AB@%lseek%@AE@% function can be used to reposition the pointer anywhere in a file.
The pointer can also be positioned beyond the end of the file. However, an
attempt to position the pointer before the beginning of the file causes an
error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%lseek%@AE@% function returns the offset, in bytes, of the new position from
the beginning of the file. The function returns -1L to indicate an error and
sets %@AB@%errno%@AE@% to one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EBADF%@AE@%                             Invalid file handle

%@AB@%EINVAL%@AE@%                            Invalid value for %@AI@%origin%@AE@%, or position 
                                  specified by %@AI@%offset%@AE@% is before the 
                                  beginning of the file

On devices incapable of seeking (such as terminals and printers), the return
value is undefined.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fseek, tell%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* LSEEK.C: This program first opens a file named LSEEK.C.
%@AS@%   * It then uses lseek to find the beginning of the file,
%@AS@%   * to find the current position in the file, and to find
%@AS@%   * the end of the file.
%@AS@%   */
%@AS@%  
%@AS@%  #include <io.h>
%@AS@%  #include <fcntl.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh;
%@AS@%     long pos;               /* Position of file pointer */
%@AS@%     char buffer[10];
%@AS@%  
%@AS@%     fh = open( "lseek.c", O_RDONLY );
%@AS@%  
%@AS@%     /* Seek the beginning of the file: */
%@AS@%     pos = lseek( fh, 0L, SEEK_SET );
%@AS@%     if( pos == -1L )
%@AS@%        perror( "lseek to beginning failed" );
%@AS@%     else
%@AS@%        printf( "Position for beginning of file seek = %ld\n", pos );
%@AS@%  
%@AS@%     /* Move file pointer a little */
%@AS@%     read( fh, buffer, 10 );
%@AS@%  
%@AS@%     /* Find current position: */
%@AS@%     pos = lseek( fh, 0L, SEEK_CUR );
%@AS@%     if( pos == -1L )
%@AS@%        perror( "lseek to current position failed" );
%@AS@%     else
%@AS@%        printf( "Position for current position seek = %ld\n", pos );
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  /* Set the end of the file: */
%@AS@%     pos = lseek( fh, 0L, SEEK_END );
%@AS@%     if( pos == -1L )
%@AS@%        perror( "lseek to end failed" );
%@AS@%     else
%@AS@%        printf( "Position for end of file seek = %ld\n", pos );
%@AS@%  
%@AS@%     close( fh );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Position for beginning of file seek = 0
%@AS@%  Position for current position seek = 10
%@AS@%  Position for end of file seek = 1183%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ltoa@%%@NL@%
%@2@%%@CR:C6A01940960 @%%@AB@%ltoa%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01940961 @%%@CR:C6A01940962 @% %@CR:C6A01940963 @%%@CR:C6A01940964 @% %@CR:C6A01940965 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Converts a long integer to a string.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AS@%  char *ltoa( long value, char *string, int radix );%@AE@%%@NL@%
%@NL@%
%@AI@%value%@AE@%                             Number to be converted

%@AI@%string%@AE@%                            String result

%@AI@%radix%@AE@%                             Base of %@AI@%value%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ltoa%@AE@% function converts the digits of %@AI@%value%@AE@% to a null-terminated
character string and stores the result (up to 33 bytes) in %@AI@%string%@AE@%. The %@AI@%radix%@AE@%
argument specifies the base of %@AI@%value%@AE@%, which must be in the range 2-36. If
%@AI@%radix%@AE@% equals 10 and %@AI@%value%@AE@% is negative, the first character of the stored
string is the minus sign (-).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ltoa%@AE@% function returns a pointer to %@AI@%string%@AE@%. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%itoa%@AE@%,%@AB@% ultoa%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ITOA.C: This program converts integers of various sizes to strings
%@AS@%   * in various radixes.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[20];
%@AS@%     int  i = 3445;
%@AS@%     long l = -344115L;
%@AS@%     unsigned long ul = 1234567890UL;
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@AS@%  itoa( i, buffer, 10 );
%@AS@%     printf( "String of integer %d (radix 10): %s\n", i, buffer );
%@AS@%     itoa( i, buffer, 16 );
%@AS@%     printf( "String of integer %d (radix 16): 0x%s\n", i, buffer );
%@AS@%     itoa( i, buffer, 2  );
%@AS@%     printf( "String of integer %d (radix 2): %s\n", i, buffer );
%@AS@%  
%@AS@%     ltoa( l, buffer, 16 );
%@AS@%     printf( "String of long int %ld (radix 16): 0x%s\n", l, buffer );
%@AS@%  
%@AS@%     ultoa( ul, buffer, 16 );
%@AS@%     printf( "String of unsigned long %lu (radix 16): 0x%s\n", ul, buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  String of integer 3445 (radix 10): 3445
%@AS@%  String of integer 3445 (radix 16): 0xd75
%@AS@%  String of integer 3445 (radix 2): 110101110101
%@AS@%  String of long int -344115 (radix 16): 0xfffabfcd
%@AS@%  String of unsigned long 1234567890 (radix 16): 0x499602d2 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_makepath@%%@NL@%
%@2@%%@CR:C6A01950966 @%%@AB@%_makepath%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01950967 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Creates a single path name.  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _makepath( char *path, char *drive, char *dir, char *fname, char *ext
%@AS@%  );%@AE@%%@NL@%
%@NL@%
%@AI@%path%@AE@%                              Full path-name buffer

%@AI@%drive%@AE@%                             Drive letter

%@AI@%dir%@AE@%                               Directory path

%@AI@%fname%@AE@%                             File name

%@AI@%ext%@AE@%                               File extension

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_makepath%@AE@% routine creates a single path name, composed of a drive
letter, directory path, file name, and file-name extension. The %@AI@%path%@AE@%
argument should point to an empty buffer large enough to hold the complete
path name. The constant %@AB@%_MAX_PATH%@AE@%, defined in STDLIB.H, specifies the
maximum size %@AI@%path%@AE@% that the %@AB@%_makepath%@AE@% function can handle. The other
arguments point to buffers containing the path-name elements:  %@NL@%
%@NL@%
%@AB@%Buffer%@AE@%                            %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AI@%drive%@AE@%                             The %@AI@%drive%@AE@% argument contains a letter (A,
                                  B, etc.) corresponding to the desired 
                                  drive and an optional trailing colon. 
                                  The %@AB@%_makepath%@AE@% routine will insert the 
                                  colon automatically in the composite 
                                  path name if it is missing. If %@AI@%drive%@AE@% is 
                                  a null character or an empty string, no 
                                  drive letter and colon will appear in 
                                  the composite %@AI@%path%@AE@% string.

%@AI@%dir%@AE@%                               The %@AI@%dir%@AE@% argument contains the path of 
                                  directories, not including the drive 
                                  designator or the actual file name. The 
                                  trailing slash is optional, and either 
                                  forward slashes ( %@AB@%/%@AE@% ) or backslashes ( \
                                  ) or both may be used in a single %@AI@%dir%@AE@% 
                                  argument. If a trailing slash ( %@AB@%/%@AE@% or \ )
                                  is not specified, it will be inserted 
                                  automatically. If %@AI@%dir%@AE@% is a null 
                                  character or an empty string, no slash 
                                  is inserted in the composite %@AI@%path%@AE@% 
                                  string.

%@AI@%fname%@AE@%                             The %@AI@%fname%@AE@% argument contains the base 
                                  file name without any extensions. If %@AI@%%@AE@%
                                  %@AI@%fname%@AE@% is %@AB@%NULL%@AE@% or points to an empty 
                                  string, no file name is inserted in the 
                                  composite %@AI@%path%@AE@% string.

%@AI@%ext%@AE@%                               The %@AI@%ext%@AE@% argument contains the actual 
                                  file-name extension, with or without a 
                                  leading period (%@AB@%.%@AE@%). The %@AB@%_makepath%@AE@% 
                                  routine will insert the period 
                                  automatically if it does not appear in %@AI@%%@AE@%
                                  %@AI@%ext%@AE@%. If %@AI@%ext%@AE@% is a null character or an 
                                  empty string, no period is inserted in 
                                  the composite %@AI@%path%@AE@% string.

There are no size limits on any of the above four fields. However, the
composite path must be no larger than the %@AB@%_MAX_PATH%@AE@% constant. The %@AB@%_MAX_PATH%@AE@%
limit permits a path name much larger than any of the current versions of
DOS or OS/2 will handle.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_fullpath%@AE@%,  %@AB@%_splitpath%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MAKEPATH.C */
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char path_buffer[_MAX_PATH];
%@AS@%     char drive[_MAX_DRIVE];
%@AS@%     char dir[_MAX_DIR];
%@AS@%     char fname[_MAX_FNAME];
%@AS@%     char ext[_MAX_EXT];
%@AS@%  
%@AS@%     _makepath( path_buffer, "c", "\\c60\\clibref\\", "makepath", "c" );
%@AS@%     printf( "Path created with _makepath: %s\n\n", path_buffer );
%@AS@%     _splitpath( path_buffer, drive, dir, fname, ext );
%@AS@%     printf( "Path extracted with _splitpath:\n" );
%@AS@%     printf( "  Drive: %s\n", drive );
%@AS@%     printf( "  Dir: %s\n", dir );
%@AS@%     printf( "  Filename: %s\n", fname );
%@AS@%     printf( "  Ext: %s\n", ext );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Path created with _makepath: c:\c60\clibref\makepath.c
%@AS@%  
%@AS@%  Path extracted with _splitpath:
%@AS@%    Drive: c:
%@AS@%    Dir: \c60\clibref\
%@AS@%    Filename: makepath
%@AS@%    Ext: .c %@AE@%%@NL@%
%@NL@%
 %@NL@%
%@NL@%
%@NL@%
%@QR:malloc@%%@NL@%
%@2@%%@CR:C6A01960968 @%%@AB@%malloc Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Allocate memory blocks.  %@NL@%
%@NL@%
%@CR:C6A01960969 @%%@CR:C6A01960970 @%%@CR:C6A01960971 @%%@CR:C6A01960972 @%%@CR:C6A01960973 @%%@CR:C6A01960974 @%%@CR:C6A01960975 @%%@CR:C6A01960976 @%  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               For ANSI compatibility (%@AB@%malloc%@AE@% only)

%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  void *malloc( size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _based(void) *_bmalloc( _segment seg, size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far *_fmalloc( size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _near *_nmalloc( size_t size );%@AE@%%@NL@%
%@NL@%
%@AI@%size%@AE@%                              Bytes to allocate

%@AI@%seg%@AE@%                               Based heap segment selector

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
Functions in the %@AB@%malloc%@AE@% family allocate a memory block of at least %@AI@%size%@AE@%
bytes. The block may be larger than %@AI@%size%@AE@% bytes because of space required for
alignment and maintenance information. If %@AI@%size%@AE@% is 0, each of these functions
allocates a zero-length item in the heap and returns a valid pointer to that
item.  %@NL@%
%@NL@%
The storage space pointed to by the return value is guaranteed to be
suitably aligned for storage of any type of object. To get a pointer to a
type other than %@AB@%void%@AE@%, use a type cast on the return value.  %@NL@%
%@NL@%
In large data models (compact-, large-, and huge-model programs), %@AB@%malloc%@AE@%
maps to %@AB@%_fmalloc%@AE@%. In small data models (tiny-, small-, and medium-model
programs), %@AB@%malloc%@AE@% maps to %@AB@%_nmalloc%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_fmalloc%@AE@% function allocates a memory block of at least %@AI@%size%@AE@% bytes in the
far heap, which is outside the default data segment. The return value is a
far pointer to %@AB@%void%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_bmalloc%@AE@% function allocates a memory block of at least %@AI@%size%@AE@% bytes in the
based heap segment specified by the segment selector %@AI@%seg%@AE@%.  %@NL@%
%@NL@%
The %@AB@%malloc%@AE@% functions allocate memory in the heap segment specified below.  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Heap Segment%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%malloc%@AE@%                            Depends on data model of program

%@AB@%_bmalloc%@AE@%                          Based heap segment specified by %@AI@%seg%@AE@% 
                                  value

%@AB@%_fmalloc%@AE@%                          Far heap (outside default data segment)

%@AB@%_nmalloc%@AE@%                          Near heap (within default data segment)

If you are creating programs to run in both real mode and protected mode,
you should probably bind with APILMR.OBJ as well as API.LIB and OS2.LIB.
This is necessary if a program will use the %@AB@%_nmalloc%@AE@% function.  %@NL@%
%@NL@%
The functions listed below call the %@AB@%malloc%@AE@% family of routines. In addition,
the C start-up code uses %@AB@%malloc%@AE@% to allocate storage for the%@AB@% environ%@AE@%/%@AB@%envp%@AE@% and
%@AB@%argv%@AE@% strings and arrays.  %@NL@%
%@NL@%
The following routines call %@AB@%malloc%@AE@%:  %@NL@%
%@NL@%
%@TH:  37  1242 01 10 10 56 @%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%calloc%@AE@%    fseek     %@AB@%_searchenv%@AE@%%@AB@%execv%@AE@%     %@AB@%fsetpos%@AE@%   %@AB@%spawnv%@AE@%%@AB@%execve%@AE@%    %@AB@%fullpath%@AE@%  %@AB@%spawnve%@AE@%%@AB@%execvp%@AE@%    %@AB@%fwrite%@AE@%    %@AB@%spawnvp%@AE@%%@AB@%execvpe%@AE@%   %@AB@%getc%@AE@%      %@AB@%spawnvpe%@AE@%%@AB@%execl%@AE@%     %@AB@%getchar%@AE@%   %@AB@%spawnl%@AE@%%@AB@%execle%@AE@%    %@AB@%getcwd%@AE@%    %@AB@%spawnle%@AE@%%@AB@%execlp%@AE@%    %@AB@%_getcwd%@AE@%   %@AB@%spawnlp%@AE@%%@AB@%execlpe%@AE@%   %@AB@%gets%@AE@%      %@AB@%spawnlpe%@AE@%%@AB@%fgetc%@AE@%     %@AB@%getw%@AE@%      %@AB@%strdup%@AE@%%@AB@%fgetchar%@AE@%  %@AB@%_popen%@AE@%    %@AB@%system%@AE@%%@AB@%fgets%@AE@%     %@AB@%printf%@AE@%    %@AB@%scanf%@AE@%%@AB@%fprint%@AE@%    %@AB@%putc%@AE@%      %@AB@%setvbuf%@AE@%%@AB@%fputc%@AE@%     %@AB@%putchar%@AE@%   %@AB@%tempnam%@AE@%%@AB@%fputchar%@AE@%  %@AB@%putenv%@AE@%    %@AB@%ungetc%@AE@%%@AB@%fputs%@AE@%     %@AB@%puts%@AE@%      %@AB@%vfprintf%@AE@%%@AB@%fread%@AE@%     %@AB@%putw%@AE@%      %@AB@%vprintf%@AE@%%@AB@%fscanf%@AE@%    %@TE:  37  1242 01 10 10 56 @%

The following routines call %@AB@%malloc %@AE@%only in the multithread run-time
libraries (LLIBCMT, LLIBCDLL, CDLLOBJS), not in the regular run-time
libraries:  %@NL@%
%@NL@%
%@TH:   9   365 01 14 11 51 @%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%asctime%@AE@%       %@AB@%localtime%@AE@%  %@AB@%_strerrpr%@AE@%%@AB@%_beginthread%@AE@%  %@AB@%mktime%@AE@%     %@AB@%tmpfile%@AE@%%@AB@%ctime%@AE@%         %@AB@%sterror%@AE@%    %@AB@%tmpnam%@AE@%%@AB@%gmtime%@AE@%        %@TE:   9   365 01 14 11 51 @%

The following routines call %@AB@%_nmalloc%@AE@%:  %@NL@%
%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_nrealloc%@AE@%

%@AB@%_ncalloc%@AE@%

%@AB@%_nstrdup%@AE@%

%@AB@%realloc%@AE@% (in small data models)


The following routines call %@AB@%_fmalloc%@AE@%:  %@NL@%
%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_frealloc%@AE@%

%@AB@%_fcalloc%@AE@%

%@AB@%_fstrdup%@AE@%

%@AB@%realloc%@AE@% (in large data models)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
%@AB@%C5.1 Differences%@AE@%%@AI@%%@AE@%%@AI@%%@AB@%
%@AB@%%@AI@%In Microsoft C version 5%@AI@%.1, the %@AE@%%@AI@%_fmalloc%@AE@%%@AI@% function would retry all%@AE@%%@AI@%ocating
%@AI@%within the default data segment (i.e., in the near heap) if sufficient
%@AI@%memory was not available outside the default data segment. Version 6.0
%@AI@%ret%@AE@%%@AI@%urns %@AE@%%@AI@%NULL%@AE@%%@AI@% under t%@AE@%%@AI@%hese conditions.%@AE@%%@AE@%%@NL@%
%@AI@%In version 5.1, the s%@AI@%tart-up code used %@AE@%%@AI@%malloc%@AE@%%@AI@% only if wild-card expansion
%@AI@%was used.%@AE@%%@AI@%%@AE@%%@AE@%%@NL@%

%@AI@%%@AI@%The %@AE@%%@AI@%_freect%@AE@%%@AI@%, %@AE@%%@AI@%_memavl%@AE@%%@AI@%, and%@AE@%%@AI@% _memmax%@AE@%%@AI@% functions called %@AE@%%@AI@%malloc%@AE@%%@AI@% in version 5.1 b%@AE@%%@AI@%ut
%@AI@%do not do so in version 6.0.%@AE@%%@AE@%%@NL@%
%@AE@%%@AE@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%malloc%@AE@% function returns a %@AB@%void%@AE@% pointer to the allocated space. The
%@AB@%_nmalloc%@AE@% function returns a %@AB@%( void _near * )%@AE@% and %@AB@%_fmalloc%@AE@% returns a %@AB@%( void
%@AB@%_far * )%@AE@%. The %@AB@%_bmalloc%@AE@% function returns a %@AB@%( void _based( void ) * )%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_malloc%@AE@%, %@AB@%_fmalloc%@AE@% and %@AB@%_nmalloc%@AE@% functions return %@AB@%NULL%@AE@% if there is
insufficient memory available. The %@AB@%_bmalloc%@AE@% function returns %@AB@%_NULLOFF%@AE@% if
there is insufficient memory available.  %@NL@%
%@NL@%
Always check the return from the %@AB@%malloc%@AE@% function, even if the amount of
memory requested is small.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%malloc%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2   %@AB@%%@AE@% UNIX   %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_bmalloc, _fmalloc, _nmalloc%@AE@%  %@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%calloc%@AE@% functions, %@AB@%free%@AE@% functions, %@AB@%realloc%@AE@% functions   %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MALLOC.C: This program allocates memory with malloc, then frees
%@AS@%   * the memory with free.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>         /* Definition of _MAX_PATH */
%@AS@%  #include <stdio.h>
%@AS@%  #include <malloc.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *string;
%@AS@%  
%@AS@%     /* Allocate space for a path name */
%@AS@%     string = malloc( _MAX_PATH );
%@AS@%     if( string == NULL )
%@AS@%        printf( "Insufficient memory available\n" );
%@AS@%     else
%@AS@%        printf( "Memory space allocated for pathname\n" );
%@AS@%     free( string );
%@AS@%     printf( "Memory freed\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Memory space allocated for pathname
%@AS@%  Memory freed %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:matherr@%%@QR:_matherrl@%%@NL@%
%@2@%%@CR:C6A01970977 @%%@AB@%matherr, _matherrl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Handle math errors.  %@NL@%
%@NL@%
%@CR:C6A01970978 @%%@CR:C6A01970979 @%%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int matherr( struct exception *except );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _matherrl( struct _exceptionl *except );%@AE@%%@NL@%
%@NL@%
%@AI@%except%@AE@%                            Pointer to structure containing error 
                                  information

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%matherr%@AE@% functions process errors generated by the functions of the math
library. The math functions call the appropriate %@AB@%matherr%@AE@% routine whenever an
error is detected. The %@AB@%_matherrl%@AE@% function uses the 80-bit, 10-byte
coprocessor form of arguments and return values. See the reference page on
the long double functions for more details on this data type.  %@NL@%
%@NL@%
The user can provide a different definition of the %@AB@%matherr%@AE@% or %@AB@%_matherrl%@AE@%
function to carry out special error handling.  %@NL@%
%@NL@%
When an error occurs in a math routine, %@AB@%matherr%@AE@% is called with a pointer to
an %@AB@%exception%@AE@% type structure (defined in%@AB@% %@AE@%MATH.H) as an argument.%@CR:C6A01970980 @%%@CR:C6A01970981 @%  %@NL@%
%@NL@%
The %@AB@%exception%@AE@% structure contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%int type%@AE@%                          Exception type

%@AB@%char *name%@AE@%                        Name of function where error occurred

%@AB@%double arg1%@AE@%, %@AB@%arg2%@AE@%                 First and second (if any) argument to 
                                  function

%@AB@%double%@AE@%%@AI@% %@AE@%%@AB@%retval%@AE@%                     Value to be returned by function

The%@AB@% type%@AE@% specifies the type of math error. It is one of the following
values, defined in MATH.H:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%DOMAIN%@AE@%                            Argument domain error %@CR:C6A01970982 @%

%@AB@%SING%@AE@%                              Argument singularity %@CR:C6A01970983 @%%@CR:C6A01970984 @%

%@AB@%OVERFLOW%@AE@%                          Overflow range error %@CR:C6A01970985 @%

%@AB@%PLOSS%@AE@%                             Partial loss of significance %@CR:C6A01970986 @%

%@AB@%TLOSS%@AE@%                             Total loss of significance %@CR:C6A01970987 @%

%@AB@%UNDERFLOW%@AE@%                         Underflow range error %@CR:C6A01970988 @%

The structure member%@AB@% name%@AE@% is a pointer to a null-terminated string
containing the name of the function that caused the error. The structure
members %@AB@%arg1%@AE@% and %@AB@%arg2%@AE@% specify the values that caused the error. (If only one
argument is given, it is stored in %@AB@%arg1%@AE@%.)  %@NL@%
%@NL@%
The default return value for the given error is %@AB@%retval%@AE@%. If you change the
return value, remember that the return value must specify whether an error
actually occurred. If the %@AB@%matherr%@AE@% function returns 0, an error message is
displayed and %@AB@%errno%@AE@% is set to an appropriate error value. If %@AB@%matherr%@AE@% returns
a nonzero value, no error message is displayed, and %@AB@%errno%@AE@% remains unchanged.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%matherr%@AE@% functions should return 0 to indicate an error, and a nonzero
value to indicate successful corrective action.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%matherr%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2   %@AB@%%@AE@% UNIX   %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_matherrl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%acos%@AE@% functions, %@AB@%asin%@AE@% functions, %@AB@%atan%@AE@% functions, %@AB@%bessel%@AE@% functions, %@AB@%cabs%@AE@%, %@AB@%cos%@AE@%
functions, %@AB@%exp%@AE@%, %@AB@%hypot%@AE@%, %@AB@%log%@AE@% functions, %@AB@%pow%@AE@%, %@AB@%sin%@AE@% functions, %@AB@%sqrt%@AE@%, %@AB@%tan%@AE@%
functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MATHERR.C: To use matherr, you must turn off the Extended Dictionary
%@AS@%   * flag within the Microsoft Programmer's WorkBench environment, or use
%@AS@%the 
%@AS@%   * /NOE linker option outside the environment. For example:
%@AS@%   *      CL matherr.c /link /NOE
%@AS@%   */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Do several math operations that cause errors. The matherr
%@AS@%      * routine handles DOMAIN errors, but lets the system handle
%@AS@%      * other errors normally.
%@AS@%      */
%@AS@%     printf( "log( -2.0 ) = %e\n", log( -2.0 ) );
%@AS@%     printf( "log10( -5.0 ) = %e\n", log10( -5.0 ) );
%@AS@%     printf( "log( 0.0 ) = %e\n", log( 0.0 ) );
%@AS@%  }
%@AS@%  
%@AS@%  /* Handle several math errors caused by passing a negative argument
%@AS@%   * to log or log10 (DOMAIN errors). When this happens, matherr returns
%@AS@%   * the natural or base-10 logarithm of the absolute value of the
%@AS@%   * argument and suppresses the usual error message.
%@AS@%   */
%@AS@%  int matherr( struct exception *except )
%@AS@%  {
%@AS@%      /* Handle DOMAIN errors for log or log10. */
%@AS@%      if( except->type == DOMAIN )
%@AS@%      {
%@AS@%          if( strcmp( except->name, "log" ) == 0 )
%@AS@%          {
%@AS@%              except->retval = log( -(except->arg1) );
%@AS@%              printf( "Special: using absolute value: %s: DOMAIN error\n",
%@AS@%                      except->name );
%@AS@%              return 1;
%@AS@%          }
%@AS@%          else if( strcmp( except->name, "log10" ) == 0 )
%@AS@%          {
%@AS@%              except->retval = log10( -(except->arg1) );
%@AS@%              printf( "Special: using absolute value: %s: DOMAIN error\n",
%@AS@%                      except->name );
%@AS@%              return 1;
%@AS@%          }
%@AS@%      }
%@AS@%      else
%@AS@%      {
%@AS@%          printf( "Normal: " );
%@AS@%          return 0;    /* Else use the default actions */
%@AS@%      }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Special: using absolute value: log: DOMAIN error
%@AS@%  log( -2.0 ) = 6.931472e-001
%@AS@%  Special: using absolute value: log10: DOMAIN error
%@AS@%  log10( -5.0 ) = 6.989700e-001
%@AS@%  Normal: log: SING error
%@AS@%  log( 0.0 ) = -1.797693e+308 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:max@%%@NL@%
%@2@%%@CR:C6A01980989 @%%@AB@%max%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01980990 @%%@CR:C6A01980991 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Returns the larger of two values.  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  type max( type a, type b );%@AE@%%@NL@%
%@NL@%
%@AI@%type%@AE@%                              Any numeric data type

%@AI@%a%@AE@%,%@AI@% b%@AE@%                              Values of any numeric type to be 
                                  compared

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%max%@AE@% macro compares two values and returns the value of the larger one.
The arguments can be of any numeric data type, signed or unsigned. Both
arguments and the return value must be of the same data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The macro returns the larger of the two arguments.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%min%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MINMAX.C */
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int a = 10;
%@AS@%     int b = 21;
%@AS@%  
%@AS@%     printf( "The larger of %d and %d is %d\n",  a, b, max( a, b ) );
%@AS@%     printf( "The smaller of %d and %d is %d\n", a, b, min( a, b ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The larger of 10 and 21 is 21
%@AS@%  The smaller of 10 and 21 is 10%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_memavl@%%@NL@%
%@2@%%@CR:C6A01990992 @%%@AB@%_memavl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A01990993 @%%@CR:C6A01990994 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Returns the size of memory available.  %@NL@%
%@NL@%
%@AS@%  #include <malloc.h> Required only for function declarations%@AE@%%@NL@%
%@NL@%
%@AS@%  size_t _memavl( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_memavl%@AE@% function returns the approximate size, in bytes, of the memory
available for dynamic memory allocation in the near heap (default data
segment). The %@AB@%_memavl%@AE@% function can be used with %@AB@%calloc%@AE@%, %@AB@%malloc%@AE@%, or %@AB@%realloc%@AE@%
in tiny, small, and medium memory models and with %@AB@%_ncalloc%@AE@%, %@AB@%_nmalloc%@AE@% or
%@AB@%_nrealloc%@AE@% in any memory model.  %@NL@%
%@NL@%
The number returned by the %@AB@%_memavl%@AE@% function may not be the number of
contiguous bytes. Consequently, a call to %@AB@%malloc%@AE@% requesting allocation of
the size returned by %@AB@%_memavl%@AE@% may not succeed. Use the %@AB@%_memmax%@AE@% function to
find the size of the largest available contiguous block of memory.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_memavl%@AE@% function returns the size in bytes as an unsigned integer.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%calloc%@AE@% functions,  %@AB@%_freect%@AE@%, %@AB@%malloc%@AE@% functions,  %@AB@%_memmax%@AE@%, %@AB@%realloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MEMAVL.C: This program uses _memavl to determine the amount of
%@AS@%   * memory available for dynamic allocation. It then uses malloc to
%@AS@%   * allocate space for 5,000 long integers and uses _memavl again to
%@AS@%   * determine the new amount of available memory.
%@AS@%   */
%@AS@%  
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     long *longptr;
%@AS@%  
%@AS@%     printf( "Memory available before _nmalloc = %u\n", _memavl() );
%@AS@%     if( (longptr = _nmalloc( 5000 * sizeof( long ) )) != NULL )
%@AS@%     {
%@AS@%        printf( "Memory available after _nmalloc = %u\n", _memavl() );
%@AS@%        _nfree( longptr );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Memory available before _nmalloc = 60906
%@AS@%  Memory available after _nmalloc = 40390%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:memccpy@%%@QR:_fmemccpy@%%@NL@%
%@2@%%@CR:C6A02000995 @%%@AB@%memccpy, _fmemccpy%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02000996 @%%@CR:C6A02000997 @% %@CR:C6A02000998 @%%@CR:C6A02000999 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Copy characters from a buffer.  %@NL@%
%@NL@%
%@AB@%#include <memory.h>%@AE@%               Required only for function declarations

%@AB@%#include <string.h>%@AE@%               Use either STRING.H or MEMORY.H

%@AS@%  void *memccpy( void *dest, void *src, int c, unsigned int count );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far * _far _fmemccpy( void _far *dest, void _far *src, int c,
%@AS@%  unsigned int count );%@AE@%%@NL@%
%@NL@%
%@AI@%dest%@AE@%                              Pointer to destination

%@AI@%src%@AE@%                               Pointer to source

%@AI@%c%@AE@%                                 Last character to copy

%@AI@%count%@AE@%                             Number of characters

%@NL@%
%@3@%%@AB@%Remarks%@CR:C6A02001000 @%%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memccpy%@AE@% and %@AB@%_fmemccpy %@AE@%functions copy 0 or more bytes of%@AB@% %@AE@%%@AI@%src%@AE@% to %@AI@%dest%@AE@%,
halting when the character %@AI@%c%@AE@% has been copied or when %@AI@%count%@AE@% bytes have been
copied, whichever comes first.  %@NL@%
%@NL@%
The %@AB@%_fmemccpy%@AE@% function is a model-independent (large-model) form of the
%@AB@%memccpy%@AE@% function. It can be called from any point in any program.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If the character %@AI@%c%@AE@% is copied, %@AB@%memccpy%@AE@% or %@AB@%_fmemccpy%@AE@% returns a pointer (or far
pointer) to the byte in %@AI@%dest%@AE@% that immediately follows the character. If %@AI@%c%@AE@% is
not copied, %@AB@%memccpy%@AE@% returns %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memccpy%@AE@%  %@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2   UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@AB@%_fmemccpy%@AE@%  %@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memchr%@AE@%,%@AB@% memcmp%@AE@%,%@AB@% memcpy%@AE@%,%@AB@% memset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MEMCCPY.C */
%@AS@%  #include <memory.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <string.h>
%@AS@%  
%@AS@%  char string1[60] = "The quick brown dog jumps over the lazy fox";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[61];
%@AS@%     char *pdest;
%@AS@%  
%@AS@%     printf( "Function:\tmemccpy 60 characters or to character 's'\n" );
%@AS@%     printf( "Source:\t\t%s\n", string1 );
%@AS@%     pdest = memccpy( buffer, string1, 's', 60 );
%@AS@%     *pdest = '\0';
%@AS@%     printf( "Result:\t\t%s\n", buffer );
%@AS@%     printf( "Length:\t\t%d characters\n\n", strlen( buffer ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Function:       memccpy 60 characters or to character 's'
%@AS@%  Source:         The quick brown dog jumps over the lazy fox
%@AS@%  Result:         The quick brown dog jumps
%@AS@%  Length:         25 characters %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:memchr@%%@QR:_fmemchr@%%@NL@%
%@2@%%@CR:C6A02011001 @%%@AB@%memchr, _fmemchr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02011002 @%%@CR:C6A02011003 @% %@CR:C6A02011004 @%%@CR:C6A02011005 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Find characters in a buffer.  %@NL@%
%@NL@%
%@AB@%#include <memory.h>%@AE@%               Required only for function declarations

%@AB@%#include <string.h>%@AE@%               Use either STRING.H (for ANSI 
                                  compatibility) or MEMORY.H

%@AS@%  void *memchr( const void *buf, int c, size_t count );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far * _far _fmemchr( const void _far *buf, int c, size_t count );%@AE@%%@NL@%
%@NL@%
%@AI@%buf%@AE@%                               Pointer to buffer

%@AI@%c%@AE@%                                 Character to look for

%@AI@%count%@AE@%                             Number of characters

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memchr%@AE@% and %@AB@%_fmemchr%@AE@% functions look for the first occurrence of %@AI@%c%@AE@% in the
first %@AI@%count%@AE@% bytes of %@AI@%buf%@AE@%. They stop when they find %@AI@%c%@AE@% or when they have
checked the first %@AI@%count%@AE@% bytes. %@CR:C6A02011006 @%  %@NL@%
%@NL@%
The %@AB@%_fmemchr%@AE@% function is a model-independent (large-model) form of the
%@AB@%memchr%@AE@% function. It can be called from any point in any program.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, %@AB@%memchr%@AE@% or %@AB@%_fmemchr%@AE@% returns a pointer (or a far pointer) to
the first location of %@AI@%c%@AE@% in %@AI@%buf%@AE@%. Otherwise, they return %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memchr%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2   %@AB@%%@AE@% UNIX   %@AB@%%@AE@% XENIX %@NL@%
%@NL@%
%@NL@%
%@AB@%_fmemchr%@AE@%  %@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memccpy%@AE@%,%@AB@% memcmp%@AE@%,%@AB@% memcpy%@AE@%,%@AB@% memset%@AE@%,%@AB@% strchr%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MEMCHR.C */
%@AS@%  #include <memory.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int  ch = 'r';
%@AS@%  char str[] =    "lazy";
%@AS@%  char string[] = "The quick brown dog jumps over the lazy fox";
%@AS@%  char fmt1[] =   "         1         2         3         4         5";
%@AS@%  char fmt2[] =   "12345678901234567890123456789012345678901234567890";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *pdest;
%@AS@%     int result;
%@AS@%  
%@AS@%     printf( "String to be searched:\n\t\t%s\n", string );
%@AS@%     printf( "\t\t%s\n\t\t%s\n\n", fmt1, fmt2 );
%@AS@%  
%@AS@%     printf( "Search char:\t%c\n", ch );
%@AS@%     pdest = memchr( string, ch, sizeof( string ) );
%@AS@%     result = pdest - string + 1;
%@AS@%     if( pdest != NULL )
%@AS@%        printf( "Result:\t\t%c found at position %d\n\n", ch, result );
%@AS@%     else
%@AS@%        printf( "Result:\t\t%c not found\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  String to be searched:
%@AS@%                  The quick brown dog jumps over the lazy fox
%@AS@%                           1         2         3         4         5
%@AS@%                  12345678901234567890123456789012345678901234567890
%@AS@%  
%@AS@%  Search char:    r
%@AS@%  Result:         r found at position 12 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:memcmp@%%@QR:_fmemcmp@%%@NL@%
%@2@%%@CR:C6A02021007 @%%@AB@%memcmp, _fmemcmp%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02021008 @%%@CR:C6A02021009 @% %@CR:C6A02021010 @%%@CR:C6A02021011 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Compare characters in two buffers.  %@NL@%
%@NL@%
%@AB@%#include <memory.h>%@AE@%               Required only for function declarations

%@AB@%#include <string.h>%@AE@%               Use either STRING.H (for ANSI 
                                  compatibility) or MEMORY.H

%@AS@%  int memcmp( const void *buf1, const void *buf2, size_t count );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _far _fmemcmp( const void _far *buf1, const void _far *buf2, size_t
%@AS@%  count );%@AE@%%@NL@%
%@NL@%
%@AI@%buf1%@AE@%                              First buffer

%@AI@%buf2%@AE@%                              Second buffer

%@AI@%count%@AE@%                             Number of characters

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memcmp%@AE@% and %@AB@%_fmemcmp%@AE@% functions compare the first %@AI@%count%@AE@% bytes of %@AI@%buf1%@AE@% and
%@AI@%buf2%@AE@% and return a value indicating their relationship, as follows: %@CR:C6A02021012 @%  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
< 0                               %@AI@%buf1%@AE@% less than %@AI@%buf2%@AE@%

= 0                               %@AI@%buf1%@AE@% identical to %@AI@%buf2%@AE@%

> 0                               %@AI@%buf1%@AE@% greater than %@AI@%buf2%@AE@%

The %@AB@%_fmemcmp%@AE@% function is a model-independent (large-model) form of the
%@AB@%memcmp%@AE@% function. It can be called from any point in program.  %@NL@%
%@NL@%
There is a semantic difference between the function version of %@AB@%memcmp %@AE@%and
its intrinsic version. The function version supports huge pointers in
compact-, large-, and huge-model programs, but the intrinsic version does
not.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memcmp%@AE@% function returns an integer value, as described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memcmp%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2   %@AB@%%@AE@% UNIX   %@AB@%%@AE@% XENIX %@NL@%
%@NL@%
%@NL@%
%@AB@%_fmemcmp%@AE@%  %@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memccpy%@AE@%, %@AB@%memchr%@AE@%, %@AB@%memcpy%@AE@%, %@AB@%memset%@AE@%, %@AB@%strcmp%@AE@%, %@AB@%strncmp%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MEMCMP.C: This program uses memcmp to compare the strings named
%@AS@%   * first and second. If the first 19 bytes of the strings are
%@AS@%   * equal, the program considers the strings to be equal.
%@AS@%   */
%@AS@%  
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char first[]  = "12345678901234567890";
%@AS@%     char second[] = "12345678901234567891";
%@AS@%     int result;
%@AS@%  
%@AS@%     printf( "Compare '%.19s' to '%.19s':\n", first, second );
%@AS@%     result = memcmp( first, second, 19 );
%@AS@%     if( result < 0 )
%@AS@%        printf( "First is less than second.\n" );
%@AS@%     else if( result == 0 )
%@AS@%        printf( "First is equal to second.\n" );
%@AS@%     else if( result > 0 )
%@AS@%        printf( "First is greater than second.\n" );
%@AS@%     printf( "Compare '%.20s' to '%.20s':\n", first, second );
%@AS@%     result = memcmp( first, second, 20 );
%@AS@%     if( result < 0 )
%@AS@%        printf( "First is less than second.\n" );
%@AS@%     else if( result == 0 )
%@AS@%        printf( "First is equal to second.\n" );
%@AS@%     else if( result > 0 )
%@AS@%        printf( "First is greater than second.\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Compare '1234567890123456789' to '1234567890123456789':
%@AS@%  First is equal to second.
%@AS@%  Compare '12345678901234567890' to '12345678901234567891':
%@AS@%  First is less than second. %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:memcpy@%%@QR:_fmemcpy@%%@NL@%
%@2@%%@CR:C6A02031013 @%%@AB@%memcpy, _fmemcpy%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02031014 @%%@CR:C6A02031015 @% %@CR:C6A02031016 @%%@CR:C6A02031017 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Copy characters between buffers.  %@NL@%
%@NL@%
%@AB@%#include <memory.h>%@AE@%               Required only for function declarations%@AB@%%@AE@%

%@AB@%#include <string.h>%@AE@%               Use either STRING.H (for ANSI 
                                  compatibility) or MEMORY.H

%@AS@%  void *memcpy( void *dest, const void *src, size_t count );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far  * _far _fmemcpy( void _far *dest, const void _far *src, size_t
%@AS@%  count );%@AE@%%@NL@%
%@NL@%
%@AI@%dest%@AE@%                              New buffer

%@AI@%src%@AE@%                               Buffer to copy from

%@AI@%count%@AE@%                             Number of characters to copy

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memcpy%@AE@% and %@AB@%_fmemcpy%@AE@% functions copy %@AI@%count%@AE@% bytes of %@AI@%src%@AE@% to %@AI@%dest%@AE@%. If the
source and destination overlap, these functions do not ensure that the
original source bytes in the overlapping region are copied before being
overwritten. Use %@AB@%memmove%@AE@% to handle overlapping regions. %@CR:C6A02031018 @%%@CR:C6A02031019 @%  %@NL@%
%@NL@%
The %@AB@%_fmemcpy%@AE@% function is a model-independent (large-model) form of the
%@AB@%memcpy%@AE@% function. It can be called from any point in any program.  %@NL@%
%@NL@%
There is a semantic difference between the function version of %@AB@%memcpy%@AE@% and
its intrinsic version. The function version supports huge pointers in
compact-, large-, and huge-model programs, but the intrinsic version does
not.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memcpy%@AE@% and %@AB@%_fmemcpy%@AE@% functions return a pointer to %@AI@%dest%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memcpy%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2   %@AB@%%@AE@% UNIX   %@AB@%%@AE@% XENIX %@NL@%
%@NL@%
%@NL@%
%@AB@%_fmemcpy%@AE@%  %@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memccpy%@AE@%, %@AB@%memchr%@AE@%, %@AB@%memcmp%@AE@%, %@AB@%memmove%@AE@%, %@AB@%memset%@AE@%, %@AB@%strcpy%@AE@%, %@AB@%strncpy%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MEMCPY.C. Illustrate overlapping copy: memmove handles it
%@AS@%   * correctly; memcpy does not.
%@AS@%   */
%@AS@%  #include <memory.h>
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  char string1[60] = "The quick brown dog jumps over the lazy fox";
%@AS@%  char string2[60] = "The quick brown fox jumps over the lazy dog";
%@AS@%  /*                           1         2         3         4         5 
%@AS@%   *                  12345678901234567890123456789012345678901234567890 
%@AS@%   */
%@AS@%  void main()
%@AS@%  {
%@AS@%     printf( "Function:\tmemcpy without overlap\n" );
%@AS@%     printf( "Source:\t\t%s\n", string1 + 40 );
%@AS@%     printf( "Destination:\t%s\n", string1 + 16 );
%@AS@%     memcpy( string1 + 16, string1 + 40, 3 );
%@AS@%     printf( "Result:\t\t%s\n", string1 );
%@AS@%     printf( "Length:\t\t%d characters\n\n", strlen( string1 ) );
%@AS@%  
%@AS@%     /* Restore string1 to original contents */
%@AS@%     memcpy( string1 + 16, string2 + 40, 3 );
%@AS@%  
%@AS@%     printf( "Function:\tmemmove with overlap\n" );
%@AS@%     printf( "Source:\t\t%s\n", string2 + 4 );
%@AS@%     printf( "Destination:\t%s\n", string2 + 10 );
%@AS@%     memmove( string2 + 10, string2 + 4, 40 );
%@AS@%     printf( "Result:\t\t%s\n", string2 );
%@AS@%     printf( "Length:\t\t%d characters\n\n", strlen( string2 ) );
%@AS@%  
%@AS@%     printf( "Function:\tmemcpy with overlap\n" );
%@AS@%     printf( "Source:\t\t%s\n", string1 + 4 );
%@AS@%     printf( "Destination:\t%s\n", string1 + 10 );
%@AS@%     memcpy( string1 + 10, string1 + 4, 40 );
%@AS@%     printf( "Result:\t\t%s\n", string1 );
%@AS@%     printf( "Length:\t\t%d characters\n\n", strlen( string1 ) );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Function:       memcpy without overlap
%@AS@%  Source:         fox
%@AS@%  Destination:    dog jumps over the lazy fox
%@AS@%  Result:         The quick brown fox jumps over the lazy fox
%@AS@%  Length:         43 characters
%@AS@%  
%@AS@%  Function:       memmove with overlap
%@AS@%  Source:         quick brown fox jumps over the lazy dog
%@AS@%  Destination:    brown fox jumps over the lazy dog
%@AS@%  Result:         The quick quick brown fox jumps over the lazy dog
%@AS@%  Length:         49 characters
%@AS@%  
%@AS@%  Function:       memcpy with overlap
%@AS@%  Source:         quick brown dog jumps over the lazy fox
%@AS@%  Destination:    brown dog jumps over the lazy fox
%@AS@%  Result:         The quick quick quick quick quick quick quick quic
%@AS@%  Length:         50 characters %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:memicmp@%%@QR:_fmemicmp@%%@NL@%
%@2@%%@CR:C6A02041020 @%%@AB@%memicmp, _fmemicmp%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02041021 @%%@CR:C6A02041022 @% %@CR:C6A02041023 @%%@CR:C6A02041024 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Compare characters in two buffers (case-insensitive).  %@NL@%
%@NL@%
%@AB@%#include <memory.h>%@AE@%               Required only for function declarations

%@AB@%#include <string.h>%@AE@%               Use either STRING.H or MEMORY.H

%@AS@%  int memicmp( void *buf1, void *buf2, unsigned int count );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _far _fmemicmp( void _far *buf1, void _far *buf2, unsigned int count
%@AS@%  );%@AE@%%@NL@%
%@NL@%
%@AI@%buf1%@AE@%                              First buffer

%@AI@%buf2%@AE@%                              Second buffer

%@AI@%count%@AE@%                             Number of characters

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memicmp%@AE@% and %@AB@%_fmemicmp%@AE@% functions compare the first %@AI@%count%@AE@% characters of
the two buffers %@AI@%buf1%@AE@% and %@AI@%buf2%@AE@% byte-by-byte. The comparison is made without
regard to the case of letters in the two buffers; that is, uppercase and
lowercase letters are considered equivalent. The %@AB@%memicmp%@AE@% and %@AB@%_fmemicmp%@AE@%
functions return a value indicating the relationship of the two buffers, as
follows: %@CR:C6A02041025 @%  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
< 0                               %@AI@%buf1%@AE@% less than %@AI@%buf2%@AE@%

= 0                               %@AI@%buf1%@AE@% identical to %@AI@%buf2%@AE@%

> 0                               %@AI@%buf1%@AE@% greater than %@AI@%buf2%@AE@%

The %@AB@%_fmemicmp%@AE@% function is a model-independent (large-model) form of the
%@AB@%memicmp%@AE@% function. It can be called from any point in any program.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memicmp%@AE@% and %@AB@%_fmemicmp%@AE@% functions return an integer value, as described
above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memicmp%@AE@%  %@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2   %@AB@%%@AE@% UNIX   %@AB@%%@AE@% XENIX %@NL@%
%@NL@%
%@NL@%
%@AB@%_fmemicmp%@AE@%  %@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memccpy%@AE@%, %@AB@%memchr%@AE@%, %@AB@%memcmp%@AE@%, %@AB@%memcpy%@AE@%, %@AB@%memset%@AE@%, %@AB@%stricmp%@AE@%, %@AB@%strnicmp%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MEMICMP.C: This program uses memicmp to compare the first
%@AS@%   * 29 letters of the strings named first and second without
%@AS@%   * regard to the case of the letters.
%@AS@%   */
%@AS@%  
%@AS@%  #include <memory.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <string.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int result;
%@AS@%     char first[]  = "Those Who Will Not Learn from History";
%@AS@%     char second[] = "THOSE WHO WILL NOT LEARN FROM their mistakes";
%@AS@%     /* Note that the 29th character is right here ^ */
%@AS@%  
%@AS@%     printf( "Compare '%.29s' to '%.29s'\n", first, second );
%@AS@%     result = memicmp( first, second, 29 );
%@AS@%     if( result < 0 )
%@AS@%        printf( "First is less than second.\n" );
%@AS@%     else if( result == 0 )
%@AS@%        printf( "First is equal to second.\n" );
%@AS@%     else if( result > 0 )
%@AS@%        printf( "First is greater than second.\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Compare 'Those Who Will Not Learn from' to 'THOSE WHO WILL NOT LEARN FROM'
%@AS@%  First is equal to second. %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_memmax@%%@NL@%
%@2@%%@CR:C6A02051026 @%%@AB@%_memmax%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02051027 @%%@CR:C6A02051028 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Finds the size of the largest contiguous memory block.  %@NL@%
%@NL@%
%@AS@%  #include <malloc.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  size_t _memmax( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_memmax%@AE@% function returns the size (in bytes) of the largest contiguous
block of memory that can be allocated from the near heap (i.e., the default
data segment). Calling %@AB@%_nmalloc%@AE@% with the value returned by the %@AB@%_memmax%@AE@%
function will succeed as long as %@AB@%_memmax%@AE@% returns a nonzero value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the block size, if successful. Otherwise, it returns 0,
indicating that nothing more can be allocated from the near heap.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%malloc%@AE@% functions, %@AB@%msize%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MEMMAX.C: This program uses _memmax and _nmalloc to allocate
%@AS@%   * the largest block of memory available in the near heap.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stddef.h>
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     size_t contig;
%@AS@%     char *p;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Determine contiguous memory size */
%@AS@%     contig = _memmax();
%@AS@%     printf( "Largest block of available memory is %u bytes long\n", contig
%@AS@%);
%@AS@%     if( contig )
%@AS@%     {
%@AS@%        p = _nmalloc( contig * sizeof( int ) );
%@AS@%        if( p == NULL )
%@AS@%           printf( "Error with malloc (should never occur)\n" );
%@AS@%        else
%@AS@%        {
%@AS@%           printf( "Maximum allocation succeeded\n" );
%@AS@%           free( p );
%@AS@%        }
%@AS@%     }
%@AS@%     else
%@AS@%        printf( "Near heap is already full\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Largest block of available memory is 60844 bytes long
%@AS@%  Maximum allocation succeeded%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:memmove@%%@QR:_fmemmove@%%@NL@%
%@2@%%@CR:C6A02061029 @%%@AB@%memmove, _fmemmove%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02061030 @%%@CR:C6A02061031 @% %@CR:C6A02061032 @%%@CR:C6A02061033 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Move one buffer to another.  %@NL@%
%@NL@%
%@AS@%  #include <string.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void *memmove( void *dest, const void *src, size_t count );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far * _far _fmemmove( void _far *dest, const void _far *src, size_t
%@AS@%  count );%@AE@%%@NL@%
%@NL@%
%@AI@%dest%@AE@%                              Destination object

%@AI@%src%@AE@%                               Source object

%@AI@%count%@AE@%                             Number of characters to copy

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memmove%@AE@% and %@AB@%_fmemmove%@AE@% functions copy %@AI@%count%@AE@% characters from the source
(%@AI@%src%@AE@%) to the destination (%@AI@%dest%@AE@%). If some regions of the source area and the
destination overlap, the %@AB@%memmove%@AE@% and %@AB@%_fmemmove%@AE@% functions ensure that the
original source bytes in the overlapping region are copied before being
overwritten.  %@NL@%
%@NL@%
The %@AB@%_fmemmove%@AE@% function is a model-independent (large-model) form of the
%@AB@%memmove%@AE@% function. It can be called from any point in any program.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memmove%@AE@% and %@AB@%_fmemmove%@AE@% functions return the value of %@AI@%dest%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memmove%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@AB@%_fmemmove%@AE@%  %@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memccpy%@AE@%, %@AB@%memcpy%@AE@%, %@AB@%strccpy%@AE@%, %@AB@%strncpy%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MEMCPY.C. Illustrate overlapping copy: memmove handles it
%@AS@%   * correctly; memcpy does not.
%@AS@%   */
%@AS@%  #include <memory.h>
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char string1[60] = "The quick brown dog jumps over the lazy fox";
%@AS@%  char string2[60] = "The quick brown fox jumps over the lazy dog";
%@AS@%  /*                           1         2         3         4         5 
%@AS@%   *                  12345678901234567890123456789012345678901234567890 
%@AS@%   */
%@AS@%  void main()
%@AS@%  {
%@AS@%     printf( "Function:\tmemcpy without overlap\n" );
%@AS@%     printf( "Source:\t\t%s\n", string1 + 40 );
%@AS@%     printf( "Destination:\t%s\n", string1 + 16 );
%@AS@%     memcpy( string1 + 16, string1 + 40, 3 );
%@AS@%     printf( "Result:\t\t%s\n", string1 );
%@AS@%     printf( "Length:\t\t%d characters\n\n", strlen( string1 ) );
%@AS@%  
%@AS@%     /* Restore string1 to original contents */
%@AS@%     memcpy( string1 + 16, string2 + 40, 3 );
%@AS@%  
%@AS@%     printf( "Function:\tmemmove with overlap\n" );
%@AS@%     printf( "Source:\t\t%s\n", string2 + 4 );
%@AS@%     printf( "Destination:\t%s\n", string2 + 10 );
%@AS@%     memmove( string2 + 10, string2 + 4, 40 );
%@AS@%     printf( "Result:\t\t%s\n", string2 );
%@AS@%     printf( "Length:\t\t%d characters\n\n", strlen( string2 ) );
%@AS@%  
%@AS@%     printf( "Function:\tmemcpy with overlap\n" );
%@AS@%     printf( "Source:\t\t%s\n", string1 + 4 );
%@AS@%     printf( "Destination:\t%s\n", string1 + 10 );
%@AS@%     memcpy( string1 + 10, string1 + 4, 40 );
%@AS@%     printf( "Result:\t\t%s\n", string1 );
%@AS@%     printf( "Length:\t\t%d characters\n\n", strlen( string1 ) );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Function:       memcpy without overlap
%@AS@%  Source:         fox
%@AS@%  Destination:    dog jumps over the lazy fox
%@AS@%  Result:         The quick brown fox jumps over the lazy fox
%@AS@%  Length:         43 characters
%@AS@%  
%@AS@%  Function:       memmove with overlap
%@AS@%  Source:         quick brown fox jumps over the lazy dog
%@AS@%  Destination:    brown fox jumps over the lazy dog
%@AS@%  Result:         The quick quick brown fox jumps over the lazy dog
%@AS@%  Length:         49 characters%@AE@%%@NL@%
%@NL@%
%@AS@%  Function:       memcpy with overlap
%@AS@%  Source:         quick brown dog jumps over the lazy fox
%@AS@%  Destination:    brown dog jumps over the lazy fox
%@AS@%  Result:         The quick quick quick quick quick quick quick quic
%@AS@%  Length:         50 characters %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:memset@%%@QR:_fmemset@%%@NL@%
%@2@%%@CR:C6A02071034 @%%@AB@%memset, _fmemset%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02071035 @%%@CR:C6A02071036 @% %@CR:C6A02071037 @%%@CR:C6A02071038 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Set buffers to a specified character.  %@NL@%
%@NL@%
%@AB@%#include <memory.h>%@AE@%               Required only for function declarations

%@AB@%#include <string.h>%@AE@%               Use either STRING.H (for ANSI 
                                  compatibility) or MEMORY.H

%@AS@%  void *memset( void *dest, int c, size_t count );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far * _far _fmemset( void _far *dest, int c, size_t count );%@AE@%%@NL@%
%@NL@%
%@AI@%dest%@AE@%                              Pointer to destination

%@AI@%c%@AE@%                                 Character to set

%@AI@%count%@AE@%                             Number of characters

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memset%@AE@% and %@AB@%_fmemset%@AE@% functions set the first %@AI@%count%@AE@% bytes of %@AI@%dest%@AE@% to the
character %@AI@%c%@AE@%.%@CR:C6A02071039 @%  %@NL@%
%@NL@%
The %@AB@%_fmemset%@AE@% function is a model-independent (large-model) form of the
%@AB@%memset%@AE@% function. It can be called from any point in any program.  %@NL@%
%@NL@%
There is a semantic difference between the function version of %@AB@%memset%@AE@% and
its intrinsic version. The function version supports huge pointers in
compact-, large-, and huge-model programs, but the intrinsic version does
not.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%memset%@AE@% and %@AB@%_fmemset%@AE@% functions return a pointer to %@AI@%dest%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memset%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2   %@AB@%%@AE@% UNIX   %@AB@%%@AE@% XENIX %@NL@%
%@NL@%
%@NL@%
%@AB@%_fmemset%@AE@%  %@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2   UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memccpy%@AE@%, %@AB@%memchr%@AE@%, %@AB@%memcmp%@AE@%, %@AB@%memcpy%@AE@%, %@AB@%strnset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MEMSET.C: This program uses memset to set the first four bytes
%@AS@%   * of buffer to "*".
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <memory.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[] = "This is a test of the memset function";
%@AS@%  
%@AS@%     printf( "Before: %s\n", buffer );
%@AS@%     memset( buffer, '*', 4 );
%@AS@%     printf( "After:  %s\n", buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Before: This is a test of the memset function
%@AS@%  After:  **** is a test of the memset function %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:min@%%@NL@%
%@2@%%@CR:C6A02081040 @%%@AB@%min%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02081041 @%%@CR:C6A02081042 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Returns the smaller of two values.  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  type min( type a, type b );%@AE@%%@NL@%
%@NL@%
%@AI@%type%@AE@%                              Any numeric data type

%@AI@%a%@AE@%,%@AI@% b%@AE@%                              Values of any numeric type to be 
                                  compared

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%min%@AE@% macro compares two values and returns the value of the smaller one.
The arguments can be of any numeric data type, signed or unsigned. Both
arguments and the return value must be of the same data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The macro returns the smaller of the two arguments.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%max%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MINMAX.C */
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int a = 10;
%@AS@%     int b = 21;
%@AS@%  
%@AS@%     printf( "The larger of %d and %d is %d\n",  a, b, max( a, b ) );
%@AS@%     printf( "The smaller of %d and %d is %d\n", a, b, min( a, b ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The larger of 10 and 21 is 21
%@AS@%  The smaller of 10 and 21 is 10%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:mkdir@%%@NL@%
%@2@%%@CR:C6A02091043 @%%@AB@%mkdir%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02091044 @%%@CR:C6A02091045 @%%@CR:C6A02091046 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Creates a new directory.  %@NL@%
%@NL@%
%@AB@%#include <direct.h>%@AE@%               Required only for function declarations

%@AS@%  int mkdir( char *dirname );%@AE@%%@NL@%
%@NL@%
%@AI@%dirname%@AE@%                           Path name for new directory

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%mkdir%@AE@% function creates a new directory with the specified %@AI@%dirname%@AE@%. Only
one directory can be created at a time, so only the last component of
%@AI@%dirname%@AE@% can name a new directory.  %@NL@%
%@NL@%
The %@AB@%mkdir%@AE@% function does not do any translation of path-name delimiters. Both
DOS and OS/ 2 accept either " \" or "/ "  internally as valid delimiters
within path names.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%mkdir%@AE@% function returns the value 0 if the new directory was created. A
return value of -1 indicates an error, and %@AB@%errno%@AE@% is set to one of the
following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Directory not created. The given name is
                                  the name of an
                                  existing file, directory, or device.

%@AB@%ENOENT%@AE@%                            Path name not found.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%chdir%@AE@%, %@AB@%rmdir%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MAKEDIR.C */
%@AS@%  #include <direct.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     int result;
%@AS@%  
%@AS@%     if( mkdir( "\\testtmp" ) == 0 )
%@AS@%     {
%@AS@%        printf( "Directory '\\testtmp' was successfully created\n" );
%@AS@%        system( "dir \\testtmp" );
%@AS@%        if( rmdir( "\\testtmp" ) == 0 )
%@AS@%           printf( "Directory '\\testtmp' was successfully removed\n"  );
%@AS@%        else
%@AS@%           printf( "Problem removing directory '\\testtmp'\n" );
%@AS@%     }
%@AS@%     else
%@AS@%        printf( "Problem creating directory '\\testtmp'\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Directory '\testtmp' was successfully created
%@AS@%  
%@AS@%   The volume label in drive C is OS2.
%@AS@%   Directory of C:\TESTTMP
%@AS@%  
%@AS@%  .            <DIR>      6-19-89  11:20a
%@AS@%  ..           <DIR>      6-19-89  11:20a
%@AS@%       2 File(s)   12730368 bytes free
%@AS@%  Directory '\testtmp' was successfully removed %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:mktemp@%%@NL@%
%@2@%%@CR:C6A02101047 @%%@AB@%mktemp%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02101048 @%%@CR:C6A02101049 @%%@CR:C6A02101050 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Creates a unique file name.  %@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  char *mktemp( char *template );%@AE@%%@NL@%
%@NL@%
%@AI@%template%@AE@%                          File-name pattern

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%mktemp%@AE@% function creates a unique file name by modifying the given
%@AI@%template%@AE@% argument. The %@AI@%template%@AE@% argument has the form:  %@NL@%
%@NL@%
%@AI@%base%@AE@%%@AB@%XXXXXX%@AE@%  %@NL@%
%@NL@%
where %@AI@%base%@AE@% is the part of the new file name that you supply, and the %@AB@%X%@AE@%'s are
placeholders for the part supplied by %@AB@%mktemp%@AE@%; %@AB@%mktemp%@AE@% preserves %@AI@%base%@AE@% and
replaces the six trailing%@AB@% X%@AE@%'s with an alphanumeric character followed by a
five-digit value. The five-digit value is a unique number identifying the
calling process. The alphanumeric character is 0 ('%@AB@%0%@AE@%') the first time %@AB@%mktemp%@AE@%
is called with a given template.  %@NL@%
%@NL@%
In subsequent calls from the same process with copies of the same template,
%@AB@%mktemp%@AE@% checks to see if previously returned names have been used to create
files. If no file exists for a given name, %@AB@%mktemp%@AE@% returns that name. If
files exist for all previously returned names, %@AB@%mktemp%@AE@% creates a new name by
replacing the alphanumeric character in the name with the next available
lowercase letter. For example, if the first name returned is %@AS@% t012345 %@AE@% and
this name is used to create a file, the next name returned will be %@AS@% ta12345%@AE@%.
When creating new names, %@AB@%mktemp%@AE@% uses, in order, '0' and then the lowercase
letters 'a' through 'z'.  %@NL@%
%@NL@%
Note that the original template is modified by the first call to %@AB@%mktemp%@AE@%. If
you then call the %@AB@%mktemp%@AE@% function again with the same template (i.e., the
original one), you will get an error.  %@NL@%
%@NL@%
The %@AB@%mktemp%@AE@% function generates unique file names but does not create or open
files.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%mktemp%@AE@% function returns a pointer to the modified template. The return
value is %@AB@%NULL%@AE@% if the %@AI@%template%@AE@% argument is badly formed or no more unique
names can be created from the given template.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2   %@AB@%%@AE@% UNIX   %@AB@%%@AE@% XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fopen%@AE@%, %@AB@%getpid%@AE@%, %@AB@%open%@AE@%, %@AB@%tempnam%@AE@%, %@AB@%tmpfile%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MKTEMP.C: The program uses mktemp to create five unique file names.
%@AS@%   * It opens each file name to ensure that the next name is unique.
%@AS@%   */
%@AS@%  
%@AS@%  #include <io.h>
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  char *template = "fnXXXXXX";
%@AS@%  char *result;
%@AS@%  char names[5][9];
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int i;
%@AS@%     FILE *fp;
%@AS@%  
%@AS@%     for( i = 0; i < 5; i++ )
%@AS@%     {
%@AS@%        strcpy( names[i], template );
%@AS@%  
%@AS@%        /* Attempt to find a unique file name: */
%@AS@%        result = mktemp( names[i] );
%@AS@%        if( result == NULL )
%@AS@%           printf( "Problem creating the template" );
%@AS@%        else
%@AS@%        {
%@AS@%           if( (fp = fopen( result, "w" )) != NULL )
%@AS@%               printf( "Unique file name is %s\n", result );
%@AS@%           else
%@AS@%               printf( "Cannot open %s\n", result );
%@AS@%           fclose( fp );
%@AS@%        }
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Unique file name is fn000686
%@AS@%  Unique file name is fna00686
%@AS@%  Unique file name is fnb00686
%@AS@%  Unique file name is fnc00686
%@AS@%  Unique file name is fnd00686%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:mktime@%%@NL@%
%@2@%%@CR:C6A02111051 @%%@AB@%mktime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02111052 @%%@CR:C6A02111053 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Converts the local time to a calendar value.  %@NL@%
%@NL@%
%@AS@%  #include <time.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  time_t mktime( struct tm *timeptr );%@AE@%%@NL@%
%@NL@%
%@AI@%timeptr%@AE@%                           Pointer to time structure

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%mktime%@AE@% function converts the supplied time structure (possibly
incomplete) pointed to by %@AI@%timeptr%@AE@% into a fully defined structure with
"normalized" values and then converts it to a %@AB@%time_t%@AE@% calendar time value.
The structure for the %@AB@%tm%@AE@% is described in the reference page for %@AB@%asctime%@AE@%.  %@NL@%
%@NL@%
The converted time has the same encoding as the values returned by the %@AB@%time%@AE@%
function. The original values of the %@AB@%tm_wday%@AE@% and %@AB@%tm_yday%@AE@% components of the
%@AI@%timeptr%@AE@% structure are ignored, and the original values of the other
components are not restricted to their normal ranges.  %@NL@%
%@NL@%
If successful, %@AB@%mktime%@AE@% sets the values of %@AB@%tm_wday%@AE@% and %@AB@%tm_yday%@AE@% appropriately,
and sets the other components to represent the specified calendar time, but
with their values forced to the normal ranges; the final value of %@AB@%tm_mday%@AE@% is
not set until %@AB@%tm_mon%@AE@% and %@AB@%tm_year%@AE@% are determined.  %@NL@%
%@NL@%
DOS and OS/2 do not accommodate dates prior to 1980. If %@AI@%timeptr%@AE@% references a
date before January 1, 1980, %@AB@%mktime%@AE@% returns -1.  %@NL@%
%@NL@%
Note that the %@AB@%gmtime%@AE@% and %@AB@%localtime%@AE@% functions use a single statically
allocated buffer for the conversion. If you supply this buffer to %@AB@%mktime%@AE@%,
the previous contents will be destroyed.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%mktime%@AE@% function returns the specified calendar time encoded as a value
of type %@AB@%time_t%@AE@%. If the calendar time cannot be represented, the function
returns the value -1 cast as type %@AB@%time_t%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asctime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%time%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MKTIME.C: The example takes a number of days as input and returns
%@AS@%   * the time, the current date, and the specified number of days.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <time.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct tm when;
%@AS@%     time_t now, result;
%@AS@%     int    days;
%@AS@%  
%@AS@%     time( &now );
%@AS@%     when = *localtime( &now );
%@AS@%     printf( "Current time is %s\n", asctime( &when ) );
%@AS@%     printf( "How many days to look ahead: " );
%@AS@%     scanf( "%d", &days );
%@AS@%  
%@AS@%     when.tm_mday = when.tm_mday + days;
%@AS@%     if( (result = mktime( &when )) != (time_t)-1 )
%@AS@%        printf( "In %d days the time will be %s\n",
%@AS@%                days, asctime( &when ) );
%@AS@%     else
%@AS@%        perror( "mktime failed" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Current time is Mon Jun 19 11:45:20 1989
%@AS@%  
%@AS@%  How many days to look ahead: 23
%@AS@%  In 23 days the time will be Wed Jul 12 11:45:20 1989 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:modf@%%@QR:modfl@%%@NL@%
%@2@%%@CR:C6A02121054 @%%@AB@%modf, modfl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02121055 @% %@CR:C6A02121056 @%%@CR:C6A02121057 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Split a floating-point value into a mantissa and an exponent.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double modf( double x, double *intptr );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double modfl( long double x, long double *intptr );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Floating-point value

%@AI@%intptr%@AE@%                            Pointer to stored integer portion

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%modf%@AE@% functions break down the floating-point value %@AI@%x%@AE@% into fractional and
integer parts, each of which has the same sign as %@AI@%x%@AE@%. The signed fractional
portion of %@AI@%x%@AE@% is returned. The integer portion is stored as a floating-point
value at  %@AI@%intptr%@AE@%.  %@NL@%
%@NL@%
The %@AB@%modfl%@AE@% function uses the 80-bit, 10-byte coprocessor form of arguments
and return values. See the reference page on the long double functions for
more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%modf%@AE@% and %@AB@%modfl%@AE@% functions return the signed fractional portion of %@AI@%x%@AE@%.
There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%modf%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2   %@AB@%%@AE@% UNIX   %@AB@%%@AE@% XENIX %@NL@%
%@NL@%
%@NL@%
%@AB@%modfl%@AE@%  %@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%frexp%@AE@%, %@AB@%ldexp%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MODF.C */
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     double x, y, n;
%@AS@%  
%@AS@%     x = -14.87654321;       /* Divide x into its fractional */
%@AS@%     y = modf( x, &n );      /* and integer parts            */
%@AS@%  
%@AS@%     printf( "For %f, the fraction is %f and the integer is %.f\n", x, y, n
%@AS@%);
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  For -14.876543, the fraction is -0.876543 and the integer is -14 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:movedata@%%@NL@%
%@2@%%@CR:C6A02131058 @%%@AB@%movedata%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02131059 @%%@CR:C6A02131060 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Moves characters to another segment.  %@NL@%
%@NL@%
%@AB@%#include <memory.h>%@AE@%               Required only for function declarations%@AB@%%@AE@%

%@AB@%#include <string.h>%@AE@%               Use either STRING.H (for ANSI 
                                  compatibility) or MEMORY.H

%@AS@%  void movedata( unsigned int srcseg, unsigned int srcoff, unsigned int
%@AS@%  destseg, 
%@AS@%  unsigned int destoff, unsigned int count );%@AE@%%@NL@%
%@NL@%
%@AI@%srcseg%@AE@%                            Segment address of source

%@AI@%srcoff%@AE@%                            Segment offset of source

%@AI@%destseg%@AE@%                           Segment address of destination

%@AI@%destoff%@AE@%                           Segment offset of destination

%@AI@%count%@AE@%                             Number of bytes

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%movedata%@AE@% function copies %@AI@%count%@AE@% bytes from the source address specified
by %@AI@%srcseg%@AE@%:%@AI@%srcoff%@AE@% to the destination address specified by %@AI@%destseg%@AE@%:%@AI@%destoff%@AE@%.%@CR:C6A02131061 @%  %@NL@%
%@NL@%
The %@AB@%movedata%@AE@% function was intended to move far data in small-data-model
programs. The newer model-independent %@AB@%_fmemcpy%@AE@% and %@AB@%_fmemmove%@AE@% functions
should be used instead of the %@AB@%movedata%@AE@% function. In large-data-model
programs, the %@AB@%memcpy%@AE@% and %@AB@%memmove%@AE@% functions can also be used.  %@NL@%
%@NL@%
Segment values for the %@AI@%srcseg%@AE@% and %@AI@%destseg%@AE@% arguments can be obtained by using
either the %@AB@%segread%@AE@% function or the %@AB@%FP_SEG%@AE@% macro.  %@NL@%
%@NL@%
The %@AB@%movedata%@AE@% function does not handle all cases of overlapping moves
correctly. These occur when part of the destination is the same memory area
as part of the source. The %@AB@%memmove%@AE@% function correctly handles overlapping
moves.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@%FP_OFF, FP_SEG, %@AB@%memcpy%@AE@%, %@AB@%memmove%@AE@%, %@AB@%segread%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MOVEDATA.C */
%@AS@%  #include <memory.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <string.h>
%@AS@%  #include <dos.h>
%@AS@%  #include <malloc.h>
%@AS@%  
%@AS@%  char _far *src = "This is a test.";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char _far *dest;
%@AS@%  
%@AS@%     if( (dest = _fmalloc( 80 )) != NULL )
%@AS@%     {
%@AS@%        movedata( FP_SEG( src ),  FP_OFF( src ),
%@AS@%                  FP_SEG( dest ), FP_OFF( dest ), _fstrlen( src ) + 1 );
%@AS@%        printf( "The source data at %Fp is '%Fs'\n", src, src );
%@AS@%        printf( "The destination data at %Fp is '%Fs'\n", dest, dest );
%@AS@%        _ffree( dest );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The source data at 2D0A:02B8 is 'This is a test.'
%@AS@%  The destination data at 3D0B:0016 is 'This is a test.'%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_moveto@%%@NL@%
%@2@%%@CR:C6A02141062 @%%@AB@%_moveto Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Move current graphics positions.  %@NL@%
%@NL@%
%@CR:C6A02141063 @%%@CR:C6A02141064 @%%@CR:C6A02141065 @%%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct xycoord _far _moveto( short x, short y );%@AE@%%@NL@%
%@NL@%
%@AS@%  struct _wxycoord _far _moveto_w( double wx, double wy );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              View-coordinate point

%@AI@%wx%@AE@%, %@AI@%wy%@AE@%                            Window-coordinate point

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_moveto%@AE@% functions move the current position to the specified point. The
%@AB@%_moveto%@AE@% function uses the view-coordinate point (%@AI@%x%@AE@%, %@AI@%y%@AE@%) as the current
position. The %@AB@%_moveto_w%@AE@% function uses the window-coordinate point (%@AI@%wx%@AE@%, %@AI@%wy%@AE@%)
as the current position. No drawing takes place.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the coordinates of the previous position. The %@AB@%_moveto%@AE@%
function returns the coordinates in an %@AB@%xycoord%@AE@% structure. The %@AB@%xycoord%@AE@%
structure, defined in GRAPH.H, contains the following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%short xcoord%@AE@%                      %@AI@%x%@AE@% coordinate

%@AB@%short ycoord%@AE@%                      %@AI@%y%@AE@% coordinate

The %@AB@%_moveto_w%@AE@% function returns the coordinates in an %@AB@%_wxycoord%@AE@% structure,
defined in GRAPH.H. The %@AB@%_wxycoord%@AE@% structure contains the following elements:
%@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%double wx%@AE@%                         %@AI@%x%@AE@% window coordinate

%@AB@%double wy%@AE@%                         %@AI@%y%@AE@% window coordinate

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS    OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_lineto%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MOVETO.C: This program draws line segments of different colors. */
%@AS@%  
%@AS@%  #include <graph.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <conio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short x, y, xinc, yinc, color = 1;
%@AS@%     struct videoconfig v;
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXCOLORMODE ) )
%@AS@%        exit( 1 );
%@AS@%     _getvideoconfig( &v );
%@AS@%     xinc = v.numxpixels / 50;
%@AS@%     yinc = v.numypixels / 50;
%@AS@%  
%@AS@%     for( x = 0, y = v.numypixels - 1; x < v.numxpixels; x += xinc, y -=
%@AS@%yinc )
%@AS@%     {
%@AS@%        _setcolor( color++ % 16 );
%@AS@%        _moveto( x, 0 );
%@AS@%        _lineto( 0, y );
%@AS@%     }
%@AS@%     getch();
%@AS@%  
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_msize@%%@NL@%
%@2@%%@CR:C6A02151066 @%%@AB@%_msize Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02151067 @%%@CR:C6A02151068 @%%@CR:C6A02151069 @% %@CR:C6A02151070 @%%@CR:C6A02151071 @% %@CR:C6A02151072 @%%@CR:C6A02151073 @% %@CR:C6A02151074 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Return the size of a memory block allocated in the heap.  %@NL@%
%@NL@%
%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  size_t  _msize( void *memblock );%@AE@%%@NL@%
%@NL@%
%@AS@%  size_t _bmsize( _segment seg, void _based( void ) *memblock );%@AE@%%@NL@%
%@NL@%
%@AS@%  size_t _fmsize( void _far *memblock );%@AE@%%@NL@%
%@NL@%
%@AS@%  size_t _nmsize( void _near *memblock );%@AE@%%@NL@%
%@NL@%
%@AI@%memblock%@AE@%                          Pointer to memory block 

%@AI@%seg%@AE@%                               Based-heap segment selector

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_msize%@AE@% family of functions returns the size, in bytes, of the memory
block allocated by a call to the appropriate version of the %@AB@%calloc%@AE@%, %@AB@%malloc%@AE@%,
or %@AB@%realloc%@AE@% functions.  %@NL@%
%@NL@%
In large data models (compact-, large-, and huge-model programs), %@AB@%_msize%@AE@%
maps to %@AB@%_fmsize%@AE@%. In small data models (tiny-, small-, and medium-model
programs), %@AB@%_msize%@AE@% maps to %@AB@%_nmsize%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_nmsize%@AE@% function returns the size (in bytes) of the memory block
allocated by a call to %@AB@%_nmalloc%@AE@%, and the %@AB@%_fmsize%@AE@% function returns the size
(in bytes) of the memory block allocated by a call to %@AB@%_fmalloc%@AE@% or %@AB@%_frealloc%@AE@%.
The %@AB@%_bmsize%@AE@% function returns the size of a block allocated in segment %@AI@%seg%@AE@% by
a call to %@AB@%_bmalloc%@AE@%, %@AB@%_bcalloc%@AE@%, or %@AB@%_brealloc%@AE@%.  %@NL@%
%@NL@%
The location of the memory block is indicated below:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Data Segment%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_msize%@AE@%                            Depends on data model of program

%@AB@%_bmsize%@AE@%                           Based heap segment specified by %@AI@%seg%@AE@% 
                                  value

%@AB@%_fmsize%@AE@%                           Far heap segment (outside default data 
                                  segment)

%@AB@%_nmsize%@AE@%                           Default data segment (inside near heap)

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
All four functions return the size (in bytes) as an unsigned integer.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   %@AB@%%@AE@% DOS   %@AB@%%@AE@% OS/2    UNIX    XENIX %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%calloc%@AE@% functions,  %@AB@%_expand%@AE@% functions, %@AB@%malloc%@AE@% functions, %@AB@%realloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* REALLOC.C: This program allocates a block of memory for buffer
%@AS@%   * and then uses _msize to display the size of that block. Next, it
%@AS@%   * uses realloc to expand the amount of memory used by buffer
%@AS@%   * and then calls _msize again to display the new amount of
%@AS@%   * memory allocated to buffer.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     long *buffer;
%@AS@%     size_t size;
%@AS@%  
%@AS@%     if( (buffer = (long *)malloc( 1000 * sizeof( long ) )) == NULL )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     size = _msize( buffer );
%@AS@%     printf( "Size of block after malloc of 1000 longs: %u\n", size );
%@AS@%  
%@AS@%     /* Reallocate and show new size: */
%@AS@%     if( (buffer = realloc( buffer, size + (1000 * sizeof( long )) )) ==
%@AS@%NULL )
%@AS@%        exit( 1 );
%@AS@%     size = _msize( buffer );
%@AS@%     printf( "Size of block after realloc of 1000 more longs: %u\n", size );
%@AS@%  
%@AS@%     free( buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Size of block after malloc of 1000 longs: 4000
%@AS@%  Size of block after realloc of 1000 more longs: 8000 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:onexit@%%@NL@%
%@2@%%@CR:C6A02161075 @%%@AB@%onexit%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02161076 @%%@CR:C6A02161077 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Registers a routine to be called at exit time.  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  onexit_t onexit( onexit_t func );%@AE@%%@NL@%
%@NL@%
%@AI@%func%@AE@%                              Pointer to function to be called at exit

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%onexit%@AE@% function is passed the address of a function (%@AI@%func%@AE@%) to be called
when the program terminates normally. Successive calls to %@AB@%onexit%@AE@% create a
register of functions that is executed in LIFO (last-in-first-out) order. No
more than 32 functions can be registered with %@AB@%onexit%@AE@%; %@AB@%onexit%@AE@% returns the
value%@AB@% NULL%@AE@% if the number of functions exceeds 32. The functions passed to
%@AB@%onexit%@AE@% cannot take parameters.  %@NL@%
%@NL@%
The %@AB@%onexit%@AE@% function is not part of the ANSI definition, but is instead a
Microsoft extension. The ANSI-standard %@AB@%atexit %@AE@%function does the same thing
as%@AB@% onexit%@AE@%, and should be used instead of %@AB@%onexit %@AE@%when ANSI portability is
desired.  %@NL@%
%@NL@%
All routines passed to %@AB@%onexit%@AE@% should have the %@AB@%_loadds%@AE@% attribute if used in
multithread dynamic-link libraries.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%onexit%@AE@% function returns a pointer to the function if successful and
returns %@AB@%NULL%@AE@% if there is no space left to store the function pointer.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%exit%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ONEXIT.C */
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  /* Prototypes */
%@AS@%  void fn1( void ), fn2( void ), fn3( void ),  fn4( void );%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     onexit( fn1 );
%@AS@%     onexit( fn2 );
%@AS@%     onexit( fn3 );
%@AS@%     onexit( fn4 );
%@AS@%     printf( "This is executed first.\n" );
%@AS@%  }
%@AS@%  
%@AS@%  void fn1()
%@AS@%  {
%@AS@%     printf( "next.\n" );
%@AS@%  }
%@AS@%  
%@AS@%  void fn2()
%@AS@%  {
%@AS@%     printf( "executed " );
%@AS@%  }
%@AS@%  
%@AS@%  void fn3()
%@AS@%  {
%@AS@%     printf( "is " );
%@AS@%  }
%@AS@%  
%@AS@%  void fn4()
%@AS@%  {
%@AS@%     printf( "This " );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  This is executed first.
%@AS@%  This is executed next. %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:open@%%@NL@%
%@2@%%@CR:C6A02171078 @%%@AB@%open%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02171079 @%%@CR:C6A02171080 @%%@CR:C6A02171081 @% %@CR:C6A02171082 @%%@CR:C6A02171083 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Opens a file.  %@NL@%
%@NL@%
%@AB@%#include <fcntl.h>%@AE@%                

%@AB@%#include <sys\types.h>%@AE@%            

%@AB@%#include <sys\stat.h>%@AE@%             

%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  int open( char *filename, int oflag [[, int pmode]] );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          File name

%@AI@%oflag%@AE@%                             Type of operations allowed

%@AI@%pmode%@AE@%                             Permission mode

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%open%@AE@% function opens the file specified by %@AI@%filename%@AE@% and prepares the file
for subsequent reading or writing, as defined by %@AI@%oflag%@AE@%. The %@AI@%oflag%@AE@% argument
is an integer expression formed from one or more of the manifest constants
defined in FCNTL.H (listed below). When two or more manifest constants are
used to form the %@AI@%oflag%@AE@% argument, the constants are combined with the
bitwise-OR operator ( | ). See Section 2.5, "File Handling," for a
discussion of binary and text modes.  %@NL@%
%@NL@%
The FCNTL.H file defines the following manifest constants:%@CR:C6A02171084 @%%@CR:C6A02171085 @%%@CR:C6A02171086 @%%@CR:C6A02171087 @%%@CR:C6A02171088 @%  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%O_APPEND%@AE@%                          Repositions the file pointer to the end 
                                  of the file before every write 
                                  operation.

%@AB@%O_BINARY%@AE@%                          Opens file in binary (untranslated) 
                                  mode.

%@AB@%O_CREAT%@AE@%                           Creates and opens a new file for 
                                  writing; this has no effect if the file 
                                  specified by %@AI@%filename%@AE@% exists.

%@AB@%O_EXCL%@AE@%                            Returns an error value if the file 
                                  specified by %@AI@%filename%@AE@% exists. Only 
                                  applies when used with %@AB@%O_CREAT%@AE@%.

%@AB@%O_RDONLY%@AE@%                          Opens file for reading only; if this 
                                  flag is given, neither %@AB@%O_RDWR%@AE@% nor %@AB@%%@AE@%
                                  %@AB@%O_WRONLY%@AE@% can be given.

%@AB@%O_RDWR%@AE@%                            Opens file for both reading and writing;
                                  if this flag is given, neither %@AB@%O_RDONLY%@AE@% 
                                  nor%@AB@% O_WRONLY%@AE@% can be given.

%@AB@%O_TEXT%@AE@%                            Opens file in text (translated) mode.

%@AB@%O_TRUNC%@AE@%                           Opens and truncates an existing file to 
                                  zero length; the file must have write 
                                  permission. The contents of the file are
                                  destroyed. If this flag is given, you 
                                  cannot specify %@AB@%O_RDONLY%@AE@%.

%@AB@%O_WRONLY%@AE@%                          Opens file for writing only; if this 
                                  flag is given, neither %@AB@%O_RDONLY%@AE@% nor %@AB@%%@AE@%
                                  %@AB@%O_RDWR%@AE@% can be given.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
%@AU@%WARNING%@AE@%%@NL@%
%@NL@%
%@AI@%Use the O_TRUNC flag with care, as it destroys the complete contents of an
%@AI@%existing file.%@AE@%%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
%@NL@%
Either %@AB@%O_RDONLY%@AE@%, %@AB@%O_RDWR%@AE@%, or%@AB@% O_WRONLY%@AE@% must be given to specify the access
mode. There is no default value for the access mode.  %@NL@%
%@NL@%
The %@AI@%pmode%@AE@% argument is required only when %@AB@%O_CREAT%@AE@% is specified. If the file
exists, %@AI@%pmode%@AE@% is ignored. Otherwise, %@AI@%pmode%@AE@% specifies the file's permission
settings, which are set when the new file is closed for the first time. The
%@AI@%pmode%@AE@% is an integer expression containing one or both of the manifest
constants %@AB@%S_IWRITE%@AE@% and %@AB@%S_IREAD%@AE@%, defined in SYS\STAT.H. When both constants
are given, they are joined with the bitwise-OR operator ( | ). The meaning
of the %@AI@%pmode%@AE@% argument is as follows:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%S_IWRITE%@AE@%                          Writing permitted

%@AB@%S_IREAD%@AE@%                           Reading permitted

%@AB@%S_IREAD |  S_IWRITE%@AE@%               Reading and writing permitted

If write permission is not given, the file is read-only. Under DOS and OS/2,
all files are readable; it is not possible to give write-only permission.
Thus the modes %@AB@%S_IWRITE%@AE@% and %@AB@%S_IREAD | S_IWRITE%@AE@% are equivalent.  %@NL@%
%@NL@%
The %@AB@%open%@AE@% function applies the current file-permission mask to %@AI@%pmode%@AE@% before
setting the permissions (see %@AB@%umask%@AE@%).  %@NL@%
%@NL@%
The %@AI@%filename%@AE@% argument used in the %@AB@%open%@AE@% function is affected by the DOS
APPEND command.  %@NL@%
%@NL@%
Note that under DOS versions 3.0 and later, a problem occurs when %@AB@%SHARE%@AE@% is
installed and a new file is opened with %@AI@%oflag%@AE@% set to %@AB@%O_CREAT%@AE@% | %@AB@%O_RDONLY%@AE@% or%@AB@%
%@AB@%O_CREAT%@AE@% | %@AB@%O _WRONLY%@AE@% and %@AI@%pmode%@AE@% set to %@AB@%S_IREAD%@AE@%. Under these conditions, the
operating system prematurely closes the file during system calls made within
%@AB@%open%@AE@%. This problem does not occur under OS/2.  %@NL@%
%@NL@%
To work around the problem, open the file with the %@AI@%pmode%@AE@% argument set to
%@AB@%S_IWRITE%@AE@%. Then close the file and use %@AB@%chmod%@AE@% to change the access mode back
to %@AB@%S_IREAD%@AE@%. Another work-around is to open the file with %@AI@%pmode%@AE@% set to
%@AB@%S_IREAD%@AE@% and %@AI@%oflag%@AE@% set to %@AB@%O_CREAT%@AE@% | %@AB@%O_RDWR%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%open%@AE@% function returns a file handle for the opened file. A return value
of -1 indicates an error, and %@AB@%errno%@AE@% is set to one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Given path name is a directory; or an 
                                  attempt was made to open a read-only 
                                  file for writing; or a sharing violation
                                  occurred (the file's sharing mode does 
                                  not allow the specified operations).

%@AB@%EEXIST%@AE@%                            The %@AB@%O_CREAT%@AE@% and %@AB@%O_EXCL%@AE@% flags are 
                                  specified, but the named file already 
                                  exists.

%@AB@%EINVAL%@AE@%                            An invalid %@AI@%oflag%@AE@% or %@AI@%pmode%@AE@% argument was 
                                  given.

%@AB@%EMFILE%@AE@%                            No more file handles available (too many
                                  open files).

%@AB@%ENOENT%@AE@%                            File or path name not found.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%access%@AE@%, %@AB@%chmod%@AE@%, %@AB@%close%@AE@%, %@AB@%creat%@AE@%, %@AB@%dup%@AE@%, %@AB@%dup2%@AE@%, %@AB@%fopen%@AE@%, %@AB@%sopen%@AE@%, %@AB@%umask%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* OPEN.C: This program uses open to open a file named OPEN.C for input
%@AS@%   * and a file named OPEN.OUT for output. The files are then closed.
%@AS@%   */
%@AS@%  
%@AS@%  #include <fcntl.h>
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  #include <io.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh1, fh2;%@AE@%%@NL@%
%@NL@%
%@AS@%  fh1 = open( "OPEN.C", O_RDONLY );
%@AS@%     if( fh1 == -1 )
%@AS@%        perror( "open failed on input file" );
%@AS@%     else
%@AS@%     {
%@AS@%        printf( "open succeeded on input file\n" );
%@AS@%        close( fh1 );
%@AS@%     }
%@AS@%  
%@AS@%     fh2 = open( "OPEN.OUT", O_WRONLY | O_CREAT, S_IREAD | S_IWRITE );
%@AS@%     if( fh2 == -1 )
%@AS@%        perror( "open failed on output file" );
%@AS@%     else
%@AS@%     {
%@AS@%        printf( "open succeeded on output file\n" );
%@AS@%        close( fh2 );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  open succeeded on input file
%@AS@%  open succeeded on output file%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_outgtext@%%@NL@%
%@2@%%@CR:C6A02181089 @%%@AB@%_outgtext%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02181090 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Prints font-based text in graphics mode.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far_outgtext( unsigned char_far *text );%@AE@%%@NL@%
%@NL@%
%@AI@%text%@AE@%                              Text string to output

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_outgtext%@AE@% function outputs on the screen the null-terminated string that
%@AI@%text%@AE@% points to. The text is output using the current font at the current
graphics position and in the current color.  %@NL@%
%@NL@%
No formatting is provided, in contrast to the standard console I/O library
routines such as %@AB@%printf%@AE@%.  %@NL@%
%@NL@%
After it outputs the text, %@AB@%_outgtext%@AE@% updates the current graphics position.
%@NL@%
%@NL@%
The %@AB@%_outgtext%@AE@% function operates only in graphics video modes (e.g.,
%@AB@%_MRES4COLOR%@AE@%). Because it is a graphics function, the color of text is set by
the %@AB@%_setcolor%@AE@% function, not by the %@AB@%_settextcolor%@AE@% function.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_moveto%@AE@% functions,  %@AB@%_setcolor%@AE@%, %@AB@% _setfont%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* OUTGTXT.C illustrates font output using functions:
%@AS@%   *   _registerfonts        _setfont            _outgtext
%@AS@%   *   _unregisterfonts      _getfontinfo        _getgtextextent
%@AS@%   *   _setgtextvector
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <string.h>
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #define NFONTS 6
%@AS@%  
%@AS@%  unsigned char *face[NFONTS] =
%@AS@%  {
%@AS@%      "Courier", "Helvetica", "Times Roman", "Modern", "Script", "Roman"
%@AS@%  };
%@AS@%  unsigned char *options[NFONTS] =
%@AS@%  {
%@AS@%      "courier", "helv", "tms rmn", "modern", "script", "roman"
%@AS@%  };
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%      unsigned char list[20];
%@AS@%      char fondir[_MAX_PATH];
%@AS@%      struct videoconfig vc;
%@AS@%      struct _fontinfo fi;
%@AS@%      short fontnum, x, y;
%@AS@%  
%@AS@%      /* Read header info from all .FON files in current or given directory.
%@AS@%*/
%@AS@%      if( _registerfonts( "*.FON" ) <= 0 )
%@AS@%      {
%@AS@%          _outtext( "Enter full path where .FON files are located: " );
%@AS@%          gets( fondir );
%@AS@%          strcat( fondir, "\\*.FON" );
%@AS@%          if( _registerfonts( fondir ) <= 0 )
%@AS@%          {
%@AS@%              _outtext( "Error: can't register fonts" );
%@AS@%              exit( 1 );
%@AS@%          }
%@AS@%      }
%@AS@%  
%@AS@%      /* Set highest available graphics mode and get configuration. */
%@AS@%      if( !_setvideomode( _MAXRESMODE ) )
%@AS@%          exit( 1 );
%@AS@%      _getvideoconfig( &vc );
%@AS@%  
%@AS@%      /* Display each font name centered on screen. */
%@AS@%      for( fontnum = 0; fontnum < NFONTS; fontnum++ )
%@AS@%      {
%@AS@%          /* Build options string. */
%@AS@%          strcat( strcat( strcpy( list, "t'" ), options[fontnum] ), "'");
%@AS@%          strcat( list, "h30w24b" );
%@AS@%  
%@AS@%          _clearscreen( _GCLEARSCREEN );
%@AS@%          if( _setfont( list ) >= 0 )
%@AS@%          {%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Use length of text and height of font to center text. */
%@AS@%              x = (vc.numxpixels / 2) - (_getgtextextent( face[fontnum] ) /
%@AS@%2);
%@AS@%              y = (vc.numypixels / 2) + (_getgtextextent( face[fontnum] ) /
%@AS@%2);
%@AS@%              if( _getfontinfo( &fi ) )
%@AS@%              {
%@AS@%                  _outtext( "Error: Can't get font information" );
%@AS@%                  break;
%@AS@%              }
%@AS@%              _moveto( x, y );
%@AS@%              if( vc.numcolors > 2 )
%@AS@%                  _setcolor( fontnum + 2 );
%@AS@%  
%@AS@%              /* Rotate and display text. */
%@AS@%              _setgtextvector( 1, 0 );
%@AS@%              _outgtext( face[fontnum] );
%@AS@%              _setgtextvector( 0, 1 );
%@AS@%              _outgtext( face[fontnum] );
%@AS@%              _setgtextvector( -1, 0 );
%@AS@%              _outgtext( face[fontnum] );
%@AS@%              _setgtextvector( 0, -1 );
%@AS@%              _outgtext( face[fontnum] );
%@AS@%          }
%@AS@%          else
%@AS@%          {
%@AS@%              _outtext( "Error: Can't set font: " );
%@AS@%              _outtext( list );
%@AS@%          }
%@AS@%          getch();
%@AS@%      }
%@AS@%      _unregisterfonts();
%@AS@%      _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_outmem@%%@NL@%
%@2@%%@CR:C6A02191091 @%%@AB@%_outmem%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02191092 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Prints text of a specified length in graphics mode.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far_outmem( unsigned char_far *text, short length );%@AE@%%@NL@%
%@NL@%
%@AI@%text%@AE@%                              Text string to output

%@AI@%length%@AE@%                            Length of string to output

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_outmem%@AE@% function outputs the string that %@AI@%text%@AE@% points to. The %@AI@%length%@AE@%
argument specifies the number of characters to output.  %@NL@%
%@NL@%
Unlike %@AB@%_outtext%@AE@%, the %@AB@%_outmem%@AE@% function prints all characters literally,
including ASCII 10, 13, and 0 as the equivalent graphics characters. No
formatting is provided. Text is printed using the current text color,
starting at the current text position.  %@NL@%
%@NL@%
To output text using special fonts, you must use the %@AB@%_outgtext%@AE@% function.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_outtext%@AE@%,  %@AB@%_settextcolor%@AE@%,  %@AB@%_settextposition%@AE@%,  %@AB@%_settextwindow%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* OUTMEM.C illustrates:
%@AS@%   *    _outmem
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%      int  i, len;
%@AS@%      char tmp[10];%@AE@%%@NL@%
%@NL@%
%@AS@%  _clearscreen( _GCLEARSCREEN );
%@AS@%      for( i = 0; i < 256; i++ )
%@AS@%      {
%@AS@%          _settextposition( (i % 24) + 1, (i / 24) * 7 );
%@AS@%          len = sprintf( tmp, "%3d %c", i, i );
%@AS@%          _outmem( tmp, len );
%@AS@%      }
%@AS@%      _settextposition( 24, 1 );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:outp@%%@QR:outpw@%%@NL@%
%@2@%%@CR:C6A02201093 @%%@AB@%outp, outpw%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02201094 @%%@CR:C6A02201095 @% %@CR:C6A02201096 @%%@CR:C6A02201097 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Outputs a byte (%@AB@%outp%@AE@%) or a word (%@AB@%outpw%@AE@%) at a port.  %@NL@%
%@NL@%
%@AS@%  #include <conio.h>    Required only for function declarations%@AE@%%@NL@%
%@NL@%
%@AS@%  int outp( unsigned port, int databyte );%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned outpw( unsigned port, unsigned dataword );%@AE@%%@NL@%
%@NL@%
%@AI@%port%@AE@%                              Port number

%@AI@%databyte%@AE@%                          Output value

%@AI@%dataword%@AE@%                          Output value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%outp%@AE@% and %@AB@%outpw%@AE@% functions write a byte and a word, respectively, to the
specified output port. The %@AI@%port%@AE@% argument can be any unsigned integer in the
range 0 - 65,535; %@AI@%byte%@AE@%  can be any integer in the range 0 - 255; and
%@AI@%dataword%@AE@% can be any value in the range 0 - 65,535.  %@NL@%
%@NL@%
Both %@AB@%outp%@AE@% and %@AB@%outpw%@AE@% are supported in OS/2. You must use a .DEF file to
declare the IOSEG segment the run-time library uses to perform input/output
on the port. In addition, the intrinsic (/Oi) versions of these functions do
not work unless you put the code in a segment that is marked with the %@AB@%IOPL%@AE@%
keyword in the .DEF file.  %@NL@%
%@NL@%
You cannot do IOPL from a regular code segment, so the run-time library has
declared a separate code segment called %@AB@%_IOSEG%@AE@%. In order to use %@AB@%inp%@AE@%, %@AB@%inpw%@AE@%,
%@AB@%outp%@AE@%, or %@AB@%outp%@AE@% in any of the protected mode run-time libraries (?LIBCP,
LLIBCDLL, LLIBCMT, or CDLLOBJS-based DLL), you must have a .DEF file with
this line in it:  %@NL@%
%@NL@%
%@AS@%  SEGMENTS _IOSEG CLASS 'IOSEG_CODE' IOPL%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The functions return the data output. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%inp%@AE@%, %@AB@%inpw%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* OUTP.C: This program uses inp and outp to make sound of variable tone
%@AS@%   * and duration.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <time.h>
%@AS@%  
%@AS@%  void Beep( unsigned duration, unsigned frequency ); /* Prototypes */
%@AS@%  void Sleep( clock_t wait );
%@AS@%  
%@AS@%  void main ()
%@AS@%  {
%@AS@%      Beep( 698, 700 );
%@AS@%      Beep( 523, 500 );
%@AS@%  }
%@AS@%  
%@AS@%  /* Sounds the speaker for a time specified in microseconds by duration
%@AS@%   * at a pitch specified in hertz by frequency.
%@AS@%   */
%@AS@%  void Beep( unsigned frequency, unsigned duration )
%@AS@%  {
%@AS@%      int control;
%@AS@%  
%@AS@%      /* If frequency is 0, Beep doesn't try to make a sound. */
%@AS@%      if( frequency )
%@AS@%      {
%@AS@%          /* 75 is about the shortest reliable duration of a sound. */
%@AS@%          if( duration < 75 )
%@AS@%              duration = 75;
%@AS@%  
%@AS@%          /* Prepare timer by sending 10111100 to port 43. */
%@AS@%          outp( 0x43, 0xb6 );
%@AS@%  
%@AS@%          /* Divide input frequency by timer ticks per second and
%@AS@%           * write (byte by byte) to timer.
%@AS@%           */
%@AS@%          frequency = (unsigned)(1193180L / frequency);
%@AS@%          outp( 0x42, (char)frequency );
%@AS@%          outp( 0x42, (char)(frequency >> 8) );
%@AS@%  
%@AS@%          /* Save speaker control byte. */
%@AS@%          control = inp( 0x61 );
%@AS@%  
%@AS@%          /* Turn on the speaker (with bits 0 and 1). */
%@AS@%          outp( 0x61, control | 0x3 );
%@AS@%      }
%@AS@%  
%@AS@%      Sleep( (clock_t)duration );
%@AS@%  
%@AS@%      /* Turn speaker back on if necessary. */
%@AS@%      if( frequency )
%@AS@%          outp( 0x61, control );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Pauses for a specified number of microseconds. */
%@AS@%  void Sleep( clock_t wait )
%@AS@%  {
%@AS@%      clock_t goal;
%@AS@%  
%@AS@%      goal = wait + clock();
%@AS@%      while( goal > clock() )
%@AS@%          ;
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_outtext@%%@NL@%
%@2@%%@CR:C6A02211098 @%%@AB@%_outtext%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02211099 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Prints text in graphics mode.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _outtext( unsigned char _far *text );%@AE@%%@NL@%
%@NL@%
%@AI@%text%@AE@%                              Text string to output

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_outtext%@AE@% function outputs the null-terminated string that %@AI@%text%@AE@% points
to. No formatting is provided, in contrast to the standard console I/O
library routines such as %@AB@%printf%@AE@%. This function will work in any screen mode.
%@NL@%
%@NL@%
Text output begins at the current text position.  %@NL@%
%@NL@%
To output text using special fonts, you must use the %@AB@%_outgtext%@AE@% function.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_outmem%@AE@%, %@AB@%_settextcolor%@AE@%, %@AB@%_settextposition%@AE@%, %@AB@%_settextwindow%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* OUTTXT.C: This example illustrates text output functions:
%@AS@%   *    _gettextcolor   _getbkcolor   _gettextposition   _outtext
%@AS@%   *    _settextcolor   _setbkcolor   _settextposition
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  char buffer [80];
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%  
%@AS@%     /* Save original foreground, background, and text position */
%@AS@%     short blink, fgd, oldfgd;
%@AS@%     long  bgd, oldbgd;
%@AS@%     struct rccoord oldpos;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Save original foreground, background, and text position. */
%@AS@%     oldfgd = _gettextcolor();
%@AS@%     oldbgd = _getbkcolor();
%@AS@%     oldpos = _gettextposition();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%  
%@AS@%     /* First time no blink, second time blinking. */
%@AS@%     for( blink = 0; blink <= 16; blink += 16 )
%@AS@%     {
%@AS@%        /* Loop through 8 background colors. */
%@AS@%        for( bgd = 0; bgd < 8; bgd++ )
%@AS@%        {
%@AS@%           _setbkcolor( bgd );
%@AS@%           _settextposition( (short)bgd + ((blink / 16) * 9) + 3, 1 );
%@AS@%           _settextcolor( 7 );
%@AS@%           sprintf(buffer, "Back: %d Fore:", bgd );
%@AS@%           _outtext( buffer );
%@AS@%  
%@AS@%           /* Loop through 16 foreground colors. */
%@AS@%           for( fgd = 0; fgd < 16; fgd++ )
%@AS@%           {
%@AS@%              _settextcolor( fgd + blink );
%@AS@%              sprintf( buffer, " %2d ", fgd + blink );
%@AS@%              _outtext( buffer );
%@AS@%           }
%@AS@%        }
%@AS@%     }
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Restore original foreground, background, and text position. */
%@AS@%     _settextcolor( oldfgd );
%@AS@%     _setbkcolor( oldbgd );
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%     _settextposition( oldpos.row, oldpos.col );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pclose@%%@NL@%
%@2@%%@CR:C6A02221100 @%%@AB@%_pclose%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02221101 @%%@CR:C6A02221102 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Waits for a child command and closes the stream on the associated pipe.  %@NL@%
%@NL@%
%@AB@%#include <stdio.h>%@AE@%                Function declaration

%@AS@%  int _pclose( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            File stream returned by previous call to
                                  %@AB@%_popen%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pclose%@AE@% function waits for a child command and closes the stream on the
associated pipe. The argument %@AI@%stream%@AE@% is the return value from a previous
call to %@AB@%_popen%@AE@%. The %@AB@%_pclose%@AE@% function looks up the process ID of the child
command started by the associated %@AB@%_popen%@AE@% call, closes the stream, executes a
%@AB@%cwait%@AE@% call on the child command, and returns the exit status of the child
command. See %@AB@%_pipe%@AE@% for a general discussion of pipes in OS/2.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pclose%@AE@% function returns the exit status of the child command. The
format of the return value is the same as that for %@AB@%cwait%@AE@%, with the exception
that the low-order and high-order bytes are swapped. If an error occurs, -1
is returned.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIXA similar function (%@AB@%pclose%@AE@%) is
available in the XENIX and UNIX operating environments.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cwait%@AE@%,  %@AB@%_pipe%@AE@%,  %@AB@%_popen%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_popen%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:perror@%%@NL@%
%@2@%%@CR:C6A02231103 @%%@AB@%perror%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02231104 @%%@CR:C6A02231105 @% %@CR:C6A02231106 @%%@CR:C6A02231107 @% %@CR:C6A02231108 @%%@CR:C6A02231109 @% %@CR:C6A02231110 @%%@CR:C6A02231111 @%%@CR:C6A02231112 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Prints an error message.  %@NL@%
%@NL@%
%@AB@%#include <stdio.h>%@AE@%                Required only for function declarations

%@AS@%  void perror( const char *string );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            String message to print

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%perror%@AE@% function prints an error message to %@AB@%stderr%@AE@%. The %@AI@%string%@AE@% argument
is printed first, followed by a colon, then by the system error message for
the last library call that produced the error, and finally by a newline
character. If %@AI@%string%@AE@% is a null pointer or a pointer to a null string, %@AB@%perror%@AE@%
prints only the system error message.  %@NL@%
%@NL@%
The actual error number is stored in the variable %@AB@%errno%@AE@% (defined in
ERRNO.H). The system error messages are accessed through the variable
%@AB@%sys_errlist%@AE@%, which is an array of messages ordered by error number. The
%@AB@%perror%@AE@% function prints the appropriate error message by using the %@AB@%errno%@AE@%
value as an index to %@AB@%sys_errlist%@AE@%. The value of the variable %@AB@%sys_nerr%@AE@% is
defined as the maximum number of elements in the %@AB@%sys_errlist%@AE@% array.  %@NL@%
%@NL@%
To produce accurate results, %@AB@%perror%@AE@% should be called immediately after a
library routine returns with an error. Otherwise, the %@AB@%errno%@AE@% value may be
overwritten by subsequent calls.  %@NL@%
%@NL@%
Under DOS and OS/2, some of the %@AB@%errno %@AE@%values listed in ERRNO.H are not used.
These additional %@AB@%errno%@AE@% values are reserved for UNIX and XENIX use. See
Section 3.3, "%@AB@%_doserrno%@AE@%, %@AB@%errno%@AE@%, %@AB@%sys_errlist%@AE@%, %@AB@%sys_nerr%@AE@%," for a list of%@AB@% errno
%@AB@%%@AE@%values used on DOS and OS/2 and the corresponding error messages. The %@AB@%perror%@AE@%
function prints an empty string for any %@AB@%errno%@AE@% value not used under the
operating system.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%clearerr%@AE@%, %@AB@%ferror%@AE@%, %@AB@%strerror%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PERROR.C: This program attempts to open a file named NOSUCHF.ILE.
%@AS@%   * Since this file probably doesn't exist, an error message is displayed.
%@AS@%   * The same message is created using perror, strerror, and _strerror.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <fcntl.h>
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  #include <io.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <string.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int  fh;
%@AS@%  
%@AS@%     if( (fh = open( "NOSUCHF.ILE", O_RDONLY )) == -1 )
%@AS@%     {
%@AS@%        /* Three ways to create error message: */
%@AS@%        perror( "perror says open failed" );
%@AS@%        printf( "strerror says open failed: %s\n", strerror( errno ) );
%@AS@%        printf( _strerror( "_strerror says open failed" ) );
%@AS@%     }
%@AS@%     else
%@AS@%     {
%@AS@%        printf( "open succeeded on input file\n" );
%@AS@%        close( fh );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  perror says open failed: No such file or directory
%@AS@%  strerror says open failed: No such file or directory
%@AS@%  _strerror says open failed: No such file or directory %@AE@%%@NL@%
%@NL@%
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_analyzechart@%%@NL@%
%@2@%%@CR:C6A02241113 @%%@AB@%_pg_analyzechart Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02241114 @% %@CR:C6A02241115 @%%@CR:C6A02241116 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Analyze a series of data.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_analyzechart( chartenv _far *env, char _far * _far
%@AS@%  *categories, 
%@AS@%  float _far *values, short n );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_analyzechartms( chartenv _far *env, char _far * _far
%@AS@%  *categories, 
%@AS@%  float _far *values, short nseries, short n, short arraydim, 
%@AS@%  char _far * _far *serieslabels );%@AE@%%@NL@%
%@NL@%
%@AI@%env%@AE@%                               Chart environment variable

%@AI@%categories%@AE@%                        Array of category variables

%@AI@%values%@AE@%                            Array of data values

%@AI@%nseries%@AE@%                           Number of series to chart

%@AI@%n%@AE@%                                 Number of data values to chart

%@AI@%arraydim%@AE@%                          Row dimension of data array

%@AI@%serieslabels%@AE@%                      Array of labels for series

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_analyzechart%@AE@% routines analyze a single or multiple series of data
without actually displaying the presentation-graphic image.  %@NL@%
%@NL@%
The %@AB@%_pg_analyzechart%@AE@% function fills the chart environment with default
values for a single-series bar, column, or line chart, depending on the type
specified by the call to the %@AB@%_pg_defaultchart%@AE@% function. The variables
calculated by %@AB@%_pg_analyzechart%@AE@% reflect the data given in the arguments
%@AI@%categories%@AE@% and %@AI@%values%@AE@%. All arguments are the same as those used with the
%@AB@%_pg_chart%@AE@% function.  %@NL@%
%@NL@%
The %@AB@%_pg_analyzechartms%@AE@% function fills the chart environment with default
values for a multiseries bar, column, or line chart, depending on which type
is specified in the %@AB@%_pg_defaultchart%@AE@% function. The variables calculated by
%@AB@%_pg_analyzechartms%@AE@% reflect the data given in the arguments %@AI@%categories%@AE@% and
%@AI@%values%@AE@%. All arguments are the same as those used with the %@AB@%_pg_chartms%@AE@%
function.  %@NL@%
%@NL@%
Boolean flags in the chart environment, such as %@AB@%AUTOSCALE%@AE@% and %@AB@%LEGEND%@AE@%, should
be set to %@AB@%TRUE%@AE@% before calling either %@AB@%_pg_analyzechart%@AE@% function. This will
ensure that the function will calculate all defaults.  %@NL@%
%@NL@%
For a discussion of the chart environment and related topics, see Section
2.6.2, "Presentation-Graphics Functions."   %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_analyzechart%@AE@% and %@AB@%_pg_analyzechartms%@AE@% functions return 0 if there were
no errors. A nonzero value indicates a failure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_chart%@AE@% functions,  %@AB@%_pg_defaultchart%@AE@%,%@AB@%  _pg_initchart  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PGACHART.C: This example illustrates presentation-graphics
%@AS@%   * analyze functions.
%@AS@%   * The example uses
%@AS@%   *      _pg_analyzechartms
%@AS@%   * The same principles apply for
%@AS@%   *      _pg_analyzepie        _pg_analyzechart
%@AS@%   *      _pg_analyzescatter    _pg_analyzescatterms
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <string.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  #include <pgchart.h>
%@AS@%  
%@AS@%  #define FALSE  0
%@AS@%  #define TRUE   1
%@AS@%  
%@AS@%  /* Note data declared as a single-dimension array. The multiseries
%@AS@%   * chart functions expect only one dimension. See _pg_chartms
%@AS@%   * example for alternate method using multidimension array.
%@AS@%   */
%@AS@%  #define TEAMS  4
%@AS@%  #define MONTHS 3
%@AS@%  float _far values[TEAMS * MONTHS] = { .435,   .522,   .671,
%@AS@%                                        .533,   .431,   .590,
%@AS@%                                        .723,   .624,   .488,
%@AS@%                                        .329,   .226,   .401   };
%@AS@%  char _far *months[MONTHS] =         { "May",  "June", "July" };
%@AS@%  char _far *teams[TEAMS] = { "Reds", "Sox", "Cubs", "Mets" };
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     chartenv env;
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     _pg_initchart();                    /* Initialize chart system.   */
%@AS@%     /* Default multiseries bar chart */
%@AS@%     _pg_defaultchart( &env, _PG_BARCHART, _PG_PLAINBARS );
%@AS@%     strcpy( env.maintitle.title, "Little League Records - Default" );
%@AS@%     _pg_chartms( &env, months, values, TEAMS, MONTHS, MONTHS, teams );
%@AS@%     getch();
%@AS@%      _clearscreen( _GCLEARSCREEN );
%@AS@%  
%@AS@%     /* Analyze multiseries bar chart with autoscale. This sets all
%@AS@%      * default scale values. We want y axis values to be automatic.
%@AS@%      */
%@AS@%     _pg_defaultchart( &env, _PG_BARCHART, _PG_PLAINBARS );
%@AS@%     strcpy( env.maintitle.title, "Little League Records - Customized" );
%@AS@%     env.xaxis.autoscale = TRUE;
%@AS@%     _pg_analyzechartms( &env, months, values, TEAMS, MONTHS, MONTHS, teams
%@AS@%);
%@AS@%  
%@AS@%     /* Now customize some of the x axis values. Then draw the chart.  */
%@AS@%     env.xaxis.autoscale = FALSE;
%@AS@%     env.xaxis.scalemax = 1.0;           /* Make scale show 0.0 to 1.0.   */
%@AS@%     env.xaxis.ticinterval = 0.2;        /* Don't make scale too crowded. */
%@AS@%     env.xaxis.ticdecimals = 3;          /* Show three decimals.          */
%@AS@%     strcpy( env.xaxis.scaletitle.title, "Win/Loss Percentage" );
%@AS@%     _pg_chartms( &env, months, values, TEAMS, MONTHS, MONTHS, teams );
%@AS@%     getch();
%@AS@%  
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_analyzepie@%%@NL@%
%@2@%%@CR:C6A02251117 @%%@AB@%_pg_analyzepie%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02251118 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Analyzes a single series of data for a pie chart.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_analyzepie( chartenv _far *env, char _far * _far
%@AS@%  *categories, 
%@AS@%  float _far *values, short _far *explode, short n );%@AE@%%@NL@%
%@NL@%
%@AI@%env%@AE@%                               Chart environment variable

%@AI@%categories%@AE@%                        Array of category variables

%@AI@%values%@AE@%                            Array of data values

%@AI@%explode%@AE@%                           Array of explode flags

%@AI@%n%@AE@%                                 Number of data values to chart

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_analyzepie%@AE@% function analyzes a single series of data without
actually displaying the graphic image.  %@NL@%
%@NL@%
The %@AB@%_pg_analyzepie%@AE@% function fills the chart environment for a pie chart
using the data contained in the array %@AI@%values%@AE@%. All arguments are the same as
those used in the %@AB@%_pg_chartpie%@AE@% function.  %@NL@%
%@NL@%
For a discussion of the chart environment and related topics, see Section
2.6.2, "Presentation-Graphics Functions."   %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_analyzepie%@AE@% function returns 0 if there were no errors. A nonzero
value indicates a failure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_chartpie%@AE@%,%@AB@%  _pg_defaultchart%@AE@%,%@AB@%  _pg_initchart  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_analyzechart%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_analyzescatter@%%@NL@%
%@2@%%@CR:C6A02261119 @%%@AB@%_pg_analyzescatter Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02261120 @% %@CR:C6A02261121 @%%@CR:C6A02261122 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Analyze a series of data for a scatter chart.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_analyzescatter( chartenv _far *env, float _far *xvalues, 
%@AS@%  float _far *yvalues, short n );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_analyzescatterms( chartenv _far *env, float _far *xvalues, 
%@AS@%  float _far *yvalues, short nseries, short n, short rowdim, 
%@AS@%  char _far * _far *serieslabels );%@AE@%%@NL@%
%@NL@%
%@AI@%env%@AE@%                               Chart environment structure

%@AI@%xvalues%@AE@%                           Array of %@AI@%x%@AE@%-axis data values

%@AI@%yvalues%@AE@%                           Array of %@AI@%y%@AE@%-axis data values

%@AI@%n%@AE@%                                 Number of data values to chart

%@AI@%nseries%@AE@%                           Number of series to chart

%@AI@%rowdim%@AE@%                            Row dimension of data array

%@AI@%serieslabels%@AE@%                      Array of labels for series

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_analyzescatter%@AE@% set of routines analyzes a single or multiple series
of data without actually displaying the graphic image.  %@NL@%
%@NL@%
The %@AB@%_pg_analyzescatter%@AE@% function fills the chart environment for a
single-series scatter diagram. The variables calculated by this function
reflect the data given in the arguments %@AI@%xvalues%@AE@% and %@AI@%yvalues%@AE@%. All arguments
are the same as those used in the %@AB@%_pg_chartscatter%@AE@% function.  %@NL@%
%@NL@%
The %@AB@%_pg_analyzescatterms%@AE@% function fills the chart environment for a
multiseries scatter diagram. The variables calculated by
%@AB@%_pg_analyzescatterms%@AE@% reflect the data given in the arguments %@AI@%xvalues%@AE@% and
%@AI@%yvalues%@AE@%. All arguments are the same as those used in the function
%@AB@%_pg_chartscatterms%@AE@%.  %@NL@%
%@NL@%
Boolean flags in the chart environment, such as %@AB@%AUTOSCALE%@AE@% and %@AB@%LEGEND%@AE@%, should
be set to %@AB@%TRUE%@AE@% before calling %@AB@%_pg_analyzescatterms%@AE@%; this ensures that the
function will calculate all defaults.%@AB@%  %@AE@%%@NL@%
%@NL@%
For a discussion of the chart environment and related topics, see Section
2.6.2, "Presentation-Graphics Functions."   %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_analyzescatter%@AE@% and %@AB@%_pg_analyzescatterms%@AE@% functions return 0 if there
were no errors. A nonzero value indicates a failure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_chartscatter%@AE@% functions,%@AB@%  _pg_defaultchart%@AE@%,%@AB@%  _pg_initchart  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_analyzechart%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_chart@%%@NL@%
%@2@%%@CR:C6A02271123 @%%@AB@%_pg_chart Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02271124 @%%@CR:C6A02271125 @% %@CR:C6A02271126 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Display single-series or multiseries charts.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_chart( chartenv _far *env, char _far * _far *categories, 
%@AS@%  float _far *values, short n );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_chartms( chartenv _far *env, char _far * _far *categories, 
%@AS@%  float _far *values, short nseries, short n, short arraydim, 
%@AS@%  char _far * _far *serieslabels );%@AE@%%@NL@%
%@NL@%
%@AI@%env%@AE@%                               Chart environment variable

%@AI@%categories%@AE@%                        Array of category variables

%@AI@%values%@AE@%                            Array of data values

%@AI@%n%@AE@%                                 Number of data values to chart

%@AI@%nseries%@AE@%                           Number of series to chart

%@AI@%arraydim%@AE@%                          Row dimension of data array

%@AI@%serieslabels%@AE@%                      Array of labels for series

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_chart%@AE@% function displays a single-series bar, column, or line chart,
depending on the type specified in the chart environment variable (%@AI@%env%@AE@%).  %@NL@%
%@NL@%
The %@AB@%_pg_chartms%@AE@% function displays a multiseries bar, column, or line chart,
depending on the type specified in the chart environment. All the series
must contain the same number of data points, specified by the argument %@AI@%n%@AE@%.  %@NL@%
%@NL@%
The array %@AI@%values%@AE@% is a two-dimensional array containing all value data for
every series to be plotted on the chart. Each column of %@AI@%values%@AE@% represents a
single series. The parameter %@AI@%rowdim%@AE@% is the integer value used to dimension
rows in the array declaration for %@AI@%values%@AE@%.  %@NL@%
%@NL@%
For example, the following code fragment declares the identifier %@AS@% values %@AE@% to
be a twodimensional floating-point array with 20 rows and 10 columns:  %@NL@%
%@NL@%
%@AS@%  #define ARRAYDIM 20
%@AS@%  float values [ARRAYDIM][10];
%@AS@%  short rowdim = ARRAYDIM;%@AE@%%@NL@%
%@NL@%
Note that the number of columns in the %@AI@%values%@AE@% array cannot exceed 10, the
maximum number of data series on a single chart. Note also that %@AS@% rowdim %@AE@%
must be greater than or equal to the argument %@AI@%n%@AE@%, and the column dimension in
the array declaration must be greater than or equal to the argument %@AI@%nseries%@AE@%.
If %@AI@%n%@AE@% and %@AI@%nseries%@AE@% are set to values less than the full dimensional size of
the %@AI@%values%@AE@% array, only part of the data contained in %@AI@%values%@AE@% will be plotted.
%@NL@%
%@NL@%
The array %@AI@%serieslabels%@AE@% holds the labels used in the chart legend to identify
each series.  %@NL@%
%@NL@%
For a discussion of the chart environment and related topics, see Section
2.6.2, "Presentation-Graphics Functions."   %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_chart%@AE@% and %@AB@%_pg_chartms%@AE@% functions return 0 if there were no errors. A
nonzero value indicates a failure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_analyzechart%@AE@% functions,  %@AB@%_pg_defaultchart%@AE@%,%@AB@%  _pg_initchart%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PGCHART.C: This example illustrates presentation-graphics support
%@AS@%   * routines and single-series chart routines, including
%@AS@%   *    _pg_initchart   _pg_defaultchart   _pg_chart   _pg_chartpie
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  #include <string.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <pgchart.h>
%@AS@%  
%@AS@%  #define COUNTRIES 5
%@AS@%  float _far value[COUNTRIES] =    { 42.5,    14.3,    35.2,   21.3,   32.6
%@AS@%};
%@AS@%  char _far *category[COUNTRIES] = { "USSR",  "France","USA",  "UK",
%@AS@%"Other" };
%@AS@%  short _far explode[COUNTRIES] =  { 0,       1,        0,      1,     0
%@AS@%};
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     chartenv env;
%@AS@%     short mode = _VRES16COLOR;
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     _pg_initchart();                    /* Initialize chart system. */
%@AS@%  
%@AS@%     /* Single-series bar chart */
%@AS@%     _pg_defaultchart( &env, _PG_BARCHART, _PG_PLAINBARS );
%@AS@%     strcpy( env.maintitle.title, "Widget Production" );
%@AS@%     _pg_chart( &env, category, value, COUNTRIES );
%@AS@%     getch();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%  
%@AS@%     /* Single-series column chart */
%@AS@%     _pg_defaultchart( &env, _PG_COLUMNCHART, _PG_PLAINBARS );
%@AS@%     strcpy( env.maintitle.title, "Widget Production" );
%@AS@%     _pg_chart( &env, category, value, COUNTRIES );
%@AS@%     getch();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%  
%@AS@%     /* Pie chart */
%@AS@%     _pg_defaultchart( &env, _PG_PIECHART, _PG_PERCENT );
%@AS@%     strcpy( env.maintitle.title, "Widget Production" );
%@AS@%     _pg_chartpie( &env, category, value, explode, COUNTRIES );
%@AS@%     getch();
%@AS@%  
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_chartscatter@%%@NL@%
%@2@%%@CR:C6A02281127 @%%@AB@%_pg_chartscatter Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02281128 @% %@CR:C6A02281129 @%%@CR:C6A02281130 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Display scatter charts.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_chartscatter( chartenv _far *env, float _far *xvalues, 
%@AS@%  float _far *yvalues, short n ); %@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_chartscatterms( chartenv _far *env, float _far *xvalues, 
%@AS@%  float _far *yvalues, short nseries, short n, short rowdim, 
%@AS@%  char _far * _far *serieslabels );%@AE@%%@NL@%
%@NL@%
%@AI@%env%@AE@%                               Chart environment structure

%@AI@%xvalues%@AE@%                           Array of %@AI@%x%@AE@%-axis data values

%@AI@%yvalues%@AE@%                           Array of %@AI@%y%@AE@%-axis data values

%@AI@%n%@AE@%                                 Number of data values to chart

%@AI@%nseries%@AE@%                           Number of series to chart

%@AI@%rowdim%@AE@%                            Row dimension of data array

%@AI@%serieslabels%@AE@%                      Array of labels for series

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_chartscatter%@AE@% function displays a scatter diagram for a single series
of data.  %@NL@%
%@NL@%
The %@AB@%_pg_chartscatterms%@AE@% function displays a scatter diagram for more than one
series of data.  %@NL@%
%@NL@%
The arguments %@AI@%xvalues%@AE@% and %@AI@%yvalues%@AE@% are two-dimensional arrays containing data
for the %@AI@%x%@AE@% axis and %@AI@%y%@AE@% axis, respectively. Columns for each array hold data
for individual series; thus the first columns of %@AI@%xvalues%@AE@% and %@AI@%yvalues%@AE@% contain
plot data for the first series, the second columns contain plot data for the
second series, and so forth.  %@NL@%
%@NL@%
The %@AI@%n%@AE@%, %@AI@%rowdim%@AE@%, %@AI@%nseries%@AE@%, and %@AI@%serieslabels%@AE@% arguments fulfill the same purposes
as those used in the %@AB@%_pg_chartms%@AE@% function. See %@AB@%_pg_chartms%@AE@% for an
explanation of these arguments.  %@NL@%
%@NL@%
For a discussion of the chart environment and related topics, see Section
2.6.2, "Presentation-Graphics Functions."   %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_chartscatter%@AE@% and %@AB@%_pg_chartscatterms%@AE@% functions return 0 if there were
no errors. A nonzero value indicates a failure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@% _pg_analyzescatter%@AE@% functions,  %@AB@%_pg_defaultchart%@AE@%,%@AB@%  _pg_initchart%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_chart%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_chartpie@%%@NL@%
%@2@%%@CR:C6A02291131 @%%@AB@%_pg_chartpie%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02291132 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Displays a pie chart.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_chartpie( chartenv _far *env, char _far * _far *categories,
%@AS@%  
%@AS@%  float _far *values, short _far *explode, short n );%@AE@%%@NL@%
%@NL@%
%@AI@%env%@AE@%                               Chart environment structure

%@AI@%categories%@AE@%                        Array of category labels

%@AI@%values%@AE@%                            Array of data values

%@AI@%explode%@AE@%                           Array of explode flags

%@AI@%n%@AE@%                                 Number of data values to chart

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_chartpie%@AE@% function displays a pie chart for the data contained in the
array %@AI@%values%@AE@%. Pie charts are formed from a single series of dataÄthere is no
multiseries version of pie charts as there is for other chart types.  %@NL@%
%@NL@%
The array %@AI@%explode%@AE@% must be dimensioned so that its length is greater than or
equal to the  argument %@AI@%n%@AE@%. All entries in %@AI@%explode%@AE@% are either 0 or 1. If an
entry is 1, the corresponding pie slice is displayed slightly removed from
the rest of the pie.  %@NL@%
%@NL@%
For example, if the %@AI@%explode%@AE@% array is initialized as  %@NL@%
%@NL@%
%@AS@%  short explode[5] = {0, 1, 0, 0, 0};%@AE@%%@NL@%
%@NL@%
the pie slice corresponding to the second entry of the %@AI@%categories%@AE@% array will
be displayed "exploded" from the other four slices.  %@NL@%
%@NL@%
For a discussion of the chart environment and related topics, see Section
2.6.2, "Presentation-Graphics Functions."   %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_chartpie%@AE@% function returns 0 if there were no errors. A nonzero value
indicates a failure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@% _pg_analyzepie%@AE@%,%@AB@%  _pg_defaultchart%@AE@%,%@AB@%  _pg_initchart%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_chart%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_defaultchart@%%@NL@%
%@2@%%@CR:C6A02301133 @%%@AB@%_pg_defaultchart%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02301134 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Initializes the chart environment.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_defaultchart( chartenv _far *env, short charttype, short
%@AS@%  chartstyle );%@AE@%%@NL@%
%@NL@%
%@AI@%env%@AE@%                               Chart environment structure

%@AI@%charttype%@AE@%                         Chart type

%@AI@%chartstyle%@AE@%                        Chart style

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_defaultchart%@AE@% function initializes all necessary variables in the
chart environment for the chart type by the variable %@AI@%charttype%@AE@%.  %@NL@%
%@NL@%
All title fields in the environment structure are blanked. Titles should be
set in the proper fields after calling %@AB@%_pg_defaultchart%@AE@%.  %@NL@%
%@NL@%
The %@AI@%charttype%@AE@% variable can be set to one of the following manifest
constants:  %@NL@%
%@NL@%
%@AB@%Chart Type%@AE@%                        %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_PG_BARCHART%@AE@%                      Bar chart

%@AB@%_PG_COLUMNCHART%@AE@%                   Column chart

%@AB@%_PG_LINECHART%@AE@%                     Line chart

%@AB@%_PG_PIECHART%@AE@%                      Pie chart

%@AB@%_PG_SCATTERCHART%@AE@%                  Scatter chart

The %@AI@%chartstyle%@AE@% variable specifies the style of the chart with either the
number "1" or the number "2." Each of the five types of
presentation-graphics charts can appear in two different chart styles, as
described below:%@AB@%  %@AE@%%@NL@%
%@NL@%
%@TH:  12   425 02 12 20 44 @%%@AB@%Chart Type%@AE@%  %@AB@%Chart Style 1%@AE@%       %@AB@%Chart Style  2%@AE@%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%Bar         Side by side        StackedColumn      Side by side        StackedLine        Points with lines   Points onlyPie         Percent             No percentScatter     Points with lines   Points only%@TE:  12   425 02 12 20 44 @%

In a pie chart, the pieces are "exploded" according to the %@AI@%explode%@AE@% array
argument in the %@AB@%_pg_chartpie%@AE@% function. In the "percent" format, percentages
are printed next to each slice. Bar and column charts have only one style
when displaying a single series of data. The styles "side by side" and
"stacked" are applicable only when more than one series appear on the same
chart. The first style arranges the bars or columns for the different series
side by side, showing relative heights or lengths. The stacked style
emphasizes relative sizes between bars and columns.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_defaultchart%@AE@% function returns 0 if there were no errors. A nonzero
value indicates a failure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_getchardef%@AE@%,%@AB@%  _pg_getpalette%@AE@%,%@AB@%  _pg_getstyleset%@AE@%,%@AB@%  _pg_hlabelchart%@AE@%,%@AB@%
%@AB@%_pg_initchart%@AE@%,%@AB@%  _pg_resetpalette%@AE@%,%@AB@%  _pg_resetstyleset%@AE@%,%@AB@%  _pg_setchardef%@AE@%,%@AB@%
%@AB@%_pg_setpalette%@AE@%,%@AB@%  _pg_setstyleset%@AE@%,%@AB@% _pg_vlabelchart  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_chart%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_getchardef@%%@NL@%
%@2@%%@CR:C6A02311135 @%%@AB@%_pg_getchardef%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02311136 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the pixel bit map for the specified character.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_getchardef( short charnum, unsigned char _far *chardef  );%@AE@%%@NL@%
%@NL@%
%@AI@%charnum%@AE@%                           ASCII number of character

%@AI@%chardef%@AE@%                           Pointer to 8-by-8 bit map array

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_getchardef%@AE@% function retrieves the current 8-by-8 pixel bit map for
the character having the ASCII number %@AI@%charnum%@AE@%. The bit map is stored in the
%@AI@%chardef%@AE@% array.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_getchardef%@AE@% function returns 0 if there were no errors. A nonzero
value indicates an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_defaultchart%@AE@%,  %@AB@%_pg_initchart%@AE@%,  %@AB@%_pg_setchardef%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_getpalette@%%@NL@%
%@2@%%@CR:C6A02321137 @%%@AB@%_pg_getpalette%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02321138 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets palette colors, line styles, and patterns.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_getpalette( paletteentry _far *palette );%@AE@%%@NL@%
%@NL@%
%@AI@%palette%@AE@%                           Pointer to first palette structure in 
                                  array

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_getpalette%@AE@% function retrieves palette colors, line styles, fill
patterns, and plot characters for all palettes. The pointer %@AI@%palette%@AE@% points
to an array of palette structures that will contain the desired palette
values.  %@NL@%
%@NL@%
The palette used by the presentation-graphics routines is independent of the
palette used by the low-level graphics routines.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function %@AB@%_pg_getpalette%@AE@% returns 0 if there were no errors, and it
returns the value %@AB@%_BADSCREENMODE%@AE@% if current palettes have not been
initialized by a previous call to %@AB@%_pg_setpalette%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_defaultchart%@AE@%,%@AB@%  _pg_initchart%@AE@%,%@AB@%  _pg_resetpalette%@AE@%,%@AB@%  _pg_setpalette%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PGGPAL.C: This example illustrates presentation-graphics palettes
%@AS@%   * and the routines that modify them, including
%@AS@%   *    _pg_getpalette    _pg_resetpalette    _pg_setstyleset
%@AS@%   *    _pg_getstyleset   _pg_resetstyleset   _pg_vlabelchart
%@AS@%   *    _pg_hlabelchart   _pg_setpalette
%@AS@%   */
%@AS@%  #include <conio.h>
%@AS@%  #include <string.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #define TEAMS  2
%@AS@%  #define MONTHS 3
%@AS@%  float _far values[TEAMS][MONTHS] = { { .435,   .522,   .671  },
%@AS@%                                       { .533,   .431,   .401  } };
%@AS@%  char _far *months[MONTHS] =          { "May", "June", "July" };
%@AS@%  char _far *teams[TEAMS] = { "Cubs", "Reds" };
%@AS@%  
%@AS@%  fillmap fill1 = { 0x99, 0x33, 0x66, 0xcc, 0x99, 0x33, 0x66, 0xcc };
%@AS@%  fillmap fill2 = { 0x99, 0xcc, 0x66, 0x33, 0x99, 0xcc, 0x66, 0x33 };
%@AS@%  styleset styles;
%@AS@%  palettetype pal;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     chartenv env;
%@AS@%     short mode = _VRES16COLOR;
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     _pg_initchart();                         /* Initialize chart system.
%@AS@%     */
%@AS@%  
%@AS@%     /* Modify global set of line styles used for borders, grids, and
%@AS@%      * data connectors. Note that this change is used before
%@AS@%      * _pg_defaultchart, which will use the style set.
%@AS@%      */
%@AS@%     _pg_getstyleset( styles );               /* Get styles and modify
%@AS@%     */
%@AS@%     styles[1] = 0x5555;                      /*   style 1 (used for
%@AS@%     */
%@AS@%     _pg_setstyleset( styles );               /*   borders)Äthen set new.
%@AS@%     */
%@AS@%  
%@AS@%     _pg_defaultchart( &env, _PG_BARCHART, _PG_PLAINBARS );
%@AS@%  
%@AS@%     /* Modify palette for data lines, colors, fill patterns, and
%@AS@%      * characters. Note that the line styles are set in the palette, not
%@AS@%      * in the style set, so that only data connectors will be affected.
%@AS@%      */
%@AS@%     _pg_getpalette( pal );                   /* Get default palette.
%@AS@%     */
%@AS@%     pal[1].plotchar = 16;                    /* Set to ASCII 16 and 17.
%@AS@%     */
%@AS@%     pal[2].plotchar = 17;
%@AS@%     memcpy( pal[1].fill, fill1, 8 );         /* Copy fill masks to
%@AS@%     palette.*/
%@AS@%     memcpy( pal[2].fill, fill2, 8 );
%@AS@%     pal[1].color = 3;                        /* Change palette colors.
%@AS@%     */
%@AS@%     pal[2].color = 4;
%@AS@%     pal[1].style = 0xfcfc;                   /* Change palette line
%@AS@%     styles.*/
%@AS@%     pal[2].style = 0x0303;
%@AS@%     _pg_setpalette( pal );                   /* Put modified palette.
%@AS@%     */%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Multiseries bar chart */
%@AS@%     strcpy( env.maintitle.title, "Little League Records - Customized" );
%@AS@%     _pg_chartms( &env, months, (float _far *)values,
%@AS@%               TEAMS, MONTHS, MONTHS, teams );
%@AS@%     getch();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%  
%@AS@%     /* Multiseries line chart */
%@AS@%     _pg_defaultchart( &env, _PG_LINECHART, _PG_POINTANDLINE );
%@AS@%     strcpy( env.maintitle.title, "Little League Records - Customized" );
%@AS@%     _pg_chartms( &env, months, (float _far *)values,
%@AS@%                   TEAMS, MONTHS, MONTHS, teams );
%@AS@%  
%@AS@%     /* Print labels. */
%@AS@%     _pg_hlabelchart( &env, (short)(env.chartwindow.x2 * .75),
%@AS@%                            (short)(env.chartwindow.y2 * .10),
%@AS@%                            12, "Up and up!" );
%@AS@%     _pg_vlabelchart( &env, (short)(env.chartwindow.x2 * .75),
%@AS@%                            (short)(env.chartwindow.y2 * .45),
%@AS@%                            13, "Sliding down!" );
%@AS@%     getch();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%  
%@AS@%     _pg_resetpalette();                     /* Restore default palette
%@AS@%*/
%@AS@%     _pg_resetstyleset();                    /*   and style set.
%@AS@%*/
%@AS@%  
%@AS@%     /* Multiseries bar chart */
%@AS@%     _pg_defaultchart( &env, _PG_BARCHART, _PG_PLAINBARS );
%@AS@%     strcpy( env.maintitle.title, "Little League Records - Default" );
%@AS@%     _pg_chartms( &env, months, (float _far *)values,
%@AS@%                  TEAMS, MONTHS, MONTHS, teams );
%@AS@%     getch();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%  
%@AS@%     /* Multiseries line chart */
%@AS@%     _pg_defaultchart( &env, _PG_LINECHART, _PG_POINTANDLINE );
%@AS@%     strcpy( env.maintitle.title, "Little League Records - Default" );
%@AS@%     _pg_chartms( &env, months, (float _far *)values,
%@AS@%                  TEAMS, MONTHS, MONTHS, teams );
%@AS@%     getch();
%@AS@%  
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_getstyleset@%%@NL@%
%@2@%%@CR:C6A02331139 @%%@AB@%_pg_getstyleset%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02331140 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current styleset.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _pg_getstyleset( unsigned short _far *styleset );%@AE@%%@NL@%
%@NL@%
%@AI@%styleset%@AE@%                          Pointer to current styleset

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_getstyleset%@AE@% function retrieves the contents of the current styleset.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_defaultchart%@AE@%,%@AB@%  _pg_initchart%@AE@%,%@AB@%  _pg_resetstyleset%@AE@%,%@AB@%  _pg_setstyleset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_getpalette%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_hlabelchart@%%@NL@%
%@2@%%@CR:C6A02341141 @%%@AB@%_pg_hlabelchart%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02341142 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Writes text horizontally on the screen.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_hlabelchart( chartenv _far *env, short x, short y, short
%@AS@%  color, 
%@AS@%  char _far *label );%@AE@%%@NL@%
%@NL@%
%@AI@%env%@AE@%                               Chart environment structure

%@AI@%x%@AE@%                                 %@AI@%x%@AE@%-coordinate for text

%@AI@%y%@AE@%                                 Pixel %@AI@%y%@AE@%-coordinate for text

%@AI@%color%@AE@%                             Color code for text

%@AI@%label%@AE@%                             Label text

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_hlabelchart%@AE@% function writes text horizontally on the screen. The
arguments %@AI@%x%@AE@% and %@AI@%y%@AE@% are pixel coordinates for the beginning location of text
relative to the upper-left corner of the chart window.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_hlabelchart%@AE@% functions return 0 if there were no errors. A nonzero
value indicates a failure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_defaultchart%@AE@%,%@AB@%  _pg_initchart%@AE@%,%@AB@%  _pg_vlabelchart %@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_getpalette%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_initchart@%%@NL@%
%@2@%%@CR:C6A02351143 @%%@AB@%_pg_initchart%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02351144 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Initializes presentation graphics.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_initchart( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_initchart%@AE@% function initializes the presentation-graphics package. It
initializes the color and style pools, resets the chartline styleset, builds
default palette modes, and reads the presentation-graphics font definition
from the disk. This function is required in all programs that use
presentation graphics. The %@AB@%_pg_initchart%@AE@% function must be called before any
of the other functions in the presentation-graphics library.  %@NL@%
%@NL@%
The %@AB@%_pg_initchart%@AE@% function assumes a valid graphics mode has been
established. Therefore, it must be called only after a successful call to
the library function %@AB@%_setvideomode%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_initchart%@AE@% functions return 0 if there were no errors. A nonzero
value indicates a failure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_defaultchart%@AE@%,%@AB@%  _pg_getchardef%@AE@%,%@AB@%  _pg_getpalette%@AE@%, %@AB@% _pg_getstyleset%@AE@%,%@AB@%
%@AB@%_pg_hlabelchart%@AE@%,%@AB@%  _pg_resetpalette%@AE@%,%@AB@%  _resetstyleset%@AE@%,%@AB@%  _pg_setchardef%@AE@%,%@AB@%
%@AB@%_pg_setpalette%@AE@%,%@AB@%  _pg_setstyleset%@AE@%,%@AB@%  _pg_vlabelchart%@AE@%,%@AB@%  _setvideomode  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_chart%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_resetpalette@%%@NL@%
%@2@%%@CR:C6A02361145 @%%@AB@%_pg_resetpalette%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02361146 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Resets palette colors, line styles, and patterns to default values.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_resetpalette( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_resetpalette%@AE@% function sets the palette colors, line styles, fill
patterns, and plot characters for the palette to the default for the current
screen mode.  %@NL@%
%@NL@%
The palette used by the presentation-graphics routines is independent of the
palette used by the low-level graphics routines.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_resetpalette%@AE@% function returns 0 if there were no errors. If the
screen mode is not valid, the value %@AB@%_BADSCREENMODE%@AE@% is returned.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_defaultchart%@AE@%,  %@AB@%_pg_getpalette%@AE@%,   %@AB@%_pg_initchart%@AE@%,  %@AB@%_pg_setpalette%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_getpalette%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_resetstyleset@%%@NL@%
%@2@%%@CR:C6A02371147 @%%@AB@%_pg_resetstyleset%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02371148 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Resets styleset to default values.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _pg_resetstyleset( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_resetstyleset%@AE@% function reinitializes the styleset to the default
values for the current screen mode.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_defaultchart%@AE@%,  %@AB@%_pg_getstyleset%@AE@%,  %@AB@%_pg_initchart%@AE@%,  %@AB@%_pg_setstyleset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_getpalette%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_setchardef@%%@NL@%
%@2@%%@CR:C6A02381149 @%%@AB@%_pg_setchardef%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02381150 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the pixel bit map for the specified character.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_setchardef( short charnum, unsigned char _far *chardef  );%@AE@%%@NL@%
%@NL@%
%@AI@%charnum%@AE@%                           ASCII number of character

%@AI@%chardef%@AE@%                           Pointer to an 8-by-8 bit map array for 
                                  the character

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_setchardef%@AE@% function sets the 8-by-8 pixel bit map for the character
with the ASCII number %@AI@%charnum%@AE@%. The bit map is stored in the %@AI@%chardef%@AE@% array.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_setchardef%@AE@% function returns 0 if there was no error. A nonzero value
indicates an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_defaultchart%@AE@%,  %@AB@%_pg_getchardef%@AE@%,  %@AB@%_pg_initchart%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_setpalette@%%@NL@%
%@2@%%@CR:C6A02391151 @%%@AB@%_pg_setpalette%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02391152 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets palette colors, line styles, and patterns.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_setpalette( paletteentry _far *palette );%@AE@%%@NL@%
%@NL@%
%@AI@%palette%@AE@%                           Pointer to first palette structure in 
                                  array

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_setpalette%@AE@% function sets palette colors, line styles, fill patterns,
and plot characters for all palettes. The pointer %@AI@%palette%@AE@% points to an array
of palette structures that contain the desired palette values.  %@NL@%
%@NL@%
The palette used by the presentation-graphics routines is independent of the
palette used by the low-level graphics routines.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_setpalette%@AE@% function returns 0 if there were no errors. If the new
palettes are not valid, the value %@AB@%_BADSCREENMODE%@AE@% is returned.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_defaultchart%@AE@%,%@AB@%  _pg_getpalette%@AE@%,  %@AB@%_pg_initchart%@AE@%,  %@AB@%_pg_resetpalette%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_getpalette%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_setstyleset@%%@NL@%
%@2@%%@CR:C6A02401153 @%%@AB@%_pg_setstyleset%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02401154 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the current styleset.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _pg_setstyleset( unsigned short _far *styleset );%@AE@%%@NL@%
%@NL@%
%@AI@%styleset%@AE@%                          Pointer to new styleset

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_setstyleset%@AE@% function sets the current styleset.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_defaultchart%@AE@%,%@AB@%  _pg_getstyleset%@AE@%,  %@AB@%_pg_initchart%@AE@%,  %@AB@%_pg_resetstyleset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_getpalette%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pg_vlabelchart@%%@NL@%
%@2@%%@CR:C6A02411155 @%%@AB@%_pg_vlabelchart%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02411156 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Writes text vertically on the screen.  %@NL@%
%@NL@%
%@AS@%  #include <pgchart.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pg_vlabelchart( chartenv _far *env, short x, short y, short
%@AS@%  color, 
%@AS@%  char _far *label );%@AE@%%@NL@%
%@NL@%
%@AI@%env%@AE@%                               Chart environment structure

%@AI@%x%@AE@%                                 Pixel %@AI@%x%@AE@% coordinate for text

%@AI@%y%@AE@%                                 Pixel %@AI@%y%@AE@% coordinate for text

%@AI@%color%@AE@%                             Color code for text

%@AI@%label%@AE@%                             Label text



%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_vlabelchart%@AE@% function writes text vertically on the screen. The
arguments %@AI@%x%@AE@% and %@AI@%y%@AE@% are pixel coordinates for the beginning location of text
relative to the upper-left corner of the chart window.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pg_vlabelchart%@AE@% function returns 0 if there were no errors. A nonzero
value indicates a failure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pg_defaultchart%@AE@%, %@AB@% _pg_hlabelchart%@AE@%, %@AB@% _pg_initchart%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_pg_getpalette%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pie@%%@NL@%
%@2@%%@CR:C6A02421157 @%%@AB@%_pie Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02421158 @% %@CR:C6A02421159 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Draw wedge-shaped figures.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pie( short control, short x1, short y1, short x2, short y2,
%@AS@%  short x3, short y3, short x4, short y4 );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pie_w( short control, double x1, double y1, double x2, double
%@AS@%  y2, 
%@AS@%  double x3, double y3, double x4, double y4 );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _pie_wxy( short control, struct _wxycoord _far *pwxy1, 
%@AS@%  struct _wxycoord _far *pwxy2, struct _wxycoord _far *pwxy3, 
%@AS@%  struct _wxycoord _far*pwxy4 );%@AE@%%@NL@%
%@NL@%
%@AI@%control%@AE@%                           Fill-control constant

%@AI@%x1%@AE@%, %@AI@%y1%@AE@%                            Upper-left corner of bounding rectangle

%@AI@%x2%@AE@%, %@AI@%y2%@AE@%                            Lower-right corner of bounding rectangle

%@AI@%x3%@AE@%, %@AI@%y3%@AE@%                            Start vector

%@AI@%x4%@AE@%, %@AI@%y4%@AE@%                            End vector

%@AI@%pwxy1%@AE@%                             Upper-left corner of bounding rectangle

%@AI@%pwxy2%@AE@%                             Lower-right corner of bounding rectangle

%@AI@%pwxy3%@AE@%                             Start vector

%@AI@%pwxy4%@AE@%                             End vector

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pie%@AE@% functions draw a pie-shaped wedge by drawing an elliptical arc
whose center and two endpoints are joined by lines.  %@NL@%
%@NL@%
The %@AB@%_pie%@AE@% function uses the view coordinate system. The center of the arc is
the center of the bounding rectangle specified by the view coordinate points
(%@AI@%x1%@AE@%, %@AI@%y1%@AE@%) and (%@AI@%x2%@AE@%, %@AI@%y2%@AE@%). The arc starts where it intersects the vector defined
by (%@AI@%x3%@AE@%, %@AI@%y3%@AE@%) and ends where it intersects the vector (%@AI@%x4%@AE@%, %@AI@%y4%@AE@%).  %@NL@%
%@NL@%
The %@AB@%_pie_wxy%@AE@% and %@AB@%_pie_w%@AE@% functions use the window coordinate system. The
center of the arc is the center of the bounding rectangle specified by the
window coordinate pairs %@AI@%pwxy1%@AE@% and %@AI@%pwxy2%@AE@% for %@AB@%_pie_wxy%@AE@%, and by the points (%@AI@%x1%@AE@%,
%@AI@%y1%@AE@%) and (%@AI@%x2%@AE@%, %@AI@%y2%@AE@%) for %@AB@%_pie_w%@AE@%. The arc starts where it intersects the vector
defined by %@AI@%pwxy3%@AE@% or (%@AI@%x3%@AE@%, %@AI@%y3%@AE@%) and ends where it intersects the vector defined
by %@AI@%pwxy4%@AE@% or (%@AI@%x4%@AE@%, %@AI@%y4%@AE@%).  %@NL@%
%@NL@%
The %@AB@%_wxycoord%@AE@% structure is defined in GRAPH.H and contains the following
elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%double wx%@AE@%                         Window%@AI@% x%@AE@% coordinate

%@AB@%double wy%@AE@%                         Window %@AI@%y%@AE@% coordinate

The wedge is drawn using the current color moving in a counterclockwise
direction. The %@AI@%control%@AE@% parameter can be one of the following manifest
constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Action%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_GFILLINTERIOR%@AE@%                    Fills the figure using the current color
                                  and fill mask

%@AB@%_GBORDER%@AE@%                          Does not fill the figure

The control option given by %@AB@%_GFILLINTERIOR%@AE@% is equivalent to a subsequent
call to the %@AB@%_floodfill%@AE@% function using the approximate center of the arc as
the starting point and the current color (set by %@AB@%_setcolor%@AE@%) as the boundary
color.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return a nonzero value if successful; otherwise, they return
0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_arc%@AE@% functions, %@AB@% _ellipse%@AE@% functions, %@AB@% _floodfill%@AE@%,  %@AB@%_getcolor%@AE@%, %@AB@% _lineto%@AE@%
functions, %@AB@%_rectangle%@AE@% functions,  %@AB@%_setcolor%@AE@%,  %@AB@%_setfillmask%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PIE.C: This program draws a pie-shaped figure. */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     _pie( _GBORDER, 80, 50, 240, 150, 240, 12, 0, 150 );
%@AS@%     getch();
%@AS@%  
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_pipe@%%@NL@%
%@2@%%@CR:C6A02431160 @%%@AB@%_pipe%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02431161 @%%@CR:C6A02431162 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Creates a pipe for reading and writing.  %@NL@%
%@NL@%
%@AB@%#include <fcntl.h>%@AE@%                For O_BINARY and O_TEXT definitions

%@AB@%#include <errno.h>%@AE@%                %@AB@%errno%@AE@% definitions

%@AB@%#include <io.h>%@AE@%                   Prototype declaration

%@AS@%  int _pipe( int *phandles, unsigned int psize, int textmode );%@AE@%%@NL@%
%@NL@%
%@AI@%phandles%@AE@%[2]                       Array to hold read and write handles

%@AI@%psize%@AE@%                             Amount of memory to reserve

%@AI@%textmode%@AE@%                          File mode

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
A pipe is an artificial file-like I/O channel that a program can create and
use to pass information to other programs. A pipe is similar to a file in
that it has a file pointer or a file descriptor, or both, and can be read
from or written to using the input and output functions of the standard
library. Unlike a file, a pipe does not represent a specific file or device.
Instead, a pipe represents temporary storage in memory that is independent
of the program's own memory and is controlled entirely by the operating
system.  %@NL@%
%@NL@%
Pipes may be used to pass information between programs. For example, the
command processor in OS/2 creates a pipe when executing a command such as  %@NL@%
%@NL@%
%@AS@%  PROGRAM1 | PROGRAM2%@AE@%%@NL@%
%@NL@%
The standard output handle of PROGRAM1 is attached to the pipe's write
handle. The standard input handle of PROGRAM2 is attached to the pipe's read
handle. This eliminates the need for creating temporary files to pass
information to other programs.  %@NL@%
%@NL@%
The %@AB@%_pipe%@AE@% function creates a pipe. This function is similar to %@AB@%open%@AE@% but
opens the pipe for both reading and writing, returning two file handles
instead of one. The program can either use both sides of the pipe or close
the one it does not need. This function typically opens a pipe in
preparation for linking it to a child process.  %@NL@%
%@NL@%
The %@AB@%_pipe%@AE@% function opens a pipe and returns two handles to the pipe in the
%@AI@%phandles%@AE@% argument. The element %@AI@%phandles%@AE@%[0] contains the read handle, and the
element %@AI@%phandles%@AE@%[1] contains the write handle. Pipe file handles are used in
the same way as other file handles. (The low-level input and output
functions %@AB@%read%@AE@% and %@AB@%write%@AE@% can read from and write to a pipe.)  %@NL@%
%@NL@%
The %@AI@%psize%@AE@% argument specifies the amount of memory, in bytes, to reserve for
the pipe.  %@NL@%
%@NL@%
The %@AI@%textmode%@AE@% argument specifies the translation mode for the pipe. The
manifest constant %@AB@%O_TEXT%@AE@% specifies a text translation, and the constant
%@AB@%O_BINARY %@AE@%specifies binary translation. (See %@AB@%fopen%@AE@% for a description of text
and binary modes.) If the %@AI@%textmode%@AE@% argument is 0, the %@AB@%_pipe%@AE@% function uses
the default translation mode specified by the default-mode variable %@AB@%_fmode%@AE@%.
%@NL@%
%@NL@%
In multithread programs, no locking is performed. The handles returned are
newly opened and should not be referenced by any thread until after the
%@AB@%_pipe%@AE@% call is complete.  %@NL@%
%@NL@%
Under OS/2, a pipe is destroyed when all its handles have been closed. (If
all read handles on the pipe have been closed, writing to the pipe will
cause an error.) All read and write operations on the pipe wait until there
is enough data or enough buffer space to complete the I/O request.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_pipe%@AE@% function returns 0 if successful. A return value of -1 indicates
an error, and %@AB@%errno%@AE@% is set to one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EMFILE%@AE@%                            No more file handles available (too many
                                  open files)

%@AB@%ENFILE%@AE@%                            System file table overflow

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
A similar function (%@AB@%pipe%@AE@%) is available in the XENIX and UNIX operating
environments.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cwait%@AE@%,%@AB@%  _pclose%@AE@%, %@AB@% _popen%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PIPE.C: This program uses _pipe to pass streams of text to
%@AS@%   * child processes.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <io.h>
%@AS@%  #include <fcntl.h>
%@AS@%  #include <process.h>            /* _pipe */
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  enum PIPES { READ, WRITE };     /* Constants 0 and 1 for READ and WRITE */
%@AS@%  #define NUMPROBLEM 8
%@AS@%  
%@AS@%  void main( int argc, char *argv[] )
%@AS@%  {
%@AS@%      int     hpipe[2];
%@AS@%      char    hstr[20];
%@AS@%      int     termstat, pid, problem, c;
%@AS@%  
%@AS@%      /* If no arguments, this is the parent. */
%@AS@%      if( argc == 1 )
%@AS@%      {
%@AS@%          /* Open a sets of pipes. */
%@AS@%          if( _pipe( hpipe, 256, O_BINARY ) == -1 )
%@AS@%              exit( 1 );
%@AS@%  
%@AS@%          /* Convert pipe read handle to string and pass as argument to
%@AS@%           * spawned child. Program spawns itself (argv[0]).
%@AS@%           */
%@AS@%          itoa( hpipe[READ],  hstr,  10 );
%@AS@%          if( spawnl( P_NOWAIT, argv[0], argv[0], hstr, NULL )  == -1 )
%@AS@%              printf( "Spawn failed" );
%@AS@%  
%@AS@%          /* Put problem in write pipe. Since child is running
%@AS@%simultaneously,
%@AS@%           * first solutions may be done before last problem is given.
%@AS@%           */
%@AS@%          for( problem = 1000; problem <= NUMPROBLEM * 1000; problem += 1000
%@AS@%)
%@AS@%          {
%@AS@%              printf( "Son, what is the square root of %d?\n", problem );
%@AS@%              write( hpipe[WRITE], (char *)&problem, sizeof( int ) );
%@AS@%          }
%@AS@%  
%@AS@%          /* Wait until child is done processing. */
%@AS@%          wait( &termstat );
%@AS@%          if( termstat & 0xff )
%@AS@%              printf( "Child failed\n" );
%@AS@%  
%@AS@%          close( hpipe[READ] );
%@AS@%          close( hpipe[WRITE] );
%@AS@%      }%@AE@%%@NL@%
%@NL@%
%@AS@%  /* If there is an argument, this must be the child. */
%@AS@%      else
%@AS@%      {
%@AS@%          /* Convert passed string handle to integer handle. */
%@AS@%          hpipe[READ] = atoi( argv[1] );
%@AS@%  
%@AS@%          /* Read problem from pipe and calculate solution. */
%@AS@%          for( c = 0; c < NUMPROBLEM; c++ )
%@AS@%          {
%@AS@%              read( hpipe[READ], (char *)&problem, sizeof( int ) );
%@AS@%              printf( "Dad, the square root of %d is %3.2f.\n",
%@AS@%                      problem, sqrt( (double)problem ) );;
%@AS@%          }
%@AS@%      }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Son, what is the square root of 1000?
%@AS@%  Dad, the square root of 1000 is 31.62.
%@AS@%  Son, what is the square root of 2000?
%@AS@%  Son, what is the square root of 3000?
%@AS@%  Dad, the square root of 2000 is 44.72.
%@AS@%  Son, what is the square root of 4000?
%@AS@%  Dad, the square root of 3000 is 54.77.
%@AS@%  Son, what is the square root of 5000?
%@AS@%  Dad, the square root of 4000 is 63.25.
%@AS@%  Son, what is the square root of 6000?
%@AS@%  Dad, the square root of 5000 is 70.71.
%@AS@%  Son, what is the square root of 7000?
%@AS@%  Dad, the square root of 6000 is 77.46.
%@AS@%  Son, what is the square root of 8000?
%@AS@%  Dad, the square root of 7000 is 83.67.
%@AS@%  Dad, the square root of 8000 is 89.44.%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_polygon@%%@NL@%
%@2@%%@CR:C6A02441163 @%%@AB@%_polygon Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02441164 @% %@CR:C6A02441165 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Draw polygon shapes.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _polygon( short control, struct xycoord _far *points, short
%@AS@%  numpoints );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _polygon_w( short control, double _far *points, short numpoints
%@AS@%  );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _polygon_wxy( short control, struct _wxycoord _far *points, 
%@AS@%  short numpoints );%@AE@%%@NL@%
%@NL@%
%@AI@%control%@AE@%                           Fill flag

%@AI@%points%@AE@%                            Pointer to an array of structures 
                                  defining the polygon

%@AI@%numpoints%@AE@%                         Number of points

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_polygon%@AE@% functions draw polygons. The border of the polygon is drawn in
the current color and line style. The %@AB@%_polygon%@AE@% routine uses the view
coordinate system (expressed in %@AB@%xycoord%@AE@% structures), and the %@AB@%_polygon_wxy%@AE@%
and %@AB@%_polygon_w%@AE@% routines use real-valued window coordinates (expressed in
%@AB@%_wxycoord%@AE@% structures and in pairs of double-precision floating-point values,
respectively).  %@NL@%
%@NL@%
The argument %@AI@%points%@AE@% is an array of %@AB@%xycoord%@AE@% or %@AB@%_wxycoord%@AE@% structures or pairs
of doubles, each of which specifies one of the polygon's vertices. (For
%@AB@%_polygon_w%@AE@%, %@AI@%points%@AE@%[0] and %@AI@%points%@AE@%[1] specify the %@AI@%x%@AE@% and %@AI@%y%@AE@% coordinates,
respectively, of the first point.) The argument %@AI@%numpoints%@AE@% indicates the
number of elements (the number of vertices) in the %@AI@%points%@AE@% array.  %@NL@%
%@NL@%
The %@AI@%control%@AE@% argument can be one of the following manifest constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Action%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_GFILLINTERIOR%@AE@%                    Fills the polygon using the current fill
                                  mask

%@AB@%_GBORDER%@AE@%                          Does not fill the polygon

The %@AB@%_setwritemode%@AE@%, %@AB@%_setlinestyle%@AE@%, and %@AB@%_setfillmask%@AE@% functions all affect the
output from the%@AB@%_polygon%@AE@% functions.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_polygon%@AE@% functions return a nonzero value if the arc is successfully
drawn; otherwise, they return 0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_ellipse%@AE@% functions, %@AB@% _floodfill%@AE@%, %@AB@% _lineto%@AE@% functions, %@AB@% _pie%@AE@% functions, %@AB@%
%@AB@%_rectangle%@AE@% functions, %@AB@% _setcolor%@AE@%, %@AB@% _setfillmask%@AE@%, %@AB@% _setlinestyle%@AE@%,
%@AB@%_setwritemode%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* POLYGON.C: This program draws a star-shaped polygon. */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  #include <math.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  #define PI 3.1415
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short  side, radius = 90, x = 0, y = 0;
%@AS@%     double radians;
%@AS@%     struct xycoord polyside[5];
%@AS@%     struct videoconfig vc;
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     _getvideoconfig( &vc );
%@AS@%     _setvieworg( vc.numxpixels / 2, vc. numypixels / 2 );
%@AS@%  
%@AS@%     /* Calculate points of star every 144 degrees, then connect them. */
%@AS@%     for( side = 0; side < 5; side++ )
%@AS@%     {
%@AS@%         radians = 144 * PI / 180;
%@AS@%         polyside[side].xcoord = x + (short)(cos( side * radians ) *
%@AS@%radius);
%@AS@%         polyside[side].ycoord = y + (short)(sin( side * radians ) *
%@AS@%radius);
%@AS@%     }
%@AS@%     _polygon( _GFILLINTERIOR, polyside, 5 );
%@AS@%  
%@AS@%     getch();
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_popen@%%@NL@%
%@2@%%@CR:C6A02451166 @%%@AB@%_popen%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02451167 @%%@CR:C6A02451168 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Creates a pipe and executes a command.  %@NL@%
%@NL@%
%@AB@%#include <stdio.h>%@AE@%                Required for function declarations only

%@AS@%  FILE *_popen( char *command, char *mode );%@AE@%%@NL@%
%@NL@%
%@AI@%command%@AE@%                           Command to be executed

%@AI@%mode%@AE@%                              Mode of returned stream

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_popen%@AE@% function creates a pipe and asynchronously executes a child copy
of the command processor with the specified command string %@AI@%command%@AE@%. See
%@AB@%_pipe%@AE@% for a general discussion of pipes in OS/2. The character string %@AI@%mode%@AE@%
specifies the type of access requested, as follows:  %@NL@%
%@NL@%
%@AB@%Type%@AE@%                              %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%"r"%@AE@%                               The calling process can read the child 
                                  command's standard output via the 
                                  returned stream.

%@AB@%"w"%@AE@%                               The calling process can write to the 
                                  child command's standard input via the 
                                  returned stream.

%@AB@%"b"%@AE@%                               Open in binary mode.

%@AB@%"t"%@AE@%                               Open in text mode.

See Section 2.7, "Input and Output," for a discussion of text and binary
modes.   %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_popen%@AE@% function returns a stream associated with one end of the created
pipe. The other end of the pipe is associated with the child command's
standard input or standard output. If an error occurs, %@AB@%NULL%@AE@% is returned.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
A similar function (%@AB@%popen%@AE@%) is available in the XENIX and UNIX operating
environments.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_pclose%@AE@%, %@AB@% _pipe%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* POPEN.C: This program uses _popen and _pclose to receive a stream
%@AS@%   * of text from a child system process.
%@AS@%   */
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char    buffer[128];
%@AS@%     FILE    *chkdsk;
%@AS@%  
%@AS@%     /* Run CHKDSK so that it writes its output to a pipe. Open pipe
%@AS@%      * with read text attribute so that we can read it like a text file.
%@AS@%      */
%@AS@%     if( (chkdsk = _popen( "dir po*.c | sort | more", "rt" )) == NULL )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     /* Read pipe until end of file. End of file indicates that CHKDSK
%@AS@%      * closed its standard out (probably meaning it terminated).
%@AS@%      */
%@AS@%     while( !feof( chkdsk ) )
%@AS@%     {
%@AS@%        if( fgets( buffer, 128, chkdsk ) != NULL )
%@AS@%           printf( buffer );
%@AS@%     }
%@AS@%  
%@AS@%     /* Close pipe and print return value of CHKDSK. */
%@AS@%     printf( "\nChild returned %d\n", _pclose( chkdsk ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%       3 File(s)   12683264 bytes free
%@AS@%   Directory of C:\LIBREF
%@AS@%   The volume label in drive C is OS2.
%@AS@%  POLYGON  C        921   6-14-89   6:51p
%@AS@%  POPEN    C        845   6-19-89   2:48p
%@AS@%  POW      C        190   6-13-89   6:07p
%@AS@%  
%@AS@%  Child returned 0 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:pow@%%@NL@%
%@2@%%@CR:C6A02461169 @%%@AB@%pow Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02461170 @%%@CR:C6A02461171 @% %@CR:C6A02461172 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate %@AI@%x%@AE@% raised to the power of %@AI@%y%@AE@%.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double pow( double x, double y );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double powl( long double x, long double y );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Number to be raised

%@AI@%y%@AE@%                                 Power of %@AI@%x%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%pow%@AE@% and %@AB@%powl%@AE@% functions compute %@AI@%x%@AE@% raised to the power of %@AI@%y%@AE@%.  %@NL@%
%@NL@%
The %@AB@%powl%@AE@% function is the 80-bit counterpart, and it uses an 80-bit, 10-byte
coprocessor form of arguments and return values. See the reference page on
the long double functions for more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%pow%@AE@% and %@AB@%powl%@AE@% functions return the value of %@AI@%xy%@AE@%. If %@AI@%x%@AE@% is not 0.0 and %@AI@%y%@AE@% is
0.0, %@AB@%pow%@AE@% and %@AB@%powl%@AE@% return the value 1. If %@AI@%x%@AE@% is 0.0 and %@AI@%y%@AE@% is negative, %@AB@%pow%@AE@% and
%@AB@%powl%@AE@% set %@AB@%errno%@AE@% to %@AB@%EDOM %@AE@%and return 0.0. If both %@AI@%x%@AE@% and %@AI@%y%@AE@% are 0.0, or if %@AI@%x%@AE@% is
negative and %@AI@%y%@AE@% is not an integer, the function prints a %@AB@%DOMAIN %@AE@%error message
to %@AB@%stderr%@AE@%, sets %@AB@%errno%@AE@% to %@AB@%EDOM,%@AE@% and returns 0.0. If an overflow results, the
function sets %@AB@%errno%@AE@% to %@AB@%ERANGE%@AE@% and returnsñ%@AB@%HUGE_VAL.%@AE@% No message is printed on
overflow or underflow.  %@NL@%
%@NL@%
The %@AB@%pow%@AE@% function does not recognize integral floating-point values greater
than 264, such as %@AS@% 1.0E100%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%pow%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%powl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%exp%@AE@%, %@AB@%log%@AE@% functions, %@AB@%sqrt%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* POW.C */
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     double x = 2.0, y = 3.0, z;
%@AS@%  
%@AS@%     z = pow( x, y );
%@AS@%     printf( "%.1f to the power of %.1f is %.1f\n", x, y, z );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  2.0 to the power of 3.0 is 8.0 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:printf@%%@NL@%
%@2@%%@CR:C6A02471173 @%%@AB@%printf%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02471174 @%%@CR:C6A02471175 @%%@CR:C6A02471176 @%%@CR:C6A02471177 @%%@CR:C6A02471178 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Prints formatted output to the standard output stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int printf( const char *format [[, argument]]... );%@AE@%%@NL@%
%@NL@%
%@AI@%format%@AE@%                            Format control

%@AI@%argument%@AE@%                          Optional arguments

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%printf%@AE@% function formats and prints a series of characters and values to
the standard output stream, %@AB@%stdout%@AE@%. The %@AI@%format%@AE@% argument consists of ordinary
characters, escape sequences, and (if arguments follow %@AI@%format%@AE@%) format
specifications. The ordinary characters and escape sequences are copied to
%@AB@%stdout%@AE@% in order of their appearance. For example, the line  %@NL@%
%@NL@%
%@AS@%  printf("Line one\n\t\tLine two\n");%@AE@%%@NL@%
%@NL@%
produces the output  %@NL@%
%@NL@%
%@AS@%  Line one
%@AS@%          Line two%@AE@%%@NL@%
%@NL@%
If arguments follow the %@AI@%format%@AE@% string, the %@AI@%format%@AE@% string must contain
specifications that determine the output format for the arguments.  %@NL@%
%@NL@%
Format specifications always begin with a percent sign (%@AB@%%%@AE@%) and are read left
to right. When the first format specification (if any) is encountered, the
value of the first argument after %@AI@%format%@AE@% is converted and output
accordingly. The second format specification causes the second argument to
be converted and output, and so on. If there are more arguments than there
are format specifications, the extra arguments are ignored. The results are
undefined if there are not enough arguments for all the format
specifications.  %@NL@%
%@NL@%
A format specification, which consists of optional and required fields, has
the following form:  %@NL@%
%@NL@%
%@AS@%  %[[flags]] [[width]] [[.precision]] [[{F | N | h | l | L}]] type%@AE@%%@NL@%
%@NL@%
%@AB@%%@AE@%%@AI@%%@AE@%Format Specification Fields  %@NL@%
%@NL@%
Each field of the format specification is a single character or a number
signifying a particular format option. The simplest format specification
contains only the percent sign and a %@AI@%type%@AE@% character (for example, %@AS@% %s%@AE@%). The
optional fields, which appear before the %@AI@%type%@AE@% character, control other
aspects of the formatting. The fields in a %@AB@%printf%@AE@% format specification are
described in the following list:  %@NL@%
%@NL@%
%@AB@%Field%@AE@%                             %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AI@%type%@AE@%                              Required character that determines 
                                  whether the associated argument is 
                                  interpreted as a character, a string, or
                                  a number. (See Table R.2.)

%@AI@%flags%@AE@%                             Optional character or characters that 
                                  control justification of output and 
                                  printing of signs, blanks, decimal 
                                  points, and octal and hexadecimal 
                                  prefixes. (See Table R.3.) More than one
                                  flag can appear in a format 
                                  specification.

%@AI@%width%@AE@%                             Optional number that specifies minimum 
                                  number of characters output.

%@AI@%precision%@AE@%                         Optional number that specifies maximum 
                                  number of characters printed for all or 
                                  part of the output field, or minimum 
                                  number of digits printed for integer 
                                  values. (See Table R.4.)

%@AB@%F, N%@AE@%                              Optional prefixes that refer to the 
                                  "distance" to the object being printed (%@AB@%%@AE@%
                                  %@AB@%near%@AE@% or %@AB@%far%@AE@%).

                                  %@AB@%F%@AE@% and %@AB@%N%@AE@% are not part of the ANSI 
                                  definition for %@AB@%printf%@AE@%. They are 
                                  Microsoft extensions that should not be 
                                  used if ANSI portability is desired.

%@AB@%h%@AE@%, %@AB@%l%@AE@%, %@AB@%L%@AE@%                           Optional prefixes that determine the 
                                  size of the argument expected, as shown 
                                  below:

                                  %@AB@%Prefix%@AE@%      %@AB@%Use%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
                                  %@AB@%h%@AE@%           Used with the integer types %@AB@%%@AE@%
                                              %@AB@%d%@AE@%,%@AB@% i%@AE@%, %@AB@%o%@AE@%, %@AB@%x,%@AE@% and%@AB@% X%@AE@% to specify
                                              that the argument is %@AB@%short %@AE@%
                                              %@AB@%int%@AE@%, or with %@AB@%u%@AE@% to specify %@AB@%%@AE@%
                                              %@AB@%short unsigned int%@AE@%. If used 
                                              with %@AB@%%p%@AE@%, it indicates a 
                                              16-bit pointer.

                                  %@AB@%l%@AE@%           Used with %@AB@%d%@AE@%,%@AB@% i%@AE@%, %@AB@%o%@AE@%, %@AB@%x%@AE@%, and %@AB@%X%@AE@% 
                                              types to specify that the 
                                              argument is %@AB@%long int%@AE@%, or 
                                              with %@AB@%u%@AE@% to specify %@AB@%long %@AE@%
                                              %@AB@%unsigned int%@AE@%; also used with
                                              %@AB@%e%@AE@%, %@AB@%E%@AE@%, %@AB@%f%@AE@%, %@AB@%g%@AE@%, and %@AB@%G%@AE@% types to 
                                              specify %@AB@%double%@AE@% rather than %@AB@%%@AE@%
                                              %@AB@%float%@AE@%. If used with %@AB@%%p%@AE@%, it 
                                              indicates a 32-bit pointer.

                                  %@AB@%L%@AE@%           Used with %@AB@%e%@AE@%, %@AB@%E%@AE@%, %@AB@%f%@AE@%, %@AB@%g%@AE@%, and %@AB@%G%@AE@% 
                                              types to specify %@AB@%long double%@AE@%
                                              .

If a percent sign is followed by a character that has no meaning as a format
field, the character is copied to %@AB@%stdout%@AE@%. For example, to print a
percent-sign character, use %%.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Type Field Characters%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AI@%type%@AE@% character is the only required format field for the %@AB@%printf%@AE@%
function; it appears after any optional format fields. The %@AI@%type%@AE@% character
determines whether the associated argument is interpreted as a character, a
string, or a number. (See Table R.2.)  %@NL@%
%@NL@%
%@AB@%Table   R.2   Type Characters for printf%@AE@%

%@TH:  60  3649 02 11 13 52 @%Character  Type         Output Format%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%d%@AE@%          %@AB@%int%@AE@%          Signed decimal integer.%@AB@%i%@AE@%          %@AB@%int%@AE@%          Signed decimal integer.%@AB@%u%@AE@%          %@AB@%int%@AE@%          Unsigned decimal integer.%@AB@%o%@AE@%          %@AB@%int%@AE@%          Unsigned octal integer.%@AB@%x%@AE@%          %@AB@%int%@AE@%          Unsigned hexadecimal integer, using "abcdef."%@AB@%X%@AE@%          %@AB@%int%@AE@%          Unsigned hexadecimal integer, using "ABCDEF."%@AB@%f%@AE@%          %@AB@%double%@AE@%       Signed value having the form [-]%@AI@%dddd.dddd%@AE@%, where %@AI@%%@AE@%                        %@AI@%dddd%@AE@% is one or more decimal digits. The number of                         digits before the decimal point depends on the                         magnitude of the number, and the number of digits                         after the decimal point depends on the requested                         precision.%@AB@%e%@AE@%          %@AB@%double%@AE@%       Signed value having the form [-]%@AI@%d.dddd%@AE@%%@AB@% e %@AE@%[%@AI@%sign%@AE@%]%@AI@%ddd%@AE@%                        , where %@AI@%d%@AE@% is a single decimal digit, %@AI@%dddd%@AE@% is one                         or more decimal digits, %@AI@%ddd%@AE@% is exactly three                         decimal digits, and %@AI@%sign%@AE@% is + or -.%@AB@%E%@AE@%          %@AB@%double%@AE@%       Identical to the %@AB@%e%@AE@% format, except that %@AB@%E%@AE@%, rather                         than%@AB@% %@AE@%e, introduces the exponent.%@AB@%g%@AE@%          %@AB@%double%@AE@%       Signed value printed in %@AB@%f%@AE@% or %@AB@%e%@AE@% format, whichever                         is more compact for the given value and precision.                        The %@AB@%e%@AE@% format is used only when the exponent of the                        value is less than - 4 or greater than or equal to                        the %@AI@%precision%@AE@% argument. Trailing zeros are                         truncated, and the decimal point appears only if                         one or more digits follow it.%@AB@%G%@AE@%          %@AB@%double%@AE@%       Identical to the %@AB@%g%@AE@% format, except that %@AB@%G%@AE@%, rather                         than%@AB@% g%@AE@%, introduces the exponent (where                         appropriate).%@AB@%c%@AE@%          %@AB@%int%@AE@%          Single character.%@AB@%s%@AE@%          String       Characters printed up to the first null character                         ('%@AB@%\0%@AE@%') or until the %@AI@%%@AE@%                        %@AI@%precision%@AE@% value is reached.%@AB@%n%@AE@%          Pointer to   Number of characters successfully written so far            integer      to the stream or buffer; this value is stored in                         the integer whose address is given as the                         argument.%@AB@%p%@AE@%          Far pointer  Prints the address pointed to by the argument in            to %@AB@%void%@AE@%      the form %@AI@%xxxx%@AE@%:%@AI@%yyyy%@AE@%, where %@AI@%xxxx%@AE@% is the segment and %@AI@%%@AE@%                        %@AI@%yyyy%@AE@% is the offset, and the digits %@AI@%x%@AE@% and %@AI@%y%@AE@% are                         uppercase hexadecimal digits; %@AB@%%hp%@AE@% indicates a near                        pointer and prints only the offset of the address.%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  60  3649 02 11 13 52 @%

%@NL@%
%@4@%%@AB@%Flag Directives%@AE@%%@EH@%%@NL@%
%@NL@%
The first optional field of the format specification is %@AI@%flag%@AE@%. A flag
directive is a character that justifies output and prints signs, blanks,
decimal points, and octal and hexadecimal prefixes. More than one flag
directive may appear in a format specification. (See Table R.3.)  %@NL@%
%@NL@%
%@AB@%Table   R.3   Flag Characters for printf%@AE@%

%@TH:  55  3149 02 27 27 27 @%Flag%@AU@%(, Meaning , Default)%@AE@%  %@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%- %@AE@%                         Left justify the result    Right justify.                           within the given field                                width.                     %@AB@%+ %@AE@%                         Prefix the output value    Sign appears only for                            with a sign                negative signed values                            (+ or -) if the output     (-).                           value is of a signed                                  type.                      %@AB@%0 %@AE@%                         If %@AI@%width%@AE@% is prefixed with  No padding.                           0, zeros are added until                              the minimum width is                                  reached. If 0 and -                                   appear, the 0 is                                      ignored. If 0 is                                      specified with an                                     integer format %@AB@%(i, u, x, %@AE@%                             %@AB@%X, o, d)%@AE@%, the                                         0 is ignored.              %@AI@%blank%@AE@% (' ')                Prefix the output value    No blank appears.                           with a blank if the                                   output value is signed                                and positive; the blank                               is ignored if both the                                blank and %@AB@%+%@AE@% flags appear.  %@AB@%#%@AE@%                          When used with the o, %@AB@%x%@AE@%,   No blank appears.                           or %@AB@%X%@AE@% format, the # flag                               prefixes any nonzero                                  output value with 0, 0x,                              or 0X, respectively.                                  When used with the %@AB@%e%@AE@%, %@AB@%E%@AE@%,   Decimal point appears                            or %@AB@%f%@AE@% format, the %@AB@%#%@AE@% flag    only if digits follow it.                           forces the output value                               to contain a decimal                                  point in all cases.                                   When used with the %@AB@%g%@AE@% or %@AB@%G%@AE@%  Decimal point appears                            format, the %@AB@%#%@AE@% flag forces  only if digits follow it.                           the output value to        Trailing zeros are                            contain a decimal point    truncated.                           in all cases and prevents                             the truncation of                                     trailing zeros.                                       Ignored when used with %@AB@%c%@AE@%,%@AB@%%@AE@%                           %@AB@%d%@AE@%, %@AB@%i%@AE@%, %@AB@%u%@AE@%, or %@AB@%s%@AE@%.%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  55  3149 02 27 27 27 @%

%@NL@%
%@4@%%@AB@%Width Specification%@AE@%%@EH@%%@NL@%
%@NL@%
The second optional field of the format specification is the width
specification. The %@AI@%width%@AE@% argument is a non-negative decimal integer
controlling the minimum number of characters printed. If the number of
characters in the output value is less than the specified width, blanks are
added to the left or the right of the valuesÄdepending on whether the %@AB@% -%@AE@%
flag (for left justification) is specifiedÄuntil the minimum width is
reached. If %@AI@%width%@AE@% is prefixed with 0, zeros are added until the minimum
width is reached (not useful for left-justified numbers).  %@NL@%
%@NL@%
The width specification never causes a value to be truncated. If the number
of characters in the output value is greater than the specified width, or
%@AI@%width%@AE@% is not given, all characters of the value are printed (subject to the
precision specification).  %@NL@%
%@NL@%
The width specification may be an asterisk (%@AB@%*%@AE@%), in which case an %@AB@%int%@AE@%
argument from the argument list supplies the value. The %@AI@%width%@AE@% argument must
precede the value being formatted in the argument list. A nonexistent or
small field width does not cause a truncation of a field; if the result of a
conversion is wider than the field width, the field expands to contain the
conversion result.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Precision Specification%@AE@%%@EH@%%@NL@%
%@NL@%
The third optional field of the format specification is the precision
specification. It specifies a non-negative decimal integer, preceded by a
period (%@AB@%.%@AE@%), which specifies the number of characters to be printed, the
number of decimal places, or the number of significant digits. (See Table
R.4.) Unlike the width specification, the precision specification can cause
truncation of the output value, or rounding in the case of a floating-point
value. If %@AI@%precision%@AE@% is specified as zero and the value to be converted is
zero, the result is no characters output, as shown below:  %@NL@%
%@NL@%
%@AS@%  printf( "%.0d", 0 );      /* No characters output */%@AE@%%@NL@%
%@NL@%
The precision specification may be an asterisk (%@AB@%*%@AE@%), in which case an %@AB@%int%@AE@%
argument from the argument list supplies the value. The %@AI@%precision%@AE@% argument
must precede the value being formatted in the argument list.  %@NL@%
%@NL@%
The interpretation of the precision value and the default when %@AI@%precision%@AE@% is
omitted depend on the type, as shown in Table R.4.  %@NL@%
%@NL@%
%@AB@%Table    R.4  How printf Precision Values Affect Type%@AE@%

%@TH:  41  2595 02 18 31 31 @%Type              Meaning                        Default%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%d, i, u, o, x, X%@AE@%  The precision specifies the    If %@AI@%precision%@AE@% is 0 or omitted                   minimum number of digits to    entirely, or if the period (%@AB@%.%@AE@%                  be printed. If the number of   ) appears without a number                   digits in the argument is      following it, the precision                   less than %@AI@%precision%@AE@%, the       is set to 1.                  output value is padded on the                    left with zeros. The value is                    not truncated when the number                    of digits exceeds %@AI@%precision%@AE@%.   %@AB@%e, E%@AE@%              The precision specifies the    Default precision is 6; if %@AI@%%@AE@%                  number of digits to be         %@AI@%precision%@AE@% is 0 or the period                   printed after the decimal      (%@AB@%.%@AE@%) appears without a number                   point. The last printed digit  following it, no decimal                   is rounded.                    point is printed. %@AB@%%@AE@%%@AB@%f%@AE@%                 The precision value specifies  Default precision is 6; if %@AI@%%@AE@%                  the number of digits after     %@AI@%precision%@AE@% is 0, or if the                   the decimal point. If a        period (%@AB@%.%@AE@%) appears without a                   decimal point appears, at      number following it, no                   least one digit appears        decimal point is printed.                  before it. The value is                          rounded to the appropriate                       number of digits.              %@AB@%g, G%@AE@%              The precision specifies the    Six significant digits are                   maximum number of significant  printed, with any trailing                   digits printed.                zeros truncated.%@AB@%c%@AE@%                 The precision has no effect.   Character is printed.%@AB@%s%@AE@%                 The precision specifies the    Characters are printed until                   maximum number of characters   a null character is                   to be printed. Characters in   encountered.                  excess of %@AI@%precision%@AE@% are not                      printed.                       %@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  41  2595 02 18 31 31 @%

If the argument corresponding to a floating-point specifier is infinite,
indefinite, or not a number (NAN), the %@AB@%printf%@AE@% function gives the following
output:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Output%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
+ infinity                        %@AB@%1.#INF%@AE@%%@AI@%random-digits%@AE@%

- infinity                        %@AB@%-1.#INF%@AE@%%@AI@%random-digits%@AE@%

Indefinite                        %@AI@%digit%@AE@%%@AB@%.#%@AE@%IND%@AI@%random-digits%@AE@%

NAN                               %@AI@%digit%@AE@%%@AB@%.#%@AE@%NAN%@AI@%random-digits%@AE@%

%@NL@%
%@4@%%@AB@%Size and Distance Specification%@AE@%%@EH@%%@NL@%
%@NL@%
For %@AB@%printf%@AE@%, the format specification fields %@AB@%F%@AE@% and %@AB@%N%@AE@% refer to the "distance"
to the object being read (%@AB@%near%@AE@% or %@AB@%far%@AE@%), and %@AB@%h%@AE@% and %@AB@%l%@AE@% refer to the "size" of
the object being read (16-bit %@AB@%short%@AE@% or 32-bit%@AB@% long%@AE@%). The following list
clarifies this use of %@AB@%F%@AE@%, %@AB@%N%@AE@%, %@AB@%h%@AE@%, %@AB@%l%@AE@%, and %@AB@%L%@AE@%:  %@NL@%
%@NL@%
%@AB@%Program Code%@AE@%                      %@AB@%Action%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%printf ("%Ns");%@AE@%                   Print%@AI@% %@AE@%%@AB@%near string%@AE@%

%@AB@%printf ("%Fs"); %@AE@%                  Print%@AI@% %@AE@%%@AB@%far string%@AE@%

%@AB@%printf ("%Nn");%@AE@%                   Store %@AB@%char%@AE@% count in %@AB@%near int%@AE@%

%@AB@%printf ("%Fn"); %@AE@%                  Store %@AB@%char%@AE@% count in %@AB@%far int%@AE@%

%@AB@%printf ("%hp");%@AE@%                   Print a 16-bit pointer (%@AI@%xxxx%@AE@%)

%@AB@%printf ("%lp"); %@AE@%                  Print a 32-bit pointer (%@AI@%xxxx%@AE@%:%@AI@%xxxx%@AE@%)

%@AB@%printf ("%Nhn"); %@AE@%                 Store %@AB@%char%@AE@% count%@AI@% %@AE@%in%@AI@% %@AE@%%@AB@%near short int%@AE@%

%@AB@%printf ("%Nln"); %@AE@%                 Store %@AB@%char %@AE@%count in %@AB@%near long int %@AE@%

%@AB@%printf ("%Fhn");%@AE@%                  Store %@AB@%char%@AE@% count%@AI@% %@AE@%in%@AI@% %@AE@%%@AB@%far short int %@AE@%

%@AB@%printf ("%Fln"); %@AE@%                 Store %@AB@%char%@AE@% count in%@AI@% %@AE@%%@AB@%far int%@AE@%

The specifications %@AB@%"%hs"%@AE@% and %@AB@%"%ls"%@AE@% are meaningless to%@AB@% printf%@AE@%. The
specifications %@AB@%"%Np"%@AE@% and %@AB@%"%Fp"%@AE@% are aliases for %@AB@%"%hp"%@AE@% and %@AB@%"%lp"%@AE@% for the sake
of compatibility with Microsoft C version 4.0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%printf%@AE@% function returns the number of characters printed, or a negative
value in the case of an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fprintf%@AE@%, %@AB@%scanf%@AE@%, %@AB@%sprintf%@AE@%, %@AB@%vfprintf%@AE@%, %@AB@%vprintf%@AE@%, %@AB@%vsprintf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PRINTF.C illustrates output formatting with printf. */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char   ch = 'h', *string = "computer";
%@AS@%     int    count = -9234;
%@AS@%     double fp = 251.7366;
%@AS@%  
%@AS@%     /* Display integers. */
%@AS@%     printf( "Integer formats:\n"
%@AS@%             "\tDecimal: %d  Justified: %.6d  Unsigned: %u\n",
%@AS@%              count, count, count, count );
%@AS@%  
%@AS@%     printf( "Decimal %d as:\n\tHex: %Xh  C hex: 0x%x  Octal: %o\n",
%@AS@%              count, count, count, count );
%@AS@%  
%@AS@%     /* Display in different radixes. */
%@AS@%     printf( "Digits 10 equal:\n\tHex: %i  Octal: %i  Decimal: %i\n",
%@AS@%              0x10, 010, 10 );
%@AS@%  
%@AS@%     /* Display characters. */
%@AS@%     printf( "Characters in field:\n%10c   %5c\n", ch, ch );
%@AS@%  
%@AS@%     /* Display strings. */
%@AS@%     printf( "Strings in field:\n%25s\n%25.4s\n", string, string );
%@AS@%  
%@AS@%     /* Display real numbers. */
%@AS@%     printf( "Real numbers:\n\t%f    %.2f    %e    %E\n", fp, fp, fp, fp );
%@AS@%  
%@AS@%     /* Display pointers. */
%@AS@%     printf( "Address as:\n\tDefault: %p  Near: %Np  Far: %Fp\n",
%@AS@%              &count, (int _near *)&count, (int _far *)&count );
%@AS@%  
%@AS@%     /* Count characters printed. */
%@AS@%     printf( "Display to here:\n" );
%@AS@%     printf( "1234567890123456%n78901234567890\n", &count );
%@AS@%     printf( "\tNumber displayed: %d\n\n", count );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Integer formats:
%@AS@%          Decimal: -9234  Justified: -009234  Unsigned: 56302
%@AS@%  Decimal -9234 as:
%@AS@%          Hex: DBEEh  C hex: 0xdbee  Octal: 155756
%@AS@%  Digits 10 equal:
%@AS@%          Hex: 16  Octal: 8  Decimal: 10
%@AS@%  Characters in field:
%@AS@%           h       h
%@AS@%  Strings in field:
%@AS@%                   computer
%@AS@%                       comp
%@AS@%  Real numbers:
%@AS@%          251.736600    251.74    2.517366e+002    2.517366E+002
%@AS@%  Address as:
%@AS@%          Default: 141C  Near: 141C  Far: 0087:141C
%@AS@%  Display to here:
%@AS@%  123456789012345678901234567890
%@AS@%          Number displayed: 16 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:putc@%%@QR:putchar@%%@NL@%
%@2@%%@CR:C6A02481179 @%%@AB@%putc, putchar%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02481180 @%%@CR:C6A02481181 @% %@CR:C6A02481182 @% %@CR:C6A02481183 @%%@CR:C6A02481184 @% %@CR:C6A02481185 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Writes a character to a stream (%@AB@%putc%@AE@%) or to %@AB@%stdout%@AE@% (%@AB@%putchar%@AE@%).  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int putc( int c, FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AS@%  int putchar( int c );%@AE@%%@NL@%
%@NL@%
%@AI@%c%@AE@%                                 Character to be written

%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%putc%@AE@% routine writes the single character %@AI@%c%@AE@% to the output %@AI@%stream%@AE@% at the
current position. The %@AB@%putchar%@AE@% routine is identical to %@AB@%putc(%@AE@%%@AI@%c%@AE@%%@AB@%, stdout)%@AE@%.  %@NL@%
%@NL@%
These routines are implemented as both macros and functions. See Section
1.4, "Choosing Between Functions and Macros," for a discussion of how to
select between the macro and function forms.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%putc%@AE@% and %@AB@%putchar%@AE@% routines return the character written, or %@AB@%EOF %@AE@%in the
case of an error. Any integer can be passed to %@AB@%putc%@AE@%, but only the lower 8
bits are written.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fputc%@AE@%, %@AB@%fputchar%@AE@%, %@AB@%getc%@AE@%, %@AB@%getchar%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PUTC.C: This program uses putc to write buffer to a stream.
%@AS@%   * If an error occurs, the program will stop before writing the
%@AS@%   * entire buffer.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE *stream;
%@AS@%     char *p, buffer[] = "This is the line of output\n";
%@AS@%     int  ch;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Make standard out the stream and write to it. */
%@AS@%     stream = stdout;
%@AS@%     for( p = buffer; (ch != EOF) && (*p != '\0'); p++ )
%@AS@%        ch = putc( *p, stream );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  This is the line of output %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:putch@%%@NL@%
%@2@%%@CR:C6A02491186 @%%@AB@%putch%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02491187 @%%@CR:C6A02491188 @% %@CR:C6A02491189 @%%@CR:C6A02491190 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Writes a character to the console.  %@NL@%
%@NL@%
%@AB@%#include <conio.h>%@AE@%                Required only for function declarations

%@AS@%  int putch( int c );%@AE@%%@NL@%
%@NL@%
%@AI@%c%@AE@%                                 Character to be output

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%putch%@AE@% function writes the character %@AI@%c%@AE@% directly (without buffering) to
the console.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns %@AI@%c%@AE@% if successful, and %@AB@%EOF%@AE@% if not.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cprintf%@AE@%, %@AB@%getch%@AE@%, %@AB@%getche%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GETCH.C: This program reads characters from the keyboard until it
%@AS@%   * receives a 'Y' or 'y'.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <ctype.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int ch;
%@AS@%  
%@AS@%     cputs( "Type 'Y' when finished typing keys: " );
%@AS@%     do
%@AS@%     {
%@AS@%        ch = getch();
%@AS@%        ch = toupper( ch );
%@AS@%     } while( ch != 'Y' );
%@AS@%  
%@AS@%     putch( ch );
%@AS@%     putch( '\r' );    /* Carriage return */
%@AS@%     putch( '\n' );    /* Line feed       */
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Type 'Y' when finished typing keys: Y %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:putenv@%%@NL@%
%@2@%%@CR:C6A02501191 @%%@AB@%putenv%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02501192 @%%@CR:C6A02501193 @% %@CR:C6A02501194 @%%@CR:C6A02501195 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Creates new environment variables.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AS@%  int putenv( char *envstring );%@AE@%%@NL@%
%@NL@%
%@AI@%envstring%@AE@%                         Environment-string definition

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%putenv%@AE@% function adds new environment variables or modifies the values of
existing environment variables. Environment variables define the environment
in which a process executes (for example, the default search path for
libraries to be linked with a program).  %@NL@%
%@NL@%
The %@AI@%envstring%@AE@% argument must be a pointer to a string with the form  %@NL@%
%@NL@%
%@AI@%%@AE@%varname=string  %@NL@%
%@NL@%
where %@AI@%varname%@AE@% is the name of the environment variable to be added or
modified and %@AI@%string%@AE@% is the variable's value. If %@AI@%varname%@AE@% is already part of
the environment, its value is replaced by %@AI@%string%@AE@%; otherwise, the new %@AI@%varname%@AE@%
variable and its %@AI@%string%@AE@% value are added to the environment. A variable can
be set to an empty value by specifying an empty %@AI@%string%@AE@%.  %@NL@%
%@NL@%
This function affects only the environment that is local to the currently
running process; it cannot be used to modify the command-level environment.
When the currently running process terminates, the environment reverts to
the level of the parent process (in most cases, the operating system level).
However, the environment affected by %@AB@%putenv%@AE@% can be passed to any child
processes created by %@AB@%spawn%@AE@%, %@AB@%exec%@AE@%, %@AB@%system%@AE@%, or (in OS/2 only) %@AB@%_popen%@AE@%, and
these child processes get any new items added by %@AB@%putenv%@AE@%.  %@NL@%
%@NL@%
Never free a pointer to an environment entry, because the environment
variable will then point to freed space. A similar problem can occur if you
pass %@AB@%putenv%@AE@% a pointer to a local variable, then exit the function in which
the variable is declared.  %@NL@%
%@NL@%
The %@AB@%putenv%@AE@% function operates only on data structures accessible to the
run-time library and not on the environment "segment" created for a process
by DOS or OS/2.  %@NL@%
%@NL@%
Note that environment-table entries must not be changed directly. If an
entry must be changed, use %@AB@%putenv%@AE@%. To modify the returned value without
affecting the environment table, use %@AB@%strdup%@AE@% or %@AB@%strcpy%@AE@% to make a copy of the
string.  %@NL@%
%@NL@%
The %@AB@%getenv%@AE@% and %@AB@%putenv%@AE@% functions use the global variable %@AB@%environ%@AE@% to access
the environment table. The %@AB@%putenv%@AE@% function may change the value of %@AB@%environ%@AE@%,
thus invalidating the %@AI@%envp %@AE@%argument to the%@AB@% main%@AE@% function. Therefore, it is
safer to use the%@AB@% environ%@AE@% variable to access the environment information.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%putenv%@AE@% function returns 0 if it is successful. A return value of -1
indicates an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%getenv%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GETENV.C: This program uses getenv to retrieve the LIB environment
%@AS@%   * variable and then uses putenv to change it to a new value.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  main()
%@AS@%  {
%@AS@%     char *libvar;
%@AS@%  
%@AS@%     /* Get the value of the LIB environment variable. */
%@AS@%     libvar = getenv( "LIB" );
%@AS@%     if( libvar != NULL )
%@AS@%        printf( "Original LIB variable is: %s\n", libvar );
%@AS@%  
%@AS@%     /* Attempt to change path. Note that this only affects the environment
%@AS@%      * variable of the current process. The command processor's environment
%@AS@%      * is not changed.
%@AS@%      */
%@AS@%     putenv( "LIB=c:\\mylib;c:\\yourlib" );
%@AS@%  
%@AS@%     /* Get new value. */
%@AS@%     libvar = getenv( "LIB" );
%@AS@%     if( libvar != NULL )
%@AS@%        printf( "New LIB variable is: %s\n", libvar );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Original LIB variable is: C:\LIB
%@AS@%  New LIB variable is: c:\mylib;c:\yourlib %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_putimage@%%@NL@%
%@2@%%@CR:C6A02511196 @%%@AB@%_putimage Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02511197 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Retrieve images from a buffer.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _putimage( short x, short y, char _huge *image, short action );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _putimage_w( double wx, double wy, char _huge *image, short
%@AS@%  action );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              Position of upper-left corner of image

%@AI@%image%@AE@%                             Stored image buffer

%@AI@%action%@AE@%                            Interaction with existing screen image

%@AI@%wx%@AE@%, %@AI@%wy%@AE@%                            Position of upper-left corner of image

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_putimage%@AE@% function transfers to the screen the image stored in the
buffer that %@AI@%image%@AE@% points to.  %@NL@%
%@NL@%
In the %@AB@%_putimage%@AE@% function, the upper-left corner of the image is placed at
the view coordinate point (%@AI@%x%@AE@%, %@AI@%y%@AE@%). In the %@AB@%_putimage_w%@AE@% function, the
upper-left corner of the image is placed at the window coordinate point (%@AI@%wx%@AE@%,
%@AI@%wy%@AE@%).  %@NL@%
%@NL@%
The %@AI@%action%@AE@% argument defines the interaction between the stored image and the
one that is already on the screen. It may be any one of the following
manifest constants (defined in GRAPH.H):  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_GAND%@AE@%                             Transfers the image over an existing 
                                  image on the screen. The resulting image
                                  is the logical-AND product of the two 
                                  images: points that had the same color 
                                  in both the existing image and the new 
                                  one will remain the same color, while 
                                  points that have different colors are 
                                  joined by logical-AND.

%@AB@%_GOR%@AE@%                              Superimposes the image onto an existing 
                                  image. The new image does not erase the 
                                  previous screen contents.

%@AB@%_GPRESET%@AE@%                          Transfers the data point-by-point onto 
                                  the screen. Each point has the inverse 
                                  of the color attribute it had when it 
                                  was taken from the screen by %@AB@%_getimage%@AE@%, 
                                  producing a negative image.

%@AB@%_GPSET%@AE@%                            Transfers the data point-by-point onto 
                                  the screen. Each point has the exact 
                                  color attribute it had when it was taken
                                  from the screen by %@AB@%_getimage%@AE@%.

%@AB@%_GXOR%@AE@%                             Causes the points on the screen to be 
                                  inverted where a point exists in the %@AI@%%@AE@%
                                  %@AI@%image%@AE@% buffer. This behavior is exactly 
                                  like that of the cursor: when an image 
                                  is put against a complex background 
                                  twice, the background is restored 
                                  unchanged. This allows you to move an 
                                  object around without erasing the 
                                  background. The %@AB@%_GXOR%@AE@% constant is a 
                                  special mode often used for animation.

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getimage%@AE@%, %@AB@% _imagesize%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_getimage%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:puts@%%@NL@%
%@2@%%@CR:C6A02521198 @%%@AB@%puts%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02521199 @%%@CR:C6A02521200 @% %@CR:C6A02521201 @%%@CR:C6A02521202 @%%@CR:C6A02521203 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Writes a string to %@AB@%stdout%@AE@%.  %@NL@%
%@NL@%
%@AB@%#include <stdio.h>%@AE@%  %@NL@%
%@NL@%
%@AS@%  int puts( const char *string );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            String to be output

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%puts%@AE@% function writes %@AI@%string%@AE@% to the standard output stream %@AB@%stdout%@AE@%,
replacing the string's terminating null character (%@AB@%'\0'%@AE@%) with a newline
character (%@AB@%\n%@AE@%) in the output stream.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%puts%@AE@% function returns a nonnegative value if it is successful. If the
function fails, it returns %@AB@%EOF%@AE@%.%@CR:C6A02521204 @%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fputs%@AE@%, %@AB@%gets%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PUTS.C: This program uses puts to write a string to stdout. */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     puts( "Hello world from puts!" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Hello world from puts! %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:putw@%%@NL@%
%@2@%%@CR:C6A02531205 @%%@AB@%putw%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02531206 @%%@CR:C6A02531207 @% %@CR:C6A02531208 @%%@CR:C6A02531209 @% %@CR:C6A02531210 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Writes an integer to a stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int putw( int binint, FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%binint%@AE@%                            Binary integer to be output

%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%putw%@AE@% function writes a binary value of type %@AB@%int%@AE@% to the current position
of %@AI@%stream%@AE@%. The %@AB@%putw%@AE@% function does not affect the alignment of items in the
stream, nor does it assume any special alignment.  %@NL@%
%@NL@%
The %@AB@%putw%@AE@% function is provided primarily for compatibility with previous
libraries. Note that portability problems may occur with %@AB@%putw%@AE@%, since the
size of an %@AB@%int%@AE@% and ordering of bytes within an %@AB@%int%@AE@% differ across systems.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%putw%@AE@% function returns the value written. A return value of %@AB@%EOF%@AE@% may
indicate an error. Since %@AB@%EOF%@AE@% is also a legitimate integer value, %@AB@%ferror%@AE@%
should be used to verify an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%getw%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PUTW.C: This program uses putw to write a word to a stream,
%@AS@%   * then performs an error check.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE *stream;
%@AS@%     unsigned u;
%@AS@%  
%@AS@%     if( (stream = fopen( "data.out", "wb" )) == NULL )
%@AS@%        exit( 1 );
%@AS@%     for( u = 0; u < 10; u++ )
%@AS@%     {
%@AS@%        putw( u + 0x2132, stdout );
%@AS@%        putw( u + 0x2132, stream );   /* Write word to stream. */
%@AS@%        if( ferror( stream ) )        /* Make error check. */
%@AS@%        {
%@AS@%           printf( "putw failed" );
%@AS@%           clearerr( stream );
%@AS@%           exit( 1 );
%@AS@%        }
%@AS@%     }
%@AS@%     printf( "\nWrote ten words\n" );
%@AS@%     fclose( stream );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  2!3!4!5!6!7!8!9!:!;!
%@AS@%  Wrote ten words %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:qsort@%%@NL@%
%@2@%%@CR:C6A02541211 @%%@AB@%qsort%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02541212 @%%@CR:C6A02541213 @% %@CR:C6A02541214 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Performs a quick sort.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               For ANSI compatibility

%@AB@%#include <search.h>%@AE@%               Required only for function declarations

%@AS@%  void qsort( void *base, size_t num, size_t width, 
%@AS@%  int( *compare ) ( const void *elem1, const void *elem2 ) );%@AE@%%@NL@%
%@NL@%
%@AI@%base%@AE@%                              Start of target array

%@AI@%num%@AE@%                               Array size in elements

%@AI@%width%@AE@%                             Element size in bytes

%@AI@%compare%@AE@%                           Comparison function

%@AI@%elem1%@AE@%                             Pointer to the key for the search

%@AI@%elem2%@AE@%                             Pointer to the array element to be 
                                  compared with the key

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%qsort%@AE@% function implements a quick-sort algorithm to sort an array of %@AI@%num%@AE@%
elements, each of %@AI@%width%@AE@% bytes. The argument %@AI@%base%@AE@% is a pointer to the base of
the array to be sorted. The %@AB@%qsort%@AE@% function overwrites this array with the
sorted elements.  %@NL@%
%@NL@%
The argument %@AI@%compare%@AE@% is a pointer to a user-supplied routine that compares
two array elements and returns a value specifying their relationship. The
%@AB@%qsort%@AE@% function calls the %@AI@%compare%@AE@% routine one or more times during the sort,
passing pointers to two array elements on each call:  %@NL@%
%@NL@%
%@AI@%compare%@AE@%%@AB@%( (void *)%@AE@% %@AI@%elem1%@AE@%%@AB@%,%@AE@% %@AB@%(void *)%@AE@% %@AI@%elem2%@AE@% %@AB@%);%@AE@%  %@NL@%
%@NL@%
The routine must compare the elements, then return one of the following
values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
< 0                               %@AI@%elem1%@AE@% less than %@AI@%elem2%@AE@%

= 0                               %@AI@%elem1%@AE@% equivalent to %@AI@%elem2%@AE@%

> 0                               %@AI@%elem1%@AE@% greater than %@AI@%elem2%@AE@%

The array is sorted in increasing order, as defined by the comparison
function. To sort an array in decreasing order, reverse the sense of
"greater than" and "less than" in the comparison function.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%bsearch%@AE@%, %@AB@%lsearch%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* QSORT.C: This program reads the command-line parameters and
%@AS@%   * uses qsort to sort them. It then displays the sorted arguments.
%@AS@%   */
%@AS@%  
%@AS@%  #include <search.h>
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  int compare( char **arg1, char **arg2 );  /* Prototype */
%@AS@%  
%@AS@%  void main( int argc, char **argv )
%@AS@%  {
%@AS@%     int i;
%@AS@%  
%@AS@%     /* Eliminate argv[0] from sort: */
%@AS@%     argv++;
%@AS@%     argcÄ;
%@AS@%  
%@AS@%     /* Sort remaining args using Quicksort algorithm: */
%@AS@%     qsort( (void *)argv, (size_t)argc, sizeof( char * ), compare );
%@AS@%  
%@AS@%     /* Output sorted list: */
%@AS@%     for( i = 0; i < argc; ++i )
%@AS@%        printf( "%s ", argv[i] );
%@AS@%     printf( "\n" );
%@AS@%  }
%@AS@%  
%@AS@%  int compare( char **arg1, char **arg2 )
%@AS@%  {
%@AS@%     /* Compare all of both strings: */
%@AS@%     return strcmpi( *arg1, *arg2 );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  [C:\LIBREF] qsort every good boy deserves favor
%@AS@%  boy deserves every favor good%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:raise@%%@NL@%
%@2@%%@CR:C6A02551215 @%%@AB@%raise%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02551216 @%%@CR:C6A02551217 @%%@CR:C6A02551218 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sends a signal to the executing program.  %@NL@%
%@NL@%
%@AS@%  #include <signal.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int raise( int sig );%@AE@%%@NL@%
%@NL@%
%@AI@%sig%@AE@%                               Signal to be raised

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%raise%@AE@% function sends %@AI@%sig%@AE@% to the executing program. If a signal-handling
routine for %@AI@%sig%@AE@% has ben installed by a prior call to %@AB@%signal%@AE@%, %@AB@%raise %@AE@%causes
that routine to be executed. If no handler routine has been installed, the
default action (as listed below) is taken.%@AI@%  %@AE@%%@NL@%
%@NL@%
The signal value %@AI@%sig%@AE@% can be one of the following manifest constants:  %@NL@%
%@NL@%
%@TH:  36  1916 02 23 27 27 @%%@AB@%Signal%@AE@%                 %@AB@%Meaning%@AE@%                    %@AB@%Default%@AE@%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%SIGABRT%@AE@%                Abnormal termination.      Terminates the calling                                                   program with exit code 3.%@AB@%SIGBREAK%@AE@%               CTRL+ BREAK interrupt.     Terminates the calling                                                   program with exit code 3.%@AB@%SIGFPE%@AE@%                 Floating-point error.      Terminates the calling                                                   program.%@AB@%SIGILL%@AE@%                 Illegal instruction. This  Terminates the calling                        signal is not generated    program.                       by DOS or OS/2, but is                            supported for ANSI                                compatibility.             %@AB@%SIGINT%@AE@%                 CTRL+ C interrupt.         Issues INT23H.%@AB@%SIGSEGV%@AE@%                Illegal storage access.    Terminates the calling                        This signal is not         program.                       generated by DOS or OS/2,                         but is supported for ANSI                         compatiblity.              %@AB@%SIGTERM%@AE@%                Termination request sent   Ignores the signal.                       to the program. This                              signal is not generated                           by DOS or OS/2, but is                            supported for ANSI                                compatibility.             %@AB@%SIGUSR1%@AE@%                User-defined signals.      Ignores the signal.%@AB@%SIGUSR2%@AE@%                                           %@AB@%SIGUSR3%@AE@%                                           %@TE:  36  1916 02 23 27 27 @%

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the %@AB@%raise%@AE@% function returns 0. Otherwise, it returns a nonzero
value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%abort%@AE@%, %@AB@%signal%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%signal%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:rand@%%@NL@%
%@2@%%@CR:C6A02561219 @%%@AB@%rand%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02561220 @%%@CR:C6A02561221 @%%@CR:C6A02561222 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Generates a pseudorandom number.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h> %@AE@%              Required only for function declarations

%@AS@%  int rand( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%rand%@AE@% function returns a pseudorandom integer in the range 0 to %@AB@%RAND_MAX.
%@AB@%%@AE@%The %@AB@%srand%@AE@% routine can be used to seed the pseudorandom-number generator
before calling %@AB@%rand%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%rand%@AE@% function returns a pseudorandom number, as described above. There
is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%srand%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* RAND.C: This program seeds the random-number generator with the
%@AS@%   * time, then displays 20 random integers.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <time.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int i;
%@AS@%  
%@AS@%     /* Seed the random-number generator with current time so that
%@AS@%      * the numbers will be different every time we run.
%@AS@%      */
%@AS@%     srand( (unsigned)time( NULL ) );
%@AS@%  
%@AS@%     /* Display 10 numbers. */
%@AS@%     for( i = 0; i < 10; i++ )
%@AS@%         printf( "  %6d\n", rand() );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%     19471
%@AS@%     16395
%@AS@%      8268
%@AS@%     15582
%@AS@%      6489
%@AS@%     28356
%@AS@%     27042
%@AS@%      5276
%@AS@%     23070
%@AS@%     10930%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:read@%%@NL@%
%@2@%%@CR:C6A02571223 @%%@AB@%read%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02571224 @%%@CR:C6A02571225 @% %@CR:C6A02571226 @%%@CR:C6A02571227 @% %@CR:C6A02571228 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Reads data from a file.  %@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  int read( int handle, void *buffer, unsigned int count );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Handle referring to open file

%@AI@%buffer%@AE@%                            Storage location for data

%@AI@%count%@AE@%                             Maximum number of bytes

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%read%@AE@% function attempts to read %@AI@%count%@AE@% bytes into %@AI@%buffer%@AE@% from the file
associated with %@AI@%handle%@AE@%. The read operation begins at the current position of
the file pointer associated with the given file. After the read operation,
the file pointer points to the next unread character.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%read%@AE@% function returns the number of bytes actually read, which may be
less than %@AI@%count%@AE@% if there are fewer than %@AI@%count%@AE@% bytes left in the file, or if
the file was opened in text mode (see below). The return value 0 indicates
an attempt to read at end-of-file. The return value -1 indicates an error,
and %@AB@%errno%@AE@% is set to the following value:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EBADF%@AE@%                             The given %@AI@%handle%@AE@% is invalid; or the file
                                  is not open for reading; or (DOS 
                                  versions 3.0 and later and OS/2 only) 
                                  the file is locked.

If you are reading more than 32K (the maximum size for type %@AB@%int%@AE@%) from a
file, the return value should be of type %@AB@%unsigned int%@AE@% (see the example that
follows). However, the maximum number of bytes that can be read from a file
in one operation is 65,534, since 65,535 (or 0xFFFF) is indistinguishable
from -1, and therefore cannot be distinguished from an error return.%@AB@%  %@AE@%%@NL@%
%@NL@%
If the file was opened in text mode, the return value may not correspond to
the number of bytes actually read. When text mode is in effect, each
carriage-return-line-feed (CR-LF) pair is replaced with a single line-feed
character. Only the single line-feed character is counted in the return
value. The replacement does not affect the file pointer.  %@NL@%
%@NL@%
Note that under DOS and OS/2, when files are opened in text mode, a CTRL+Z
character is treated as an end-of-file indicator. When the CTRL+Z is
encountered, the read terminates, and the next read returns 0 bytes. The
%@AB@%lseek%@AE@% function will clear the end-of-file indicator.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%creat%@AE@%, %@AB@%fread%@AE@%, %@AB@%open%@AE@%, %@AB@%write%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* READ.C: This program opens a file named READ.C and tries to read 60,000
%@AS@%   * bytes from that file using read. It then displays the actual
%@AS@%   * number of bytes read from READ.C.
%@AS@%   */
%@AS@%  
%@AS@%  #include <fcntl.h>      /* Needed only for O_RDWR definition */
%@AS@%  #include <io.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  char buffer[60000];
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh;
%@AS@%     unsigned int nbytes = 60000, bytesread;
%@AS@%  
%@AS@%     /* Open file for input: */
%@AS@%     if( (fh = open( "read.c", O_RDONLY )) == -1 )
%@AS@%     {
%@AS@%        perror( "open failed on input file" );
%@AS@%        exit( 1 );
%@AS@%     }
%@AS@%  
%@AS@%     /* Read in input: */
%@AS@%     if( ( bytesread = read( fh, buffer, nbytes ) ) <= 0 )
%@AS@%        perror( "Problem reading file" );
%@AS@%     else
%@AS@%        printf( "Read %u bytes from file\n", bytesread );
%@AS@%  
%@AS@%     close( fh );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Read 747 bytes from file %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:realloc@%%@NL@%
%@2@%%@CR:C6A02581229 @%%@AB@%realloc Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02581230 @%%@CR:C6A02581231 @% %@CR:C6A02581232 @%%@CR:C6A02581233 @% %@CR:C6A02581234 @%%@CR:C6A02581235 @% %@CR:C6A02581236 @%%@CR:C6A02581237 @% %@CR:C6A02581238 @%%@CR:C6A02581239 @% %@CR:C6A02581240 @%%@EH@%
%@AB@%%@CR:C6A02581241 @%%@AE@%%@NL@%
%@NL@%
%@CR:C6A02581242 @%#include <stdlib.h>  %@NL@%
%@NL@%
                                  For ANSI compatibility (%@AB@%realloc%@AE@% only)

%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  void *realloc( void *memblock, size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _based( void ) *_brealloc( _segment seg, void _based( void )
%@AS@%  *memblock, 
%@AS@%  size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far *_frealloc( void _far *memblock, size_t size );%@AE@%%@NL@%
%@NL@%
%@AS@%  void _near *_nrealloc( void _near *memblock, size_t size );%@AE@%%@NL@%
%@NL@%
%@AI@%memblock%@AE@%                          Pointer to previously allocated memory 
                                  block

%@AI@%size%@AE@%                              New size in bytes

%@AI@%seg%@AE@%                               Segment selector

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%realloc%@AE@% family of functions changes the size of a previously allocated
memory block. The %@AI@%memblock%@AE@% argument points to the beginning of the memory
block. If %@AI@%memblock%@AE@% is %@AB@%NULL%@AE@%, %@AB@%realloc%@AE@% functions in the same way as %@AB@%malloc%@AE@% and
allocates a new block of %@AI@%size%@AE@% bytes. If %@AI@%memblock%@AE@% is not %@AB@%NULL,%@AE@% it should be a
pointer returned by %@AB@%calloc%@AE@%, %@AB@%malloc%@AE@%, or a prior call to %@AB@%realloc%@AE@%.  %@NL@%
%@NL@%
The %@AI@%size%@AE@% argument gives the new size of the block, in bytes. The contents of
the block are unchanged up to the shorter of the new and old sizes, although
the new block may be in a different location.  %@NL@%
%@NL@%
The %@AI@%memblock%@AE@% argument can also point to a block that has been freed, as long
as there has been no intervening call to the corresponding %@AB@%calloc%@AE@%, %@AB@%malloc%@AE@%,
%@AB@%_expand%@AE@%, or %@AB@%realloc%@AE@% function. If successful, the reallocated block is marked
in use.  %@NL@%
%@NL@%
In large data models (that is, compact-, large-, and huge-model programs),
%@AB@%realloc%@AE@% maps to %@AB@%_frealloc%@AE@%. In small data models (tiny-, small-, and
medium-model programs), %@AB@%realloc%@AE@% maps to %@AB@%_nrealloc%@AE@%.  %@NL@%
%@NL@%
The various %@AB@%realloc%@AE@% functions reallocate memory in the heap specified in the
following list:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Heap%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%realloc%@AE@%                           Depends on data model of program

%@AB@%_brealloc%@AE@%                         Based heap specified by %@AI@%seg%@AE@% value

%@AB@%_frealloc%@AE@%                         Far heap (outside default data segment)

%@AB@%_nrealloc%@AE@%                         Near heap (inside default data segment)

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%realloc%@AE@% functions return a %@AB@%void%@AE@% pointer to the reallocated (and possibly
moved) memory block.  %@NL@%
%@NL@%
The return value is %@AB@%NULL%@AE@% if the size is zero and the buffer argument is not
%@AB@%NULL%@AE@%, or if there is not enough available memory to expand the block to the
given size. In the first case, the original block is freed. In the second,
the original block is unchanged.  %@NL@%
%@NL@%
The storage space pointed to by the return value is guaranteed to be
suitably aligned for storage of any type of object. To get a pointer to a
type other than %@AB@%void%@AE@%, use a type cast on the return value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%realloc%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_brealloc%@AE@%, %@AB@% _frealloc%@AE@%, %@AB@% _nrealloc%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%calloc%@AE@% functions, %@AB@%free%@AE@% functions, %@AB@%malloc%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* REALLOC.C: This program allocates a block of memory for buffer
%@AS@%   * and then uses _msize to display the size of that block. Next, it
%@AS@%   * uses realloc to expand the amount of memory used by buffer
%@AS@%   * and then calls _msize again to display the new amount of
%@AS@%   * memory allocated to buffer.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <stdio.h>
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     long *buffer;
%@AS@%     size_t size;
%@AS@%  
%@AS@%     if( (buffer = (long *)malloc( 1000 * sizeof( long ) )) == NULL )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     size = _msize( buffer );
%@AS@%     printf( "Size of block after malloc of 1000 longs: %u\n", size );
%@AS@%  
%@AS@%     /* Reallocate and show new size: */
%@AS@%     if( (buffer = realloc( buffer, size + (1000 * sizeof( long )) )) ==
%@AS@%NULL )
%@AS@%        exit( 1 );
%@AS@%     size = _msize( buffer );
%@AS@%     printf( "Size of block after realloc of 1000 more longs: %u\n", size );
%@AS@%  
%@AS@%     free( buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Size of block after malloc of 1000 longs: 4000
%@AS@%  Size of block after realloc of 1000 more longs: 8000 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_rectangle@%%@NL@%
%@2@%%@CR:C6A02591243 @%%@AB@%_rectangle Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02591244 @% %@CR:C6A02591245 @% %@CR:C6A02591246 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Draw rectangles.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _rectangle( short control, short x1, short y1, short x2, short
%@AS@%  y2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _rectangle_w( short control, double wx1, double wy1, double
%@AS@%  wx2, 
%@AS@%  double wy2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _rectangle_wxy( short control, struct _wxycoord _far *pwxy1, 
%@AS@%  struct _wxycoord _far *pwxy2 );%@AE@%%@NL@%
%@NL@%
%@AI@%control%@AE@%                           Fill flag

%@AI@%x1%@AE@%, %@AI@%y1%@AE@%                            Upper-left corner

%@AI@%x2%@AE@%, %@AI@%y2%@AE@%                            Lower-right corner

%@AI@%wx1%@AE@%, %@AI@%wy1%@AE@%                          Upper-left corner

%@AI@%wx2%@AE@%, %@AI@%wy2%@AE@%                          Lower-right corner

%@AI@%pwxy1%@AE@%                             Upper-left corner

%@AI@%pwxy2%@AE@%                             Lower-right corner

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_rectangle%@AE@% functions draw a rectangle with the current line style.  %@NL@%
%@NL@%
The %@AB@%_rectangle%@AE@% function uses the view coordinate system. The view coordinate
points  (%@AI@%x1%@AE@%, %@AI@%y1%@AE@%) and (%@AI@%x2%@AE@%, %@AI@%y2%@AE@%) are the diagonally opposed corners of the
rectangle.  %@NL@%
%@NL@%
The %@AB@%_rectangle_w%@AE@% function uses the window coordinate system. The window
coordinate points (%@AI@%wx1%@AE@%, %@AI@%wy1%@AE@%) and (%@AI@%wx2%@AE@%, %@AI@%wy2%@AE@%) are the diagonally opposed
corners of the rectangle.  %@NL@%
%@NL@%
The %@AB@%_rectangle_wxy%@AE@% function uses the window coordinate system. The window
coordinate points (%@AI@%pwxy1%@AE@%) and (%@AI@%pwxy2%@AE@%) are the diagonally opposed corners of
the rectangle. The coordinates for the %@AB@%_rectangle_wxy%@AE@% routine are given in
terms of an %@AB@%_wxycoord%@AE@% structure (defined in GRAPH.H), which contains the
following elements:  %@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%double wx%@AE@%                         window %@AI@%x%@AE@% coordinate

%@AB@%double wy%@AE@%                         window %@AI@%y%@AE@% coordinate

The %@AI@%control%@AE@% parameter can be one of the following manifest constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Action%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_GFILLINTERIOR%@AE@%                    Fills the figure with the current color 
                                  using the current fill mask

%@AB@%_GBORDER%@AE@%                          Does not fill the rectangle

If the current fill mask is %@AB@%NULL%@AE@%, no mask is used. Instead, the rectangle is
filled with the current color.  %@NL@%
%@NL@%
If you try to fill the rectangle with the %@AB@%_floodfill%@AE@% function, the rectangle
must be bordered by a solid line-style pattern.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns a nonzero value if the rectangle is drawn successfully,
or 0 if not.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_arc %@AE@%functions,  %@AB@%_ellipse %@AE@%functions,%@AB@%  _floodfill%@AE@%, %@AB@% _getcolor%@AE@%,  %@AB@%_lineto
%@AB@%%@AE@%functions, %@AB@%_pie %@AE@%functions,  %@AB@%_setcolor%@AE@%, %@AB@% _setfillmask%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* RECT.C: This program draws a rectangle. */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     _rectangle( _GBORDER, 80, 50, 240, 150 );
%@AS@%  
%@AS@%     getch();
%@AS@%  
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_registerfonts@%%@NL@%
%@2@%%@CR:C6A02601247 @%%@AB@%_registerfonts%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02601248 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Initializes the fonts graphics system.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _registerfonts( unsigned char _far *pathname );%@AE@%%@NL@%
%@NL@%
%@AI@%pathname%@AE@%                          Path name specifying .FON files to be 
                                  registered

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_registerfonts%@AE@% function initializes the fonts graphics system. Font
files must be registered with the %@AB@%_registerfonts%@AE@% function before any other
font-related library function (%@AB@%_getgtextextent%@AE@%, %@AB@%_outgtext%@AE@%, %@AB@%_setfont%@AE@%,
%@AB@%_unregisterfonts%@AE@%) can be used.  %@NL@%
%@NL@%
The %@AB@%_registerfonts%@AE@% function reads the specified files and loads font header
information into memory. Each font header takes up about 140 bytes of
memory.  %@NL@%
%@NL@%
The %@AI@%pathname%@AE@% argument is the path specification and file name of valid .FON
files. The %@AI@%pathname%@AE@% can contain standard DOS wild-card characters.  %@NL@%
%@NL@%
The font functions affect only the output from the font output function
%@AB@%_outgtext%@AE@%; no other C run-time output functions are affected by font usage.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_registerfonts%@AE@% function returns a positive value which indicates the
number of fonts successfully registered. A negative return value indicates
failure. The following negative values may be returned:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
-1                                No such file or directory.

-2                                One or more of the .FON files was not a
                                  valid, binary .FON file.

-3                                One or more of the .FON files is 
                                  damaged.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@% _getfontinfo%@AE@%,  %@AB@%_getgtextextent%@AE@%,  %@AB@%_outgtext%@AE@%, %@AB@% _setfont%@AE@%,  %@AB@%_unregisterfonts%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_outgtext%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_remapallpalette@%%@QR:_remappalette@%%@NL@%
%@2@%%@CR:C6A02611249 @%%@AB@%_remapallpalette, _remappalette%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02611250 @% %@CR:C6A02611251 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Remap all palette colors.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _remapallpalette( long _far *colors );%@AE@%%@NL@%
%@NL@%
%@AS@%  long _far _remappalette( short index, long color );%@AE@%%@NL@%
%@NL@%
%@AI@%colors%@AE@%                            Color value array

%@AI@%index%@AE@%                             Color index to reassign

%@AI@%color%@AE@%                             Color value to assign color index to

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_remapallpalette%@AE@% function remaps the entire color palette simultaneously
to the colors given in the %@AI@%colors%@AE@% array. The %@AI@%colors%@AE@% array is an array of
%@AB@%long%@AE@% integers where the size of the array varies from 16 to 64 to 256,
depending on the video mode. The number of colors mapped depends on the
number of colors supported by the current video mode. The %@AB@%_remapallpalette%@AE@%
function works in all video modes (except %@AB@%_ORESCOLOR%@AE@% mode), but only with
EGA, MCGA, or VGA hardware.  %@NL@%
%@NL@%
The default color values for a color text on 16-color graphics mode are
shown below:  %@NL@%
%@NL@%
%@TH:  18   513 02 08 10 08 50 @%%@AB@%Number%@AE@%  %@AB@%Color%@AE@%     %@AB@%Number%@AE@%  %@AB@%Color%@AE@%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%0       Black     8       Dark gray1       Blue      9       Light blue2       Green     10      Light green3       Cyan      11      Light cyan4       Red       12      Light red5       Magenta   13      Light magenta6       Brown     14      Yellow7       White     15      Bright white%@TE:  18   513 02 08 10 08 50 @%

The first array element specifies the new color value to be associated with
color index 0 (the background color in graphics modes). After the call to
%@AB@%_remapallpalette%@AE@%, calls to %@AB@%_setcolor%@AE@% will index into the new array of
colors. The mapping done by %@AB@%_remapallpalette%@AE@% affects the current display
immediately.  %@NL@%
%@NL@%
The %@AI@%colors%@AE@% array can be larger than the number of colors supported by the
current video mode, but only the first %@AI@%n%@AE@% elements are used, where %@AI@%n%@AE@% is the
number of colors supported by the current video mode, as indicated by the
%@AB@%numcolors%@AE@% element of the %@AB@%videoconfig%@AE@%  structure.  %@NL@%
%@NL@%
The %@AB@%long%@AE@% color value is defined by specifying three bytes of data
representing the three component colors: red, green, and blue.  %@NL@%
%@NL@%
Each of the three bytes represents the intensity of one of the red, green,
or blue component colors, and must be in the range 0-31. In other words, the
low-order six bits of each byte specify the component's intensity and the
high-order two bits should be zero. The fourth (high-order) byte in the %@AB@%long%@AE@%
is unused and should be set to zero. The diagram below shows the ordering of
bytes within the %@AB@%long%@AE@% value.  %@NL@%
%@NL@%
For example, to create a lighter shade of blue, start with lots of blue, add
some green, and maybe a little bit of red. The three-byte color value would
be:  %@NL@%
%@NL@%
%@AS@%  blue byte            green byte        red byte
%@AS@%  00011111             00101111          00011111
%@AS@%  high ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ->  low order %@AE@%%@NL@%
%@NL@%
Manifest constants are defined in GRAPH.H for the default color values
corresponding to color indices 0-15 in color text modes and 16-color
graphics modes, as shown below:  %@NL@%
%@NL@%
%@TH:  18   702 02 07 11 07 51 @%%@AB@%Index%@AE@%  %@AB@%Constant%@AE@%   %@AB@%Index%@AE@%  %@AB@%Constant%@AE@%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%0      %@AB@%_BLACK %@AE@%    8      %@AB@%_GRAY %@AE@%1      %@AB@%_BLUE %@AE@%     9      %@AB@%_LIGHTBLUE %@AE@%2      %@AB@%_GREEN %@AE@%    10     %@AB@%_LIGHTGREEN %@AE@%3      %@AB@%_CYAN %@AE@%     11     %@AB@%_LIGHTCYAN%@AE@%4      %@AB@%_RED %@AE@%      12     %@AB@%_LIGHTRED %@AE@%5      %@AB@%_MAGENTA %@AE@%  13     %@AB@%_LIGHTMAGENTA%@AE@% 6      %@AB@%_BROWN %@AE@%    14     %@AB@%_YELLOW %@AE@%7      %@AB@%_WHITE %@AE@%    15     %@AB@%_BRIGHTWHITE%@AE@%%@TE:  18   702 02 07 11 07 51 @%

The VGA supports a palette of 262,144 colors (256K) in color modes, and the
EGA supports a palette of only 64 different colors. Color values for EGA are
specified in exactly the same way as with the VGA; however, the low-order
four bits of each byte are simply ignored.  %@NL@%
%@NL@%
The %@AB@%_remappalette%@AE@% function assigns a new color value %@AI@%color%@AE@% to the color
index given by %@AI@%index%@AE@%. This remapping affects the current display
immediately.  %@NL@%
%@NL@%
The %@AB@%_remappalette%@AE@% function works in all graphics modes, but only with EGA,
MCGA, or VGA hardware. An error results if the function is called while
using any other configuration.  %@NL@%
%@NL@%
The color value used in %@AB@%_remappalette%@AE@% is defined and used exactly as noted
above for %@AB@%_remapallpalette%@AE@%. The range of color indices used with
%@AB@%_remappalette%@AE@% depends on the number of colors supported by the video mode.  %@NL@%
%@NL@%
The %@AB@%_remapallpalette%@AE@% and %@AB@%_remappalette%@AE@% functions do not affect the
presentation-graphics palettes, which are manipulated with the
%@AB@%_pg_getpalette%@AE@%, %@AB@%_pg_setpalette%@AE@%, and %@AB@%_pg_resetpalette%@AE@% functions.  %@NL@%
%@NL@%
If a VGA or MCGA adapter is connected to an analog monochrome monitor, the
color value is transformed into its gray-scale equivalent, based on the
weighted sum of its red, green, and blue components (30% red + 50% green +
11% blue). The original red, green, and blue values are lost.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, %@AB@%_remapallpalette%@AE@% returns -1 (short). In case of an error,
%@AB@%_remapallpalette%@AE@% returns 0 (short).  %@NL@%
%@NL@%
If successful, %@AB@%_remappalette %@AE@%returns the color value previously assigned to%@AB@%
%@AS@%%@AE@%%@AI@%index%@AE@%, or -1 if the function is inoperative (not EGA, VGA, or MCGA), or if
the color index is out of range.  %@NL@%
%@NL@%
Note that %@AB@%_remapallpalette%@AE@% returns a %@AB@%short%@AE@% value and %@AB@%_remappalette%@AE@% returns a
%@AB@%long%@AE@% value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@%_selectpalette, %@AB@% _setbkcolor,  _setvideomode%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* RMPALPAL.C: This example illustrates functions for assigning
%@AS@%   * color values to color indices. Functions illustrated include:
%@AS@%   *    _remappalette         _remapallpalette
%@AS@%   */
%@AS@%  
%@AS@%  #include <graph.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  /* Macro for mixing Red, Green, and Blue elements of color */
%@AS@%  #define RGB(r,g,b) (((long) ((b) << 8 | (g)) << 8) | (r))%@AE@%%@NL@%
%@NL@%
%@AS@%  long tmp, pal[256];
%@AS@%  void main()
%@AS@%  {
%@AS@%     short  red, blue, green;
%@AS@%     short  inc, i, mode, cells, x, y, xinc, yinc;
%@AS@%     char   buf[40];
%@AS@%     struct videoconfig vc;
%@AS@%  
%@AS@%     /* Make sure all palette numbers are valid. */
%@AS@%     for( i = 0; i < 256; i++ )
%@AS@%        pal[i] = _BLACK;
%@AS@%  
%@AS@%     /* Loop through each graphics mode that supports palettes. */
%@AS@%     for( mode = _MRES4COLOR; mode <= _MRES256COLOR; mode++ )
%@AS@%     {
%@AS@%        if( mode == _ERESNOCOLOR )
%@AS@%           mode++;
%@AS@%        if( !_setvideomode( mode ) )
%@AS@%           continue;
%@AS@%  
%@AS@%        /* Set variables for each mode. */
%@AS@%        _getvideoconfig( &vc );
%@AS@%        switch( vc.numcolors )
%@AS@%        {
%@AS@%           case 256:          /* Active bits in this order:           */
%@AS@%              cells = 13;
%@AS@%              inc = 12;       /* ???????? ??bbbbbb ??gggggg ??rrrrrr  */
%@AS@%              break;
%@AS@%           case  16:
%@AS@%              cells = 4;
%@AS@%              if( (vc.mode == _ERESCOLOR) || (vc.mode == _VRES16COLOR) )
%@AS@%                 inc = 16;    /* ???????? ??bb???? ??gg???? ??rr????  */
%@AS@%              else
%@AS@%                 inc = 32;    /* ???????? ??Bb???? ??Gg???? ??Rr????  */
%@AS@%              break;
%@AS@%           case   4:
%@AS@%              cells = 2;
%@AS@%              inc = 32;       /* ???????? ??Bb???? ??Gg???? ??Rr????  */
%@AS@%              break;
%@AS@%           default:
%@AS@%               continue;
%@AS@%        }
%@AS@%        xinc = vc.numxpixels / cells;
%@AS@%        yinc = vc.numypixels / cells;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Fill palette arrays in BGR order. */
%@AS@%        for( i = 0, blue = 0; blue < 64; blue += inc )
%@AS@%           for( green = 0; green < 64; green += inc )
%@AS@%              for( red = 0; red < 64; red += inc )
%@AS@%              {
%@AS@%                 pal[i] = RGB( red, green, blue );
%@AS@%                 /* Special case of using 6 bits to represent 16 colors.
%@AS@%                  * If both bits are on for any color, intensity is set.
%@AS@%                  * If one bit is set for a color, the color is on.
%@AS@%                  */
%@AS@%                 if( inc == 32 )
%@AS@%                    pal[i + 8] = pal[i] | (pal[i] >> 1);
%@AS@%                 i++;
%@AS@%              }
%@AS@%  
%@AS@%        /* If palettes available, remap all palettes at once. */
%@AS@%        if( !_remapallpalette( pal ) )
%@AS@%        {
%@AS@%           _setvideomode( _DEFAULTMODE );
%@AS@%           _outtext( "Palettes not available with this adapter" );
%@AS@%           exit( 1 );
%@AS@%        }
%@AS@%  
%@AS@%        /* Draw colored squares. */
%@AS@%        for( i = 0, x = 0; x < ( xinc * cells ); x += xinc )
%@AS@%           for( y = 0; y < ( yinc * cells); y += yinc )
%@AS@%           {
%@AS@%              _setcolor( i++ );
%@AS@%              _rectangle( _GFILLINTERIOR, x, y, x + xinc, y + yinc );
%@AS@%           }
%@AS@%  
%@AS@%        /* Note that for 256-color mode, not all colors are shown. The
%@AS@%number
%@AS@%         * of colors from mixing three base colors can never be the same as
%@AS@%         * the number that can be shown on a two-dimensional grid.
%@AS@%         */
%@AS@%        sprintf( buf, "Mode %d has %d colors", vc.mode, vc.numcolors );
%@AS@%        _setcolor( vc.numcolors / 2 );
%@AS@%        _outtext( buf );
%@AS@%        getch();%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Change each palette entry separately in GRB order. */
%@AS@%        for( i = 0, green = 0; green < 64; green += inc )
%@AS@%           for( red = 0; red < 64; red += inc )
%@AS@%              for(blue = 0; blue < 64; blue += inc )
%@AS@%              {
%@AS@%                 tmp = RGB( red, green, blue );
%@AS@%                 _remappalette( i, tmp );
%@AS@%                 if( inc == 32 )
%@AS@%                    _remappalette( i + 8, tmp | (tmp >> 1) );
%@AS@%                 i++;
%@AS@%              }
%@AS@%        getch();
%@AS@%     }
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:remove@%%@NL@%
%@2@%%@CR:C6A02621252 @%%@AB@%remove%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02621253 @%%@CR:C6A02621254 @%%@CR:C6A02621255 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Deletes a file.  %@NL@%
%@NL@%
%@AB@%#include <stdio.h>%@AE@%                Required for ANSI compatibility

%@AB@%#include <io.h>%@AE@%                   Use either IO.H or STDIO.H

%@AS@%  int remove( const char *path );%@AE@%%@NL@%
%@NL@%
%@AI@%path%@AE@%                              Path name of file to be removed

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%remove%@AE@% function deletes the file specified by %@AI@%path%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns 0 if the file is successfully deleted. Otherwise, it
returns -1 and sets %@AB@%errno%@AE@% to one of these values:  %@NL@%
%@NL@%
%@AB@%Value %@AE@%                            %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Path name specifies a read-only file.

%@AB@%ENOENT%@AE@%                            File or path name not found, or path 
                                  name specifies a directory.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@%unlink  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* REMOVE.C: This program uses remove to delete REMOVE.OBJ. */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     if( remove( "remove.obj" ) == -1 )
%@AS@%        perror( "Could not delete 'REMOVE.OBJ'" );
%@AS@%     else
%@AS@%        printf( "Deleted 'REMOVE.OBJ'\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Deleted 'REMOVE.OBJ' %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:rename@%%@NL@%
%@2@%%@CR:C6A02631256 @%%@AB@%rename%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02631257 @%%@CR:C6A02631258 @%%@CR:C6A02631259 @% %@CR:C6A02631260 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Renames a file or directory.  %@NL@%
%@NL@%
%@AB@%#include <stdio.h>%@AE@%                Required for ANSI compatibility

%@AB@%#include <io.h>%@AE@%                   Use either IO.H or STDIO.H

%@AS@%  int rename( const char *oldname, const char *newname );%@AE@%%@NL@%
%@NL@%
%@AI@%oldname%@AE@%                           Pointer to old name

%@AI@%newname%@AE@%                           Pointer to new name

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%rename%@AE@% function renames the file or directory specified by %@AI@%oldname%@AE@% to
the name given by %@AI@%newname%@AE@%. The old name must be the path name of an existing
file or directory. The new name must not be the name of an existing file or
directory.  %@NL@%
%@NL@%
The %@AB@%rename%@AE@% function can be used to move a file from one directory to another
by giving a different path name in the %@AI@%newname%@AE@% argument. However, files
cannot be moved from one device to another (for example, from drive A to
drive B). Directories can only be renamed, not moved.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%rename%@AE@% function returns 0 if it is successful. On an error, it returns a
nonzero value and sets %@AB@%errno%@AE@% to one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            File or directory specified by %@AI@%newname%@AE@% 
                                  already exists or could not be created 
                                  (invalid path); or %@AI@%oldname%@AE@% is a 
                                  directory and %@AI@%newname%@AE@% specifies a 
                                  different path.

%@AB@%ENOENT%@AE@%                            File or path name specified by %@AI@%oldname%@AE@% 
                                  not found.

%@AB@%EXDEV%@AE@%                             Attempt to move a file to a different 
                                  device.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* RENAMER.C: This program attempts to rename a file named RENAMER.OBJ to
%@AS@%   * RENAMER.JBO. For this operation to succeed, a file named RENAMER.OBJ
%@AS@%   * must exist and a file named RENAMER.JBO must not exist.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int  result;
%@AS@%     char old[] = "RENAMER.OBJ", new[] = "RENAMER.JBO";
%@AS@%  
%@AS@%     /* Attempt to rename file: */
%@AS@%     result = rename( old, new );
%@AS@%     if( result != 0 )
%@AS@%        printf( "Could not rename '%s'\n", old );
%@AS@%     else
%@AS@%        printf( "File '%s' renamed to '%s'\n", old, new );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  File 'RENAMER.OBJ' renamed to 'RENAMER.JBO' %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:rewind@%%@NL@%
%@2@%%@CR:C6A02641261 @%%@AB@%rewind%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02641262 @%%@CR:C6A02641263 @% %@CR:C6A02641264 @%%@CR:C6A02641265 @% %@CR:C6A02641266 @%%@CR:C6A02641267 @% %@CR:C6A02641268 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Repositions the file pointer to the beginning of a file.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void rewind( FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to%@AB@% FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%rewind%@AE@% function repositions the file pointer associated with %@AI@%stream%@AE@% to
the beginning of the file. A call to %@AB@%rewind%@AE@% is equivalent to  %@NL@%
%@NL@%
%@AB@%%@AE@%(void) fseek( %@AI@%st%@AE@%ream%@AB@%, %@AE@%0L, SEEK_SET );  %@NL@%
%@NL@%
except that %@AB@%rewind%@AE@% clears the error indicators for the stream, and %@AB@%fseek%@AE@%
does not. Both %@AB@%rewind%@AE@% and %@AB@%fseek%@AE@% clear the end-of-file indicator. Also, %@AB@%fseek%@AE@%
returns a value that indicates whether the pointer was successfully moved,
but %@AB@%rewind%@AE@% does not return any value.  %@NL@%
%@NL@%
You can also use the %@AB@%rewind%@AE@% function to clear the keyboard buffer. Use the
%@AB@%rewind%@AE@% function with the stream %@AB@%stdin%@AE@%, which is associated with the keyboard
by default.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%rewind%@AE@% function has no return value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* REWIND.C: This program first opens a file named REWIND.OUT for input
%@AS@%  and
%@AS@%   * output and writes two integers to the file. Next, it uses rewind to
%@AS@%   * reposition the file pointer to the beginning of the file and reads
%@AS@%   * the data back in.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE *stream;
%@AS@%     int data1, data2;
%@AS@%  
%@AS@%     data1 = 1;
%@AS@%     data2 = -37;
%@AS@%  
%@AS@%     if( (stream = fopen( "rewind.out", "w+" )) != NULL )
%@AS@%     {
%@AS@%        fprintf( stream, "%d %d", data1, data2 );
%@AS@%        printf( "The values written are: %d and %d\n", data1, data2 );
%@AS@%        rewind( stream );
%@AS@%        fscanf( stream, "%d %d", &data1, &data2 );
%@AS@%        printf( "The values read are: %d and %d\n", data1, data2 );
%@AS@%        fclose( stream );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The values written are: 1 and -37
%@AS@%  The values read are: 1 and -37 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:rmdir@%%@NL@%
%@2@%%@CR:C6A02651269 @%%@AB@%rmdir%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02651270 @%%@CR:C6A02651271 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Deletes a directory.  %@NL@%
%@NL@%
%@AB@%#include <direct.h>%@AE@%               Required only for function declarations

%@AS@%  int rmdir( char *dirname );%@AE@%%@NL@%
%@NL@%
%@AI@%dirname%@AE@%                           Path name of directory to be removed

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%rmdir%@AE@% function deletes the directory specified by %@AI@%dirname%@AE@%. The directory
must be empty, and it must not be the current working directory or the root
directory.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%rmdir%@AE@% function returns the value 0 if the directory is successfully
deleted. A return value of -1 indicates an error, and %@AB@%errno%@AE@% is set to one of
the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            The given path name is not a directory; 
                                  or the directory is not empty; or the 
                                  directory is the current working 
                                  directory or the  root directory.

%@AB@%ENOENT%@AE@%                            Path name not found.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%chdir%@AE@%, %@AB@%mkdir%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MAKEDIR.C */
%@AS@%  #include <direct.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int result;%@AE@%%@NL@%
%@NL@%
%@AS@%  if( mkdir( "\\testtmp" ) == 0 )
%@AS@%     {
%@AS@%        printf( "Directory '\\testtmp' was successfully created\n" );
%@AS@%        system( "dir \\testtmp" );
%@AS@%        if( rmdir( "\\testtmp" ) == 0 )
%@AS@%           printf( "Directory '\\testtmp' was successfully removed\n"  );
%@AS@%        else
%@AS@%           printf( "Problem removing directory '\\testtmp'\n" );
%@AS@%     }
%@AS@%     else
%@AS@%        printf( "Problem creating directory '\\testtmp'\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Directory '\testtmp' was successfully created
%@AS@%  
%@AS@%   The volume label in drive C is OS2.
%@AS@%   Directory of C:\TESTTMP
%@AS@%  
%@AS@%  .            <DIR>      6-19-89  11:20a
%@AS@%  ..           <DIR>      6-19-89  11:20a
%@AS@%       2 File(s)   12730368 bytes free
%@AS@%  Directory '\testtmp' was successfully removed %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:rmtmp@%%@NL@%
%@2@%%@CR:C6A02661272 @%%@AB@%rmtmp%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02661273 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Removes temporary files.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int rmtmp( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%rmtmp%@AE@% function is used to clean up all the temporary files in the
current directory. The function removes only those files created by %@AB@%tmpfile%@AE@%
and should be used only in the same directory in which the temporary files
were created.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%rmtmp%@AE@% function returns the number of temporary files closed and deleted.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%flushall%@AE@%, %@AB@%tmpfile%@AE@%, %@AB@%tmpnam%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* TMPFILE.C: This program uses tmpfile to create a temporary file,
%@AS@%   * then deletes this file with rmtmp.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE *stream;
%@AS@%     char tempstring[] = "String to be written";
%@AS@%     int  i;
%@AS@%  
%@AS@%     /* Create temporary files. */
%@AS@%     for( i = 1; i <= 10; i++ )
%@AS@%     {
%@AS@%        if( (stream = tmpfile()) == NULL )
%@AS@%           perror( "Could not open new temporary file\n" );
%@AS@%        else
%@AS@%           printf( "Temporary file %d was created\n", i );
%@AS@%     }
%@AS@%  
%@AS@%     /* Remove temporary files. */
%@AS@%     printf( "%d temporary files deleted\n", rmtmp() );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Temporary file 1 was created
%@AS@%  Temporary file 2 was created
%@AS@%  Temporary file 3 was created
%@AS@%  Temporary file 4 was created
%@AS@%  Temporary file 5 was created
%@AS@%  Temporary file 6 was created
%@AS@%  Temporary file 7 was created
%@AS@%  Temporary file 8 was created
%@AS@%  Temporary file 9 was created
%@AS@%  Temporary file 10 was created
%@AS@%  10 temporary files deleted%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_rotl@%%@QR:_rotr@%%@NL@%
%@2@%%@CR:C6A02671274 @%%@AB@%_rotl, _rotr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02671275 @%%@CR:C6A02671276 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Rotate bits to the left (%@AB@%_rotl%@AE@%) or right (%@AB@%_rotr%@AE@%).  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned int _rotl( unsigned int value, int shift );%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned int _rotr( unsigned int value, int shift );%@AE@%%@NL@%
%@NL@%
%@AI@%value%@AE@%                             Value to be rotated

%@AI@%shift%@AE@%                             Number of bits to shift

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_rotl%@AE@% and %@AB@%_rotr%@AE@% functions rotate the %@AB@%unsigned%@AE@% %@AI@%value%@AE@% by %@AI@%shift%@AE@% bits. The
%@AB@%_rotl%@AE@% function rotates the value left. The %@AB@%_rotr%@AE@% function rotates the value
right. Both functions "wrap" bits rotated off one end of %@AI@%value%@AE@% to the other
end.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
Both functions return the rotated value. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_lrotl%@AE@%, %@AB@% _lrotr%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ROT.C: This program uses _rotr and _rotl with different shift
%@AS@%   * values to rotate an integer.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     unsigned val = 0x0fd93;
%@AS@%  
%@AS@%     printf( "0x%4.4x rotated left three times is 0x%4.4x\n",
%@AS@%             val, _rotl( val, 3 ) );
%@AS@%     printf( "0x%4.4x rotated right four times is 0x%4.4x\n",
%@AS@%             val, _rotr( val, 4 ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  0xfd93 rotated left three times is 0xec9f
%@AS@%  0xfd93 rotated right four times is 0x3fd9%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:scanf@%%@NL@%
%@2@%%@CR:C6A02681277 @%%@AB@%scanf%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02681278 @%%@CR:C6A02681279 @%%@CR:C6A02681280 @%%@CR:C6A02681281 @%%@CR:C6A02681282 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Reads formatted data from the standard input stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int scanf( const char *format [[,argument]]... );%@AE@%%@NL@%
%@NL@%
%@AI@%format%@AE@%                            Format control

%@AI@%argument%@AE@%                          Optional argument

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%scanf%@AE@% function reads data from the standard input stream %@AB@%stdin%@AE@% into the
locations given by %@AI@%argument%@AE@%. Each %@AI@%argument%@AE@% must be a pointer to a variable
with a type that corresponds to a type specifier in %@AI@%format%@AE@%. The format
controls the interpretation of the input fields. The format can contain one
or more of the following:  %@NL@%
%@NL@%
%@NL@%
  ş   White-space characters: blank (%@AB@%' '%@AE@%); tab (%@AB@%\t%@AE@%); or newline (%@AB@%\n%@AE@%). A
      white-space character causes %@AB@%scanf%@AE@% to read, but not store, all
      consecutive white-space characters in the input up to the next
      non-white-space character. One white-space character in the format
      matches any number (including 0) and combination of white-space
      characters in the input.%@NL@%
%@NL@%
  ş   Non-white-space characters, except for the percent sign (%@AB@%%%@AE@%). A
      non-white-space character causes %@AB@%scanf%@AE@% to read, but not store, a
      matching non-white-space character. If the next character in %@AB@%stdin%@AE@%
      does not match, %@AB@%scanf%@AE@% terminates.%@NL@%
%@NL@%
  ş   Format specifications, introduced by the percent sign (%@AB@%%%@AE@%). A format
      specification causes %@AB@%scanf%@AE@% to read and convert characters in the input
      into values of a specified type. The value is assigned to an argument
      in the argument list.%@NL@%
%@NL@%
%@NL@%
The format is read from left to right. Characters outside format
specifications are expected to match the sequence of characters in %@AB@%stdin%@AE@%;
the matching characters in %@AB@%stdin%@AE@% are scanned but not stored. If a character
in %@AB@%stdin%@AE@% conflicts with the format specification, %@AB@%scanf%@AE@% terminates. The
character is left in %@AB@%stdin%@AE@% as if it had not been read.  %@NL@%
%@NL@%
When the first format specification is encountered, the value of the first
input field is converted according to this specification and stored in the
location that is specified by the first %@AI@%argument%@AE@%. The second format
specification causes the second input field to be converted and stored in
the second %@AI@%argument%@AE@%, and so on through the end of the format string.  %@NL@%
%@NL@%
An input field is defined as all characters up to the first white-space
character (space, tab, or newline), or up to the first character that cannot
be converted according to the format specification, or until the field width
(if specified) is reached. If there are too many arguments for the given
specifications, the extra arguments are evaluated but ignored. The results
are unpredictable if there are not enough arguments for the format
specification.  %@NL@%
%@NL@%
A format specification has the following form:  %@NL@%
%@NL@%
%@AS@%  %[[*]] [[width]] [[{F | N}]] [[{h | l}]]type%@AE@%%@NL@%
%@NL@%
Each field of the format specification is a single character or a number
signifying a particular format option. The %@AI@%type%@AE@% character, which appears
after the last optional format field, determines whether the input field is
interpreted as a character, a string, or a number. The simplest format
specification contains only the percent sign and a %@AI@%type%@AE@% character (for
example, %@AS@% %s %@AE@%).  %@NL@%
%@NL@%
Each field of the format specification is discussed in detail below. If a
percent sign (%@AB@%%%@AE@%) is followed by a character that has no meaning as a
format-control character, that character and the following characters (up to
the next percent sign) are treated as an ordinary sequence of
charactersÄthat is, a sequence of characters that must match the input. For
example, to specify that a percent-sign character is to be input, use %@AS@% %%.%@AE@%  %@NL@%
%@NL@%
An asterisk (%@AB@%*%@AE@%) following the percent sign suppresses assignment of the next
input field, which is interpreted as a field of the specified type. The
field is scanned but not stored.  %@NL@%
%@NL@%
The %@AI@%width%@AE@% is a positive decimal integer controlling the maximum number of
characters to be read from %@AB@%stdin%@AE@%. No more than %@AI@%width%@AE@% characters are
converted and stored at the corresponding %@AI@%argument%@AE@%. Fewer than %@AI@%width%@AE@%
characters may be read if a white-space character (space, tab, or newline)
or a character that cannot be converted according to the given format occurs
before %@AI@%width%@AE@% is reached.  %@NL@%
%@NL@%
The optional %@AB@%F%@AE@% and %@AB@%N%@AE@% prefixes allow the user to specify whether the argument
is far or near, respectively. %@AB@%F%@AE@% should be prefixed to an %@AI@%argument%@AE@% pointing
to a %@AB@%far%@AE@% object, while %@AB@%N%@AE@% should be prefixed to an %@AI@%argument%@AE@% pointing to a
%@AB@%near%@AE@% object. Note also that the %@AB@%F%@AE@% and %@AB@%N%@AE@% prefixes are not part of the ANSI
definition for %@AB@%scanf%@AE@%, but are instead Microsoft extensions, which should not
be used when ANSI portability is desired.  %@NL@%
%@NL@%
The optional prefix %@AB@%l%@AE@% indicates that the %@AB@%long%@AE@% version of the following type
is to be used, while the prefix %@AB@%h%@AE@% indicates that the %@AB@%short%@AE@% version is to be
used. The corresponding %@AI@%argument%@AE@% should point to a %@AB@%long%@AE@% or %@AB@%double%@AE@% object
(with the %@AB@%l%@AE@% character) or a %@AB@%short%@AE@% object (with the %@AB@%h%@AE@% character). The %@AB@%l%@AE@% and %@AB@%h%@AE@%
modifiers can be used with the %@AB@%d%@AE@%, %@AB@%i%@AE@%, %@AB@%n%@AE@%, %@AB@%o%@AE@%, %@AB@%x%@AE@%, and %@AB@%u%@AE@% type characters. The %@AB@%l%@AE@%
modifier can also be used with the %@AB@%e%@AE@%, %@AB@%f%@AE@%, and %@AB@%g%@AE@% type characters. The %@AB@%l%@AE@% and %@AB@%h%@AE@%
modifiers are ignored if specified for any other type.  %@NL@%
%@NL@%
For %@AB@%scanf%@AE@%, %@AB@%N%@AE@% and %@AB@%F%@AE@% refer to the "distance" to the object being read in (near
or far) and %@AB@%h%@AE@% and %@AB@%l%@AE@% refer to the "size" of the object being read in (16-bit
short or 32-bit long). The list below clarifies this use of %@AB@%N%@AE@%, %@AB@%F%@AE@%, %@AB@%l%@AE@%, and %@AB@%h%@AE@%:
%@NL@%
%@NL@%
%@AB@%Program Code%@AE@%                      %@AB@%Action%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%scanf%@AE@%( %@AS@%"%Ns", &x %@AE@%);               Read a string into near memory

%@AB@%scanf%@AE@%( %@AS@%"%Fs", &x %@AE@%);               Read a string into far memory

%@AB@%scanf%@AE@%( %@AS@%"%Nd", &x %@AE@%);               Read an %@AB@%int%@AE@% into near memory

%@AB@%scanf%@AE@%( %@AS@%"%Fd", &x %@AE@%);               Read an %@AB@%int%@AE@% into far memory

%@AB@%scanf%@AE@%( %@AS@%"%Nld", &x %@AE@%);              Read a %@AB@%long int%@AE@% into near memory

%@AB@%scanf%@AE@%( %@AS@%"%Fld", &x %@AE@%);              Read a %@AB@%long int%@AE@% into far memory

%@AB@%scanf%@AE@%( %@AS@%"%Nhp", &x %@AE@%);              Read a 16-bit pointer into near memory

%@AB@%scanf%@AE@%( %@AS@%"%Nlp", &x %@AE@%);              Read a 32-bit pointer into near memory

%@AB@%scanf%@AE@%( %@AS@%"%Fhp", &x %@AE@%);              Read a 16-bit pointer into far memory

%@AB@%scanf%@AE@%( %@AS@%"%Flp", &x %@AE@%);              Read a 32-bit pointer into far memory

The type characters and their meanings are described in Table R.5.  %@NL@%
%@NL@%
To read strings not delimited by space characters, a set of characters in
brackets (%@AB@%[ ]%@AE@%) can be substituted for the %@AB@%s%@AE@% (string) type character. The
corresponding input field is read up to the first character that does not
appear in the bracketed character set. If the first character in the set is
a caret (%@AB@%^%@AE@%), the effect is reversed: the input field is read up to the first
character that does appear in the rest of the character set.  %@NL@%
%@NL@%
Note that %@AB@%%[a-z]%@AE@% and %@AB@%%[z-a]%@AE@% are interpreted as equivalent to %@AB@%%[abcde...z]%@AE@%.
This is a common %@AB@%scanf%@AE@% extension, but note that it is not required by the
ANSI specification.  %@NL@%
%@NL@%
To store a string without storing a terminating null character (%@AB@%'\0'%@AE@%), use
the specification %@AB@%%%@AE@%%@AI@%n%@AE@%%@AB@%c%@AE@%, where %@AI@%n%@AE@% is a decimal integer. In this case, the %@AB@%c%@AE@%
type character indicates that the argument is a pointer to a character
array. The next %@AI@%n%@AE@% characters are read from the input stream into the
specified location, and no null character (%@AB@%'\0'%@AE@%) is appended. If %@AI@%n%@AE@% is not
specified, the default value for it is 1.  %@NL@%
%@NL@%
The %@AB@%scanf%@AE@% function scans each input field, character by character. It may
stop reading a particular input field before it reaches a space character
for a variety of reasons: the specified width has been reached; the next
character cannot be converted as specified; the next character conflicts
with a character in the control string that it is supposed to match; or the
next character fails to appear in a given character set. For whatever
reason, when %@AB@%scanf%@AE@% stops reading an input field, the next input field is
considered to begin at the first unread character. The conflicting
character, if there is one, is considered unread and is the first character
of the next input field or the first character in subsequent read operations
on %@AB@%stdin%@AE@%.  %@NL@%
%@NL@%
%@AB@%Table   R.5 Type Characters for scanf%@AE@%

%@TH:  57  3513 02 27 27 27 @%Character                  Type of Input Expected     Type of Argument%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%d%@AE@%                          Decimal integer            Pointer to%@AB@% int%@AE@%%@AB@%o%@AE@%                          Octal integer              Pointer to %@AB@%int%@AE@%%@AB@%x%@AE@%                          Hexadecimal integer%@AU@%(1)%@AE@%     Pointer to%@AB@% int%@AE@%%@AB@%i%@AE@%                          Decimal, hexadecimal, or   Pointer to %@AB@%int%@AE@%                           octal integer              %@AB@%u%@AE@%                          Unsigned decimal integer   Pointer to %@AB@%unsigned int%@AE@%%@AB@%U%@AE@%                          Unsigned decimal integer   Pointer to%@AB@% unsigned long%@AE@%%@AB@%e%@AE@%, %@AB@%E%@AE@%%@AB@%%@AE@%                       Floating-point value       Pointer to %@AB@%float%@AE@%%@AB@%f%@AE@% %@AB@%%@AE@%                         consisting of an optional  %@AB@%g%@AE@%, %@AB@%G%@AE@%                       sign (+ or -), a series                               of one or more decimal                                digits containing a                                   decimal point, and an                                 optional exponent ("e" or                             "E") followed by an                                   optionally signed integer                             value.                     %@AB@%c%@AE@%                          Character. White-space     Pointer to %@AB@%char%@AE@%                           characters that are                                   ordinarily skipped are                                read when %@AB@%c%@AE@% is specified;                             to read the next                                      non-white-space                                       character, use %@AS@% %1s%@AE@%.       %@AB@%s%@AE@%                          String                     Pointer to character                                                       array large enough for                                                       input field plus a                                                       terminating null                                                       character (%@AB@%'\0'%@AE@%), which                                                       is automatically                                                       appended.%@AB@%n%@AE@%                          No input read from stream  Pointer to %@AB@%int%@AE@%, into                            or buffer.                 which is stored the                                                       number of characters                                                       successfully read from                                                       the stream or buffer up                                                       to that point in the                                                       current call to %@AB@%scanf%@AE@%.%@AB@%p%@AE@%                          Value in the form %@AI@%xxxx%@AE@%:%@AI@%%@AE@%    Pointer to far pointer to                           %@AI@%yyyy%@AE@%, where the digits %@AI@%x%@AE@%   %@AB@%void%@AE@%                           and %@AI@%y%@AE@% are uppercase                                   hexadecimal digits.        %@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  57  3513 02 27 27 27 @%

1     Since the input for a %@AB@%%x %@AE@%format specifier is always interpreted as a
hexadecimal number, the input should     not include a leading 0x. (If 0x is
included, the 0 is interpreted as a hexadecimal input value.)%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%scanf%@AE@% function returns the number of fields that were successfully
converted and assigned. The return value may be less than the number
requested in the call to %@AB@%scanf%@AE@%. The return value does not include fields
that were read but not assigned.  %@NL@%
%@NL@%
The return value is %@AB@%EOF%@AE@% if the end-of-file or end-of-string is encountered
in the first attempt to read a character.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fscanf%@AE@%, %@AB@%printf%@AE@%, %@AB@%sscanf%@AE@%, %@AB@%vfprintf%@AE@%, %@AB@%vprintf%@AE@%, %@AB@%vsprintf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SCANF.C: This program receives formatted input using scanf. */
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int   i;
%@AS@%     float fp;
%@AS@%     char  c, s[81];
%@AS@%     int   result;
%@AS@%  
%@AS@%     printf( "Enter an integer, a floating-point number, "
%@AS@%             "a character and a string:\n" );
%@AS@%     result = scanf( "%d %f %c %s", &i, &fp, &c, s );
%@AS@%  
%@AS@%     printf( "\nThe number of fields input is %d\n", result );
%@AS@%     printf( "The contents are: %d %f %c %s\n", i, fp, c, s );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Enter an integer, a floating-point number, a character and a string:
%@AS@%  71
%@AS@%  98.6
%@AS@%  h
%@AS@%  White space stops input
%@AS@%  
%@AS@%  The number of fields input is 4
%@AS@%  The contents are: 71 98.599998 h White %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_scrolltextwindow@%%@NL@%
%@2@%%@CR:C6A02691283 @%%@AB@%_scrolltextwindow%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02691284 @% %@CR:C6A02691285 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Scrolls the text in a text window.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _scrolltextwindow( short lines );%@AE@%%@NL@%
%@NL@%
%@AI@%lines%@AE@%                             Number of lines to scroll

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_scrolltextwindow%@AE@% function scrolls the text in a text window (previously
defined by the %@AB@%_settextwindow%@AE@% function). The %@AI@%lines%@AE@% argument specifies the
number of lines to scroll. A positive value of %@AI@%lines%@AE@% scrolls the window up
(the usual direction); a negative value scrolls the window down. Specifying
a number larger than the height of the current text window is equivalent to
calling %@AB@%_clearscreen( _GWINDOW )%@AE@%. A value of 0 for %@AI@%lines%@AE@% has no effect on
the text.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_gettextposition%@AE@%,  %@AB@%_outmem%@AE@%,  %@AB@%_outtext%@AE@%,  %@AB@%_settextposition%@AE@%,  %@AB@%_settextwindow%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SCRTXWIN.C: This program displays text in text windows and then
%@AS@%   * scrolls, inserts, and deletes lines.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void deleteline( void );
%@AS@%  void insertline( void );
%@AS@%  void status( char *msg );
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short row;
%@AS@%     char  buf[40];
%@AS@%  
%@AS@%     /* Set up screen for scrolling, and put text window around scroll area.
%@AS@%*/
%@AS@%     _settextrows( 25 );
%@AS@%     _clearscreen( _GCLEARSCREEN );%@AE@%%@NL@%
%@NL@%
%@AS@%  for( row = 1; row <= 25; row++ )
%@AS@%     {
%@AS@%        _settextposition( row, 1 );
%@AS@%        sprintf( buf, "Line %c             %2d", row + 'A' - 1, row );
%@AS@%        _outtext( buf );
%@AS@%     }
%@AS@%     getch();
%@AS@%     _settextwindow( 1, 1, 25, 10 );
%@AS@%  
%@AS@%     /* Delete some lines. */
%@AS@%     _settextposition( 11, 1 );
%@AS@%     for( row = 12; row < 20; row++ )
%@AS@%        deleteline();
%@AS@%     status( "Deleted 8 lines" );
%@AS@%  
%@AS@%     /* Insert some lines. */
%@AS@%     _settextposition( 5, 1 );
%@AS@%     for( row = 1; row < 6; row++ )
%@AS@%        insertline();
%@AS@%     status( "Inserted 5 lines" );
%@AS@%  
%@AS@%     /* Scroll up and down. */
%@AS@%     _scrolltextwindow( -7 );
%@AS@%     status( "Scrolled down 7 lines" );
%@AS@%     _scrolltextwindow( 5 );
%@AS@%     status( "Scrolled up 5 lines" );
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }
%@AS@%  
%@AS@%  /* Delete lines by scrolling them off the top of the current text window.
%@AS@%   * Save and restore original window.
%@AS@%   */
%@AS@%  void deleteline()
%@AS@%  {
%@AS@%     short left, top, right, bottom;
%@AS@%     struct rccoord rc;
%@AS@%  
%@AS@%     _gettextwindow( &top, &left, &bottom, &right );
%@AS@%     rc = _gettextposition();
%@AS@%     _settextwindow( rc.row, left, bottom, right );
%@AS@%     _scrolltextwindow( _GSCROLLUP );
%@AS@%     _settextwindow( top, left, bottom, right );
%@AS@%     _settextposition( rc.row, rc.col );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Insert some lines by scrolling in blank lines from the top of the
%@AS@%   * current text window. Save and restore original window.
%@AS@%   */
%@AS@%  void insertline()
%@AS@%  {
%@AS@%     short left, top, right, bottom;
%@AS@%     struct rccoord rc;
%@AS@%  
%@AS@%     _gettextwindow( &top, &left, &bottom, &right );
%@AS@%     rc = _gettextposition();
%@AS@%     _settextwindow( rc.row, left, bottom, right );
%@AS@%     _scrolltextwindow( _GSCROLLDOWN );
%@AS@%     _settextwindow( top, left, bottom, right );
%@AS@%     _settextposition( rc.row, rc.col );
%@AS@%  }
%@AS@%  
%@AS@%  /* Display and clear status in its own window. */
%@AS@%  void status( char *msg )
%@AS@%  {
%@AS@%     short left, top, right, bottom;
%@AS@%     struct rccoord rc;
%@AS@%  
%@AS@%     _gettextwindow( &top, &left, &bottom, &right );
%@AS@%     _settextwindow( 1, 50, 2, 80 );
%@AS@%     _outtext( msg );
%@AS@%     getch();
%@AS@%     _clearscreen( _GWINDOW );
%@AS@%     _settextwindow( top, left, bottom, right );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_searchenv@%%@NL@%
%@2@%%@CR:C6A02701286 @%%@AB@%_searchenv%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02701287 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Searches for a file using environment paths.  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _searchenv( char *filename, char *varname, char *pathname );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          Name of file to search for

%@AI@%varname%@AE@%                           Environment to search

%@AI@%pathname%@AE@%                          Buffer to store complete path

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_searchenv%@AE@% routine searches for the target file in the specified domain.
The %@AI@%varname%@AE@% variable can be any environment variable which specifies a list
of directory paths, such as PATH, LIB, INCLUDE, or other user-defined
variables. It is most often PATH, which searches for %@AI@%filename%@AE@% on all paths
specified in the PATH variable. The %@AB@%_searchenv%@AE@% function is case-sensitive,
so the %@AI@%varname%@AE@% variable should match the case of the environment variable.  %@NL@%
%@NL@%
The routine first searches for the file in the current working directory. If
it doesn't find the file, it next looks through the directories specified by
the environment variable.  %@NL@%
%@NL@%
If the target file is found in one of the directories, the newly created
path is copied into the buffer pointed to by %@AI@%pathname%@AE@%. You must ensure that
there is sufficient space for the constructed path name. If the %@AI@%filename%@AE@%
file is not found, %@AI@%pathname%@AE@% will contain an empty null-terminated string.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_searchenv%@AE@% function does not return a value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%getenv%@AE@%, %@AB@%putenv%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SEARCHEN.C: This program searches for a file in a directory
%@AS@%   * specified by an environment variable.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char pathbuffer[_MAX_PATH];
%@AS@%     char searchfile[] = "CL.EXE";
%@AS@%     char envvar[] = "PATH";
%@AS@%     /* Search for file in PATH environment variable: */
%@AS@%     _searchenv( searchfile, envvar, pathbuffer );
%@AS@%     if( *pathbuffer != '\0' )
%@AS@%        printf( "Path for %s: %s\n", searchfile, pathbuffer );
%@AS@%     else
%@AS@%        printf( "%s not found\n", searchfile );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Path for CL.EXE: C:\BIN\CL.EXE %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:segread@%%@NL@%
%@2@%%@CR:C6A02711288 @%%@AB@%segread%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02711289 @%%@CR:C6A02711290 @% %@CR:C6A02711291 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the current values of segment registers.  %@NL@%
%@NL@%
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void segread( struct SREGS *segregs );%@AE@%%@NL@%
%@NL@%
%@AI@%segregs%@AE@%                           Segment-register values

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%segread%@AE@% function fills the structure pointed to by %@AI@%segregs%@AE@% with the
current contents of the segment registers. The %@AB@%SREGS%@AE@% union is described in
the reference section for %@AB@%int86x%@AE@%. This function is intended to be used with
the %@AB@%intdosx%@AE@% and %@AB@%int86x%@AE@% functions to retrieve segment-register values for
later use.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@%FP_SEG, %@AB@%intdosx%@AE@%, %@AB@%int86x%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SEGREAD.C: This program gets the current segment values with segread.
%@AS@%  */
%@AS@%  
%@AS@%  #include <dos.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct   SREGS segregs;
%@AS@%     unsigned cs, ds, es, ss;
%@AS@%  
%@AS@%     /* Read the segment register values */
%@AS@%     segread( &segregs );
%@AS@%     cs = segregs.cs;
%@AS@%     ds = segregs.ds;
%@AS@%     es = segregs.es;
%@AS@%     ss = segregs.ss;
%@AS@%     printf( "CS = 0x%.4x    DS = 0x%.4x    ES = 0x%.4x    SS = 0x%.4x\n",
%@AS@%             cs, ds, es, ss );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  CS = 0x0047    DS = 0x0067    ES = 0x0067    SS = 0x0067
%@AS@%  
%@AS@%  CS = 0x2bcc    DS = 0x2ce8    ES = 0x2ba3    SS = 0x2ce8 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_selectpalette@%%@NL@%
%@2@%%@CR:C6A02721292 @%%@AB@%_selectpalette%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02721293 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Selects a graphics palette.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _selectpalette( short number );%@AE@%%@NL@%
%@NL@%
%@AI@%number%@AE@%                            Palette number

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_selectpalette%@AE@% function works only under the video modes %@AB@%_MRES4COLOR%@AE@% and
%@AB@%_MRESNOCOLOR%@AE@%. A palette consists of a selectable background color (Color 0)
and three set colors. Under the %@AB@%_MRES4COLOR%@AE@% mode, the %@AI@%number%@AE@% argument
selects one of the four predefined palettes shown in Table R.6.  %@NL@%
%@NL@%
%@AB@%Table   R.6 _MRES4COLOR Palette Colors%@AE@%

%@TH:  14   641 01 16 14 16 30 @%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%%@AE@%                %@AB@%%@AE@%              %@AB@%%@AE@%                %@AB@%%@AE@%%@AB@%Palette Number%@AE@%  %@AB@%Color 1%@AE@%       %@AB@%Color 2%@AE@%         %@AB@%Color 3%@AE@%0               Green         Red             Brown1               Cyan          Magenta         Light gray2               Light green   Light red       Yellow3               Light cyan    Light magenta   White%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  14   641 01 16 14 16 30 @%

The %@AB@%_MRESNOCOLOR%@AE@% video mode is used with black-and-white displays, producing
palettes consisting of various shades of gray. It will also produce color
when used with a color display. The number of palettes available depends
upon whether a CGA or EGA hardware package is employed. Under a CGA
configuration, only the two palettes shown in Table R.7 are available.  %@NL@%
%@NL@%
%@AB@%Table   R.7 _MRESNOCOLOR Mode CGA Palette Colors %@AE@%

%@TH:  11   588 01 16 14 15 31 @%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%%@AE@%                %@AB@%%@AE@%              %@AB@%%@AE@%               %@AB@%%@AE@%%@AB@%Palette  %@AE@%       %@AB@%Color 1%@AE@%       %@AB@%Color 2%@AE@%        %@AB@%Color 3%@AE@%%@AB@%Number%@AE@%                                       0               Blue          Red            Light gray1               Light blue    Light red      White%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  11   588 01 16 14 15 31 @%

Under the EGA configuration, the three palettes shown in Table R.8 are
available in the %@AB@%_MRESNOCOLOR%@AE@% video mode.  %@NL@%
%@NL@%
%@AB@%Table   R.8 _MRESNOCOLOR Mode EGA Palette Colors %@AE@%

%@TH:  13   631 01 16 14 14 32 @%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%%@AE@%                %@AB@%%@AE@%              %@AB@%%@AE@%              %@AB@%%@AE@%%@AB@%Palette  %@AE@%       %@AB@%Color 1%@AE@%       %@AB@%Color 2%@AE@%       %@AB@%Color 3%@AE@%%@AB@%Number%@AE@%                                      0               Green         Red           Brown1               Light green   Light red     Yellow2               Light cyan    Light red     Yellow%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  13   631 01 16 14 14 32 @%

Note that with an EGA in %@AB@%_MRESNOCOLOR%@AE@% video mode, Palette 3 is identical to
Palette 1.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the value of the previous palette. There is no error
return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getvideoconfig%@AE@%,  %@AB@%_setbkcolor%@AE@%,  %@AB@%_setvideomode%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SELPAL.C: This program changes the current CGA palette. */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  long bkcolor[8] = { _BLACK,  _BLUE,     _GREEN,  _CYAN,
%@AS@%                      _RED,    _MAGENTA,  _BROWN,  _WHITE };
%@AS@%  char *bkname [] = { "BLACK", "BLUE",    "GREEN", "CYAN",
%@AS@%                      "RED",   "MAGENTA", "BROWN", "WHITE" };
%@AS@%  void main()
%@AS@%  {
%@AS@%     int i, j, k;
%@AS@%  
%@AS@%     if ( !_setvideomode( _MRES4COLOR ) )
%@AS@%     {
%@AS@%        printf( "No palettes available" );
%@AS@%        exit( 1 );
%@AS@%     }
%@AS@%     for( i = 0; i < 4; i++ )                    /* Palette loop          */
%@AS@%     {
%@AS@%         _selectpalette( i );
%@AS@%         for( k = 0; k < 8; k++ )                /* Background color loop */
%@AS@%         {
%@AS@%             _clearscreen( _GCLEARSCREEN );
%@AS@%             _setbkcolor( bkcolor[k] );
%@AS@%             _settextposition( 1, 1 );
%@AS@%             printf( "Background: %s\tPalette: %d", bkname[k], i );
%@AS@%             for( j = 1; j < 4; j++ )            /* Foreground color loop */
%@AS@%             {
%@AS@%                 _setcolor( j );
%@AS@%                 _ellipse( _GFILLINTERIOR, 100, j * 30, 220, 80 + (j * 30)
%@AS@%);
%@AS@%             }
%@AS@%             getch();
%@AS@%         }
%@AS@%     }
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setactivepage@%%@NL@%
%@2@%%@CR:C6A02731294 @%%@AB@%_setactivepage%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02731295 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the active page.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _setactivepage( short  page );%@AE@%%@NL@%
%@NL@%
%@AI@%page%@AE@%                              Memory page number

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
For hardware and mode configurations with enough memory to support multiple
screen pages,  %@AB@%_setactivepage%@AE@% specifies the area in memory in which graphics
output is written. The %@AI@%page%@AE@% argument selects the current active page. The
default page number is 0.  %@NL@%
%@NL@%
Screen animation can be done by alternating the graphics pages displayed.
Use the %@AB@%_setvisualpage%@AE@% function to display a completed graphics page while
executing graphics statements in another active page.  %@NL@%
%@NL@%
These functions can also be used to control text output if you use the text
functions %@AB@%_gettextcursor%@AE@%,  %@AB@%_settextcursor%@AE@%,  %@AB@%_outtext%@AE@%,  %@AB@%_settextposition%@AE@%,
%@AB@%_gettextposition%@AE@%,  %@AB@%_settextcolor%@AE@%,  %@AB@%_gettextcolor%@AE@%,  %@AB@%_settextwindow%@AE@%, and
%@AB@%_wrapon%@AE@% instead of the standard C-language I/O functions.  %@NL@%
%@NL@%
The CGA hardware configuration has only 16K of RAM available to support
multiple video pages, and only in the text mode. The EGA and VGA
configurations may be equipped with up to 256K of RAM for multiple video
pages in graphics mode.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the function returns the page number of the previous active
page. If the function fails, it returns a negative value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getactivepage%@AE@%,  %@AB@%_getvisualpage%@AE@%,  %@AB@%_setvisualpage%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* PAGE.C illustrates video page functions including:
%@AS@%   *      _getactivepage  _getvisualpage  _setactivepage  _setvisualpage
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     short  oldvpage, oldapage, page, row, col, line;
%@AS@%     struct videoconfig vc;
%@AS@%     char   buf[80];
%@AS@%  
%@AS@%     _getvideoconfig( &vc );
%@AS@%     if( vc.numvideopages < 4 )
%@AS@%         exit( 1 );              /* Fail for OS/2 or monochrome */
%@AS@%     oldapage  = _getactivepage();
%@AS@%     oldvpage  = _getvisualpage();
%@AS@%     _displaycursor( _GCURSOROFF );
%@AS@%  
%@AS@%     /* Draw arrows in different place on each page. */
%@AS@%     for( page = 1; page < 4; page++ )
%@AS@%     {
%@AS@%        _setactivepage( page );
%@AS@%        _settextposition( 12, 16 * page );
%@AS@%        _outtext( ">>>>>>>>" );
%@AS@%     }
%@AS@%  
%@AS@%     while( !kbhit() )
%@AS@%        /* Cycle through pages 1 to 3 to show moving image. */
%@AS@%        for( page = 1; page < 4; page++ )
%@AS@%            _setvisualpage( page );
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Restore original page (normally 0) to restore screen. */
%@AS@%     _setactivepage( oldapage );
%@AS@%     _setvisualpage( oldvpage );
%@AS@%     _displaycursor( _GCURSORON );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setbkcolor@%%@NL@%
%@2@%%@CR:C6A02741296 @%%@AB@%_setbkcolor%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02741297 @%%@CR:C6A02741298 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the current background color.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  long _far _setbkcolor( long color );%@AE@%%@NL@%
%@NL@%
%@AI@%color%@AE@%                             Desired color

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setbkcolor%@AE@% function sets the current background color to the color
value %@AI@%color%@AE@%.  %@NL@%
%@NL@%
In a color text mode (such as %@AB@%_TEXTC80%@AE@%), %@AB@%_setbkcolor%@AE@% accepts (and
%@AB@%_getbkcolor%@AE@% returns) a color index. The value for the default colors is
given in a table in the description of the %@AB@%_settextcolor%@AE@% function. For
example, %@AB@%_setbkcolor(2L)%@AE@% sets the background color to color index 2. The
actual color displayed depends on the palette mapping for color index 2. The
default is green in a color text mode.  %@NL@%
%@NL@%
In a color graphics mode (such as %@AB@%_ERESCOLOR%@AE@%), %@AB@%_setbkcolor%@AE@% accepts (and
%@AB@%_getbkcolor %@AE@%returns) a color value. The value for the background color is
given by the manifest constants defined in the GRAPH.H include file. For
example, %@AB@%_setbkcolor( _GREEN)%@AE@% sets the background color in a graphics mode
to green. These manifest constants are provided as a convenience in defining
and manipulating the most common colors. The actual range of colors is, in
general, much greater.  %@NL@%
%@NL@%
In general, whenever an argument is long, it refers to a color value, and
whenever it is short, it refers to a color index. The two exceptions are
%@AB@%_setbkcolor%@AE@% and %@AB@%_getbkcolor%@AE@%.  %@NL@%
%@NL@%
Since the background color is color index 0, the %@AB@%_remappalette%@AE@% function will
act identically to the %@AB@%_setbkcolor%@AE@% function. Unlike %@AB@%_remappalette%@AE@%, however,
%@AB@%_setbkcolor%@AE@% does not require an EGA or VGA environment.  %@NL@%
%@NL@%
In a text mode, the %@AB@%_setbkcolor%@AE@% function does not affect anything already
appearing on the display; only the subsequent output is affected. In a
graphics mode, it immediately changes all background pixels.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
In text modes, %@AB@%_setbkcolor%@AE@% returns the color index of the old background
color. In graphics modes, %@AB@%_setbkcolor%@AE@% returns the old color value of color
index 0. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getbkcolor%@AE@%, %@AB@% _remappalette%@AE@%,  %@AB@%_selectpalette%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_getcolor%@AE@%. %@NL@%
%@NL@%
%@NL@%
%@QR:setbuf@%%@NL@%
%@2@%%@CR:C6A02751299 @%%@AB@%setbuf%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02751300 @%%@CR:C6A02751301 @%%@CR:C6A02751302 @% %@CR:C6A02751303 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Controls stream buffering.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void setbuf( FILE *stream, char *buffer );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@AI@%buffer%@AE@%                            User-allocated buffer

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%setbuf%@AE@% function allows the user to control buffering for %@AI@%stream%@AE@%. The
%@AI@%stream%@AE@% argument must refer to an open file that has not been read or
written. If the %@AI@%buffer%@AE@% argument is %@AB@%NULL%@AE@%, the stream is unbuffered. If not,
the buffer must point to a character array of length %@AB@%BUFSIZ%@AE@%, where %@AB@%BUFSIZ%@AE@% is
the buffer size as defined in STDIO.H. The user-specified buffer, instead of
the default system-allocated buffer for the given stream, is used for I/O
buffering.  %@NL@%
%@NL@%
The %@AB@%stderr%@AE@% and (in DOS only) %@AB@%stdaux%@AE@% streams are unbuffered by default, but
may be assigned buffers with %@AB@%setbuf%@AE@%.  %@NL@%
%@NL@%
The %@AB@%setbuf%@AE@% function has been subsumed by the %@AB@%setvbuf%@AE@% function, which should
be the preferred routine for new code. The %@AB@%setbuf%@AE@% function is retained for
compatibility with existing code.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fclose%@AE@%, %@AB@%fflush%@AE@%, %@AB@%fopen%@AE@%, %@AB@%setvbuf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SETBUF.C: This program first opens files named DATA1 and DATA2.
%@AS@%   * Then it uses setbuf to give DATA1 a user-assigned buffer
%@AS@%   * and to change DATA2 so that it has no buffer.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buf[BUFSIZ];
%@AS@%     FILE *stream1, *stream2;
%@AS@%  
%@AS@%     if( ((stream1 = fopen( "data1", "a" )) != NULL) &&
%@AS@%         ((stream2 = fopen( "data2", "w" )) != NULL) )
%@AS@%     {
%@AS@%        /* "stream1" uses user-assigned buffer: */
%@AS@%        setbuf( stream1, buf );
%@AS@%        printf( "stream1 set to user-defined buffer at: %Fp\n", buf );
%@AS@%  
%@AS@%        /* "stream2" is unbuffered              */
%@AS@%        setbuf( stream2, NULL );
%@AS@%        printf( "stream2 buffering disabled\n" );
%@AS@%        fcloseall();
%@AS@%     }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  stream1 set to user-defined buffer at: 0298:0DF2
%@AS@%  stream2 buffering disabled %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setcliprgn@%%@NL@%
%@2@%%@CR:C6A02761304 @%%@AB@%_setcliprgn%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02761305 @%%@CR:C6A02761306 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the clipping region for graphics.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _setcliprgn( short x1, short y1, short x2, short y2 );%@AE@%%@NL@%
%@NL@%
%@AI@%x1%@AE@%, %@AI@%y1%@AE@%                            Upper-left corner of clip region

%@AI@%x2%@AE@%, %@AI@%y2%@AE@%                            Lower-right corner of clip region

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setcliprgn%@AE@% function limits the display of subsequent graphics output
and font text output to an area of the screen called the "clipping region."
The physical points (%@AI@%x1%@AE@%, %@AI@%y1%@AE@%) and (%@AI@%x2%@AE@%, %@AI@%y2%@AE@%) are the diagonally opposed sides
of a rectangle that defines the clipping region. This function does not
change the view coordinate system. Rather, it merely masks the screen. %@CR:C6A02761307 @%  %@NL@%
%@NL@%
Note that the %@AB@%_setcliprgn%@AE@% function affects graphics and font text output
only. To mask the screen for text output, use the %@AB@%_settextwindow%@AE@% function.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_settextwindow%@AE@%,  %@AB@%_setvieworg%@AE@%,  %@AB@%_setviewport%@AE@%,  %@AB@%_setwindow%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SCLIPRGN.C */
%@AS@%  #include <stdlib.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     /* Set clip region, then draw and ellipse larger than the region. */
%@AS@%     _setcliprgn( 0, 0, 200, 125 );
%@AS@%     _ellipse( _GFILLINTERIOR, 80, 50, 240, 190 );%@AE@%%@NL@%
%@NL@%
%@AS@%  getch();
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setcolor@%%@NL@%
%@2@%%@CR:C6A02771308 @%%@AB@%_setcolor%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02771309 @%%@CR:C6A02771310 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the current color.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _setcolor( short color );%@AE@%%@NL@%
%@NL@%
%@AI@%color%@AE@%                             Desired color index

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setcolor%@AE@% function sets the current color index to %@AI@%color%@AE@%. The %@AI@%color%@AE@%
parameter is masked but always within range. The following graphics
functions use the current color:  %@AB@%_arc%@AE@%,  %@AB@%_ellipse%@AE@%,  %@AB@%_floodfill%@AE@%,  %@AB@%_lineto%@AE@%,
%@AB@%_outgtext%@AE@%,  %@AB@%_pie%@AE@%,  %@AB@%_rectangle%@AE@%, and  %@AB@%_setpixel%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_setcolor%@AE@% function accepts an %@AB@%int%@AE@% value as an argument. It is a color
index.  %@NL@%
%@NL@%
The default color index is the highest numbered color index in the current
palette.  %@NL@%
%@NL@%
Note that the %@AB@%_setcolor%@AE@% function does not affect the output of the
presentation-graphics functions.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
This function returns the previous color. If the function fails (e.g., if
used in a text mode), it returns  -1.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_arc%@AE@% functions,  %@AB@%_ellipse%@AE@% functions,  %@AB@%_floodfill%@AE@%,  %@AB@%_getcolor%@AE@%,  %@AB@%_lineto%@AE@%
functions,  %@AB@%_outgtext%@AE@%,  %@AB@%_pie%@AE@% functions,  %@AB@%_rectangle%@AE@% functions,
%@AB@%_selectpalette%@AE@%,  %@AB@%_setpixel%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GPIXEL.C: This program assigns different colors to randomly
%@AS@%   * selected pixels.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short xvar, yvar;
%@AS@%     struct videoconfig vc;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXCOLORMODE ) )
%@AS@%        exit( 1 );
%@AS@%     _getvideoconfig( &vc );
%@AS@%  
%@AS@%     /* Draw filled ellipse to turn on certain pixels. */
%@AS@%     _ellipse( _GFILLINTERIOR, vc.numxpixels / 6, vc.numypixels / 6,
%@AS@%                               vc.numxpixels / 6 * 5, vc.numypixels / 6 * 5
%@AS@%                                             );
%@AS@%  
%@AS@%     /* Draw random pixels in random colors... */
%@AS@%     while( !kbhit() )
%@AS@%     {
%@AS@%        /* ...but only if they are already on (inside the ellipse). */
%@AS@%        xvar = rand() % vc.numxpixels;
%@AS@%        yvar = rand() % vc.numypixels;
%@AS@%        if( _getpixel( xvar, yvar ) != 0 )
%@AS@%        {
%@AS@%           _setcolor( rand() % 16 );
%@AS@%           _setpixel( xvar, yvar );
%@AS@%        }
%@AS@%     }
%@AS@%  
%@AS@%     getch();          /* Throw away the keystroke. */
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setfillmask@%%@NL@%
%@2@%%@CR:C6A02781311 @%%@AB@%_setfillmask%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02781312 @%%@CR:C6A02781313 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the fill mask.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _setfillmask( unsigned char _far *mask );%@AE@%%@NL@%
%@NL@%
%@AI@%mask%@AE@%                              Mask array

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setfillmask%@AE@% function sets the current fill mask, which determines the
fill pattern. The mask is an 8-by-8 array of bits in which each bit
represents a pixel. A 1 bit sets the corresponding pixel to the current
color, while a 0 bit leaves the pixel unchanged. The pattern is repeated
over the entire fill area.  %@NL@%
%@NL@%
If no fill mask is set (%@AI@%mask%@AE@% is %@AB@%NULL%@AE@%Äthe default), only the current color is
used in fill operations.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_ellipse%@AE@% functions,  %@AB@%_floodfill%@AE@%,  %@AB@%_getfillmask%@AE@%,  %@AB@%_pie%@AE@% functions,  %@AB@%_rectangle%@AE@%
functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GFILLMSK.C: This program illustrates _getfillmask and _setfillmask. */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void ellipsemask( short x1, short y1, short x2, short y2, char _far
%@AS@%*newmask );
%@AS@%  
%@AS@%  unsigned char mask1[8] = { 0x43, 0x23, 0x7c, 0xf7, 0x8a, 0x4d, 0x78, 0x39
%@AS@%};
%@AS@%  unsigned char mask2[8] = { 0x18, 0xad, 0xc0, 0x79, 0xf6, 0xc4, 0xa8, 0x23
%@AS@%};
%@AS@%  char oldmask[8];
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int loop;
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     /* Set first fill mask and draw rectangle. */
%@AS@%     _setfillmask( mask1 );
%@AS@%     _rectangle( _GFILLINTERIOR, 20, 20, 100, 100 );
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Call routine that saves and restores mask. */
%@AS@%     ellipsemask( 60, 60, 150, 150, mask2 );
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Back to original mask. */
%@AS@%     _rectangle( _GFILLINTERIOR, 120, 120, 190, 190 );
%@AS@%     getch();
%@AS@%  
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }
%@AS@%  
%@AS@%  /* Draw an ellipse with a specified fill mask. */
%@AS@%  void ellipsemask( short x1, short y1, short x2, short y2, char _far
%@AS@%*newmask )
%@AS@%  {
%@AS@%     unsigned char savemask[8];
%@AS@%  
%@AS@%     _getfillmask( savemask );                    /* Save mask         */
%@AS@%     _setfillmask( newmask );                     /* Set new mask      */
%@AS@%     _ellipse( _GFILLINTERIOR, x1, y1, x2, y2 );  /* Use new mask      */
%@AS@%     _setfillmask( savemask );                    /* Restore original  */
%@AS@%  }
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setfont@%%@NL@%
%@2@%%@CR:C6A02791314 @%%@AB@%_setfont%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02791315 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Finds a single font.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _setfont( unsigned char _far *options );%@AE@%%@NL@%
%@NL@%
%@AI@%options%@AE@%                           String describing font characteristics

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setfont%@AE@% function finds a single font, from the set of registered fonts,
that has the characteristics specified by the %@AI@%options%@AE@% string. If a font is
found, it is made the current font. The current font is used in all
subsequent calls to the %@AB@%_outgtext%@AE@% function. There can be only one active
font at any time.  %@NL@%
%@NL@%
The %@AI@%options%@AE@% string is a set of characters that specifies the desired
characteristics of the font. The %@AB@%_setfont%@AE@% function searches the list of
registered fonts for a font matching the specified characteristics.  %@NL@%
%@NL@%
The characteristics that may be specified in the %@AI@%options%@AE@% string are shown in
the list below. Characteristics specified in the %@AI@%options%@AE@% string are not
case- or position-sensitive.  %@NL@%
%@NL@%
%@AB@%Characteristic%@AE@%                    %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%t%@AE@%%@AI@%'fontname'%@AE@%                       Typeface.

%@AB@%h%@AE@%%@AI@%x%@AE@%                                Character height, where %@AI@%x%@AE@% is the number 
                                  of pixels.

%@AB@%w%@AE@%%@AI@%y%@AE@%                                Character width, where %@AI@%y%@AE@% is the number 
                                  of pixels.

%@AB@%f%@AE@%                                 Find only a fixed-space font (should not
                                  be used with the %@AB@%%@AE@%
                                  %@AB@%p%@AE@% characteristic).

%@AB@%p%@AE@%                                 Find only a proportionally spaced font 
                                  (should not be used with the %@AB@%f%@AE@% 
                                  characteristic).

%@AB@%v%@AE@%                                 Find only a vector font (should not be 
                                  used with the %@AB@%r%@AE@% 
                                  characteristic).

%@AB@%r%@AE@%                                 Find only a raster-mapped (bit-mapped) 
                                  font (should not be used with the %@AB@%v%@AE@% 
                                  characteristic). %@CR:C6A02791316 @%

%@AB@%b%@AE@%                                 Select a best fit font.

%@AB@%n%@AE@%%@AI@%x%@AE@%                                Select font number %@AI@%x%@AE@%, where %@AI@%x%@AE@% is less 
                                  than or equal to the value returned by 
                                  the %@AB@%_registerfonts%@AE@% function. Use this 
                                  option to "step through" an entire set 
                                  of fonts.

You can request as many options as desired, except with %@AB@%n%@AE@%%@AI@%x%@AE@%, which should be
used alone. If mutually exclusive options are requested (such as the pair
%@AB@%f/p%@AE@% or %@AB@%r/v%@AE@%), the %@AB@%_setfont%@AE@% function ignores them. There is no error detection
for incompatible parameters used with %@AB@%n%@AE@%%@AI@%x%@AE@%.  %@NL@%
%@NL@%
Options can be separated by blanks in the %@AI@%options%@AE@% string. Any other
character is ignored by %@AB@%_setfont%@AE@%.  %@NL@%
%@NL@%
The %@AB@%t%@AE@% (the typeface specification) in %@AI@%options%@AE@% is specified as a "t" followed
by %@AI@%fontname%@AE@% in single quotes. Choose %@AI@%fontname%@AE@% from the following list:  %@NL@%
%@NL@%
%@AB@%Fontname%@AE@%                          %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
Courier                           Fixed-width bit-mapped font with serifs

Helv                              Sans serif proportional bit-mapped font

Tms Rmn                           Proportional bit-mapped font with serifs

Script                            Proportional vector-mapped font of 
                                  slanted characters formed from nearly 
                                  continuous lines 

Modern                            Proportional vector-mapped font without 
                                  serifs

Roman                             Proportional vector-mapped font with 
                                  serifs

A %@AB@%b%@AE@% in the %@AI@%options%@AE@% field causes the %@AB@%_setfont%@AE@% routine to automatically select
the "best fit" font that matches the other characteristics you have
specified. If the %@AB@%b%@AE@% parameter is spec-ified and at least one font is
registered, %@AB@%_setfont%@AE@% will always be able to set a font and will return 0 to
indicate success.  %@NL@%
%@NL@%
In selecting a font, the %@AB@%_setfont%@AE@% routine uses the following precedence
(rated from highest precedence to lowest):  %@NL@%
%@NL@%
%@NL@%
  1.  Pixel height%@NL@%
%@NL@%
  2.  Typeface%@NL@%
%@NL@%
  3.  Pixel width %@NL@%
%@NL@%
  4.  Fixed or proportional font%@NL@%
%@NL@%
%@NL@%
You can also specify a pixel width and height for fonts. If a nonexistent
value is chosen for either, and the %@AB@%b%@AE@% option is specified, the %@AB@%_setfont%@AE@%
function will chose the closest match. A smaller font size has precedence
over a larger size. If %@AB@%_setfont%@AE@% requests Helv 12 with best fit, and only
Helv 10 and Helv 14 are available, %@AB@%_setfont%@AE@% will select Helv 10.  %@NL@%
%@NL@%
If a nonexistent value is chosen for pixel height and width, the %@AB@%_setfont%@AE@%
function will apply a magnification factor to a vector-mapped font to obtain
a suitable font size. This automatic magnification does not apply if the %@AB@%r%@AE@%
(raster-mapped font) option is specified, or if a specific typeface is
requested and no best fit (%@AB@%b%@AE@%) option is specified.  %@NL@%
%@NL@%
If you specify the %@AB@%n%@AE@%%@AI@%x%@AE@% parameter, %@AB@%_setfont%@AE@% will ignore any other specified
options and supply only the font number corresponding to %@AI@%x%@AE@%.  %@NL@%
%@NL@%
Note that the font functions affect only the output from the font output
function %@AB@%_outgtext%@AE@%; no other C run-time output functions are affected by
font usage.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setfont%@AE@% function returns a 0 to indicate success and a -1 to indicate
an error. An error occurs if a request for a specific font fails and the %@AB@%b%@AE@%
option was not specified, or if fonts have not yet been registered.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getfontinfo%@AE@%,  %@AB@%_getgtextextent%@AE@%,  %@AB@%_outgtext%@AE@%,  %@AB@%_registerfonts%@AE@%,
%@AB@%_unregisterfonts%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_outgtext%@AE@%. %@NL@%
%@NL@%
%@NL@%
%@QR:_setgtextvector@%%@NL@%
%@2@%%@CR:C6A02801317 @%%@AB@%_setgtextvector%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02801318 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Changes the orientation of font text output.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct xycoord _far _setgtextvector( short x, short y );%@AE@%%@NL@%
%@NL@%
%@AI@%x, y%@AE@%                              Integers specifying font rotation

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setgtextvector%@AE@% function sets the current orientation for font text
output to the vector specified by %@AI@%x%@AE@% and %@AI@%y%@AE@%. The current orientation is used
in calls to the %@AB@%_outgtext%@AE@% function.  %@NL@%
%@NL@%
The values of %@AI@%x%@AE@% and %@AI@%y%@AE@% define the vector which determines the direction of
rotation of font text on the screen. The text-rotation options are shown
below:  %@NL@%
%@NL@%
%@AB@%(x, y)%@AE@%                            %@AB@%Text Orientation%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
(0, 0)                            Unchanged

(1, 0)                            Horizontal text (default)

(0, 1)                            Rotated 90 degrees counterclockwise

(-1, 0)                           Rotated 180 degrees

(0, -1)                           Rotated 270 degrees counterclockwise

If other values are input, only the sign of the input is used. For example,
(-3, 0) is interpreted as (-1, 0).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setgtextvector%@AE@% function returns the previous vector in a structure of
%@AB@%xycoord%@AE@% type. If you pass the %@AB@%_setgtextvector%@AE@% function the values (0, 0),
the function returns the current vector values in the %@AB@%xycoord%@AE@% structure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getfontinfo%@AE@%,  %@AB@%_getgtextextent%@AE@%,  %@AB@%_grstatus%@AE@%,  %@AB@%_outgtext%@AE@%,  %@AB@%_registerfonts%@AE@%,
%@AB@%_setfont%@AE@%, %@AB@%_unregisterfonts%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_outgtext%@AE@%. %@NL@%
%@NL@%
%@NL@%
%@QR:setjmp@%%@NL@%
%@2@%%@CR:C6A02811319 @%%@AB@%setjmp%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02811320 @%%@CR:C6A02811321 @%%@CR:C6A02811322 @% %@CR:C6A02811323 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Saves the current state of the program.  %@NL@%
%@NL@%
%@AS@%  #include <setjmp.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int setjmp( jmp_buf env );%@AE@%%@NL@%
%@NL@%
%@AI@%env%@AE@%                               Variable in which environment is stored

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%setjmp%@AE@% function saves a stack environment that can be subsequently
restored using %@AB@%longjmp%@AE@%. Used together this way, %@AB@%setjmp%@AE@% and %@AB@%longjmp%@AE@% provide a
way to execute a "non-local %@AB@%goto%@AE@%." They are typically used to pass execution
control to error-handling or recovery code in a previously called routine
without using the normal calling or return conventions.  %@NL@%
%@NL@%
A call to %@AB@%setjmp%@AE@% causes the current stack environment to be saved in %@AI@%env%@AE@%. A
subsequent call to %@AB@%longjmp%@AE@% restores the saved environment and returns
control to the point just after the corresponding %@AB@%setjmp%@AE@% call. All variables
(except register variables) accessible to the routine receiving control
contain the values they had when %@AB@%setjmp%@AE@% was called.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%setjmp%@AE@% function returns 0 after saving the stack environment. If %@AB@%setjmp%@AE@%
returns as a result of a %@AB@%longjmp%@AE@% call, it returns the %@AI@%value%@AE@% argument of
%@AB@%longjmp%@AE@%, or, if the %@AI@%value%@AE@% argument of %@AB@%longjmp%@AE@% is 0, %@AB@%setjmp%@AE@% returns 1. There
is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%longjmp%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_fpreset%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setlinestyle@%%@NL@%
%@2@%%@CR:C6A02821324 @%%@AB@%_setlinestyle%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02821325 @%%@CR:C6A02821326 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the line style.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _setlinestyle( unsigned short mask );%@AE@%%@NL@%
%@NL@%
%@AI@%mask%@AE@%                              Desired line-style mask

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
Some graphics routines ( %@AB@%_lineto%@AE@% and %@AB@%_rectangle%@AE@%) draw straight lines on the
screen. The type of line is controlled by the current line-style mask.  %@NL@%
%@NL@%
The %@AB@%_setlinestyle%@AE@% function selects the mask used for line drawing. The %@AI@%mask%@AE@%
argument is a 16-bit array, where each bit represents a pixel in the line
being drawn. If a bit is 1, the corresponding pixel is set to the color of
the line (the current color). If a bit is 0, the corresponding pixel is left
unchanged. The template is repeated for the entire length of the line.  %@NL@%
%@NL@%
The default mask is 0xFFFF (a solid line).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getlinestyle%@AE@%,  %@AB@%_lineto%@AE@% functions,  %@AB@%_rectangle%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_getlinestyle%@AE@%. %@NL@%
%@NL@%
%@NL@%
%@QR:setlocale@%%@NL@%
%@2@%%@CR:C6A02831327 @%%@AB@%setlocale%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02831328 @%%@CR:C6A02831329 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Defines the locale.  %@NL@%
%@NL@%
%@AS@%  #include <locale.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char *setlocale( int category, const char *locale );%@AE@%%@NL@%
%@NL@%
%@AI@%category%@AE@%                          Category affected by locale

%@AI@%locale%@AE@%%@AB@%%@AE@%                            Name of the locale that will control the
                                  specified category

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%setlocale%@AE@% function sets the categories specified by %@AI@%category%@AE@% to the
locale specified by %@AI@%locale%@AE@%. The "locale" refers to the locality (country)
for which certain aspects of your program can be customized. Some
locale-dependent aspects include the formatting of dates and the display
format for monetary values.  %@NL@%
%@NL@%
The %@AB@%setlocale%@AE@% function is used to set or get the program's current entire
locale or simply portions of the locale information. The %@AI@%category%@AE@% argument
specifies which portion of a program's locale information will be used. The
manifest constants used for the %@AI@%category%@AE@% argument are listed below:  %@NL@%
%@NL@%
%@AB@%Category     %@AE@%                     %@AB@%Parts of Program Affected%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%LC_ALL%@AE@%                            All categories listed below.

%@AB@%LC_COLLATE%@AE@%                        The%@AB@% strcoll%@AE@% and %@AB@%strxfrm%@AE@% functions.

%@AB@%LC_CTYPE%@AE@%                          The character-handling functions (except
                                  for %@AB@%isdigit%@AE@% and %@AB@%isxdigit%@AE@%, which are 
                                  unaffected).

%@AB@%LC_MONETARY%@AE@%                       Monetary formatting information returned
                                  by the %@AB@%localeconv%@AE@% function.

%@AB@%LC_NUMERIC%@AE@%                        Decimal point character for the 
                                  formatted output routines (such as %@AB@%%@AE@%
                                  %@AB@%printf%@AE@%), for the data conversion 
                                  routines, and for 
                                  the nonmonetary formatting information 
                                  returned by the%@AB@%%@AE@%
                                  %@AB@%localeconv%@AE@% function.

%@AB@%LC_TIME%@AE@%                           The %@AB@%strftime%@AE@% function.

The %@AI@%locale%@AE@% argument is a pointer to a string that specifies the name of the
locale. If %@AI@%locale%@AE@% points to an empty string, the locale is the
implementation-defined native environment. A value of "C" specifies the
minimal ANSI conforming environment for C translation. This is the only
locale supported in Microsoft C, version 6.0.  %@NL@%
%@NL@%
If the %@AI@%locale%@AE@% argument is a null pointer, %@AB@%setlocale%@AE@% returns a pointer to the
string associated with the category of the program's locale. The program's
current locale setting is not changed.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If a valid locale and category are given, %@AB@%_setlocale%@AE@% returns a pointer to
the string associated with the specified category for the new locale. If the
locale or category is invalid, the %@AB@%setlocale%@AE@% function returns a null pointer
and the program's current locale settings are not changed.  %@NL@%
%@NL@%
The pointer to a string returned by %@AB@%setlocale%@AE@% can be used in subsequent
calls to restore that part of the program's locale information. Later calls
to %@AB@%setlocale%@AE@% will overwrite the string.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%localeconv%@AE@%, %@AB@%strcoll%@AE@%, %@AB@%strftime%@AE@%, %@AB@%strxfrm%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:setmode@%%@NL@%
%@2@%%@CR:C6A02841330 @%%@AB@%setmode%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02841331 @%%@CR:C6A02841332 @%%@CR:C6A02841333 @% %@CR:C6A02841334 @%%@CR:C6A02841335 @% %@CR:C6A02841336 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the file translation mode.  %@NL@%
%@NL@%
%@AB@%#include <fcntl.h>%@AE@%                

%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  int setmode ( int handle, int mode );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            File handle

%@AI@%mode%@AE@%                              New translation mode

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%setmode%@AE@% function sets to %@AI@%mode%@AE@% the translation mode of the file given by
%@AI@%handle%@AE@%. The mode must be one of the following manifest constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%O_TEXT%@AE@%                            Sets text (translated) mode. 
                                  Carriage-return-line-feed (CR-LF) 
                                  combinations are translated into a 
                                  single line-feed (LF) character on 
                                  input. Line-feed characters are 
                                  translated into CR-LF combinations on 
                                  output.

%@AB@%O_BINARY%@AE@%                          Sets binary (untranslated) mode. The 
                                  above translations are suppressed.

The %@AB@%setmode%@AE@% function is typically used to modify the default translation
mode of %@AB@%stdin%@AE@%, %@AB@%stdout%@AE@%, %@AB@%stderr%@AE@%, %@AB@%stdaux%@AE@%, and %@AB@%stdprn%@AE@%, but can be used on any
file. If %@AB@%setmode%@AE@% is applied to the file handle for a stream, the %@AB@%setmode%@AE@%
function should be called before any input or output operations are
performed on the stream.%@CR:C6A02841337 @%%@CR:C6A02841338 @%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, %@AB@%setmode%@AE@% returns the previous translation mode. A return value
of -1 indicates an error, and %@AB@%errno%@AE@% is set to one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EBADF%@AE@%                             Invalid file handle

%@AB@%EINVAL%@AE@%                            Invalid %@AI@%mode%@AE@% argument (neither%@AB@% O_TEXT%@AE@%nor%@AB@%%@AE@%
                                  %@AB@%O_BINARY%@AE@% )

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%creat%@AE@%, %@AB@%fopen%@AE@%, %@AB@%open%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SETMODE.C: This program uses setmode to change stdin from text
%@AS@%   * mode to binary mode.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <fcntl.h>
%@AS@%  #include <io.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int result;
%@AS@%  
%@AS@%     /* Set "stdin" to have binary mode: */
%@AS@%     result = setmode( fileno( stdin ), O_BINARY );
%@AS@%     if( result == -1 )
%@AS@%        perror( "Cannot set mode" );
%@AS@%     else
%@AS@%        printf( "'stdin' successfully changed to binary mode\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  'stdin' successfully changed to binary mode%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setpixel@%%@NL@%
%@2@%%@CR:C6A02851339 @%%@AB@%_setpixel Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02851340 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Set a pixel to the current color.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _setpixel( short x, short y );%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _setpixel_w( double wx, double wy );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              Target pixel

%@AI@%wx%@AE@%, %@AI@%wy%@AE@%                            Target pixel

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setpixel%@AE@% and the %@AB@%_setpixel_w%@AE@% functions set a pixel at a specified
location to the current color.  %@NL@%
%@NL@%
The %@AB@%_setpixel%@AE@% function sets the pixel at the view-coordinate point (%@AI@%x%@AE@%, %@AI@%y%@AE@%) to
the current color.  %@NL@%
%@NL@%
The %@AB@%_setpixel_w%@AE@% function sets the pixel at the window-coordinate point (%@AI@%wx%@AE@%,
%@AI@%wy%@AE@%) to the current color.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the previous value of the target pixel. If the function
fails (for example, the point lies outside of the clipping region), it will
return -1.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getpixel%@AE@% functions,  %@AB@%_setcolor%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* GPIXEL.C: This program assigns different colors to randomly
%@AS@%   * selected pixels.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short xvar, yvar;
%@AS@%     struct videoconfig vc;%@AE@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXCOLORMODE ) )
%@AS@%        exit( 1 );
%@AS@%     _getvideoconfig( &vc );
%@AS@%  
%@AS@%     /* Draw filled ellipse to turn on certain pixels. */
%@AS@%     _ellipse( _GFILLINTERIOR, vc.numxpixels / 6, vc.numypixels / 6,
%@AS@%                               vc.numxpixels / 6 * 5, vc.numypixels / 6 * 5
%@AS@%                                             );
%@AS@%  
%@AS@%     /* Draw random pixels in random colors... */
%@AS@%     while( !kbhit() )
%@AS@%     {
%@AS@%        /* ...but only if they are already on (inside the ellipse). */
%@AS@%        xvar = rand() % vc.numxpixels;
%@AS@%        yvar = rand() % vc.numypixels;
%@AS@%        if( _getpixel( xvar, yvar ) != 0 )
%@AS@%        {
%@AS@%           _setcolor( rand() % 16 );
%@AS@%           _setpixel( xvar, yvar );
%@AS@%        }
%@AS@%     }
%@AS@%  
%@AS@%     getch();          /* Throw away the keystroke. */
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_settextcolor@%%@NL@%
%@2@%%@CR:C6A02861341 @%%@AB@%_settextcolor%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02861342 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the current text color.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _settextcolor( short index );%@AE@%%@NL@%
%@NL@%
%@AI@%index%@AE@%                             Desired color index

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_settextcolor%@AE@% function sets the current text color to the color index
specified by %@AI@%index%@AE@%. The default text color is the same as the maximum color
index.  %@NL@%
%@NL@%
The %@AB@%_settextcolor%@AE@% routine sets the color for the %@AB@%_outtext%@AE@% and %@AB@%_outmem%@AE@%
functions only. It does not affect the color of the %@AB@%printf%@AE@% function or the
color of text output with the %@AB@%_outgtext%@AE@% font routine. Use the %@AB@%_setcolor%@AE@%
function to change the color of font output.  %@NL@%
%@NL@%
In text color mode, you can specify a color index in the range 0 -31. The
colors in the range 0 -15 are interpreted as normal (non-blinking). The
normal color range is defined below:  %@NL@%
%@NL@%
%@TH:  18   492 02 08 10 07 51 @%%@AB@%Index %@AE@%  Color     %@AB@%Index%@AE@%  %@AB@%Color%@AE@%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%0       Black     8      Dark gray1       Blue      9      Light blue2       Green     10     Light green3       Cyan      11     Light cyan4       Red       12     Light red5       Magenta   13     Light magenta6       Brown     14     Yellow7       White     15     Bright white%@TE:  18   492 02 08 10 07 51 @%

Blinking is selected by adding 16 to the normal color value.  %@NL@%
%@NL@%
In every text mode, including monochrome, %@AB@%_getvideoconfig%@AE@% returns the value
32 for the number of available colors. The value 32 indicates the range of
values (0 -31) accepted by the%@AB@% _settextcolor%@AE@% function. This includes sixteen
normal colors (0 -15) and sixteen blinking colors (16 -31). Monochrome text
mode has fewer unique display attributes, so some color values are
redundant. However, because blinking is selected in the same manner,
monochrome text mode has the same range (0 -31) as other text modes.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the color index of the previous text color. There is no
error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_gettextcolor%@AE@%,  %@AB@%_outtext%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* OUTTXT.C: This example illustrates text output functions:
%@AS@%   *    _gettextcolor   _getbkcolor   _gettextposition   _outtext
%@AS@%   *    _settextcolor   _setbkcolor   _settextposition
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  char buffer [80];
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%  
%@AS@%     /* Save original foreground, background, and text position */
%@AS@%     short blink, fgd, oldfgd;
%@AS@%     long  bgd, oldbgd;
%@AS@%     struct rccoord oldpos;
%@AS@%  
%@AS@%     /* Save original foreground, background, and text position. */
%@AS@%     oldfgd = _gettextcolor();
%@AS@%     oldbgd = _getbkcolor();
%@AS@%     oldpos = _gettextposition();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%  
%@AS@%     /* First time no blink, second time blinking. */
%@AS@%     for( blink = 0; blink <= 16; blink += 16 )
%@AS@%     {
%@AS@%        /* Loop through 8 background colors. */
%@AS@%        for( bgd = 0; bgd < 8; bgd++ )
%@AS@%        {
%@AS@%           _setbkcolor( bgd );
%@AS@%           _settextposition( (short)bgd + ((blink / 16) * 9) + 3, 1 );
%@AS@%           _settextcolor( 7 );
%@AS@%           sprintf(buffer, "Back: %d Fore:", bgd );
%@AS@%           _outtext( buffer );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Loop through 16 foreground colors. */
%@AS@%           for( fgd = 0; fgd < 16; fgd++ )
%@AS@%           {
%@AS@%              _settextcolor( fgd + blink );
%@AS@%              sprintf( buffer, " %2d ", fgd + blink );
%@AS@%              _outtext( buffer );
%@AS@%           }
%@AS@%        }
%@AS@%     }
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Restore original foreground, background, and text position. */
%@AS@%     _settextcolor( oldfgd );
%@AS@%     _setbkcolor( oldbgd );
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%     _settextposition( oldpos.row, oldpos.col );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_settextcursor@%%@NL@%
%@2@%%@CR:C6A02871343 @%%@AB@%_settextcursor%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02871344 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the current cursor attribute.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _settextcursor( short attr );%@AE@%%@NL@%
%@NL@%
%@AI@%attr%@AE@%                              Cursor attribute

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_settextcursor%@AE@% function sets the cursor attribute (i.e., the shape) to
the value specified by %@AI@%attr%@AE@%. The high-order byte of %@AI@%attr%@AE@% determines the top
line of the cursor within the character cell. The low-order byte of %@AI@%attr%@AE@%
determines the bottom line of the cursor.  %@NL@%
%@NL@%
The %@AB@%_settextcursor%@AE@% function uses the same format as the BIOS routines in
setting the cursor. Typical values for the cursor attribute are listed
below:  %@NL@%
%@NL@%
%@AB@%Attribute%@AE@%                         %@AB@%Cursor Shape%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
0x0707                            Underline

0x0007                            Full block cursor

0x0607                            Double underline

0x2000                            No cursor

Note that this function works only in text video modes.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the previous cursor attribute, or -1 if an error occurs
(such as calling the function in a graphics screen mode).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_displaycursor%@AE@%,  %@AB@%_gettextcursor%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* DISCURS.C: This program changes the cursor shape using _gettextcursor
%@AS@%   * and _settextcursor, and hides the cursor using _displaycursor.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     short oldcursor;
%@AS@%     short newcursor = 0x007;        /* Full block cursor */
%@AS@%  
%@AS@%     /* Save old cursor shape and make sure cursor is on. */
%@AS@%     oldcursor = _gettextcursor();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%     _displaycursor( _GCURSORON );
%@AS@%     _outtext( "\nOld cursor shape: " );
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Change cursor shape. */
%@AS@%     _outtext( "\nNew cursor shape: " );
%@AS@%     _settextcursor( newcursor );
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Restore original cursor shape. */
%@AS@%     _outtext( "\n" );
%@AS@%     _settextcursor( oldcursor );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_settextposition@%%@NL@%
%@2@%%@CR:C6A02881345 @%%@AB@%_settextposition%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02881346 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the text position.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct rccoord _far _settextposition( short row, short column );%@AE@%%@NL@%
%@NL@%
%@AI@%row%@AE@%, %@AI@%column%@AE@%                       New output start position

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_settextposition%@AE@% function sets the current text position to the display
point (%@AI@%row%@AE@%, %@AI@%column%@AE@%). The %@AB@%_outtext%@AE@% and %@AB@%_outmem %@AE@%functions (and standard
console I/O routines, such as %@AB@%printf%@AE@%) output text at that point.  %@NL@%
%@NL@%
The %@AB@%rccoord%@AE@% structure, defined in GRAPH.H, contains the following elements:
%@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%short row%@AE@%                         Row coordinate

%@AB@%short col%@AE@%                         Column coordinate

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the previous text position in an %@AB@%rccoord%@AE@% structure,
defined in GRAPH.H.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_gettextposition%@AE@%,  %@AB@%_outtext%@AE@%,  %@AB@%_settextwindow%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* OUTTXT.C: This example illustrates text output functions:
%@AS@%   *    _gettextcolor   _getbkcolor   _gettextposition   _outtext
%@AS@%   *    _settextcolor   _setbkcolor   _settextposition
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  char buffer [80];
%@AS@%  
%@AS@%  void main()
%@AS@%  {%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Save original foreground, background, and text position */
%@AS@%     short blink, fgd, oldfgd;
%@AS@%     long  bgd, oldbgd;
%@AS@%     struct rccoord oldpos;
%@AS@%  
%@AS@%     /* Save original foreground, background, and text position. */
%@AS@%     oldfgd = _gettextcolor();
%@AS@%     oldbgd = _getbkcolor();
%@AS@%     oldpos = _gettextposition();
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%  
%@AS@%     /* First time no blink, second time blinking. */
%@AS@%     for( blink = 0; blink <= 16; blink += 16 )
%@AS@%     {
%@AS@%        /* Loop through 8 background colors. */
%@AS@%        for( bgd = 0; bgd < 8; bgd++ )
%@AS@%        {
%@AS@%           _setbkcolor( bgd );
%@AS@%           _settextposition( (short)bgd + ((blink / 16) * 9) + 3, 1 );
%@AS@%           _settextcolor( 7 );
%@AS@%           sprintf(buffer, "Back: %d Fore:", bgd );
%@AS@%           _outtext( buffer );
%@AS@%  
%@AS@%           /* Loop through 16 foreground colors. */
%@AS@%           for( fgd = 0; fgd < 16; fgd++ )
%@AS@%           {
%@AS@%              _settextcolor( fgd + blink );
%@AS@%              sprintf( buffer, " %2d ", fgd + blink );
%@AS@%              _outtext( buffer );
%@AS@%           }
%@AS@%        }
%@AS@%     }
%@AS@%     getch();
%@AS@%  
%@AS@%     /* Restore original foreground, background, and text position. */
%@AS@%     _settextcolor( oldfgd );
%@AS@%     _setbkcolor( oldbgd );
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%     _settextposition( oldpos.row, oldpos.col );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_settextrows@%%@NL@%
%@2@%%@CR:C6A02891347 @%%@AB@%_settextrows%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02891348 @% %@CR:C6A02891349 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the number of screen rows for text modes.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _settextrows( short rows );%@AE@%%@NL@%
%@NL@%
%@AI@%rows%@AE@%                              Number of text rows

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_settextrows%@AE@% function specifies the number of screen rows to be used in
text modes.  %@NL@%
%@NL@%
If the constant %@AB@%_MAXTEXTROWS%@AE@% is specified for the %@AI@%rows%@AE@% argument, the
function will choose the maximum number of rows available. In text modes,
this is 50 rows on VGA, 43 on EGA, and 25 on others. In graphics modes that
support 30 or 60 rows, %@AB@%_MAXTEXTROWS%@AE@% specifies 60 rows.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
This function returns the numbers of rows set. The function returns 0 if an
error occurred.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getvideoconfig%@AE@%,  %@AB@%_setvideomode%@AE@%,  %@AB@%_setvideomoderows%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STXTROWS.C: This program attempts to set the screen height. It returns
%@AS@%   * an errorlevel code of 1 (fail) or 0 (success) that could be tested in
%@AS@%   * a batch file.
%@AS@%   */
%@AS@%  
%@AS@%  #include <graph.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main( int argc, char **argv )
%@AS@%  {
%@AS@%     short rows;
%@AS@%  
%@AS@%     if( !(rows = atoi( argv[1] )) )
%@AS@%     {
%@AS@%        _outtext( "\nSyntax: STXTROWS [ 25 | 43 | 50 ]\n" );
%@AS@%        exit( 1 );
%@AS@%     }%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Make sure new rows are the same as requested rows. */
%@AS@%     if( _settextrows( rows ) != rows )
%@AS@%     {
%@AS@%        _outtext( "\nInvalid rows\n" );
%@AS@%        exit( 1 );
%@AS@%     }
%@AS@%     else
%@AS@%        exit( 0 );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_settextwindow@%%@NL@%
%@2@%%@CR:C6A02901350 @%%@AB@%_settextwindow%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02901351 @% %@CR:C6A02901352 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Creates a text window.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _settextwindow( short r1, short c1, short r2, short c2 );%@AE@%%@NL@%
%@NL@%
%@AI@%r1%@AE@%, %@AI@%c1%@AE@%                            Upper-left corner of window

%@AI@%r2%@AE@%, %@AI@%c2%@AE@%                            Lower-right corner of window

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_settextwindow%@AE@% function specifies a window in row and column coordinates
where all text output to the screen is displayed. The arguments (%@AI@%r1%@AE@%, %@AI@%c1%@AE@%)
specify the upper-left corner of the text window, and the arguments (%@AI@%r2%@AE@%, %@AI@%c2%@AE@%)
specify the lower-right corner of the text window.  %@NL@%
%@NL@%
Text is output from the top of the text window down. When the text window is
full, the uppermost line scrolls up out of it.  %@NL@%
%@NL@%
Note that this function does not affect the output of presentation-graphics
text (e.g., labels, axis marks, etc.). It also does not affect the output of
the font display routine %@AB@%_outgtext%@AE@%. Use the %@AB@%_setviewport%@AE@% function to control
the display area for presentation graphics or fonts.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_gettextposition%@AE@%,  %@AB@%_gettextwindow%@AE@%,  %@AB@%_outtext%@AE@%,  %@AB@%_settextposition%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_scrolltextwindow%@AE@%. %@NL@%
%@NL@%
%@NL@%
%@QR:setvbuf@%%@NL@%
%@2@%%@CR:C6A02911353 @%%@AB@%setvbuf%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Controls stream buffering and buffer size.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int setvbuf( FILE *stream, char *buffer, int mode, size_t size );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to %@AB@%FILE structure%@AE@%

%@AI@%buffer%@AE@%                            User-allocated buffer

%@AI@%mode%@AE@%                              Mode of buffering:  _%@AB@%IOFBF%@AE@% (full 
                                  buffering), _%@AB@%IOLBF%@AE@% (line buffering), _%@AB@%%@AE@%
                                  %@AB@%IONBF%@AE@% (no buffer)

%@AI@%size%@AE@%                              Size of buffer

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%setvbuf%@AE@% function allows the program to control both buffering and buffer
size for %@AI@%stream%@AE@%. The %@AI@%stream%@AE@% must refer to an open file that has not been
read from or written to since it was opened. The array pointed to by %@AI@%buffer%@AE@%
is used as the buffer, unless it is %@AB@%NULL%@AE@%, and an automatically allocated
buffer %@AI@%size%@AE@% bytes long is used.  %@NL@%
%@NL@%
The mode must be %@AB@%_IOFBF%@AE@%, %@AB@%_%@AE@%IOLBF, or %@AB@%_IONBF%@AE@%. If %@AI@%mode %@AE@%is%@AI@% %@AE@%%@AB@%_IOFBF%@AE@% or %@AB@%_IOLBF,%@AE@%
then %@AI@%size%@AE@% is used as the size of the buffer. If %@AI@%mode%@AE@% is %@AB@%_IONBF%@AE@%, the stream
is unbuffered and %@AI@%size%@AE@% and %@AI@%buffer%@AE@% are ignored.  %@NL@%
%@NL@%
Values for %@AI@%mode%@AE@% and their meanings are:  %@NL@%
%@NL@%
%@AB@%Type%@AE@%                              %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_IOFBF%@AE@%                            Full buffering; that is, %@AI@%buffer%@AE@% is used 
                                  as the buffer and %@AI@%size%@AE@% is used as the 
                                  size of the buffer. If %@AI@%buffer%@AE@% is %@AB@%NULL%@AE@%, 
                                  an automatically allocated buffer %@AI@%size%@AE@% 
                                  bytes long is used.

%@AB@%_IOLBF%@AE@%                            Under DOS and OS/2, the same as %@AB@%_IOFBF%@AE@%.

%@AB@%_IONBF%@AE@%                            No buffer is used, regardless of %@AI@%buffer%@AE@% 
                                  or %@AI@%size%@AE@%.

The legal values for %@AI@%size%@AE@% are greater than 0 and less than 32,768.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return value for %@AB@%setvbuf%@AE@% is 0 if successful, and a nonzero value if an
illegal type or buffer size is specified.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
 %@AB@%fclose%@AE@%,%@AB@% fflush%@AE@%,%@AB@% fopen, setbuf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SETVBUF.C: This program opens two streams named stream1 and stream2.
%@AS@%   * It then uses setvbuf to give stream1 a user-defined buffer of 1024
%@AS@%   * bytes and stream2 no buffer.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buf[1024];
%@AS@%     FILE *stream1, *stream2;
%@AS@%  
%@AS@%     if( ((stream1 = fopen( "data1", "a" )) != NULL) &&
%@AS@%         ((stream2 = fopen( "data2", "w" )) != NULL) )
%@AS@%     {
%@AS@%        if( setvbuf( stream1, buf, _IOFBF, sizeof( buf ) ) != 0 )
%@AS@%           printf( "Incorrect type or size of buffer for stream1\n" );
%@AS@%        else
%@AS@%           printf( "'stream1' now has a buffer of 1024 bytes\n" );
%@AS@%        if( setvbuf( stream2, NULL, _IONBF, 0 ) != 0 )
%@AS@%           printf( "Incorrect type or size of buffer for stream2\n" );
%@AS@%        else
%@AS@%           printf( "'stream2' now has no buffer\n" );
%@AS@%        fcloseall();
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  'stream1' now has a buffer of 1024 bytes
%@AS@%  'stream2' now has no buffer
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setvideomode@%%@NL@%
%@2@%%@CR:C6A02921354 @%%@AB@%_setvideomode%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02921355 @%%@CR:C6A02921356 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the video mode.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _setvideomode( short mode );%@AE@%%@NL@%
%@NL@%
%@AI@%mode%@AE@%                              Desired mode

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setvideomode%@AE@% function selects a screen mode appropriate for a
particular hardware/display configuration. The %@AI@%mode%@AE@% argument can be one of
the manifest constants shown in Table R.9 and defined in GRAPH.H.  %@NL@%
%@NL@%
%@AB@%Table   R.9 Manifest Constants for Screen Mode%@AE@%

%@TH:  48  2321 02 21 19 19 11 12 @%Mode                 Type%@AU@%(1)%@AE@%            Size%@AU@%(2)%@AE@%            Colors%@AU@%(3)%@AE@%  Adapter%@AU@%(4)%@AE@%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%_DEFAULTMODE%@AE@%         Hardware default                                           mode                                  %@AB@%_MAXRESMODE%@AE@%          Highest                                                    resolution in                                              graphics mode                         %@AB@%_MAXCOLORMODE%@AE@%        Maximum colors in                                          graphics mode                         %@AB@%_TEXTBW40%@AE@%            M/T                40 x 25            16         CGA%@AB@%_TEXTC40%@AE@%             C/T                40 x 25            16         CGA%@AB@%_TEXTBW80%@AE@%            M/T                80 x 25            16         CGA%@AB@%_TEXTC80%@AE@%             C/T                80 x 25            6          CGA%@AB@%_MRES4COLOR%@AE@%          C/G                320 x 200          4          CGA%@AB@%_MRESNOCOLOR%@AE@%         M/G                320 x 200          4          CGA%@AB@%_HRESBW%@AE@%              M/G                640 x 200          2          CGA%@AB@%_TEXTMONO%@AE@%            M/T                80 x 25            1          MDPA%@AB@%_HERCMONO%@AE@%%@AU@%(5)%@AE@%         Hercules graphics  720 x 348          1          HGC%@AB@%_MRES16COLOR%@AE@%         C/G                320 x 200          16         EGA%@AB@%_HRES16COLOR%@AE@%         C/G                640 x 200          16         EGA%@AB@%_ERESNOCOLOR%@AE@%         M/T                640 x 350          1          EGA%@AB@%_ERESCOLOR%@AE@%           C/G                640 x 350          16         EGA%@AB@%_VRES2COLOR%@AE@%          C/G                640 x 480          2          VGA%@AB@%_VRES16COLOR%@AE@%         C/G                640 x 480          16         VGA%@AB@%_MRES256COLOR%@AE@%        C/G                320 x 200          256        VGA%@AB@%_ORESCOLOR%@AE@%           C/G                640 x 400          1 of 16    OLIV%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  48  2321 02 21 19 19 11 12 @%

1. M indicates monochrome, C indicates color output, T indicates text, and G
indicates graphics generation.
2. For text modes, size is given in characters (columns  x  rows). For
graphics modes, size is given in pixels   (horizontal  x  vertical).
3. For monochrome displays, the number of colors is the number of gray
shades.
4. Adapters are the IBM (and compatible) Monochrome Adapter (MDPA), Color
Graphics Adapter (CGA),    Enhanced Graphics Adapter (EGA), Video Graphics
Array (VGA), Hercules-compatible adapter (HGC), and   Olivetti-compatible
adapter (OLIV). 
5.  In %@AB@%_HERCMONO%@AE@% mode, the text dimensions are 80 columns by 25 rows, with a
9 by 14 character box. The    bottom two scan lines of row 25 are not
visible.%@NL@%
%@NL@%
%@NL@%
Note that only standard hardware is described here, but display hardware
that is strictly compatible with IBM, Hercules, or Olivetti hardware should
also work as described.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%_MAXRESMODE and _MAXCOLORMODE%@AE@%%@EH@%%@NL@%
%@NL@%
The two special modes %@AB@%_MAXRESMODE%@AE@% and %@AB@%_MAXCOLORMODE%@AE@% select the highest
resolution or greatest number of colors available with the current hardware,
respectively. These two modes fail for adapters that do not support graphics
modes.  %@NL@%
%@NL@%
Table R.10 lists the video mode selected for different adapter and monitor
combinations when %@AB@%_MAXRESMODE%@AE@% or %@AB@%_MAXCOLORMODE%@AE@% is specified:  %@NL@%
%@NL@%
%@AB@%Table   R.10 Modes Selected by _MAXRESMODE and _MAXCOLORMODE%@AE@%

%@TH:  32  1196 02 17 14 45 @%Adapter/Monitor  _MAXRESMODE   _MAXCOLORMODE%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%MDPA             fails         failsHGC              %@AB@%_HERCMONO%@AE@%     %@AB@%_HERCMONO%@AE@%CGA color*       %@AB@%_HRESBW%@AE@%       %@AB@%_MRES4COLOR%@AE@%CGA noncolor*    %@AB@%_HRESBW%@AE@%       %@AB@%_MRESNOCOLOR%@AE@%OCGA             %@AB@%_ORESCOLOR%@AE@%    %@AB@%_MRES4COLOR%@AE@%OEGA color       %@AB@%_ORESCOLOR%@AE@%    %@AB@%_ERESCOLOR%@AE@%EGA color 256K   %@AB@%_HRES16COLOR%@AE@%  %@AB@%_HRES16COLOR%@AE@%EGA color 64K    %@AB@%_HRES16COLOR%@AE@%  %@AB@%_HRES16COLOR%@AE@%EGA ecd 256K     %@AB@%_ERESCOLOR%@AE@%    %@AB@%_ERESCOLOR%@AE@%EGA ecd 64K      %@AB@%_ERESCOLOR%@AE@%    %@AB@%_HRES16COLOR%@AE@%EGA mono         %@AB@%_ERESNOCOLOR%@AE@%  %@AB@%_ERESNOCOLOR%@AE@%MCGA             %@AB@%_VRES2COLOR%@AE@%   %@AB@%_MRES256COLOR%@AE@%VGA              %@AB@%_VRES16COLOR%@AE@%  %@AB@%_MRES256COLOR%@AE@%OVGA             %@AB@%_VRES16COLOR%@AE@%  %@AB@%_MRES256COLOR%@AE@%%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  32  1196 02 17 14 45 @%

* Color monitor is assumed if the start-up text mode was TEXTC80 or TEXTC40
or if the start-up mode   was graphics mode. Composite or other noncolor CGA
monitor is assumed if start-up mode was TEXTBW80 or   TEXTBW40.%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Hercules Support%@AE@%%@EH@%%@NL@%
%@NL@%
You must install the Hercules driver MSHERC.COM before running your program.
Type MSHERC to load the driver. This can be done from an AUTOEXEC.BAT file.
%@NL@%
%@NL@%
If you have both a Hercules monochrome card and a color video card, you
should install MSHERC.COM with the /H (/HALF) option. The /H option causes
the driver to use one instead of two graphics pages. This prevents the two
video cards from attempting to use the same memory. You do not have to use
the /H option if you have only a Hercules card. See your Hercules hardware
manuals for more details of compatibility.  %@NL@%
%@NL@%
To use a mouse, you must follow special instructions for Hercules cards in
%@AI@%Microsoft Mouse Programmer's Reference Guide%@AE@%. (This is sold separately; it
is not supplied with either Microsoft C or the mouse package.)  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the number of text rows if the function is successful.
If an error is encountered (that is, the mode selected is not supported by
the current hardware configuration), the function returns 0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
In OS/2, only text video modes may be selected by %@AB@%_setvideomode%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getvideoconfig%@AE@%,  %@AB@%_settextrows%@AE@%,  %@AB@%_setvideomoderows%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SVIDMODE.C: This program sets a video mode from a string given on the
%@AS@%   * command line.
%@AS@%   */
%@AS@%  
%@AS@%  #include <graph.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <string.h>
%@AS@%  
%@AS@%  short modes[] = { _TEXTBW40,     _TEXTC40,      _TEXTBW80,
%@AS@%                    _TEXTC80,      _MRES4COLOR,   _MRESNOCOLOR,
%@AS@%                    _HRESBW,       _TEXTMONO,     _HERCMONO,
%@AS@%                    _MRES16COLOR,  _HRES16COLOR,  _ERESNOCOLOR,
%@AS@%                    _ERESCOLOR,    _VRES2COLOR,   _VRES16COLOR,
%@AS@%                    _MRES256COLOR, _ORESCOLOR
%@AS@%                  };
%@AS@%  char *names[] = { "TEXTBW40",    "TEXTC40",     "TEXTBW80",
%@AS@%                    "TEXTC80",     "MRES4COLOR",  "MRESNOCOLOR",
%@AS@%                    "HRESBW",      "TEXTMONO",    "HERCMONO",
%@AS@%                    "MRES16COLOR", "HRES16COLOR", "ERESNOCOLOR",
%@AS@%                    "ERESCOLOR",   "VRES2COLOR",  "VRES16COLOR",
%@AS@%                    "MRES256COLOR","ORESCOLOR"
%@AS@%                   };
%@AS@%  
%@AS@%  void error( char *msg );
%@AS@%  
%@AS@%  
%@AS@%  void main( int argc, char *argv[] )
%@AS@%  {
%@AS@%     short i, num = sizeof( modes ) / sizeof( short );
%@AS@%     struct videoconfig vc;
%@AS@%  
%@AS@%     if( argc < 2 )
%@AS@%        error( "No argument given" );
%@AS@%  
%@AS@%     /* If matching name found, change to corresponding mode. */
%@AS@%     for( i = 0; i < num; i++ )
%@AS@%     {
%@AS@%        if( !strcmpi( argv[1], names[i] ) )
%@AS@%        {
%@AS@%           _setvideomode( modes[i] );
%@AS@%           _outtext( "New mode is: " );
%@AS@%           _outtext( names[i] );
%@AS@%           exit( 0 );
%@AS@%        }
%@AS@%     }
%@AS@%     error( "Invalid mode string" );
%@AS@%  }
%@AS@%  
%@AS@%  void error( char *msg )
%@AS@%  {
%@AS@%     _outtext( msg );
%@AS@%     exit( 1 );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setvideomoderows@%%@NL@%
%@2@%%@CR:C6A02931357 @%%@AB@%_setvideomoderows%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02931358 @% %@CR:C6A02931359 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the video mode and number of text rows for text modes.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _setvideomoderows( short mode, short rows );%@AE@%%@NL@%
%@NL@%
%@AI@%mode%@AE@%                              Desired mode

%@AI@%rows%@AE@%                              Number of text rows

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setvideomoderows%@AE@% function selects a screen mode for a particular
hardware/display combination. The manifest constants for the screen mode are
given in the reference pages for %@AB@%_setvideomode%@AE@%. The %@AB@%_setvideomoderows%@AE@%
function also specifies the number of text rows to be used in a text mode.
If the constant %@AB@%_MAXTEXTROWS%@AE@% is specified for the %@AI@%rows%@AE@% argument, the
function will choose the maximum number of rows available. In text modes,
this is 50 rows on VGA, 43 on EGA, and 25 on others. In graphics modes that
support 30 or 60 rows, %@AB@%_MAXTEXTROWS%@AE@% specifies 60 rows.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%setvideomoderows%@AE@% function returns the numbers of rows set. The function
returns 0 if an error occurred (e.g., if the mode is not supported).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
In OS/2, only text video modes may be selected by %@AB@%_setvideomoderows%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getvideoconfig%@AE@%,  %@AB@%_settextrows%@AE@%, %@AB@% _setvideomode%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SVMROWS.C */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct videoconfig config;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Set 43-line graphics mode if available. */
%@AS@%     if( !_setvideomoderows( _ERESCOLOR, 43 ) )
%@AS@%     {
%@AS@%        _outtext( "EGA or VGA required" );
%@AS@%        exit( 1 );
%@AS@%     }
%@AS@%     _getvideoconfig( &config );
%@AS@%  
%@AS@%     /* Set logical origin to center and draw a rectangle. */
%@AS@%     _setlogorg( config.numxpixels / 2 - 1, config.numypixels / 21 );
%@AS@%     _rectangle( _GBORDER, -80, -50, 80, 50 );
%@AS@%  
%@AS@%     getch();
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setvieworg@%%@NL@%
%@2@%%@CR:C6A02941360 @%%@AB@%_setvieworg%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02941361 @%%@CR:C6A02941362 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Moves the view-coordinate origin to the specified physical point.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  struct xycoord _far _setvieworg( short x, short y );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%, %@AI@%y%@AE@%                              New origin point

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setvieworg%@AE@% function moves the view-coordinate origin (0, 0) to the
physical point (%@AI@%x%@AE@%, %@AI@%y%@AE@%). All other view-coordinate points move the same
direction and distance.  %@NL@%
%@NL@%
The %@AB@%xycoord%@AE@% structure, defined in GRAPH.H, contains the following elements:
%@NL@%
%@NL@%
%@AB@%Element%@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%short xcoord%@AE@%                      %@AI@%x%@AE@% coordinate

%@AB@%short ycoord%@AE@%                      %@AI@%y%@AE@% coordinate

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%
C 5.1 Difference
%@AI@%%@AI@%This function replaces the %@AE@%%@AI@%%@AB@%_setlogorg%@AE@%%@AE@%%@AI@% function.%@AE@%%@AE@%%@NL@%
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@NL@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the physical coordinates of the previous view origin in
an %@AB@%xycoord%@AE@% structure, defined in GRAPH.H.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@%_getphyscoord, %@AB@% _getviewcoord%@AE@%, %@AB@% _getwindowcoord%@AE@%, %@AB@% _setcliprgn%@AE@%,  %@AB@%_setviewport%@AE@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SVORG.C: This program sets the view origin to the center of
%@AS@%   * the screen, then draws a rectangle using the new origin.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct videoconfig config;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%     _getvideoconfig( &config );
%@AS@%  
%@AS@%     /* Set view origin to the center of the screen. */
%@AS@%     _setvieworg( config.numxpixels / 2, config.numypixels / 2 );
%@AS@%     _rectangle( _GBORDER, -80, -50, 80, 50 );
%@AS@%  
%@AS@%     getch();
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setviewport@%%@NL@%
%@2@%%@CR:C6A02951363 @%%@AB@%_setviewport%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02951364 @%%@CR:C6A02951365 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Creates a viewport.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _setviewport( short x1, short y1, short x2, short y2 );%@AE@%%@NL@%
%@NL@%
%@AI@%x1%@AE@%, %@AI@%y1%@AE@%                            Upper-left corner of viewport

%@AI@%x2%@AE@%, %@AI@%y2%@AE@%                            Lower-right corner of viewport

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setviewport%@AE@% function redefines the graphics viewport. The %@AB@%_setviewport%@AE@%
function defines a clipping region in exactly the same manner as
%@AB@%_setcliprgn%@AE@%, and then sets the view-coordinate origin to the upper-left
corner of the region. The physical points (%@AI@%x1%@AE@%, %@AI@%y1%@AE@%) and (%@AI@%x2%@AE@%, %@AI@%y2%@AE@%) are the
diagonally opposed corners of the rectangular clipping region. Any window
transformation done with the %@AB@%_setwindow%@AE@% function applies only to the
viewport and not to the entire screen.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_setcliprgn%@AE@%, %@AB@% _setvieworg%@AE@%, %@AB@% _setwindow%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SVIEWPRT.C: This program sets a viewport and then draws a rectangle
%@AS@%   * around it and an ellipse in it.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%  
%@AS@%     _setviewport( 100, 100, 200, 200 );
%@AS@%     _rectangle( _GBORDER, 0, 0, 100, 100 );
%@AS@%     _ellipse( _GFILLINTERIOR, 10, 10, 90, 90 );%@AE@%%@NL@%
%@NL@%
%@AS@%  getch();
%@AS@%     _setvideomode( _DEFAULTMODE );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setvisualpage@%%@NL@%
%@2@%%@CR:C6A02961366 @%%@AB@%_setvisualpage%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02961367 @%%@CR:C6A02961368 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the visual page.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _setvisualpage( short page );%@AE@%%@NL@%
%@NL@%
%@AI@%page%@AE@%                              Visual page number

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
For hardware configurations that have an EGA or a VGA and enough memory to
support multiple-screen pages, the %@AB@%_setvisualpage%@AE@% function selects the
current visual page. The %@AI@%page%@AE@% argument specifies the current visual page.
The default page number is 0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the number of the previous visual page. If the function
fails, it returns a negative value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getactivepage%@AE@%, %@AB@% _getvisualpage%@AE@%, %@AB@% _setactivepage%@AE@%, %@AB@% _setvideomode%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_setactivepage%@AE@%. %@NL@%
%@NL@%
%@NL@%
%@QR:_setwindow@%%@NL@%
%@2@%%@CR:C6A02971369 @%%@AB@%_setwindow%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02971370 @%%@CR:C6A02971371 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Defines a graphics window.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _setwindow( short finvert, double wx1, double wy1, double wx2, 
%@AS@%  double wy2 );%@AE@%%@NL@%
%@NL@%
%@AI@%finvert%@AE@%                           Invert flag

%@AI@%wx1%@AE@%, %@AI@%wy1%@AE@%                          Upper-left corner of window

%@AI@%wx2%@AE@%, %@AI@%wy2%@AE@%                          Lower-right corner of window

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setwindow%@AE@% function defines a window bounded by the specified
coordinates. The arguments (%@AI@%wx1%@AE@%, %@AI@%wy1%@AE@%) specify the upper-left corner of the
window, and the arguments (%@AI@%wx2%@AE@%, %@AI@%wy2%@AE@%) specify the lower-right corner of the
window.  %@NL@%
%@NL@%
The %@AI@%finvert%@AE@% argument specifies the direction of the coordinates. If %@AI@%finvert%@AE@%
is %@AB@%TRUE%@AE@%, the %@AI@%y%@AE@% axis increases from the screen bottom to the screen top
(Cartesian coordinates). If %@AI@%finvert%@AE@% is %@AB@%FALSE%@AE@%, the %@AI@%y%@AE@% axis increases from the
screen top to the screen bottom (screen coordinates).  %@NL@%
%@NL@%
Any window transformation done with the %@AB@%_setwindow%@AE@% function applies only to
the viewport and not to the entire screen.  %@NL@%
%@NL@%
If %@AI@%wx1%@AE@% equals %@AI@%wx2%@AE@% or %@AI@%wy1%@AE@% equals %@AI@%wy2%@AE@%, the function will fail.  %@NL@%
%@NL@%
Note that this function does not affect the output of presentation-graphics
text (e.g., labels, axis marks, etc.). It also does not affect the output of
the font display routine %@AB@%_outgtext%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns a nonzero value if successful. If the function fails
(e.g., if it is not in a graphics mode), it returns 0.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_setviewport%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SWINDOW.C: This program illustrates translation between window,
%@AS@%   * view, and physical coordinates. Functions used include:
%@AS@%   *      _setwindow         _getwindowcoord
%@AS@%   *      _getphyscoord      _getviewcoord_wxy
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  enum boolean { FALSE, TRUE };
%@AS@%  enum display { MOVE, DRAW, ERASE };
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct xycoord view, phys;
%@AS@%     struct _wxycoord oldwin, newwin;
%@AS@%     struct videoconfig vc;
%@AS@%     double xunit, yunit, xinc, yinc;
%@AS@%     short  color, key, fintersect = FALSE, fdisplay = TRUE;
%@AS@%  
%@AS@%     /* Find a valid graphics mode. */
%@AS@%     if( !_setvideomode( _MAXRESMODE ) )
%@AS@%        exit( 1 );
%@AS@%     _getvideoconfig( &vc );
%@AS@%  
%@AS@%     /* Set a window using real numbers. */
%@AS@%     _setwindow( FALSE, -125.0, -100.0, 125.0, 100.0 );
%@AS@%  
%@AS@%     /* Calculate the size of one pixel in window coordinates.
%@AS@%      * Then get the current window coordinates and color.
%@AS@%      */
%@AS@%     oldwin = _getwindowcoord( 1, 1 );
%@AS@%     newwin = _getwindowcoord( 2, 2 );
%@AS@%     xunit = xinc = newwin.wx - oldwin.wx;
%@AS@%     yunit = yinc = newwin.wy - oldwin.wy;
%@AS@%     newwin = oldwin = _getcurrentposition_w();
%@AS@%     color = _getcolor();
%@AS@%  
%@AS@%     while( 1 )
%@AS@%     {
%@AS@%        /* Set flag according to whether current pixel is on, then
%@AS@%         * turn pixel on.
%@AS@%         */
%@AS@%        if( _getpixel_w( oldwin.wx, oldwin.wy ) == color )
%@AS@%           fintersect = TRUE;
%@AS@%        else
%@AS@%           fintersect = FALSE;
%@AS@%        _setcolor( color );
%@AS@%        _setpixel_w( oldwin.wx, oldwin.wy );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Get and test key. */
%@AS@%        key = getch();
%@AS@%        switch( key )
%@AS@%        {
%@AS@%           case 27:                        /* ESC Quit                 */
%@AS@%              _setvideomode( _DEFAULTMODE );
%@AS@%              exit( 0 );
%@AS@%           case 32:                        /* SPACE    Move no color   */
%@AS@%              fdisplay = MOVE;
%@AS@%              continue;
%@AS@%           case 0:                         /* Extended code - get next */
%@AS@%              key = getch();
%@AS@%              switch( key )
%@AS@%              {
%@AS@%                 case 72:                  /* UP          -y           */
%@AS@%                    newwin.wy -= yinc;
%@AS@%                    break;
%@AS@%                 case 77:                  /* RIGHT    +x              */
%@AS@%                    newwin.wx += xinc;
%@AS@%                    break;
%@AS@%                 case 80:                  /* DOWN        +y           */
%@AS@%                    newwin.wy += yinc;
%@AS@%                    break;
%@AS@%                 case 75:                  /* LEFT     -x              */
%@AS@%                    newwin.wx -= xinc;
%@AS@%                    break;
%@AS@%                 case 82:                  /* INS      Draw white      */
%@AS@%                    fdisplay = DRAW;
%@AS@%                    continue;
%@AS@%                 case 83:                  /* DEL      Draw black      */
%@AS@%                    fdisplay = ERASE;
%@AS@%                    continue;
%@AS@%              }
%@AS@%              break;
%@AS@%        }
%@AS@%  
%@AS@%        /* Translate window coordinates to view, view to physical.
%@AS@%         * Then check physical to make sure we're on screen. Update screen
%@AS@%         * and position if we are. Ignore if not.
%@AS@%         */
%@AS@%        view = _getviewcoord_wxy( &newwin );
%@AS@%        phys = _getphyscoord( view.xcoord, view.ycoord );
%@AS@%        if( (phys.xcoord >= 0) && (phys.xcoord < vc.numxpixels) &&
%@AS@%            (phys.ycoord >= 0) && (phys.ycoord < vc.numypixels) )
%@AS@%        {%@AE@%%@NL@%
%@NL@%
%@AS@%  /* If display on, draw to new position, else move to new. */
%@AS@%           if( fdisplay != MOVE )
%@AS@%           {
%@AS@%              if( fdisplay == ERASE )
%@AS@%                 _setcolor( 0 );
%@AS@%              _lineto_w( newwin.wx, newwin.wy );
%@AS@%           }
%@AS@%           else
%@AS@%           {
%@AS@%              _setcolor( 0 );
%@AS@%              _moveto_w( newwin.wx, newwin.wy );
%@AS@%  
%@AS@%              /* If there was no intersect, erase old pixel. */
%@AS@%              if( !fintersect )
%@AS@%                 _setpixel_w( oldwin.wx, oldwin.wy );
%@AS@%           }
%@AS@%           oldwin = newwin;
%@AS@%        }
%@AS@%        else
%@AS@%           newwin = oldwin;
%@AS@%     }
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_setwritemode@%%@NL@%
%@2@%%@CR:C6A02981372 @%%@AB@%_setwritemode%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02981373 @% %@CR:C6A02981374 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the current logical mode for line drawing.  %@NL@%
%@NL@%
%@AS@%  #include  <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _setwritemode( short action );%@AE@%%@NL@%
%@NL@%
%@AI@%action%@AE@%                            Interaction with existing screen image

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setwritemode%@AE@% function sets the current logical write mode, which is
used when drawing lines with the %@AB@%_lineto%@AE@% and %@AB@%_rectangle%@AE@% functions.  %@NL@%
%@NL@%
The %@AI@%action%@AE@% argument defines the write mode. The possible values are %@AB@%_GAND%@AE@%,
%@AB@%_GOR%@AE@%, %@AB@%_GPRESET%@AE@%, %@AB@%_GPSET%@AE@%, and %@AB@%_GXOR%@AE@%. See the description of the%@AB@% _putimage%@AE@%
function for more details on these manifest constants.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_setwritemode%@AE@% function returns the previous write mode, or -1 if an
error occurs.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_getwritemode%@AE@%, %@AB@% _grstatus%@AE@%, %@AB@% _lineto%@AE@% functions, %@AB@% _putimage%@AE@% functions, %@AB@%
%@AB@%_rectangle%@AE@% functions, %@AB@% _setcolor%@AE@%, %@AB@% _setlinestyle%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_getwritemode%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:signal@%%@NL@%
%@2@%%@CR:C6A02991375 @%%@AB@%signal%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A02991376 @%%@CR:C6A02991377 @% %@CR:C6A02991378 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets interrupt signal handling.  %@NL@%
%@NL@%
%@AS@%  #include <signal.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void ( *signal( int sig, void( *func )( int sig [[, int subcode ]] ) ) ) (
%@AS@%  int sig );%@AE@%%@NL@%
%@NL@%
%@AI@%sig%@AE@%                               Signal value

%@AI@%func%@AE@%%@AB@%%@AE@%                              Function to be executed

%@AI@%subcode%@AE@%                           Optional subcode to the signal number

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%signal%@AE@% function allows a process to choose one of several ways to handle
an interrupt signal from the operating system.  %@NL@%
%@NL@%
The %@AI@%sig%@AE@% argument must be one of the manifest constants described in Table
R.11 and defined in SIGNAL.H.  %@NL@%
%@NL@%
%@AB@%Table   R.11 Signals and Responses%@AE@%

%@TH:  38  2049 02 11 17 23 25 @%Value      Modes            Meaning                Default Action%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@AB@%SIGABRT%@AE@%    Real,            Abnormal termination   Terminates the calling            protected                               program with exit code                                                    3%@AB@%SIGBREAK%@AE@%   Protected        CTRL+BREAK signal      Terminates the calling                                                    program with exit code                                                    3%@AB@%SIGFPE%@AE@%     Real,            Floating-point error   Terminates the calling            protected                               program with exit code                                                    3%@AB@%SIGILL%@AE@%     Real,            Illegal instruction    Terminates the calling            protected                               program with exit code                                                    3%@AB@%SIGINT%@AE@%     Real,            CTRL+C signal          Terminates the calling            protected                               program with exit code                                                    3%@AB@%SIGSEGV%@AE@%    Real,            Illegal storage        Terminates the calling            protected        access                 program with exit code                                                    3%@AB@%SIGTERM%@AE@%    Real,            Termination request    Terminates the calling            protected                               program with exit code                                                    3%@AB@%SIGUSR1%@AE@%    Protected        OS/2 process flag A    Signal is ignored%@AB@%SIGUSR2%@AE@%    Protected        OS/2 process flag B    Signal is ignored%@AB@%SIGUSR3%@AE@%    Protected        OS/2 process flag C    Signal is ignored%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%%@TE:  38  2049 02 11 17 23 25 @%

%@AB@%%@AE@%SIGUSR1, %@AB@%SIGUSR2%@AE@%, and %@AB@%SIGUSR3%@AE@% are user-defined signals which can be sent by
means of %@AB@%DosFlagProcess.%@AE@% For details, see %@AI@%Microsoft Operating System/2
%@AI@%Programmer's Reference%@AE@%.  %@NL@%
%@NL@%
Note that %@AB@%SIGILL, SIGSEGV, %@AE@%and %@AB@%SIGTERM %@AE@%are not generated under DOS and
%@AB@%SIGSEGV%@AE@% is not generated under OS/2. They are included for ANSI
compatibility. Thus, you may set signal handlers for these signals via
%@AB@%signal%@AE@%, and you may also explicitly generate these signals by calling %@AB@%raise.%@AE@%
%@NL@%
%@NL@%
Note also that signal settings are not preserved in child processes created
by calls to %@AB@%exec%@AE@% or %@AB@%spawn%@AE@%. The signal settings are reset to the default in
the child process.  %@NL@%
%@NL@%
The action taken when the interrupt signal is received depends on the value
of %@AI@%func%@AE@%. The %@AI@%func%@AE@% argument must be either a function address or one of the
manifest constants defined in SIGNAL.H and listed below:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%SIG_ACK%@AE@%                           Acknowledges receipt of a signal (OS/2 
                                  only). This constant is valid only if a 
                                  user-defined signal handler is 
                                  installed. Once a process receives a 
                                  given signal, the operating system does 
                                  not send any more signals of this type 
                                  until it receives a %@AB@%SIG_ACK%@AE@% 
                                  acknowledgment from the process. The 
                                  operating system does not queue up 
                                  signals of a given type; therefore, if 
                                  more than one signal of a given type 
                                  accumulates before the process returns a
                                  %@AB@%SIG_ACK%@AE@% value, only the most recent 
                                  signal is sent to the process after the %@AB@%%@AE@%
                                  %@AB@%SIG_ACK%@AE@% value is received by the 
                                  operating system. This option has no 
                                  effect on which handler is installed for
                                  a given signal. The manifest constant %@AB@%%@AE@%
                                  %@AB@%SIG_ACK%@AE@% is not supported for %@AB@%SIGFPE%@AE@% 
                                  signals.

%@AB@%SIG_DFL%@AE@%                           Uses system-default response. The 
                                  system-default response for all signals 
                                  except %@AB@%SIGUSR1%@AE@%, %@AB@%SIGUSR2%@AE@%, and %@AB@%SIGUSR3%@AE@% is 
                                  to abort the calling program. The 
                                  calling process is terminated with exit 
                                  code 3, and control returns to DOS or 
                                  OS/2. If the
                                  calling program uses stream I/O, buffers
                                  created by the run-time library are not 
                                  flushed, but buffers created by the 
                                  operating system are flushed. The 
                                  default response for%@AB@% SIGUSR1%@AE@%, %@AB@%SIGUSR2%@AE@%, 
                                  and %@AB@%SIGUSR3%@AE@% is to ignore the signal.

%@AB@%SIG_ERR%@AE@%                           Ignores interrupt signal (OS/2 only). 
                                  This constant is equivalent to %@AB@%SIG_IGN,%@AE@% 
                                  except that any process that tries to 
                                  send this signal receives an error. A 
                                  process may use the %@AB@%raise%@AE@% function to 
                                  send a signal to itself. A different 
                                  process may send a signal by means of 
                                  the function %@AB@%DosFlagProcess%@AE@% (if the 
                                  signal is %@AB@%SIGUSR1, SIGUSR2%@AE@%, or %@AB@%SIGUSR3%@AE@%) 
                                  or by means of%@AB@%%@AE@%
                                  %@AB@%DosKillProcess%@AE@% (if the signal is %@AB@%SIGTERM%@AE@%
                                  ).

%@AB@%SIG_IGN%@AE@%                           Ignores interrupt signal. This value 
                                  should never be given for %@AB@%SIGFPE%@AE@%, since 
                                  the floating-point state of the process 
                                  is left
                                  undefined.

Function address                  Installs the specified function as the 
                                  handler for the given
                                  signal.

                                  For all signals except%@AB@% SIGFPE %@AE@%and %@AB@%SIGUSR%@AE@%
                                  %@AI@%X%@AE@%, the function is passed the %@AI@%sig%@AE@% 
                                  argument %@AB@%SIGINT%@AE@% and executed.

                                  For %@AB@%SIGFPE%@AE@% signals, the function is 
                                  passed two arguments; namely %@AB@%SIGFPE%@AE@% and 
                                  the floating-point error code 
                                  identifying the type of exception that 
                                  occurred.

                                  For%@AB@% SIGUSR1%@AE@%, %@AB@%SIGUSR2%@AE@%, and %@AB@%SIGUSR3%@AE@%, the 
                                  function is passed two arguments: the 
                                  signal number and the argument furnished
                                  by the %@AB@%DosFlagProcess %@AE@%function.%@AB@%%@AE@%

For %@AB@%SIGFPE%@AE@%, the function pointed to by %@AI@%func%@AE@% is passed two arguments, %@AB@%SIGFPE%@AE@%
and an integer error subcode,%@AB@% FPE_%@AE@%%@AI@%xxx%@AE@%; then the function is executed. (See
the include file%@AI@% %@AE@%FLOAT.H for definitions of the %@AB@%FPE_%@AE@%%@AI@%xxx%@AE@% subcodes.) The value
of %@AI@%func%@AE@% is not reset upon receiving the signal. To recover from
floating-point exceptions, use %@AB@%setjmp%@AE@% in conjunction with %@AB@%longjmp%@AE@%. (See the
example under %@AB@%_fpreset%@AE@%.) If the function returns, the calling process
resumes execution with the floating-point state of the process left
undefined.  %@NL@%
%@NL@%
If the function returns, the calling process resumes execution immediately
following the point at which it received the interrupt signal. This is true
regardless of the type of signal or operating mode.  %@NL@%
%@NL@%
Before the specified function is executed under DOS versions 3.x or earlier,
the value of %@AI@%func%@AE@% is set to %@AB@%SIG_DFL%@AE@%. The next interrupt signal is treated as
described above for %@AB@%SIG_DFL%@AE@%, unless an intervening call to %@AB@%signal%@AE@% specifies
otherwise. This allows the program to reset signals in the called function.
%@NL@%
%@NL@%
Under OS/2, the signal handler is not reset to the system-default response.
Instead, no signals of a given type are received by a process until the
process sends a %@AB@%SIG_ACK%@AE@% value to the operating system. The program can
restore the system-default response from the handler by first sending
%@AB@%SIG_DFL%@AE@% and then sending %@AB@%SIG_ACK%@AE@% to the operating system.  %@NL@%
%@NL@%
Since signal-handler routines are normally called asynchronously when an
interrupt occurs, it is possible that your signal-handler function will get
control when a C run-time operation is incomplete and in an unknown state.
Certain restrictions therefore apply to the C functions that can be used in
your signal-handler routine:  %@NL@%
%@NL@%
%@NL@%
  1.  Do not issue low-level or standard input and output routines (e.g.,
      %@AB@%printf%@AE@%,%@AB@% read%@AE@%, %@AB@%write%@AE@%, and %@AB@%fread%@AE@%).%@AB@%%@AE@%%@NL@%
%@NL@%
  2.  Do not call heap routines or any routine that uses the heap routines
      (e.g., %@AB@%malloc%@AE@%, %@AB@%strdup%@AE@%, %@AB@%putenv%@AE@%).%@NL@%
%@NL@%
  3.  Do not use any C function that generates a system call (e.g., %@AB@%getcwd%@AE@%,
      %@AB@%time%@AE@%).%@NL@%
%@NL@%
  4.  Do not use the %@AB@%longjmp%@AE@% function unless the interrupt is caused by a
      floating-point exception (i.e., %@AI@%sig%@AE@% is %@AB@%SIGFPE).%@AE@% In this case, the
      program should first reinitialize the floating-point package by means
      of a call t%@AB@%o _fpreset%@AE@%.%@NL@%
%@NL@%
  5.  Do not use any overlay routines.%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%signal%@AE@% function returns the previous value of %@AI@%func%@AE@% associated with the
given signal. For example, if the previous value of %@AI@%func%@AE@% was %@AB@%SIG_IGN%@AE@%, the
return value will be %@AB@%SIG_IGN%@AE@%. The one exception to this rule is %@AB@%SIG_ACK%@AE@%,
which returns the address of the currently installed handler.  %@NL@%
%@NL@%
A return value of -1 indicates an error, and %@AB@%errno%@AE@% is set to %@AB@%EINVAL%@AE@%. The
possible error causes are an invalid %@AI@%sig%@AE@% value, an invalid %@AI@%func%@AE@% value (that
is, a value that is less than %@AB@%SIG_ACK%@AE@% but not defined), or a %@AI@%func%@AE@% value of
%@AB@%SIG_ACK%@AE@% used when no handler is currently installed.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%abort%@AE@%, %@AB@%exec%@AE@% functions, %@AB@%exit%@AE@%, %@AB@%_exit%@AE@%, %@AB@%_fpreset%@AE@%,%@AB@% spawn%@AE@% functions%@AB@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SIGNAL.C illustrates setting up signal interrupt routines. Functions
%@AS@%   * illustrated include signal and raise.
%@AS@%   *
%@AS@%   * Since C I/O functions are not safe inside signal routines, the code
%@AS@%   * uses conditionals to use system-level DOS and OS/2 services. Another
%@AS@%   * option is to set global flags and do any I/O operations outside the
%@AS@%   * signal handler. To compile the OS/2 version, define the symbol OS2.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <signal.h>
%@AS@%  #include <process.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #if defined( OS2 )
%@AS@%     #define INCL_NOCOMMON
%@AS@%     #define INCL_NOPM
%@AS@%     #define INCL_VIO
%@AS@%     #define INCL_KBD
%@AS@%     #include <os2.h>
%@AS@%     #include <string.h>
%@AS@%  #else
%@AS@%     #include <dos.h>
%@AS@%     #include <bios.h>
%@AS@%  #endif%@AE@%%@NL@%
%@NL@%
%@AS@%  void ctrlchandler( void );          /* Prototypes */
%@AS@%  void safeout( char *str );
%@AS@%  int  safein( void );
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int ch;
%@AS@%  
%@AS@%     /* Modify CTRL+C behavior. */
%@AS@%     if( signal( SIGINT, ctrlchandler ) == SIG_ERR )
%@AS@%     {
%@AS@%        fprintf( stderr, "Couldn't set SIGINT\n" );
%@AS@%        abort();
%@AS@%     }
%@AS@%  
%@AS@%     /* Input loop illustrates results. */
%@AS@%     do
%@AS@%     {
%@AS@%        ch = getch();
%@AS@%        if( ch == 0 )
%@AS@%        {
%@AS@%           ch = getch();
%@AS@%           if( ch == 46 )      /* Treat ALT+C like CTRL+C */
%@AS@%              raise( SIGINT );
%@AS@%           else
%@AS@%              printf( "Extended code: %X\n", ch );
%@AS@%        }
%@AS@%        else
%@AS@%           printf( "ASCII code: %X\n", ch );
%@AS@%     } while( ch != 27 );        /* ESC code */
%@AS@%  }
%@AS@%  
%@AS@%  /* Handles SIGINT (CTRL+C) interrupt. */
%@AS@%  void ctrlchandler()
%@AS@%  {
%@AS@%     int c;
%@AS@%     char str[] = " ";
%@AS@%  
%@AS@%     /* Disallow CTRL+C during handler. */
%@AS@%     signal( SIGINT, SIG_IGN );
%@AS@%  
%@AS@%     safeout( "User break - abort processing? " );
%@AS@%     c = safein();
%@AS@%     str[0] = c;
%@AS@%     safeout( str );
%@AS@%     safeout( "\r\n" );
%@AS@%     if( (c == 'y') || (c == 'Y') )
%@AS@%        abort();
%@AS@%     else%@AE@%%@NL@%
%@NL@%
%@AS@%  /* The CTRL+C interrupt must be reset to our handler since
%@AS@%         * by default it is reset to the system handler.
%@AS@%         */
%@AS@%        signal( SIGINT, ctrlchandler );
%@AS@%  }
%@AS@%  
%@AS@%  /* Outputs a string using system level calls. */
%@AS@%  void safeout( char *str )
%@AS@%  {
%@AS@%  #if defined( OS2 )
%@AS@%     VioWrtTTY( str, strlen( str ), 0 );
%@AS@%  #else
%@AS@%     union REGS inregs, outregs;
%@AS@%  
%@AS@%     inregs.h.ah = 0x0e;
%@AS@%     while( *str )
%@AS@%     {
%@AS@%        inregs.h.al = *str++;
%@AS@%        int86( 0x10, &inregs, &outregs );
%@AS@%     }
%@AS@%  #endif
%@AS@%  }
%@AS@%  
%@AS@%  /* Inputs a character using system level calls. */
%@AS@%  int safein()
%@AS@%  {
%@AS@%  #if defined( OS2 )
%@AS@%     KBDKEYINFO kki;
%@AS@%  
%@AS@%     KbdCharIn( &kki, IO_WAIT, 0 );
%@AS@%     return kki.chChar;
%@AS@%  #else
%@AS@%     return _bios_keybrd( _KEYBRD_READ ) & 0xff;
%@AS@%  #endif
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  ASCII code: 74
%@AS@%  ASCII code: 68
%@AS@%  ASCII code: 65
%@AS@%  ^C
%@AS@%  User break - abort processing? n
%@AS@%  ASCII code: 62
%@AS@%  ASCII code: 1B%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:sin@%%@NL@%
%@2@%%@CR:C6A03001379 @%%@AB@%sin Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03001380 @%%@CR:C6A03001381 @%%@CR:C6A03001382 @% %@CR:C6A03001383 @%%@CR:C6A03001384 @%%@CR:C6A03001385 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate sines and hyperbolic sines.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double sin( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  double sinh( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double sinl( long double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double sinhl( long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Angle in radians

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%sin%@AE@% and %@AB@%sinh%@AE@% functions find the sine and hyperbolic sine of %@AI@%x%@AE@%,
respectively. The %@AB@%sinl%@AE@% and %@AB@%sinhl%@AE@% functions are the 80-bit counterparts and
use an 80-bit, 10-byte coprocessor form of arguments and return values. See
the reference page on the long double functions for more details on this
data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%sin%@AE@% functions return the sine of %@AI@%x%@AE@%. If %@AI@%x%@AE@% is large, a partial loss of
significance in the result may occur, and %@AB@%sin%@AE@% generates a %@AB@%PLOSS%@AE@% error. If %@AI@%x%@AE@%
is so large that significance is completely lost, the %@AB@%sin%@AE@% function prints a
%@AB@%TLOSS%@AE@% message to %@AB@%stderr%@AE@% and returns 0. In both cases, %@AB@%errno%@AE@% is set to
%@AB@%ERANGE%@AE@%.  %@NL@%
%@NL@%
The %@AB@%sinh%@AE@% function returns the hyperbolic sine of %@AI@%x%@AE@%. If the result is too
large, %@AB@%sinh%@AE@% sets %@AB@%errno%@AE@% to %@AB@%ERANGE%@AE@% and returns%@AB@% ñ%@AE@%HUGE_VAL.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%sin%@AE@%, %@AB@%sinh%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%sinl%@AE@%, %@AB@%sinhl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%acos%@AE@% functions, %@AB@%asin%@AE@% functions, %@AB@%atan%@AE@% functions, %@AB@%cos%@AE@% functions, %@AB@%tan%@AE@% functions
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SINCOS.C: This program displays the sine, hyperbolic sine, cosine,
%@AS@%   * and hyperbolic cosine of pi / 2.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     double pi = 3.1415926535;
%@AS@%     double x, y;
%@AS@%  
%@AS@%     x = pi / 2;
%@AS@%     y = sin( x );
%@AS@%     printf( "sin( %f ) = %f\n", x, y );
%@AS@%     y = sinh( x );
%@AS@%     printf( "sinh( %f ) = %f\n",x, y );
%@AS@%     y = cos( x );
%@AS@%     printf( "cos( %f ) = %f\n", x, y );
%@AS@%     y = cosh( x );
%@AS@%     printf( "cosh( %f ) = %f\n",x, y );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  sin( 1.570796 ) = 1.000000
%@AS@%  sinh( 1.570796 ) = 2.301299
%@AS@%  cos( 1.570796 ) = 0.000000
%@AS@%  cosh( 1.570796 ) = 2.509178 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:sopen@%%@NL@%
%@2@%%@CR:C6A03011386 @%%@AB@%sopen%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03011387 @%%@CR:C6A03011388 @%%@CR:C6A03011389 @% %@CR:C6A03011390 @%%@CR:C6A03011391 @%%@CR:C6A03011392 @% %@CR:C6A03011393 @%%@CR:C6A03011394 @%%@CR:C6A03011395 @% %@CR:C6A03011396 @%%@CR:C6A03011397 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Opens a file for file sharing.  %@NL@%
%@NL@%
%@AB@%#include <fcntl.h>%@AE@%                

%@AB@%#include <sys\types.h>%@AE@%            

%@AB@%#include <sys\stat.h>%@AE@%             

%@AB@%#include <share.h>%@AE@%                

%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  int sopen( char *filename, int oflag, int shflag [[,  int pmode ]] );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          File name

%@AI@%oflag%@AE@%                             Type of operations allowed

%@AI@%shflag%@AE@%                            Type of sharing allowed

%@AI@%pmode%@AE@%                             Permission setting

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%sopen%@AE@% function opens the file specified by %@AI@%filename%@AE@% and prepares the
file for subsequent shared reading or writing, as defined by %@AI@%oflag%@AE@% and
%@AI@%shflag.%@AE@% The integer expression %@AI@%oflag%@AE@% is formed by combining one or more of
the following manifest constants, defined in the file FCNTL.H. When two or
more constants are used to form the argument %@AI@%oflag%@AE@%, the constants are
combined with the OR operator ( | ).  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%O_APPEND%@AE@%                          Repositions the file pointer to the end 
                                  of the file before every write 
                                  operation.

%@AB@%O_BINARY%@AE@%                          Opens file in binary (untranslated) 
                                  mode. (See %@AB@%fopen%@AE@% for a description of 
                                  binary mode.)

%@AB@%O_CREAT%@AE@%                           Creates and opens a new file. This has 
                                  no effect if the file specified by %@AI@%%@AE@%
                                  %@AI@%filename%@AE@% exists.

%@AB@%O_EXCL%@AE@%                            Returns an error value if the file 
                                  specified by %@AI@%filename%@AE@% exists. This 
                                  applies only when used with %@AB@%O_CREAT%@AE@%.

%@AB@%O_RDONLY%@AE@%                          Opens file for reading only. If this 
                                  flag is given, neither the %@AB@%O_RDWR%@AE@% flag 
                                  nor the %@AB@%O_WRONLY%@AE@% flag can be given.

%@AB@%O_RDWR%@AE@%                            Opens file for both reading and writing.
                                  If this flag is given, neither %@AB@%O_RDONLY%@AE@% 
                                  nor %@AB@%O_WRONLY%@AE@% can be given.

%@AB@%O_TEXT%@AE@%                            Opens file in text (translated) mode. 
                                  (See %@AB@%fopen%@AE@% for a description of text 
                                  mode.)

%@AB@%O_TRUNC%@AE@%                           Opens and truncates an existing file to 
                                  0 bytes. The file must have write 
                                  permission; the contents of the file are
                                  destroyed.

%@AB@%O_WRONLY%@AE@%                          Opens file for writing only. If this 
                                  flag is given, neither %@AB@%O_RDONLY%@AE@% nor %@AB@%%@AE@%
                                  %@AB@%O_RDWR%@AE@% can be given.

The argument %@AI@%shflag%@AE@% is a constant expression consisting of one of the
following manifest constants, defined in SHARE.H. If SHARE.COM (or SHARE.EXE
for some versions of DOS) is not installed, DOS ignores the sharing mode.
(See your system documentation for detailed information about sharing
modes.)  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%SH_COMPAT%@AE@%                         Sets compatibility mode (not available 
                                  in OS/2). This is the sharing mode used 
                                  in the %@AB@%open%@AE@% function in DOS.

%@AB@%SH_DENYRW%@AE@%                         Denies read and write access to file.

%@AB@%SH_DENYWR%@AE@%                         Denies write access to file.

%@AB@%SH_DENYRD%@AE@%                         Denies read access to file.

%@AB@%SH_DENYNO%@AE@%                         Permits read and write access. This is 
                                  the sharing mode used in the %@AB@%open%@AE@% 
                                  function in OS/2.

The %@AB@%sopen%@AE@% function should be used only under OS/2 and DOS versions 3.0 and
later. Under earlier versions of DOS, the %@AI@%shflag%@AE@% argument is ignored.  %@NL@%
%@NL@%
The %@AI@%pmode%@AE@% argument is required only when %@AB@%O_CREAT%@AE@% is specified. If the file
does not exist, %@AI@%pmode%@AE@% specifies the file's permission settings, which are
set when the new file is closed for the first time. Otherwise, the %@AI@%pmode%@AE@%
argument is ignored. The %@AI@%pmode%@AE@% argument is an integer expression that
contains one or both of the manifest constants %@AB@%S_IWRITE%@AE@% and %@AB@%S_IREAD%@AE@%, defined
in SYS\STAT.H. When both constants are given, they are combined with the OR
operator ( | ). The meaning of the %@AI@%pmode%@AE@% argument is as follows:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%S_IWRITE%@AE@%                          Writing permitted

%@AB@%S_IREAD%@AE@%                           Reading permitted

%@AB@%S_IREAD | S_IWRITE%@AE@%                Reading and writing permitted

If write permission is not given, the file is read-only. Under DOS and OS/2,
all files are readable; it is not possible to give write-only permission.
Thus, the modes %@AB@%S_IWRITE%@AE@% and %@AB@%S_IREAD | S_IWRITE%@AE@% are equivalent.  %@NL@%
%@NL@%
Note that under DOS versions 3.x with %@AB@%SHARE%@AE@% installed, a problem occurs when
opening a new file with %@AB@%sopen%@AE@% under the following sets of conditions:  %@NL@%
%@NL@%
%@NL@%
  ş   With %@AI@%oflag%@AE@% set to %@AB@%O_CREAT | O_RDONLY %@AE@%or %@AB@%O_CREAT | WRONLY%@AE@%, %@AI@%pmode%@AE@% set to
      %@AB@%S_IREAD%@AE@%, and %@AI@%shflag%@AE@% set to %@AB@%SH_COMPAT%@AE@%.%@NL@%
%@NL@%
  ş   With %@AI@%oflag%@AE@% set to any combination that includes %@AB@%O_CREAT | O_RDWR%@AE@%,
      %@AI@%pmode%@AE@% set to %@AB@%S_IREAD%@AE@%, and %@AI@%shflag%@AE@% set to anything other than %@AB@%SH_COMPAT%@AE@%.%@NL@%
%@NL@%
%@NL@%
In either case, the operating system will prematurely close the file during
system calls made within %@AB@%sopen%@AE@%, or the system will generate a sharing
violation (INT 24H). To avoid the problem, open the file with %@AI@%pmode%@AE@% set to
%@AB@%S_IWRITE%@AE@%. After closing the file, call %@AB@%chmod%@AE@% and change the mode back to
%@AB@%S_IREAD%@AE@%. Another solution is to open the file with %@AI@%pmode%@AE@% set to %@AB@%S_IREAD%@AE@%,
%@AI@%oflag%@AE@% set to%@AB@% %@AE@%O_CREAT | O_RDWR, and %@AI@%shflag%@AE@% set to %@AB@%SH_COMPAT%@AE@%.  %@NL@%
%@NL@%
The %@AB@%sopen%@AE@% function applies the current file-permission mask to %@AI@%pmode%@AE@% before
setting the permissions (see %@AB@%umask%@AE@%).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%sopen%@AE@% function returns a file handle for the opened file. A return value
of -1 indicates an error, and %@AB@%errno%@AE@% is set to one of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Given path name is a directory; or the 
                                  file is read-only but an open for 
                                  writing was attempted; or a sharing 
                                  violation occurred (the file's sharing 
                                  mode does not allow the specified 
                                  operations; OS/2 and DOS versions 3.0 
                                  and later only).

%@AB@%EEXIST%@AE@%                            The %@AB@%O_CREAT%@AE@% and %@AB@%O_EXCL %@AE@%flags are 
                                  specified, but the named file already 
                                  exists.

%@AB@%EINVAL%@AE@%                            An invalid %@AI@%oflag%@AE@% or %@AI@%shflag%@AE@% argument was 
                                  given.

%@AB@%EMFILE%@AE@%                            No more file handles available (too many
                                  open files).

%@AB@%ENOENT%@AE@%                            File or path name not found.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%close%@AE@%, %@AB@%creat%@AE@%, %@AB@%fopen%@AE@%, %@AB@%_fsopen%@AE@%, %@AB@%open%@AE@%, %@AB@%umask%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%locking%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:spawn@%%@NL@%
%@2@%%@CR:C6A03021398 @%%@AB@%spawn Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03021399 @% %@CR:C6A03021400 @% %@CR:C6A03021401 @% %@CR:C6A03021402 @% %@CR:C6A03021403 @%%@CR:C6A03021404 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Create and execute a new child process.  %@NL@%
%@NL@%
%@AB@%#include <stdio.h>%@AE@%                

%@AB@%#include%@AE@% %@AB@%<process.h>%@AE@%              

%@AS@%  int spawnl( int mode, char *cmdname, char *arg0,  char *arg1, ... char
%@AS@%  *argn, NULL );%@AE@%%@NL@%
%@NL@%
%@AS@%  int spawnle( int mode, char *cmdname, char *arg0, char *arg1, ... char
%@AS@%  *argn, NULL, char **envp );%@AE@%%@NL@%
%@NL@%
%@AS@%  int spawnlp( int mode, char *cmdname, char *arg0, char *arg1, ... char
%@AS@%  *argn, NULL );%@AE@%%@NL@%
%@NL@%
%@AS@%  int spawnlpe( int mode, char *cmdname, char *arg0, char *arg1, ... char
%@AS@%  *argn, NULL, char **envp );%@AE@%%@NL@%
%@NL@%
%@AS@%  int spawnv( int mode, char *cmdname, char **argv ); %@AE@%%@NL@%
%@NL@%
%@AS@%  int spawnve( int mode, char *cmdname, char **argv, char  **envp );%@AE@%%@NL@%
%@NL@%
%@AS@%  int spawnvp( int mode, char *cmdname, char **argv ); %@AE@%%@NL@%
%@NL@%
%@AS@%  int spawnvpe( int mode, char *cmdname, char **argv, char **envp );%@AE@%%@NL@%
%@NL@%
%@AI@%mode%@AE@%%@AB@%%@AE@%                              Execution mode for parent process

%@AI@%cmdname%@AE@%%@AB@%%@AE@%                           Path name of file to be executed

%@AI@%arg0%@AE@%, ... %@AI@%argn%@AE@%                    List of pointers to arguments

%@AI@%argv%@AE@%                              Array of pointers to arguments

%@AI@%envp%@AE@%                              Array of pointers to environment 
                                  settings

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%spawn%@AE@% family of functions creates and executes a new child process.
Enough memory must be available for loading and executing the child process.
The %@AI@%mode%@AE@% argument determines the action taken by the parent process before
and during %@AB@%spawn%@AE@%. The following values for %@AI@%mode%@AE@% are defined in PROCESS.H:%@CR:C6A03021405 @%%@CR:C6A03021406 @%  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%P_DETACH%@AE@%                          Continues to execute the parent process;
                                  child process is run in the background 
                                  with no access to the console or 
                                  keyboard. Calls to %@AB@%wait%@AE@% and %@AB@%cwait%@AE@% 
                                  against the child process will fail. 
                                  This is an asynchronous detached %@AB@%spawn%@AE@% 
                                  and is valid only in OS/2 protected 
                                  mode.

%@AB@%P_NOWAIT%@AE@%                          Continues to execute parent process 
                                  concurrently with child process 
                                  (asynchronous %@AB@%spawn%@AE@%, valid only in 
                                  protected mode).

%@AB@%P_NOWAITO%@AE@%                         Continues to execute parent process and 
                                  ignores %@AB@%wait%@AE@% and %@AB@%cwait%@AE@% calls against 
                                  child process (asynchronous %@AB@%spawn%@AE@%, valid
                                  only in protected mode).

%@AB@%P_OVERLAY%@AE@%                         Overlays parent process with child, 
                                  destroying the parent (same effect as %@AB@%%@AE@%
                                  %@AB@%exec%@AE@% calls).

%@AB@%P_WAIT%@AE@%                            Suspends parent process until execution 
                                  of child process is complete 
                                  (synchronous %@AB@%spawn%@AE@%).

The %@AI@%cmdname%@AE@% argument specifies the file which will be executed as the child
process, and can specify a full path (from the root), a partial path (from
the current working directory), or just a file name. If %@AI@%cmdname%@AE@% does not
have a file-name extension or does not end with a period (.), the%@AB@% spawn%@AE@%
function first tries the .COM extension, then the .EXE extension, and
finally the .BAT extension (or, in OS/2 protected mode, the .CMD extension).
This ability to spawn batch files is a new feature in Microsoft C version
6.0.  %@NL@%
%@NL@%
If %@AI@%cmdname%@AE@% has an extension, only that extension is used. If %@AI@%cmdname%@AE@% ends
with a period, the %@AB@%spawn%@AE@% calls search for %@AI@%cmdname%@AE@% with no extension. The
%@AB@%spawnlp%@AE@%, %@AB@%spawnlpe%@AE@%, %@AB@%spawnvp%@AE@%, and %@AB@%spawnvpe%@AE@% routines search for %@AI@%cmdname%@AE@% (using
the same procedures) in the directories specified by the PATH environment
variable.  %@NL@%
%@NL@%
If %@AI@%cmdname%@AE@% contains a drive specifier or any slashes (i.e., if it is a
relative path name), the %@AB@%spawn%@AE@% call searches only for the specified file and
no path searching is done.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Arguments for the Child Process%@AE@%%@EH@%%@NL@%
%@NL@%
Arguments are passed to the child process by giving one or more pointers to
character strings as arguments in the %@AB@%spawn%@AE@% call. These character strings
form the argument list for the child process. The combined length of the
strings forming the argument list for the child process must not exceed 128
bytes in real mode. The terminating null character (%@AB@%'\0'%@AE@%) for each string is
not included in the count, but space characters (automatically inserted to
separate arguments) are included.  %@NL@%
%@NL@%
The argument pointers may be passed as separate arguments (%@AB@%spawnl%@AE@%, %@AB@%spawnle%@AE@%,
%@AB@%spawnlp%@AE@%, and %@AB@%spawnlpe%@AE@%) or as an array of pointers (%@AB@%spawnv%@AE@%, %@AB@%spawnve%@AE@%, %@AB@%spawnvp%@AE@%,
and %@AB@%spawnvpe%@AE@%). At least one argument, %@AI@%arg0%@AE@% or %@AI@%argv%@AE@%[0], must be passed to the
child process. By convention, this argument is the name of the program as it
might be typed on the command line by the user. (A different value will not
produce an error.) In real mode, the %@AI@%argv%@AE@%[0] value is supplied by the
operating system and is the fully qualified path name of the executing
program. In protected mode, it is usually the program name as it would be
typed on the command line.  %@NL@%
%@NL@%
The %@AB@%spawnl%@AE@%, %@AB@%spawnle%@AE@%, %@AB@%spawnlp%@AE@%, and %@AB@%spawnlpe%@AE@% calls are typically used in cases
where the number of arguments is known in advance. The %@AI@%arg0%@AE@% argument is
usually a pointer to %@AI@%cmdname%@AE@%. The arguments %@AI@%arg1%@AE@% through %@AI@%argn%@AE@% are pointers
to the character strings forming the new argument list. Following %@AI@%argn%@AE@%,
there must be a %@AB@%NULL%@AE@% pointer to mark the end of the argument list.  %@NL@%
%@NL@%
The %@AB@%spawnv%@AE@%, %@AB@%spawnve%@AE@%, %@AB@%spawnvp%@AE@%, and %@AB@%spawnvpe%@AE@% calls are useful when the number
of arguments to the child process is variable. Pointers to the arguments are
passed as an array, %@AI@%argv.%@AE@% The argument %@AI@%argv%@AE@%[0] is usually a pointer to a
path name in real mode or to the program name in protected mode, and %@AI@%argv%@AE@%[1]
through %@AI@%argv%@AE@%%@AB@%[%@AE@%%@AI@%n%@AE@%%@AB@%]%@AE@% are pointers to the character strings forming the new
argument list. The argument %@AI@%argv%@AE@%%@AB@%[%@AE@%%@AI@%n%@AE@%%@AB@%+1]%@AE@% must be a %@AB@%NULL%@AE@% pointer to mark the end
of the argument list.  %@NL@%
%@NL@%
%@NL@%
%@4@%%@AB@%Environment of the Child Process%@AE@%%@EH@%%@NL@%
%@NL@%
Files that are open when a %@AB@%spawn%@AE@% call is made remain open in the child
process. In the %@AB@%spawnl%@AE@%, %@AB@%spawnlp%@AE@%, %@AB@%spawnv%@AE@%, and %@AB@%spawnvp%@AE@% calls, the child
process inherits the environment of the parent. The %@AB@%spawnle%@AE@%, %@AB@%spawnlpe%@AE@%,
%@AB@%spawnve%@AE@%, and %@AB@%spawnvpe%@AE@% calls allow the user to alter the environment for the
child process by passing a list of environment settings through the %@AI@%envp%@AE@%
argument. The argument %@AI@%envp%@AE@% is an array of character pointers, each element
of which (except for the final element) points to a null-terminated string
defining an environment variable. Such a string usually has the form  %@NL@%
%@NL@%
%@AB@%%@AE@%NAME=%@AI@%value%@AE@%  %@NL@%
%@NL@%
where %@AB@%NAME%@AE@% is the name of an environment variable and %@AI@%value%@AE@% is the string
value to which that variable is set. (Note that %@AI@%value%@AE@% is not enclosed in
double quotation marks.) The final element of the %@AI@%envp%@AE@% array should be %@AB@%NULL%@AE@%.
When %@AI@%envp%@AE@% itself is %@AB@%NULL%@AE@%, the child process inherits the environment
settings of the parent process.  %@NL@%
%@NL@%
The %@AB@%spawn%@AE@% functions can pass the child process all information about open
files, including the translation mode, through the %@AB@%C_FILE_INFO%@AE@% entry in the
environment that is passed in real mode (%@AB@%_C_FILE_INFO%@AE@% in protected mode).  %@NL@%
%@NL@%
The C start-up code normally processes this entry and then deletes it from
the environment. However, if a %@AB@%spawn%@AE@% function spawns a non-C process (such
as CMD.EXE), this entry remains in the environment. Printing the environment
shows graphics characters in the definition string for this entry, since the
environment information is passed in binary form in real mode. It should not
have any other effect on normal operations. In protected mode, the
environment information is passed in text form and therefore contains no
graphics characters.  %@NL@%
%@NL@%
You must explicitly flush (using %@AB@%fflush%@AE@% or %@AB@%flushall%@AE@%) or close any stream
prior to the %@AB@%spawn%@AE@% function call.  %@NL@%
%@NL@%
Starting with Microsoft C version 6.0, you can control whether or not the
open file information of a process will be passed to its child processes.
The external variable %@AB@%_fileinfo%@AE@% (declared in STDLIB.H) controls the passing
of %@AB@%C_FILE_INFO%@AE@% information. If %@AB@%_fileinfo %@AE@%is 0, the %@AB@%C_FILE_INFO%@AE@% information
is not passed to the child processes. If %@AB@%_fileinfo%@AE@% is not 0, %@AB@%C_FILE_INFO %@AE@%is
passed to child processes.  %@NL@%
%@NL@%
By default, %@AB@%_fileinfo%@AE@% is 0 and thus the%@AB@% C_FILE_INFO%@AE@% information is not
passed to child processes. There are two ways to modify the default value of
%@AB@%_fileinfo%@AE@%:  %@NL@%
%@NL@%
%@NL@%
  ş   Link the supplied object file FILEINFO.OBJ into your program. Use the
      /NOE option to avoid multiple symbol definitions.%@NL@%
%@NL@%
  ş   Set the %@AB@%_fileinfo%@AE@% variable to a nonzero value directly within your C
      program.%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return value from a synchronous %@AB@%spawn%@AE@% (%@AB@%P_WAIT%@AE@% specified for %@AI@%mode%@AE@%) is the
exit status of the child process.  %@NL@%
%@NL@%
The return value from an asynchronous %@AB@%spawn%@AE@% (%@AB@%P_NOWAIT%@AE@% or %@AB@%P_NOWAITO%@AE@% specified
for %@AI@%mode%@AE@%) is the process ID. To obtain the exit code for a process spawned
with %@AB@%P_NOWAIT%@AE@%, you must call the %@AB@%wait%@AE@% or %@AB@%cwait%@AE@% function and specify the
process ID. The exit code cannot be obtained for a process spawned with
%@AB@%P_NOWAITO%@AE@%.  %@NL@%
%@NL@%
The exit status is 0 if the process terminated normally. The exit status can
be set to a nonzero value if the child process specifically calls the %@AB@%exit%@AE@%
routine with a nonzero argument. If the child process did not explicitly set
a positive exit status, a positive exit status indicates an abnormal exit
with an %@AB@%abort%@AE@% or an interrupt. A return value of -1 indicates an error (the
child process is not started). In this case, %@AB@%errno%@AE@% is set to one of the
following values:  %@NL@%
%@NL@%
%@AB@%Value %@AE@%                            %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%E2BIG%@AE@%                             In DOS, the argument list exceeds 128 
                                  bytes, or the space
                                  required for the environment information
                                  exceeds 32K. In OS/2, the argument list 
                                  and the space required for environment 
                                  information combined exceed 32K.

%@AB@%EINVAL%@AE@%                            The %@AI@%mode%@AE@% argument is invalid.

%@AB@%ENOENT%@AE@%                            The file or path name is not found.

%@AB@%ENOEXEC%@AE@%                           The specified file is not executable or 
                                  has an invalid
                                  executable-file format.

%@AB@%ENOMEM%@AE@%                            Not enough memory is available to 
                                  execute the child process.

Note that signal settings are not preserved in child processes created by
calls to %@AB@%spawn%@AE@% routines. The signal settings are reset to the default in the
child process.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
The %@AB@%spawn %@AE@%functions, with %@AB@%P_OVERLAY %@AE@%%@AI@%mode%@AE@%,%@AI@% %@AE@%will not work in OS/2
DOScompatibility mode in programs which are bound with FAPI for dual-mode
execution.  %@NL@%
%@NL@%
Programs linked as DOS mode .EXE files will work, and protected-mode
programs will work. The restriction applies only to bound programs in real
mode.  %@NL@%
%@NL@%
In order to ensure proper overlay initialization and termination, do not use
the %@AB@%setjmp%@AE@% or %@AB@%longjmp%@AE@%%@AI@% %@AE@%functions to enter or leave an overlay routine.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%abort%@AE@%, %@AB@%atexit%@AE@%, %@AB@%exec%@AE@% functions, %@AB@%exit%@AE@%, %@AB@%_exit%@AE@%, %@AB@%onexit%@AE@%, %@AB@%system%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SPAWN.C: This program accepts a number in the range 18 from the
%@AS@%   * command line. Based on the number it receives, it executes one of the
%@AS@%   * eight different procedures that spawn the process named child. For
%@AS@%   * some of these procedures, the CHILD.EXE file must be in the
%@AS@%   * same directory; for others, it only has to be in the same path.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <process.h>
%@AS@%  
%@AS@%  char *my_env[] =
%@AS@%  {
%@AS@%     "THIS=environment will be",
%@AS@%     "PASSED=to child.exe by the",
%@AS@%     "SPAWNLE=and",
%@AS@%     "SPAWNLPE=and",
%@AS@%     "SPAWNVE=and",
%@AS@%     "SPAWNVPE=functions",
%@AS@%     NULL
%@AS@%  };
%@AS@%  
%@AS@%  void main( int argc, char *argv[] )
%@AS@%  {
%@AS@%     char *args[4];
%@AS@%     int  result;
%@AS@%  
%@AS@%     /* Set up parameters to be sent: */
%@AS@%     args[0] = "child";
%@AS@%     args[1] = "spawn??";
%@AS@%     args[2] = "two";
%@AS@%     args[3] = NULL;
%@AS@%     switch (argv[1][0])   /* Based on first letter of argument */
%@AS@%     {
%@AS@%        case '1':
%@AS@%           spawnl( P_WAIT, argv[2], argv[2], "spawnl", "two", NULL );
%@AS@%           break;
%@AS@%        case '2':
%@AS@%           spawnle( P_WAIT, argv[2], argv[2], "spawnle", "two",
%@AS@%                    NULL, my_env );
%@AS@%           break;
%@AS@%        case '3':
%@AS@%           spawnlp( P_WAIT, argv[2], argv[2], "spawnlp", "two", NULL );
%@AS@%           break;
%@AS@%        case '4':
%@AS@%           spawnlpe( P_WAIT, argv[2], argv[2], "spawnlpe", "two",
%@AS@%                     NULL, my_env );
%@AS@%           break;
%@AS@%        case '5':
%@AS@%           spawnv( P_OVERLAY, argv[2], args );
%@AS@%           break;
%@AS@%        case '6':
%@AS@%           spawnve( P_OVERLAY, argv[2], args, my_env );
%@AS@%           break;
%@AS@%        case '7':
%@AS@%           spawnvp( P_OVERLAY, argv[2], args );
%@AS@%           break;
%@AS@%        case '8':
%@AS@%           spawnvpe( P_OVERLAY, argv[2], args, my_env );
%@AS@%           break;
%@AS@%        default:
%@AS@%           printf( "SYNTAX: SPAWN <1-8> <childprogram>\n" );
%@AS@%           exit( 1 );
%@AS@%     }
%@AS@%     printf( "\n\nReturned from SPAWN!\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_splitpath@%%@NL@%
%@2@%%@CR:C6A03031407 @%%@AB@%_splitpath%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03031408 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Breaks a path name into components.  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _splitpath( char *path, char *drive, char *dir, char *fname, char
%@AS@%  *ext );%@AE@%%@NL@%
%@NL@%
%@AI@%path%@AE@%                              Full path name

%@AI@%drive%@AE@%                             Drive letter

%@AI@%dir%@AE@%                               Directory path

%@AI@%fname%@AE@%                             File name

%@AI@%ext%@AE@%                               File extension

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_splitpath%@AE@% routine breaks a full path name into its four components. The
%@AI@%path%@AE@% argument should point to a buffer containing the complete path name.
The maximum size necessary for each buffer is specified by the manifest
constants %@AB@%_MAX_DRIVE%@AE@%, %@AB@%_MAX_DIR%@AE@%, %@AB@%_MAX_FNAME%@AE@%, and %@AB@%_MAX_EXT,%@AE@% defined in
STDLIB.H. The other arguments point to the buffers used to store the
path-name elements:  %@NL@%
%@NL@%
%@AB@%Buffer%@AE@%                            %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AI@%drive%@AE@%                             Contains the drive letter followed by a 
                                  colon (%@AB@%:%@AE@%) if a drive is specified in %@AI@%%@AE@%
                                  %@AI@%path%@AE@%.

%@AI@%dir%@AE@%                               Contains the path of subdirectories, if 
                                  any, including the trailing slash. 
                                  Forward slashes ( %@AB@%/ %@AE@%), backslashes ( \ 
                                  ), or both may be present in %@AI@%path%@AE@%.

%@AI@%fname%@AE@%                             Contains the base file name without any 
                                  extensions.

%@AI@%ext%@AE@%                               Contains the file-name extension, if 
                                  any, including the leading period (%@AB@%.%@AE@%).

The return parameters will contain empty strings for any path-name
components not found in %@AI@%path%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_fullpath%@AE@%, %@AB@% _makepath%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* MAKEPATH.C */
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char path_buffer[_MAX_PATH];
%@AS@%     char drive[_MAX_DRIVE];
%@AS@%     char dir[_MAX_DIR];
%@AS@%     char fname[_MAX_FNAME];
%@AS@%     char ext[_MAX_EXT];
%@AS@%  
%@AS@%     _makepath( path_buffer, "c", "\\c60\\clibref\\", "makepath", "c" );
%@AS@%     printf( "Path created with _makepath: %s\n\n", path_buffer );
%@AS@%     _splitpath( path_buffer, drive, dir, fname, ext );
%@AS@%     printf( "Path extracted with _splitpath:\n" );
%@AS@%     printf( "  Drive: %s\n", drive );
%@AS@%     printf( "  Dir: %s\n", dir );
%@AS@%     printf( "  Filename: %s\n", fname );
%@AS@%     printf( "  Ext: %s\n", ext );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Path created with _makepath: c:\c60\clibref\makepath.c
%@AS@%  
%@AS@%  Path extracted with _splitpath:
%@AS@%    Drive: c:
%@AS@%    Dir: \c60\clibref\
%@AS@%    Filename: makepath
%@AS@%    Ext: .c %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:sprintf@%%@NL@%
%@2@%%@CR:C6A03041409 @%%@AB@%sprintf%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03041410 @%%@CR:C6A03041411 @% %@CR:C6A03041412 @%%@CR:C6A03041413 @% %@CR:C6A03041414 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Writes formatted data to a string.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int sprintf( char *buffer, const char *format [[, argument]]...);%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%%@AE@%%@EH@%%@NL@%
%@NL@%
%@AI@%buffer%@AE@%                            Storage location for output

%@AI@%format%@AE@%                            Format-control string

%@AI@%argument%@AE@%                          Optional arguments

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%sprintf%@AE@% function formats and stores a series of characters and values in
%@AI@%buffer%@AE@%. Each %@AI@%argument%@AE@% (if any) is converted and output according to the
corresponding format specification in the %@AI@%format%@AE@%. The format consists of
ordinary characters and has the same form and function as the %@AI@%format%@AE@%
argument for the %@AB@%printf%@AE@% function. (See %@AB@%printf%@AE@% for a description of the
format and arguments.) A null character is appended to the end of the
characters written, but is not counted in the return value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%sprintf%@AE@% function returns the number of characters stored in %@AI@%buffer%@AE@%, not
counting the terminating null character.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fprintf%@AE@%, %@AB@%printf%@AE@%, %@AB@%sscanf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SPRINTF.C: This program uses sprintf to format various data and
%@AS@%   * place them in the string named buffer.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char  buffer[200], s[] = "computer", c = 'l';
%@AS@%     int   i = 35, j;
%@AS@%     float fp = 1.7320534;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Format and print various data: */
%@AS@%     j  = sprintf( buffer,     "\tString:    %s\n", s );
%@AS@%     j += sprintf( buffer + j, "\tCharacter: %c\n", c );
%@AS@%     j += sprintf( buffer + j, "\tInteger:   %d\n", i );
%@AS@%     j += sprintf( buffer + j, "\tReal:      %f\n", fp );
%@AS@%  
%@AS@%     printf( "Output:\n%s\ncharacter count = %d\n", buffer, j );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Output:
%@AS@%          String:    computer
%@AS@%          Character: l
%@AS@%          Integer:   35
%@AS@%          Real:      1.732053
%@AS@%  
%@AS@%  character count = 71 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:sqrt@%%@QR:sqrtl@%%@NL@%
%@2@%%@CR:C6A03051415 @%%@AB@%sqrt, sqrtl%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03051416 @%%@CR:C6A03051417 @% %@CR:C6A03051418 @%%@CR:C6A03051419 @%%@CR:C6A03051420 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculates the square root.  %@NL@%
%@NL@%
%@AS@%  #include <math.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double sqrt( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double sqrtl( long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Nonnegative floating-point value

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%sqrt%@AE@% functions calculate the square root of %@AI@%x%@AE@%. The %@AB@%sqrtl%@AE@% function is the
80-bit counterpart and uses an 80-bit, 10-byte coprocessor form of arguments
and return values.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%sqrt%@AE@% functions return the square-root result. If %@AI@%x%@AE@% is negative, the
function prints a %@AB@%DOMAIN%@AE@% error message to %@AB@%stderr%@AE@%, sets %@AB@%errno%@AE@% to %@AB@%EDOM%@AE@%, and
returns 0.  %@NL@%
%@NL@%
Error handling can be modified by using the %@AB@%matherr%@AE@% or %@AB@%_matherrl%@AE@% routine.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%exp%@AE@%, %@AB@%log%@AE@%, %@AB@%matherr%@AE@%, %@AB@%pow%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SQRT.C: This program calculates a square root. */
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     double question = 45.35, answer;
%@AS@%  
%@AS@%     answer = sqrt( question );
%@AS@%     if( errno == EDOM )
%@AS@%        printf( "Domain error\n" );
%@AS@%     else
%@AS@%        printf( "The square root of %.2f is %.2f\n", question, answer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The square root of 45.35 is 6.73 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:srand@%%@NL@%
%@2@%%@CR:C6A03061421 @%%@AB@%srand%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03061422 @%%@CR:C6A03061423 @%%@CR:C6A03061424 @% %@CR:C6A03061425 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets a random starting point.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AS@%  void srand( unsigned int seed );%@AE@%%@NL@%
%@NL@%
%@AI@%seed%@AE@%                              Seed for random-number generation

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%srand%@AE@% function sets the starting point for generating a series of
pseudorandom integers. To reinitialize the generator, use 1 as the %@AI@%seed%@AE@%
argument. Any other value for %@AI@%seed%@AE@% sets the generator to a random starting
point.  %@NL@%
%@NL@%
The %@AB@%rand%@AE@% function is used to retrieve the pseudorandom numbers that are
generated. Calling %@AB@%rand%@AE@% before any call to %@AB@%srand%@AE@% will generate the same
sequence as calling %@AB@%srand%@AE@% with %@AI@%seed%@AE@% passed as 1.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%rand%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* RAND.C: This program seeds the random number generator with the
%@AS@%   * time, then displays 20 random integers.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <time.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int i;
%@AS@%  
%@AS@%     /* Seed the random number generator with current time so that
%@AS@%      * the numbers will be different every time we run.
%@AS@%      */
%@AS@%     srand( (unsigned)time( NULL ) );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Display 10 numbers. */
%@AS@%     for( i = 0; i < 10; i++ )
%@AS@%         printf( "  %6d\n", rand() );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%     19471
%@AS@%     16395
%@AS@%      8268
%@AS@%     15582
%@AS@%      6489
%@AS@%     28356
%@AS@%     27042
%@AS@%      5276
%@AS@%     23070
%@AS@%     10930 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:sscanf@%%@NL@%
%@2@%%@CR:C6A03071426 @%%@AB@%sscanf%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03071427 @%%@CR:C6A03071428 @% %@CR:C6A03071429 @%%@CR:C6A03071430 @% %@CR:C6A03071431 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Reads formatted data from a string.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int sscanf( const char *buffer, const char *format [[, argument ]] ... );%@AE@%%@NL@%
%@NL@%
%@AI@%buffer%@AE@%                            Stored data

%@AI@%format%@AE@%                            Format-control string

%@AI@%argument%@AE@%                          Optional arguments

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%sscanf%@AE@% function reads data from %@AI@%buffer%@AE@% into the locations given by each
%@AI@%argument%@AE@%. Every %@AI@%argument%@AE@% must be a pointer to a variable with a type that
corresponds to a type specifier in %@AI@%format%@AE@%. The format controls the
interpretation of the input fields and has the same form and function as the
%@AI@%format%@AE@% argument for the %@AB@%scanf%@AE@% function; see %@AB@%scanf%@AE@% for a complete description
of %@AI@%format%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%sscanf%@AE@% function returns the number of fields that were successfully
converted and assigned. The return value does not include fields that were
read but not assigned.  %@NL@%
%@NL@%
The return value is %@AB@%EOF%@AE@% for an attempt to read at end-of-string. A return
value of 0 means that no fields were assigned.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fscanf%@AE@%, %@AB@%scanf%@AE@%, %@AB@%sprintf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SSCANF.C: This program uses sscanf to read data items from
%@AS@%   * a string named tokenstring, then displays them.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char  tokenstring[] = "15 12 14...";
%@AS@%     char  s[81];
%@AS@%     char  c;
%@AS@%     int   i;
%@AS@%     float fp;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Input various data from tokenstring: */
%@AS@%     sscanf( tokenstring, "%s", s );
%@AS@%     sscanf( tokenstring, "%c", &c );
%@AS@%     sscanf( tokenstring, "%d", &i );
%@AS@%     sscanf( tokenstring, "%f", &fp );
%@AS@%  
%@AS@%     /* Output the data read */
%@AS@%     printf( "String    = %s\n", s );
%@AS@%     printf( "Character = %c\n", c );
%@AS@%     printf( "Integer:  = %d\n", i );
%@AS@%     printf( "Real:     = %f\n", fp );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  String    = 15
%@AS@%  Character = 1
%@AS@%  Integer:  = 15
%@AS@%  Real:     = 15.000000%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:stackavail@%%@NL@%
%@2@%%@CR:C6A03081432 @%%@AB@%stackavail%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03081433 @%%@CR:C6A03081434 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the size of the stack available.  %@NL@%
%@NL@%
%@AB@%#include <malloc.h>%@AE@%               Required only for function declarations

%@AS@%  size_t stackavail( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%stackavail%@AE@% function returns the approximate size (in bytes) of the stack
space available for dynamic memory allocation with %@AB@%alloca%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%stackavail%@AE@% function returns the size in bytes as an unsigned integer
value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ALLOCA.C: This program checks the stack space available before
%@AS@%   * and after using the alloca function to allocate space on the stack.
%@AS@%   */
%@AS@%  
%@AS@%  #include <malloc.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *buffer;
%@AS@%  
%@AS@%     printf( "Bytes available on stack: %u\n", stackavail() );
%@AS@%  
%@AS@%     /* Allocate memory for string. */
%@AS@%     buffer = alloca( 120 * sizeof( char ) );
%@AS@%     printf( "Enter a string: " );
%@AS@%     gets( buffer );
%@AS@%     printf( "You entered: %s\n", buffer );
%@AS@%  
%@AS@%     printf( "Bytes available on stack: %u\n", stackavail() );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Bytes available on stack: 2028
%@AS@%  Enter a string: How much stack space will this string take?
%@AS@%  You entered: How much stack space will this string take?
%@AS@%  Bytes available on stack: 1902%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:stat@%%@NL@%
%@2@%%@CR:C6A03091435 @%%@AB@%stat%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03091436 @%%@CR:C6A03091437 @% %@CR:C6A03091438 @%%@CR:C6A03091439 @%%@CR:C6A03091440 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets status information on a file.  %@NL@%
%@NL@%
%@AS@%  #include <sys\stat.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <sys\types.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int stat( char *pathname, struct stat *buffer );%@AE@%%@NL@%
%@NL@%
%@AI@%pathname%@AE@%                          Path name of existing file

%@AI@%buffer%@AE@%                            Pointer to structure that receives 
                                  results

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%stat%@AE@% function obtains information about the file or directory specified
by %@AI@%pathname%@AE@% and stores it in the structure pointed to by %@AI@%buffer%@AE@%. The %@AB@%stat%@AE@%
structure, defined in the file SYS\STAT.H, includes the following fields:  %@NL@%
%@NL@%
%@AB@%Field%@AE@%                             %@AB@%Value%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%st_atime%@AE@%                          Time of last modification of file (same 
                                  as %@AB@%st_mtime%@AE@% and %@AB@%st_ctime%@AE@%).

%@AB@%st_ctime%@AE@%                          Time of last modification of file (same 
                                  as %@AB@%st_atime%@AE@% and %@AB@%st_mtime%@AE@%).

%@AB@%st_dev%@AE@%                            Drive number of the disk containing the 
                                  file (same as %@AB@%st_rdev%@AE@%). Real mode only. 

%@AB@%st_mode%@AE@%                           Bit mask for file-mode information. The %@AB@%%@AE@%
                                  %@AB@%S_IFDIR%@AE@% bit is set if %@AI@%pathname%@AE@% specifies
                                  a directory; the %@AB@%S_IFREG%@AE@% bit is set if %@AI@%%@AE@%
                                  %@AI@%pathname%@AE@% specifies an ordinary file. 
                                  User read/write bits are set according 
                                  to the file's permission mode; user 
                                  execute bits are set according to the 
                                  file-name extension.

%@AB@%st_mtime%@AE@%                          Time of last modification of file (same 
                                  as %@AB@%st_atime%@AE@% and %@AB@%st_ctime%@AE@%).

%@AB@%st_nlink%@AE@%                          Always 1.

%@AB@%st_rdev%@AE@%                           Drive number of the disk containing the 
                                  file (same as %@AB@%st_dev%@AE@%). Real mode only. 

%@AB@%st_size%@AE@%                           Size of the file in bytes.

Note that if %@AI@%pathname%@AE@% refers to a device, the size and time fields in the
%@AB@%stat%@AE@% structure are not meaningful.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%stat%@AE@% function returns the value 0 if the file-status information is
obtained. A return value of -1 indicates an error; also, %@AB@%errno%@AE@% is set to
%@AB@%ENOENT%@AE@%, indicating that the file name or path name could not be found.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%access%@AE@%, %@AB@%fstat%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STAT.C: This program uses the stat function to report information
%@AS@%   * about the file named STAT.C.
%@AS@%   */
%@AS@%  
%@AS@%  #include <time.h>
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     struct stat buf;
%@AS@%     int  fh, result;
%@AS@%     char buffer[] = "A line to output";
%@AS@%  
%@AS@%     /* Get data associated with "stat.c": */
%@AS@%     result = stat( "stat.c", &buf );
%@AS@%  
%@AS@%     /* Check if statistics are valid: */
%@AS@%     if( result != 0 )
%@AS@%        perror( "Problem getting information" );
%@AS@%     else
%@AS@%     {
%@AS@%        /* Output some of the statistics: */
%@AS@%        printf( "File size     : %ld\n", buf.st_size );
%@AS@%        printf( "Drive         : %c:\n", buf.st_dev + 'A' );
%@AS@%        printf( "Time modified : %s", ctime( &buf.st_atime ) );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  File size     : 761
%@AS@%  Drive         : C:
%@AS@%  Time modified : Wed Jun 14 12:20:08 1989%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_status87@%%@NL@%
%@2@%%@CR:C6A03101441 @%%@AB@%_status87%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03101442 @% %@CR:C6A03101443 @%%@CR:C6A03101444 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the floating-point status word.  %@NL@%
%@NL@%
%@AS@%  #include <float.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned int _status87( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_status87%@AE@% function gets the floating-point status word. The status word
is a combination of the 8087/80287/80387 status word and other conditions
detected by the 8087/80287/80387 exception handler, such as floating-point
stack overflow and underflow.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The bits in the value returned indicate the floating-point status. See the
FLOAT.H include file for a complete definition of the bits returned by
%@AB@%_status87%@AE@%.  %@NL@%
%@NL@%
Note that many of the math library functions modify the 8087/80287 status
word, with unpredictable results. Return values from %@AB@%_clear87%@AE@% and %@AB@%_status87%@AE@%
become more reliable as fewer floating-point operations are performed
between known states of the floating-point status word.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_clear87%@AE@%,  %@AB@%_control87%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STATUS87.C: This program creates various floating-point errors and
%@AS@%   * then uses _status87 to display messages indicating these problems.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <float.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     double a = 1e-40, b;
%@AS@%     float  x, y;
%@AS@%  
%@AS@%     printf( "Status = %.4x - clear\n",_status87() );
%@AS@%  
%@AS@%     /* Assignment into y is inexact & underflows: */
%@AS@%     y = a;
%@AS@%     printf( "Status = %.4x - inexact, underflow\n", _status87() );
%@AS@%  
%@AS@%     /* y is denormal: */
%@AS@%     b = y;
%@AS@%     printf( "Status = %.4x - inexact underflow, denormal\n", _status87() );
%@AS@%  
%@AS@%     /* Clear user 8087: */
%@AS@%     _clear87();
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Status = 0000 - clear
%@AS@%  Status = 0030 - inexact, underflow
%@AS@%  Status = 0032 - inexact underflow, denormal%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strcat@%%@QR:_fstrcat@%%@NL@%
%@2@%%@CR:C6A03111445 @%%@AB@%strcat, _fstrcat%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03111446 @%%@CR:C6A03111447 @%%@CR:C6A03111448 @% %@CR:C6A03111449 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Append a string.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strcat( char *string1, const char *string2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrcat( char _far *string1, const char _far *string2 );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           Destination string

%@AI@%string2%@AE@%                           Source string

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strcat%@AE@% and %@AB@%_fstrcat%@AE@% functions append %@AI@%string2%@AE@% to %@AI@%string1%@AE@%, terminate the
resulting string with a null character, and return a pointer to the
concatenated string (%@AI@%string1%@AE@%).  %@NL@%
%@NL@%
The %@AB@%strcat%@AE@% and %@AB@%_fstrcat%@AE@% functions operate on null-terminated strings. The
string arguments to these functions are expected to contain a null character
(%@AB@%'\0'%@AE@%) marking the end of the string. No overflow checking is performed when
strings are copied or appended.  %@NL@%
%@NL@%
The %@AB@%_fstrcat%@AE@% function is a model-independent (large-model) form of the
%@AB@%strcat%@AE@% function. The behavior and return value of %@AB@%_fstrcat%@AE@% are identical to
those of the model-dependent function %@AB@%strcat%@AE@%, with the exception that the
arguments and return values are far pointers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcat%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrcat%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strncat%@AE@%,%@AB@% strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRCPY.C: This program uses strcpy and strcat to build a phrase. */
%@AS@%  
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[80];
%@AS@%  
%@AS@%     strcpy( string, "Hello world from " );
%@AS@%     strcat( string, "strcpy " );
%@AS@%     strcat( string, "and " );
%@AS@%     strcat( string, "strcat!" );
%@AS@%     printf( "String = %s\n", string );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  String = Hello world from strcpy and strcat! %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strchr@%%@QR:_fstrchr@%%@NL@%
%@2@%%@CR:C6A03121450 @%%@AB@%strchr, _fstrchr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03121451 @%%@CR:C6A03121452 @% %@CR:C6A03121453 @%%@CR:C6A03121454 @% %@CR:C6A03121455 @% %@CR:C6A03121456 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Find a character in a string.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strchr( const char *string, int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrchr( const char _far *string, int c );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            Source string

%@AI@%c%@AE@%                                 Character to be located

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strchr%@AE@% and %@AB@%_fstrchr%@AE@% functions return a pointer to the first occurrence
of %@AI@%c%@AE@% in %@AI@%string.%@AE@% The character %@AI@%c%@AE@% may be the null character (%@AB@%'\0'%@AE@%); the
terminating null character of %@AI@%string%@AE@% is included in the search. The function
returns %@AB@%NULL%@AE@% if the character is not found.  %@NL@%
%@NL@%
The %@AB@%strchr%@AE@% and %@AB@%_fstrchr%@AE@% functions operate on null-terminated strings. The
string arguments to these functions are expected to contain a null character
(%@AB@%'\0'%@AE@%) marking the end of the string.  %@NL@%
%@NL@%
The %@AB@%_fstrchr%@AE@% function is a model-independent (large-model) form of the
%@AB@%strchr%@AE@% function. The behavior and return value of %@AB@%_fstrchr%@AE@% are identical to
those of the model-dependent function %@AB@%strchr%@AE@%, with the exception that the
arguments and return values are far.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strchr%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrchr%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcspn%@AE@%, %@AB@%strncat%@AE@%,%@AB@% strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strpbrk%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strspn%@AE@%,
%@AB@%strstr%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRCHR.C: This program illustrates searching for a character with
%@AS@%   * strchr (search forward) or strrchr (search backward).
%@AS@%   */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  int  ch = 'r';
%@AS@%  char string[] = "The quick brown dog jumps over the lazy fox";
%@AS@%  char fmt1[] =   "         1         2         3         4         5";
%@AS@%  char fmt2[] =   "12345678901234567890123456789012345678901234567890";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *pdest;
%@AS@%     int result;
%@AS@%  
%@AS@%     printf( "String to be searched: \n\t\t%s\n", string );
%@AS@%     printf( "\t\t%s\n\t\t%s\n\n", fmt1, fmt2 );
%@AS@%     printf( "Search char:\t%c\n", ch );
%@AS@%  
%@AS@%     /* Search forward. */
%@AS@%     pdest = strchr( string, ch );
%@AS@%     result = pdest - string + 1;
%@AS@%     if( pdest != NULL )
%@AS@%        printf( "Result:\tfirst %c found at position %d\n\n", ch, result );
%@AS@%     else
%@AS@%        printf( "Result:\t%c not found\n" );
%@AS@%  
%@AS@%     /* Search backward. */
%@AS@%     pdest = strrchr( string, ch );
%@AS@%     result = pdest - string + 1;
%@AS@%     if( pdest != NULL )
%@AS@%        printf( "Result:\tlast %c found at position %d\n\n", ch, result );
%@AS@%     else
%@AS@%        printf( "Result:\t%c not found\n" );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  String to be searched:
%@AS@%                  The quick brown dog jumps over the lazy fox
%@AS@%                           1         2         3         4         5
%@AS@%                  12345678901234567890123456789012345678901234567890
%@AS@%  
%@AS@%  Search char:    r
%@AS@%  Result: first r found at position 12
%@AS@%  
%@AS@%  Result: last r found at position 30 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strcmp@%%@QR:_fstrcmp@%%@NL@%
%@2@%%@CR:C6A03131457 @%%@AB@%strcmp, _fstrcmp%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03131458 @%%@CR:C6A03131459 @%%@CR:C6A03131460 @% %@CR:C6A03131461 @%%@CR:C6A03131462 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Compare strings.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  int strcmp( const char *string1, const char *string2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _far _fstrcmp( const char _far *string1, const char _far *string2 );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           String to compare

%@AI@%string2%@AE@%                           String to compare

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strcmp%@AE@% and %@AB@%_fstrcmp%@AE@% functions compare %@AI@%string1%@AE@% and %@AI@%string2%@AE@%
lexicographically and return a value indicating their relationship, as
follows:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
< 0                               %@AI@%string1%@AE@% less than %@AI@%string2%@AE@%

= 0                               %@AI@%string1%@AE@% identical to %@AI@%string2%@AE@%

> 0                               %@AI@%string1%@AE@% greater than %@AI@%string2%@AE@%

The %@AB@%strcmp%@AE@% and %@AB@%_fstrcmp%@AE@% functions operate on null-terminated strings. The
string arguments to these functions are expected to contain a null character
(%@AB@%'\0'%@AE@%) marking the end of the string.  %@NL@%
%@NL@%
The %@AB@%_fstrcmp%@AE@% function is a model-independent (large-model) form of the
%@AB@%strcmp%@AE@% function. The behavior and return value of %@AB@%_fstrcmp%@AE@% are identical to
those of the model-dependent function %@AB@%strcmp%@AE@%, with the exception that the
arguments are far pointers.  %@NL@%
%@NL@%
The %@AB@%strcmpi%@AE@% and %@AB@%stricmp%@AE@% functions are case-insensitive versions of %@AB@%strcmp%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcmp%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrcmp%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memcmp%@AE@%,%@AB@% memicmp%@AE@%,%@AB@% strncat, strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRCMP.C */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  char string1[] = "The quick brown dog jumps over the lazy fox";
%@AS@%  char string2[] = "The QUICK brown dog jumps over the lazy fox";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char tmp[20];
%@AS@%     int result;
%@AS@%  
%@AS@%     /* Case sensitive */
%@AS@%     printf( "Compare strings:\n\t%s\n\t%s\n\n", string1, string2 );
%@AS@%     result = strcmp( string1, string2 );
%@AS@%     if( result > 0 )
%@AS@%        strcpy( tmp, "greater than" );
%@AS@%     else if( result < 0 )
%@AS@%        strcpy( tmp, "less than" );
%@AS@%     else
%@AS@%        strcpy( tmp, "equal to" );
%@AS@%     printf( "\tstrcmp:   String 1 is %s string 2\n", tmp );
%@AS@%  
%@AS@%     /* Case insensitive (could use equivalent stricmp) */
%@AS@%     result = strcmpi( string1, string2 );
%@AS@%     if( result > 0 )
%@AS@%        strcpy( tmp, "greater than" );
%@AS@%     else if( result < 0 )
%@AS@%        strcpy( tmp, "less than" );
%@AS@%     else
%@AS@%        strcpy( tmp, "equal to" );
%@AS@%     printf( "\tstrcmpi:  String 1 is %s string 2\n", tmp );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Compare strings:
%@AS@%          The quick brown dog jumps over the lazy fox
%@AS@%          The QUICK brown dog jumps over the lazy fox
%@AS@%  
%@AS@%          strcmp:   String 1 is greater than string 2
%@AS@%          strcmpi:  String 1 is equal to string 2%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strcmpi@%%@NL@%
%@2@%%@CR:C6A03141463 @%%@AB@%strcmpi%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03141464 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Compares strings without regard to case.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  int strcmpi( const char *string1, const char *string2 );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           String to compare

%@AI@%string2%@AE@%                           String to compare

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strcmpi%@AE@% function compares %@AI@%string1%@AE@% and %@AI@%string2%@AE@% lexicographically and
returns a value indicating their relationship, as follows:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
< 0                               %@AI@%string1%@AE@% less than %@AI@%string2%@AE@%

= 0                               %@AI@%string1%@AE@% identical to %@AI@%string2%@AE@%

> 0                               %@AI@%string1%@AE@% greater than %@AI@%string2%@AE@%

The %@AB@%strcmp%@AE@% function is a case-sensitive version of %@AB@%strcmpi%@AE@%.  %@NL@%
%@NL@%
The %@AB@%strcmpi%@AE@% function operates on null-terminated strings. The string
arguments to these functions are expected to contain a null character (%@AB@%'\0'%@AE@%)
marking the end of the string.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memcmp%@AE@%,%@AB@% memicmp%@AE@%,%@AB@% strncat%@AE@%,%@AB@% strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%strcmp%@AE@%. %@NL@%
%@NL@%
%@NL@%
%@QR:strcoll@%%@NL@%
%@2@%%@CR:C6A03151465 @%%@AB@%strcoll%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03151466 @%%@CR:C6A03151467 @% %@CR:C6A03151468 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Compares strings using locale-specific information.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  int strcoll( const char *string1, const char *string2 );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           String to compare

%@AI@%string2%@AE@%                           String to compare

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strcoll%@AE@% function compares %@AI@%string1%@AE@% and %@AI@%string2%@AE@% lexicographically and
returns a value indicating their relationship, as follows:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
< 0                               %@AI@%string1%@AE@% less than %@AI@%string2%@AE@%

= 0                               %@AI@%string1%@AE@% identical to %@AI@%string2%@AE@%

> 0                               %@AI@%string1%@AE@% greater than %@AI@%string2%@AE@%

The %@AB@%strcoll%@AE@% function operates on null-terminated strings. The string
arguments to these functions are expected to contain a null character (%@AB@%'\0'%@AE@%)
marking the end of the string.  %@NL@%
%@NL@%
The %@AB@%strcoll%@AE@% function differs from %@AB@%strcmp%@AE@% in that it uses locale-specific
information to provide locale-specific collating sequences.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return value for this function is described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%localeconv%@AE@%, %@AB@%setlocale%@AE@%, %@AB@%strcmp, strncmp%@AE@%, %@AB@%strxfrm%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strcpy@%%@QR:_fstrcpy@%%@NL@%
%@2@%%@CR:C6A03161469 @%%@AB@%strcpy, _fstrcpy%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03161470 @%%@CR:C6A03161471 @%%@CR:C6A03161472 @% %@CR:C6A03161473 @%%@CR:C6A03161474 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Copy a string.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strcpy( char *string1, const char *string2 ); %@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrcpy( char _far *string1, const char _far *string2 );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           Destination string

%@AI@%string2%@AE@%                           Source string

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strcpy%@AE@% function copies %@AI@%string2%@AE@%, including the terminating null
character, to the location specified by %@AI@%string1%@AE@%, and returns %@AI@%string1%@AE@%.  %@NL@%
%@NL@%
The %@AB@%strcpy%@AE@% and %@AB@%_fstrcpy%@AE@% functions operate on null-terminated strings. The
string arguments to these functions are expected to contain a null character
(%@AB@%'\0'%@AE@%) marking the end of the string. No overflow checking is performed when
strings are copied or appended.  %@NL@%
%@NL@%
The %@AB@%_fstrcpy%@AE@% function is a model-independent (large-model) form of the
%@AB@%strcpy%@AE@% function. The behavior and return value of %@AB@%_fstrcpy%@AE@% are identical to
those of the model-dependent function %@AB@%strcpy%@AE@%, with the exception that the
arguments and return values are far pointers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcpy%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrcpy%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcat%@AE@%, %@AB@%strcmp%@AE@%, %@AB@%strncat%@AE@%,%@AB@% strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRCPY.C: This program uses strcpy and strcat to build a phrase. */
%@AS@%  
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[80];
%@AS@%  
%@AS@%     strcpy( string, "Hello world from " );
%@AS@%     strcat( string, "strcpy " );
%@AS@%     strcat( string, "and " );
%@AS@%     strcat( string, "strcat!" );
%@AS@%     printf( "String = %s\n", string );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  String = Hello world from strcpy and strcat! %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strcspn@%%@QR:_fstrcspn@%%@NL@%
%@2@%%@CR:C6A03171475 @%%@AB@%strcspn, _fstrcspn%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03171476 @%%@CR:C6A03171477 @% %@CR:C6A03171478 @%%@CR:C6A03171479 @% %@CR:C6A03171480 @%%@CR:C6A03171481 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Find a substring in a string.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  size_t strcspn( const char *string1, const char *string2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  size_t _far _fstrcspn( const char _far *string1, const char _far *string2
%@AS@%  );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           Source string

%@AI@%string2%@AE@%                           Character set

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strcspn%@AE@% functions return the index of the first character in %@AI@%string1%@AE@%
belonging to the set of characters specified by %@AI@%string2%@AE@%. This value is
equivalent to the length of the initial substring of %@AI@%string1%@AE@% consisting
entirely of characters not in %@AI@%string2%@AE@%. Terminating null characters are not
considered in the search. If %@AI@%string1%@AE@% begins with a character from %@AI@%string2%@AE@%,
%@AB@%strcspn%@AE@% returns 0.  %@NL@%
%@NL@%
The %@AB@%strcspn%@AE@% and %@AB@%_fstrcspn%@AE@% functions operate on null-terminated strings. The
string arguments to these functions are expected to contain a null character
(%@AB@%'\0'%@AE@%) marking the end of the string.  %@NL@%
%@NL@%
The %@AB@%_fstrcspn%@AE@% function is a model-independent (large-model) form of the
%@AB@%strcspn%@AE@% function. The behavior and return value of %@AB@%_fstrcspn%@AE@% are identical
to those of the modeldependent function %@AB@%strcspn%@AE@%, with the exception that the
arguments and return values are far.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcspn%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrcspn%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strncat%@AE@%,%@AB@% strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRCSPN.C */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[] = "xyzabc";
%@AS@%     int  pos;
%@AS@%  
%@AS@%     pos = strcspn( string, "abc" );
%@AS@%     printf( "First a, b or c in %s is at character %d\n", string, pos );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  First a, b or c in xyzabc is at character 3 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_strdate@%%@NL@%
%@2@%%@CR:C6A03181482 @%%@AB@%_strdate%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03181483 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Copies a date to a buffer.  %@NL@%
%@NL@%
%@AS@%  #include <time.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char *_strdate( char *datestr );%@AE@%%@NL@%
%@NL@%
%@AI@%datestr%@AE@%                           Current date

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_strdate%@AE@% function copies the date to the buffer pointed to by %@AI@%datestr%@AE@%,
formatted  %@NL@%
%@NL@%
%@AS@%  mm/dd/yy%@AE@%%@NL@%
%@NL@%
where %@AS@% mm %@AE@% is two digits representing the month, %@AS@% dd %@AE@% is two digits
representing the day of%@AS@% %@AE@%the month, and %@AS@% yy %@AE@% is the last two digits of the
year. For example, the string  %@NL@%
%@NL@%
%@AS@%  12/05/88%@AE@%%@NL@%
%@NL@%
represents December 5, 1988.  %@NL@%
%@NL@%
The buffer must be at least nine bytes long.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_strdate%@AE@% function returns a pointer to the resulting text string
%@AI@%datestr%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asctime%@AE@%, %@AB@%ctime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%mktime%@AE@%, %@AB@%time%@AE@%, %@AB@%tzset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRTIME.C */
%@AS@%  #include <time.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char dbuffer [9];
%@AS@%     char tbuffer [9];
%@AS@%  
%@AS@%     _strdate( dbuffer );
%@AS@%     printf( "The current date is %s \n", dbuffer );
%@AS@%     _strtime( tbuffer );
%@AS@%     printf( "The current time is %s \n", tbuffer );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The current date is 06/20/89
%@AS@%  The current time is 09:33:13 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strdup@%%@NL@%
%@2@%%@CR:C6A03191484 @%%@AB@%strdup Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03191485 @%%@CR:C6A03191486 @%%@CR:C6A03191487 @% %@CR:C6A03191488 @%%@CR:C6A03191489 @% %@CR:C6A03191490 @%%@CR:C6A03191491 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Duplicate strings.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strdup( const char *string );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrdup( const char _far *string );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _near * _far _nstrdup( const char _far *string );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            Source string

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strdup%@AE@% function allocates storage space (with a call to %@AB@%malloc%@AE@%) for a
copy of %@AI@%string%@AE@% and returns a pointer to the storage space containing the
copied string. The function returns %@AB@%NULL%@AE@% if storage cannot be allocated.  %@NL@%
%@NL@%
The %@AB@%_fstrdup%@AE@% and %@AB@%_nstrdup%@AE@% functions provide complete control over the heap
used for string duplication. The %@AB@%strdup%@AE@% function returns a pointer to a copy
of the string argument. The space for the string is allocated from the heap
specified by the memory model in use. In large-data models (that is,
compact-, large-, and huge-model programs), %@AB@%strdup%@AE@% allocates space from the
far heap. In small-data models (tiny-, small-, and medium-model programs),
%@AB@%strdup%@AE@% allocates space from the near heap.  %@NL@%
%@NL@%
The %@AB@%strdup%@AE@%, %@AB@%_fstrdup%@AE@%, and %@AB@%_nstrdup%@AE@% functions operate on null-terminated
strings. The string arguments to these functions are expected to contain a
null character (%@AB@%'\0'%@AE@%) marking the end of the string.  %@NL@%
%@NL@%
The %@AB@%_fstrdup%@AE@% function returns a far pointer to a copy of the string
allocated in far memory (the far heap). As with the other model-independent
functions, the syntax and semantics of these functions correspond to those
of %@AB@%strdup%@AE@% except for the sizes of the arguments and return values. The
%@AB@%_nstrdup%@AE@% function returns a near pointer to a copy of the string allocated
in the near heap (in the default data segment).  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strdup%@AE@%,  %@AB@%_fstrdup%@AE@%,  %@AB@%_nstrdup%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcat%@AE@%, %@AB@%strcmp%@AE@%, %@AB@%strncat%@AE@%,%@AB@% strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRDUP.C */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <dos.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[] = "This is the buffer text";
%@AS@%     char *newstring;
%@AS@%  
%@AS@%     printf( "Original: %s\n", buffer );
%@AS@%     newstring = strdup( buffer );
%@AS@%     printf( "Copy:     %s\n", newstring );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Original: This is the buffer text
%@AS@%  Copy:     This is the buffer text %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strerror@%%@QR:_strerror@%%@NL@%
%@2@%%@CR:C6A03201492 @%%@AB@%strerror, _strerror%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03201493 @%%@CR:C6A03201494 @% %@CR:C6A03201495 @%%@CR:C6A03201496 @% %@CR:C6A03201497 @%%@CR:C6A03201498 @% %@CR:C6A03201499 @%%@CR:C6A03201500 @% %@CR:C6A03201501 @%%@CR:C6A03201502 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets a system error message (%@AB@%strerror%@AE@%) or prints a user-supplied error
message (%@AB@%_strerror%@AE@%).  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strerror( int errnum );%@AE@%%@NL@%
%@NL@%
%@AS@%  char *_strerror( char *string );%@AE@%%@NL@%
%@NL@%
%@AI@%errnum%@AE@%                            Error number

%@AI@%string%@AE@%                            User-supplied message

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strerror%@AE@% function maps %@AI@%errnum%@AE@% to an error-message string, returning a
pointer to the string. The function itself does not actually print the
message; for that, you need to call an output function such as %@AB@%printf%@AE@%.  %@NL@%
%@NL@%
If %@AI@%string%@AE@% is passed as %@AB@%NULL%@AE@%, %@AB@%_strerror%@AE@% returns a pointer to a string
containing the system error message for the last library call that produced
an error. The error-message string is terminated by the newline character
(%@AB@%'\n'%@AE@%).  %@NL@%
%@NL@%
If %@AI@%string%@AE@% is not equal to %@AB@%NULL%@AE@%, then %@AB@%_strerror%@AE@% returns a pointer to a string
containing (in order) your string message, a colon, a space, the system
error message for the last library call producing an error, and a newline
character. Your string message can be a maximum of 94 bytes long.  %@NL@%
%@NL@%
Unlike %@AB@%perror%@AE@%, %@AB@%_strerror%@AE@% alone does not print any messages. To print the
message returned by %@AB@%_strerror%@AE@% to %@AB@%stderr%@AE@%, your program will need an %@AB@%fprintf%@AE@%
statement, as shown in the following lines:  %@NL@%
%@NL@%
%@AS@%  if ((access("datafile",2)) == -1)
%@AS@%       fprintf(_strerror(NULL));%@AE@%%@NL@%
%@NL@%
The actual error number for %@AB@%_strerror%@AE@% is stored in the variable %@AB@%errno%@AE@%, which
should be declared at the external level. The system error messages are
accessed through the variable %@AB@%sys_errlist%@AE@%, which is an array of messages
ordered by error number. The %@AB@%_strerror%@AE@% function accesses the appropriate
error message by using the %@AB@%errno%@AE@% value as an index to the variable
%@AB@%sys_errlist%@AE@%. The value of the variable %@AB@%sys_nerr%@AE@% is defined as the maximum
number of elements in the %@AB@%sys_errlist%@AE@% array.  %@NL@%
%@NL@%
To produce accurate results, %@AB@%_strerror%@AE@% should be called immediately after a
library routine returns with an error. Otherwise, the %@AB@%errno%@AE@% value may be
overwritten by subsequent calls.  %@NL@%
%@NL@%
Note that the %@AB@%_strerror%@AE@% function under Microsoft C version 5.0 is identical
to the version 4.0 %@AB@%strerror%@AE@% function. The name was altered to permit the
inclusion in Microsoft C version 5.0 of the ANSI-conforming %@AB@%strerror%@AE@%
function. The %@AB@%_strerror%@AE@% function is not part of the ANSI definition but is
instead a Microsoft extension to it; it should not be used where portability
is desired. For ANSI compatibility, use %@AB@%strerror%@AE@% instead.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strerror%@AE@% function returns a pointer to the error-message string. The
string can be overwritten by subsequent calls to %@AB@%strerror%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_strerror%@AE@% function returns no value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strerror%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_strerror%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%clearerr%@AE@%, %@AB@%ferror%@AE@%, %@AB@%perror%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%perror%@AE@%. %@NL@%
%@NL@%
%@NL@%
%@QR:strftime@%%@NL@%
%@2@%%@CR:C6A03211503 @%%@AB@%strftime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03211504 @%%@CR:C6A03211505 @% %@CR:C6A03211506 @%%@CR:C6A03211507 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Formats a time string.  %@NL@%
%@NL@%
%@AB@%#include <time.h>%@AE@%                 Required only for function declarations

%@AS@%  size_t strftime( char *string, size_t maxsize, const char *format, 
%@AS@%  const struct tm *timeptr );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            Output string

%@AI@%maxsize%@AE@%                           Maximum length of string

%@AI@%format%@AE@%                            Format control string

%@AI@%timeptr%@AE@%                           %@AB@%tm%@AE@% data structure

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strftime%@AE@% function formats the %@AB@%tm%@AE@% time value in %@AI@%timeptr%@AE@% according to the
supplied %@AI@%format%@AE@% argument and stores the result in the buffer %@AI@%string%@AE@%. At
most, %@AI@%maxsize%@AE@% characters are placed in the string.  %@NL@%
%@NL@%
The %@AI@%format%@AE@% argument consists of one or more codes; as in %@AB@%printf%@AE@%, the
formatting codes are preceded by a %@AB@%%%@AE@% sign. Characters that do not begin with
a %@AB@%%%@AE@% sign are copied unchanged to %@AI@%string%@AE@%. The %@AB@%LC_TIME%@AE@% category of the current
locale affects the output formatting of %@AB@%strftime%@AE@%.  %@NL@%
%@NL@%
The formatting codes for %@AB@%strftime%@AE@% are listed below:  %@NL@%
%@NL@%
%@AB@%Format %@AE@%                           %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%a                                Abbreviated weekday name

%A                                Full weekday name

%b                                Abbreviated month name

%B                                Full month name

%c                                Date and time representation appropriate
                                  for the locale

%d                                Day of the month as a decimal number (01
                                  - 31)

%H                                Hour in 24-hour format (00 - 23)

%I                                Hour in 12-hour format (01 - 12)

%j                                Day of the year as a decimal number (001
                                  - 366)

%m                                Month as a decimal number (01 - 12)

%M                                Minute as a decimal number (00 - 59)

%p                                Current locale's AM/PM indicator for a 
                                  12-hour clock

%S                                Second as a decimal number (00 - 61)

%U                                Week of the year as a decimal number; 
                                  Sunday is taken as the first day of the 
                                  week (00 - 53)

%w                                Weekday as a decimal number (0 - 6; 
                                  Sunday is 0)

%W                                Week of the year as a decimal number; 
                                  Monday is taken as the first day of the 
                                  week (00 - 53)

%x                                Date representation for current locale

%X                                Time representation for current locale

%y                                Year without the century as a decimal 
                                  number (00 - 99)

%Y                                Year with the century as a decimal 
                                  number

%z                                Time zone name or abbreviation; no 
                                  characters if time zone is unknown

%%                                Percent sign

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strftime%@AE@% function returns the number of characters placed in %@AI@%string%@AE@% if
the total number of resulting characters, including the terminating null, is
not more than %@AI@%maxsize%@AE@%.  %@NL@%
%@NL@%
Otherwise, %@AB@%strftime%@AE@% returns 0, and the contents of the string are
indeterminate.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%localeconv%@AE@%, %@AB@%setlocale%@AE@%, %@AB@%strxfrm%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%perror%@AE@%. %@NL@%
%@NL@%
%@NL@%
%@QR:stricmp@%%@QR:_fstricmp@%%@NL@%
%@2@%%@CR:C6A03221508 @%%@AB@%stricmp, _fstricmp%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03221509 @%%@CR:C6A03221510 @% %@CR:C6A03221511 @%%@CR:C6A03221512 @% %@CR:C6A03221513 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Compare strings without regard to case.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  int stricmp( const char *string1, const char *string2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _far _fstricmp( const char _far *string1, const char _far *string2 );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           String to compare

%@AI@%string2%@AE@%                           String to compare

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%stricmp%@AE@% and %@AB@%_fstricmp%@AE@% functions compare %@AI@%string1%@AE@% and %@AI@%string2%@AE@%
lexicographically and return a value indicating their relationship, as
follows:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
< 0                               %@AI@%string1%@AE@% less than %@AI@%string2%@AE@%

= 0                               %@AI@%string1%@AE@% identical to %@AI@%string2%@AE@%

> 0                               %@AI@%string1%@AE@% greater than %@AI@%string2%@AE@%

The %@AB@%stricmp%@AE@% and %@AB@%_fstricmp%@AE@% functions operate on null-terminated strings. The
string arguments to these functions are expected to contain a null character
(%@AB@%'\0'%@AE@%) marking the end of the string.  %@NL@%
%@NL@%
The %@AB@%_fstricmp%@AE@% function is a model-independent (large-model) form of the
%@AB@%stricmp%@AE@% function. The behavior and return value of %@AB@%_fstricmp%@AE@% are identical
to those of the modeldependent function %@AB@%stricmp%@AE@%, with the exception that the
arguments are far pointers.  %@NL@%
%@NL@%
The %@AB@%strcmp%@AE@% function is a case-sensitive version of %@AB@%stricmp%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%stricmp%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@AB@%_fstricmp  %@AE@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@%DOS  %@AB@%%@AE@%OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memcmp%@AE@%, %@AB@%memicmp%@AE@%, %@AB@%strcat%@AE@%, %@AB@%strcpy%@AE@%, %@AB@%strncat%@AE@%, %@AB@%strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%,
%@AB@%strrchr%@AE@%, %@AB@%strset%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%strcmp%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strlen@%%@QR:_fstrlen@%%@NL@%
%@2@%%@CR:C6A03231514 @%%@AB@%strlen, _fstrlen%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Get the length of a string.%@CR:C6A03231515 @%  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  size_t strlen( const char *string );%@AE@%%@NL@%
%@NL@%
%@AS@%  size_t _fstrlen( const char _far *string );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            Null-terminated string

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strlen%@AE@% and %@AB@%_fstrlen%@AE@% functions return the length in bytes of %@AI@%string%@AE@%, not
including the terminating null character (%@AB@%'\0'%@AE@%).  %@NL@%
%@NL@%
The %@AB@%_fstrlen%@AE@% function is a model-independent (large-model) form of the
%@AB@%strlen%@AE@% function. The behavior and return value of %@AB@%_fstrlen%@AE@% are identical to
those of the model-dependent function %@AB@%strlen%@AE@%, with the exception that the
argument is a far pointer.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return the string length. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strlen%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrlen%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRLEN.C */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <conio.h>
%@AS@%  #include <dos.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[61] = "How long am I?";
%@AS@%     int  len;
%@AS@%  
%@AS@%     len = strlen( buffer );
%@AS@%     printf( "'%s' is %d characters long\n", buffer, len );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  'How long am I?' is 14 characters long %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strlwr@%%@QR:_fstrlwr@%%@NL@%
%@2@%%@CR:C6A03241516 @%%@AB@%strlwr, _fstrlwr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03241517 @%%@CR:C6A03241518 @% %@CR:C6A03241519 @%%@CR:C6A03241520 @% %@CR:C6A03241521 @%%@CR:C6A03241522 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Convert a string to lowercase.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strlwr( char *string );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrlwr( char _far *string );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            String to be converted

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strlwr%@AE@% and %@AB@%_fstrlwr%@AE@% functions convert any uppercase letters in the given
nullterminated %@AI@%string%@AE@% to lowercase. Other characters are not affected.  %@NL@%
%@NL@%
The %@AB@%_fstrlwr%@AE@% function is a model-independent (large-model) form of the
%@AB@%strlwr%@AE@% function. The behavior and return value of %@AB@%_fstrlwr%@AE@% are identical to
those of the model-dependent function %@AB@%strlwr%@AE@%, with the exception that the
argument and return values are far pointers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return a pointer to the converted string. There is no error
return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strupr%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRLWR.C: This program uses strlwr and strupr to create
%@AS@%   * uppercase and lowercase copies of a mixed-case string.
%@AS@%   */
%@AS@%  
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[100] = "The String to End All Strings!";
%@AS@%     char *copy1, *copy2;
%@AS@%  
%@AS@%     copy1 = strlwr( strdup( string ) );
%@AS@%     copy2 = strupr( strdup( string ) );
%@AS@%     printf( "Mixed: %s\n", string );
%@AS@%     printf( "Lower: %s\n", copy1 );
%@AS@%     printf( "Upper: %s\n", copy2 );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Mixed: The String to End All Strings!
%@AS@%  Lower: the string to end all strings!
%@AS@%  Upper: THE STRING TO END ALL STRINGS! %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strncat@%%@QR:_fstrncat@%%@NL@%
%@2@%%@CR:C6A03251523 @%%@AB@%strncat, _fstrncat%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03251524 @%%@CR:C6A03251525 @% %@CR:C6A03251526 @%%@CR:C6A03251527 @% %@CR:C6A03251528 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Appends characters of a string.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strncat( char *string1, const char *string2, size_t count );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrncat( char _far *string1, const char _far *string2, 
%@AS@%  size_t count );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           Destination string

%@AI@%string2%@AE@%                           Source string

%@AI@%count%@AE@%                             Number of characters appended

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strncat%@AE@% and _%@AB@%fstrncat%@AE@% functions append, at most, the first %@AI@%count%@AE@%
characters of %@AI@%string2%@AE@% to %@AI@%string1%@AE@%, terminate the resulting string with a null
character (%@AB@%'\0'%@AE@%), and return a pointer to the concatenated string (%@AI@%string1%@AE@%).
If %@AI@%count%@AE@% is greater than the length of %@AI@%string2%@AE@%, the length of %@AI@%string2%@AE@% is
used in place of %@AI@%count%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_fstrncat%@AE@% function is a model-independent (large-model) form of the
%@AB@%strncat%@AE@% function. The behavior and return value of %@AB@%_fstrncat%@AE@% are identical
to those of the model-dependent function %@AB@%strncat%@AE@%, with the exception that
all the pointer arguments and return values are far pointers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strncat%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrncat%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcat%@AE@%, %@AB@%strcmp%@AE@%, %@AB@%strcpy%@AE@%, %@AB@%strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strset%@AE@%, %@AB@%strspn%@AE@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRNCAT.C */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[80] = "This is the initial string!";
%@AS@%     char suffix[] = " extra text to add to the string...";
%@AS@%  
%@AS@%     /* Combine strings with no more than 19 characters of suffix:  */
%@AS@%     printf( "Before: %s\n", string );
%@AS@%     strncat( string, suffix, 19 );
%@AS@%     printf( "After:  %s\n", string );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Before: This is the initial string!
%@AS@%  After:  This is the initial string! extra text to add %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strncmp@%%@QR:_fstrncmp@%%@NL@%
%@2@%%@CR:C6A03261529 @%%@AB@%strncmp, _fstrncmp%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03261530 @%%@CR:C6A03261531 @% %@CR:C6A03261532 @%%@CR:C6A03261533 @% %@CR:C6A03261534 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Compare characters of two strings.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  int strncmp( const char *string1, const char *string2, size_t count );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _far _fstrncmp( const char _far *string1, const char _far *string2,
%@AS@%  size_t count );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           String to compare

%@AI@%string2%@AE@%                           String to compare

%@AI@%count%@AE@%                             Number of characters compared

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strncmp%@AE@% and %@AB@%_fstrncmp%@AE@% functions lexicographically compare, at most, the
first %@AI@%count %@AE@%characters of %@AI@%string1%@AE@% and %@AI@%string2%@AE@% and return a value indicating
the relationship between the substrings, as listed below:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
< 0                               %@AI@%string1%@AE@% less than %@AI@%string2%@AE@%

= 0                               %@AI@%string1%@AE@% equivalent to %@AI@%string2%@AE@%

> 0                               %@AI@%string1%@AE@% greater than %@AI@%string2%@AE@%

The %@AB@%strnicmp%@AE@% function is a case-insensitive version of %@AB@%strncmp%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_fstrncmp%@AE@% function is a model-independent (large-model) form of the
%@AB@%strncmp%@AE@% function. The behavior and return value of %@AB@%_fstrncmp%@AE@% are identical
to those of the model-dependent function %@AB@%strncmp%@AE@%, with the exception that
all the arguments and return values are far.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strncmp%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrncmp%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcat%@AE@%, %@AB@%strcmp%@AE@%, %@AB@%strcpy%@AE@%, %@AB@%strncat%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strset%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRNCMP.C */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  char string1[] = "The quick brown dog jumps over the lazy fox";
%@AS@%  char string2[] = "The QUICK brown fox jumps over the lazy dog";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char tmp[20];
%@AS@%     int result;
%@AS@%  
%@AS@%     printf( "Compare strings:\n\t\t%s\n\t\t%s\n\n", string1, string2 );
%@AS@%  
%@AS@%     printf( "Function:\tstrncmp (first 10 characters only)\n" );
%@AS@%     result = strncmp( string1, string2 , 10 );
%@AS@%     if( result > 0 )
%@AS@%        strcpy( tmp, "greater than" );
%@AS@%     else if( result < 0 )
%@AS@%        strcpy( tmp, "less than" );
%@AS@%     else
%@AS@%        strcpy( tmp, "equal to" );
%@AS@%     printf( "Result:\t\tString 1 is %s string 2\n\n", tmp );
%@AS@%  
%@AS@%     printf( "Function:\tstrnicmp (first 10 characters only)\n" );
%@AS@%     result = strnicmp( string1, string2, 10 );
%@AS@%     if( result > 0 )
%@AS@%        strcpy( tmp, "greater than" );
%@AS@%     else if( result < 0 )
%@AS@%        strcpy( tmp, "less than" );
%@AS@%     else
%@AS@%        strcpy( tmp, "equal to" );
%@AS@%     printf( "Result:\t\tString 1 is %s string 2\n\n", tmp );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Compare strings:
%@AS@%                  The quick brown dog jumps over the lazy fox
%@AS@%                  The QUICK brown fox jumps over the lazy dog
%@AS@%  
%@AS@%  Function:       strncmp (first 10 characters only)
%@AS@%  Result:         String 1 is greater than string 2
%@AS@%  
%@AS@%  Function:       strnicmp (first 10 characters only)
%@AS@%  Result:         String 1 is equal to string 2 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strncpy@%%@QR:_fstrncpy@%%@NL@%
%@2@%%@CR:C6A03271535 @%%@AB@%strncpy, _fstrncpy%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03271536 @%%@CR:C6A03271537 @% %@CR:C6A03271538 @%%@CR:C6A03271539 @% %@CR:C6A03271540 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Copy characters of one string to another.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strncpy( char *string1, const char *string2, size_t count );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrncpy( char _far *string1, const char _far *string2, 
%@AS@%  size_t count );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           Destination string

%@AI@%string2%@AE@%                           Source string

%@AI@%count%@AE@%                             Number of characters copied

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strncpy%@AE@% and %@AB@%_fstrncpy%@AE@% functions copy%@AI@% count%@AE@% characters of %@AI@%string2%@AE@% to
%@AI@%string1%@AE@% and return %@AI@%string1%@AE@%. If %@AI@%count%@AE@% is less than the length of %@AI@%string2%@AE@%, a
null character (%@AB@%'\0'%@AE@%) is not appended automatically to the copied string. If
%@AI@%count%@AE@% is greater than the length of %@AI@%string2%@AE@%, the %@AI@%string1%@AE@% result is padded
with null characters (%@AB@%'\0'%@AE@%) up to length %@AI@%count.%@AE@%  %@NL@%
%@NL@%
Note that the behavior of %@AB@%strncpy%@AE@% and %@AB@%_fstrncpy%@AE@% is undefined if the address
ranges of the source and destination strings overlap.  %@NL@%
%@NL@%
The %@AB@%_fstrncpy%@AE@% function is a model-independent (large-model) form of the
%@AB@%strncpy%@AE@% function. The behavior and return value of %@AB@%_fstrncpy%@AE@% are identical
to those of the model- dependent function %@AB@%strncpy%@AE@%, with the exception that
all the arguments and return values are far.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strncpy%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrncpy%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcat%@AE@%, %@AB@%strcmp%@AE@%, %@AB@%strcpy%@AE@%, %@AB@%strncat%@AE@%, %@AB@%strncmp%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strset%@AE@%, %@AB@%strspn%@AE@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRNCPY.C */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[100] = "Cats are nice usually";
%@AS@%  
%@AS@%     printf("Before: %s\n", string );
%@AS@%     strncpy( string, "Dogs", 4 );
%@AS@%     strncpy( string + 9, "mean", 4 );
%@AS@%     printf("After:  %s\n", string );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Before: Cats are nice usually
%@AS@%  After:  Dogs are mean usually %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strnicmp@%%@QR:_fstrnicmp@%%@NL@%
%@2@%%@CR:C6A03281541 @%%@AB@%strnicmp, _fstrnicmp%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03281542 @%%@CR:C6A03281543 @% %@CR:C6A03281544 @%%@CR:C6A03281545 @% %@CR:C6A03281546 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Compare characters of two strings without regard to case.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  int strnicmp( const char *string1, const char *string2, size_t count );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _far _fstrnicmp( const char _far *string1, const char _far *string2, 
%@AS@%  size_t count );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           String to compare

%@AI@%string2%@AE@%                           String to compare

%@AI@%count%@AE@%                             Number of characters compared

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strnicmp%@AE@% and %@AB@%_fstrnicmp%@AE@% functions lexicographically compare (without
regard to case), at most, the first %@AI@%count%@AE@% characters of %@AI@%string1%@AE@% and %@AI@%string2%@AE@%
and return a value indicating the relationship between the substrings, as
listed below:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
< 0                               %@AI@%string1%@AE@% less than %@AI@%string2%@AE@%

= 0                               %@AI@%string1%@AE@% equivalent to %@AI@%string2%@AE@%

> 0                               %@AI@%string1%@AE@% greater than %@AI@%string2%@AE@%

The %@AB@%strncmp%@AE@% function is a case-sensitive version of %@AB@%strnicmp%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_fstrnicmp%@AE@% function is a model-independent (large-model) form of the
%@AB@%strnicmp%@AE@% function. The behavior and return value of %@AB@%_fstrnicmp%@AE@% are identical
to those of the model-dependent function %@AB@%strnicmp%@AE@%, with the exception that
all the arguments and return values are far.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcat%@AE@%, %@AB@%strcmp%@AE@%, %@AB@%strcpy%@AE@%, %@AB@%strncat%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strset%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%strncmp%@AE@%. %@NL@%
%@NL@%
%@NL@%
%@QR:strnset@%%@QR:_fstrnset@%%@NL@%
%@2@%%@CR:C6A03291547 @%%@AB@%strnset, _fstrnset%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03291548 @%%@CR:C6A03291549 @% %@CR:C6A03291550 @%%@CR:C6A03291551 @% %@CR:C6A03291552 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Initialize characters of a string to a given character.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strnset( char *string, int c, size_t count );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrnset( char _far *string, int c, size_t count );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            String to be initialized

%@AI@%c%@AE@%                                 Character setting

%@AI@%count%@AE@%                             Number of characters set

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strnset%@AE@% and %@AB@%_fstrnset%@AE@% functions set, at most, the first %@AI@%count%@AE@% characters
of %@AI@%string%@AE@% to the character %@AI@%c%@AE@% and return a pointer to the altered string. If
%@AI@%count%@AE@% is greater than the length of %@AI@%string%@AE@%, the length of %@AI@%string%@AE@% is used in
place of %@AI@%count%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_fstrnset%@AE@% function is a model-independent (large-model) form of the
%@AB@%strnset%@AE@% function. The behavior and return value of %@AB@%_fstrnset%@AE@% are identical
to those of the model-dependent function %@AB@%strnset%@AE@%, with the exception that
all the arguments and return values are far.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return values for these functions are described above.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcat%@AE@%, %@AB@%strcmp%@AE@%, %@AB@%strcpy%@AE@%, %@AB@%strset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRNSET.C */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[15] = "This is a test";
%@AS@%  
%@AS@%     /* Set not more than 4 characters of string to be *'s */
%@AS@%     printf( "Before: %s\n", string );
%@AS@%     strnset( string, '*', 4 );
%@AS@%     printf( "After:  %s\n", string );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Before: This is a test
%@AS@%  After:  **** is a test %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strpbrk@%%@QR:_fstrpbrk@%%@NL@%
%@2@%%@CR:C6A03301553 @%%@AB@%strpbrk, _fstrpbrk%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03301554 @%%@CR:C6A03301555 @% %@CR:C6A03301556 @%%@CR:C6A03301557 @% %@CR:C6A03301558 @%%@CR:C6A03301559 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Scan strings for characters in specified character sets.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strpbrk( const char *string1, const char *string2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrpbrk( const char _far *string1, const char _far
%@AS@%  *string2 );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           Source string

%@AI@%string2%@AE@%                           Character set

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strpbrk%@AE@% function finds the first occurrence in %@AI@%string1%@AE@% of any character
from %@AI@%string2%@AE@%. The terminating null character (%@AB@%'\0'%@AE@%) is not included in the
search.  %@NL@%
%@NL@%
The %@AB@%_fstrpbrk%@AE@% function is a model-independent (large-model) form of the
%@AB@%strpbrk%@AE@% function. The behavior and return value of %@AB@%_fstrpbrk%@AE@% are identical
to those of the model- dependent function %@AB@%strpbrk%@AE@%, with the exception that
all the arguments and return values are far.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return a pointer to the first occurrence of any character
from %@AI@%string2%@AE@% in %@AI@%string1%@AE@%. A %@AB@%NULL%@AE@% return value indicates that the two string
arguments have no characters in common.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strpbrk%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrpbrk%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strchr%@AE@%, %@AB@%strrchr%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRPBRK.C */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[100] = "The 3 men and 2 boys ate 5 pigs\n";
%@AS@%     char *result;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Return pointer to first 'a' or 'b' in "string"  */
%@AS@%     printf( "1: %s\n", string );
%@AS@%     result = strpbrk( string, "0123456789" );
%@AS@%     printf( "2: %s\n", result++ );
%@AS@%     result = strpbrk( result, "0123456789" );
%@AS@%     printf( "3: %s\n", result++ );
%@AS@%     result = strpbrk( result, "0123456789" );
%@AS@%     printf( "4: %s\n", result );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  1: The 3 men and 2 boys ate 5 pigs
%@AS@%  
%@AS@%  2: 3 men and 2 boys ate 5 pigs
%@AS@%  
%@AS@%  3: 2 boys ate 5 pigs
%@AS@%  
%@AS@%  4: 5 pigs %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strrchr@%%@QR:_fstrrchr@%%@NL@%
%@2@%%@CR:C6A03311560 @%%@AB@%strrchr, _fstrrchr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03311561 @%%@CR:C6A03311562 @% %@CR:C6A03311563 @%%@CR:C6A03311564 @% %@CR:C6A03311565 @% %@CR:C6A03311566 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Scan a string for the last occurrence of a character.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strrchr( const char *string, int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrrchr( const char _far *string, int c );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            Searched string

%@AI@%c%@AE@%                                 Character to be located

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strrchr%@AE@% function finds the last occurrence of the character %@AI@%c%@AE@% in %@AI@%string.%@AE@%
The string's terminating null character (%@AB@%'\0'%@AE@%) is included in the search.
(Use %@AB@%strchr%@AE@% to find the first occurrence of %@AI@%c%@AE@% in %@AI@%string%@AE@%.)  %@NL@%
%@NL@%
The %@AB@%_fstrrchr%@AE@% function is a model-independent (large-model) form of the
%@AB@%strrchr%@AE@% function. The behavior and return value of %@AB@%_fstrrchr%@AE@% are identical
to those of the modeldependent function %@AB@%strrchr%@AE@%, with the exception that all
the pointer arguments and return values are far pointers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return a pointer to the last occurrence of the character in
the string. A %@AB@%NULL%@AE@% pointer is returned if the given character is not found.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strrchr%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrrchr%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strchr%@AE@%, %@AB@%strcspn%@AE@%, %@AB@%strncat%@AE@%, %@AB@%strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strpbrk%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRCHR.C: This program illustrates searching for a character with
%@AS@%   * strchr (search forward) or strrchr (search backward).
%@AS@%   */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int  ch = 'r';
%@AS@%  char string[] = "The quick brown dog jumps over the lazy fox";
%@AS@%  char fmt1[] =   "         1         2         3         4         5";
%@AS@%  char fmt2[] =   "12345678901234567890123456789012345678901234567890";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *pdest;
%@AS@%     int result;
%@AS@%  
%@AS@%     printf( "String to be searched: \n\t\t%s\n", string );
%@AS@%     printf( "\t\t%s\n\t\t%s\n\n", fmt1, fmt2 );
%@AS@%     printf( "Search char:\t%c\n", ch );
%@AS@%  
%@AS@%     /* Search forward. */
%@AS@%     pdest = strchr( string, ch );
%@AS@%     result = pdest - string + 1;
%@AS@%     if( pdest != NULL )
%@AS@%        printf( "Result:\tfirst %c found at position %d\n\n", ch, result );
%@AS@%     else
%@AS@%        printf( "Result:\t%c not found\n" );
%@AS@%  
%@AS@%     /* Search backward. */
%@AS@%     pdest = strrchr( string, ch );
%@AS@%     result = pdest - string + 1;
%@AS@%     if( pdest != NULL )
%@AS@%        printf( "Result:\tlast %c found at position %d\n\n", ch, result );
%@AS@%     else
%@AS@%        printf( "Result:\t%c not found\n" );
%@AS@%  
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  String to be searched:
%@AS@%                  The quick brown dog jumps over the lazy fox
%@AS@%                           1         2         3         4         5
%@AS@%                  12345678901234567890123456789012345678901234567890
%@AS@%  
%@AS@%  Search char:    r
%@AS@%  Result: first r found at position 12
%@AS@%  
%@AS@%  Result: last r found at position 30 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strrev@%%@QR:_fstrrev@%%@NL@%
%@2@%%@CR:C6A03321567 @%%@AB@%strrev, _fstrrev%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03321568 @%%@CR:C6A03321569 @%%@CR:C6A03321570 @% %@CR:C6A03321571 @%%@CR:C6A03321572 @% %@CR:C6A03321573 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Reverses characters of a string.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strrev( char *string );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrrev( char _far *string );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            String to be reversed

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strrev%@AE@% function reverses the order of the characters in %@AI@%string%@AE@%. The
terminating null character (%@AB@%'\0'%@AE@%) remains in place.  %@NL@%
%@NL@%
The %@AB@%_fstrrev%@AE@% function is a model-independent (large-model) form of the
%@AB@%strrev%@AE@% function. The behavior and return value of %@AB@%_fstrrev%@AE@% are identical to
those of the model-dependent function %@AB@%strrev%@AE@%, with the exception that the
argument and return value are far pointers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return a pointer to the altered string. There is no error
return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcpy%@AE@%, %@AB@%strset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRREV.C: This program checks an input string to see whether it is a
%@AS@%   * palindrome: that is, whether it reads the same forward and backward.
%@AS@%   */
%@AS@%  
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[100];
%@AS@%     int result;
%@AS@%  
%@AS@%     printf( "Input a string and I will tell you if it is a palindrome:\n"
%@AS@%);
%@AS@%     gets( string );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Reverse string and compare (ignore case): */
%@AS@%     result = strcmpi( string, strrev( strdup( string ) ) );
%@AS@%     if( result == 0 )
%@AS@%        printf( "The string \"%s\" is a palindrome\n\n", string );
%@AS@%     else
%@AS@%        printf( "The string \"%s\" is not a palindrome\n\n", string );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Input a string and I will tell you if it is a palindrome:
%@AS@%  Able was I ere I saw Elba
%@AS@%  The string "Able was I ere I saw Elba" is a palindrome %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strset@%%@QR:_fstrset@%%@NL@%
%@2@%%@CR:C6A03331574 @%%@AB@%strset, _fstrset%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03331575 @%%@CR:C6A03331576 @% %@CR:C6A03331577 @%%@CR:C6A03331578 @% %@CR:C6A03331579 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Set characters of a string to a character.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strset( char *string, int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrset( char _far *string, int c );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            String to be set

%@AI@%c%@AE@%                                 Character setting

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strset%@AE@% function sets all of the characters of %@AI@%string%@AE@% to %@AI@%c%@AE@%, except the
terminating null character (%@AB@%'\0'%@AE@%).  %@NL@%
%@NL@%
The %@AB@%_fstrset%@AE@% function is a model-independent (large-model) form of the
%@AB@%strset%@AE@% function. The behavior and return value of %@AB@%_fstrset%@AE@% are identical to
those of the model-dependent function %@AB@%strset%@AE@%, with the exception that the
pointer arguments and return value are far pointers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return a pointer to the altered string. There is no error
return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%memset%@AE@%, %@AB@%strcat%@AE@%, %@AB@%strcmp%@AE@%, %@AB@%strcpy%@AE@%, %@AB@%strnset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRSET.C */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[] = "Fill the string with something";
%@AS@%  
%@AS@%     printf( "Before: %s\n", string );
%@AS@%     strset( string, '*' );
%@AS@%     printf( "After:  %s\n", string );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Before: Fill the string with something
%@AS@%  After:  ****************************** %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strspn@%%@QR:_fstrspn@%%@NL@%
%@2@%%@CR:C6A03341580 @%%@AB@%strspn, _fstrspn%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03341581 @%%@CR:C6A03341582 @% %@CR:C6A03341583 @%%@CR:C6A03341584 @% %@CR:C6A03341585 @% %@CR:C6A03341586 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Find the first substring.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  size_t strspn( const char *string1, const char *string2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  size_t _far _fstrspn( const char _far *string1, const char _far *string2
%@AS@%  );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           Searched string

%@AI@%string2%@AE@%                           Character set

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strspn%@AE@% function returns the index of the first character in %@AI@%string1%@AE@% that
does not belong to the set of characters specified by %@AI@%string2%@AE@%. This value is
equivalent to the length of the initial substring of %@AI@%string1%@AE@% that consists
entirely of characters from %@AI@%string2%@AE@%. The null character (%@AB@%'\0'%@AE@%) terminating
%@AI@%string2%@AE@% is not considered in the matching process. If %@AI@%string1%@AE@% begins with a
character not in %@AI@%string2%@AE@%, %@AB@%strspn%@AE@% returns 0.  %@NL@%
%@NL@%
The %@AB@%_fstrspn%@AE@% function is a model-independent (large-model) form of the
%@AB@%strspn%@AE@% function. The behavior and return value of %@AB@%_fstrspn%@AE@% are identical to
those of the model-dependent function %@AB@%strspn%@AE@%, with the exception that the
arguments are far pointers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return an integer value specifying the length of the segment
in %@AI@%string1%@AE@% consisting entirely of characters in %@AI@%string2.  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrspn%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcspn%@AE@%, %@AB@%strncat%@AE@%, %@AB@%strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strrchr%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRSPN.C: This program uses strspn to determine the length of
%@AS@%   * the segment in the string "cabbage" consisting of a's, b's, and c's.
%@AS@%   * In other words, it finds the first non-abc letter.
%@AS@%   */
%@AS@%  
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[] = "cabbage";
%@AS@%     int  result;
%@AS@%  
%@AS@%     result = strspn( string, "abc" );
%@AS@%     printf( "The portion of '%s' containing only a, b, or c "
%@AS@%             "is %d bytes long\n", string, result );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The portion of 'cabbage' containing only a, b, or c is 5 bytes long %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strstr@%%@QR:_fstrstr@%%@NL@%
%@2@%%@CR:C6A03351587 @%%@AB@%strstr, _fstrstr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03351588 @%%@CR:C6A03351589 @% %@CR:C6A03351590 @%%@CR:C6A03351591 @% %@CR:C6A03351592 @% %@CR:C6A03351593 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Find a substring.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strstr( const char *string1, const char *string2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrstr( const char _far *string1, const char _far
%@AS@%  *string2 );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           Searched string

%@AI@%string2%@AE@%                           String to search for

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strstr%@AE@% function returns a pointer to the first occurrence of %@AI@%string2%@AE@% in
%@AI@%string1%@AE@%.  %@NL@%
%@NL@%
The %@AB@%_fstrstr%@AE@% function is a model-independent (large-model) form of the
%@AB@%strstr%@AE@% function. The behavior and return value of %@AB@%_fstrstr%@AE@% are identical to
those of the model-dependent function %@AB@%strstr%@AE@%, with the exception that the
arguments and return value are far pointers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return either a pointer to the first occurrence of %@AI@%string2%@AE@%
in %@AI@%string1%@AE@%, or %@AB@%NULL%@AE@% if they do not find the string.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strstr%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrstr%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcspn%@AE@%, %@AB@%strncat%@AE@%, %@AB@%strncmp%@AE@%, %@AB@%strncpy%@AE@%, %@AB@%strnicmp%@AE@%, %@AB@%strpbrk%@AE@%, %@AB@%strrchr%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRSTR.C */
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  char str[] =    "lazy";
%@AS@%  char string[] = "The quick brown dog jumps over the lazy fox";
%@AS@%  char fmt1[] =   "         1         2         3         4         5";
%@AS@%  char fmt2[] =   "12345678901234567890123456789012345678901234567890";%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *pdest;
%@AS@%     int  result;
%@AS@%  
%@AS@%     printf( "String to be searched:\n\t%s\n", string );
%@AS@%     printf( "\t%s\n\t%s\n\n", fmt1, fmt2 );
%@AS@%  
%@AS@%     pdest = strstr( string, str );
%@AS@%     result = pdest - string + 1;
%@AS@%     if( pdest != NULL )
%@AS@%        printf( "%s found at position %d\n\n", str, result );
%@AS@%     else
%@AS@%        printf( "%s not found\n", str );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  String to be searched:
%@AS@%          The quick brown dog jumps over the lazy fox
%@AS@%                   1         2         3         4         5
%@AS@%          12345678901234567890123456789012345678901234567890
%@AS@%  
%@AS@%  lazy found at position 36 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_strtime@%%@NL@%
%@2@%%@CR:C6A03361594 @%%@AB@%_strtime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03361595 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Copies the time to a buffer.  %@NL@%
%@NL@%
%@AS@%  #include <time.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char *_strtime( char *timestr );%@AE@%%@NL@%
%@NL@%
%@AI@%timestr%@AE@%                           Time string

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_strtime%@AE@% function copies the current time into the buffer pointed to by
%@AI@%timestr.%@AE@% The time is formatted  %@NL@%
%@NL@%
%@AS@%  hh:mm:ss%@AE@%%@NL@%
%@NL@%
where %@AS@% hh %@AE@% is two digits representing the hour in 24-hour notation, %@AS@% mm %@AE@% is
two digits representing the minutes past the hour, and %@AS@% ss %@AE@% is two digits
representing seconds. For example, the string  %@NL@%
%@NL@%
%@AS@%  18:23:44%@AE@%%@NL@%
%@NL@%
represents 23 minutes and 44 seconds past 6:00 PM.  %@NL@%
%@NL@%
The buffer must be at least nine bytes long.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_strtime%@AE@% function returns a pointer to the resulting text string
%@AI@%timestr%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asctime%@AE@%, %@AB@%ctime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%mktime%@AE@%, %@AB@%time%@AE@%, %@AB@%tzset%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRTIME.C */
%@AS@%  #include <time.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char dbuffer [9];
%@AS@%     char tbuffer [9];%@AE@%%@NL@%
%@NL@%
%@AS@%  _strdate( dbuffer );
%@AS@%     printf( "The current date is %s \n", dbuffer );
%@AS@%     _strtime( tbuffer );
%@AS@%     printf( "The current time is %s \n", tbuffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The current date is 06/20/89
%@AS@%  The current time is 09:33:13 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strtod@%%@QR:strtol@%%@QR:_strtold@%%@QR:strtoul@%%@NL@%
%@2@%%@CR:C6A03371596 @%%@AB@%strtod, strtol, _strtold, strtoul%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03371597 @%%@CR:C6A03371598 @%%@CR:C6A03371599 @% %@CR:C6A03371600 @% %@CR:C6A03371601 @%%@CR:C6A03371602 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Convert strings to a double-precision (%@AB@%strtod%@AE@%, %@AB@%_strtold%@AE@%), long-integer
(%@AB@%strtol%@AE@%), or unsigned long-integer (%@AB@%strtoul%@AE@%) value.  %@NL@%
%@NL@%
%@AS@%  #include <stdlib.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  double strtod( const char *nptr, char **endptr );%@AE@%%@NL@%
%@NL@%
%@AS@%  long strtol( const char *nptr, char **endptr, int base );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double _strtold( const char *nptr, char **endptr );%@AE@%%@NL@%
%@NL@%
%@AS@%  unsigned long strtoul( const char *nptr, char **endptr, int base );%@AE@%%@NL@%
%@NL@%
%@AI@%nptr%@AE@%                              String to convert

%@AI@%endptr%@AE@%                            End of scan

%@AI@%base%@AE@%                              Number base to use

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strtod%@AE@%, %@AB@%_strtold%@AE@%, %@AB@%strtol%@AE@%, and %@AB@%strtoul%@AE@% functions convert a character
string to a double-precision value, a long-double value, a long-integer
value, or an unsigned long-integer value, respectively. The input string is
a sequence of characters that can be interpreted as a numerical value of the
specified type. If the %@AB@%strtod%@AE@% or %@AB@%_strtold%@AE@% function appears in a compact-,
large-, or huge-model program, %@AI@%nptr%@AE@% can be a maximum of 100 characters.  %@NL@%
%@NL@%
These functions stop reading the string at the first character they cannot
recognize as part of a number. This may be the null character (%@AB@%'\0'%@AE@%) at the
end of the string. With %@AB@%strtol%@AE@% or %@AB@%strtoul%@AE@%, this terminating character can
also be the first numeric character greater than or equal to %@AI@%base%@AE@%. If %@AI@%endptr%@AE@%
is not %@AB@%NULL%@AE@%, a pointer to the character that stopped the scan is stored at
the location pointed to by %@AI@%endptr%@AE@%. If no conversion could be performed (no
valid digits were found or an invalid base was specified), the value of %@AI@%nptr%@AE@%
is stored at the location pointed to by %@AI@%endptr%@AE@%.  %@NL@%
%@NL@%
The %@AB@%strtod%@AE@% and %@AB@%_strtold%@AE@% functions expect %@AI@%nptr%@AE@% to point to a string with the
following form:  %@NL@%
%@NL@%
%@AS@%  [[whitespace]] [[sign]] [[digits]] [[.digits]] [[ {d | D | e |
%@AS@%  E}[[sign]]digits]]%@AE@%%@NL@%
%@NL@%
The first character that does not fit this form stops the scan.  %@NL@%
%@NL@%
The %@AB@%strtol%@AE@% function expects %@AI@%nptr%@AE@% to point to a string with the following
form:  %@NL@%
%@NL@%
%@AS@%  [[whitespace]] [[sign]] [[0]] [[{ x | X }]] [[digits]]%@AE@%%@NL@%
%@NL@%
The %@AB@%strtoul%@AE@% function expects %@AI@%nptr%@AE@% to point to a string having this form:  %@NL@%
%@NL@%
%@AS@%  [[whitespace]] [[{ + | -}]] [[0]] [[{ x | X }]] [[digits]]%@AE@%%@NL@%
%@NL@%
If %@AI@%base%@AE@% is between 2 and 36, then it is used as the base of the number. If
%@AI@%base%@AE@% is 0, the initial characters of the string pointed to by %@AI@%nptr%@AE@% are used
to determine the base. If the first character is 0 and the second character
is not 'x' or 'X', then the string is interpreted as an octal integer;
otherwise, it is interpreted as a decimal number. If the first character is
'0' and the second character is 'x' or 'X', then the string is interpreted
as a hexadecimal integer. If the first character is '1' through '9', then
the string is interpreted as a decimal integer. The letters 'a' through 'z'
(or 'A' through 'Z') are assigned the values 10 through 35; only letters
whose assigned values are less than %@AI@%base%@AE@% are permitted.  %@NL@%
%@NL@%
The %@AB@%strtoul%@AE@% function allows a plus (+) or minus (-) sign prefix; a leading
minus sign indicates that the return value is negated.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strtod%@AE@% and %@AB@%_strtold%@AE@% functions return the value of the floating-point
number, except when the representation would cause an overflow, in which
case it returns ñ%@AB@%HUGE_VAL%@AE@%. The functions return 0 if no conversion could be
performed or an underflow occurred.  %@NL@%
%@NL@%
The %@AB@%strtol%@AE@% function returns the value represented in the string, except when
the representation would cause an overflow, in which case it returns
%@AB@%LONG_MAX%@AE@% or %@AB@%LONG_MIN%@AE@%. The function returns 0 if no conversion could be
performed.  %@NL@%
%@NL@%
The %@AB@%strtoul%@AE@% function returns the converted value, if any. If no conversion
can be performed, the function returns 0. The function returns %@AB@%ULONG_MAX%@AE@% on
overflow. In all four functions, %@AB@%errno%@AE@% is set to %@AB@%ERANGE%@AE@% if overflow or
underflow occurs.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strtod%@AE@%,%@AB@% strtol%@AE@%, %@AB@%_strtold%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%strtoul%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%atof%@AE@%, %@AB@%atol%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRTOD.C: This program uses strtod to convert a string to a
%@AS@%   * double-precision value; strtol to convert a string to long
%@AS@%   * integer values; and strtoul to convert a string to unsigned
%@AS@%   * long-integer values.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void main()
%@AS@%  {
%@AS@%     char   *string, *stopstring;
%@AS@%     double x;
%@AS@%     long   l;
%@AS@%     int    base;
%@AS@%     unsigned long ul;
%@AS@%  
%@AS@%     string = "3.1415926This stopped it";
%@AS@%     x = strtod( string, &stopstring );
%@AS@%     printf( "string = %s\n", string );
%@AS@%     printf("   strtod = %f\n", x );
%@AS@%     printf("   Stopped scan at: %s\n\n", stopstring );
%@AS@%  
%@AS@%     string = "-10110134932This stopped it";
%@AS@%     l = strtol( string, &stopstring, 10 );
%@AS@%     printf( "string = %s\n", string );
%@AS@%     printf("   strtol = %ld\n", l );
%@AS@%     printf("   Stopped scan at: %s\n\n", stopstring );
%@AS@%  
%@AS@%     string = "10110134932";
%@AS@%     printf( "string = %s\n", string );
%@AS@%     /* Convert string using base 2, 4, and 8: */
%@AS@%     for( base = 2; base <= 8; base *= 2 )
%@AS@%     {
%@AS@%        /* Convert the string: */
%@AS@%        ul = strtoul( string, &stopstring, base );
%@AS@%        printf( "   strtol = %ld (base %d)\n", ul, base );
%@AS@%        printf( "   Stopped scan at: %s\n", stopstring );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  string = 3.1415926This stopped it
%@AS@%     strtod = 3.141593
%@AS@%     Stopped scan at: This stopped it
%@AS@%  
%@AS@%  string = -10110134932This stopped it
%@AS@%     strtol = -2147483647
%@AS@%     Stopped scan at: This stopped it
%@AS@%  
%@AS@%  string = 10110134932
%@AS@%     strtol = 45 (base 2)
%@AS@%     Stopped scan at: 34932
%@AS@%     strtol = 4423 (base 4)
%@AS@%     Stopped scan at: 4932
%@AS@%     strtol = 2134108 (base 8)
%@AS@%     Stopped scan at: 932 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strtok@%%@QR:_fstrtok@%%@NL@%
%@2@%%@CR:C6A03381603 @%%@AB@%strtok, _fstrtok%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03381604 @%%@CR:C6A03381605 @% %@CR:C6A03381606 @%%@CR:C6A03381607 @%%@CR:C6A03381608 @% %@CR:C6A03381609 @% %@CR:C6A03381610 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Find the next token in a string.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strtok( char *string1, const char *string2 );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrtok( char _far *string1, const char _far *string2 );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           String containing token(s)

%@AI@%string2%@AE@%                           Set of delimiter characters

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strtok%@AE@% function reads %@AI@%string1%@AE@% as a series of zero or more tokens and
%@AI@%string2%@AE@% as the set of characters serving as delimiters of the tokens in
%@AI@%string1%@AE@%. The tokens in %@AI@%string1%@AE@% may be separated by one or more of the
delimiters from %@AI@%string2%@AE@%.  %@NL@%
%@NL@%
The tokens can be broken out of %@AI@%string1%@AE@% by a series of calls to %@AB@%strtok%@AE@%. In
the first call to %@AB@%strtok%@AE@% for %@AI@%string1%@AE@%, %@AB@%strtok%@AE@% searches for the first token in
%@AI@%string1%@AE@%, skipping leading delimiters. A pointer to the first token is
returned. To read the next token from %@AI@%string1%@AE@%, call %@AB@%strtok%@AE@% with a %@AB@%NULL%@AE@% value
for the %@AI@%string1%@AE@% argument. The %@AB@%NULL%@AE@% %@AI@%string1%@AE@% argument causes %@AB@%strtok%@AE@% to search
for the next token in the previous token string. The set of delimiters may
vary from call to call, so %@AI@%string2%@AE@% can take any value.  %@NL@%
%@NL@%
The %@AB@%_fstrtok%@AE@% function is a model-independent (large-model) form of the
%@AB@%strtok%@AE@% function. The behavior and return value of %@AB@%_fstrtok%@AE@% are identical to
those of the model-dependent function %@AB@%strtok%@AE@%, with the exception that the
arguments and return value are far pointers.  %@NL@%
%@NL@%
Note that calls to these functions will modify %@AI@%string1%@AE@%, since each time
%@AB@%strtok%@AE@% is called it inserts a null character (%@AB@%'\0'%@AE@%) after the token in
%@AI@%string1%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The first time %@AB@%strtok%@AE@% is called, it returns a pointer to the first token in
%@AI@%string1%@AE@%. In later calls with the same token string, %@AB@%strtok%@AE@% returns a pointer
to the next token in the string. A %@AB@%NULL%@AE@% pointer is returned when there are
no more tokens. All tokens are null-terminated.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strtok%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%_fstrtok%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strcspn%@AE@%, %@AB@%strspn%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRTOK.C: In this program, a loop uses strtok to print all the tokens
%@AS@%   * (separated by commas or blanks) in the string named "string".
%@AS@%   */
%@AS@%  
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  char string[] = "A string\tof ,,tokens\nand some  more tokens";
%@AS@%  char seps[]   = " ,\t\n";
%@AS@%  char *token;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%  
%@AS@%     printf( "%s\n\nTokens:\n", string );
%@AS@%  
%@AS@%     /* Establish string and get the first token: */
%@AS@%     token = strtok( string, seps );
%@AS@%     while( token != NULL )
%@AS@%     {
%@AS@%        /* While there are tokens in "string" */
%@AS@%        printf( " %s\n", token );
%@AS@%        /* Get next token: */
%@AS@%        token = strtok( NULL, seps );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  A string        of ,,tokens
%@AS@%  and some  more tokens
%@AS@%  
%@AS@%  Tokens:
%@AS@%   A
%@AS@%   string
%@AS@%   of
%@AS@%   tokens
%@AS@%   and
%@AS@%   some
%@AS@%   more
%@AS@%   tokens %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strupr@%%@QR:_fstrupr@%%@NL@%
%@2@%%@CR:C6A03391611 @%%@AB@%strupr, _fstrupr%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description %@CR:C6A03391612 @%%@CR:C6A03391613 @%%@CR:C6A03391614 @% %@CR:C6A03391615 @%%@CR:C6A03391616 @% %@CR:C6A03391617 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Convert a string to uppercase.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  char *strupr( char *string );%@AE@%%@NL@%
%@NL@%
%@AS@%  char _far * _far _fstrupr( char _far *string );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            String to be capitalized

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
These functions convert any lowercase letters in the string to uppercase.
Other characters are not affected.  %@NL@%
%@NL@%
The %@AB@%_fstrupr%@AE@% function is a model-independent (large-model) form of the
%@AB@%strupr%@AE@% function. The behavior and return value of %@AB@%_fstrupr%@AE@% are identical to
those of the model-dependent function %@AB@%strupr%@AE@%, with the exception that the
argument and return value are far pointers.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
These functions return a pointer to the converted string. There is no error
return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%strlwr%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* STRLWR.C: This program uses strlwr and strupr to create
%@AS@%   * uppercase and lowercase copies of a mixed-case string.
%@AS@%   */
%@AS@%  
%@AS@%  #include <string.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char string[100] = "The String to End All Strings!";
%@AS@%     char *copy1, *copy2;
%@AS@%  
%@AS@%     copy1 = strlwr( strdup( string ) );
%@AS@%     copy2 = strupr( strdup( string ) );
%@AS@%     printf( "Mixed: %s\n", string );
%@AS@%     printf( "Lower: %s\n", copy1 );
%@AS@%     printf( "Upper: %s\n", copy2 );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Mixed: The String to End All Strings!
%@AS@%  Lower: the string to end all strings!
%@AS@%  Upper: THE STRING TO END ALL STRINGS! %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:strxfrm@%%@NL@%
%@2@%%@CR:C6A03401618 @%%@AB@%strxfrm%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description %@CR:C6A03401619 @%%@CR:C6A03401620 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Transforms a string based on locale-specific information.  %@NL@%
%@NL@%
%@AB@%#include <string.h>%@AE@%               Required only for function declarations

%@AS@%  size_t strxfrm( char *string1, const char *string2, size_t count );%@AE@%%@NL@%
%@NL@%
%@AI@%string1%@AE@%                           String to which transformed version of %@AI@%%@AE@%
                                  %@AI@%string2%@AE@% is returned

%@AI@%string2%@AE@%                           String to transform

%@AI@%count%@AE@%                             Maximum number of characters to be 
                                  placed in %@AI@%string1%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strxfrm%@AE@% function transforms the string pointed to by %@AI@%string2%@AE@% into a new
form that is stored in %@AI@%string1%@AE@%. No more than %@AI@%count%@AE@% characters (including the
null character) are transformed and placed into the resulting string.  %@NL@%
%@NL@%
The transformation is made using the information in the locale-specific
%@AB@%LC_COLLATE%@AE@% macro.  %@NL@%
%@NL@%
After the transformation, a call to %@AB@%strcmp%@AE@% with the two transformed strings
will yield identical results to a call to %@AB@%strcoll%@AE@% applied to the original
two strings.  %@NL@%
%@NL@%
The value of the following expression is the size of the array needed to
hold the transformation of the source string:  %@NL@%
%@NL@%
%@AS@%  1 + strxfrm( NULL, string, 0 )%@AE@%%@NL@%
%@NL@%
Currently, the C libraries support the "C" locale only; thus %@AB@%strxfrm%@AE@% is
equivalent to the following:  %@NL@%
%@NL@%
%@AS@%  strncpy( _string1, _string2, _count );
%@AS@%  return( strlen( _string2 ) );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%strxfrm%@AE@% function returns the length of the transformed string, not
counting the terminating null character. If the return value is greater than
or equal to %@AI@%count%@AE@%, the contents of %@AI@%string1%@AE@% are unpredictable.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%localeconv%@AE@%, %@AB@%setlocale%@AE@%, %@AB@%strncmp%@AE@%%@NL@%
%@NL@%
%@NL@%
%@QR:swab@%%@NL@%
%@2@%%@CR:C6A03411621 @%%@AB@%swab%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description %@CR:C6A03411622 @%%@CR:C6A03411623 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Swaps bytes.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AS@%  void swab( char *src, char *dest, int n );%@AE@%%@NL@%
%@NL@%
%@AI@%src%@AE@%                               Data to be copied and swapped

%@AI@%dest%@AE@%                              Storage location for swapped data

%@AI@%n%@AE@%                                 Number of bytes to be copied and swapped

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%swab%@AE@% function copies %@AI@%n%@AE@% bytes from %@AI@%src%@AE@%, swaps each pair of adjacent
bytes, and stores the result at %@AI@%dest%@AE@%. The integer %@AI@%n%@AE@% should be an even number
to allow for swapping. The %@AB@%swab%@AE@% function is typically used to prepare binary
data for transfer to a machine that uses a different byte order.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SWAB.C */
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  char from[] = "BADCFEHGJILKNMPORQTSVUXWZY";
%@AS@%  char to[] =   "..........................";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     printf( "Before:\t%s\n\t%s\n\n", from, to );
%@AS@%     swab( from, to, sizeof( from ) );
%@AS@%     printf( "After:\t%s\n\t%s\n\n", from, to );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Before: BADCFEHGJILKNMPORQTSVUXWZY
%@AS@%          ..........................
%@AS@%  
%@AS@%  After:  BADCFEHGJILKNMPORQTSVUXWZY
%@AS@%          ABCDEFGHIJKLMNOPQRSTUVWXYZ %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:system@%%@NL@%
%@2@%%@CR:C6A03421624 @%%@AB@%system%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description %@CR:C6A03421625 @%%@CR:C6A03421626 @%%@CR:C6A03421627 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Executes a command.  %@NL@%
%@NL@%
%@AB@%#include <process.h>%@AE@%              Required only for function declarations%@CR:C6A03421628 @%

%@AB@%#include <stdlib.h>%@AE@%               Use STDLIB.H for ANSI compatibility

%@AS@%  int system( const char *command );%@AE@%%@NL@%
%@NL@%
%@AI@%command%@AE@%%@AB@%%@AE@%                           Command to be executed

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%system%@AE@% function passes %@AI@%command%@AE@% to the command interpreter, which
executes the string as an operating-system command. The %@AB@%system%@AE@% function
refers to the COMSPEC and PATH environment variables that locate the
command-interpreter file (the file named COMMAND.COM in DOS or CMD.EXE in
OS/2). If %@AI@%command%@AE@% is a pointer to an empty string, the function simply
checks to see whether or not the command interpreter exists.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If %@AI@%command%@AE@% is %@AB@%NULL%@AE@% and the command interpreter is found, the function
returns a nonzero value. If the command interpreter is not found, it returns
the value 0 and sets %@AB@%errno%@AE@% to %@AB@%ENOENT%@AE@%. If %@AI@%command%@AE@% is not %@AB@%NULL%@AE@%, the %@AB@%system%@AE@%
function returns the value 0 if the command interpreter is successfully
started. Under OS/2, the %@AB@%system%@AE@% function returns the exit status from the
command interpreter.  %@NL@%
%@NL@%
A return value of -1 indicates an error, and %@AB@%errno%@AE@% is set to one of the
following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%E2BIG%@AE@%                             In DOS, the argument list exceeds 128 
                                  bytes, or the space required for the 
                                  environment information exceeds 32K. In 
                                  OS/2, the combined argument list and 
                                  space required for environment 
                                  information exceed 32K.

%@AB@%ENOENT%@AE@%                            The command interpreter cannot be found.

%@AB@%ENOEXEC%@AE@%                           The command-interpreter file has an 
                                  invalid format and is not executable.

%@AB@%ENOMEM%@AE@%                            Not enough memory is available to 
                                  execute the command; or the available 
                                  memory has been corrupted; or an invalid
                                  block exists, indicating that the 
                                  process making the call was not 
                                  allocated properly.

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%exec%@AE@% functions, %@AB@%exit%@AE@%, %@AB@%_exit%@AE@%, %@AB@%spawn%@AE@% functions%@AB@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* SYSTEM.C: This program uses system to TYPE its source file. */
%@AS@%  
%@AS@%  #include <process.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     system( "type system.c" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  /* SYSTEM.C: This program uses system to TYPE its source file. */
%@AS@%  
%@AS@%  #include <process.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     system( "type system.c" );
%@AS@%  } %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:tan@%%@NL@%
%@2@%%@CR:C6A03431629 @%%@AB@%tan Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03431630 @%%@CR:C6A03431631 @%%@CR:C6A03431632 @% %@CR:C6A03431633 @%%@CR:C6A03431634 @% %@CR:C6A03431635 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Calculate the tangent (%@AB@%tan%@AE@% and %@AB@%tanl%@AE@%) and hyperbolic tangent (%@AB@%tanh%@AE@% and
%@AB@%tanhl%@AE@%).  %@NL@%
%@NL@%
%@AB@%#include <math.h>%@AE@%  %@NL@%
%@NL@%
%@AS@%  double tan( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  double tanh( double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double tanl( long double x );%@AE@%%@NL@%
%@NL@%
%@AS@%  long double tanhl( long double x );%@AE@%%@NL@%
%@NL@%
%@AI@%x%@AE@%                                 Angle in radians

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%tan%@AE@% functions return the tangent or hyperbolic tangent of their
arguments. The list below describes the differences between the various
tangent functions:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%tan%@AE@%                               Calculates tangent of %@AI@%x%@AE@%

%@AB@%tanh%@AE@%                              Calculates hyperbolic tangent of %@AI@%x%@AE@%

%@AB@%tanl%@AE@%                              Calculates tangent of %@AI@%x%@AE@% (80-bit version)

%@AB@%tanhl%@AE@%                             Calculates hyperbolic tangent of %@AI@%x%@AE@% 
                                  (80-bit version)

The %@AB@%tanl%@AE@% and %@AB@%tanhl%@AE@% functions are the 80-bit counterparts and use an 80-bit,
10-byte coprocessor form of arguments and return values. See the reference
page on the long double functions for more details on this data type.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The%@AB@% tan%@AE@% function returns the tangent of %@AI@%x%@AE@%. If %@AI@%x%@AE@% is large, a partial loss of
significance in the result may occur; in this case, %@AB@%tan%@AE@% sets %@AB@%errno%@AE@% to %@AB@%ERANGE%@AE@%
and generates a%@AB@% PLOSS%@AE@% error. If %@AI@%x%@AE@% is so large that significance is totally
lost, %@AB@%tan%@AE@% prints a %@AB@%TLOSS%@AE@% error message to %@AB@%stderr%@AE@%, sets %@AB@%errno%@AE@% to %@AB@%ERANGE%@AE@%, and
returns 0.  %@NL@%
%@NL@%
There is no error return for %@AB@%tanh%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%tan%@AE@%, %@AB@%tanh%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%tanl%@AE@%, %@AB@%tanhl%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%acos%@AE@% functions, %@AB@%asin%@AE@% functions, %@AB@%atan%@AE@% functions, %@AB@%cos%@AE@% functions, %@AB@%sin%@AE@% functions
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* TAN.C:  This program displays the tangent of pi / 4 and the hyperbolic
%@AS@%   * tangent of the result.
%@AS@%   */
%@AS@%  
%@AS@%  #include <math.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     double pi = 3.1415926535;
%@AS@%     double x, y;
%@AS@%  
%@AS@%     x = tan( pi / 4 );
%@AS@%     y = tanh( x );
%@AS@%     printf( "tan( %f ) = %f\n", x, y );
%@AS@%     printf( "tanh( %f ) = %f\n", y, x );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  tan( 1.000000 ) = 0.761594
%@AS@%  tanh( 0.761594 ) = 1.000000 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:tell@%%@NL@%
%@2@%%@CR:C6A03441636 @%%@AB@%tell%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03441637 @%%@CR:C6A03441638 @% %@CR:C6A03441639 @%%@CR:C6A03441640 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the position of the file pointer.  %@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  long tell( int handle );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Handle referring to open file

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%tell%@AE@% function gets the current position of the file pointer (if any)
associated with the %@AI@%handle%@AE@% argument. The position is expressed as the number
of bytes from the beginning of the file.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
A return value of -1L indicates an error, and %@AB@%errno%@AE@% is set to%@AB@% EBADF%@AE@% to
indicate an invalid file-handle argument. On devices incapable of seeking,
the return value is undefined.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%ftell%@AE@%, %@AB@%lseek%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* TELL.C:  This program uses tell to tell the file pointer position
%@AS@%   * after a file read.
%@AS@%   */
%@AS@%  
%@AS@%  #include <io.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <fcntl.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int  fh;
%@AS@%     long position;
%@AS@%     char buffer[500];
%@AS@%  
%@AS@%     if( (fh = open( "tell.c", O_RDONLY )) != -1 )
%@AS@%     {
%@AS@%        if( read( fh, buffer, 500 ) > 0 )
%@AS@%           printf( "Current file position is: %d\n", tell( fh ) );%@AE@%%@NL@%
%@NL@%
%@AS@%  close( fh );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Current file position is: 425 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:tempnam@%%@QR:tmpnam@%%@NL@%
%@2@%%@CR:C6A03451641 @%%@AB@%tempnam, tmpnam%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03451642 @%%@CR:C6A03451643 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Create temporary file names.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  char *tempnam( char *dir, char *prefix );%@AE@%%@NL@%
%@NL@%
%@AS@%  char *tmpnam( char *string );%@AE@%%@NL@%
%@NL@%
%@AI@%string%@AE@%                            Pointer to temporary name

%@AI@%dir%@AE@%                               Target directory to be used if TMP not 
                                  defined

%@AI@%prefix%@AE@%                            File-name prefix

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%tmpnam%@AE@% function generates a temporary file name that can be used to open
a temporary file without overwriting an existing file. This name is stored
in %@AI@%string%@AE@%. If %@AI@%string%@AE@% is%@AB@% NULL%@AE@%, then %@AB@%tmpnam%@AE@% leaves the result in an internal
static buffer. Thus, any subsequent calls destroy this value. If %@AI@%string%@AE@% is
not %@AB@%NULL%@AE@%, it is assumed to point to an array of at least %@AB@%L%@AE@%_tmpnam bytes (the
value of %@AB@%L_tmpnam%@AE@% is defined in STDIO.H). The function will generate unique
file names for up to %@AB@%TMP_MAX%@AE@% calls.  %@NL@%
%@NL@%
The character string that %@AB@%tmpnam%@AE@% creates consists of the path prefix,
defined by the entry %@AB@%P_tmpdir%@AE@% in the file STDIO.H, followed by a sequence
consisting of the digit characters '0' through '9'; the numerical value of
this string can range from 1 to 65,535. Changing the definitions of %@AB@%L_tmpnam%@AE@%
or %@AB@%P_tmpdir%@AE@% in STDIO.H does not change the operation of %@AB@%tmpnam%@AE@%.  %@NL@%
%@NL@%
The %@AB@%tempnam%@AE@% function allows the program to create a temporary file name for
use in another directory. This file name will be different from that of any
existing file. The %@AI@%prefix%@AE@% argument is the prefix to the file name. The
%@AB@%tempnam%@AE@% function uses %@AB@%malloc%@AE@% to allocate space for the file name; the
program is responsible for freeing this space when it is no longer needed.
The %@AB@%tempnam%@AE@% function looks for the file with the given name in the following
directories, listed in order of precedence:  %@NL@%
%@NL@%
%@AB@%Directory Used%@AE@%                    %@AB@%Conditions%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
Directory specified by TMP        TMP environment variable is set, and 
                                  directory specified by TMP exists.

%@AI@%dir%@AE@% argument to %@AB@%tempnam%@AE@%           TMP environment variable is not set, or 
                                  directory specified by TMP does not 
                                  exist.

%@AB@%P_tmpdir%@AE@% in STDIO.H               The %@AI@%dir%@AE@% argument is %@AB@%NULL%@AE@%, or %@AI@%dir%@AE@%is name 
                                  of nonexistent directory.

Current working directory         %@AB@%P_tmpdir%@AE@% does not exist.

If the search through the locations listed above fails, %@AB@%tempnam%@AE@% returns the
value %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%tmpnam%@AE@% and %@AB@%tempnam%@AE@% functions both return a pointer to the name
generated, unless it is impossible to create this name or the name is not
unique. If the name cannot be created or if a file with that name already
exists, %@AB@%tmpnam%@AE@% and %@AB@%tempnam%@AE@% return the value %@AB@%NULL%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%tmpnam%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%tempnam%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%tmpfile%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* TEMPNAM.C: This program uses tmpnam to create a unique file name in
%@AS@%   * the current working directory, then uses tempnam to create a unique
%@AS@%   * file name with a prefix of stq.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char *name1, *name2;
%@AS@%  
%@AS@%     /* Create a temporary file name for the current working directory: */
%@AS@%     if( ( name1 = tmpnam( NULL ) ) != NULL )
%@AS@%        printf( "%s is safe to use as a temporary file.\n", name1 );
%@AS@%     else
%@AS@%        printf( "Cannot create a unique file name\n" );
%@AS@%  
%@AS@%     /* Create a temporary file name in temporary directory with the
%@AS@%      * prefix "stq". The actual destination directory may vary depending
%@AS@%      * on the state of the TMP environment variable and the global variable
%@AS@%      * P_tmpdir.
%@AS@%      */
%@AS@%     if( ( name2 = tempnam( "c:\\tmp", "stq" ) ) != NULL )
%@AS@%        printf( "%s is safe to use as a temporary file.\n", name2 );
%@AS@%     else
%@AS@%        printf( "Cannot create a unique file name\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  \2 is safe to use as a temporary file.
%@AS@%  C:\TMP\stq2 is safe to use as a temporary file. %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:time@%%@NL@%
%@2@%%@CR:C6A03461644 @%%@AB@%time%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03461645 @%%@CR:C6A03461646 @%%@CR:C6A03461647 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Gets the system time.  %@NL@%
%@NL@%
%@AB@%#include <time.h>%@AE@%                 Required only for function declarations

%@AS@%  time_t time( time_t *timer );%@AE@%%@NL@%
%@NL@%
%@AI@%timer%@AE@%                             Storage location for time

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%time%@AE@% function returns the number of seconds elapsed since 00:00:00
Greenwich mean time (GMT), January 1, 1970, according to the system clock.
The system time is adjusted according to the %@AB@%timezone%@AE@% system variable, which
is explained in the %@AB@%tzset%@AE@% reference section.  %@NL@%
%@NL@%
The return value is stored in the location given by %@AI@%timer%@AE@%. This parameter
may be %@AB@%NULL%@AE@%, in which case the return value is not stored.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%time%@AE@% function returns the time in elapsed seconds. There is no error
return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asctime%@AE@%, %@AB@%ftime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%tzset%@AE@%, %@AB@%utime%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* CTIME.C: This program gets the current time in time_t form, then uses
%@AS@%   * ctime to display the time in string form.
%@AS@%   */
%@AS@%  
%@AS@%  #include <time.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     time_t ltime;
%@AS@%  
%@AS@%     time( &ltime );
%@AS@%     printf( "The time is %s\n", ctime( &ltime ) );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  The time is Thu Jun 15 16:08:18 1989 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:tmpfile@%%@NL@%
%@2@%%@CR:C6A03471648 @%%@AB@%tmpfile%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Creates a temporary file.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  FILE *tmpfile( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%tmpfile%@AE@% function creates a temporary file and returns a pointer to that
stream. If the file cannot be opened, %@AB@%tmpfile%@AE@% returns a %@AB@%NULL%@AE@% pointer.  %@NL@%
%@NL@%
This temporary file is automatically deleted when the file is closed, when
the program terminates normally, or when %@AB@%rmtmp%@AE@% is called, assuming that the
current working directory does not change. The temporary file is opened in
%@AB@%w+b%@AE@% (binary read/write) mode.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, the %@AB@%tmpfile%@AE@% function returns a stream pointer. Otherwise, it
returns a %@AB@%NULL%@AE@% pointer.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%rmtmp%@AE@%, %@AB@%tempnam%@AE@%, %@AB@%tmpnam%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* TMPFILE.C: This program uses tmpfile to create a temporary file,
%@AS@%   * then deletes this file with rmtmp.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     FILE *stream;
%@AS@%     char tempstring[] = "String to be written";
%@AS@%     int  i;
%@AS@%  
%@AS@%     /* Create temporary files. */
%@AS@%     for( i = 1; i <= 10; i++ )
%@AS@%     {
%@AS@%        if( (stream = tmpfile()) == NULL )
%@AS@%           perror( "Could not open new temporary file\n" );
%@AS@%        else
%@AS@%           printf( "Temporary file %d was created\n", i );
%@AS@%     }
%@AS@%  
%@AS@%     /* Remove temporary files. */
%@AS@%     printf( "%d temporary files deleted\n", rmtmp() );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Temporary file 1 was created
%@AS@%  Temporary file 2 was created
%@AS@%  Temporary file 3 was created
%@AS@%  Temporary file 4 was created
%@AS@%  Temporary file 5 was created
%@AS@%  Temporary file 6 was created
%@AS@%  Temporary file 7 was created
%@AS@%  Temporary file 8 was created
%@AS@%  Temporary file 9 was created
%@AS@%  Temporary file 10 was created
%@AS@%  10 temporary files deleted%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:toascii@%%@QR:tolower@%%@QR:toupper@%%@NL@%
%@2@%%@CR:C6A03481649 @%%@AB@%toascii, tolower, toupper Functions%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03481650 @%%@CR:C6A03481651 @%%@CR:C6A03481652 @% %@CR:C6A03481653 @% %@CR:C6A03481654 @% %@CR:C6A03481655 @% %@CR:C6A03481656 @% %@CR:C6A03481657 @% %@CR:C6A03481658 @% %@CR:C6A03481659 @% %@CR:C6A03481660 @%%@AE@%%@EH@%
%@NL@%
%@NL@%
Convert characters.  %@NL@%
%@NL@%
%@AS@%  #include <ctype.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int toascii( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int tolower( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _tolower( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int toupper( int c );%@AE@%%@NL@%
%@NL@%
%@AS@%  int _toupper( int c );%@AE@%%@NL@%
%@NL@%
%@AI@%c%@AE@%                                 Character to be converted

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%toascii%@AE@%, %@AB@%tolower%@AE@%, %@AB@%_tolower%@AE@%, %@AB@%toupper%@AE@%, and %@AB@%_toupper%@AE@% routines convert a
single character, as described below:  %@NL@%
%@NL@%
%@AB@%Function%@AE@%                          %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%toascii%@AE@%                           Converts %@AI@%c%@AE@% to ASCII character

%@AB@%tolower%@AE@%                           Converts %@AI@%c%@AE@% to lowercase if appropriate

%@AB@%_tolower%@AE@%                          Converts %@AI@%c%@AE@% to lowercase

%@AB@%toupper%@AE@%                           Converts %@AI@%c%@AE@% to uppercase if appropriate

%@AB@%_toupper%@AE@%                          Converts %@AI@%c%@AE@% to uppercase

The %@AB@%toascii%@AE@% routine sets all but the low-order 7 bits of %@AI@%c%@AE@% to 0, so that the
converted value represents a character in the ASCII character set. If %@AI@%c%@AE@%
already represents an ASCII character, %@AI@%c%@AE@% is unchanged.  %@NL@%
%@NL@%
The %@AB@%tolower%@AE@% and %@AB@%_tolower%@AE@% routines convert %@AI@%c%@AE@% to lowercase if %@AI@%c%@AE@% represents an
uppercase letter. Otherwise, %@AI@%c%@AE@% is unchanged. The %@AB@%_tolower%@AE@% routine is a
version of %@AB@%tolower%@AE@% to be used only when %@AI@%c%@AE@% is known to be uppercase. The
result of %@AB@%_tolower%@AE@% is undefined if %@AI@%c%@AE@% is not an uppercase letter.  %@NL@%
%@NL@%
The %@AB@%toupper%@AE@% and %@AB@%_toupper%@AE@% routines convert %@AI@%c%@AE@% to uppercase if %@AI@%c%@AE@% represents a
lowercase letter. Otherwise, %@AI@%c%@AE@% is unchanged. The %@AB@%_toupper%@AE@% routine is a
version of %@AB@%toupper%@AE@% to be used only when %@AI@%c%@AE@% is known to be lowercase. The
result of %@AB@%_toupper%@AE@% is undefined if %@AI@%c%@AE@% is not a lowercase letter.  %@NL@%
%@NL@%
Note that these routines are implemented both as functions and as macros. To
conform with the ANSI specification, the %@AB@%tolower%@AE@% and %@AB@%toupper%@AE@% routines are
also implemented as functions. The function versions can be used by removing
the macro definitions through%@AB@% #undef%@AE@% directives or by not including CTYPE.H.
Function declarations of %@AB@%tolower%@AE@% and %@AB@%toupper%@AE@% are given in STDLIB.H.  %@NL@%
%@NL@%
If the -Za compile option is used, the macro form of %@AB@%toupper%@AE@% or %@AB@%tolower%@AE@% is
not used because it evaluates its argument more than once. Since the
arguments are evaluated more than once, arguments with side effects would
produce potentially bad results.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%toascii%@AE@%, %@AB@%tolower%@AE@%, %@AB@%_tolower%@AE@%, %@AB@%toupper%@AE@%, and %@AB@%_toupper%@AE@% routines return the
converted character %@AI@%c%@AE@%. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%toascii%@AE@%,%@AB@% _tolower%@AE@%,%@AB@% _toupper%@AE@%  %@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@AB@%tolower%@AE@%, %@AB@%toupper%@AE@%  %@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%is%@AE@% functions  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* TOUPPER.C: This program uses toupper and tolower to analyze all
%@AS@%   * characters between 0x0 and 0x7F. It also applies _toupper and _tolower
%@AS@%   * to any code in this range for which these functions make sense.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <ctype.h>
%@AS@%  #include <string.h>
%@AS@%  
%@AS@%  char msg[] = "Some of THESE letters are Capitals\r\n";
%@AS@%  char *p;
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     cputs( msg );%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Reverse case of message. */
%@AS@%     for( p = msg; p < msg + strlen( msg ); p++ )
%@AS@%     {
%@AS@%        if( islower( *p ) )
%@AS@%           putch( _toupper( *p ) );
%@AS@%        else if( isupper( *p ) )
%@AS@%           putch( _tolower( *p ) );
%@AS@%        else
%@AS@%           putch( *p );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Some of THESE letters are Capitals
%@AS@%  sOME OF these LETTERS ARE cAPITALS %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:tzset@%%@NL@%
%@2@%%@CR:C6A03491661 @%%@AB@%tzset%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03491662 @%%@CR:C6A03491663 @%%@CR:C6A03491664 @% %@CR:C6A03491665 @%%@CR:C6A03491666 @% %@CR:C6A03491667 @%%@CR:C6A03491668 @%%@CR:C6A03491669 @% %@CR:C6A03491670 @%%@CR:C6A03491671 @% %@CR:C6A03491672 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets time environment variables.  %@NL@%
%@NL@%
%@AB@%#include <time.h>%@AE@%                 Required only for function declarations

%@AB@%void tzset( void );%@AE@%               

%@AB@%int daylight;%@AE@%                     Global variables set by function
%@AB@%long timezone;%@AE@%%@AB@%%@AE@%                    
%@AB@%char *tzname%@AE@%[2]                   

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%tzset%@AE@% function uses the current setting of the environment variable TZ
to assign values to three global variables: %@AB@%daylight%@AE@%, %@AB@%timezone%@AE@%, and %@AB@%tzname%@AE@%.
These variables are used by the %@AB@%ftime%@AE@% and %@AB@%localtime%@AE@% functions to make
corrections from Greenwich mean time (GMT) to local time, and by %@AB@%time%@AE@% to
compute GMT from system time.  %@NL@%
%@NL@%
The value of the environment variable TZ must be a three-letter time-zone
name, such as PST, followed by an optionally signed number giving the
difference in hours between GMT and local time. The number may be followed
by a three-letter daylight-saving-time (DST) zone, such as PDT. For example,
"PST8PDT" represents a valid TZ value for the Pacific time zone. If DST is
never in effect, as is the case in certain states and localities, TZ should
be set without a DST zone.  %@NL@%
%@NL@%
If the TZ value is not currently set, the default is PST8PDT, which
corresponds to the Pacific time zone.  %@NL@%
%@NL@%
Based on the TZ environment variable value, the following values are
assigned to the variables %@AB@%daylight%@AE@%, %@AB@%timezone%@AE@%, and %@AB@%tzname%@AE@% when %@AB@%tzset%@AE@% is
called:  %@NL@%
%@NL@%
%@AB@%Variable%@AE@%                          %@AB@%Value%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%daylight%@AE@%                          Nonzero value if a daylight-saving-time 
                                  zone is specified in the TZ setting; 
                                  otherwise, 0

%@AB@%timezone%@AE@%                          Difference in seconds between GMT and 
                                  local time

%@AB@%tzname%@AE@%[0]                         String value of the three-letter 
                                  time-zone name from the TZ setting

%@AB@%tzname%@AE@%[1]                         String value of the daylight-saving-time
                                  zone, or an empty string if the 
                                  daylight-saving-time zone is omitted 
                                  from the TZ setting

The default for %@AB@%daylight%@AE@% is 1; for %@AB@%timezone%@AE@%, 28,800; for %@AB@%tzname%@AE@%[0], PST; and
for %@AB@%tzname%@AE@%[1], PDT. This corresponds to "PST8PDT."  %@NL@%
%@NL@%
If the DST zone is omitted from the TZ settings, the %@AB@%daylight%@AE@% variable will
be 0 and the %@AB@%ftime%@AE@%, %@AB@%gmtime%@AE@%, and %@AB@%localtime%@AE@% functions will return 0 for their
DST flags.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asctime%@AE@%, %@AB@%ftime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%time%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* TZSET.C: This program first sets up the time zone by placing the
%@AS@%  variable
%@AS@%   * named TZ=EST5 in the environment table. It then uses tzset to set the
%@AS@%   * global variables named daylight, timezone, and tzname.
%@AS@%   */
%@AS@%  
%@AS@%  #include <time.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%  
%@AS@%     if( putenv( "TZ=EST5EDT" ) == -1 )
%@AS@%     {
%@AS@%        printf( "Unable to set TZ\n" );
%@AS@%        exit( 1 );
%@AS@%     }
%@AS@%     else
%@AS@%     {
%@AS@%        tzset();
%@AS@%        printf( "daylight = %d\n", daylight );
%@AS@%        printf( "timezone = %ld\n", timezone );
%@AS@%        printf( "tzname[0] = %s\n", tzname[0] );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  daylight = 1
%@AS@%  timezone = 18000
%@AS@%  tzname[0] = EST%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ultoa@%%@NL@%
%@2@%%@CR:C6A03501673 @%%@AB@%ultoa%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03501674 @%%@CR:C6A03501675 @% %@CR:C6A03501676 @%%@CR:C6A03501677 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Converts an unsigned long integer to a string.  %@NL@%
%@NL@%
%@AB@%#include <stdlib.h>%@AE@%               Required only for function declarations

%@AS@%  char *ultoa( unsigned long value, char *string, int radix );%@AE@%%@NL@%
%@NL@%
%@AI@%value%@AE@%                             Number to be converted

%@AI@%string%@AE@%                            String result

%@AI@%radix%@AE@%                             Base of %@AI@%value%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ultoa%@AE@% function converts %@AI@%value%@AE@% to a null-terminated character string and
stores the result (up to 33 bytes) in %@AI@%string%@AE@%. No overflow checking is
performed. The %@AI@%radix%@AE@% argument specifies the base of %@AI@%value%@AE@%; it must be in the
range 2-36.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ultoa%@AE@% function returns a pointer to %@AI@%string%@AE@%. There is no error return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%itoa%@AE@%, %@AB@%ltoa%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* ITOA.C: This program converts integers of various sizes to strings
%@AS@%   * in various radixes.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[20];
%@AS@%     int  i = 3445;
%@AS@%     long l = -344115L;
%@AS@%     unsigned long ul = 1234567890UL;
%@AS@%  
%@AS@%     itoa( i, buffer, 10 );
%@AS@%     printf( "String of integer %d (radix 10): %s\n", i, buffer );
%@AS@%     itoa( i, buffer, 16 );
%@AS@%     printf( "String of integer %d (radix 16): 0x%s\n", i, buffer );
%@AS@%     itoa( i, buffer, 2  );
%@AS@%     printf( "String of integer %d (radix 2): %s\n", i, buffer );
%@AS@%  
%@AS@%     ltoa( l, buffer, 16 );
%@AS@%     printf( "String of long int %ld (radix 16): 0x%s\n", l, buffer );
%@AS@%  
%@AS@%     ultoa( ul, buffer, 16 );
%@AS@%     printf( "String of unsigned long %lu (radix 16): 0x%s\n", ul, buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  String of integer 3445 (radix 10): 3445
%@AS@%  String of integer 3445 (radix 16): 0xd75
%@AS@%  String of integer 3445 (radix 2): 110101110101
%@AS@%  String of long int -344115 (radix 16): 0xfffabfcd
%@AS@%  String of unsigned long 1234567890 (radix 16): 0x499602d2 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:umask@%%@NL@%
%@2@%%@CR:C6A03511678 @%%@AB@%umask%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03511679 @%%@CR:C6A03511680 @%%@CR:C6A03511681 @% %@CR:C6A03511682 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the default file-permission mask.  %@NL@%
%@NL@%
%@AB@%#include <sys\types.h>%@AE@%            

%@AB@%#include <sys\stat.h>%@AE@%             

%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  int umask( int pmode );%@AE@%%@NL@%
%@NL@%
%@AI@%pmode%@AE@%                             Default permission setting

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%umask%@AE@% function sets the file-permission mask of the current process to
the mode specified by %@AI@%pmode%@AE@%. The file-permission mask is used to modify the
permission setting of new files created by %@AB@%creat%@AE@%, %@AB@%open%@AE@%, or %@AB@%sopen%@AE@%. If a bit
in the mask is 1, the corresponding bit in the file's requested permission
value is set to 0 (disallowed). If a bit in the mask is 0, the corresponding
bit is left unchanged. The permission setting for a new file is not set
until the file is closed for the first time.  %@NL@%
%@NL@%
The argument %@AI@%pmode%@AE@% is a constant expression containing one or both of the
manifest constants %@AB@%S_IREAD%@AE@% and%@AB@% S_IWRITE%@AE@%, defined in SYS\STAT.H. When both
constants are given, they are joined with the bitwise-OR operator ( %@AS@%|%@AE@% ). The
meaning of the %@AS@% %@AE@%pmode argument is as follows:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%S_IREAD%@AE@%                           Reading not allowed (file is write-only)

%@AB@%S_IWRITE%@AE@%                          Writing not allowed (file is read-only)

For example, if the write bit is set in the mask, any new files will be
read-only.  %@NL@%
%@NL@%
Note that under DOS and OS/2, all files are readableÄit is not possible to
give write-only permission. Therefore, setting the read bit with %@AB@%umask%@AE@% has
no effect on the file's modes.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%umask%@AE@% function returns the previous value of %@AI@%pmode%@AE@%. There is no error
return.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%chmod%@AE@%, %@AB@%creat%@AE@%, %@AB@%mkdir%@AE@%, %@AB@%open%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* UMASK.C: This program uses umask to set the file-permission mask so
%@AS@%   * that all future files will be created as read-only files. It also
%@AS@%   * displays the old mask.
%@AS@%   */
%@AS@%  
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  #include <io.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int oldmask;
%@AS@%  
%@AS@%     /* Create read-only files: */
%@AS@%     oldmask = umask( S_IWRITE );
%@AS@%     printf( "Oldmask = 0x%.4x\n", oldmask );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Oldmask = 0x0000 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ungetc@%%@NL@%
%@2@%%@CR:C6A03521683 @%%@AB@%ungetc%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03521684 @%%@CR:C6A03521685 @% %@CR:C6A03521686 @%%@CR:C6A03521687 @% %@CR:C6A03521688 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Pushes a character back onto the stream.  %@NL@%
%@NL@%
%@AS@%  #include <stdio.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int ungetc( int c, FILE *stream );%@AE@%%@NL@%
%@NL@%
%@AI@%c%@AE@%                                 Character to be pushed

%@AI@%stream%@AE@%                            Pointer to%@AB@% FILE structure%@AE@%

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ungetc%@AE@% function pushes the character %@AI@%c%@AE@% back onto %@AI@%stream%@AE@% and clears the
end-of-file indicator. The stream must be open for reading. A subsequent
read operation on the stream starts with %@AI@%c%@AE@%. An attempt to push %@AB@%EOF%@AE@% onto the
stream using %@AB@%ungetc%@AE@% is ignored. The %@AB@% ungetc%@AE@% function returns an error value
if nothing has yet been read from %@AI@%stream%@AE@% or if %@AI@%c%@AE@% cannot be pushed back.  %@NL@%
%@NL@%
Characters placed on the stream by %@AB@%ungetc%@AE@% may be erased if %@AB@%fflush%@AE@%, %@AB@%fseek%@AE@%,
%@AB@%fsetpos%@AE@%, or %@AB@%rewind%@AE@% is called before the character is read from the stream.
The file-position indicator will have the same value it had before the
characters were pushed back. On a successful %@AB@%ungetc%@AE@% call against a text
stream, the file-position indicator is unspecified until all the pushed-back
characters are read or discarded. On each successful %@AB@%ungetc%@AE@% call against a
binary stream, the file-position indicator is stepped down; if its value was
0 before a call, the value is undefined after the call.  %@NL@%
%@NL@%
Results are unpredictable if the %@AB@%ungetc%@AE@% function is called twice without a
read operation between the two calls. After a call to the %@AB@%fscanf%@AE@% function, a
call to %@AB@%ungetc%@AE@% may fail unless another read operation (such as the %@AB@%getc%@AE@%
function) has been performed. This is because the %@AB@%fscanf%@AE@% function itself
calls the %@AB@%ungetc%@AE@% function.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ungetc%@AE@% function returns the character argument %@AI@%c%@AE@%. The return value %@AB@%EOF%@AE@%
indicates a failure to push back the specified character.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%getc%@AE@%, %@AB@%getchar%@AE@%, %@AB@%putc%@AE@%, %@AB@%putchar%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* UNGETC.C: This program first converts a character representation of an
%@AS@%   * unsigned integer to an integer. If the program encounters a character
%@AS@%   * that is not a digit, the program uses ungetc to replace it in the
%@AS@%stream.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <stdio.h>
%@AS@%  #include <ctype.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int ch;
%@AS@%     int result = 0;
%@AS@%  
%@AS@%     printf( "Enter an integer: " );
%@AS@%  
%@AS@%     /* Read in and convert number: */
%@AS@%     while( ((ch = getchar()) != EOF) && isdigit( ch ) )
%@AS@%        result = result * 10 + ch - '0';       /* Use digit. */
%@AS@%     if( ch != EOF )
%@AS@%        ungetc( ch, stdin );                   /* Put non-digit back. */
%@AS@%     printf( "Number = %d\nNext character in stream = '%c'\n",
%@AS@%             result, getchar() );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Enter an integer: 521a
%@AS@%  Number = 521
%@AS@%  Next character in stream = 'a' %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:ungetch@%%@NL@%
%@2@%%@CR:C6A03531689 @%%@AB@%ungetch%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03531690 @%%@CR:C6A03531691 @% %@CR:C6A03531692 @%%@CR:C6A03531693 @% %@CR:C6A03531694 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Pushes back the last character read from the console.  %@NL@%
%@NL@%
%@AB@%#include <conio.h>%@AE@%                Required only for function declarations

%@AS@%  int ungetch( int c );%@AE@%%@NL@%
%@NL@%
%@AI@%c%@AE@%                                 Character to be pushed

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ungetch%@AE@% function pushes the character %@AI@%c%@AE@% back to the console, causing %@AI@%c%@AE@%
to be the next character read by %@AB@%getch%@AE@% or %@AB@%getche%@AE@%. The %@AB@%ungetch%@AE@% function fails
if it is called more than once before the next read. The %@AI@%c%@AE@% argument may not
be %@AB@%EOF%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%ungetch%@AE@% function returns the character %@AI@%c%@AE@% if it is successful. A return
value of %@AB@%EOF%@AE@% indicates an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cscanf%@AE@%, %@AB@%getch%@AE@%, %@AB@%getche%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* UNGETCH.C: In this program, a white-space delimited token is read
%@AS@%   * from the keyboard. When the program encounters a delimiter,
%@AS@%   * it uses ungetch to replace the character in the keyboard buffer.
%@AS@%   */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <ctype.h>
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     char buffer[100];
%@AS@%     int count = 0;
%@AS@%     int ch;%@AE@%%@NL@%
%@NL@%
%@AS@%  ch = getche();
%@AS@%     while( isspace( ch ) )      /* Skip preceding white space. */
%@AS@%        ch = getche();
%@AS@%     while( count < 99 )         /* Gather token. */
%@AS@%     {
%@AS@%        if( isspace( ch ) )      /* End of token. */
%@AS@%           break;
%@AS@%        buffer[count++] = ch;
%@AS@%        ch = getche();
%@AS@%     }
%@AS@%     ungetch( ch );              /* Put back delimiter. */
%@AS@%     buffer[count] = '\0';       /* Null terminate the token. */
%@AS@%     printf( "\ntoken = %s\n", buffer );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  White
%@AS@%  token = White %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:unlink@%%@NL@%
%@2@%%@CR:C6A03541695 @%%@AB@%unlink%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03541696 @%%@CR:C6A03541697 @%%@CR:C6A03541698 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Deletes a file.  %@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AB@%#include <stdio.h>%@AE@%                Use either IO.H or STDIO.H

%@AS@%  int unlink( const char *filename );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          Name of file to remove

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%unlink%@AE@% function deletes the file specified by %@AI@%filename%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If successful, %@AB@%unlink%@AE@% returns 0; otherwise, it returns -1 and sets %@AB@%errno%@AE@% to
one of the following constants:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Path name specifies a read-only file

%@AB@%ENOENT%@AE@%                            File or path name not found, or path 
                                  name specified a directory

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%close%@AE@%, %@AB@%remove%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* UNLINK.C: This program uses unlink to delete UNLINK.OBJ. */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     if( unlink( "unlink.obj" ) == -1 )
%@AS@%        perror( "Could not delete 'UNLINK.OBJ'" );
%@AS@%     else
%@AS@%        printf( "Deleted 'UNLINK.OBJ'\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Deleted 'UNLINK.OBJ' %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_unregisterfonts@%%@NL@%
%@2@%%@CR:C6A03551699 @%%@AB@%_unregisterfonts%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03551700 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Frees memory used by fonts.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  void _far _unregisterfonts( void );%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_unregisterfonts%@AE@% function frees memory previously allocated and used by
the %@AB@%_registerfonts%@AE@% function. The %@AB@%_unregisterfonts%@AE@% function removes the
header information for all fonts and unloads the currently selected font
data from memory.  %@NL@%
%@NL@%
Any attempt to use the %@AB@%_setfont%@AE@% or %@AB@%_outgtext%@AE@% function after calling
%@AB@%_unregisterfonts%@AE@% results in an error.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
None.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS   OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@% _getfontinfo%@AE@%, %@AB@% _getgtextextent%@AE@%,%@AB@%  _outgtext%@AE@%, %@AB@% _registerfonts%@AE@%, %@AB@% _setfont%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
See the example for %@AB@%_outgtext%@AE@%.  %@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:utime@%%@NL@%
%@2@%%@CR:C6A03561701 @%%@AB@%utime%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03561702 @%%@CR:C6A03561703 @%%@CR:C6A03561704 @% %@CR:C6A03561705 @%%@CR:C6A03561706 @%%@CR:C6A03561707 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Sets the file modification time.  %@NL@%
%@NL@%
%@AS@%  #include <sys\types.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <sys\utime.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int utime( char *filename, struct utimbuf *times );%@AE@%%@NL@%
%@NL@%
%@AI@%filename%@AE@%                          File name

%@AI@%times%@AE@%                             Pointer to stored time values

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%utime%@AE@% function sets the modification time for the file specified by
%@AI@%filename%@AE@%. The process must have write access to the file; otherwise, the
time cannot be changed.  %@NL@%
%@NL@%
Although the %@AB@%utimbuf%@AE@% structure contains a field for access time, only the
modification time is set under DOS and OS/2 . If %@AI@%times%@AE@% is a %@AB@%NULL%@AE@% pointer,
the modification time is set to the current time. Otherwise, %@AI@%times%@AE@% must
point to a structure of type %@AB@%utimbuf%@AE@%, defined in SYS\UTIME.H. The
modification time is set from the %@AB@%modtime%@AE@% field in this structure.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%utime%@AE@% function returns the value 0 if the file-modification time was
changed. A return value of -1 indicates an error, and %@AB@%errno%@AE@% is set to one of
the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EACCES%@AE@%                            Path name specifies directory or 
                                  read-only file

%@AB@%EINVAL%@AE@%                            Invalid argument; the %@AI@%times%@AE@% argument is 
                                  invalid

%@AB@%EMFILE%@AE@%                            Too many open files (the file must be 
                                  opened to change its modification time)

%@AB@%ENOENT%@AE@%                            File or path name not found

%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%asctime%@AE@%, %@AB@%ctime%@AE@%, %@AB@%fstat%@AE@%, %@AB@%ftime%@AE@%, %@AB@%gmtime%@AE@%, %@AB@%localtime%@AE@%, %@AB@%stat%@AE@%, %@AB@%time%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* UTIME.C: This program uses utime to set the file-modification time to
%@AS@%   * the current time.
%@AS@%   */%@AE@%%@NL@%
%@NL@%
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\utime.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Show file time before and after. */
%@AS@%     system( "dir utime.c" );
%@AS@%     if( utime( "utime.c", NULL ) == -1 )
%@AS@%        perror( "utime failed\n" );
%@AS@%     else
%@AS@%        printf( "File time modified\n" );
%@AS@%     system( "dir utime.c" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  
%@AS@%   The volume label in drive C is OS2.
%@AS@%   Directory of C:\LIBREF
%@AS@%  
%@AS@%  UTIME    C        397   6-20-89   2:11p
%@AS@%       1 File(s)   12974080 bytes free
%@AS@%  File time modified
%@AS@%  
%@AS@%   The volume label in drive C is OS2.
%@AS@%   Directory of C:\LIBREF
%@AS@%  
%@AS@%  UTIME    C        397   6-20-89   2:12p
%@AS@%       1 File(s)   12974080 bytes free %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:va_arg@%%@QR:va_end@%%@QR:va_start@%%@QR:va_start @%%@NL@%
%@2@%%@CR:C6A03571708 @%%@AB@%va_arg, va_end, va_start%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Access variable-argument lists.  %@NL@%
%@NL@%
%@AB@%#include <stdarg.h>%@AE@%               Required for ANSI compatibility

%@AB@%#include <varargs.h>%@AE@%              Required for UNIX V compatibility

%@AB@%#include <stdio.h>%@AE@%                

%@AS@%  type va_arg( va_list arg_ptr, type );%@AE@%%@NL@%
%@NL@%
%@AS@%  void va_end( va_list arg_ptr );%@AE@%%@NL@%
%@NL@%
%@AS@%  void va_start( va_list arg_ptr );   UNIX version%@AE@%%@NL@%
%@NL@%
%@AS@%  void va_start( va_list arg_ptr, prev_param );  ANSI%@AE@%%@NL@%
%@NL@%
%@AI@%arg_ptr%@AE@%                           Pointer to list of arguments

%@AI@%prev_param%@AE@%                        Parameter preceding first optional 
                                  argument (ANSI only)

%@AI@%type%@AE@%                              Type of argument to be retrieved

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%va_arg%@AE@%, %@AB@%va_end%@AE@%, and %@AB@%va_start%@AE@% macros provide a portable way to access the
arguments to a function when the function takes a variable number of
arguments. Two versions of the macros are available: the macros defined in
STDARG.H conform to the proposed ANSI C standard, and the macros defined in
VARARGS.H are compatible with the UNIX System V definition. The macros are
listed below:  %@NL@%
%@NL@%
%@AB@%Macro %@AE@%                            %@AB@%Description%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%va_alist%@AE@%                          Name of parameter to called function 
                                  (UNIX version only)

%@AB@%va_arg%@AE@%                            Macro to retrieve current argument

%@AB@%va_dcl%@AE@%                            Declaration of %@AB@%va_alist%@AE@% (UNIX version 
                                  only)

%@AB@%va_end%@AE@%                            Macro to reset %@AI@%arg_ptr%@AE@%

%@AB@%va_list%@AE@%                           The %@AB@%typedef %@AE@%for the pointer to list of 
                                  arguments

%@AB@%va_start%@AE@%                          Macro to set %@AI@%arg_ptr%@AE@% to beginning of 
                                  list of optional arguments (UNIX version
                                  only)

Both versions of the macros assume that the function takes a fixed number of
required arguments, followed by a variable number of optional arguments. The
required arguments are declared as ordinary parameters to the function and
can be accessed through the param-eter names. The optional arguments are
accessed through the macros in STDARG.H or VARARGS.H, which set a pointer to
the first optional argument in the argument list, retrieve arguments from
the list, and reset the pointer when argument processing is completed.%@AB@%  %@AE@%%@NL@%
%@NL@%
The proposed ANSI C standard macros, defined in STDARG.H, are used as
follows:  %@NL@%
%@NL@%
%@NL@%
  1.  All required arguments to the function are declared as parameters in
      the usual way. The %@AB@%va_dcl%@AE@% macro is not used with the STDARG.H macros.%@NL@%
%@NL@%
  2.  The %@AB@%va_start%@AE@% macro sets %@AI@%arg_ptr%@AE@% to the first optional argument in the
      list of arguments passed to the function. The argument %@AI@%arg_ptr%@AE@% must
      have %@AB@%va_list%@AE@% type. The argument %@AI@%prev_param%@AE@% is the name of the required
      parameter immediately preceding the first  optional argument in the
      argument list. If %@AI@%prev_param%@AE@% is declared with the %@AB@%register%@AE@% storage
      class, the macro's behavior is undefined. The %@AB@%va_start%@AE@% macro must be
      used before %@AB@%va_arg%@AE@% is used for the first time.%@NL@%
%@NL@%
  3.  The %@AB@%va_arg%@AE@% macro does the following:
%@NL@%
      ş   Retrieves a value of %@AI@%type%@AE@% from the location given by %@AI@%arg_ptr%@AE@%%@NL@%
%@NL@%
      ş   Increments %@AI@%arg_ptr%@AE@% to point to the next argument in the list,
          using the size of %@AI@%type%@AE@% to determine where the next argument starts%@NL@%
%@NL@%
%@STUB@%      The %@AB@%va_arg%@AE@% macro can be used any number of times within the function
      to retrieve arguments from the list.%@NL@%
%@NL@%
%@NL@%
  4.  After all arguments have been retrieved, %@AB@%va_end%@AE@% resets the pointer to%@AB@%
%@AB@%      NULL%@AE@%.%@NL@%
%@NL@%
%@NL@%
The UNIX System V macros, defined in VARARGS.H, operate in a slightly
different manner, as follows:  %@NL@%
%@NL@%
%@NL@%
  1.  Any required arguments to the function can be declared as parameters
      in the usual way.%@NL@%
%@NL@%
  2.  The last (or only) parameter to the function represents the list of
      optional arguments. This parameter must be named %@AB@%va_alist%@AE@% (not to be
      confused with %@AB@%va_list%@AE@%, which is defined as the type of %@AB@%va_alist%@AE@%).%@NL@%
%@NL@%
  3.  The %@AB@%va_dcl%@AE@% macro appears after the function definition and before the
      opening left brace of the function. This macro is defined as a
      complete declaration of the %@AB@%va_alist%@AE@% parameter, including the
      terminating semicolon; therefore, no semicolon should follow %@AB@%va_dcl%@AE@%.%@NL@%
%@NL@%
  4.  Within the function, the %@AB@%va_start%@AE@% macro sets %@AI@%arg_ptr%@AE@% to the beginning
      of the list of optional arguments passed to the function. The %@AB@%va_start%@AE@%
      macro must be used before %@AB@%va_arg%@AE@% is used for the first time. The
      argument %@AI@%arg_ptr%@AE@% must have %@AB@%va_list%@AE@% type.%@NL@%
%@NL@%
  5.  The %@AB@%va_arg%@AE@% macro does the following:
%@NL@%
      ş   Retrieves a value of %@AI@%type%@AE@% from the location given by %@AI@%arg_ptr%@AE@%%@NL@%
%@NL@%
      ş   Increments %@AI@%arg_ptr%@AE@% to point to the next argument in the list,
          using the size of %@AI@%type%@AE@% to determine where the next argument starts%@NL@%
%@NL@%
%@STUB@%      The %@AB@%va_arg%@AE@% macro can be used any number of times within the function
      to retrieve the arguments from the list.%@NL@%
%@NL@%
%@NL@%
  6.  After all arguments have been retrieved, %@AB@%va_end%@AE@% resets the pointer to%@AB@%
%@AB@%      NULL%@AE@%.%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%va_arg%@AE@% macro returns the current argument; %@AB@%va_start%@AE@% and %@AB@%va_end%@AE@% do not
return values.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%vfprintf%@AE@%, %@AB@%vprintf%@AE@%, %@AB@%vsprintf%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* VA.C: The program below illustrates passing a variable number of
%@AS@%  arguments
%@AS@%   * using the following macros:
%@AS@%   *      va_start            va_arg              va_end
%@AS@%   *      va_list             va_decl (UNIX only)
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #define ANSI            /* Comment out for UNIX version     */
%@AS@%  #ifdef ANSI             /* ANSI compatible version          */
%@AS@%  #include <stdarg.h>
%@AS@%  int average( int first, ... );
%@AS@%  #else                   /* UNIX compatible version          */
%@AS@%  #include <varargs.h>
%@AS@%  int average( va_list );
%@AS@%  #endif
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     /* Call with 3 integers (-1 is used as terminator). */
%@AS@%     printf( "Average is: %d\n", average( 2, 3, 4, -1 ) );
%@AS@%  
%@AS@%     /* Call with 4 integers. */
%@AS@%     printf( "Average is: %d\n", average( 5, 7, 9, 11, -1 ) );
%@AS@%  
%@AS@%     /* Call with just -1 terminator. */
%@AS@%     printf( "Average is: %d\n", average( -1 ) );
%@AS@%  }
%@AS@%  
%@AS@%  /* Returns the average of a variable list of integers. */
%@AS@%  #ifdef ANSI             /* ANSI compatible version    */
%@AS@%  int average( int first, ... )
%@AS@%  {
%@AS@%     int count = 0, sum = 0, i = first;
%@AS@%     va_list marker;
%@AS@%  
%@AS@%     va_start( marker, first );      /* Initialize variable arguments. */
%@AS@%     while( i != -1 )
%@AS@%     {
%@AS@%        sum += i;
%@AS@%        count++;
%@AS@%        i = va_arg( marker, int);
%@AS@%     }
%@AS@%     va_end( marker );               /* Reset variable arguments.      */
%@AS@%     return( sum ? (sum / count) : 0 );
%@AS@%  }
%@AS@%  #else       /* UNIX compatible version must use old-style definition. */
%@AS@%  int average( va_alist )
%@AS@%  va_dcl
%@AS@%  {
%@AS@%     int i, count, sum;
%@AS@%     va_list marker;
%@AS@%  
%@AS@%     va_start( marker );             /* Initialize variable arguments. */
%@AS@%     for( sum = count = 0; (i = va_arg( marker, int)) != -1;  count++ )
%@AS@%        sum += i;
%@AS@%     va_end( marker );               /* Reset variable arguments.      */
%@AS@%     return( sum ? (sum / count) : 0 );
%@AS@%  }
%@AS@%  #endif%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Average is: 3
%@AS@%  Average is: 8
%@AS@%  Average is: 0 %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:vfprintf@%%@QR:vprintf@%%@QR:vsprintf@%%@NL@%
%@2@%%@CR:C6A03581709 @%%@AB@%vfprintf, vprintf, vsprintf%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@AE@%%@EH@%%@NL@%
%@NL@%
Write formatted output using a pointer to a list of arguments.  %@NL@%
%@NL@%
%@AB@%#include <stdio.h>%@AE@%                

%@AB@%#include <varargs.h>%@AE@%              Required for compatibility with UNIX 
                                  System V

%@AB@%#include <stdarg.h>%@AE@%               Required for compatibility with the ANSI
                                  C standard

%@AS@%  int vfprintf( FILE *stream, const char *format, va_list argptr );%@AE@%%@NL@%
%@NL@%
%@AS@%  int vprintf( const char *format, va_list argptr );%@AE@%%@NL@%
%@NL@%
%@AS@%  int vsprintf( char *buffer, const char *format, va_list argptr );%@AE@%%@NL@%
%@NL@%
%@AI@%stream%@AE@%                            Pointer to%@AB@% FILE structure%@AE@%

%@AI@%format%@AE@%                            Format control

%@AI@%argptr%@AE@%                            Pointer to list of arguments

%@CR:C6A03581710 @%%@CR:C6A03581711 @%%@CR:C6A03581712 @%%@CR:C6A03581713 @%%@CR:C6A03581714 @%%@CR:C6A03581715 @%%@CR:C6A03581716 @%%@AI@%buffer%@AE@%                            Storage location for output

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%vfprintf%@AE@%, %@AB@%vprintf%@AE@%, and %@AB@%vsprintf%@AE@% functions format data and output data to
the file specified by %@AI@%stream%@AE@%, to standard output, and to the memory pointed
to by %@AI@%buffer%@AE@%, respectively. These functions are similar to their
counterparts %@AB@%fprintf%@AE@%, %@AB@%printf%@AE@%, and %@AB@%sprintf%@AE@%, but each accepts a pointer to a
list of arguments instead of an argument list.  %@NL@%
%@NL@%
The %@AI@%format%@AE@% argument has the same form and function as the %@AI@%format%@AE@% argument
for the %@AB@%printf%@AE@% function; see %@AB@%printf%@AE@% for a description of %@AI@%format%@AE@%.  %@NL@%
%@NL@%
The %@AI@%argptr%@AE@% parameter has type %@AB@%va_list%@AE@%, which is defined in the include files
VARARGS.H and STDARG.H. The %@AI@%argptr%@AE@% parameter points to a list of arguments
that are converted and output according to the corresponding format
specifications in the format.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The return value for %@AB@%vprintf%@AE@% and %@AB@%vsprintf%@AE@% is the number of characters
written, not counting the terminating null character. If successful, the
%@AB@%vfprintf%@AE@% return value is the number of characters written. If an output
error occurs, it is a negative value.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%%@AE@% ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fprintf%@AE@%, %@AB@%printf%@AE@%, %@AB@%sprintf%@AE@%,%@AB@% va_arg%@AE@%, %@AB@%va_end%@AE@%, %@AB@%va_start%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* VPRINTF.C shows how to use vprintf functions to write new versions
%@AS@%   * of printf. The vsprintf function is used in the example.
%@AS@%   */
%@AS@%  
%@AS@%  #include <stdio.h>
%@AS@%  #include <graph.h>
%@AS@%  #include <string.h>
%@AS@%  #include <stdarg.h>
%@AS@%  #include <malloc.h>
%@AS@%  
%@AS@%  int wprintf( short row, short col, short clr, long bclr, char *fmt, ... );
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     short fgd = 0;
%@AS@%     long  bgd = 0L;
%@AS@%  
%@AS@%     _clearscreen( _GCLEARSCREEN );
%@AS@%     _outtext( "Color text example:\n\n" );
%@AS@%  
%@AS@%     /* Loop through 8 background colors. */
%@AS@%     for( bgd = 0L; bgd < 8; bgd++ )
%@AS@%     {
%@AS@%        wprintf( (int)bgd + 3, 1, 7, bgd, "Back: %d Fore:", bgd );
%@AS@%  
%@AS@%        /* Loop through 16 foreground colors. */
%@AS@%        for( fgd = 0; fgd < 16; fgd++ )
%@AS@%           wprintf( -1, -1, fgd, -1L, " %2d ", fgd );
%@AS@%     }
%@AS@%  }
%@AS@%  
%@AS@%  /* Full-screen window version of printf that takes row, column, textcolor,
%@AS@%   * and background color as its first arguments, followed by normal printf
%@AS@%   * format strings (except that \t is not handled). You can specify -1 for
%@AS@%   * any of the first arguments to use the current value. The function
%@AS@%returns
%@AS@%   * the number of characters printed, or a negative number for errors.
%@AS@%   */
%@AS@%  int wprintf( short row, short col, short clr, long bclr, char *fmt, ... )
%@AS@%  {
%@AS@%     struct  rccoord tmppos;
%@AS@%     short   ret, size;
%@AS@%     va_list marker;
%@AS@%     char    *buffer;%@AE@%%@NL@%
%@NL@%
%@AS@%  /* It's probably safe to use a buffer length of 512 bytes or five times
%@AS@%      * the length of the format string.
%@AS@%      */
%@AS@%     size = strlen( fmt );
%@AS@%     size = (size > 512) ? 512 : size * 5;
%@AS@%     if( (buffer = (char *)malloc( size )) == NULL )
%@AS@%        return -1;
%@AS@%  
%@AS@%     /* Set text position. */
%@AS@%     tmppos = _gettextposition();
%@AS@%     if( row < 1 )
%@AS@%        row = tmppos.row;
%@AS@%     if( col < 1 )
%@AS@%        col = tmppos.col;
%@AS@%     _settextposition( row, col );
%@AS@%  
%@AS@%     /* Set foreground and background colors. */
%@AS@%     if( clr >= 0 )
%@AS@%        _settextcolor( clr );
%@AS@%     if( bclr >= 0 )
%@AS@%        _setbkcolor( bclr );
%@AS@%  
%@AS@%     /* Write text to a string and output the string. */
%@AS@%     va_start( marker, fmt );
%@AS@%     ret = vsprintf( buffer, fmt, marker );
%@AS@%     va_end( marker );
%@AS@%     _outtext( buffer );
%@AS@%     free( buffer );
%@AS@%     return ret;
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:wait@%%@NL@%
%@2@%%@CR:C6A03591717 @%%@AB@%wait%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03591718 @%%@CR:C6A03591719 @% %@CR:C6A03591720 @%%@CR:C6A03591721 @% %@CR:C6A03591722 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Suspends the calling process.  %@NL@%
%@NL@%
%@AS@%  #include <process.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  int wait( int *termstat );%@AE@%%@NL@%
%@NL@%
%@AI@%termstat%@AE@%                          Termination-status word and return code 
                                  for terminated child process

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%wait%@AE@% function suspends the calling process until any of the caller's
immediate child processes terminate. If all of the caller's children have
terminated before it calls the %@AB@%wait%@AE@% function, the function returns
immediately.  %@NL@%
%@NL@%
If not %@AB@%NULL%@AE@%, %@AI@%termstat%@AE@% points to a buffer containing a termination-status
word and return code for the child process. The status word indicates
whether or not the child process ended normally by calling the OS/2 %@AB@%DosExit%@AE@%
function. Supply %@AB@%NULL%@AE@% if you do not need the child's termination-status
word.  %@NL@%
%@NL@%
If the child process did terminate normally, the low-order and high-order
bytes of the termination-status word are as follows:  %@NL@%
%@NL@%
%@AB@%Byte%@AE@%                              %@AB@%Contents%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
Low order                         0

High order                        Low-order byte of the result code passed
                                  by the child process to %@AB@%DosExit%@AE@%. The %@AB@%%@AE@%
                                  %@AB@%DosExit%@AE@% function is called if the child 
                                  process called %@AB@%exit%@AE@% or %@AB@%_exit%@AE@%, if it 
                                  returned from %@AB@%main%@AE@%, or if it reached the
                                  end of %@AB@%main%@AE@%. The low-order byte of the 
                                  result code is either the low-order byte
                                  of the argument to %@AB@%_exit%@AE@% or %@AB@%exit%@AE@%, the 
                                  low-order byte of the return value from %@AB@%%@AE@%
                                  %@AB@%main%@AE@%, or a random value if the child 
                                  process reached the end of %@AB@%main%@AE@%.

Note that the OS/2 %@AB@%DosExit%@AE@% function allows programs to return a 16-bit
result code. However, the %@AB@%wait%@AE@% and %@AB@%cwait%@AE@% functions will return only the
low-order byte of that result code.  %@NL@%
%@NL@%
If the child process terminated for any other reason, the high-order and
low-order bytes of the termination-status word are as follows:  %@NL@%
%@NL@%
%@AB@%Byte%@AE@%                              %@AB@%Contents%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
Low order                         Termination code from %@AB@%DosWait%@AE@%:

                                  %@AB@%Code%@AE@%        %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
                                  %@AB@%1%@AE@%           Hard-error abort

                                  %@AB@%2%@AE@%           Trap operation

                                  %@AB@%3%@AE@%           %@AB@%SIGTERM%@AE@%        intercepted
                                              signal not     

High order                        0 

%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
If %@AB@%wait%@AE@% returns after normal termination of a child process, it returns the
child's process ID.  %@NL@%
%@NL@%
If %@AB@%wait%@AE@% returns after abnormal termination of a child process, it returns
the number -1 and sets %@AB@%errno%@AE@% to %@AB@%EINTR%@AE@%.  %@NL@%
%@NL@%
Otherwise, %@AB@%wait%@AE@% returns -1 immediately and sets %@AB@%errno%@AE@% to %@AB@%ECHILD%@AE@%, indicating
that no child processes exist for the calling process.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI   DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%cwait%@AE@%, %@AB@%exit%@AE@%, %@AB@%_exit%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* WAIT.C: This program launches several child processes and waits for
%@AS@%   * the first to finish.
%@AS@%   */
%@AS@%  
%@AS@%  #define INCL_NOPM
%@AS@%  #define INCL_NOCOMMON
%@AS@%  #define INCL_DOSPROCESS
%@AS@%  #include <os2.h>        /* DosSleep   */
%@AS@%  #include <process.h>    /* wait       */
%@AS@%  #include <stdlib.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <time.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  /* Macro to get a random integer within a specified range */
%@AS@%  #define getrandom( min, max ) ((rand() % (int)(((max) + 1) - (min))) +
%@AS@%(min))
%@AS@%  
%@AS@%  struct  CHILD
%@AS@%  {
%@AS@%      int     pid;
%@AS@%      char    name[10];
%@AS@%  } child[4] = { { 0, "Ann" }, { 0, "Beth"  }, { 0, "Carl" }, { 0, "Dave" }
%@AS@%};
%@AS@%  
%@AS@%  void main( int argc, char *argv[] )
%@AS@%  {
%@AS@%      int     termstat, pid, c, tmp;
%@AS@%  
%@AS@%      srand( (unsigned)time( NULL ) );               /* Seed randomizer */
%@AS@%      /* If no arguments, this is the parent. */
%@AS@%      if( argc == 1 )
%@AS@%      {
%@AS@%  
%@AS@%          /* Spawn children in random order with a random delay. */
%@AS@%          tmp = getrandom( 0, 3 );
%@AS@%          for( c = tmp; c < tmp + 4; c++ )
%@AS@%              child[c % 4].pid = spawnl( P_NOWAIT, argv[0], argv[0],
%@AS@%                                     child[c % 4].name, NULL );
%@AS@%  
%@AS@%          /* Wait for the first children. Only get ID of first. */
%@AS@%          printf( "Who's first?\n" );
%@AS@%          pid = wait( &termstat );
%@AS@%          for( c = 0; c < 3; c++ )
%@AS@%              wait( &termstat );
%@AS@%  
%@AS@%          /* Check IDs to see who was first. */
%@AS@%          for( c = 0; c < 4; c++ )
%@AS@%              if( pid == child[c].pid )
%@AS@%                  printf( "%s was first\n\n", child[c].name );
%@AS@%      }
%@AS@%  
%@AS@%      /* If there are arguments, this must be a child. */
%@AS@%      else
%@AS@%      {
%@AS@%          /* Delay for random time. */
%@AS@%          srand( (unsigned)time( NULL ) * argv[1][0] );
%@AS@%          DosSleep( getrandom( 1, 5) * 1000L );
%@AS@%          printf( "Hi, dad. It's %s.\n", argv[1] );
%@AS@%      }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Who's first?
%@AS@%  Hi, dad. It's Carl.
%@AS@%  Hi, dad. It's Ann.
%@AS@%  Hi, dad. It's Beth.
%@AS@%  Hi, dad. It's Dave.
%@AS@%  Carl was first %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:_wrapon@%%@NL@%
%@2@%%@CR:C6A03601723 @%%@AB@%_wrapon%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03601724 @%%@CR:C6A03601725 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Controls word wrap.  %@NL@%
%@NL@%
%@AS@%  #include <graph.h>%@AE@%%@NL@%
%@NL@%
%@AS@%  short _far _wrapon( short option );%@AE@%%@NL@%
%@NL@%
%@AI@%option%@AE@%                            Wrap condition

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%_wrapon%@AE@% function controls whether text output with the %@AB@%_outtext%@AE@% function
wraps to a new line or is simply clipped when the text output reaches the
edge of the defined text window. The %@AI@%option%@AE@% argument can be one of the
following manifest constants:  %@NL@%
%@NL@%
%@AB@%Constant%@AE@%                          %@AB@%Meaning%@AE@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%_GWRAPOFF%@AE@%                         Truncates lines at window border

%@AB@%_GWRAPON%@AE@%                          Wraps lines at window border

Note that this function does not affect the output of presentation-graphics
routines or font routines.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The function returns the previous value of %@AI@%option%@AE@%. There is no error return.
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2   UNIX   XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%_outtext%@AE@%,  %@AB@%_settextwindow%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* WRAPON.C */
%@AS@%  
%@AS@%  #include <conio.h>
%@AS@%  #include <graph.h>
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     _wrapon( _GWRAPON );
%@AS@%     while( !kbhit() )
%@AS@%        _outtext( "Wrap on!   " );
%@AS@%     getch();
%@AS@%     _outtext( "\n\n" );
%@AS@%  
%@AS@%     _wrapon( _GWRAPOFF );
%@AS@%     while( !kbhit() )
%@AS@%        _outtext( "Wrap off!  " );
%@AS@%     getch();
%@AS@%     _outtext( "\n\n" );
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap
%@AS@%   on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!
%@AS@%    Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wr
%@AS@%  ap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap on!  Wrap o
%@AS@%  n!  Wrap on!  Wrap on!
%@AS@%  
%@AS@%  Wrap off! Wrap off! Wrap off! Wrap off! Wrap off! Wrap off! Wrap off! Wrap
%@AS@%%@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@QR:write@%%@NL@%
%@2@%%@CR:C6A03611726 @%%@AB@%write%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Description%@CR:C6A03611727 @%%@CR:C6A03611728 @% %@CR:C6A03611729 @%%@CR:C6A03611730 @% %@CR:C6A03611731 @%%@AE@%%@EH@%%@NL@%
%@NL@%
Writes data to a file.  %@NL@%
%@NL@%
%@AB@%#include <io.h>%@AE@%                   Required only for function declarations

%@AS@%  int write( int handle, void *buffer, unsigned int count );%@AE@%%@NL@%
%@NL@%
%@AI@%handle%@AE@%                            Handle referring to open file

%@AI@%buffer%@AE@%                            Data to be written

%@AI@%count%@AE@%                             Number of bytes

%@NL@%
%@3@%%@AB@%Remarks%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%write%@AE@% function writes %@AI@%count%@AE@% bytes from %@AI@%buffer%@AE@% into the file associated
with %@AI@%handle%@AE@%. The write operation begins at the current position of the file
pointer (if any) associated with the given file. If the file is open for
appending, the operation begins at the current end of the file. After the
write operation, the file pointer is increased by the number of bytes
actually written.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Return Value%@AE@%%@EH@%%@NL@%
%@NL@%
The %@AB@%write%@AE@% function returns the number of bytes actually written. The return
value may be positive but less than %@AI@%count%@AE@% (for example, when %@AB@%write%@AE@% runs out
of disk space before %@AI@%count%@AE@% bytes are written).  %@NL@%
%@NL@%
A return value of -1 indicates an error. In this case, %@AB@%errno%@AE@% is set to one
of the following values:  %@NL@%
%@NL@%
%@AB@%Value%@AE@%                             %@AB@%Meaning %@AE@% %@CR:C6A03611732 @%%@CR:C6A03611733 @%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ%@AE@%%@NL@%
%@AB@%EBADF%@AE@%                             Invalid file handle or file not opened 
                                  for writing

%@AB@%ENOSPC%@AE@%                            No space left on device

If you are writing more than 32K (the maximum size for type %@AB@%int%@AE@%) to a file,
the return value should be of type %@AB@%unsigned int%@AE@%. (See the example that
follows.) However, the maximum number of bytes that can be written to a file
at one time is 65,534, since 65,535 (or 0xFFFF) is indistinguishable from -1
and would return an error.  %@NL@%
%@NL@%
If the file is opened in text mode, each line-feed character is replaced
with a carriagereturn-line-feed pair in the output. The replacement does not
affect the return value.  %@NL@%
%@NL@%
When writing to files opened in text mode, the %@AB@%write%@AE@% function treats a
CTRL+Z character as the logical end-of-file. When writing to a device, %@AB@%write%@AE@%
treats a CTRL+Z character in the buffer as an output terminator.  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Compatibility%@AE@%%@EH@%%@NL@%
%@NL@%
 ANSI  %@AB@%%@AE@% DOS  %@AB@%%@AE@% OS/2  %@AB@%%@AE@% UNIX  %@AB@%%@AE@% XENIX%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%See Also%@AE@%%@EH@%%@NL@%
%@NL@%
%@AB@%fwrite%@AE@%, %@AB@%open%@AE@%, %@AB@%read%@AE@%  %@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Example%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  /* WRITE.C: This program opens a file for output and uses write to
%@AS@%   * write some bytes to the file.
%@AS@%   */
%@AS@%  
%@AS@%  #include <io.h>
%@AS@%  #include <stdio.h>
%@AS@%  #include <stdlib.h>
%@AS@%  #include <fcntl.h>
%@AS@%  #include <sys\types.h>
%@AS@%  #include <sys\stat.h>
%@AS@%  
%@AS@%  char buffer[] = "This is a test of 'write' function";
%@AS@%  
%@AS@%  void main()
%@AS@%  {
%@AS@%     int fh;
%@AS@%     unsigned byteswritten;
%@AS@%  
%@AS@%     if( (fh = open( "write.o", O_RDWR | O_CREAT, S_IREAD | S_IWRITE )) !=
%@AS@%-1 )
%@AS@%     {
%@AS@%        if( (byteswritten = write( fh, buffer, sizeof( buffer ) )) == -1 )
%@AS@%           perror( "Write failed" );
%@AS@%        else
%@AS@%           printf( "Wrote %u bytes to file\n", byteswritten );
%@AS@%  
%@AS@%        close( fh );
%@AS@%     }
%@AS@%  }%@AE@%%@NL@%
%@NL@%
%@NL@%
%@3@%%@AB@%Output%@AE@%%@EH@%%@NL@%
%@NL@%
%@AS@%  
%@AS@%  
%@AS@%  Wrote 35 bytes to file
%@AS@%  %@AE@%%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@CR:GeneralIndex@%
%@1@%%@AB@%INDEX%@AE@%%@EH@%%@NL@%
%@AB@%ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


 

%@2@%%@AB@%    A%@AE@%%@EH@%%@NL@%
abort%@BO:       2970b@%%@BO:       39232@%
abs%@BO:       39d24@%
Absolute value
  abs%@BO:       39d24@%
  cabs%@BO:       53af4@%
  cabsl%@BO:       53af4@%
  fabs%@BO:       89c1a@%
  fabsl%@BO:       89c1a@%
  labs%@BO:       d7ae9@%
Access mode%@BO:       8c727@%%@BO:       960fb@%%@BO:       9e7c6@%%@BO:       a3dcd@%
access%@BO:       151f1@%%@BO:       3a5c1@%
acos%@BO:       2519d@%%@BO:       3b39e@%
acosl%@BO:       2519c@%%@BO:       2519d@%%@BO:       3b39d@%%@BO:       3b39e@%
alloca%@BO:       2719e@%%@BO:       3c056@%
Allocation
   %@AI@%see%@AE@% Memory allocation%@NL@%; %@AI@%see%@AE@% %@NL@%
_amblksiz variable%@BO:       32884@%
Appending
  constants%@BO:       fb68c@%%@BO:      150a9d@%
  streams%@BO:       960fb@%%@BO:       9e7c6@%%@BO:       a3dcd@%
_arc, _arc_w, _arc_wxy
  description%@BO:       3cdec@%
  use%@BO:       18fcd@%
Arccosine function%@BO:       3b39e@%
Arcsine function%@BO:       3eff5@%
Arctangent function%@BO:       40b56@%
Arguments
  singularity%@BO:       e9b2e@%
  type checking%@BO:        6ead@%
  variable-length number%@BO:       32325@%%@BO:      185753@%
asctime%@BO:       31041@%%@BO:       3e045@%
asin%@BO:       2519d@%%@BO:       3eff5@%
asinl%@BO:       2519c@%%@BO:       2519d@%%@BO:       3eff4@%%@BO:       3eff5@%
assert%@BO:       3fc46@%
Assertions%@BO:       3fc46@%%@BO:       3fe8c@%
atan, atan2%@BO:       2519d@%%@BO:       40b55@%%@BO:       40b56@%
atanl, atan2l%@BO:       2528c@%%@BO:       40b56@%
atanl, _atan2l%@BO:       2528c@%%@BO:       40b56@%
atexit%@BO:       2970b@%%@BO:       418cf@%
atof, atoi, atol, _atold%@BO:       139f1@%%@BO:       42547@%
_atold%@BO:       13977@%
Attributes%@BO:       181c4@%

%@2@%%@AB@%    B%@AE@%%@EH@%%@NL@%
_bcalloc%@BO:       545a7@%
bdos%@BO:       2e8b5@%%@BO:       43a0f@%
_beginthread%@BO:       446c0@%
Bessel functions
  described%@BO:       254e0@%%@BO:       4687d@%
  j0, j1, jn;%@BO:       4687d@%
  y0, y1, yn;%@BO:       4687d@%
  _j0l, _j1l, _jnl;%@BO:       4687d@%
  _y0l, _y1l, _ynl;%@BO:       4687d@%
_bexpand%@BO:       885b0@%
_bfree%@BO:       9c946@%
_bfreeseg%@BO:       47d29@%
_bheapadd%@BO:       c81c1@%
_bheapchk%@BO:       c991a@%
_bheapmin%@BO:       ca973@%
_bheapseg%@BO:       48c44@%
_bheapset%@BO:       cb409@%
_bheapwalk%@BO:       cc742@%
Binary
  format, conversion to IEEE
    double precision%@BO:       67566@%
  int
    reading%@BO:       beda4@%
    writing%@BO:      11ee6f@%
  mode
    fdopen%@BO:       8cc62@%
    fopen%@BO:       96c8d@%
    freopen%@BO:       9e7c6@%%@BO:       9f5e5@%
    open%@BO:       fb68c@%
    setmode%@BO:      13e0d5@%
    sopen%@BO:      150a9d@%
    vs. text mode%@BO:       1d78e@%
    _fmode%@BO:       34df1@%
    _fsopen%@BO:       a4b2f@%
  search%@BO:       52757@%%@BO:       d97d3@%%@BO:       e2c09@%
BINMODE.OBJ%@BO:       34df1@%
_bios_disk%@BO:       2deea@%%@BO:       49e24@%
_bios_equiplist%@BO:       2deea@%%@BO:       4c5a0@%
_bios_keybrd}bios_keybrd%@BO:       2df7d@%%@BO:       4d0ad@%
_bios_memsize%@BO:       2df7d@%%@BO:       4e9a0@%
_bios_printer%@BO:       2df7d@%%@BO:       4efb4@%
_bios_serialcom%@BO:       2deea@%%@BO:       501e2@%
_bios_timeofday%@BO:       2df7d@%%@BO:       51b50@%
_bmalloc%@BO:       e6e95@%
_bmsize%@BO:       f9464@%
Bold type, use of%@BO:        90e5@%
Brackets, double, use of%@BO:        9302@%
_brealloc%@BO:      1232cc@%
bsearch%@BO:       2cb61@%%@BO:       52757@%
Buffer manipulation
  memccpy%@BO:       ec066@%
  memchr%@BO:       ecda0@%
  memcmp%@BO:       edc30@%
  memcpy%@BO:       eed69@%
  memicmp%@BO:       f024c@%
  memmove%@BO:       f1c14@%
  memset%@BO:       f2f06@%
  routines and uses (list)%@BO:       f78e7@%
  _fmemccpy%@BO:       ec066@%
  _fmemchr%@BO:       ecda0@%
  _fmemcmp%@BO:       edc30@%
  _fmemcpy%@BO:       eed69@%
  _fmemicmp%@BO:       f024c@%
  _fmemmove%@BO:       f1c14@%
  _fmemset%@BO:       f2f06@%
Buffering
  described%@BO:       1e73c@%
  preopened streams%@BO:       21099@%
  using%@BO:       21099@%
Buffers
  assigning%@BO:      136a2a@%
  comparing%@BO:       edffc@%%@BO:       f072e@%
  copying%@BO:       ec3aa@%%@BO:       ef1e1@%%@BO:       f7d07@%
  flushing%@BO:       8ebeb@%%@BO:       94f64@%
  searching%@BO:       ed1b7@%
  setting characters%@BO:       f32bc@%
BUFSIZ constant%@BO:       1e9f3@%
Byte order, swapping%@BO:      175cc2@%

%@2@%%@AB@%    C%@AE@%%@EH@%%@NL@%
cabs%@BO:       254e0@%%@BO:       53af4@%
cabsl%@BO:       254e0@%%@BO:       53af3@%%@BO:       53af4@%
calloc%@BO:       2719e@%%@BO:       545a7@%
Carry flag
  bdos%@BO:       44287@%
  int86%@BO:       d0cdb@%
  int86x%@BO:       d1ad3@%
  intdos%@BO:       d2b37@%
  intdosx%@BO:       d385f@%
ceil%@BO:       23c11@%%@BO:       254e0@%%@BO:       55680@%
Ceiling function%@BO:       55680@%
ceill%@BO:       254e0@%%@BO:       55680@%
_cexit, _c_exit%@BO:       561c1@%
cgets%@BO:       23d2f@%%@BO:       56bc6@%
_chain_intr%@BO:       2e8fd@%%@BO:       30d0b@%%@BO:       57864@%
Character classification and conversion functions
  include files%@BO:       1365b@%
  isalnum%@BO:       12c50@%%@BO:       d4727@%
  iscntrl%@BO:       d4727@%
  isdigit%@BO:       d4727@%
  isgraph%@BO:       d4727@%
  islower%@BO:       12e6c@%%@BO:       d481b@%
  isprint%@BO:       12edf@%%@BO:       d481b@%
  ispunct%@BO:       12f52@%%@BO:       d481b@%
  isspace%@BO:       12fc7@%%@BO:       d481b@%
  isupper%@BO:       1303c@%
  isxdigit%@BO:       1309c@%%@BO:       d481b@%
  toascii%@BO:       130fa@%%@BO:      17b58a@%
  tolower, _tolower%@BO:       131d2@%%@BO:      17b58a@%
  toupper, _toupper%@BO:       131d2@%%@BO:      17b58a@%
Characters
  converting. See Character classification and conversion functions%@BO:      17b58a@%
  device%@BO:       d6045@%
  reading
    fgetc, fgetchar%@BO:       8f784@%
    from console%@BO:       ae3a8@%
    from port%@BO:       d03f6@%
    getc, getchar%@BO:       ad77e@%
    read function%@BO:      122083@%
  ungetting%@BO:      17f6e0@%%@BO:      180681@%
  writing
    fputc, fputchar%@BO:       9a711@%
    putc, putchar%@BO:      11b0aa@%
    to console%@BO:      11bb1f@%
    to port%@BO:       ff3fa@%
    write function%@BO:      1890d4@%
chdir%@BO:       141fe@%%@BO:       5864f@%
_chdrive%@BO:       59494@%
Child process
  cwait
    signal settings%@BO:      15314f@%
    termination-status word%@BO:       654e7@%%@BO:      15314f@%%@BO:      186a5f@%
  exec%@BO:       83683@%
  floating-point state of parent%@BO:       98a1f@%
  spawn%@BO:      15314f@%
  wait%@BO:      186a5f@%
chmod%@BO:       149b0@%%@BO:       5a336@%
chsize%@BO:       14a25@%%@BO:       5b200@%
_clear87%@BO:       254e0@%%@BO:       5c048@%
clearerr%@BO:       1eb43@%%@BO:       5ca41@%
_clearscreen%@BO:       18e2e@%%@BO:       5d3f3@%
Clipping regions%@BO:      1379f9@%
clock%@BO:       31041@%%@BO:       5de39@%
clock_t type%@BO:       36403@%
close%@BO:       22557@%%@BO:       5eb0e@%
Comparison
  max macro%@BO:       eae22@%
  min macro%@BO:       f3acc@%
Compatibility mode%@BO:      150a9d@%
complex type%@BO:       3655a@%
CONIO.H%@BO:       23c11@%
Console, ungetting characters from%@BO:      180681@%
_control87%@BO:       254e0@%%@BO:       5f514@%
Conversion
  characters. See Character classification and conversion functions%@BO:      17b58a@%
  data. See Data conversion%@BO:      17b58a@%
  floating-point numbers 
    to integers and fractions%@BO:       f6ebe@%
    to strings%@BO:       808da@%%@BO:       8b426@%%@BO:       aaf0e@%
  floating-point numbers
    IEEE double to MS binary double%@BO:       67566@%
  integers to strings%@BO:       d6757@%
  long integers to strings%@BO:       e4b07@%%@BO:      17ddcc@%
  strings to
    floating-point values%@BO:       429d6@%
    lowercase%@BO:      167955@%
    uppercase%@BO:      1748f9@%
  time. See Time, conversion%@BO:      17b58a@%
cos, cosh%@BO:       25658@%%@BO:       60951@%
Cosine%@BO:       60951@%
cosl, coshl%@BO:       25658@%
cprintf%@BO:       23da4@%%@BO:       616a2@%
cputs%@BO:       23e1e@%%@BO:       620f6@%
creat%@BO:       22619@%%@BO:       627fe@%
cscanf%@BO:       23e7f@%%@BO:       63ba4@%
ctime%@BO:       31041@%%@BO:       6478f@%
CTYPE.H routines%@BO:       1365b@%%@BO:       d4727@%
cwait%@BO:       654e7@%

%@2@%%@AB@%    D%@AE@%%@EH@%%@NL@%
Data conversion
   %@AI@%see also%@AE@% Conversion%@NL@%; %@AI@%see also%@AE@% %@NL@%
  atof, atol%@BO:       13977@%
  atof, atol, _atold%@BO:       42547@%
  atoi%@BO:       42547@%
  ecvt%@BO:       13b03@%%@BO:       804d3@%
  fcvt%@BO:       13b7e@%%@BO:       8b426@%
  gcvt%@BO:       13bf9@%%@BO:       aaf0e@%
  include files%@BO:       136c7@%
  itoa%@BO:       13c74@%%@BO:       d6757@%
  ltoa%@BO:       13d4c@%%@BO:       e4b07@%
  strtod, strtol, strtoul%@BO:       13e2d@%%@BO:      17195e@%%@BO:      17195f@%
  ultoa%@BO:       13fa7@%%@BO:      17ddcc@%
Data items
  reading%@BO:       9b98d@%
  writing%@BO:       aa0ad@%
Date routines
   %@AI@%see%@AE@% Time, routines%@NL@%; %@AI@%see%@AE@% %@NL@%
Daylight variable%@BO:       33178@%%@BO:      17cabe@%
Default translation mode
  child process, used in%@BO:      15314f@%
  O_TEXT%@BO:       fb68c@%
  setmode%@BO:      13e0d5@%
  sopen%@BO:      150a9d@%
  _fmode%@BO:       34df1@%
  _fopen%@BO:       96c8d@%
  _fsopen%@BO:       a4b2f@%
dexpl%@BO:       258bd@%%@BO:       d8378@%
dieeetomsbin, dmsbintoieee%@BO:       25f54@%%@BO:       67566@%
difftime%@BO:       31161@%%@BO:       67dbe@%
DIRECT.H%@BO:       141fe@%
Directories
  creating%@BO:       f4209@%
  deleting%@BO:      12b5ce@%
  getting current%@BO:       b0741@%%@BO:       b1454@%
  renaming%@BO:      129c8c@%
Directory control
  chdir%@BO:       141fe@%
  chmod%@BO:       5a336@%
  getcwd%@BO:       142cd@%%@BO:       b0741@%
  include files%@BO:       14030@%
  mkdir%@BO:       14415@%%@BO:       f4209@%
  remove%@BO:      12943c@%
  rmdir%@BO:       14480@%
  unlink%@BO:      181113@%
  _getdcwd%@BO:       b1454@%
_disable%@BO:       2e968@%%@BO:       30d0b@%
diskfree_t structure%@BO:       3666d@%
diskinfo_t structure%@BO:       367dc@%
_displaycursor%@BO:       1600b@%%@BO:       68787@%
div%@BO:       690c5@%
Division
  div%@BO:       690c5@%
  ldiv%@BO:       d8c97@%
div_t type%@BO:       3694e@%
Document conventions%@BO:        8dc1@%
DOMAIN%@BO:       e9ad5@%
DOS commands, execution within programs%@BO:      17650f@%
DOS error codes%@BO:       34328@%
DOS interface routines
  and uses (list)%@BO:       2e68c@%
  bdos%@BO:       2e68c@%%@BO:       43a0f@%
  dosexterr%@BO:       7e5db@%
  FP_OFF%@BO:       2e712@%
  harderr, _hardresume, _hardretn%@BO:       2e712@%
  include files%@BO:       30440@%
  int86%@BO:       2e712@%%@BO:       d0cdb@%
  int86x%@BO:       d1ad3@%
  intdos%@BO:       2e712@%%@BO:       d2b37@%
  intdosx%@BO:       d385f@%
  segread%@BO:       2e712@%%@BO:      1330d6@%
  _bios_disk%@BO:       49e24@%
  _bios_equiplist%@BO:       4c5a0@%
  _bios_keybrd%@BO:       4d0ad@%
  _bios_memsize%@BO:       4e9a0@%
  _bios_printer%@BO:       4efb4@%
  _bios_timeofday%@BO:       51b50@%
  _chain_intr%@BO:       57864@%
  _dos_allocmem%@BO:       69ca1@%
  _dos_close%@BO:       6a8bf@%
  _dos_creat, _dos_creatnew%@BO:       6b2a1@%
  _dos_findnext%@BO:       6c1fa@%
  _dos_freemem%@BO:       6dfe6@%
  _dos_getdate%@BO:       6eb1e@%
  _dos_getdiskfree%@BO:       6f522@%
  _dos_getdrive%@BO:       70115@%
  _dos_getfileattr%@BO:       70b15@%
  _dos_getftime%@BO:       71c07@%
  _dos_gettime%@BO:       72dbe@%
  _dos_getvect%@BO:       7377a@%
  _dos_keep%@BO:       73e64@%
  _dos_open%@BO:       74a3f@%
  _dos_read%@BO:       75cf6@%
  _dos_setblock%@BO:       76ab6@%
  _dos_setdate%@BO:       776b8@%
  _dos_setdrive%@BO:       7834b@%
  _dos_setfileattr%@BO:       78ef4@%
  _dos_setftime%@BO:       7a0f1@%
  _dos_settime%@BO:       7b225@%
  _dos_setvect%@BO:       7bea7@%
  _dos_write%@BO:       7d8cd@%
  _enable%@BO:       2e68c@%%@BO:       82370@%
DOS interrupts, invoking%@BO:       d0cdb@%%@BO:       d1ad3@%
DOS system calls
  error handling%@BO:       7e86e@%
  invoking%@BO:       43d81@%%@BO:       d2b37@%%@BO:       d385f@%
  _bios_serialcom%@BO:       501e2@%
DOS version number, detection%@BO:       35126@%
DOS.H%@BO:       30440@%
dosdate_t structure, dostime_t structure%@BO:       36c28@%
_doserrnovariable%@BO:       33a2f@%
DOSERROR type%@BO:       36d83@%%@BO:       7e940@%
dosexterr%@BO:       2fc1b@%%@BO:       7e5da@%%@BO:       7e5db@%
_dos_allocmem%@BO:       2ea15@%%@BO:       69ca1@%
_dos_close%@BO:       2eab1@%%@BO:       6a8bf@%
_dos_creat%@BO:       2eb85@%%@BO:       6b2a1@%
_dos_creatnew%@BO:       2ecab@%%@BO:       6b2a1@%
_dos_findfirst%@BO:       2ed43@%%@BO:       6c1fa@%
_dos_findnext%@BO:       2edec@%%@BO:       6c1fa@%
_dos_freemem%@BO:       2eebf@%%@BO:       6dfe6@%
_dos_getdate%@BO:       2ef56@%%@BO:       6eb1e@%
_dos_getdiskfree%@BO:       2efee@%%@BO:       6f522@%
_dos_getdrive%@BO:       2f08f@%%@BO:       70115@%
_dos_getfileattr%@BO:       2f12f@%%@BO:       70b15@%
_dos_getftime%@BO:       2f1e2@%%@BO:       71c07@%
_dos_gettime%@BO:       2f2bd@%%@BO:       72dbe@%
_dos_getvect%@BO:       2f39e@%%@BO:       7377a@%
_dos_keep%@BO:       2f476@%%@BO:       73e64@%
_dos_open%@BO:       2f509@%%@BO:       74a3f@%
_dos_read%@BO:       2f5a1@%%@BO:       75cf6@%
_dos_setblock%@BO:       2f672@%%@BO:       76ab6@%
_dos_setdate%@BO:       2f72e@%%@BO:       776b8@%
_dos_setdrive%@BO:       2f7ee@%%@BO:       7834b@%
_dos_setfileattr%@BO:       2f885@%%@BO:       78ef4@%
_dos_setftime%@BO:       2f970@%%@BO:       7a0f1@%
_dos_settime%@BO:       2fa12@%%@BO:       7b225@%
_dos_setvect%@BO:       2faf0@%%@BO:       7bea7@%
_dos_write%@BO:       2fb83@%%@BO:       7d8cd@%
Drive routines
  _chdrive%@BO:       59494@%
  _getdrive%@BO:       b269a@%
dup, dup2%@BO:       2266a@%%@BO:       7f42c@%
Dynamic allocation
   %@AI@%see%@AE@% Memory allocation%@NL@%; %@AI@%see%@AE@% %@NL@%

%@2@%%@AB@%    E%@AE@%%@EH@%%@NL@%
E2BIG%@BO:       347a0@%
EACCES%@BO:       34809@%
EBADF%@BO:       34873@%%@BO:      1896b7@%
ecvt%@BO:       13b03@%%@BO:       804d3@%
EDEADLOCK%@BO:       348dc@%
EDOM%@BO:       34946@%
EEXIST%@BO:       349b0@%
EINVAL%@BO:       34a1a@%
_ellipse, _ellipse_w, _ellipse_wxy%@BO:       18ef4@%%@BO:       8124d@%
Ellipses%@BO:        9639@%%@BO:        9721@%
EMFILE%@BO:       34a84@%
_enable%@BO:       2fc67@%%@BO:       82370@%
End-of-file
  indicators%@BO:       5ca40@%%@BO:       5ca41@%
  low-level I/O%@BO:       82c98@%
  stream I/O
    clearing%@BO:       5ca41@%%@BO:      12aa22@%
    described%@BO:       8d6cd@%
_endthread%@BO:       826f6@%
ENOENT%@BO:       34aee@%
ENOEXEC%@BO:       34b57@%
ENOMEM%@BO:       34bc0@%
ENOSPC%@BO:       34c2a@%%@BO:      1896b7@%
environ variable%@BO:       358aa@%%@BO:       35e51@%%@BO:       b30e9@%%@BO:      11c2c7@%
Environment variables
  described%@BO:       35b14@%
  getenv%@BO:       b2e59@%
  putenv%@BO:      11c2c7@%
EOF constant%@BO:       1e9f3@%
eof%@BO:       2271b@%%@BO:       82c98@%
ERANGE%@BO:       34c94@%
errno variable
  described%@BO:       33a2f@%
  error numbers%@BO:      101b0c@%%@BO:      164160@%
  I/O routines%@BO:       230d8@%
Error handling
  DOS error codes%@BO:       34328@%
  DOS system calls%@BO:       7e86e@%
  logic errors%@BO:       4023c@%
  perror%@BO:      101b0c@%
  strerror, _strerror%@BO:      164160@%
Error indicator
  described%@BO:       2218f@%%@BO:       5ca41@%
  ferror%@BO:       8e401@%
Error messages, user supplied%@BO:      101b0c@%%@BO:      164160@%
Euclidean distance%@BO:       cedec@%
exception type%@BO:       36ee4@%%@BO:       e96aa@%
EXDEV%@BO:       34cfe@%
exec family%@BO:       2970b@%%@BO:       83683@%
exit, _exit%@BO:       29563@%%@BO:       86d56@%
Exiting processes%@BO:       8711c@%
exp%@BO:       25658@%%@BO:       87d2c@%
_expand%@BO:       2719e@%%@BO:       885b0@%
expl%@BO:       25658@%%@BO:       87d2c@%
Exponential functions
  exp%@BO:       87d2c@%
  expl%@BO:       87d2c@%
  frexp%@BO:       a0510@%
  frexpl%@BO:       a0510@%
  ldexp%@BO:       d8378@%
  ldexpl%@BO:       d8378@%
  log, log10%@BO:       dfd78@%
  logl, log10%@BO:       dfd78@%
  pow%@BO:      113fdf@%
  powl%@BO:      113fdf@%
  sqrt%@BO:      158e76@%
  sqrtl%@BO:      158e76@%

%@2@%%@AB@%    F%@AE@%%@EH@%%@NL@%
fabs%@BO:       25658@%%@BO:       89c1a@%
fabsl%@BO:       25658@%%@BO:       89c1a@%
Far pointers%@BO:       97df4@%
_fcalloc%@BO:       545a7@%
fclose, fcloseall%@BO:       1ebae@%%@BO:       8a678@%
fcvt%@BO:       13b7e@%%@BO:       8b426@%
fdopen%@BO:       1ec9d@%%@BO:       8c296@%
feof%@BO:       1ecdb@%%@BO:       8d6cd@%
ferror%@BO:       1ed40@%%@BO:       8e19b@%
_fexpand%@BO:       885b0@%
fflush%@BO:       1ed9f@%%@BO:       8ebeb@%
_ffree%@BO:       276a4@%%@BO:       9c946@%
fgetc, fgetchar%@BO:       1ee42@%%@BO:       8f784@%
fgetpos%@BO:       1ef1a@%%@BO:       9047c@%
fgets%@BO:       1ef85@%%@BO:       912ee@%
_fheapchk%@BO:       272e1@%%@BO:       c991a@%
_fheapmin%@BO:       ca973@%
_fheapset%@BO:       272e1@%%@BO:       cb409@%
_fheapwalk%@BO:       272e1@%%@BO:       cc742@%
fieeetomsbin, fmsbintoieee%@BO:       261da@%
File handles
  duplication%@BO:       7f788@%
  functions%@BO:       22da0@%
  predefined%@BO:       234c8@%
  stream%@BO:       9304b@%
File handling
  access%@BO:       1494f@%%@BO:       3a5c1@%
  chmod%@BO:       149b0@%
  chsize%@BO:       14a25@%%@BO:       5b200@%
  filelength%@BO:       14a8c@%%@BO:       926b2@%
  fstat%@BO:       14af2@%%@BO:       a5f1d@%
  includefiles%@BO:       14831@%
  isatty%@BO:       14bf6@%%@BO:       d6045@%
  locking%@BO:       14c67@%%@BO:       de43b@%
  mktemp%@BO:       14dd5@%%@BO:       f4e71@%
  remove%@BO:       14e43@%
  rename%@BO:       14ea5@%%@BO:      129c8c@%
  setmode%@BO:       14f07@%%@BO:      13e0d5@%
  stat%@BO:       14fcf@%%@BO:      15b540@%
  umask%@BO:       15072@%%@BO:      17e930@%
  unlink%@BO:       150e4@%
File permission mask
   %@AI@%see%@AE@% Permission setting%@NL@%; %@AI@%see%@AE@% %@NL@%
File pointers
  defined%@BO:       21b4a@%
  positioning
    fgetpos%@BO:       9047b@%%@BO:       9047c@%
    fseek%@BO:       a1d74@%
    fsetpos%@BO:       a2f82@%
    ftell%@BO:       a7417@%
    lseek%@BO:       e3852@%
    read and write operations%@BO:       22f03@%
    rewind%@BO:      12aa22@%
    tell%@BO:      1783a0@%
File status information%@BO:       a5f1d@%%@BO:      15b540@%
FILE
  pointer%@BO:       1e472@%
  structure%@BO:       1e9f3@%
  type%@BO:       37083@%
filelength%@BO:       14a8c@%%@BO:       926b2@%
fileno%@BO:       1f03b@%%@BO:       9304b@%
Files
  changing size%@BO:       5b200@%
  closing%@BO:       23358@%%@BO:       5eb0e@%
  creating%@BO:       627fe@%%@BO:       fb18b@%%@BO:      150a9d@%
  deleting%@BO:      12943c@%%@BO:      181113@%
  determining length%@BO:       926b2@%
  locking%@BO:       de43b@%
  modifying names%@BO:       f4e71@%
  obtaining status%@BO:       a5f1d@%%@BO:      15b540@%
  opening
    creat%@BO:       627fe@%
    input and ouput%@BO:       22d08@%
    open%@BO:       fb18b@%
    sopen%@BO:      150a9d@%
  reading characters%@BO:      122083@%
  renaming%@BO:      129c8c@%
  setting modification time%@BO:      181f2f@%
  writing characters%@BO:      1890d4@%
find_t structure%@BO:       371fa@%
Floating point
  control word%@BO:       5f514@%
  errors%@BO:       9860c@%
  math package
    reinitialization%@BO:       9860c@%
    _clear87%@BO:       5c048@%
    _control87%@BO:       5f514@%
    _fpreset%@BO:       9860c@%
    _status87%@BO:      15c848@%
  numbers, conversion to strings%@BO:       808da@%%@BO:       8b426@%%@BO:       aaf0e@%
  status word%@BO:       5c048@%%@BO:      15c848@%
_floodfill, _floodfill_w%@BO:       190d6@%%@BO:       9386f@%
floor%@BO:       254e0@%%@BO:       94505@%
floorl%@BO:       254e0@%%@BO:       94505@%
flushall%@BO:       1f079@%%@BO:       94f64@%
Flushing buffers%@BO:       8ebeb@%%@BO:       94f64@%
_fmalloc%@BO:       272e1@%%@BO:       e6e95@%
_fmemccpy%@BO:       122a3@%%@BO:       ec066@%
_fmemchr%@BO:       123e4@%%@BO:       12499@%%@BO:       ecda0@%
_fmemcmp%@BO:       edc30@%
_fmemcpy%@BO:       12556@%%@BO:       eed69@%
_fmemicmp%@BO:       126af@%%@BO:       f024c@%
_fmemmove%@BO:       1277c@%%@BO:       f1c14@%
_fmemset%@BO:       128ad@%%@BO:       f2f06@%
fmod%@BO:       25658@%%@BO:       9574e@%
_fmode variable%@BO:       34df1@%
fmodl%@BO:       25658@%%@BO:       9574e@%
_fmsize%@BO:       272e1@%%@BO:       f9464@%
Fonts
  bit-mapped%@BO:      13a3cd@%
  functions (list)%@BO:       1aa61@%
fopen%@BO:       1f0d0@%%@BO:       960fb@%
Formatted I/O
  cprintf%@BO:       616a2@%
  cscanf%@BO:       63ba4@%
  fprintf%@BO:       99bc5@%
  fscanf%@BO:       a0fb2@%
  printf%@BO:      114bac@%
  scanf%@BO:      12d43e@%
  sprintf%@BO:      158291@%
  sscanf%@BO:      15a11e@%
  vfprintf, vprintf, vsprintf%@BO:      185753@%
fpos_t type%@BO:       373b8@%
_fpreset%@BO:       25658@%%@BO:       9860c@%
fprintf%@BO:       1f122@%%@BO:       99bc5@%
fputc, fputchar%@BO:       1f1de@%%@BO:       9a711@%
fputs%@BO:       1f2ac@%%@BO:       9b240@%%@BO:      11e787@%
FP_OFF, FP_SEG%@BO:       2fd3c@%%@BO:       97df4@%
fread%@BO:       1f30b@%%@BO:       9b98d@%
_frealloc%@BO:      1232cc@%
free%@BO:       272e1@%%@BO:       9c946@%
_freect%@BO:       272e1@%%@BO:       9dc9e@%%@BO:       9dc9f@%
freopen%@BO:       1f373@%%@BO:       9e7c6@%
frexp%@BO:       25756@%%@BO:       a0510@%
frexpl%@BO:       25756@%%@BO:       a0510@%
fscanf%@BO:       1f3e8@%%@BO:       a0fb2@%
fseek%@BO:       1f44e@%%@BO:       a1d74@%
fsetpos%@BO:       1f4b9@%%@BO:       a2f82@%
_fsopen%@BO:       1f524@%%@BO:       a3dcd@%
fstat%@BO:       14af2@%%@BO:       a5f1d@%
_fstrcat%@BO:      15d2ca@%
_fstrchr%@BO:      15dea7@%
_fstrcmp%@BO:      15efe7@%
_fstrcpy%@BO:      161247@%
_fstrcspn%@BO:      161e31@%
_fstrdup%@BO:      1632fa@%
_fstricmp%@BO:      166504@%
_fstrlen%@BO:      1670d7@%
_fstrlwr%@BO:      167955@%
_fstrncat%@BO:      168391@%
_fstrncmp%@BO:      169054@%
_fstrncpy%@BO:      16a270@%
_fstrnicmp%@BO:      16af7b@%
_fstrnset%@BO:      16ba58@%
_fstrpbrk%@BO:      16c4d6@%
_fstrrchr%@BO:      16d12b@%
_fstrrev%@BO:      16e1c9@%
_fstrset%@BO:      16ecbd@%
_fstrspn%@BO:      16f61a@%
_fstrstr%@BO:      170321@%
_fstrtok%@BO:      173766@%
_fstrupr%@BO:      1748f9@%
ftell%@BO:       1f588@%%@BO:       a7417@%
ftime%@BO:       31161@%%@BO:       a8413@%
_fullpath%@BO:       a92ae@%
fwrite%@BO:       1f638@%%@BO:       aa0ad@%

%@2@%%@AB@%    G%@AE@%%@EH@%%@NL@%
gcvt%@BO:       13bf9@%%@BO:       aaf0e@%
_getactivepage%@BO:       ab9ab@%
_getarcinfo%@BO:       ac3bd@%
_getbkcolor%@BO:       181c4@%%@BO:       ace01@%
getc, getchar%@BO:       1f676@%%@BO:       ad77e@%
getch, getche%@BO:       23efa@%%@BO:       ae3a8@%
_getcolor%@BO:       181c4@%%@BO:       aecbe@%
_getcurrentposition, _getcurrentposition_w%@BO:       191dc@%%@BO:       af82a@%
getcwd%@BO:       142cd@%%@BO:       b0741@%
_getdcwd%@BO:       b1454@%
_getdrive%@BO:       b269a@%
getenv%@BO:       b2b1c@%
_getfillmask%@BO:       18462@%%@BO:       b3a02@%
_getfontinfo%@BO:       b485e@%
_getgtextextent%@BO:       b518c@%
_getimage, _getimage_w, _getimage_wxy%@BO:       1a4b4@%%@BO:       b583d@%
_getlinestyle%@BO:       18353@%%@BO:       b6c31@%
_getphyscoord%@BO:       168aa@%%@BO:       b7a81@%
getpid%@BO:       29563@%%@BO:       b8114@%
_getpixel, _getpixel_w%@BO:       1925d@%%@BO:       b87db@%
gets%@BO:       1f731@%%@BO:       b9473@%
_gettextcolor%@BO:       19a65@%%@BO:       b9d16@%
_gettextcursor%@BO:       ba362@%
_gettextposition%@BO:       19a65@%%@BO:       ba84d@%
_gettextwindow%@BO:       bb7bf@%
_getvideoconfig%@BO:       160d5@%%@BO:       bbfe1@%
_getviewcoord, _getviewcoord_w, _getviewcoord_wxy%@BO:       168aa@%%@BO:       bdb56@%
_getvisualpage%@BO:       be80d@%
getw%@BO:       1f798@%%@BO:       beda4@%
_getwindowcoord%@BO:       168aa@%%@BO:       bf943@%
_getwritemode%@BO:       c006c@%
Global variables
  accessing%@BO:       327ea@%
  daylight%@BO:       33178@%%@BO:      17cabe@%
  environ%@BO:       358aa@%%@BO:       b30e9@%%@BO:      11c2c7@%
  errno
    described%@BO:       33a2f@%
    perror%@BO:      101b0c@%
    strerror%@BO:      164160@%
  sys_errlist
    described%@BO:       33a2f@%
    perror%@BO:      101b0c@%
    strerror%@BO:      164160@%
  sys_nerr%@BO:       33a2f@%%@BO:      101b0c@%%@BO:      164160@%
  timezone%@BO:       33178@%%@BO:      17cabe@%
  tzname%@BO:       33178@%%@BO:      17cabe@%
  _amblksiz%@BO:       32884@%
  _doserrno%@BO:       33a2f@%
  _fmode%@BO:       34df1@%
  _osmajor%@BO:       35126@%
  _osminor%@BO:       35126@%
  _psp%@BO:       35e51@%
gmtime%@BO:       31161@%%@BO:       c0ce8@%
Goto, nonlocal%@BO:       e156f@%%@BO:      13c096@%
Graphics
  attributes%@BO:       18353@%
  color selection%@BO:       18462@%%@BO:      135e2a@%
  configuration%@BO:       15f03@%%@BO:       1600b@%%@BO:      144c56@%%@BO:      149201@%
  coordinates%@BO:       167f1@%%@BO:       167f2@%%@BO:      137692@%%@BO:      147d5d@%%@BO:      1488df@%
  font functions (list)%@BO:       1b10b@%
  image transfer%@BO:       1a592@%%@BO:       1a593@%
  low-level palettes%@BO:       17b2b@%
  output%@BO:       8124d@%%@BO:       da793@%%@BO:       f874a@%%@BO:      124a3a@%
  parameters%@BO:      137fcb@%%@BO:      138d0f@%%@BO:      13c976@%
  presentation graphics%@BO:       1b669@%%@BO:       1b66a@%%@BO:       1be22@%%@BO:       1c06b@%%@BO:       1c06c@%%@BO:       1c4df@%%@BO:       1c4e0@%%@BO:       1c4e1@%%@BO:       1c4e2@%%@BO:       1c4e3@%%@BO:       1c4e4@%%@BO:       1c4e5@%%@BO:       1c4e6@%%@BO:      102b72@%
  text output%@BO:       19a65@%
  text support
    _gettextwindow%@BO:       bb7bf@%
    _scrolltextwindow%@BO:      131234@%
    _settextrows%@BO:      142997@%
    _settextwindow%@BO:      1432d5@%
    _setvideomoderows%@BO:      14728e@%
    _setwindow%@BO:      1497a8@%
    _wrapon%@BO:      188602@%
Greenwich mean time%@BO:       c0ce8@%
_grstatus%@BO:       c1c21@%

%@2@%%@AB@%    H%@AE@%%@EH@%%@NL@%
halloc%@BO:       277f2@%%@BO:       c5145@%
Handle
   %@AI@%see%@AE@% File handles%@NL@%; %@AI@%see%@AE@% %@NL@%
_harderr%@BO:       2fe27@%
_hardresume%@BO:       2fe8f@%
_hardretn%@BO:       2ff4a@%
Heap consistency check
  _bheapchk%@BO:       c991a@%
  _bheapmin%@BO:       ca973@%
  _fheapchk, _heapchk, _nheapchk%@BO:       c991a@%
  _fheapmin, _heapmin, _nheapmin%@BO:       ca973@%
_heapadd%@BO:       c81c1@%
_heapchk%@BO:       c991a@%
_heapmin%@BO:       ca973@%
_heapset%@BO:       cb409@%
_heapwalk%@BO:       cc742@%
hfree%@BO:       27b66@%%@BO:       ce4d5@%
Hyperbolic
  cosine%@BO:       60951@%
  sine%@BO:      14fd4f@%
  tangent%@BO:      1774d9@%
hypot%@BO:       25756@%%@BO:       cedec@%
Hypotenuse%@BO:       cedec@%
hypotl%@BO:       258bd@%%@BO:       cedec@%

%@2@%%@AB@%    I%@AE@%%@EH@%%@NL@%
I/O
  buffered%@BO:       1e73c@%
  console and port
    cgets%@BO:       23d2f@%%@BO:       56bc6@%
    cprintf%@BO:       23da4@%%@BO:       616a2@%
    cputs%@BO:       620f6@%
    cscanf%@BO:       23e7f@%%@BO:       63ba4@%
    described%@BO:       1d29b@%
    getch, getche%@BO:       23efa@%%@BO:       ae3a8@%
    include files%@BO:       23c11@%
    inp, inpw%@BO:       23ff5@%%@BO:       d03f6@%
    kbhit%@BO:       2411b@%%@BO:       d7327@%
    outp, outpw%@BO:       24196@%%@BO:       ff3fa@%
    putch%@BO:       242bb@%%@BO:      11bb1f@%
    ungetch%@BO:       24332@%%@BO:      180681@%
  low-level
    close%@BO:       221df@%%@BO:       5eb0e@%
    creat%@BO:       221df@%%@BO:       627fe@%
    described%@BO:       1d08b@%
    dup, dup2%@BO:       22415@%%@BO:       7f42c@%
    eof%@BO:       22415@%%@BO:       82c98@%
    error handling%@BO:       230d8@%
    include files%@BO:       22557@%
    lseek%@BO:       22415@%%@BO:       e3852@%
    open%@BO:       22415@%%@BO:       fb18b@%
    read%@BO:       22415@%%@BO:      122083@%
    sopen%@BO:       22415@%%@BO:      150a9d@%
    tell%@BO:       22415@%%@BO:      1783a0@%
    write%@BO:       22557@%%@BO:      1890d4@%
  stream%@BO:       1cf67@%%@BO:       1e2b4@%
IEEE format, converting double-precision to Microsoft binary%@BO:       67566@%
_imagesize, _imagesize_w, _imagesize_wxy%@BO:       1a4b4@%%@BO:       cf7e9@%
Include files
  buffer manipulation routines%@BO:       11f9c@%
  character classification, conversion%@BO:       1365b@%
  console and port I/O%@BO:       23c11@%
  data conversion%@BO:       136c7@%
  directory control%@BO:       14125@%
  DOS interface routines%@BO:       30440@%
  file handling%@BO:       14831@%
  low-level I/O%@BO:       22557@%
  math routines%@BO:       2519d@%
  memory allocation%@BO:       27159@%
  naming conventions%@BO:        6ead@%
  process control%@BO:       29920@%
  processor calls%@BO:       30ad2@%
  searching and sorting%@BO:       2c9a9@%
  stream I/O%@BO:       1e2b4@%
  string manipulation%@BO:       2cd6b@%
  time routines%@BO:       31b62@%%@BO:       31d49@%
inp, inpw%@BO:       23ff5@%%@BO:       2473c@%%@BO:       d03f6@%
int86%@BO:       2ff90@%%@BO:       d0cdb@%
int86x%@BO:       3003d@%%@BO:       d1ad3@%
intdos%@BO:       300db@%%@BO:       d2b37@%
intdosx%@BO:       301c3@%%@BO:       d385f@%
Integers
  conversion to strings%@BO:       d6757@%
  long, conversion to strings%@BO:       e4b07@%%@BO:      17ddcc@%
Interrupt signals%@BO:      14baa8@%
Interrupts
   %@AI@%see%@AE@% DOS interrupts, invoking%@NL@%; %@AI@%see%@AE@% %@NL@%
IO.H%@BO:       14831@%%@BO:       22557@%
isalnum, isdigit, isgraph%@BO:       12c50@%%@BO:       d4727@%
isalpha, isascii, iscntrl%@BO:       d4727@%
isatty%@BO:       14bf6@%%@BO:       d6045@%
isdigit%@BO:       d481b@%
islower, isupper, isxdigit%@BO:       12e6c@%%@BO:       d4727@%
isprint%@BO:       12edf@%%@BO:       d4727@%
ispunct%@BO:       12f52@%%@BO:       d4727@%
isspace%@BO:       12fc7@%%@BO:       d4727@%
Italic letters, use of%@BO:        926e@%
itoa%@BO:       13c74@%%@BO:       d6757@%

%@2@%%@AB@%    J%@AE@%%@EH@%%@NL@%
j0, j1, jn%@BO:       4687d@%
_j0l, _j1l, _jnl%@BO:       4687d@%
jmp_buf type%@BO:       375b1@%

%@2@%%@AB@%    K%@AE@%%@EH@%%@NL@%
kbhit%@BO:       2411b@%%@BO:       d7327@%
Keystroke, testing%@BO:       d7327@%

%@2@%%@AB@%    L%@AE@%%@EH@%%@NL@%
labs%@BO:       d7ae9@%
ldexpl%@BO:       258bd@%%@BO:       d8378@%
ldiv%@BO:       d8c97@%
ldiv_t type%@BO:       3694e@%
lfind%@BO:       2cbcd@%%@BO:       d97d3@%
Lines
  reading%@BO:       912ee@%%@BO:       b9473@%
  writing%@BO:      11e787@%
_lineto%@BO:       192c2@%%@BO:       da793@%
_lineto_w%@BO:       192c2@%%@BO:       da793@%
Local time corrections%@BO:       334e3@%%@BO:       dd211@%%@BO:      17cabe@%
localeconv%@BO:       db3cb@%
Localization
  localeconv%@BO:       db3cb@%
  setlocale%@BO:      13d015@%
localtime%@BO:       31161@%%@BO:       dd211@%
locking%@BO:       14c67@%%@BO:       de43b@%
log, log10%@BO:       dfd78@%
Logarithmic functions%@BO:       258bd@%%@BO:       dfd78@%
logl, log10l%@BO:       dfd78@%
Long integers, conversion to strings%@BO:       e4b07@%
longjmp%@BO:       e156f@%
Low-level graphics
   %@AI@%see also%@AE@% %@AI@%individual function names%@AE@%%@NL@%; %@AI@%see also%@AE@% %@NL@%
  color selection%@BO:       17b2b@%%@BO:       18462@%
  configuration%@BO:       15f03@%
  coordinates%@BO:       167f1@%%@BO:       167f2@%
  font functions. See Fonts%@BO:       b485e@%
  image transfer%@BO:       1a592@%%@BO:       1a593@%
  output
    _arc, _arc_w, _arc_wxy%@BO:       18fcd@%%@BO:       3cdec@%
    _ellipse, _ellipse_w, _ellipse_wxy%@BO:       18e2e@%%@BO:       8124d@%
    _getarcinfo%@BO:       ac3bd@%
    _getwritemode%@BO:       c006c@%
    _grstatus%@BO:       c1c21@%
    _lineto, _lineto_w%@BO:       192c2@%%@BO:       da793@%
    _pie, _pie_w, _pie_wxy%@BO:       19464@%%@BO:      10e980@%
    _polygon, _polygon_w, _polygon_wxy%@BO:      111e61@%
    _rectangle, _rectangle_w, _rectangle_wxy%@BO:       195e6@%%@BO:      124a3a@%
    _setwritemode%@BO:      14b3ae@%
  palettes%@BO:       17b2b@%
  parameters%@BO:       18462@%
  physical coordinates%@BO:       1672b@%
  text support (list)%@BO:       19a65@%
  view coordinates%@BO:       1672b@%
  window coordinates%@BO:       1672b@%
_lrotl%@BO:       e238d@%
_lrotr%@BO:       e238d@%
lsearch%@BO:       2cc49@%%@BO:       e2c09@%
lseek%@BO:       22773@%%@BO:       e3852@%
ltoa%@BO:       13d4c@%%@BO:       e4b07@%

%@2@%%@AB@%    M%@AE@%%@EH@%%@NL@%
_makepath%@BO:       e56f2@%
malloc%@BO:       27c43@%%@BO:       e6e95@%
MALLOC.H%@BO:       27159@%
Mask
   %@AI@%see%@AE@% Permission setting%@NL@%; %@AI@%see%@AE@% %@NL@%
MATH.H%@BO:       136c7@%%@BO:       2519d@%
matherr
  described%@BO:       e9287@%
  use%@BO:       258bd@%
matherrl%@BO:       e9287@%
max%@BO:       eae22@%
_memavl%@BO:       27c99@%%@BO:       eb560@%
memccpy%@BO:       122a3@%%@BO:       ec066@%
memchr%@BO:       123e4@%%@BO:       ecda0@%
memcmp%@BO:       12499@%%@BO:       edc30@%
memcpy%@BO:       12556@%%@BO:       eed69@%
memicmp%@BO:       126af@%%@BO:       f024c@%
_memmax%@BO:       27d6f@%%@BO:       f1208@%
memmove%@BO:       1277c@%%@BO:       f1c14@%
Memory allocation
  available memory, determination%@BO:       9dc9f@%
  calloc%@BO:       545a7@%
  free%@BO:       9c946@%
  halloc%@BO:       c5145@%
  hfree%@BO:       ce4d5@%
  malloc%@BO:       e6e95@%
  realloc%@BO:      1232cc@%
  routines and uses (list)%@BO:       2719e@%
  stackavail%@BO:      15ad33@%
  _amblksiz%@BO:       329d5@%
  _bcalloc%@BO:       545a7@%
  _bfree%@BO:       9c946@%
  _bfreeseg%@BO:       47d29@%
  _bheapadd%@BO:       c81c1@%
  _bheapchk%@BO:       c991a@%
  _bheapmin%@BO:       ca973@%
  _bheapseg%@BO:       48c44@%
  _bheapset%@BO:       cb409@%
  _bheapwalk%@BO:       cc742@%
  _bmalloc%@BO:       e6e95@%
  _bmsize%@BO:       f9464@%
  _brealloc%@BO:      1232cc@%
  _expand%@BO:       885b0@%
  _fcalloc%@BO:       545a7@%
  _ffree%@BO:       9c946@%
  _fheapchk%@BO:       c991a@%
  _fheapmin%@BO:       ca973@%
  _fheapset%@BO:       cb409@%
  _fheapwalk%@BO:       cc742@%
  _fmalloc%@BO:       e6e95@%
  _fmsize%@BO:       f9464@%
  _frealloc%@BO:      1232cc@%
  _freect%@BO:       9dc9f@%
  _heapadd%@BO:       c81c1@%
  _heapchk%@BO:       c991a@%
  _heapmin%@BO:       ca973@%
  _heapset%@BO:       cb409@%
  _heapwalk%@BO:       cc742@%
  _memavl%@BO:       eb560@%
  _memmax%@BO:       f1208@%
  _msize%@BO:       f9464@%
  _ncalloc%@BO:       545a7@%
  _nfree%@BO:       9c946@%
  _nheapchk%@BO:       c991a@%
  _nheapmin%@BO:       ca973@%
  _nheapset%@BO:       cb409@%
  _nheapwalk%@BO:       cc742@%
  _nmalloc%@BO:       e6e95@%
  _nmsize%@BO:       f9464@%
  _nrealloc%@BO:      1232cc@%
MEMORY.H%@BO:       11f9c@%
memset%@BO:       1284f@%%@BO:       f2f06@%
Microsoft Windows%@BO:       15e57@%
min%@BO:       f3acc@%
mkdir%@BO:       14415@%%@BO:       f4209@%
mktemp%@BO:       14dd5@%%@BO:       f4e71@%
mktime%@BO:       31161@%%@BO:       f5fbd@%
Model-independent memory routines%@BO:       120b0@%
modf%@BO:       258bd@%%@BO:       f6ebe@%
modfl%@BO:       258bd@%%@BO:       f6ebe@%
Modification time%@BO:      181f2f@%
Monofont, use of%@BO:        9538@%
movedata%@BO:       f78e7@%
_moveto%@BO:       193a3@%%@BO:       f874a@%
_moveto_w%@BO:       193a3@%%@BO:       f874a@%
MS C 4.0, differences
  fputs%@BO:       9b591@%
  puts%@BO:      11eab8@%
_msize%@BO:       27e87@%%@BO:       f9464@%

%@2@%%@AB@%    N%@AE@%%@EH@%%@NL@%
_ncalloc%@BO:       545a7@%
NDEBUG%@BO:       4023c@%
_nexpand%@BO:       885b0@%
_nfree%@BO:       272e1@%%@BO:       9c946@%
_nheapchk%@BO:       27a49@%%@BO:       c991a@%
_nheapmin%@BO:       ca973@%
_nheapset%@BO:       27a49@%%@BO:       cb409@%
_nheapwalk%@BO:       27a49@%%@BO:       cc742@%
_nmalloc%@BO:       27c43@%%@BO:       e6e95@%
_nmsize%@BO:       2719e@%%@BO:       f9464@%
Nonlocal goto%@BO:       e156f@%%@BO:      13c096@%
_nrealloc%@BO:      1232cc@%
_nstrdup%@BO:      1632fa@%
Null pointer%@BO:       1e9f3@%

%@2@%%@AB@%    O%@AE@%%@EH@%%@NL@%
oflag
   %@AI@%see%@AE@% Open flag%@NL@%; %@AI@%see%@AE@% %@NL@%
onexit%@BO:       2970b@%%@BO:       fa5ff@%
Open flag%@BO:       fb68c@%%@BO:      150a9d@%
open%@BO:       22805@%%@BO:       fb18b@%%@BO:      13e0d5@%
Optional items%@BO:        9302@%
_osmajor variable%@BO:       35126@%
_osminor variable%@BO:       35126@%
_outgtext%@BO:       1aa61@%%@BO:       fd735@%
_outmem%@BO:       feb25@%
outp, outpw%@BO:       24196@%%@BO:       2473c@%%@BO:       ff3fa@%
Output
   %@AI@%see%@AE@% I/O%@NL@%; %@AI@%see%@AE@% %@NL@%
_outtext%@BO:       19a65@%%@BO:      1005e1@%
OVERFLOW%@BO:       e9b99@%
Overlapping moves%@BO:       ef1e1@%
Overlay, of parent process%@BO:      1538fb@%
O_BINARY%@BO:       34df1@%

%@2@%%@AB@%    P%@AE@%%@EH@%%@NL@%
Palettes, low-level%@BO:       17b2b@%
Parameters, variable-length number%@BO:       32325@%%@BO:      185753@%
Parent process
  cwait%@BO:       654e7@%
  described%@BO:       83683@%
  overlay and suspension%@BO:      1538fb@%
  wait%@BO:      186a5f@%
_pclose%@BO:      10130f@%
Permission setting
  access%@BO:       3a8dd@%
  changing%@BO:       5a336@%
  described%@BO:       62ddd@%
  mask%@BO:      17e930@%
  open%@BO:       fb18b@%
  sopen%@BO:      150a9d@%
  umask%@BO:      17e930@%
perror%@BO:      101b0c@%
_pg_analyzechart%@BO:       1bf93@%%@BO:      102b72@%
_pg_analyzechartms%@BO:       1bf93@%%@BO:      102b72@%
_pg_analyzepie%@BO:       1be22@%%@BO:      10443a@%
_pg_analyzescatter%@BO:      104c67@%
_pg_analyzescatterms%@BO:       1be22@%%@BO:      104c67@%
_pg_chart%@BO:       1b4f8@%%@BO:      10592f@%
_pg_chartms%@BO:       1b4f8@%%@BO:      10592f@%
_pg_chartpie%@BO:       1b66a@%%@BO:      107b70@%
_pg_chartscatter%@BO:       1b4f8@%%@BO:      106f98@%
_pg_chartscatterms%@BO:       1b4f8@%%@BO:      106f98@%
_pg_defaultchart%@BO:       1b439@%%@BO:      10854b@%
_pg_getchardef%@BO:       1caf4@%%@BO:      10941d@%
_pg_getpalette%@BO:       1c3bf@%%@BO:      109988@%
_pg_getstyleset%@BO:       1c3bf@%%@BO:      10b3a1@%
_pg_hlabelchart%@BO:       1c3bf@%%@BO:      10b852@%
_pg_initchart%@BO:       1b439@%%@BO:      10bf4c@%
_pg_resetpalette%@BO:       1c3bf@%%@BO:      10c741@%
_pg_resetstyleset%@BO:       1c4e6@%%@BO:      10cd38@%
_pg_setchardef%@BO:       1cb9e@%%@BO:      10d1ac@%
_pg_setpalette%@BO:       1c3bf@%%@BO:      10d73e@%
_pg_setstyleset%@BO:       1c4e6@%%@BO:      10ddf2@%
_pg_vlabelchart%@BO:       1c3bf@%%@BO:      10e28b@%
_pie, _pie_w, _pie_wxy%@BO:       19464@%%@BO:      10e980@%
_pipe%@BO:      10fdd0@%
Pipes
  _pclose%@BO:      10130f@%
  _pipe%@BO:      10fdd0@%
  _popen%@BO:      113018@%
PLOSS%@BO:       e9bf1@%
Pointers, long%@BO:       97df4@%
_polygon, _polygon_w, _polygon_wxy%@BO:      111e61@%
_popen%@BO:      113018@%
Port I/O
   %@AI@%see%@AE@% I/O, console and port%@NL@%; %@AI@%see%@AE@% %@NL@%
pow%@BO:       258bd@%%@BO:      113fdf@%
Predefined
  handles%@BO:       234c8@%
  stream pointers%@BO:       2063b@%
  types. See Standard types%@BO:       327ea@%
printf%@BO:       1f80d@%%@BO:      114bac@%
Printing
   %@AI@%see%@AE@% Write operations%@NL@%; %@AI@%see%@AE@% %@NL@%
Process control
  abort%@BO:       29437@%%@BO:       39232@%
  atexit%@BO:       29437@%%@BO:       418cf@%
  cwait%@BO:       654e7@%
  exec family%@BO:       2970b@%
  exit, _exit%@BO:       29437@%%@BO:       86d56@%
  getpid%@BO:       29563@%%@BO:       b8114@%
  include files%@BO:       29920@%
  onexit%@BO:       29563@%%@BO:       fa5ff@%
  raise%@BO:       29563@%%@BO:      120a5a@%
  signal%@BO:       29563@%%@BO:      14baa8@%
  spawn family%@BO:       2970b@%
  system%@BO:       29563@%%@BO:      17650f@%
  wait%@BO:      186a5f@%
  _cexit, _c_exit%@BO:       561c1@%
Process ID%@BO:       b8114@%
PROCESS.H%@BO:       29920@%
Processor calls, include files%@BO:       30ad2@%
Program segment prefix (PSP)%@BO:       36105@%
Pseudorandom integers%@BO:      12180b@%%@BO:      15975f@%
_psp%@BO:       35e51@%
putc, putchar%@BO:       1f8ca@%%@BO:      11b0aa@%
putch%@BO:       242bb@%%@BO:      11bb1f@%
putenv%@BO:      11c2c7@%
_putimage, _putimage_w%@BO:       1a4b4@%%@BO:      11d5f5@%
puts%@BO:       1f936@%
putw%@BO:       1f993@%%@BO:      11ee6f@%

%@2@%%@AB@%    Q%@AE@%%@EH@%%@NL@%
qsort%@BO:       2ccfb@%%@BO:      11f997@%
Quick sort algorithm%@BO:      11f997@%
Quotation marks, use of%@BO:        9a92@%

%@2@%%@AB@%    R%@AE@%%@EH@%%@NL@%
R eallocation
  _freal loc%@BO:      1232cc@%
raise%@BO:       2970b@%%@BO:      120a5a@%
rand%@BO:      12180b@%
Random access
  fgetpos%@BO:       9047c@%
  fseek%@BO:       a1d74@%
  fsetpos%@BO:       a2f82@%
  ftell%@BO:       a7417@%
  lseek%@BO:       e3852@%
  rewind%@BO:      12aa22@%
  tell%@BO:      1783a0@%
Random number generator%@BO:      12180b@%%@BO:      15975f@%
Read access
   %@AI@%see%@AE@% Permission setting%@NL@%; %@AI@%see%@AE@% %@NL@%
Read operations
  binary int value%@BO:       beda4@%
  characters 
    from file%@BO:      122083@%
    from stdin%@BO:       8f784@%%@BO:       ad77e@%
    from stream%@BO:       8f784@%%@BO:       ad77e@%
  formatted
    cscanf%@BO:       63ba4@%
    fscanf%@BO:       a0fb2@%
    scanf%@BO:      12d43e@%
    sscanf%@BO:      15a11e@%
  from console
    cgets%@BO:       56bc6@%
    cscanf%@BO:       63ba4@%
    getch%@BO:       ae3a8@%
    keystroke checking%@BO:       d7327@%
  from port%@BO:       d03f6@%
  line 
    from stdin%@BO:       b9473@%
    from stream%@BO:       912ee@%
read%@BO:       22854@%%@BO:      122083@%
realloc%@BO:       27f44@%%@BO:      1232cc@%
Reallocation
  realloc%@BO:       27eca@%%@BO:      1232cc@%
  _brealloc%@BO:      1232cc@%
  _expand%@BO:       885b0@%
  _frealloc Reallocate memory blocks. 
    HO = @L2C1 =%@BO:      1233ec@%
  _nrealloc%@BO:      1233bf@%
_rectangle, _rectangle_w, _rectangle_wxy%@BO:       195e6@%%@BO:      124a3a@%
Redirection%@BO:       20d6e@%%@BO:       2387f@%%@BO:       2399b@%%@BO:       9ec68@%
_registerfonts%@BO:       1aa61@%%@BO:      125bda@%
REGS type%@BO:       379f2@%
Remainder function%@BO:       9574e@%
_remapallpalette%@BO:       17ab4@%%@BO:      1266a2@%
_remappalette%@BO:       17ab4@%%@BO:      1266a2@%
remove%@BO:       14e43@%%@BO:      12943c@%
rename%@BO:       14ea5@%%@BO:      129c8c@%
Reversing strings%@BO:      16e1c9@%
rewind%@BO:       1fa5c@%%@BO:      12aa22@%
rmdir%@BO:       14480@%%@BO:      12b5ce@%
rmtmp%@BO:       1faf8@%%@BO:      12c19f@%
_rotl%@BO:      12cb67@%
_rotr%@BO:      12cb67@%

%@2@%%@AB@%    S%@AE@%%@EH@%%@NL@%
scanf%@BO:       1fb43@%%@BO:      12d43e@%
Scanning
   %@AI@%see%@AE@% Read operations%@NL@%; %@AI@%see%@AE@% %@NL@%
_scrolltextwindow%@BO:      131234@%
SEARCH.H%@BO:       2ca66@%
_searchenv%@BO:      1324eb@%
Searching and sorting
  bsearch%@BO:       2cb61@%%@BO:       52757@%
  include files%@BO:       2c9a9@%
  lfind%@BO:       d97d3@%
  lfind, lsearch%@BO:       2cbcd@%
  lsearch%@BO:       e2c09@%
  qsort%@BO:       2ccfb@%%@BO:      11f997@%
seed%@BO:      15975f@%
Segment registers%@BO:      1330d6@%
segread%@BO:       3025b@%%@BO:      1330d6@%
_selectpalette%@BO:       17c69@%%@BO:      13399f@%
_setactivepage%@BO:       1600b@%%@BO:      134fdb@%
_setbkcolor%@BO:       181c4@%%@BO:      135e2a@%
setbuf%@BO:       1fbb2@%%@BO:       21387@%%@BO:      136a2a@%
_setcliprgn%@BO:      137692@%
_setcolor%@BO:       181c4@%%@BO:      137fcb@%
_setfillmask%@BO:       18353@%%@BO:      138d0f@%
_setfont%@BO:       1aa61@%%@BO:      1399df@%
_setgtextvector%@BO:      13b707@%
setjmp%@BO:      13c096@%
_setlinestyle%@BO:       181c4@%%@BO:      13c976@%
setlocale%@BO:      13d015@%
setmode%@BO:       14f07@%%@BO:      13e0d5@%
_setpixel, _setpixel_w%@BO:       1963c@%%@BO:      13f062@%
_settextcolor%@BO:       19a65@%%@BO:      13fc58@%
_settextcursor%@BO:      140f54@%
_settextposition%@BO:      141af8@%
_settextrows%@BO:      142997@%
_settextwindow%@BO:       19a65@%%@BO:      1432d5@%
setvbuf%@BO:       1fc63@%%@BO:       21387@%
_setvideomode%@BO:       1600b@%%@BO:      144c56@%
_setvideomoderows%@BO:      14728e@%
_setvieworg%@BO:       167f2@%%@BO:      147d5d@%
_setviewport%@BO:       168aa@%%@BO:      1488df@%
_setvisualpage%@BO:       160d5@%%@BO:      149201@%
_setwindow%@BO:       168aa@%%@BO:      1497a8@%
_setwritemode%@BO:      14b3ae@%
SIGNAL.H%@BO:       29920@%
signal
  described%@BO:       2970b@%%@BO:      14baa8@%
Signal
  raise%@BO:      120a5a@%
sin, sinh%@BO:       258bd@%%@BO:      14fd4f@%
Sine%@BO:      14fd4f@%
SING%@BO:       e9b2e@%
sinl, sinhl%@BO:       259b4@%%@BO:      14fd4f@%
size_t type%@BO:       37d26@%
Small capital letters, use of%@BO:        992d@%
sopen%@BO:       228ad@%%@BO:      150a9d@%
Sorting
   %@AI@%see%@AE@% Searching and sorting%@NL@%; %@AI@%see%@AE@% %@NL@%
spawn family
  argument-type-checking limitations%@BO:      15314f@%
  described%@BO:      15314f@%
  use%@BO:       2970b@%
_splitpath%@BO:      157346@%
sprintf%@BO:      158291@%
sqrt%@BO:       259b4@%%@BO:      158e76@%
sqrtl%@BO:       259b4@%%@BO:      158e76@%
Square-root function%@BO:      158e76@%
srand%@BO:      15975f@%
SREGS type%@BO:       37f20@%
sscanf
  described%@BO:      15a11e@%
  use%@BO:       1fcf0@%
Stack environment
  restoring%@BO:       e156f@%
  saving%@BO:      13c096@%
stackavail%@BO:       27f87@%%@BO:      15ad33@%
Standard auxiliary
   %@AI@%see%@AE@% stdaux%@NL@%; %@AI@%see%@AE@% %@NL@%
Standard error
   %@AI@%see%@AE@% stderr%@NL@%; %@AI@%see%@AE@% %@NL@%
Standard input
   %@AI@%see%@AE@% stdin%@NL@%; %@AI@%see%@AE@% %@NL@%
Standard output
   %@AI@%see%@AE@% stdout%@NL@%; %@AI@%see%@AE@% %@NL@%
Standard print
   %@AI@%see%@AE@% stdprn%@NL@%; %@AI@%see%@AE@% %@NL@%
Standard types
  clock_t%@BO:       36403@%
  complex%@BO:       3655a@%
  diskfree_t%@BO:       3666d@%
  diskinfo_t%@BO:       367dc@%
  div_t%@BO:       3694e@%
  dosdate_t%@BO:       36acd@%
  DOSERROR%@BO:       36d83@%%@BO:       7e940@%
  dostime_t%@BO:       36c28@%
  exceptions%@BO:       36ee4@%%@BO:       e96aa@%
  FILE%@BO:       37083@%
  find_t%@BO:       371fa@%
  fpos_t%@BO:       373b8@%
  jmp_buf%@BO:       375b1@%
  ldiv_t%@BO:       3694e@%
  listed%@BO:       36265@%
  REGS%@BO:       379f2@%
  size_t%@BO:       37d26@%
  SREGS%@BO:       37f20@%
  stat%@BO:      15b540@%
  timeb%@BO:       382e5@%%@BO:       a8728@%
  time_t%@BO:       3818d@%%@BO:       67dbe@%
  tm%@BO:       38450@%%@BO:       c0ce8@%
  utimbuf%@BO:       385f5@%%@BO:      181f2f@%
  va_list%@BO:       3883b@%
stat routine
  described%@BO:      15b540@%
  use%@BO:       14fcf@%
stat type
  described%@BO:       38084@%
  fstat%@BO:       a61ff@%
_status87%@BO:      15c848@%
stdaux, stderr, stdin
  buffering%@BO:       21099@%
  described%@BO:       20814@%
  file handle%@BO:       2355e@%
  translation mode, changing%@BO:      13e872@%
STDIO.H%@BO:       1e2b4@%
stdout, stdprn
  buffering%@BO:       21099@%
  described%@BO:       20814@%
  file handle%@BO:       2355e@%
  translation mode, changing%@BO:      13e872@%
strcat%@BO:       2d1c2@%%@BO:      15d2ca@%
strchr%@BO:       2d22d@%%@BO:      15dea7@%
strcmp%@BO:       2d2d5@%%@BO:      15efe7@%
strcoll%@BO:      1609bb@%%@BO:      165270@%
strcpy%@BO:       2d337@%%@BO:      161247@%
strcspn%@BO:       2d069@%%@BO:      161e31@%
_strdate%@BO:       31161@%%@BO:       31f61@%%@BO:      162a58@%
strdup%@BO:       2d069@%%@BO:      1632fa@%
Stream I/O
   %@AI@%see also%@AE@% I/O, console and port%@NL@%; %@AI@%see also%@AE@% %@NL@%
  buffering%@BO:       21099@%
  clearerr%@BO:       5ca41@%
  described%@BO:       1cf67@%
  error handling%@BO:       2218f@%
  fclose, fcloseall%@BO:       8a678@%
  fdopen%@BO:       8c296@%
  feof%@BO:       8d6cd@%
  ferror%@BO:       8e19b@%
  fflush%@BO:       8ebeb@%
  fgetc, fgetchar%@BO:       8f784@%
  fgetpos%@BO:       9047c@%
  fgets%@BO:       912ee@%
  fileno%@BO:       9304b@%
  flushall%@BO:       94f64@%
  fopen%@BO:       960fb@%
  fprintf%@BO:       99bc5@%
  fputc, fputchar%@BO:       9a711@%
  fputs%@BO:       9b240@%%@BO:      11e787@%
  fread%@BO:       9b98d@%
  freopen%@BO:       9e7c6@%
  fscanf%@BO:       a0fb2@%
  fseek%@BO:       a1d74@%
  fsetpos%@BO:       a2f82@%
  ftell%@BO:       a7417@%
  fwrite%@BO:       aa0ad@%
  getc, getchar%@BO:       ad77e@%
  gets%@BO:       b9473@%
  getw%@BO:       beda4@%
  printf%@BO:      114bac@%
  putc, putchar%@BO:      11b0aa@%
  putw%@BO:      11ee6f@%
  rewind%@BO:      12aa22@%
  routines and uses (list)%@BO:       1e2b4@%
  scanf%@BO:      12d43e@%
  setbuf%@BO:      136a2a@%
  sprintf%@BO:      158291@%
  sscanf%@BO:      15a11e@%
  tempnam, tmpnam%@BO:       1e2b4@%
  ungetc%@BO:      17f6e0@%
  vfprintf, vprintf, vsprintf%@BO:      185753@%
  _fsopen%@BO:       a3dcd@%
Stream pointer%@BO:       1e472@%
Streams
  appending%@BO:       960fb@%%@BO:       9e7c6@%%@BO:       a3dcd@%
  buffering%@BO:      136a2a@%
  clearing errors%@BO:       5ca41@%
  closing%@BO:       217d7@%%@BO:       8a678@%
  file handles for%@BO:       9304b@%
  file pointer position
    fseek%@BO:       a1d74@%
    fsetpos%@BO:       a2f82@%
    ftell%@BO:       a7417@%
    getpos%@BO:       9047c@%
    rewind%@BO:      12aa22@%
  formatted I/O
    printf%@BO:      114bac@%
    scanf%@BO:      12d43e@%
    sprintf%@BO:      158291@%
    sscanf%@BO:      15a11e@%
    stream%@BO:       99bc5@%%@BO:       a0fb2@%
    vprintf%@BO:      185753@%
  opening%@BO:       20159@%%@BO:       8c296@%%@BO:       960fb@%%@BO:       a3dcd@%
  reading
    binary int value%@BO:       beda4@%
    characters%@BO:       8f784@%%@BO:       ad77e@%
    data items%@BO:       9b98d@%
    lines%@BO:       912ee@%%@BO:       b9473@%
  reopening%@BO:       9e7c6@%
  rewinding%@BO:      12aa22@%
  stdaux, stderr, stdin%@BO:       2063b@%
  stdout, stdprn%@BO:       2063b@%
  translation mode. See Binary, mode%@BO:       a4b2f@%
  ungetting characters%@BO:      17f6e0@%
  writing
    binary int value%@BO:      11ee6f@%
    characters%@BO:       9a711@%%@BO:      11b0aa@%
    data items%@BO:       aa0ad@%
    lines%@BO:      11e787@%
    strings%@BO:       9b240@%
strerror%@BO:       2d069@%%@BO:      164160@%
_strerror%@BO:      164160@%
strftime%@BO:      165270@%
stricmp%@BO:       2ce64@%%@BO:      166504@%
String manipulation
  routines and uses (list)%@BO:       2ce64@%
  strcat%@BO:      15d2ca@%
  strchr%@BO:      15dea7@%
  strcmp%@BO:      15efe7@%
  strcoll%@BO:      1609bb@%%@BO:      165270@%
  strcpy%@BO:      161247@%
  strcspn%@BO:      161e31@%
  strdup%@BO:      1632fa@%
  stricmp%@BO:      166504@%
  strlwr%@BO:      167955@%
  strncat%@BO:      168391@%
  strncmp%@BO:      169054@%
  strncpy%@BO:      16a270@%
  strnicmp%@BO:      16af7b@%
  strnset%@BO:      16ba58@%
  strpbrk%@BO:      16c4d6@%
  strrchr%@BO:      16d12b@%
  strrev%@BO:      16e1c9@%
  strset%@BO:      16ecbd@%
  strspn%@BO:      16f61a@%
  strstr%@BO:      170321@%
  strtok%@BO:      173766@%
  strupr%@BO:      1748f9@%
  strxfrm%@BO:      1752a5@%
  _fstrcat%@BO:      15d2ca@%
  _fstrchr%@BO:      15dea7@%
  _fstrcmp%@BO:      15efe7@%
  _fstrcpy%@BO:      161247@%
  _fstrcspn%@BO:      161e31@%
  _fstrdup%@BO:      1632fa@%
  _fstricmp%@BO:      166504@%
  _fstrlwr%@BO:      167955@%
  _fstrncat%@BO:      168391@%
  _fstrncmp%@BO:      169054@%
  _fstrncpy%@BO:      16a270@%
  _fstrnicmp%@BO:      16af7b@%
  _fstrnset%@BO:      16ba58@%
  _fstrpbrk%@BO:      16c4d6@%
  _fstrrchr%@BO:      16d12b@%
  _fstrrev%@BO:      16e1c9@%
  _fstrset%@BO:      16ecbd@%
  _fstrspn%@BO:      16f61a@%
  _fstrstr%@BO:      170321@%
  _fstrtok%@BO:      173766@%
  _fstrupr%@BO:      1748f9@%
  _nstrdup%@BO:      1632fa@%
STRING.H%@BO:       2ce64@%
Strings
  comparing%@BO:      15efe7@%%@BO:      160128@%%@BO:      1609bb@%%@BO:      165270@%%@BO:      166504@%%@BO:      169054@%%@BO:      16af7b@%
  concatenating%@BO:      168391@%
  converting 
    to floating-point values%@BO:       429d6@%
    to lowercase%@BO:      167955@%
    to uppercase%@BO:      1748f9@%
  copying%@BO:      161247@%%@BO:      1632fa@%%@BO:      16a270@%
  initializing%@BO:      16ba58@%%@BO:      16ecbd@%
  reading from console%@BO:       56bc6@%
  reversing%@BO:      16e1c9@%
  searching
    strchr%@BO:      15dea7@%
    strcspn%@BO:      161e31@%
    strpbrk%@BO:      16c4d6@%
    strrchr%@BO:      16d12b@%
    strspn%@BO:      16f61a@%
    strstr%@BO:      170321@%
    strtok%@BO:      173766@%
    _fstrchr%@BO:      15dea7@%
    _fstrcspn%@BO:      161e31@%
    _fstrpbrk%@BO:      16c4d6@%
    _fstrrchr%@BO:      16d12b@%
    _fstrspn%@BO:      16f61a@%
    _fstrstr%@BO:      170321@%
    _fstrtok%@BO:      173766@%
  writing 
    to console%@BO:       616a2@%%@BO:       620f6@%
    to stream%@BO:       9b240@%
strlen%@BO:       2ce64@%
strlwr%@BO:       2ce64@%%@BO:      167955@%
strncat%@BO:       2ce64@%%@BO:      168391@%
strncmp%@BO:       2ce64@%%@BO:      169054@%
strncpy%@BO:       2ce64@%%@BO:      16a270@%
strnicmp%@BO:       2ce64@%%@BO:      16af7b@%
strnset%@BO:       2ce64@%%@BO:      16ba58@%
strpbrk%@BO:       2ce64@%%@BO:      16c4d6@%
strrchr%@BO:       2cf57@%%@BO:      16d12b@%
strrev%@BO:       2cf57@%%@BO:      16e1c9@%
strset%@BO:       2d069@%%@BO:      16ecbd@%
strspn%@BO:       2d069@%%@BO:      16f61a@%
strstr%@BO:       2d069@%%@BO:      170321@%
_strtime%@BO:       31161@%%@BO:       31f61@%%@BO:      17104b@%
strtod%@BO:       13dc5@%%@BO:      17195f@%
strtok%@BO:       2d069@%%@BO:      173766@%
strtol%@BO:       13e2d@%%@BO:      17195f@%
_strtold%@BO:      17195f@%
strtoul%@BO:       13f0a@%%@BO:      17195f@%
strupr%@BO:       2d069@%%@BO:      1748f9@%
strxfrm%@BO:      1752a5@%
swab%@BO:      175cc2@%
System calls
   %@AI@%see%@AE@% DOS system calls%@NL@%; %@AI@%see%@AE@% %@NL@%
System time
   %@AI@%see%@AE@% Time%@NL@%; %@AI@%see%@AE@% %@NL@%
system%@BO:       2970b@%%@BO:      17650f@%%@BO:      17659c@%
SYS\STAT.H%@BO:       14831@%
SYS\TIMEB.H%@BO:       31d49@%
SYS\TYPES%@BO:       31d49@%
SYS\UTIME.H%@BO:       31d49@%
sys_errlist
  described%@BO:       33a2f@%
  system error messages%@BO:      101b0c@%%@BO:      164160@%
sys_nerr%@BO:       33a2f@%%@BO:      101b0c@%%@BO:      164160@%

%@2@%%@AB@%    T%@AE@%%@EH@%%@NL@%
tan, tanh%@BO:       259b4@%%@BO:      1774d9@%
Tangent%@BO:      1774d9@%
tanl, tanhl%@BO:       259b4@%%@BO:      1774d9@%
tell%@BO:       22557@%%@BO:      1783a0@%
tempnam, tmpnam%@BO:       1fdad@%%@BO:      178c37@%
Terminal capabilities%@BO:       d6045@%
Text mode
  described%@BO:       34df1@%%@BO:       fb68c@%
  setmode%@BO:      13e0d5@%
  sopen%@BO:      150a9d@%
  stream I/O%@BO:       8cc62@%%@BO:       96c8d@%%@BO:       9e7c6@%%@BO:       a4b2f@%
  vs. binary%@BO:       1d78e@%
Threads
  DosExit%@BO:       8299e@%
  termination%@BO:       8299e@%
  _beginthread%@BO:       446c0@%
  _endthread%@BO:       826f6@%
time function%@BO:      17a1fa@%
TIME.H%@BO:       31b62@%%@BO:       31d49@%
Time
  conversion 
    long integer to string%@BO:       6478f@%
    long integer to structure%@BO:       dd211@%
    structure to string%@BO:       3e2e8@%
time
  functions%@BO:       31161@%
Time
  global variables, setting%@BO:      17cabe@%
  local time, correcting%@BO:       dd211@%
  obtaining%@BO:       a8413@%%@BO:      17a1fa@%
  routines
    (list)%@BO:       31041@%
    asctime%@BO:       3e045@%
    clock%@BO:       5de39@%
    ctime%@BO:       6478f@%
    difftime%@BO:       67dbe@%
    ftime%@BO:       a8413@%
    gmtime%@BO:       c0ce8@%
    localtime%@BO:       dd211@%
    mktime%@BO:       f5fbd@%
    time%@BO:      17a1fa@%
    tzset%@BO:      17cabe@%
    utime%@BO:      181f2f@%
  time differences, computing%@BO:       67dbe@%
timeb type%@BO:       382e5@%%@BO:       a8728@%
timezone variable%@BO:       33178@%%@BO:      17cabe@%
time_t type%@BO:       3818d@%%@BO:       67dbe@%
TLOSS%@BO:       e9c51@%
tm type%@BO:       38450@%%@BO:       c0ce8@%
tmpfile%@BO:       1fdee@%
tmpnam%@BO:      178c37@%
toascii%@BO:       130fa@%%@BO:      17b58a@%
Tokens, finding in strings%@BO:      173766@%
_tolower%@BO:       13170@%%@BO:      17b58a@%
tolower, toupper%@BO:       131d2@%%@BO:      17b58a@%
_toupper%@BO:      17b58a@%
Trigonometric functions
  acos%@BO:       3b39e@%
  acosl%@BO:       3b39e@%
  asin%@BO:       3eff5@%
  asinl%@BO:       3eff5@%
  atan, atan2%@BO:       40b56@%
  atanl, atan2%@BO:       40b56@%
  cos, cosh%@BO:       60951@%
  hypot%@BO:       cedec@%
  hypotl%@BO:       cedec@%
  sin, sinh%@BO:      14fd4f@%
  sinl, sinhl%@BO:      14fd4f@%
  tan, tanh%@BO:      1774d9@%
  tanl, tanhl%@BO:      1774d9@%
TZ environment variable
  default value%@BO:       334e3@%
  localtime%@BO:       ddb00@%
  tzset%@BO:      17cabe@%
tzname variable%@BO:       33178@%%@BO:      17cabe@%
tzset%@BO:      17cabe@%

%@2@%%@AB@%    U%@AE@%%@EH@%%@NL@%
ultoa%@BO:       13fa7@%%@BO:      17ddcc@%
umask%@BO:       15072@%%@BO:      17e930@%
UNDERFLOW%@BO:       e9caf@%
ungetc%@BO:       1fe99@%%@BO:      17f6e0@%
ungetch%@BO:       24332@%%@BO:      180681@%
Universal Coordinated Time%@BO:       31b62@%
unlink%@BO:       150e4@%%@BO:      181113@%
_unregisterfonts%@BO:       1aa61@%%@BO:      181997@%
Update%@BO:       960fb@%%@BO:       9e7c6@%%@BO:       a3dcd@%
Uppercase, use of%@BO:        8f51@%
utimbuf type%@BO:       385f5@%%@BO:      181f2f@%
utime%@BO:      181f2f@%

%@2@%%@AB@%    V%@AE@%%@EH@%%@NL@%
va_arg, va_end, va_start%@BO:       32325@%
va_list type%@BO:       3883b@%
Version number (DOS)%@BO:       35125@%%@BO:       35126@%
vfprintf, vprintf, vsprintf%@BO:       1fefd@%%@BO:      185753@%

%@2@%%@AB@%    W%@AE@%%@EH@%%@NL@%
wait%@BO:      186a5f@%
Word
   %@AI@%see%@AE@% Binary, int%@NL@%; %@AI@%see%@AE@% %@NL@%
_wrapon%@BO:       19a65@%%@BO:      188602@%
Write access
   %@AI@%see%@AE@% Permission setting%@NL@%; %@AI@%see%@AE@% %@NL@%
Write operations
  binary int value to stream%@BO:      11ee6f@%
  character 
    to console%@BO:      180681@%
    to file%@BO:      1890d4@%
    to stdout%@BO:       9a711@%%@BO:      11b0aa@%
    to stream%@BO:       9a711@%%@BO:      11b0aa@%%@BO:      17f6e0@%
  data items from stream%@BO:       aa0ad@%
  formatted
    cprintf%@BO:       616a2@%
    printf%@BO:      114bac@%
    sprintf%@BO:      158291@%
    stream I/O%@BO:       99bc5@%
    vprintf%@BO:      185753@%
  line to stream%@BO:      11e787@%
  string to stream%@BO:       9b240@%
  to console%@BO:       616a2@%%@BO:       620f6@%%@BO:      11bb1f@%
  to port%@BO:       ff3fa@%
write%@BO:       22557@%%@BO:      1890d4@%

%@2@%%@AB@%    Y%@AE@%%@EH@%%@NL@%
y0, y1, yn%@BO:       4687d@%
_y0l, _y1l, _ynl%@BO:       4687c@%%@BO:       4687d@%
_y1l%@BO:       4687d@%
_ynl%@BO:       4687d@%

