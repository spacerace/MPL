%@1@%%@AH@%Microsoft BASIC (Professional Development System) Sample Code%@EH@%%@AE@%
%@NL@%
%@NL@%
%@2@%%@AH@%BALLPSET.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\BALLPSET.BAS%@AE@%%@NL@%
%@NL@%
DECLARE FUNCTION GetArraySize (WLeft, WRight, WTop, WBottom)%@NL@%
%@NL@%
SCREEN 2%@NL@%
%@NL@%
%@AB@%' Define a viewport and draw a border around it:%@AE@%%@NL@%
VIEW (20, 10)-(620, 190),,1%@NL@%
%@NL@%
CONST PI = 3.141592653589#%@NL@%
%@NL@%
%@AB@%' Redefine the coordinates of the viewport with view%@AE@%%@NL@%
%@AB@%' coordinates:%@AE@%%@NL@%
WINDOW (-3.15, -.14)-(3.56, 1.01)%@NL@%
%@NL@%
%@AB@%' Arrays in program are now dynamic:%@AE@%%@NL@%
%@AB@%' $DYNAMIC%@AE@%%@NL@%
%@NL@%
%@AB@%' Calculate the view coordinates for the top and bottom of a%@AE@%%@NL@%
%@AB@%' rectangle large enough to hold the image that will be%@AE@%%@NL@%
%@AB@%' drawn with CIRCLE and PAINT:%@AE@%%@NL@%
WLeft = -.21%@NL@%
WRight = .21%@NL@%
WTop = .07%@NL@%
WBottom = -.07%@NL@%
%@NL@%
%@AB@%' Call the GetArraySize function,%@AE@%%@NL@%
%@AB@%' passing it the rectangle's view coordinates:%@AE@%%@NL@%
ArraySize% = GetArraySize(WLeft, WRight, WTop, WBottom)%@NL@%
%@NL@%
DIM Array (1 TO ArraySize%) AS INTEGER%@NL@%
%@NL@%
%@AB@%' Draw and paint the circle:%@AE@%%@NL@%
CIRCLE (0, 0), .18%@NL@%
PAINT (0, 0)%@NL@%
%@NL@%
%@AB@%' Store the rectangle in Array:%@AE@%%@NL@%
GET (WLeft, WTop)-(WRight, WBottom), Array%@NL@%
CLS%@NL@%
%@AB@%' Draw a box and fill it with a pattern:%@AE@%%@NL@%
LINE (-3, .8)-(3.4, .2), , B%@NL@%
Pattern$ = CHR$(126) + CHR$(0) + CHR$(126) + CHR$(126)%@NL@%
PAINT (0, .5), Pattern$%@NL@%
%@NL@%
LOCATE 21, 29%@NL@%
PRINT "Press any key to end."%@NL@%
%@NL@%
%@AB@%' Initialize loop variables:%@AE@%%@NL@%
StepSize = .02%@NL@%
StartLoop = -PI%@NL@%
Decay = 1%@NL@%
%@NL@%
DO%@NL@%
   EndLoop = -StartLoop%@NL@%
   FOR X = StartLoop TO EndLoop STEP StepSize%@NL@%
%@NL@%
%@AB@%      ' Each time the ball "bounces" (hits the bottom of the%@AE@%%@NL@%
%@AB@%      ' viewport), the Decay variable gets smaller, making%@AE@%%@NL@%
%@AB@%      ' the height of the next bounce smaller:%@AE@%%@NL@%
      Y = ABS(COS(X)) * Decay - .14%@NL@%
      IF Y < -.13 THEN Decay = Decay * .9%@NL@%
%@NL@%
%@AB@%      ' Stop if key pressed or Decay less than .01:%@AE@%%@NL@%
      Esc$ = INKEY$%@NL@%
      IF Esc$ <> "" OR Decay < .01 THEN EXIT FOR%@NL@%
%@NL@%
%@AB@%      ' Put the image on the screen. The StepSize offset is%@AE@%%@NL@%
%@AB@%      ' smaller than the border around the circle. Thus,%@AE@%%@NL@%
%@AB@%      ' each time the image moves, it erases any traces%@AE@%%@NL@%
%@AB@%      ' left from the previous PUT (and also erases anything%@AE@%%@NL@%
%@AB@%      ' else on the screen):%@AE@%%@NL@%
      PUT (X, Y), Array, PSET%@NL@%
   NEXT X%@NL@%
%@NL@%
%@AB@%   ' Reverse direction:%@AE@%%@NL@%
   StepSize = -StepSize%@NL@%
   StartLoop = -StartLoop%@NL@%
LOOP UNTIL Esc$ <> "" OR Decay < .01%@NL@%
%@NL@%
END%@NL@%
%@NL@%
FUNCTION GetArraySize (WLeft, WRight, WTop, WBottom) STATIC%@NL@%
%@NL@%
%@AB@%   ' Map the view coordinates passed to this function to%@AE@%%@NL@%
%@AB@%   ' their physical-coordinate equivalents:%@AE@%%@NL@%
   VLeft = PMAP(WLeft, 0)%@NL@%
   VRight = PMAP(WRight, 0)%@NL@%
   VTop = PMAP(WTop, 1)%@NL@%
   VBottom = PMAP(WBottom, 1)%@NL@%
%@AB@%' Calculate the height and width in pixels%@AE@%%@NL@%
%@AB@%   ' of the enclosing rectangle:%@AE@%%@NL@%
   RectHeight = ABS(VBottom - VTop) + 1%@NL@%
   RectWidth = ABS(VRight - VLeft) + 1%@NL@%
%@NL@%
%@AB@%   ' Calculate size in bytes of array:%@AE@%%@NL@%
   ByteSize = 4 + RectHeight * INT((RectWidth + 7) / 8)%@NL@%
%@NL@%
%@AB@%   ' Array is integer, so divide bytes by two:%@AE@%%@NL@%
   GetArraySize = ByteSize \ 2 + 1%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BALLXOR.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\BALLXOR.BAS%@AE@%%@NL@%
%@NL@%
DECLARE FUNCTION GetArraySize (WLeft, WRight, WTop, WBottom)%@NL@%
%@NL@%
SCREEN 2%@NL@%
%@NL@%
%@AB@%' Define a viewport and draw a border around it:%@AE@%%@NL@%
VIEW (20, 10)-(620, 190), , 1%@NL@%
%@NL@%
CONST PI = 3.141592653589#%@NL@%
%@NL@%
%@AB@%' Redefine the coordinates of the viewport with view%@AE@%%@NL@%
%@AB@%' coordinates:%@AE@%%@NL@%
WINDOW (-3.15, -.14)-(3.56, 1.01)%@NL@%
%@NL@%
%@AB@%' Arrays in program are now dynamic:%@AE@%%@NL@%
%@AB@%' $DYNAMIC%@AE@%%@NL@%
%@NL@%
%@AB@%' Calculate the view coordinates for the top and bottom of a%@AE@%%@NL@%
%@AB@%' rectangle large enough to hold the image that will be%@AE@%%@NL@%
%@AB@%' drawn with CIRCLE and PAINT:%@AE@%%@NL@%
WLeft = -.18%@NL@%
WRight = .18%@NL@%
WTop = .05%@NL@%
WBottom = -.05%@NL@%
%@NL@%
%@AB@%' Call the GetArraySize function,%@AE@%%@NL@%
%@AB@%' passing it the rectangle's view coordinates:%@AE@%%@NL@%
ArraySize% = GetArraySize(WLeft, WRight, WTop, WBottom)%@NL@%
%@NL@%
DIM Array(1 TO ArraySize%)  AS INTEGER%@NL@%
%@NL@%
%@AB@%' Draw and paint the circle:%@AE@%%@NL@%
CIRCLE (0, 0), .18%@NL@%
PAINT (0, 0)%@NL@%
%@NL@%
%@AB@%' Store the rectangle in Array:%@AE@%%@NL@%
GET (WLeft, WTop)-(WRight, WBottom), Array%@NL@%
CLS%@NL@%
%@AB@%' Draw a box and fill it with a pattern:%@AE@%%@NL@%
LINE (-3, .8)-(3.4, .2), , B%@NL@%
Pattern$ = CHR$(126) + CHR$(0) + CHR$(126) + CHR$(126)%@NL@%
PAINT (0, .5), Pattern$%@NL@%
%@NL@%
LOCATE 21, 29%@NL@%
PRINT "Press any key to end."%@NL@%
%@NL@%
%@AB@%' Initialize loop variables:%@AE@%%@NL@%
StepSize = .02%@NL@%
StartLoop = -PI%@NL@%
Decay = 1%@NL@%
%@NL@%
DO%@NL@%
   EndLoop = -StartLoop%@NL@%
   FOR X = StartLoop TO EndLoop STEP StepSize%@NL@%
      Y = ABS(COS(X)) * Decay - .14%@NL@%
%@NL@%
%@AB@%      ' The first PUT statement places the image%@AE@%%@NL@%
%@AB@%      ' on the screen:%@AE@%%@NL@%
      PUT (X, Y), Array, XOR%@NL@%
%@NL@%
%@AB@%      ' Use an empty FOR...NEXT loop to delay%@AE@%%@NL@%
%@AB@%      ' the program and reduce image flicker:%@AE@%%@NL@%
      FOR I = 1 TO 5: NEXT I%@NL@%
%@NL@%
      IF Y < -.13 THEN Decay = Decay * .9%@NL@%
      Esc$ = INKEY$%@NL@%
      IF Esc$ <> "" OR Decay < .01 THEN EXIT FOR%@NL@%
%@NL@%
%@AB@%      ' The second PUT statement erases the image and%@AE@%%@NL@%
%@AB@%      ' restores the background:%@AE@%%@NL@%
      PUT (X, Y), Array, XOR%@NL@%
   NEXT X%@NL@%
%@NL@%
   StepSize = -StepSize%@NL@%
   StartLoop = -StartLoop%@NL@%
LOOP UNTIL Esc$ <> "" OR Decay < .01%@NL@%
%@NL@%
END%@NL@%
%@AB@%'  .%@AE@%%@NL@%
%@AB@%'  .%@AE@%%@NL@%
%@AB@%'  .%@AE@%%@NL@%
%@NL@%
FUNCTION GetArraySize (WLeft, WRight, WTop, WBottom) STATIC%@NL@%
%@NL@%
%@AB@%   ' Map the view coordinates passed to this function to%@AE@%%@NL@%
%@AB@%   ' their physical-coordinate equivalents:%@AE@%%@NL@%
   VLeft = PMAP(WLeft, 0)%@NL@%
   VRight = PMAP(WRight, 0)%@NL@%
   VTop = PMAP(WTop, 1)%@NL@%
   VBottom = PMAP(WBottom, 1)%@NL@%
%@AB@%' Calculate the height and width in pixels%@AE@%%@NL@%
%@AB@%   ' of the enclosing rectangle:%@AE@%%@NL@%
   RectHeight = ABS(VBottom - VTop) + 1%@NL@%
   RectWidth = ABS(VRight - VLeft) + 1%@NL@%
%@NL@%
%@AB@%   ' Calculate size in bytes of array:%@AE@%%@NL@%
   ByteSize = 4 + RectHeight * INT((RectWidth + 7) / 8)%@NL@%
%@NL@%
%@AB@%   ' Array is integer, so divide bytes by two:%@AE@%%@NL@%
   GetArraySize = ByteSize \ 2 + 1%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BAR.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\BAR.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' Define type for the titles:%@AE@%%@NL@%
TYPE TitleType%@NL@%
   MainTitle AS STRING * 40%@NL@%
   XTitle AS STRING * 40%@NL@%
   YTitle AS STRING * 18%@NL@%
END TYPE%@NL@%
%@NL@%
DECLARE SUB InputTitles (T AS TitleType)%@NL@%
DECLARE FUNCTION DrawGraph$ (T AS TitleType, Label$(), Value!(), N%)%@NL@%
DECLARE FUNCTION InputData% (Label$(), Value!())%@NL@%
%@NL@%
%@AB@%' Variable declarations for titles and bar data:%@AE@%%@NL@%
DIM Titles AS TitleType, Label$(1 TO 5), Value(1 TO 5)%@NL@%
%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE%@NL@%
%@NL@%
DO%@NL@%
   InputTitles Titles%@NL@%
   N% = InputData%(Label$(), Value())%@NL@%
   IF N% <> FALSE THEN%@NL@%
      NewGraph$ = DrawGraph$(Titles, Label$(), Value(), N%)%@NL@%
   END IF%@NL@%
LOOP WHILE NewGraph$ = "Y"%@NL@%
%@NL@%
END%@NL@%
%@NL@%
%@AB@%' ======================== DRAWGRAPH ======================%@AE@%%@NL@%
%@AB@%'   Draws a bar graph from the data entered in the%@AE@%%@NL@%
%@AB@%'   INPUTTITLES and INPUTDATA procedures.%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
FUNCTION DrawGraph$ (T AS TitleType, Label$(), Value(), N%) STATIC%@NL@%
%@NL@%
%@AB@%   ' Set size of graph:%@AE@%%@NL@%
   CONST GRAPHTOP = 24, GRAPHBOTTOM = 171%@NL@%
   CONST GRAPHLEFT = 48, GRAPHRIGHT = 624%@NL@%
   CONST YLENGTH = GRAPHBOTTOM - GRAPHTOP%@NL@%
%@NL@%
%@AB@%   ' Calculate maximum and minimum values:%@AE@%%@NL@%
   YMax = 0%@NL@%
   YMin = 0%@NL@%
   FOR I% = 1 TO N%%@NL@%
      IF Value(I%) < YMin THEN YMin = Value(I%)%@NL@%
      IF Value(I%) > YMax THEN YMax = Value(I%)%@NL@%
   NEXT I%%@NL@%
%@NL@%
%@AB@%   ' Calculate width of bars and space between them:%@AE@%%@NL@%
   BarWidth = (GRAPHRIGHT - GRAPHLEFT) / N%%@NL@%
   BarSpace = .2 * BarWidth%@NL@%
   BarWidth = BarWidth - BarSpace%@NL@%
%@NL@%
   SCREEN 2%@NL@%
   CLS%@NL@%
%@NL@%
%@AB@%   ' Draw y-axis:%@AE@%%@NL@%
   LINE (GRAPHLEFT, GRAPHTOP)-(GRAPHLEFT, GRAPHBOTTOM), 1%@NL@%
%@NL@%
%@AB@%   ' Draw main graph title:%@AE@%%@NL@%
   Start% = 44 - (LEN(RTRIM$(T.MainTitle)) / 2)%@NL@%
   LOCATE 2, Start%%@NL@%
   PRINT RTRIM$(T.MainTitle);%@NL@%
%@NL@%
%@AB@%   ' Annotate y-axis:%@AE@%%@NL@%
   Start% = CINT(13 - LEN(RTRIM$(T.YTitle)) / 2)%@NL@%
   FOR I% = 1 TO LEN(RTRIM$(T.YTitle))%@NL@%
      LOCATE Start% + I% - 1, 1%@NL@%
      PRINT MID$(T.YTitle, I%, 1);%@NL@%
   NEXT I%%@NL@%
%@NL@%
%@AB@%   ' Calculate scale factor so labels aren't bigger than four digits:%@AE@%%@NL@%
   IF ABS(YMax) > ABS(YMin) THEN%@NL@%
      Power = YMax%@NL@%
   ELSE%@NL@%
      Power = YMin%@NL@%
   END IF%@NL@%
   Power = CINT(LOG(ABS(Power) / 100) / LOG(10))%@NL@%
   IF Power < 0 THEN Power = 0%@NL@%
%@NL@%
%@AB@%   ' Scale minimum and maximum values down:%@AE@%%@NL@%
   ScaleFactor = 10 ^ Power%@NL@%
   YMax = CINT(YMax / ScaleFactor)%@NL@%
   YMin = CINT(YMin / ScaleFactor)%@NL@%
%@AB@%   ' If power isn't zero then put scale factor on chart:%@AE@%%@NL@%
   IF Power <> 0 THEN%@NL@%
      LOCATE 3, 2%@NL@%
      PRINT "x 10^"; LTRIM$(STR$(Power))%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' Put tic mark and number for Max point on y-axis:%@AE@%%@NL@%
   LINE (GRAPHLEFT - 3, GRAPHTOP) -STEP(3, 0)%@NL@%
   LOCATE 4, 2%@NL@%
   PRINT USING "####"; YMax%@NL@%
%@NL@%
%@AB@%   ' Put tic mark and number for Min point on y-axis:%@AE@%%@NL@%
   LINE (GRAPHLEFT - 3, GRAPHBOTTOM) -STEP(3, 0)%@NL@%
   LOCATE 22, 2%@NL@%
   PRINT USING "####"; YMin%@NL@%
%@NL@%
   YMax = YMax * ScaleFactor ' Scale minimum and maximum back%@NL@%
   YMin = YMin * ScaleFactor ' up for charting calculations.%@NL@%
%@NL@%
%@AB@%   ' Annotate x-axis:%@AE@%%@NL@%
   Start% = 44 - (LEN(RTRIM$(T.XTitle)) / 2)%@NL@%
   LOCATE 25, Start%%@NL@%
   PRINT RTRIM$(T.XTitle);%@NL@%
%@NL@%
%@AB@%   ' Calculate the pixel range for the y-axis:%@AE@%%@NL@%
   YRange = YMax - YMin%@NL@%
%@NL@%
%@AB@%   ' Define a diagonally striped pattern:%@AE@%%@NL@%
   Tile$ = CHR$(1)+CHR$(2)+CHR$(4)+CHR$(8)+CHR$(16)+CHR$(32)+CHR$(64)+CHR$(128)%@NL@%
%@NL@%
%@AB@%   ' Draw a zero line if appropriate:%@AE@%%@NL@%
   IF YMin < 0 THEN%@NL@%
      Bottom = GRAPHBOTTOM - ((-YMin) / YRange * YLENGTH)%@NL@%
      LOCATE INT((Bottom - 1) / 8) + 1, 5%@NL@%
      PRINT "0";%@NL@%
   ELSE%@NL@%
      Bottom = GRAPHBOTTOM%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' Draw x-axis:%@AE@%%@NL@%
   LINE (GRAPHLEFT - 3, Bottom)-(GRAPHRIGHT, Bottom)%@NL@%
%@AB@%   ' Draw bars and labels:%@AE@%%@NL@%
   Start% = GRAPHLEFT + (BarSpace / 2)%@NL@%
   FOR I% = 1 TO N%%@NL@%
%@NL@%
%@AB@%      ' Draw a bar label:%@AE@%%@NL@%
      BarMid = Start% + (BarWidth / 2)%@NL@%
      CharMid = INT((BarMid - 1) / 8) + 1%@NL@%
      LOCATE 23, CharMid - INT(LEN(RTRIM$(Label$(I%))) / 2)%@NL@%
      PRINT Label$(I%);%@NL@%
%@NL@%
%@AB@%      ' Draw the bar and fill it with the striped pattern:%@AE@%%@NL@%
      BarHeight = (Value(I%) / YRange) * YLENGTH%@NL@%
      LINE (Start%, Bottom) -STEP(BarWidth, -BarHeight), , B%@NL@%
      PAINT (BarMid, Bottom - (BarHeight / 2)), Tile$, 1%@NL@%
%@NL@%
      Start% = Start% + BarWidth + BarSpace%@NL@%
   NEXT I%%@NL@%
   LOCATE 1, 1%@NL@%
   PRINT "New graph? ";%@NL@%
   DrawGraph$ = UCASE$(INPUT$(1))%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@AB@%' ======================== INPUTDATA ======================%@AE@%%@NL@%
%@AB@%'     Gets input for the bar labels and their values%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
FUNCTION InputData% (Label$(), Value()) STATIC%@NL@%
%@NL@%
%@AB@%   ' Initialize the number of data values:%@AE@%%@NL@%
   NumData% = 0%@NL@%
%@NL@%
%@AB@%   ' Print data-entry instructions:%@AE@%%@NL@%
   CLS%@NL@%
   PRINT "Enter data for up to 5 bars:"%@NL@%
   PRINT "   * Enter the label and value for each bar."%@NL@%
   PRINT "   * Values can be negative."%@NL@%
   PRINT "   * Enter a blank label to stop."%@NL@%
   PRINT%@NL@%
   PRINT "After viewing the graph, press any key ";%@NL@%
   PRINT "to end the program."%@NL@%
%@NL@%
%@AB@%   ' Accept data until blank label or 5 entries:%@AE@%%@NL@%
   Done% = FALSE%@NL@%
   DO%@NL@%
      NumData% = NumData% + 1%@NL@%
      PRINT%@NL@%
      PRINT "Bar("; LTRIM$(STR$(NumData%)); "):"%@NL@%
      INPUT ; "        Label? ", Label$(NumData%)%@NL@%
%@NL@%
%@AB@%      ' Only input value if label isn't blank:%@AE@%%@NL@%
      IF Label$(NumData%) <> "" THEN%@NL@%
         LOCATE , 35%@NL@%
         INPUT "Value? ", Value(NumData%)%@NL@%
%@NL@%
%@AB@%      ' If label is blank, decrement data counter%@AE@%%@NL@%
%@AB@%      ' and set Done flag equal to TRUE:%@AE@%%@NL@%
      ELSE%@NL@%
         NumData% = NumData% - 1%@NL@%
         Done% = TRUE%@NL@%
      END IF%@NL@%
   LOOP UNTIL (NumData% = 5) OR Done%%@NL@%
%@NL@%
%@AB@%   ' Return the number of data values input:%@AE@%%@NL@%
   InputData% = NumData%%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@AB@%' ====================== INPUTTITLES ======================%@AE@%%@NL@%
%@AB@%'     Accepts input for the three different graph titles%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
SUB InputTitles (T AS TitleType) STATIC%@NL@%
   SCREEN 0, 0                ' Set text screen.%@NL@%
   DO                        ' Input titles.%@NL@%
      CLS%@NL@%
      INPUT "Enter main graph title: ", T.MainTitle%@NL@%
      INPUT "Enter x-axis title    : ", T.XTitle%@NL@%
      INPUT "Enter y-axis title    : ", T.YTitle%@NL@%
%@NL@%
%@AB@%      ' Check to see if titles are OK:%@AE@%%@NL@%
      LOCATE 7, 1%@NL@%
      PRINT "OK (Y to continue, N to change)? ";%@NL@%
      LOCATE , , 1%@NL@%
      OK$ = UCASE$(INPUT$(1))%@NL@%
   LOOP UNTIL OK$ = "Y"%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIGSTRIN.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\BIGSTRIN.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'Define arrays which will be passed to each new level%@AE@%%@NL@%
%@AB@%'       of recursion.%@AE@%%@NL@%
DECLARE SUB BigStrings (n%, s1$(), s2$(), s3$(), s4$())%@NL@%
DEFINT A-Z%@NL@%
DIM s1$(1 TO 2), s2$(1 TO 2), s3$(1 TO 2), s4$(1 TO 2)%@NL@%
%@AB@%' Compute the # of 64K blocks available in far memory.%@AE@%%@NL@%
n = FRE(-1) \ 65536%@NL@%
CLS%@NL@%
%@AB@%'Quit if not enough memory.%@AE@%%@NL@%
IF n < 1 THEN%@NL@%
             PRINT "Not enough memory for operation."%@NL@%
             END%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Start the recursion.%@AE@%%@NL@%
CALL BigStrings(n, s1$(), s2$(), s3$(), s4$())%@NL@%
%@NL@%
SUB BigStrings (n, s1$(), s2$(), s3$(), s4$())%@NL@%
%@AB@%' Create a new array (up to 64K) for each level of recursion.%@AE@%%@NL@%
DIM a$(1 TO 2)%@NL@%
%@AB@%' Have n keep track of recursion level.%@AE@%%@NL@%
SELECT CASE n%@NL@%
%@AB@%' When at highest recusion level, process the strings.%@AE@%%@NL@%
        CASE 0%@NL@%
                PRINT s1$(1); s1$(2); s2$(1); s2$(2); s3$(1); s3$(2); s4$(1); s4$(2)%@NL@%
        CASE 1%@NL@%
                a$(1) = "Each "%@NL@%
                a$(2) = "word "%@NL@%
                s1$(1) = a$(1)%@NL@%
                s1$(2) = a$(2)%@NL@%
        CASE 2%@NL@%
                a$(1) = "pair "%@NL@%
                a$(2) = "comes "%@NL@%
                s2$(1) = a$(1)%@NL@%
                s2$(2) = a$(2)%@NL@%
        CASE 3%@NL@%
                a$(1) = "from "%@NL@%
                a$(2) = "separate "%@NL@%
                s3$(1) = a$(1)%@NL@%
                s3$(2) = a$(2)%@NL@%
        CASE 4%@NL@%
                a$(1) = "recursive "%@NL@%
                a$(2) = "procedures."%@NL@%
                s4$(1) = a$(1)%@NL@%
                s4$(2) = a$(2)%@NL@%
END SELECT%@NL@%
%@NL@%
%@AB@%' Keep going until we're out of memory.%@AE@%%@NL@%
IF n > 0 THEN%@NL@%
                n = n - 1%@NL@%
%@AB@%' For each recursion, pass in previously created arrays.%@AE@%%@NL@%
                CALL BigStrings(n, s1$(), s2$(), s3$(), s4$())%@NL@%
END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BOOKLOOK.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\BOOKLOOK.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'****************************** Main  Module *******************************%@AE@%%@NL@%
%@AB@%'* This window contains the module-level code of BOOKLOOK.BAS, a program   *%@AE@%%@NL@%
%@AB@%'* used to manage the database of a hypothethical library (BOOKS.MDB). The *%@AE@%%@NL@%
%@AB@%'* program requires the following additional modules: BOOKMOD1.BAS,        *%@AE@%%@NL@%
%@AB@%'* BOOKMOD2.BAS, and BOOKMOD3.BAS, all named in the file BOOKLOOK.MAK. The *%@AE@%%@NL@%
%@AB@%'* include file BOOKLOOK.BI and the database file BOOKS.MDB must also be   *%@AE@%%@NL@%
%@AB@%'* accessible. The program is discussed in Chapter 10, Database Programming*%@AE@%%@NL@%
%@AB@%'* with ISAM in the BASIC 7.0 Programmer's Guide.                          *%@AE@%%@NL@%
%@AB@%'*                                                                         *%@AE@%%@NL@%
%@AB@%'* If you do NOT have expanded memory available, you should have invoked   *%@AE@%%@NL@%
%@AB@%'* the PROISAM.EXE TSR as PROISAM /Ib:n, where n can be between 10-20.     *%@AE@%%@NL@%
%@AB@%'* The /Ib: option specifies the number of buffers ISAM needs. Higher n    *%@AE@%%@NL@%
%@AB@%'* values improve performance. Too few buffers, and the program will fail  *%@AE@%%@NL@%
%@AB@%'* with an "Out of Memory" error. However if /Ib: is set too high, there   *%@AE@%%@NL@%
%@AB@%'* may not be enough memory to load and run the program. If you do HAVE    *%@AE@%%@NL@%
%@AB@%'* expanded memory, ISAM automatically uses up to 1.2 megabytes, even if   *%@AE@%%@NL@%
%@AB@%'* you set Ib: to a low value. With a program the size of BOOKLOOK, use the*%@AE@%%@NL@%
%@AB@%'* /Ie: option to reserve some expanded memory for QBX. This indirectly    *%@AE@%%@NL@%
%@AB@%'* limits the amount of expanded memory ISAM uses, but make sure ISAM gets *%@AE@%%@NL@%
%@AB@%'* enough EMS for at least 15 buffers (each buffer = 2K). As a last resort,*%@AE@%%@NL@%
%@AB@%'* you can start QBX with the /NOF switch to make more memory available.   *%@AE@%%@NL@%
%@AB@%'*                                                                         *%@AE@%%@NL@%
%@AB@%'* BOOKLOOK manages 3 tables, BookStock, CardHolders, and BooksOut. The    *%@AE@%%@NL@%
%@AB@%'* data in the BookStock and CardHolders tables is displayed as forms on   *%@AE@%%@NL@%
%@AB@%'* screen. The user can switch between table displays by pressing "V" (for *%@AE@%%@NL@%
%@AB@%'* View Other Table). Each table is defined as a separate structure. The   *%@AE@%%@NL@%
%@AB@%'* structure for BookStock is Books, for CardHolders it is Borrowers, and  *%@AE@%%@NL@%
%@AB@%'* for BooksOut it is BookStatus. Each of these is incorporated as an      *%@AE@%%@NL@%
%@AB@%'* element of the structure RecStruct. RecStruct also has an element of    *%@AE@%%@NL@%
%@AB@%'* INTEGER type called TableNum (to keep track of which table is being     *%@AE@%%@NL@%
%@AB@%'* displayed), and a STRING element called WhichIndex that holds the name  *%@AE@%%@NL@%
%@AB@%'* of the index by which the user chooses to order presentation of records.*%@AE@%%@NL@%
%@AB@%'* Press F2 to see a list of procedures called by the program.             *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@AB@%'$INCLUDE: 'BOOKLOOK.BI'%@AE@%%@NL@%
SCREEN 0%@NL@%
CLS                         ' TempRec is for editing and adding records%@NL@%
DIM TempRec AS RecStruct    ' Used only to blank out a TempRec%@NL@%
DIM EmptyRec AS RecStruct   ' See BOOKLOOK.BI for declaration of%@NL@%
DIM BigRec AS RecStruct     ' this structure and its elements%@NL@%
DIM Marker(25) AS INTEGER   ' Array to hold SAVEPOINT returns%@NL@%
%@NL@%
%@AB@%' Open the database and the BookStock, CardHolders, and BooksOut tables%@AE@%%@NL@%
%@NL@%
ON ERROR GOTO MainHandler%@NL@%
OPEN "BOOKS.MDB" FOR ISAM Books "BookStock" AS cBookStockTableNum%@NL@%
OPEN "BOOKS.MDB" FOR ISAM Borrowers "CardHolders" AS cCardHoldersTableNum%@NL@%
OPEN "BOOKS.MDB" FOR ISAM BookStatus "BooksOut" AS cBooksOutTableNum%@NL@%
ON ERROR GOTO 0%@NL@%
%@NL@%
BigRec.TableNum = cBookStockTableNum   ' Decide which table to show first%@NL@%
%@NL@%
%@AB@%   ' Since the database has multiple tables, this outer DO loop is used to%@AE@%%@NL@%
%@AB@%   ' reset the number associated with the table the user wants to%@AE@%%@NL@%
%@AB@%   ' to access, then draw the screen appropriate to that table, etc.%@AE@%%@NL@%
DO%@NL@%
  EraseMessage                          ' Show the interface%@NL@%
  CALL DrawScreen(BigRec.TableNum)%@NL@%
  Checked = CheckIndex%(BigRec, TRUE)   ' Show current index%@NL@%
  CALL Retriever(BigRec, DimN, DimP, Answer) ' Retrieve and show a record%@NL@%
  CALL ShowMessage(" Press V to View other table", 0)%@NL@%
  CALL ShowStatus(" Total records in table: ", CDBL(LOF(BigRec.TableNum)))%@NL@%
%@NL@%
%@AB@%  ' This loop lets the user traverse BigRec.TableNum and insert, delete,%@AE@%%@NL@%
%@AB@%  ' or modify records.%@AE@%%@NL@%
  DO                                           ' At start of each loop, show%@NL@%
%@AB@%                                               ' the user valid operations%@AE@%%@NL@%
    CALL Retriever(BigRec, DimN, DimP, Answer) ' and display current record%@NL@%
%@NL@%
    STACK 4000                          ' Set large stack for recursions-it%@NL@%
%@AB@%                                        ' also resets FRE(-2) to stack 4000.%@AE@%%@NL@%
%@NL@%
    Answer% = GetInput%(BigRec)         ' Find out what the user wants to do%@NL@%
%@NL@%
    IF Answer < UNDO THEN               ' Excludes UNDOALL & INVALIDKEY too%@NL@%
      CALL EditCheck(PendingFlag, Answer, BigRec)%@NL@%
    END IF%@NL@%
%@NL@%
    SELECT CASE Answer         ' Process valid user requests%@NL@%
      CASE QUIT%@NL@%
        CALL ShowMessage(" You chose Quit. So long! ", 0)%@NL@%
        END%@NL@%
%@NL@%
%@AB@%                               ' If user picks "N" (Next Record), MOVENEXT.%@AE@%%@NL@%
%@AB@%                               ' CheckPosition handles end-of-file (i.e. the%@AE@%%@NL@%
      CASE GOAHEAD, ENDK       ' position just past the last record). If EOF%@NL@%
%@AB@%                               ' or BOF = TRUE, CheckPosition holds position%@AE@%%@NL@%
        MOVENEXT BigRec.TableNum%@NL@%
        CALL CheckPosition(BigRec, Answer, DimN, DimP)%@NL@%
%@NL@%
%@AB@%                               ' Same logic as GOAHEAD, but reversed%@AE@%%@NL@%
      CASE GOBACK, HOME%@NL@%
%@NL@%
        MOVEPREVIOUS BigRec.TableNum%@NL@%
        CALL CheckPosition(BigRec, Answer, DimN, DimP)%@NL@%
%@NL@%
%@AB@%                               ' If user chooses "E", let him edit a field.%@AE@%%@NL@%
%@AB@%                               ' Assign the value returned by SAVEPOINT to%@AE@%%@NL@%
%@AB@%                               ' an array element, then update the table and%@AE@%%@NL@%
%@AB@%                               ' show the changed field. Trap any "duplicate%@AE@%%@NL@%
      CASE EDITRECORD          ' value for unique index" (error 86) and%@NL@%
%@AB@%                               ' handle it. The value returned by SAVEPOINT%@AE@%%@NL@%
%@AB@%                               ' allows rollbacks so the user can undo edits%@AE@%%@NL@%
%@NL@%
        IF LOF(BigRec.TableNum) THEN%@NL@%
          IF EditField(Argument%, BigRec, Letter$, EDITRECORD, Answer%) THEN%@NL@%
%@NL@%
%@AB@%              ' You save a sequence of savepoint identifiers in an array so%@AE@%%@NL@%
%@AB@%              ' you can let the user roll the state of the file back to a%@AE@%%@NL@%
%@AB@%              ' specific point. The returns from SAVEPOINT aren't guaranteed%@AE@%%@NL@%
%@AB@%              ' to be sequential.%@AE@%%@NL@%
            n = n + 1              ' Increment counter first so savepoint%@NL@%
            Marker(n) = SAVEPOINT  ' is synced with array-element subscript%@NL@%
%@NL@%
            Alert$ = "Setting Savepoint number " + STR$(Marker(n))%@NL@%
            CALL ShowMessage(Alert$, 0)%@NL@%
            ON ERROR GOTO MainHandler%@NL@%
            SELECT CASE BigRec.TableNum   ' Update the table being displayed%@NL@%
              CASE cBookStockTableNum%@NL@%
                UPDATE BigRec.TableNum, BigRec.Inventory%@NL@%
              CASE cCardHoldersTableNum%@NL@%
                UPDATE BigRec.TableNum, BigRec.Lendee%@NL@%
            END SELECT%@NL@%
            ON ERROR GOTO 0%@NL@%
          ELSE%@NL@%
            COMMITTRANS               ' Use COMMITTRANS abort transaction if%@NL@%
            PendingFlag = FALSE       ' the user presses ESC%@NL@%
            n = 0                     ' Reset array counter%@NL@%
          END IF%@NL@%
        ELSE%@NL@%
          CALL ShowMessage("Sorry, no records in this table to edit", 0): SLEEP%@NL@%
        END IF%@NL@%
%@AB@%                          ' If choice is "A", get the values the user wants%@AE@%%@NL@%
%@AB@%                          ' in each of the fields (with AddOne). If there%@AE@%%@NL@%
%@AB@%                          ' is no ESCAPE from the edit, INSERT the record.%@AE@%%@NL@%
%@AB@%                          ' Trap "Duplicate value for unique index" errors%@AE@%%@NL@%
%@AB@%                          ' and handle them in MainHandler (error 86).%@AE@%%@NL@%
      CASE ADDRECORD%@NL@%
        added = AddOne(BigRec, EmptyRec, TempRec, Answer%)%@NL@%
        IF added THEN%@NL@%
          Alert$ = "A new record assumes proper place in current index"%@NL@%
          CALL ShowMessage(Alert$, 0)%@NL@%
          ON ERROR GOTO MainHandler%@NL@%
          SELECT CASE BigRec.TableNum     ' Insert into table being shown%@NL@%
            CASE cBookStockTableNum%@NL@%
              INSERT BigRec.TableNum, TempRec.Inventory%@NL@%
            CASE cCardHoldersTableNum%@NL@%
              INSERT BigRec.TableNum, TempRec.Lendee%@NL@%
          END SELECT%@NL@%
          ON ERROR GOTO 0%@NL@%
        END IF%@NL@%
        TempRec = EmptyRec%@NL@%
%@NL@%
%@AB@%                              ' If choice is "D" --- prompt for confirmation.%@AE@%%@NL@%
%@AB@%                              ' If so, delete it and show new current record.%@AE@%%@NL@%
      CASE TOSSRECORD%@NL@%
        AnyRecords = LOF(BigRec.TableNum)%@NL@%
        IF BigRec.TableNum = cBookStockTableNum THEN CheckedOut = GetStatus(BigRec, 0#)%@NL@%
        IF BigRec.TableNum = cCardHoldersTableNum THEN%@NL@%
          SETINDEX cBooksOutTableNum, "CardNumIndexBO"%@NL@%
          SEEKEQ cBooksOutTableNum, BigRec.Lendee.CardNum%@NL@%
          IF NOT EOF(cBooksOutTableNum) THEN CheckedOut = TRUE%@NL@%
        END IF%@NL@%
        IF AnyRecords AND CheckedOut = FALSE THEN%@NL@%
          Alert$ = "Press D again to Delete this record, ESC to escape"%@NL@%
          CALL ShowMessage(Alert$, 0)%@NL@%
          DeleteIt% = GetInput%(BigRec)%@NL@%
          IF DeleteIt% = TOSSRECORD THEN   ' Delete currently-displayed record%@NL@%
            DELETE BigRec.TableNum%@NL@%
            CALL ShowMessage("Record deleted...Press a key to continue", 0)%@NL@%
          ELSE%@NL@%
            CALL ShowMessage("Record not deleted. Press a key to continue", 0)%@NL@%
            CALL ShowRecord(BigRec)%@NL@%
          END IF%@NL@%
%@AB@%          ' The following code checks whether the record deleted was the last%@AE@%%@NL@%
%@AB@%          ' record in the index, then makes the new last record current%@AE@%%@NL@%
          IF EOF(BigRec.TableNum) THEN%@NL@%
            MOVELAST BigRec.TableNum%@NL@%
          END IF%@NL@%
        ELSE%@NL@%
          IF BigRec.TableNum = cBookStockTableNum THEN%@NL@%
            IF AnyRecords = 0 THEN Alert$ = "Sorry, no records in this table to delete"%@NL@%
            IF CheckedOut THEN Alert$ = "Can't delete --- this book currently checked out!"%@NL@%
          ELSEIF BigRec.TableNum = cCardHoldersTableNum THEN%@NL@%
            IF AnyRecords = 0 THEN Alert$ = "Sorry, no records in this table to delete"%@NL@%
            IF CheckedOut THEN Alert$ = "Can't delete --- this cardholder still has books out!"%@NL@%
          END IF%@NL@%
          CALL ShowMessage(Alert$, 0): SLEEP%@NL@%
        END IF%@NL@%
        CheckedOut = FALSE%@NL@%
%@NL@%
%@AB@%                               ' If user chooses "R", walk the fields so he%@AE@%%@NL@%
%@AB@%                               ' can choose new index to order presentation%@AE@%%@NL@%
      CASE REORDER%@NL@%
        Letter$ = CHR$(TABKEY)%@NL@%
        GotOne = ChooseOrder(BigRec, EmptyRec, TempRec, Letter$, REORDER)%@NL@%
%@NL@%
%@AB@%                               ' If a choice of indexes was made, retrieve%@AE@%%@NL@%
%@AB@%                               ' the index name, set an error trap, and try%@AE@%%@NL@%
%@AB@%                               ' to set the index, then display new index.%@AE@%%@NL@%
        IF GotOne THEN%@NL@%
          IndexName$ = LTRIM$(RTRIM$(TempRec.WhichIndex))%@NL@%
          ON ERROR GOTO MainHandler%@NL@%
          IF IndexName$ <> "NULL" THEN            ' This string is placed in%@NL@%
            SETINDEX BigRec.TableNum, IndexName$  ' TempRec.WhichIndex if%@NL@%
          ELSE                                    ' user chooses "Default."%@NL@%
            SETINDEX BigRec.TableNum, ""          ' "" is valid index name%@NL@%
          END IF                                  'representing NULL index%@NL@%
          ON ERROR GOTO 0                         '(i.e. the default order)%@NL@%
          CALL AdjustIndex(BigRec)%@NL@%
          LSET TempRec = EmptyRec%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%                          ' If choice is "F", first set current index%@AE@%%@NL@%
      CASE SEEKFIELD      ' using same procedure as REORDER. Then do seek.%@NL@%
%@NL@%
        Letter$ = CHR$(TABKEY)        ' Pass TABKEY for PlaceCursor%@NL@%
        GotOne = ChooseOrder(BigRec, EmptyRec, TempRec, Letter$, SEEKFIELD)%@NL@%
%@NL@%
        IF GotOne AND TEXTCOMP(TempRec.WhichIndex, "NULL") THEN%@NL@%
          CALL SeekRecord(BigRec, TempRec, Letter$)%@NL@%
          FirstLetter$ = ""%@NL@%
          DimN = EOF(BigRec.TableNum): DimP = BOF(BigRec.TableNum)%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%                          ' STATUS gets the due date of a book & displays it%@AE@%%@NL@%
      CASE STATUS%@NL@%
        IF BigRec.TableNum = cBookStockTableNum THEN%@NL@%
          CALL ShowStatus("", 0#)                  ' Explicitly type the 0%@NL@%
          GotIt = GetStatus(BigRec, DateToShow#)   ' to avoid type mismatch%@NL@%
          IF GotIt THEN%@NL@%
            Alert$ = "Press B for information on Borrower of this book"%@NL@%
            CALL ShowMessage(Alert$, 0)%@NL@%
            CALL ShowStatus("Due Date: ", DateToShow#)%@NL@%
          END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%                         ' LendeeProfile displays borrower of displayed book%@AE@%%@NL@%
      CASE BORROWER%@NL@%
        CALL LendeeProfile(BigRec)%@NL@%
%@NL@%
%@AB@%                         ' BooksBorrowed shows books borrowed by CardHolder%@AE@%%@NL@%
      CASE WHICHBOOKS%@NL@%
        IF Borrowed THEN CALL BooksBorrowed(BigRec)%@NL@%
%@NL@%
%@AB@%                         ' If user hits "V" cycle through displayable tables%@AE@%%@NL@%
      CASE OTHERTABLE%@NL@%
        IF BigRec.TableNum < cDisplayedTables THEN%@NL@%
          BigRec.TableNum = BigRec.TableNum + 1%@NL@%
        ELSE%@NL@%
          BigRec.TableNum = 1%@NL@%
        END IF%@NL@%
        EXIT DO%@NL@%
%@AB@%                         ' If user picks "I" to check current book back in,%@AE@%%@NL@%
%@AB@%                         ' make sure it is out, then check it back in%@AE@%%@NL@%
      CASE CHECKIN%@NL@%
        IF Borrowed THEN%@NL@%
          GotIt = GetStatus(BigRec, DateToShow#)%@NL@%
          IF DateToShow# THEN%@NL@%
            CALL ReturnBook(BigRec, DateToShow#)%@NL@%
          END IF%@NL@%
        END IF%@NL@%
%@AB@%                         ' If user picks "O" to check current book out,%@AE@%%@NL@%
%@AB@%                         ' make sure it is available, then check it out%@AE@%%@NL@%
      CASE CHECKOUT%@NL@%
        GotIt = GetStatus(BigRec, DateToShow#)%@NL@%
          IF DateToShow# = 0# THEN%@NL@%
             CALL BorrowBook(BigRec)%@NL@%
          ELSE%@NL@%
             CALL ShowMessage("Sorry, this book is already checked out...", 0)%@NL@%
          END IF%@NL@%
%@NL@%
%@AB@%                        ' If user wants to Undo all or some of a series of%@AE@%%@NL@%
%@AB@%                        ' uncommitted edits, make sure there is a pending%@AE@%%@NL@%
%@AB@%                        ' transaction to undo, then restore the state of the%@AE@%%@NL@%
%@AB@%                        ' file one step at a time, or altogether, depending%@AE@%%@NL@%
%@AB@%                        ' on whether U or ^U was entered.%@AE@%%@NL@%
      CASE UNDO, UNDOALL%@NL@%
        IF PendingFlag = TRUE THEN%@NL@%
          IF n < 1 THEN%@NL@%
            CALL ShowMessage("No pending edits left to Undo...", 0)%@NL@%
          ELSE%@NL@%
            IF Answer = UNDO THEN%@NL@%
              Alert$ = "Restoring back to Savepoint # " + STR$(Marker(n))%@NL@%
              CALL ShowMessage(Alert$, 0)%@NL@%
              ROLLBACK Marker(n)%@NL@%
              n = n - 1%@NL@%
            ELSE                    ' If it's not UNDO, it must be UNDOALL%@NL@%
              CALL ShowMessage("Undoing the whole last series of edits", 0)%@NL@%
              ROLLBACK ALL%@NL@%
              n = 0%@NL@%
            END IF%@NL@%
         END IF%@NL@%
       ELSE%@NL@%
         CALL ShowMessage("There are no pending edits left to Undo...", 0)%@NL@%
       END IF%@NL@%
%@NL@%
      CASE INVALIDKEY              ' Alert user if wrong key is pressed%@NL@%
        CALL ShowMessage(KEYSMESSAGE, 0)%@NL@%
        IF PendingFlag = TRUE THEN CALL DrawIndexBox(BigRec.TableNum, EDITRECORD)%@NL@%
    END SELECT%@NL@%
    CALL DrawHelpKeys(BigRec.TableNum)%@NL@%
    CALL ShowKeys(BigRec, BRIGHT + FOREGROUND, DimN, DimP)%@NL@%
  LOOP%@NL@%
LOOP%@NL@%
CLOSE%@NL@%
END%@NL@%
%@NL@%
%@AB@%' This error handler takes care of the most common ISAM errors%@AE@%%@NL@%
%@NL@%
MainHandler:%@NL@%
%@NL@%
IF ERR = 73 THEN        ' 73 = Feature unavailable%@NL@%
  CALL ShowMessage("You forgot to load the ISAM TSR program", 0)%@NL@%
  END%@NL@%
ELSEIF ERR = 88 THEN        ' 88 = Database inconsistent%@NL@%
%@AB@%  ' If you have text files corresponding to each of the tables, then%@AE@%%@NL@%
%@AB@%  ' MakeOver prompts for their names and creates an ISAM file from them.%@AE@%%@NL@%
  CALL MakeOver(BigRec)%@NL@%
  RESUME NEXT%@NL@%
%@NL@%
ELSEIF ERR = 83 THEN        ' 83 = Index not found%@NL@%
    CALL DrawScreen(BigRec.TableNum)%@NL@%
    CALL ShowMessage("Unable to set the index. Need more buffers?", 0)%@NL@%
    RESUME NEXT%@NL@%
ELSEIF ERR = 86 THEN        ' 86 = Duplicate value for unique index%@NL@%
%@AB@%    ' Trap errors when a user tries to enter a value for the Card Number or%@AE@%%@NL@%
%@AB@%    ' ID fields that duplicates a value already in the table%@AE@%%@NL@%
    CALL DupeFixer(BigRec)%@NL@%
    RESUME%@NL@%
ELSE%@NL@%
  Alert$ = "Sorry, not able to handle this error in BOOKLOOK: " + STR$(ERR)%@NL@%
  CALL ShowMessage(Alert$, 0)%@NL@%
  END%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The AddOne FUNCTION is called once for each field when the user wants  *%@AE@%%@NL@%
%@AB@%'*  to add a record to the displayed table.                                *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  BigRec    RecStruct variable containing information on all tables      *%@AE@%%@NL@%
%@AB@%'*  EmptyRec  Empty record of same type as BigRec                          *%@AE@%%@NL@%
%@AB@%'*  TempRec   Temporary record record of same type as BigRec               *%@AE@%%@NL@%
%@AB@%'*  Answer    Integer passed through to EditField; tells task to perform   *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION AddOne (BigRec AS RecStruct, EmptyRec AS RecStruct, TempRec AS RecStruct, Answer%)%@NL@%
  CALL ClearEm(BigRec.TableNum, 1, 1, 1, 1, 1, 1)%@NL@%
  LSET TempRec = EmptyRec%@NL@%
  CALL ShowMessage("Enter the first field of the new record", 0)%@NL@%
  TempRec.TableNum = BigRec.TableNum%@NL@%
  Edited = EditField(Argument%, TempRec, FirstLetter$, ADDRECORD, Answer%)%@NL@%
  IF Edited THEN%@NL@%
    AddOne = -1%@NL@%
  ELSE%@NL@%
    AddOne = 0%@NL@%
  END IF%@NL@%
  COLOR FOREGROUND, BACKGROUND%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'* The CheckPosition SUB checks the table position after the requested user*%@AE@%%@NL@%
%@AB@%'* action is completed. If EOF follows a MOVENEXT or the user has chosen   *%@AE@%%@NL@%
%@AB@%'* MOVELAST, the Keys for Database Viewing/Editing box is updated to say   *%@AE@%%@NL@%
%@AB@%'* "No Next Record." If BOF  follows a MOVEPREVIOUS or user has chosen a   *%@AE@%%@NL@%
%@AB@%'* MOVEFIRST, "No Previous Record" is displayed.                           *%@AE@%%@NL@%
%@AB@%'* In either case, the position is held by executing MOVELAST or MOVEFIRST.*%@AE@%%@NL@%
%@AB@%'*                            Parameters:                                  *%@AE@%%@NL@%
%@AB@%'*   Big Rec      User-defined type containing all table information       *%@AE@%%@NL@%
%@AB@%'*   Answer       Tells what operation retrieve results from               *%@AE@%%@NL@%
%@AB@%'*   DimN & DimP  Flags telling which menu items should be dimmed/changed  *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB CheckPosition (BigRec AS RecStruct, Answer, DimN%, DimP%)%@NL@%
  SELECT CASE Answer%@NL@%
    CASE GOAHEAD, ENDK%@NL@%
      IF EOF(BigRec.TableNum) OR (Answer = ENDK) THEN%@NL@%
        CALL ShowMessage("This is the last record in this index", 0)%@NL@%
        DimN = TRUE: DimP = FALSE%@NL@%
        MOVELAST BigRec.TableNum%@NL@%
      ELSE                    ' If not EOF, turn on N%@NL@%
        DimN = FALSE: DimP = FALSE%@NL@%
        CALL EraseMessage%@NL@%
      END IF%@NL@%
    CASE GOBACK, HOME%@NL@%
      IF BOF(BigRec.TableNum) OR (Answer = HOME) THEN%@NL@%
        CALL ShowMessage("This is the first record in this index", 0)%@NL@%
        DimP = TRUE: DimN = FALSE%@NL@%
        MOVEFIRST BigRec.TableNum%@NL@%
      ELSE%@NL@%
        DimP = FALSE: DimN = FALSE%@NL@%
        CALL EraseMessage%@NL@%
      END IF%@NL@%
  END SELECT%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'* The ChooseOrder FUNCTION calls PlaceCursor so the user can move around  *%@AE@%%@NL@%
%@AB@%'* the form to pick the index to set.                                      *%@AE@%%@NL@%
%@AB@%'*                                  Parameters                             *%@AE@%%@NL@%
%@AB@%'*  BigRec       BigRec has all the table information in updated form      *%@AE@%%@NL@%
%@AB@%'*  EmptyRec     EmptyRec is same template as BigRec, but fields are empty *%@AE@%%@NL@%
%@AB@%'*  TempRec      Holds intermediate and temporary data                     *%@AE@%%@NL@%
%@AB@%'*  FirstLetter  Catches letter if user starts typing during SEEKFIELD     *%@AE@%%@NL@%
%@AB@%'*  Task         Either REORDER or SEEKFIELD - passed on to PlaceCursor    *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION ChooseOrder (BigRec AS RecStruct, EmptyRec AS RecStruct, TempRec AS RecStruct, FirstLetter$, Task%)%@NL@%
  CALL DrawTable(BigRec.TableNum)%@NL@%
  CALL DrawIndexBox(BigRec.TableNum, Task)%@NL@%
  Argument = TITLEFIELD                    ' Always start with first field%@NL@%
  TempRec = EmptyRec: TempRec.TableNum = BigRec.TableNum%@NL@%
%@NL@%
%@AB@%  ' Pass temporary RecStruct variable so user can't trash BigRec%@AE@%%@NL@%
  value = PlaceCursor(Argument, TempRec, FirstLetter$, 1, Task)%@NL@%
%@NL@%
%@AB@%  ' If the user chooses ESC, redraw everything, then exit to module level%@AE@%%@NL@%
  IF ASC(TempRec.WhichIndex) = 0 THEN%@NL@%
    CALL DrawIndexBox(BigRec.TableNum, Task)%@NL@%
    CALL ShowRecord(BigRec)%@NL@%
    CALL ShowMessage(KEYSMESSAGE, 0)%@NL@%
    ChooseOrder = 0%@NL@%
    EXIT FUNCTION%@NL@%
  ELSE                                ' Otherwise, if user makes a choice%@NL@%
    ChooseOrder = -1                  ' of Indexes, signal success to the%@NL@%
  END IF                              ' module-level code%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*                                                                         *%@AE@%%@NL@%
%@AB@%'*  The DupeFixer SUB is called when the tries to enter a duplicate value  *%@AE@%%@NL@%
%@AB@%'*  for the BookStock table's IDnum column or the the CardHolders table's  *%@AE@%%@NL@%
%@AB@%'*  CardNum column, because their indexes are Unique. The procedure prompts*%@AE@%%@NL@%
%@AB@%'*  the user to enter a new value.                                         *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB DupeFixer (BigRec AS RecStruct)%@NL@%
    IF BigRec.TableNum = cBookStockTableNum THEN%@NL@%
      DO%@NL@%
        Alert$ = STR$(BigRec.Inventory.IDnum) + " is not unique. "%@NL@%
        CALL ShowMessage(Alert$, 1)%@NL@%
        COLOR YELLOW + BRIGHT, BACKGROUND%@NL@%
        INPUT "Try another number: ", TempString$%@NL@%
        BigRec.Inventory.IDnum = VAL(TempString$)%@NL@%
      LOOP UNTIL BigRec.Inventory.IDnum%@NL@%
    ELSEIF BigRec.TableNum = cCardHoldersTableNum THEN%@NL@%
      DO%@NL@%
        Alert$ = STR$(BigRec.Lendee.CardNum) + " is not unique. "%@NL@%
        CALL ShowMessage(Alert$, 1)%@NL@%
        COLOR YELLOW + BRIGHT, BACKGROUND%@NL@%
        INPUT "Try another number: ", TempString$%@NL@%
        BigRec.Lendee.CardNum = VAL(TempString$)%@NL@%
      LOOP UNTIL BigRec.Lendee.CardNum%@NL@%
    END IF%@NL@%
    COLOR FOREGROUND, BACKGROUND%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'********************************* EditCheck SUB ***************************%@AE@%%@NL@%
%@AB@%'*                                                                         *%@AE@%%@NL@%
%@AB@%'* The EditCheck procedure monitors what the user wants to do, and if the  *%@AE@%%@NL@%
%@AB@%'* choice is EDITRECORD, makes sure that a transaction is begun, or if it  *%@AE@%%@NL@%
%@AB@%'* already has begun, continues it. If a transaction has been pending, and *%@AE@%%@NL@%
%@AB@%'* the user chooses anything except EDITRECORD, then the transaction is    *%@AE@%%@NL@%
%@AB@%'* committed.                                                              *%@AE@%%@NL@%
%@AB@%'*                                                                         *%@AE@%%@NL@%
%@AB@%'*                            Parameters:                                  *%@AE@%%@NL@%
%@AB@%'*   Pending      A flag that indicates whether transaction is pending     *%@AE@%%@NL@%
%@AB@%'*   Task         Tells what operation the user wants to perform now       *%@AE@%%@NL@%
%@AB@%'*   TablesRec    Structure containing information about the tables        *%@AE@%%@NL@%
%@AB@%'*                                                                         *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB EditCheck (Pending, Task, TablesRec AS RecStruct)%@NL@%
%@AB@%  ' First, decide if this is a new or pending transaction, or not one at all%@AE@%%@NL@%
%@AB@%  ' The only transaction in this program keeps edits to the current record%@AE@%%@NL@%
%@AB@%  ' pending until the user moves on to a new record or a new operation%@AE@%%@NL@%
%@AB@%  ' (for example a Reorder).%@AE@%%@NL@%
SHARED n                          ' n is index to array of savepoint ids%@NL@%
%@NL@%
      IF Task = EDITRECORD THEN%@NL@%
        IF Pending = FALSE THEN%@NL@%
          BEGINTRANS%@NL@%
          Pending = TRUE%@NL@%
        END IF%@NL@%
      ELSEIF Pending = TRUE THEN  ' Equivalent to Task<>EDITRECORD AND%@NL@%
        COMMITTRANS               ' Pending=TRUE%@NL@%
        Pending = FALSE%@NL@%
        n = 0                     ' Reset array index for savepoint ids%@NL@%
        CALL DrawIndexBox(TablesRec.TableNum, 0)%@NL@%
      END IF%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The GetInput FUNCTION takes the keystroke input by the user and returns*%@AE@%%@NL@%
%@AB@%'*  a constant indicating what the user wants to do. If the keystroke rep- *%@AE@%%@NL@%
%@AB@%'*  resents a valid operation, the choice is echoed to the screen.         *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION GetInput% (BigRec AS RecStruct)%@NL@%
DO%@NL@%
  Answer$ = INKEY$%@NL@%
LOOP WHILE Answer$ = EMPTYSTRING%@NL@%
  IF LEN(Answer$) > 1 THEN%@NL@%
    RightSide = HighKeys%(Answer$)%@NL@%
    GetInput = RightSide%@NL@%
  ELSE%@NL@%
    SELECT CASE Answer$%@NL@%
      CASE "A", "a"%@NL@%
        CALL UserChoice(BigRec, ALINE, 7, "Add Record")%@NL@%
        GetInput% = ADDRECORD%@NL@%
      CASE "B", "b"%@NL@%
        IF BigRec.TableNum = cBookStockTableNum THEN%@NL@%
          CALL UserChoice(BigRec, WLINE, 28, "Borrower")%@NL@%
          GetInput% = BORROWER%@NL@%
        ELSE%@NL@%
          CALL UserChoice(BigRec, WLINE, 13, "Books Outstanding")%@NL@%
          GetInput% = WHICHBOOKS%@NL@%
        END IF%@NL@%
      CASE "O", "o"%@NL@%
        CALL UserChoice(BigRec, CLINE, 7, "Check Book Out")%@NL@%
        GetInput% = CHECKOUT%@NL@%
      CASE "I", "i"%@NL@%
        CALL UserChoice(BigRec, CLINE, 28, "Check In")%@NL@%
        GetInput% = CHECKIN%@NL@%
      CASE "D", "d"%@NL@%
        CALL UserChoice(BigRec, ALINE, 28, "Drop Record")%@NL@%
        GetInput% = TOSSRECORD%@NL@%
      CASE "N", "n"%@NL@%
        GetInput% = GOAHEAD%@NL@%
      CASE "P", "p"%@NL@%
        GetInput% = GOBACK%@NL@%
      CASE "Q", "q"%@NL@%
        CALL UserChoice(BigRec, ELINE, 28, "Quit")%@NL@%
        GetInput% = QUIT%@NL@%
      CASE "E", "e"%@NL@%
        CALL UserChoice(BigRec, ELINE, 7, "Edit Record")%@NL@%
        GetInput% = EDITRECORD%@NL@%
      CASE "F", "f"%@NL@%
        CALL UserChoice(BigRec, RLINE, 28, "Find Record")%@NL@%
        GetInput% = SEEKFIELD%@NL@%
      CASE "R", "r"%@NL@%
        CALL UserChoice(BigRec, RLINE, 7, "Reorder Records")%@NL@%
        GetInput% = REORDER%@NL@%
      CASE "V", "v"%@NL@%
        GetInput% = OTHERTABLE%@NL@%
      CASE "W", "w"%@NL@%
        CALL UserChoice(BigRec, WLINE, 7, "When Due Back")%@NL@%
        GetInput% = STATUS%@NL@%
      CASE CHR$(ESCAPE)%@NL@%
        GetInput% = ESCAPE%@NL@%
      CASE "U", "u"%@NL@%
        GetInput = UNDO       ' U signals rollback request after editing%@NL@%
      CASE CHR$(CTRLU)        ' ^U = rollback a whole series of edits%@NL@%
        GetInput = UNDOALL%@NL@%
      CASE ELSE%@NL@%
        GetInput% = INVALIDKEY%@NL@%
        BEEP%@NL@%
    END SELECT%@NL@%
  END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
%@AB@%'*  The HighKeys FUNCTION handles common two-byte keys input by the user. *%@AE@%%@NL@%
%@AB@%'*  The Answer parameter is the keystroke entered by the user.            *                                                          *%@AE@%%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
FUNCTION HighKeys (Answer AS STRING)%@NL@%
  SELECT CASE ASC(RIGHT$(Answer$, 1))     ' Look at code for right byte%@NL@%
    CASE UP%@NL@%
      HighKeys = GOBACK                   ' UP is the up-arrow key%@NL@%
    CASE DOWN%@NL@%
      HighKeys = GOAHEAD                  ' DOWN is the down-arrow key%@NL@%
    CASE HOME%@NL@%
      HighKeys = HOME                     ' etc.%@NL@%
    CASE ENDK%@NL@%
      HighKeys = ENDK%@NL@%
      CASE LEFT%@NL@%
      HighKeys = OTHERTABLE%@NL@%
    CASE RIGHT%@NL@%
      HighKeys = OTHERTABLE%@NL@%
    CASE PGUP%@NL@%
      CALL ShowMessage("You could program so PGUP moves back n records", 0): SLEEP%@NL@%
      HighKeys = INVALIDKEY%@NL@%
    CASE PGDN%@NL@%
      CALL ShowMessage("You could program so PGDN moves forward n records", 0): SLEEP%@NL@%
      HighKeys = INVALIDKEY%@NL@%
    CASE ELSE%@NL@%
      CALL ShowMessage("Sorry, that key isn't handled yet.", 0): SLEEP%@NL@%
      HighKeys = INVALIDKEY%@NL@%
  END SELECT%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'****************************** Retriever SUB ******************************%@AE@%%@NL@%
%@AB@%'* The Retriever SUB retrieves records from the database file and puts     *%@AE@%%@NL@%
%@AB@%'* them into the appropriate recordvariable for the table being displayed. *%@AE@%%@NL@%
%@AB@%'* An error trap is set in case the retrieve fails, in which case a message*%@AE@%%@NL@%
%@AB@%'* is displayed. Note that if a preceding SEEKoperand fails, EOF is TRUE.  *%@AE@%%@NL@%
%@AB@%'* In that case, position is set to the last record, which is retrieved.   *%@AE@%%@NL@%
%@AB@%'*                            Parameters:                                  *%@AE@%%@NL@%
%@AB@%'*   Big Rec      User-defined type containing all table information       *%@AE@%%@NL@%
%@AB@%'*   DimN & DimP  Flags telling which menu items should be dimmed/changed  *%@AE@%%@NL@%
%@AB@%'*   Task         Tells what operation retrieve results from               *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB Retriever (BigRec AS RecStruct, DimN, DimP, Task)%@NL@%
  STATIC PeekFlag         ' Set this if user is just peeking at other table%@NL@%
  LOCATE , , 0            ' Turn off the cursor%@NL@%
%@AB@%  ' Show the user which choice was made, and whether EOF or BOF%@AE@%%@NL@%
  CALL ShowKeys(BigRec, FOREGROUND + BRIGHT, DimN, DimP)%@NL@%
%@AB@%  ' If table is empty, don't try to retrieve anything%@AE@%%@NL@%
  IF LOF(BigRec.TableNum) = 0 THEN%@NL@%
    DrawTable (BigRec.TableNum)%@NL@%
    CALL ShowMessage("There are no records in this table", 0): EXIT SUB%@NL@%
  END IF%@NL@%
%@NL@%
  IF Task <> ENDK AND Task <> HOME THEN%@NL@%
    IF Task < EDITRECORD THEN                         ' Edit needs its%@NL@%
      CALL Indexbox(BigRec, CheckIndex%(BigRec, 0))   ' own prompts. Show%@NL@%
    ELSEIF Task > INVALIDKEY THEN                     ' indexbox otherwise%@NL@%
      IF Task <> ESC THEN CALL DrawIndexBox(BigRec.TableNum, 0)%@NL@%
      CALL Indexbox(BigRec, CheckIndex%(BigRec, 0))%@NL@%
    END IF%@NL@%
  END IF%@NL@%
  IF BOF(BigRec.TableNum) THEN MOVEFIRST (BigRec.TableNum)%@NL@%
  ON LOCAL ERROR GOTO LocalHandler           ' Trap errors on the retrieve.%@NL@%
  IF NOT EOF(BigRec.TableNum) THEN           ' Retrieve current record%@NL@%
    SELECT CASE BigRec.TableNum              ' from table being displayed%@NL@%
      CASE cBookStockTableNum                ' if EOF is not true%@NL@%
        RETRIEVE BigRec.TableNum, BigRec.Inventory%@NL@%
      CASE cCardHoldersTableNum%@NL@%
        RETRIEVE BigRec.TableNum, BigRec.Lendee%@NL@%
    END SELECT%@NL@%
  ELSE                                       ' If EOF is true, set position%@NL@%
    MOVELAST BigRec.TableNum                 ' to the last record in table,%@NL@%
    SELECT CASE BigRec.TableNum              ' then retrieve the record%@NL@%
      CASE cBookStockTableNum%@NL@%
        RETRIEVE BigRec.TableNum, BigRec.Inventory%@NL@%
      CASE cCardHoldersTableNum%@NL@%
        RETRIEVE BigRec.TableNum, BigRec.Lendee%@NL@%
    END SELECT%@NL@%
    DimN = TRUE%@NL@%
  END IF%@NL@%
  ON LOCAL ERROR GOTO 0                             ' Turn off error trap%@NL@%
  CALL ClearEm(BigRec.TableNum, 1, 1, 1, 1, 1, 1)%@NL@%
  CALL ShowRecord(BigRec)%@NL@%
  IF Task = OTHERTABLE THEN   ' If user is just peeking at the other table%@NL@%
    IF PeekFlag = 0 THEN      ' remind him how to get back to first table%@NL@%
      CALL ShowMessage("Press V to return to the other table", 0)%@NL@%
      PeekFlag = 1%@NL@%
    END IF%@NL@%
  ELSE%@NL@%
    PeekFlag = 0%@NL@%
  END IF%@NL@%
EXIT SUB%@NL@%
%@NL@%
LocalHandler:%@NL@%
  IF ERR = 85 THEN%@NL@%
    CALL ShowMessage("Unable to retrieve your record...", 0)%@NL@%
  END IF%@NL@%
  RESUME NEXT%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'********************************* SeekRecord SUB *************************%@AE@%%@NL@%
%@AB@%'*  SeekRecord takes the name of the user's chosen index, sets it as the  *%@AE@%%@NL@%
%@AB@%'*  current index, then prompts the user to enter the value to seek. A    *%@AE@%%@NL@%
%@AB@%'*  minimal editor, MakeString, gets user input. If the SEEK is on a com- *%@AE@%%@NL@%
%@AB@%'*  bined index, GetKeyVals is called to get the input. Input is checked  *%@AE@%%@NL@%
%@AB@%'*  for minimal acceptability by ValuesOK. If it is OK, GetOperand is     *%@AE@%%@NL@%
%@AB@%'*  called to let the user specify how to conduct the SEEK.               *%@AE@%%@NL@%
%@AB@%'*                              Parameters:                               *%@AE@%%@NL@%
%@AB@%'*      TablesRec  Contains current record information for all tables     *%@AE@%%@NL@%
%@AB@%'*      TempRec    Contains the name of the index on which to seek (in    *%@AE@%%@NL@%
%@AB@%'*                 TempRec.WhichIndex element)                            *%@AE@%%@NL@%
%@AB@%'*      Letter$    If the user starts typing instead of pressing ENTER    *%@AE@%%@NL@%
%@AB@%'*                 Letter$ catches the keystroke, passes it to MakeString *%@AE@%%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
SUB SeekRecord (TablesRec AS RecStruct, TempRec AS RecStruct, Letter$)%@NL@%
  DIM EmptyRec AS RecStruct             ' Make an empty record.%@NL@%
  IF LEFT$(Letter$, 1) < " " THEN       ' Exit if value is not a valid%@NL@%
%@AB@%                                        ' character, then redraw%@AE@%%@NL@%
    CALL DrawIndexBox(TablesRec.TableNum, SEEKFIELD)%@NL@%
    CALL Indexbox(TablesRec, CheckIndex%(TablesRec, TRUE))%@NL@%
    CALL ShowMessage("You must enter a valid string or numeric value", 0)%@NL@%
    EXIT SUB%@NL@%
  END IF%@NL@%
  TheTable = TablesRec.TableNum%@NL@%
  IndexName$ = RTRIM$(TempRec.WhichIndex)%@NL@%
  IF GETINDEX$(TheTable) <> IndexName$ THEN  ' If index to seek on is not%@NL@%
    ON LOCAL ERROR GOTO SeekHandler          ' current, set it now. Trap%@NL@%
    SETINDEX TheTable, IndexName$            ' possible failure of SETINDEX%@NL@%
    ON LOCAL ERROR GOTO 0                    ' then turn off error trap.%@NL@%
  END IF%@NL@%
  CALL AdjustIndex(TablesRec)                ' Show the current index%@NL@%
  TablesRec.WhichIndex = TempRec.WhichIndex%@NL@%
  TempRec = EmptyRec                         ' Clear TempRec for data%@NL@%
  TempRec.TableNum = TablesRec.TableNum%@NL@%
%@AB@%  ' Get the value to SEEK for from the user. The data type you assign the%@AE@%%@NL@%
%@AB@%  ' input to must be the same as the data in the database, so get it as a%@AE@%%@NL@%
%@AB@%  ' string with MakeString, then convert it to proper type for index. If%@AE@%%@NL@%
%@AB@%  ' the index is the combined index BigIndex, use GetKeyVals for input...%@AE@%%@NL@%
%@NL@%
 SELECT CASE RTRIM$(LTRIM$(IndexName$))%@NL@%
   CASE "TitleIndexBS", "AuthorIndexBS", "PubIndexBS", "NameIndexCH", "StateIndexCH"%@NL@%
    Prompt$ = "Value To Seek: "%@NL@%
    Key1$ = MakeString$(ASC(Letter$), Prompt$): IF Key1$ = "" THEN EXIT SUB%@NL@%
   CASE "IDIndex", "CardNumIndexCH", "ZipIndexCH"%@NL@%
    ValueToSeek$ = MakeString$(ASC(Letter$), Prompt$)%@NL@%
    IF ValueToSeek$ = "" THEN EXIT SUB%@NL@%
    IF IndexName$ = "IDIndex" THEN%@NL@%
      NumberToSeek# = VAL(ValueToSeek$)%@NL@%
      Key1$ = ValueToSeek$%@NL@%
    ELSE%@NL@%
      NumberToSeek& = VAL(ValueToSeek$)%@NL@%
      Key1$ = ValueToSeek$%@NL@%
    END IF%@NL@%
   CASE "BigIndex"%@NL@%
    CALL GetKeyVals(TempRec, Key1$, Key2$, Key3#, Letter$)%@NL@%
    ValueToSeek$ = STR$(Key3#)%@NL@%
   CASE ""%@NL@%
     Alert$ = "Sorry, can't search for field values on the default index"%@NL@%
     CALL ShowMessage(Alert$, 0)%@NL@%
   CASE ELSE%@NL@%
  END SELECT%@NL@%
%@NL@%
%@AB@%  ' Make sure the input values are minimally acceptable%@AE@%%@NL@%
%@NL@%
  IF NOT ValuesOK(TablesRec, Key1$, Key2$, ValueToSeek$) THEN%@NL@%
    CALL ShowMessage("Sorry, problem with your entry. Try again!", 0)%@NL@%
    EXIT SUB%@NL@%
  END IF%@NL@%
%@NL@%
%@AB@%  ' Show the user the values he entered in their appropriate fields%@AE@%%@NL@%
  CALL ClearEm(TablesRec.TableNum, 1, 1, 1, 1, 1, 1)%@NL@%
  CALL ShowIt(TempRec, IndexName$, TheTable, Key1$)%@NL@%
%@NL@%
%@AB@%  ' GetOperand lets user specify the way the SEEK is to be conducted ---%@AE@%%@NL@%
%@AB@%  ' either  =, >, >=, <, or <= the value that was entered above%@AE@%%@NL@%
%@NL@%
  DidIt = GetOperand%(Operand$)%@NL@%
%@NL@%
%@AB@%  ' The actual SEEK has to be done according to two factors, the Index on%@AE@%%@NL@%
%@AB@%  ' which it is conducted, and the condition chosen in GetOperand. In the%@AE@%%@NL@%
%@AB@%  ' next section, case on the Operand returned, then IF and ELSEIF on the%@AE@%%@NL@%
%@AB@%  ' basis of the index on which the search is being conducted%@AE@%%@NL@%
%@NL@%
  IF Operand$ <> "<>" THEN                ' "<>" represents user ESC choice%@NL@%
%@NL@%
   SELECT CASE Operand$%@NL@%
    CASE "", "="                        ' If operand ="" or "=", use =%@NL@%
      IF IndexName$ = "BigIndex" THEN%@NL@%
        IF INSTR(Key2$, ",") = 0 THEN Key2$ = TransposeName(Key2$) ' a name%@NL@%
        SEEKEQ TheTable, Key1$, Key2$, Key3#%@NL@%
      ELSEIF IndexName$ = "NameIndexCH" OR IndexName$ = "AuthorIndexBS" THEN%@NL@%
        IF INSTR(Key1$, ",") = 0 THEN Key1$ = TransposeName(Key1$) ' a name%@NL@%
        SEEKEQ TheTable, LTRIM$(RTRIM$(Key1$))%@NL@%
      ELSEIF IndexName$ = "IDIndex" THEN%@NL@%
        SEEKEQ TheTable, NumberToSeek#%@NL@%
      ELSEIF IndexName$ = "CardNumIndexCH" OR IndexName$ = "ZipIndexCH" THEN%@NL@%
        SEEKEQ TheTable, NumberToSeek&%@NL@%
      ELSE%@NL@%
        SEEKEQ TheTable, Key1$%@NL@%
      END IF%@NL@%
    CASE ">="                      ' at least gets them close%@NL@%
      IF IndexName$ = "BigIndex" THEN%@NL@%
        IF INSTR(Key2$, ",") = 0 THEN Key2$ = TransposeName(Key2$) ' a name%@NL@%
        SEEKGE TheTable, Key1$, Key2$, Key3#%@NL@%
      ELSEIF IndexName$ = "NameIndexCH" OR IndexName$ = "AuthorIndexBS" THEN%@NL@%
        IF INSTR(Key1$, ",") = 0 THEN Key1$ = TransposeName(Key1$)%@NL@%
        SEEKGE TheTable, Key1$%@NL@%
      ELSEIF IndexName$ = "IDIndex" THEN%@NL@%
        SEEKGE TheTable, NumberToSeek#%@NL@%
      ELSEIF IndexName$ = "CardNumIndexCH" OR IndexName$ = "ZipIndexCH" THEN%@NL@%
        SEEKGE TheTable, NumberToSeek&%@NL@%
      ELSE%@NL@%
        SEEKGE TheTable, Key1$%@NL@%
      END IF%@NL@%
    CASE ">"%@NL@%
      IF IndexName$ = "BigIndex" THEN%@NL@%
        IF INSTR(Key2$, ",") = 0 THEN Key2$ = TransposeName(Key2$)%@NL@%
        SEEKGT TheTable, Key1$, Key2$, Key3#%@NL@%
      ELSEIF IndexName$ = "NameIndexCH" OR IndexName$ = "AuthorIndexBS" THEN%@NL@%
        IF INSTR(Key1$, ",") = 0 THEN Key1$ = TransposeName(Key1$)%@NL@%
        SEEKGT TheTable, Key1$%@NL@%
      ELSEIF IndexName$ = "IDIndex" THEN%@NL@%
        SEEKGT TheTable, NumberToSeek#%@NL@%
      ELSEIF IndexName$ = "CardNumIndexCH" OR IndexName$ = "ZipIndexCH" THEN%@NL@%
        SEEKGT TheTable, NumberToSeek&%@NL@%
      ELSE%@NL@%
        SEEKGT TheTable, Key1$%@NL@%
      END IF%@NL@%
    CASE "<="%@NL@%
      IF IndexName$ = "BigIndex" THEN%@NL@%
        IF INSTR(Key2$, ",") = 0 THEN Key2$ = TransposeName(Key2$)%@NL@%
        SEEKGT TheTable, Key1$, Key2$, Key3#%@NL@%
        MOVEPREVIOUS TheTable%@NL@%
      ELSEIF IndexName$ = "NameIndexCH" OR IndexName$ = "AuthorIndexBS" THEN%@NL@%
        IF INSTR(Key1$, ",") = 0 THEN Key1$ = TransposeName(Key1$)%@NL@%
        SEEKGT TheTable, Key1$%@NL@%
        MOVEPREVIOUS TheTable%@NL@%
      ELSEIF IndexName$ = "IDIndex" THEN%@NL@%
        SEEKGT TheTable, NumberToSeek#%@NL@%
        MOVEPREVIOUS TheTable%@NL@%
      ELSEIF IndexName$ = "CardNumIndexCH" OR IndexName$ = "ZipIndexCH" THEN%@NL@%
        SEEKGT TheTable, NumberToSeek&%@NL@%
        MOVEPREVIOUS TheTable%@NL@%
      ELSE%@NL@%
        SEEKGT TheTable, Key1$%@NL@%
        MOVEPREVIOUS TheTable%@NL@%
      END IF%@NL@%
    CASE "<"%@NL@%
      IF IndexName$ = "BigIndex" THEN%@NL@%
        IF INSTR(Key2$, ",") = 0 THEN Key2$ = TransposeName(Key2$)%@NL@%
        SEEKGE TheTable, Key1$, Key2$, Key3#%@NL@%
        MOVEPREVIOUS TheTable%@NL@%
      ELSEIF IndexName$ = "NameIndexCH" OR IndexName$ = "AuthorIndexBS" THEN%@NL@%
        IF INSTR(Key1$, ",") = 0 THEN Key1$ = TransposeName(Key1$)%@NL@%
        SEEKGE TheTable, Key1$%@NL@%
        MOVEPREVIOUS TheTable%@NL@%
      ELSEIF IndexName$ = "IDIndex" THEN%@NL@%
        SEEKGE TheTable, NumberToSeek#%@NL@%
        MOVEPREVIOUS TheTable%@NL@%
      ELSEIF IndexName$ = "CardNumIndexCH" OR IndexName$ = "ZipIndexCH" THEN%@NL@%
        SEEKGE TheTable, NumberToSeek&%@NL@%
        MOVEPREVIOUS TheTable%@NL@%
      ELSE%@NL@%
        SEEKGE TheTable, Key1$%@NL@%
        MOVEPREVIOUS TheTable%@NL@%
      END IF%@NL@%
    CASE ELSE%@NL@%
      Alert$ = "The returned operand was " + Operand$%@NL@%
      CALL ShowMessage(Alert$, 0)%@NL@%
      SLEEP%@NL@%
  END SELECT%@NL@%
 ELSE                        ' If they choose ESC, go back to module level%@NL@%
   CALL DrawScreen(TheTable)%@NL@%
   CALL ShowRecord(TablesRec)%@NL@%
   Alert$ = "You've escaped. " + KEYSMESSAGE%@NL@%
   CALL ShowMessage(Alert$, 0)%@NL@%
   SLEEP%@NL@%
   Operand$ = ""%@NL@%
 END IF%@NL@%
  CALL EraseMessage%@NL@%
  CALL DrawScreen(TheTable)%@NL@%
  CALL Indexbox(TablesRec, CheckIndex%(TablesRec, FALSE))%@NL@%
 IF EOF(TablesRec.TableNum) THEN%@NL@%
  Alert$ = "Sorry,  unable to match value you entered with any field value"%@NL@%
  CALL ShowMessage(Alert$, 0):  ' SLEEP: EraseMessage%@NL@%
 END IF%@NL@%
%@NL@%
EXIT SUB%@NL@%
%@NL@%
SeekHandler:%@NL@%
 IF ERR = 83 THEN                          ' 83 = Index not found%@NL@%
    CALL DrawScreen(TablesRec.TableNum)%@NL@%
    Alert$ = "SETINDEX for " + IndexName$ + " failed. Need more buffers?"%@NL@%
    CALL ShowMessage(Alert$, 0)%@NL@%
    EXIT SUB%@NL@%
 END IF%@NL@%
%@NL@%
END SUB   ' End of SeekRecord procedure%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BOOKMOD1.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\BOOKMOD1.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'***********************************************************************%@AE@%%@NL@%
%@AB@%'*      This is module level code for BOOKMOD2.BAS, and contains screen*%@AE@%%@NL@%
%@AB@%'*      drawing and user interface maintenance routines. This module   *%@AE@%%@NL@%
%@AB@%'*      doesn't contain ISAM statements.                               *%@AE@%%@NL@%
%@AB@%'***********************************************************************%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@AB@%'$INCLUDE: 'booklook.bi'%@AE@%%@NL@%
KeysBox:%@NL@%
  DATA ""%@NL@%
  DATA "                                      "%@NL@%
  DATA "                                      "%@NL@%
  DATA "                                      "%@NL@%
  DATA "                                      "%@NL@%
  DATA "                                      "%@NL@%
  DATA "                                      "%@NL@%
  DATA "                                      "%@NL@%
  DATA " Keys for Database Viewing/Editing "%@NL@%
%@NL@%
HelpKeys1:%@NL@%
  DATA ""%@NL@%
  DATA "N = Next Record      P = Previous   "%@NL@%
  DATA "R = Reorder Records  F = Find Record"%@NL@%
  DATA "W = When Due Back    B = Borrower   "%@NL@%
  DATA "      V = View Other Table          "%@NL@%
  DATA "A = Add Record       D = Drop Record"%@NL@%
  DATA "E = Edit Record      Q = Quit       "%@NL@%
  DATA "O = Check Book Out   I = Check In   "%@NL@%
  DATA ""%@NL@%
%@NL@%
HelpKeys2:%@NL@%
  DATA ""%@NL@%
  DATA "N = Next Record      P = Previous   "%@NL@%
  DATA "R = Reorder Records  F = Find Record"%@NL@%
  DATA "      B = Books Outstanding         "%@NL@%
  DATA "      V = View Other Table          "%@NL@%
  DATA "A = Add Record       D = Drop Record"%@NL@%
  DATA "E = Edit Record      Q = Quit       "%@NL@%
  DATA "                                    "%@NL@%
  DATA ""%@NL@%
%@NL@%
Indexbox1:%@NL@%
  DATA ""%@NL@%
  DATA " By Titles                 "%@NL@%
  DATA " By Authors                "%@NL@%
  DATA " By Publishers             "%@NL@%
  DATA " By ID numbers             "%@NL@%
  DATA " By Title + Author + ID    "%@NL@%
  DATA " Default = Insertion order "%@NL@%
  DATA "                           "%@NL@%
  DATA " Current Sorting Order "%@NL@%
Indexbox2:%@NL@%
  DATA ""%@NL@%
  DATA " By Name                   "%@NL@%
  DATA " By State                  "%@NL@%
  DATA " By Zip code               "%@NL@%
  DATA " By Card number            "%@NL@%
  DATA "                           "%@NL@%
  DATA " Default = Insertion order "%@NL@%
  DATA "                           "%@NL@%
  DATA " Current Sorting Order "%@NL@%
%@NL@%
%@NL@%
BooksTable:%@NL@%
DATA ""%@NL@%
DATA "                                                                    "%@NL@%
DATA "    Title:                                                          "%@NL@%
DATA "                                                                    "%@NL@%
DATA "    Author:                                                         "%@NL@%
DATA "                                                                    "%@NL@%
DATA "    Publisher:                                                      "%@NL@%
DATA "                                                                    "%@NL@%
DATA "    Edition:                                                        "%@NL@%
DATA "                                                                    "%@NL@%
DATA "    Price:                                                          "%@NL@%
DATA "                                                                    "%@NL@%
DATA "    ID number:                                                      "%@NL@%
DATA ""%@NL@%
%@NL@%
%@NL@%
LendeesTable:%@NL@%
DATA ""%@NL@%
DATA "                                                                    "%@NL@%
DATA "   Name:                                                            "%@NL@%
DATA "                                                                    "%@NL@%
DATA "   Street:                                                          "%@NL@%
DATA "                                                                    "%@NL@%
DATA "   City:                                                            "%@NL@%
DATA "                                                                    "%@NL@%
DATA "   State:                                                           "%@NL@%
DATA "                                                                    "%@NL@%
DATA "   Zipcode:                                                         "%@NL@%
DATA "                                                                    "%@NL@%
DATA "   Card number:                                                     "%@NL@%
DATA ""%@NL@%
%@NL@%
OperandBox:%@NL@%
DATA ""%@NL@%
DATA "                           "%@NL@%
DATA " Greater Than              "%@NL@%
DATA " or                        "%@NL@%
DATA " Equal To     Value Entered"%@NL@%
DATA " or                        "%@NL@%
DATA " Less Than                 "%@NL@%
DATA "                           "%@NL@%
DATA " Relationship to Key "%@NL@%
%@NL@%
EditMessage:%@NL@%
DATA ""%@NL@%
DATA " A log is being kept while "%@NL@%
DATA " you edit fields in this   "%@NL@%
DATA " record. Press U to undo   "%@NL@%
DATA " each preceding edit, or   "%@NL@%
DATA " CTRL+U to undo all of the "%@NL@%
DATA " pending edits as a group. "%@NL@%
DATA "                           "%@NL@%
DATA " To Undo Edits "%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The ClearEm SUB erases the parts of the screen where table record col- *%@AE@%%@NL@%
%@AB@%'*  umn information is displayed, depending on which fields are specified. *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  TableNum    Integer specifying the table being displayed               *%@AE@%%@NL@%
%@AB@%'*  Field?      Boolean values specifying which fields to erase            *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB ClearEm (TableNum%, Field1%, Field2%, Field3%, Field4%, Field5%, Field6%)%@NL@%
%@NL@%
  DIM ToClear(10) AS INTEGER%@NL@%
%@NL@%
  ToClear(0) = Field1: ToClear(1) = Field2: ToClear(2) = Field3%@NL@%
  ToClear(3) = Field4: ToClear(4) = Field5: ToClear(5) = Field6%@NL@%
%@NL@%
  COLOR FOREGROUND, BACKGROUND%@NL@%
%@NL@%
      FOR Index = 0 TO 5%@NL@%
        IF ToClear(Index) THEN%@NL@%
          SELECT CASE Index%@NL@%
            CASE 0%@NL@%
              LOCATE TITLEFIELD, 18%@NL@%
              PRINT "                                                    "%@NL@%
            CASE 1%@NL@%
              LOCATE AUTHORFIELD, 18%@NL@%
              PRINT "                                                    "%@NL@%
            CASE 2%@NL@%
              LOCATE PUBFIELD, 18%@NL@%
              PRINT "                                                    "%@NL@%
            CASE 3%@NL@%
              LOCATE EDFIELD, 18%@NL@%
              PRINT "                                                    "%@NL@%
            CASE 4%@NL@%
              IF TableNum% = cCardHoldersTableNum THEN%@NL@%
                LOCATE PRICEFIELD, 18%@NL@%
                PRINT "                                                    "%@NL@%
              ELSE%@NL@%
                LOCATE PRICEFIELD, 19%@NL@%
                PRINT "                                                   "%@NL@%
              END IF%@NL@%
            CASE 5%@NL@%
              LOCATE IDFIELD, 18%@NL@%
              PRINT "                                                    "%@NL@%
          END SELECT%@NL@%
        END IF%@NL@%
      NEXT Index%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
%@AB@%'*  The ConfirmEntry FUNCTION echoes the user's input and processes his   *%@AE@%%@NL@%
%@AB@%'*  response to make sure the proper action is taken.                     *%@AE@%%@NL@%
%@AB@%'*                                 Parameters                             *%@AE@%%@NL@%
%@AB@%'*  Letter$   Contains the input that the user has just entered.          *%@AE@%%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
FUNCTION ConfirmEntry% (Letter$)%@NL@%
  Alert$ = "Press ENTER to confirm choice, type value, or TAB to move on"%@NL@%
  CALL ShowMessage(Alert$, 1)%@NL@%
  DO%@NL@%
  Answer$ = INKEY$%@NL@%
  LOOP WHILE Answer$ = EMPTYSTRING%@NL@%
  Reply% = ASC(Answer$)%@NL@%
%@NL@%
  SELECT CASE Reply%%@NL@%
    CASE ENTER%@NL@%
      ConfirmEntry% = -1%@NL@%
      Letter$ = ""%@NL@%
    CASE TABKEY%@NL@%
      ConfirmEntry% = 0%@NL@%
      Letter$ = Answer$%@NL@%
    CASE ASC(" ") TO ASC("~")%@NL@%
      Letter$ = Answer$%@NL@%
      ConfirmEntry = -1%@NL@%
    CASE ELSE%@NL@%
      ConfirmEntry% = 0%@NL@%
      Letter$ = "eScApE"%@NL@%
      CALL ShowMessage("Invalid key --- Try again", 0)%@NL@%
   END SELECT%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*    The DrawHelpBoox SUB draws the menu box that links a key to a task.  *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB DrawHelpBox%@NL@%
  COLOR FOREGROUND, BACKGROUND%@NL@%
  RESTORE KeysBox%@NL@%
    FOR Row = BOXTOP TO BOXEND%@NL@%
      LOCATE Row, 1%@NL@%
      READ Temp$%@NL@%
      PRINT Temp$%@NL@%
      IF Row = BOXEND THEN%@NL@%
        COLOR BACKGROUND, FOREGROUND + BRIGHT%@NL@%
        LOCATE Row, HELPCOL + 3%@NL@%
        PRINT " Keys for Database Viewing/Editing "%@NL@%
        COLOR FOREGROUND, BACKGROUND%@NL@%
      END IF%@NL@%
    NEXT Row%@NL@%
  COLOR FOREGROUND, BACKGROUND%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*    The DrawHelpKeys SUB refills the menu box that links a key to a task.*%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*    TableNum    Integer identifying the table being displayed            *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB DrawHelpKeys (TableNum AS INTEGER)%@NL@%
%@NL@%
COLOR FOREGROUND, BACKGROUND%@NL@%
IF TableNum = cBookStockTableNum THEN RESTORE HelpKeys1 ELSE RESTORE HelpKeys2%@NL@%
FOR Row = BOXTOP TO BOXEND%@NL@%
  LOCATE Row, HELPCOL + 2%@NL@%
  READ Temp$%@NL@%
  PRINT Temp$%@NL@%
  IF Row = BOXEND THEN%@NL@%
    COLOR BACKGROUND, FOREGROUND + BRIGHT%@NL@%
    LOCATE Row, HELPCOL + 3%@NL@%
    PRINT " Keys for Database Viewing/Editing "%@NL@%
    COLOR FOREGROUND, BACKGROUND%@NL@%
    END IF%@NL@%
NEXT Row%@NL@%
COLOR FOREGROUND, BACKGROUND%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The DrawIndexBox procedure draws the appropriate index box, depending  *%@AE@%%@NL@%
%@AB@%'*  the table being displayed. If the task is EDITRECORD, the index box    *%@AE@%%@NL@%
%@AB@%'*  information is replaced with information about Undo and Undo All       *%@AE@%%@NL@%
%@AB@%'*                               Parameters                                *%@AE@%%@NL@%
%@AB@%'*  TableNum    Integer identifying the table being displayed              *%@AE@%%@NL@%
%@AB@%'*  Task        Integer identifying the task the user is involved in       *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB DrawIndexBox (TableNum AS INTEGER, Task%)%@NL@%
%@NL@%
COLOR FOREGROUND, BACKGROUND%@NL@%
%@NL@%
IF Task = EDITRECORD THEN%@NL@%
  RESTORE EditMessage%@NL@%
ELSE%@NL@%
  IF TableNum = 1 THEN RESTORE Indexbox1 ELSE RESTORE Indexbox2%@NL@%
END IF%@NL@%
%@NL@%
FOR Row = BOXTOP TO BOXEND%@NL@%
  LOCATE Row, 42%@NL@%
  READ Temp$%@NL@%
  PRINT Temp$%@NL@%
  IF Row = BOXEND THEN%@NL@%
    IF Task = EDITRECORD THEN%@NL@%
      COLOR FOREGROUND + BRIGHT, BACKGROUND%@NL@%
      LOCATE 19, INDBOX + 16%@NL@%
      PRINT "U"%@NL@%
      LOCATE 21, INDBOX + 2%@NL@%
      PRINT "CTRL+U"%@NL@%
      LOCATE Row, INDBOX + 7%@NL@%
      PRINT " To Undo Edits "%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
    ELSE%@NL@%
      COLOR BACKGROUND, FOREGROUND + BRIGHT%@NL@%
      LOCATE Row, INDBOX + 3%@NL@%
      PRINT " Current Sorting Order "%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
    END IF%@NL@%
  END IF%@NL@%
NEXT Row%@NL@%
COLOR FOREGROUND, BACKGROUND%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The DrawScreen SUB calls other procedures to draw the appropriate parts*%@AE@%%@NL@%
%@AB@%'*  of the screen for the table to be displayed.                           *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  TableNum    Integer telling which table is to be shown                 *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB DrawScreen (TableNum AS INTEGER)%@NL@%
  CALL DrawTable(TableNum)%@NL@%
  CALL DrawHelpBox%@NL@%
  CALL DrawHelpKeys(TableNum)%@NL@%
  CALL DrawIndexBox(TableNum, Task)%@NL@%
  CALL ShowMessage("", 0)%@NL@%
  COLOR FOREGROUND, BACKGROUND%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The DrawTable SUB draws and lables the table being displayed.          *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  TableNum    The number of the table currently being displayed          *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB DrawTable (TableNum AS INTEGER)%@NL@%
CALL ClearEm(TableNum, 1, 1, 1, 1, 1, 1)%@NL@%
VIEW PRINT%@NL@%
COLOR FOREGROUND, BACKGROUND%@NL@%
SELECT CASE TableNum%@NL@%
  CASE 1%@NL@%
    TableName$ = " Book Stock Table "%@NL@%
  CASE 2%@NL@%
    TableName$ = " Card Holders Table "%@NL@%
END SELECT%@NL@%
%@NL@%
HowLong = LEN(TableName$)%@NL@%
NameSpace$ = "" + STRING$(HowLong, 32) + ""%@NL@%
PlaceName = (72 \ 2) - (HowLong \ 2)%@NL@%
%@NL@%
IF TableNum = 1 THEN RESTORE BooksTable ELSE RESTORE LendeesTable%@NL@%
%@NL@%
COLOR FOREGROUND, BACKGROUND%@NL@%
%@NL@%
FOR Row = TABLETOP TO TABLEEND%@NL@%
  LOCATE Row, 1%@NL@%
  READ Temp$%@NL@%
  PRINT Temp$%@NL@%
  IF Row = TABLETOP THEN%@NL@%
    LOCATE TABLETOP, PlaceName%@NL@%
    PRINT NameSpace$%@NL@%
    COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
    LOCATE 1, PlaceName + 1%@NL@%
    PRINT TableName$%@NL@%
    COLOR FOREGROUND, BACKGROUND%@NL@%
  END IF%@NL@%
NEXT Row%@NL@%
COLOR FOREGROUND, BACKGROUND%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The EraseMessage SUB erases the message in the message box between the *%@AE@%%@NL@%
%@AB@%'*  displayed table and the menus at the bottom of the screen. It replaces *%@AE@%%@NL@%
%@AB@%'*  the corners of the table and menus that may have been overwritten      *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB EraseMessage%@NL@%
  COLOR FOREGROUND, BACKGROUND%@NL@%
       LOCATE MESBOXTOP, 1%@NL@%
       PRINT ""; STRING$(68, CHR$(205)); ""%@NL@%
       LOCATE MESFIELD, 1%@NL@%
       PRINT SPACE$(70)%@NL@%
       LOCATE MESBOXEND, 1%@NL@%
       PRINT ""; STRING$(38, CHR$(205)); " "; STRING$(27, CHR$(205)); ""%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'**************************** MakeString FUNCTION **************************%@AE@%%@NL@%
%@AB@%'*                                                                         *%@AE@%%@NL@%
%@AB@%'* The MakeString FUNCTION provides a minimal editor to operate in the     *%@AE@%%@NL@%
%@AB@%'* BOOKLOOK message box. A prompt is shown. The user can enter numbers,    *%@AE@%%@NL@%
%@AB@%'* letters, punctuation, the ENTER, BACKSPACE and ESC keys.                *%@AE@%%@NL@%
%@AB@%'*                                                                         *%@AE@%%@NL@%
%@AB@%'*                            Parameters:                                  *%@AE@%%@NL@%
%@AB@%'*   FilterTrap   Brings in a keystroke or letter by ASCII value           *%@AE@%%@NL@%
%@AB@%'*   ThisString   Prompt passed in depends on calling function             *%@AE@%%@NL@%
%@AB@%'*                                                                         *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION MakeString$ (FilterTrap AS INTEGER, ThisString$)%@NL@%
%@NL@%
MessageLen = LEN(ThisString$)                   ' Save length of the prompt%@NL@%
IF FilterTrap THEN                              ' then, if a letter was%@NL@%
  ThisString$ = ThisString$ + CHR$(FilterTrap)  ' passed in, add it to the%@NL@%
  NewString$ = CHR$(FilterTrap)                 ' prompt and use it to start%@NL@%
END IF                                          ' string to be returned.%@NL@%
CALL ShowMessage(ThisString$, 1)                ' Show the string and turn%@NL@%
DO                                              ' on cursor at end.%@NL@%
  DO%@NL@%
  Answer$ = INKEY$%@NL@%
  LOOP WHILE Answer$ = EMPTYSTRING%@NL@%
      SELECT CASE Answer$%@NL@%
        CASE CHR$(ESCAPE)%@NL@%
          FilterTrap = ESCAPE%@NL@%
          CALL ShowMessage(KEYSMESSAGE, 0)%@NL@%
          EXIT FUNCTION%@NL@%
        CASE " " TO "~"%@NL@%
          NewString$ = NewString$ + Answer$%@NL@%
          ThisString$ = ThisString$ + Answer$%@NL@%
          CALL ShowMessage(ThisString$, 1)%@NL@%
        CASE CHR$(BACKSPACE)%@NL@%
          ShortLen = LEN(ThisString$) - 1%@NL@%
          ThisString$ = MID$(ThisString$, 1, ShortLen)%@NL@%
          NewString$ = MID$(ThisString$, MessageLen + 1)%@NL@%
          CALL ShowMessage(ThisString$, 1)%@NL@%
        CASE CHR$(ENTER)%@NL@%
          LOCATE , , 0%@NL@%
          MakeString$ = LTRIM$(RTRIM$(NewString$))%@NL@%
          EXIT FUNCTION%@NL@%
        CASE ELSE%@NL@%
          BEEP%@NL@%
          CALL ShowMessage("Not a valid key --- press Space bar", 0)%@NL@%
      END SELECT%@NL@%
LOOP%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The ReturnKey$ FUNCTION gets a key from the user and returns its value *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION ReturnKey$%@NL@%
  DO%@NL@%
    Answer$ = INKEY$%@NL@%
  LOOP WHILE Answer$ = EMPTYSTRING%@NL@%
  ReturnKey$ = Answer$%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'******************************** ShowIt SUB ******************************%@AE@%%@NL@%
%@AB@%'*                                                                        *%@AE@%%@NL@%
%@AB@%'*    After the user enters a value to search for in a specific index,    *%@AE@%%@NL@%
%@AB@%'*    this SUB places the value in the proper element of the temporary    *%@AE@%%@NL@%
%@AB@%'*    record variable, then displays the value in the field. Finally,     *%@AE@%%@NL@%
%@AB@%'*    the user is prompted to choose the relationship the indexed value   *%@AE@%%@NL@%
%@AB@%'*    should have to the key that has been entered.                       *%@AE@%%@NL@%
%@AB@%'*                            Parameters:                                 *%@AE@%%@NL@%
%@AB@%'*    TabesRec:       A temporary recordvariable - same as BigRec         *%@AE@%%@NL@%
%@AB@%'*    WhichIndex:     Tells name of Index on which key should be sought   *%@AE@%%@NL@%
%@AB@%'*    WhichTable:     The number of the table currently being displayed   *%@AE@%%@NL@%
%@AB@%'*    StringTo Show:  Value user wants to search for in index             *%@AE@%%@NL@%
%@AB@%'*                                                                        *%@AE@%%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
SUB ShowIt (TablesRec AS RecStruct, WhichIndex$, WhichTable%, StringToShow$)%@NL@%
  TablesRec.TableNum = WhichTable%@NL@%
  TablesRec.WhichIndex = WhichIndex$%@NL@%
  COLOR BRIGHT + FOREGROUND, BACKGROUND%@NL@%
      SELECT CASE WhichIndex$%@NL@%
        CASE "TitleIndexBS"%@NL@%
          TablesRec.Inventory.Title = StringToShow$%@NL@%
        CASE "AuthorIndexBS"%@NL@%
          TablesRec.Inventory.Author = StringToShow$%@NL@%
        CASE "PubIndexBS"%@NL@%
          TablesRec.Inventory.Publisher = StringToShow$%@NL@%
        CASE "IDIndex"%@NL@%
          TablesRec.Inventory.IDnum = VAL(StringToShow$)%@NL@%
        CASE "NameIndexCH"%@NL@%
          TablesRec.Lendee.TheName = StringToShow$%@NL@%
        CASE "StateIndexCH"%@NL@%
          TablesRec.Lendee.State = StringToShow$%@NL@%
        CASE "ZipIndexCH"%@NL@%
          TablesRec.Lendee.Zip = VAL(StringToShow$)%@NL@%
        CASE "CardNumIndexCH"%@NL@%
          TablesRec.Lendee.CardNum = VAL(StringToShow$)%@NL@%
      END SELECT%@NL@%
    CALL ShowRecord(TablesRec)%@NL@%
  COLOR FOREGROUND, BACKGROUND%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The ShowKeys SUB presents the key the user should press for a desired  *%@AE@%%@NL@%
%@AB@%'*  operation associated with a description of the task.                   *%@AE@%%@NL@%
%@AB@%'*                               Parameters                                *%@AE@%%@NL@%
%@AB@%'*  TablesRec   RecStruct type variable containing table information       *%@AE@%%@NL@%
%@AB@%'*  ForeGrnd    Integer indicating whether key is highlighted or not       *%@AE@%%@NL@%
%@AB@%'*  TableDone   1 for No Next Record, 0 otherwise (usually DimN)           *%@AE@%%@NL@%
%@AB@%'*  TableStart  1 for No Previous Record, 0 otherwise (usually DimP)       *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB ShowKeys (TablesRec AS RecStruct, ForeGrnd%, TableDone%, TableStart%)%@NL@%
  COLOR ForeGrnd, BACKGROUND                    'foreground bright%@NL@%
  LOCATE NLINE, 3%@NL@%
  PRINT "N"%@NL@%
  LOCATE NLINE, 24%@NL@%
  PRINT "P"%@NL@%
  LOCATE RLINE, 3%@NL@%
  PRINT "R"%@NL@%
  LOCATE RLINE, 24%@NL@%
  PRINT "F"%@NL@%
  IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
    LOCATE WLINE, 3%@NL@%
    PRINT "W"%@NL@%
    LOCATE WLINE, 24%@NL@%
    PRINT "B"%@NL@%
  ELSE%@NL@%
    LOCATE WLINE, 9%@NL@%
    PRINT "B"%@NL@%
  END IF%@NL@%
  LOCATE VLINE, 9%@NL@%
  PRINT "V"%@NL@%
  LOCATE ALINE, 3%@NL@%
  PRINT "A"%@NL@%
  LOCATE ALINE, 24%@NL@%
  PRINT "D"%@NL@%
  LOCATE ELINE, 3%@NL@%
  PRINT "E"%@NL@%
  LOCATE ELINE, 24%@NL@%
  PRINT "Q"%@NL@%
  IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
    LOCATE CLINE, 3%@NL@%
    PRINT "O"%@NL@%
    LOCATE CLINE, 24%@NL@%
    PRINT "I"%@NL@%
  END IF%@NL@%
  IF TableDone = TRUE THEN%@NL@%
%@NL@%
    LOCATE NLINE, 3%@NL@%
    PRINT " No Next Record"%@NL@%
  ELSE%@NL@%
    LOCATE NLINE, 3%@NL@%
    PRINT "N "%@NL@%
    COLOR FOREGROUND, BACKGROUND%@NL@%
    LOCATE NLINE, 5%@NL@%
    PRINT "= "%@NL@%
    LOCATE NLINE, 6%@NL@%
    PRINT " Next Record"%@NL@%
  END IF%@NL@%
  IF TableStart = TRUE THEN%@NL@%
    COLOR ForeGrnd, BACKGROUND%@NL@%
    LOCATE NLINE, 20%@NL@%
    PRINT " No Previous Record"%@NL@%
  ELSE%@NL@%
    COLOR ForeGrnd, BACKGROUND%@NL@%
    LOCATE NLINE, 20%@NL@%
    PRINT "    P "%@NL@%
    COLOR FOREGROUND, BACKGROUND%@NL@%
    LOCATE NLINE, 26%@NL@%
    PRINT "= "%@NL@%
    LOCATE NLINE, 27%@NL@%
    PRINT " Previous   "%@NL@%
    END IF%@NL@%
  COLOR FOREGROUND, BACKGROUND%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
%@AB@%'*  The ShowMessage SUB displays the message string passed in the message *%@AE@%%@NL@%
%@AB@%'*  box between the displayed table and the menus. If the Cursor parameter*%@AE@%%@NL@%
%@AB@%'*  is 0, no cursor appears in the box; if it is 1, a cursor is displaed. *%@AE@%%@NL@%
%@AB@%'*                                 Parameters                             *%@AE@%%@NL@%
%@AB@%'*  Message$    Prompt or message to display                              *%@AE@%%@NL@%
%@AB@%'*  Cursor      Boolean value telling whether or not to show a cursor     *%@AE@%%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
SUB ShowMessage (Message$, Cursor)%@NL@%
  CALL EraseMessage%@NL@%
  IF (LEN(Message$) MOD 2) THEN%@NL@%
        Borderlen = 1%@NL@%
  END IF%@NL@%
  MesLen = LEN(Message$)%@NL@%
  SELECT CASE Cursor                          ' No cursor request means to%@NL@%
  CASE FALSE                                  ' center the message in box%@NL@%
    HalfMes = (MesLen \ 2) + 1                ' and display without cursor%@NL@%
    Start = (SCREENWIDTH \ 2) - HalfMes%@NL@%
  CASE ELSE%@NL@%
    Start = 4                                 ' Message is part of an edit%@NL@%
  END SELECT                                  ' so display flush left, and%@NL@%
    LOCATE MESBOXTOP, 2                       ' keep cursor visible%@NL@%
    PRINT ""; STRING$(66, CHR$(205)); ""%@NL@%
    LOCATE MESFIELD, 2%@NL@%
    PRINT ""; SPACE$(66); ""%@NL@%
    LOCATE MESBOXEND, 2%@NL@%
    PRINT ""; STRING$(37, CHR$(205)); ""; ""; STRING$(26, CHR$(205)); ""%@NL@%
    COLOR BRIGHT + FOREGROUND, BACKGROUND%@NL@%
    LOCATE MESFIELD, Start, Cursor%@NL@%
    PRINT Message$;%@NL@%
    LOCATE MESFIELD, Start + MesLen, Cursor%@NL@%
    PRINT "";%@NL@%
    COLOR FOREGROUND, BACKGROUND%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
%@AB@%'*  The ShowRecord SUB displays the columns of the current record of the  *%@AE@%%@NL@%
%@AB@%'*  table being displayed. Numerics are only displayed if they are <> 0.  *%@AE@%%@NL@%
%@AB@%'*                                Parameters                              *%@AE@%%@NL@%
%@AB@%'*  TablesRec   RecStruct type variable containing table information      *%@AE@%%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
SUB ShowRecord (TablesRec AS RecStruct)%@NL@%
COLOR FOREGROUND, BACKGROUND%@NL@%
  SELECT CASE TablesRec.TableNum%@NL@%
    CASE cBookStockTableNum%@NL@%
      LOCATE TITLEFIELD, 18: PRINT TablesRec.Inventory.Title%@NL@%
      LOCATE AUTHORFIELD, 18: PRINT TablesRec.Inventory.Author%@NL@%
      LOCATE PUBFIELD, 18: PRINT TablesRec.Inventory.Publisher%@NL@%
      IF TablesRec.Inventory.Edition <> 0 THEN LOCATE EDFIELD, 17: PRINT STR$(TablesRec.Inventory.Edition)%@NL@%
      IF TablesRec.Inventory.Price <> 0 THEN LOCATE PRICEFIELD, 17: PRINT " $"; STR$(TablesRec.Inventory.Price)%@NL@%
      IF TablesRec.Inventory.IDnum <> 0 THEN LOCATE IDFIELD, 17: PRINT STR$(TablesRec.Inventory.IDnum)%@NL@%
    CASE cCardHoldersTableNum%@NL@%
      LOCATE NAMEFIELD, 18: PRINT TablesRec.Lendee.TheName%@NL@%
      LOCATE STREETFIELD, 18: PRINT TablesRec.Lendee.Street%@NL@%
      LOCATE CITYFIELD, 18: PRINT TablesRec.Lendee.City%@NL@%
      LOCATE STATEFIELD, 18: PRINT TablesRec.Lendee.State%@NL@%
      IF TablesRec.Lendee.Zip <> 0 THEN LOCATE ZIPFIELD, 17: PRINT STR$(TablesRec.Lendee.Zip)%@NL@%
      IF TablesRec.Lendee.CardNum <> 0 THEN LOCATE CARDNUMFIELD, 17: PRINT STR$(TablesRec.Lendee.CardNum)%@NL@%
    CASE ELSE%@NL@%
       CALL ShowMessage("There are no other forms defined", 0)%@NL@%
  END SELECT%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
%@AB@%'*  The UserChoice SUB is used to echo back to the user the most recent   *%@AE@%%@NL@%
%@AB@%'*  menu selection he has made. Not all menu choices are echoed back.     *%@AE@%%@NL@%
%@AB@%'*                                Parameters                              *%@AE@%%@NL@%
%@AB@%'*  BigRec    RecStruct type variable containing table information        *%@AE@%%@NL@%
%@AB@%'*  Row       Row on which to put the Feedback$                           *%@AE@%%@NL@%
%@AB@%'*  Column    Column at which to start the Feedback$                      *%@AE@%%@NL@%
%@AB@%'*  Feedback$ Menu-choice string to highlight                             *%@AE@%%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
SUB UserChoice (BigRec AS RecStruct, Row, Column, Feedback$)%@NL@%
    CALL DrawHelpKeys(BigRec.TableNum)%@NL@%
    CALL ShowKeys(BigRec, BRIGHT + FOREGROUND, DimN, DimP)%@NL@%
    COLOR FOREGROUND + BRIGHT, BACKGROUND%@NL@%
    LOCATE Row, Column%@NL@%
    PRINT Feedback$%@NL@%
    COLOR FOREGROUND, BACKGROUND%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BOOKMOD2.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\BOOKMOD2.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'***********************************************************************%@AE@%%@NL@%
%@AB@%'*  This is module level code for BOOKMOD2.BAS. It contains procedures *%@AE@%%@NL@%
%@AB@%'*  that use ISAM statements as well as procedures that support them.  *%@AE@%%@NL@%
%@AB@%'*  It is the third module of the BOOKLOOK program.                    *%@AE@%%@NL@%
%@AB@%'***********************************************************************%@AE@%%@NL@%
DEFINT A-Z%@NL@%
%@AB@%'$INCLUDE: 'booklook.bi'%@AE@%%@NL@%
%@NL@%
EditMessage:%@NL@%
DATA ""%@NL@%
DATA " A log is being kept while "%@NL@%
DATA " you edit fields in this   "%@NL@%
DATA " record. Press U to undo   "%@NL@%
DATA " each preceding edit, or   "%@NL@%
DATA " CTRL+U to undo all of the "%@NL@%
DATA " pending edits as a group. "%@NL@%
DATA "                           "%@NL@%
DATA " To Undo Edits "%@NL@%
%@NL@%
OperandBox:%@NL@%
DATA ""%@NL@%
DATA "                           "%@NL@%
DATA " Greater Than              "%@NL@%
DATA " or                        "%@NL@%
DATA " Equal To     Value Entered"%@NL@%
DATA " or                        "%@NL@%
DATA " Less Than                 "%@NL@%
DATA "                           "%@NL@%
DATA " Relationship to Key "%@NL@%
%@NL@%
%@AB@%'************************************************************************%@AE@%%@NL@%
%@AB@%'*                                                                      *%@AE@%%@NL@%
%@AB@%'*  This SUB checks the real current index after a try to set an index. *%@AE@%%@NL@%
%@AB@%'*  If the index was successfully set, it's name is displayed, other-   *%@AE@%%@NL@%
%@AB@%'*  wise the current index is displayed. IndexBox is called to update   *%@AE@%%@NL@%
%@AB@%'*  Current Sorting Order box on the screen.                            *%@AE@%%@NL@%
%@AB@%'*                                                                      *%@AE@%%@NL@%
%@AB@%'************************************************************************%@AE@%%@NL@%
SUB AdjustIndex (TablesRec AS RecStruct)%@NL@%
  RealIndexName$ = GETINDEX$(TablesRec.TableNum)%@NL@%
  CALL Indexbox(TablesRec, CheckIndex%(TablesRec, 0))%@NL@%
  IF RealIndexName$ <> EMPTYSTRING THEN%@NL@%
    Alert$ = "Records are now ordered by the index called " + RealIndexName$%@NL@%
  ELSE%@NL@%
    Alert$ = "Records now ordered by the default (NULL) index"%@NL@%
  END IF%@NL@%
  CALL ShowMessage(Alert$, 0)%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The ChangeRecord FUNCTION gets the new field value with MakeString. It *%@AE@%%@NL@%
%@AB@%'*  then assigns the value (converted if necessary) to its proper element  *%@AE@%%@NL@%
%@AB@%'*  in the recordvariable (TablesRec) used to update the table.            *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  FirstLetter   If the user has started typing, this contains a letter   *%@AE@%%@NL@%
%@AB@%'*  Argument      Tells what field the cursor is currently in              *%@AE@%%@NL@%
%@AB@%'*  TablesRec     RecStruct type variable holding all table information    *%@AE@%%@NL@%
%@AB@%'*  Task          Tells which operation is being performed                 *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION ChangeRecord (FirstLetter$, Argument, TablesRec AS RecStruct, Task AS INTEGER)%@NL@%
  STATIC SaveTitle AS STRING%@NL@%
  Prompt$ = "New Field Value: "%@NL@%
%@NL@%
  IF Task <> SEEKFIELD THEN            ' Adjust the Argument --- It is in-%@NL@%
    IF Argument = TITLEFIELD THEN      ' cremented as part of PlaceCursor.%@NL@%
      Argument = IDFIELD               ' But it needs the user's original%@NL@%
    ELSE                               ' choice in this function.%@NL@%
       Argument = Argument - 2%@NL@%
    END IF%@NL@%
  END IF%@NL@%
%@NL@%
  Filter% = ASC(FirstLetter$)                ' Convert FirstLetter$ to ascii%@NL@%
  Remainder$ = MakeString$(Filter%, Prompt$) ' number to pass to MakeString.%@NL@%
  IF Filter% = ESCAPE THEN                   ' This lets the user press ESC%@NL@%
    ChangeRecord = 0                         ' to abandon function.%@NL@%
    CALL ShowRecord(TablesRec)%@NL@%
    EXIT FUNCTION%@NL@%
  END IF%@NL@%
%@AB@%                                           ' Select for proper assignment of%@AE@%%@NL@%
  SELECT CASE Argument                     ' string user makes with MakeString%@NL@%
    CASE TITLEFIELD, NAMEFIELD%@NL@%
      IF Task = EDITRECORD OR Task = ADDRECORD OR Task = SEEKFIELD THEN%@NL@%
        IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
          TablesRec.Inventory.Title = Remainder$%@NL@%
        ELSE%@NL@%
          TablesRec.Lendee.TheName = Remainder$%@NL@%
        END IF%@NL@%
      END IF%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
    CASE AUTHORFIELD, STREETFIELD%@NL@%
      IF Task = EDITRECORD OR Task = ADDRECORD THEN%@NL@%
        IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
          TablesRec.Inventory.Author = Remainder$%@NL@%
        ELSE%@NL@%
          TablesRec.Lendee.Street = Remainder$%@NL@%
        END IF%@NL@%
      END IF%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
    CASE PUBFIELD, CITYFIELD%@NL@%
      IF Task = EDITRECORD OR Task = ADDRECORD THEN%@NL@%
        IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
          TablesRec.Inventory.Publisher = Remainder$%@NL@%
        ELSE%@NL@%
          TablesRec.Lendee.City = Remainder$%@NL@%
        END IF%@NL@%
      END IF%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
    CASE EDFIELD, STATEFIELD%@NL@%
      IF Task = EDITRECORD OR Task = ADDRECORD THEN%@NL@%
        IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
          TablesRec.Inventory.Edition = VAL(Remainder$)%@NL@%
        ELSE%@NL@%
          TablesRec.Lendee.State = Remainder$%@NL@%
        END IF%@NL@%
      END IF%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
    CASE PRICEFIELD, ZIPFIELD%@NL@%
      IF Task = EDITRECORD OR Task = ADDRECORD THEN%@NL@%
        IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
          TablesRec.Inventory.Price = VAL(Remainder$)%@NL@%
        ELSE%@NL@%
          TablesRec.Lendee.Zip = VAL(Remainder$)%@NL@%
        END IF%@NL@%
      END IF%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
    CASE IDFIELD, CARDNUMFIELD%@NL@%
      IF Task = EDITRECORD OR Task = ADDRECORD THEN%@NL@%
        IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
          size = LEN(Remainder$)%@NL@%
          FOR counter = 1 TO size%@NL@%
            IF ASC(MID$(Remainder$, counter, 1)) = 0 THEN%@NL@%
              Remainder$ = MID$(Remainder$, (counter + 1), size)%@NL@%
            END IF%@NL@%
          NEXT counter%@NL@%
          TablesRec.Inventory.IDnum = VAL(LTRIM$(RTRIM$(Remainder$)))%@NL@%
        ELSE%@NL@%
          TablesRec.Lendee.CardNum = VAL(Remainder$)%@NL@%
        END IF%@NL@%
      END IF%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
    CASE ELSE%@NL@%
        CALL ShowMessage("  Can't change that field ", 0)%@NL@%
        BEEP%@NL@%
        SLEEP 1%@NL@%
END SELECT%@NL@%
 ChangeRecord = 1%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The CheckIndex uses the GETINDEX function to find the current index.   *%@AE@%%@NL@%
%@AB@%'*  Since only some displayed fields correspond to indexes, the number     *%@AE@%%@NL@%
%@AB@%'*  returned is a code indicating what to do, not the index name           *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  TablesRec   RecStuct type variable holding all table information       *%@AE@%%@NL@%
%@AB@%'*  FirstTime   If first time is TRUE, Index is NULL index                 *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION CheckIndex% (TablesRec AS RecStruct, FirstTime)%@NL@%
  Check$ = GETINDEX$(TablesRec.TableNum)%@NL@%
  SELECT CASE Check$%@NL@%
    CASE "TitleIndexBS", "NameIndexCH"%@NL@%
      CheckIndex% = 0%@NL@%
    CASE "AuthorIndexBS"%@NL@%
      CheckIndex% = 1%@NL@%
    CASE "PubIndexBS"%@NL@%
      CheckIndex% = 2%@NL@%
    CASE "StateIndexCH"%@NL@%
      CheckIndex% = 3%@NL@%
    CASE "ZipIndexCH"%@NL@%
      CheckIndex% = 4%@NL@%
    CASE "IDIndex", "CardNumIndexCH"%@NL@%
      CheckIndex% = 5%@NL@%
    CASE "BigIndex"                 ' There's no combined index on%@NL@%
      CheckIndex% = 6               ' CardHolders table%@NL@%
    CASE ""%@NL@%
      CheckIndex% = 7               ' This is a special case for the%@NL@%
%@AB@%                                    ' Blank line in CardHolders table%@AE@%%@NL@%
    IF FirstTime% THEN%@NL@%
      CALL Indexbox(TablesRec, 7)%@NL@%
    END IF%@NL@%
  END SELECT%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The EdAddCursor function is used to place the cursor in the proper     *%@AE@%%@NL@%
%@AB@%'*  when the task is to Edit or Add a record.  Note when printing numeric  *%@AE@%%@NL@%
%@AB@%'*  fields LOCATE 1 column left to compensate  for the implicit "+" sign.  *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  NextField   Tells which field is to be highlighted next                *%@AE@%%@NL@%
%@AB@%'*  Job         Tells operation user wants to engage in                    *%@AE@%%@NL@%
%@AB@%'*  TablesRec   RecStruct type variable holding all table information      *%@AE@%%@NL@%
%@AB@%'*  FirstShot   Nonzero value indicates this is first time through         *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION EdAddCursor (NextField%, Job%, TablesRec AS RecStruct, FirstShot%)%@NL@%
  SELECT CASE TablesRec.TableNum%@NL@%
    CASE cBookStockTableNum                       ' BookStock table is 1%@NL@%
      SELECT CASE NextField%@NL@%
        CASE TITLEFIELD, NAMEFIELD%@NL@%
          LOCATE IDFIELD, 17%@NL@%
          IF FirstShot THEN COLOR FOREGROUND, BACKGROUND%@NL@%
          PRINT TablesRec.Inventory.IDnum%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE TITLEFIELD, 18%@NL@%
          PRINT TablesRec.Inventory.Title%@NL@%
          NextField% = AUTHORFIELD%@NL@%
        CASE AUTHORFIELD, STREETFIELD%@NL@%
          LOCATE TITLEFIELD, 18%@NL@%
          PRINT TablesRec.Inventory.Title%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE AUTHORFIELD, 18%@NL@%
          PRINT TablesRec.Inventory.Author%@NL@%
          NextField% = PUBFIELD%@NL@%
        CASE PUBFIELD, CITYFIELD%@NL@%
          LOCATE AUTHORFIELD, 18%@NL@%
          PRINT TablesRec.Inventory.Author%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE PUBFIELD, 18%@NL@%
            PRINT TablesRec.Inventory.Publisher%@NL@%
            NextField% = EDFIELD%@NL@%
        CASE EDFIELD, STATEFIELD%@NL@%
          LOCATE PUBFIELD, 18%@NL@%
          PRINT TablesRec.Inventory.Publisher%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE EDFIELD, 17%@NL@%
          PRINT TablesRec.Inventory.Edition%@NL@%
          NextField% = PRICEFIELD%@NL@%
        CASE PRICEFIELD, ZIPFIELD%@NL@%
          LOCATE EDFIELD, 17%@NL@%
          PRINT TablesRec.Inventory.Edition%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE PRICEFIELD, 19%@NL@%
          PRINT ; TablesRec.Inventory.Price%@NL@%
          NextField% = IDFIELD%@NL@%
        CASE IDFIELD, CARDNUMFIELD%@NL@%
          LOCATE PRICEFIELD, 18%@NL@%
          PRINT "$"; TablesRec.Inventory.Price%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE IDFIELD, 17%@NL@%
          PRINT TablesRec.Inventory.IDnum%@NL@%
          NextField% = TITLEFIELD%@NL@%
      END SELECT%@NL@%
    CASE cCardHoldersTableNum                       ' CardHolders table is 2%@NL@%
      SELECT CASE NextField%@NL@%
        CASE NAMEFIELD%@NL@%
          LOCATE CARDNUMFIELD, 17%@NL@%
          IF FirstShot THEN COLOR FOREGROUND, BACKGROUND%@NL@%
          PRINT TablesRec.Lendee.CardNum%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE NAMEFIELD, 18%@NL@%
          PRINT TablesRec.Lendee.TheName%@NL@%
          NextField% = STREETFIELD%@NL@%
        CASE STREETFIELD%@NL@%
          LOCATE NAMEFIELD, 18%@NL@%
          PRINT TablesRec.Lendee.TheName%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE STREETFIELD, 18%@NL@%
          PRINT TablesRec.Lendee.Street%@NL@%
          NextField% = CITYFIELD%@NL@%
        CASE CITYFIELD%@NL@%
          LOCATE STREETFIELD, 18%@NL@%
          PRINT TablesRec.Lendee.Street%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE CITYFIELD, 18%@NL@%
          PRINT TablesRec.Lendee.City%@NL@%
          NextField% = STATEFIELD%@NL@%
        CASE STATEFIELD%@NL@%
          LOCATE CITYFIELD, 18%@NL@%
          PRINT TablesRec.Lendee.City%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE STATEFIELD, 18%@NL@%
          PRINT TablesRec.Lendee.State%@NL@%
          NextField% = PRICEFIELD%@NL@%
        CASE ZIPFIELD%@NL@%
          LOCATE STATEFIELD, 18%@NL@%
          PRINT TablesRec.Lendee.State%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE ZIPFIELD, 17%@NL@%
          PRINT TablesRec.Lendee.Zip%@NL@%
          NextField% = IDFIELD%@NL@%
        CASE CARDNUMFIELD%@NL@%
          LOCATE ZIPFIELD, 17%@NL@%
          PRINT TablesRec.Lendee.Zip%@NL@%
          COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
          LOCATE CARDNUMFIELD, 17%@NL@%
          PRINT TablesRec.Lendee.CardNum%@NL@%
          NextField% = TITLEFIELD%@NL@%
      END SELECT%@NL@%
  END SELECT%@NL@%
  COLOR FOREGROUND, BACKGROUND%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The EditField function lets the user choose whether or not to actually *%@AE@%%@NL@%
%@AB@%'*  change the current field (by calling ChangeRecord) or move on to the   *%@AE@%%@NL@%
%@AB@%'*  next field. It also displays a message telling how to Undo edits. If   *%@AE@%%@NL@%
%@AB@%'*  EditField returns TRUE, a SAVEPOINT is set at module level. If the task*%@AE@%%@NL@%
%@AB@%'*  is ADDRECORD, the user is taken through the fields one at a time until *%@AE@%%@NL@%
%@AB@%'*  they have all been entered.                                            *%@AE@%%@NL@%
%@AB@%'*                              Parameters                                 *%@AE@%%@NL@%
%@AB@%'*  Argument    Tells which field is currently being dealt with            *%@AE@%%@NL@%
%@AB@%'*  TablesRec   RecStruct type variable holding current table information  *%@AE@%%@NL@%
%@AB@%'*  FirstLetter If the user has started typing, the letter is passed in    *%@AE@%%@NL@%
%@AB@%'*  Task        Tells what type of operation the user is performing        *%@AE@%%@NL@%
%@AB@%'*  Answer      Same as Task, but passed to ChangeRecord%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION EditField (Argument%, TablesRec AS RecStruct, FirstLetter$, Task%, Answer%)%@NL@%
%@AB@%  ' Show the transaction block message dealing with undoing edits:%@AE@%%@NL@%
  IF Task = EDITRECORD THEN CALL DrawIndexBox(1, Task)%@NL@%
%@NL@%
  STATIC NextField%@NL@%
  FirstLetter$ = ""%@NL@%
  IF Task = EDITRECORD THEN CALL ShowMessage("Edit this field or TAB to another", 0)%@NL@%
  Argument = TITLEFIELD%@NL@%
  Value = PlaceCursor(Argument, TablesRec, FirstLetter$, 1, Task%)%@NL@%
  IF Argument THEN%@NL@%
    IF Task = EDITRECORD THEN CALL ShowMessage("Edit this field or TAB to another", 0)%@NL@%
    COLOR FOREGROUND, BACKGROUND%@NL@%
    WasFieldChanged = ChangeRecord(FirstLetter$, Argument, TablesRec, Answer)%@NL@%
%@NL@%
    IF Task = EDITRECORD AND WasFieldChanged <> 0 THEN%@NL@%
      CALL ShowMessage("Press E to Edit another field ", 0)%@NL@%
      EditField = TRUE            ' If True is returned, a SAVEPOINT is set%@NL@%
    ELSEIF Task = EDITRECORD AND WasFieldChanged = 0 THEN%@NL@%
      CALL ShowRecord(TablesRec)%@NL@%
      CALL ShowMessage("Please try again...", 0)%@NL@%
      EditField = FALSE     'Don't set SAVEPOINT if user escapes from edit%@NL@%
    ELSEIF Task = SEEKFIELD THEN%@NL@%
      EditField = FALSE: EXIT FUNCTION%@NL@%
    END IF%@NL@%
    IF Task = ADDRECORD THEN%@NL@%
      NextField = 1%@NL@%
      DO WHILE NextField <> 0 AND Argument <> 0%@NL@%
        CALL ShowMessage("Enter value for field or ESC to abandon addition ", 0)%@NL@%
        SELECT CASE NextField%@NL@%
          CASE 1%@NL@%
            Argument = AUTHORFIELD%@NL@%
            FieldsDone = FieldsDone + 1%@NL@%
          CASE 2%@NL@%
            Argument = PUBFIELD%@NL@%
            FieldsDone = FieldsDone + 1%@NL@%
          CASE 3%@NL@%
            Argument = EDFIELD%@NL@%
            FieldsDone = FieldsDone + 1%@NL@%
          CASE 4%@NL@%
            Argument = PRICEFIELD%@NL@%
            FieldsDone = FieldsDone + 1%@NL@%
          CASE 5%@NL@%
            Argument = IDFIELD%@NL@%
            FieldsDone = FieldsDone + 1%@NL@%
            NextField = 0%@NL@%
          CASE ELSE%@NL@%
            CALL ShowMessage("Problem in the CASE assignments to Argument", 0): SLEEP%@NL@%
        END SELECT%@NL@%
        FirstLetter$ = ""%@NL@%
        Value = PlaceCursor(Argument, TablesRec, FirstLetter$, 1, Task%)%@NL@%
        IF Argument THEN%@NL@%
          COLOR FOREGROUND, BACKGROUND%@NL@%
          WasFieldChanged = ChangeRecord(FirstLetter$, Argument, TablesRec, Answer)%@NL@%
          NextField = NextField + 1%@NL@%
          IF FieldsDone = 5 THEN EditField% = 1: EXIT FUNCTION%@NL@%
        END IF%@NL@%
      LOOP%@NL@%
      EditField = FALSE 'No need for SAVEPOINT with ADDRECORD%@NL@%
    END IF%@NL@%
  ELSE%@NL@%
  CALL ShowRecord(TablesRec)%@NL@%
  CALL ShowMessage("Please try again...", 0)%@NL@%
  SLEEP: CALL EraseMessage%@NL@%
  CALL DrawIndexBox(TablesRec.TableNum, 0)' Replace Edit stuff with Index stuff%@NL@%
  EditField = FALSE     'Don't set SAVEPOINT if user escapes from edit%@NL@%
  END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The GetKeyVals SUB gathers the Keys for searching on a combined index. *%@AE@%%@NL@%
%@AB@%'*  It shows the fields as they are entered.                               *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  TablesRec   Contains all the information for the tables                *%@AE@%%@NL@%
%@AB@%'*  Key1        Represents the Title field of BookStock table              *%@AE@%%@NL@%
%@AB@%'*  Key2        Represents the Author field of BookStock table             *%@AE@%%@NL@%
%@AB@%'*  Key3        Represents the IDnum field of BookStock table              *%@AE@%%@NL@%
%@AB@%'*  Letter      Holds the first letter the user tries to enter at prompt   *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB GetKeyVals (TablesRec AS RecStruct, Key1$, Key2$, Key3#, Letter$)%@NL@%
  WhichTable = TablesRec.TableNum%@NL@%
  Prompt$ = "Value to Seek: "%@NL@%
%@NL@%
  CALL DrawScreen(WhichTable)%@NL@%
  DO%@NL@%
%@AB@%    ' Have the user ENTER the Title value to search for%@AE@%%@NL@%
    COLOR BACKGROUND, FOREGROUND%@NL@%
    LOCATE TITLEFIELD, 18%@NL@%
    PRINT "Please enter the Title to find"%@NL@%
    Key1$ = MakeString$(ASC(Letter$), Prompt$)%@NL@%
    CALL ShowIt(TablesRec, "TitleIndexBS", WhichTable, Key1$)%@NL@%
  LOOP UNTIL Key1$ <> ""%@NL@%
%@NL@%
  Letter$ = " "    ' Set it to a blank space for typing%@NL@%
%@NL@%
%@AB@%    ' Have the user ENTER the Author value to search for%@AE@%%@NL@%
  DO%@NL@%
    COLOR BACKGROUND, FOREGROUND%@NL@%
    LOCATE AUTHORFIELD, 18%@NL@%
    PRINT "Please enter the Author name to find"%@NL@%
    Key2$ = MakeString$(ASC(Letter$), Prompt$)%@NL@%
%@AB@%    ' Show it just shows the input user has entered, not a record from file%@AE@%%@NL@%
    CALL ShowIt(TablesRec, "AuthorIndexBS", WhichTable, Key2$)%@NL@%
  LOOP UNTIL Key2$ <> ""%@NL@%
%@NL@%
  Letter$ = " "    ' Set it to a blank space for typing%@NL@%
%@AB@%    ' Have the user ENTER the ID number value to search for%@AE@%%@NL@%
  DO%@NL@%
    COLOR BACKGROUND, FOREGROUND%@NL@%
    LOCATE IDFIELD, 18%@NL@%
    PRINT "Please enter the ID number to find"%@NL@%
    ValueToSeek$ = MakeString$(ASC(Letter$), Prompt$)%@NL@%
    Key3# = CDBL(VAL(ValueToSeek$))       ' CURRENCY field%@NL@%
    CALL ShowIt(TablesRec, "IDIndex", WhichTable, ValueToSeek$)%@NL@%
LOOP UNTIL Key3# <> 0%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'****************************** GetOperand FUNCTION ************************%@AE@%%@NL@%
%@AB@%'* The GetOperand FUNCTION displays a choice of operators to allow user a  *%@AE@%%@NL@%
%@AB@%'* choice in how a SEEKoperand search will be conducted. If the user makes *%@AE@%%@NL@%
%@AB@%'* a valid choice, it is assigned to HoldOperand. An invalid choice or a   *%@AE@%%@NL@%
%@AB@%'* choice of ESC results in "<>" being passed back. This permits an exit   *%@AE@%%@NL@%
%@AB@%'* from the function (which is recursive). Otherwise, the user's choice is *%@AE@%%@NL@%
%@AB@%'* trapped in HoldOperand when ENTER is pressed.                           *%@AE@%%@NL@%
%@AB@%'* Note that this function is recursive so use the calls menu to keep      *%@AE@%%@NL@%
%@AB@%'* track of the nesting depth when stepping through it. Unlike PlaceCursor *%@AE@%%@NL@%
%@AB@%'* GetOperand doesn't keep track of the stack - the stack set should be OK.*%@AE@%%@NL@%
%@AB@%'*                              Parameters                                 *%@AE@%%@NL@%
%@AB@%'*   HoldOperand    Contains operand to check each time function calls     *%@AE@%%@NL@%
%@AB@%'*                  itself; Let's user ESC from function if desired.       *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION GetOperand% (HoldOperand$)%@NL@%
  STATIC WhichOne     ' Keep track of which case from call to call%@NL@%
%@NL@%
%@AB@%  ' If user has chose ESC then exit back to caller%@AE@%%@NL@%
  IF HoldOperand$ = "<>" THEN WhichOne = 0: EXIT FUNCTION%@NL@%
%@NL@%
%@AB@%  ' if this is the first time through the function then%@AE@%%@NL@%
%@AB@%  ' Replace the Sort Order box with box of operand choices%@AE@%%@NL@%
  IF WhichOne = 0 THEN%@NL@%
    RESTORE OperandBox%@NL@%
    FOR Row = BOXTOP TO BOXEND%@NL@%
      LOCATE Row, 42%@NL@%
      READ Temp$%@NL@%
      PRINT Temp$%@NL@%
      IF Row = BOXEND THEN%@NL@%
        COLOR FOREGROUND + BRIGHT, BACKGROUND%@NL@%
        LOCATE Row, INDBOX + 5%@NL@%
        PRINT "Relationship to Key"%@NL@%
      END IF%@NL@%
    NEXT Row%@NL@%
    LOCATE VLINE, 44%@NL@%
    PRINT "Equal To     Value Entered"     ' This is default --- if user%@NL@%
    COLOR FOREGROUND, BACKGROUND           ' presses ENTER without tabbing,%@NL@%
  END IF                                   ' SeekRecord sets the operand%@NL@%
%@AB@%                                           ' to =    Note: a more flexible%@AE@%%@NL@%
%@AB@%                                           ' default choice might be >=%@AE@%%@NL@%
%@NL@%
  Alert$ = "Now press TAB to select how search should be conducted"%@NL@%
  CALL ShowMessage(Alert$, 0)%@NL@%
  DO%@NL@%
  Answer$ = INKEY$%@NL@%
  LOOP WHILE Answer$ <> CHR$(TABKEY) AND Answer$ <> CHR$(ENTER) AND Answer$ <> CHR$(ESCAPE)%@NL@%
%@NL@%
  IF LEN(Answer$) = 1 THEN%@NL@%
    SELECT CASE ASC(Answer$)%@NL@%
      CASE TABKEY%@NL@%
        SELECT CASE WhichOne%@NL@%
          CASE 0%@NL@%
            COLOR FOREGROUND, BACKGROUND%@NL@%
            LOCATE VLINE, 44%@NL@%
            PRINT "Equal To"%@NL@%
            COLOR BRIGHT + FOREGROUND, BACKGROUND%@NL@%
            LOCATE RLINE, 44%@NL@%
            PRINT "Greater Than"%@NL@%
            WhichOne = WhichOne + 1%@NL@%
            HoldOperand$ = ">"%@NL@%
          CASE 1%@NL@%
            COLOR BRIGHT + FOREGROUND, BACKGROUND%@NL@%
            LOCATE VLINE, 44%@NL@%
            PRINT "Equal To"%@NL@%
            LOCATE WLINE, 44%@NL@%
            PRINT "or"%@NL@%
            WhichOne = WhichOne + 1%@NL@%
            HoldOperand$ = ">="%@NL@%
          CASE 2%@NL@%
            COLOR FOREGROUND, BACKGROUND%@NL@%
            LOCATE RLINE, 44%@NL@%
            PRINT "Greater Than"%@NL@%
            LOCATE WLINE, 44%@NL@%
            PRINT "or"%@NL@%
            COLOR BRIGHT + FOREGROUND, BACKGROUND%@NL@%
            LOCATE ALINE, 44%@NL@%
            PRINT "or"%@NL@%
            LOCATE ELINE, 44%@NL@%
            PRINT "Less Than"%@NL@%
            WhichOne = WhichOne + 1%@NL@%
            HoldOperand$ = "<="%@NL@%
          CASE 3%@NL@%
            COLOR FOREGROUND, BACKGROUND%@NL@%
            LOCATE VLINE, 44%@NL@%
            PRINT "Equal To"%@NL@%
            LOCATE ALINE, 44%@NL@%
            PRINT "or"%@NL@%
            WhichOne = WhichOne + 1%@NL@%
            HoldOperand$ = "<"%@NL@%
            SLEEP%@NL@%
          CASE 4%@NL@%
            COLOR FOREGROUND, BACKGROUND%@NL@%
            LOCATE ELINE, 44%@NL@%
            PRINT "Less Than"%@NL@%
            COLOR BRIGHT + FOREGROUND, BACKGROUND%@NL@%
            LOCATE VLINE, 44%@NL@%
            PRINT "Equal To     Value Entered"%@NL@%
            WhichOne = WhichOne + 1%@NL@%
            HoldOperand$ = "="%@NL@%
          CASE ELSE%@NL@%
        END SELECT                          ' If no choice was made, call%@NL@%
        IF WhichOne > 4 THEN WhichOne = 0   ' GetOperand again%@NL@%
        COLOR FOREGROUND, BACKGROUND%@NL@%
        OK = GetOperand%(HoldOperand$)%@NL@%
      CASE ENTER%@NL@%
        WhichOne = 0%@NL@%
        EXIT FUNCTION%@NL@%
    CASE ESCAPE                 ' If user chooses ESC, signal the function%@NL@%
      HoldOperand$ = "<>"       ' to exit and keep exiting back through%@NL@%
      GetOperand% = 0           ' all levels of recursion%@NL@%
      WhichOne = 0%@NL@%
    CASE ELSE                   ' If user chooses invalid key, try again%@NL@%
      BEEP%@NL@%
      CALL ShowMessage("Use TAB to select relationship to search for...", 0)%@NL@%
      COLOR white, BACKGROUND%@NL@%
      OK = GetOperand%(HoldOperand$)%@NL@%
  END SELECT%@NL@%
ELSE%@NL@%
END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The IndexBox SUB highlights the proper index name in the Current Index *%@AE@%%@NL@%
%@AB@%'*  box at the bottom right section of the screen.                         *%@AE@%%@NL@%
%@AB@%'                                                                          *%@AE@%%@NL@%
%@AB@%'*  TablesRec   RecStruct type variable containing all table information   *%@AE@%%@NL@%
%@AB@%'*  MoveDown    Integer representing line on which index name resides      *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB Indexbox (TablesRec AS RecStruct, MoveDown)%@NL@%
   Table = TablesRec.TableNum%@NL@%
   COLOR BRIGHT + FOREGROUND, BACKGROUND%@NL@%
   LOCATE 17 + MoveDown, 44%@NL@%
   SELECT CASE MoveDown%@NL@%
     CASE 0%@NL@%
      IF Table = cBookStockTableNum THEN PRINT "By Titles   " ELSE PRINT "By Name    "%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
      LOCATE ELINE, 44%@NL@%
      PRINT "Default = Insertion Order"%@NL@%
     CASE 1%@NL@%
      IF Table = cBookStockTableNum THEN PRINT "By Authors   "%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
      LOCATE NLINE, 44%@NL@%
      IF Table = cBookStockTableNum THEN PRINT "By Titles   " ELSE PRINT "By Name     "%@NL@%
     CASE 2%@NL@%
      IF Table = cBookStockTableNum THEN PRINT "By Publishers   "%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
      LOCATE RLINE, 44%@NL@%
      IF Table = cBookStockTableNum THEN PRINT "By Authors    "%@NL@%
     CASE 3%@NL@%
      IF Table = cCardHoldersTableNum THEN%@NL@%
        LOCATE RLINE, 44%@NL@%
        PRINT "By States     "%@NL@%
        COLOR FOREGROUND, BACKGROUND%@NL@%
        LOCATE NLINE, 44%@NL@%
        PRINT "By Names     "%@NL@%
      ELSE%@NL@%
        COLOR FOREGROUND, BACKGROUND%@NL@%
        LOCATE WLINE, 44%@NL@%
        PRINT "By Publishers"%@NL@%
      END IF%@NL@%
     CASE 4%@NL@%
      IF Table = cCardHoldersTableNum THEN%@NL@%
        LOCATE WLINE, 44%@NL@%
        PRINT "By Zipcodes   "%@NL@%
        COLOR FOREGROUND, BACKGROUND%@NL@%
        LOCATE RLINE, 44%@NL@%
        PRINT "By States     "%@NL@%
      END IF%@NL@%
     CASE 5%@NL@%
      LOCATE VLINE, 44%@NL@%
      IF Table = cBookStockTableNum THEN%@NL@%
        PRINT "By ID Numbers   "%@NL@%
        COLOR FOREGROUND, BACKGROUND%@NL@%
      ELSE%@NL@%
        PRINT "By Card numbers   "%@NL@%
        COLOR FOREGROUND, BACKGROUND%@NL@%
        LOCATE WLINE, 44%@NL@%
        PRINT "By Zipcodes    "%@NL@%
      END IF%@NL@%
     CASE 6%@NL@%
      IF Table = cBookStockTableNum THEN%@NL@%
        LOCATE ALINE, 44%@NL@%
        PRINT "By Title + Author + ID"%@NL@%
        COLOR FOREGROUND, BACKGROUND%@NL@%
        LOCATE VLINE, 44%@NL@%
        PRINT "By ID Numbers"%@NL@%
      ELSE%@NL@%
        LOCATE VLINE, 44%@NL@%
        COLOR FOREGROUND, BACKGROUND%@NL@%
        PRINT "By Card numbers   "%@NL@%
      END IF%@NL@%
     COLOR FOREGROUND, BACKGROUND%@NL@%
     CASE 7%@NL@%
      LOCATE ELINE, 44%@NL@%
      PRINT "Default = Insertion Order"%@NL@%
      COLOR FOREGROUND, BACKGROUND%@NL@%
      IF Table = cBookStockTableNum THEN%@NL@%
        LOCATE ALINE, 44%@NL@%
        PRINT "By Title + Author + ID"%@NL@%
      ELSE%@NL@%
        LOCATE VLINE, 44%@NL@%
        PRINT "By Card numbers"%@NL@%
      END IF%@NL@%
    END SELECT%@NL@%
   IF MoveDown < 7 THEN%@NL@%
    MoveDown = MoveDown + 1%@NL@%
   ELSE%@NL@%
    MoveDown = 0%@NL@%
   END IF%@NL@%
COLOR FOREGROUND, BACKGROUND%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'* The OrderCursor FUNCTION returns TRUE or FALSE for user index choice.   *%@AE@%%@NL@%
%@AB@%'* Each time the user places the cursor on an Index to sort on, this       *%@AE@%%@NL@%
%@AB@%'* function displays an instruction message in the field(s) corresponding  *%@AE@%%@NL@%
%@AB@%'* to the Index, It then associates the highlighted index name (in the     *%@AE@%%@NL@%
%@AB@%'* Sorting Order box) with the name it is known by in the program, and     *%@AE@%%@NL@%
%@AB@%'* places that name in the .WhichIndex element of a structured variable of *%@AE@%%@NL@%
%@AB@%'* RecStruct type.                                                         *%@AE@%%@NL@%
%@AB@%'*                                   Parameters:                           *%@AE@%%@NL@%
%@AB@%'* Index       Integer telling which index user has highlighted            *%@AE@%%@NL@%
%@AB@%'* NextField   Manifest Constant telling big cursor field position         *%@AE@%%@NL@%
%@AB@%'* Job         Manifest Constant indicating task being performed           *%@AE@%%@NL@%
%@AB@%'* TablesRec   Variable of RecStruct type, whose .WhichInded element is    *%@AE@%%@NL@%
%@AB@%'*             used to return the index name to be used by SETINDEX.       *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION OrderCursor (Index%, NextField%, Job%, TablesRec AS RecStruct, Letter$)%@NL@%
  OrderCursor = FALSE%@NL@%
  CALL Indexbox(TablesRec, Index)         ' Light up the new index%@NL@%
  COLOR BACKGROUND, BRIGHT + FOREGROUND   ' in Sorting Order box%@NL@%
  LOCATE NextField, 18%@NL@%
  IF Job = REORDER THEN         ' Tell the user what is expected of him%@NL@%
%@NL@%
    IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
      IF NextField <> PRICEFIELD AND NextField <> EDFIELD THEN%@NL@%
        PRINT "Press enter to resort, or TAB to move on"%@NL@%
      ELSE%@NL@%
        LOCATE NextField, 20 '19%@NL@%
        PRINT "Sorry, cannot sort on an unindexed field"%@NL@%
      END IF%@NL@%
    ELSE%@NL@%
      IF NextField <> STREETFIELD AND NextField <> CITYFIELD THEN%@NL@%
        PRINT "Press enter to resort, or TAB to move on"%@NL@%
      ELSE%@NL@%
        PRINT "Sorry, cannot sort on an unindexed field"%@NL@%
      END IF%@NL@%
    END IF%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%        ' The following places the name of the index to sort on in the%@AE@%%@NL@%
%@AB@%        ' WhichIndex element of the structured variable TablesRec --- it%@AE@%%@NL@%
%@AB@%        ' retrieved at the module-level code%@AE@%%@NL@%
%@NL@%
        LOCATE NextField, 18%@NL@%
        SELECT CASE NextField%@NL@%
          CASE TITLEFIELD, NAMEFIELD%@NL@%
            IF Job = SEEKFIELD THEN%@NL@%
              IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
                PRINT "Type Title to search for, or press TAB to move on"%@NL@%
              ELSE%@NL@%
                PRINT "Type Name to search for, or press TAB to move on"%@NL@%
              END IF%@NL@%
            END IF%@NL@%
            IF ConfirmEntry%(Letter$) THEN%@NL@%
              IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
                TablesRec.WhichIndex = "TitleIndexBS"%@NL@%
              ELSE%@NL@%
                TablesRec.WhichIndex = "NameIndexCH"%@NL@%
              END IF%@NL@%
              OrderCursor = TRUE%@NL@%
              EXIT FUNCTION%@NL@%
            ELSE%@NL@%
              OrderCursor = FALSE%@NL@%
              NextField% = AUTHORFIELD%@NL@%
            END IF%@NL@%
          CASE AUTHORFIELD, STREETFIELD%@NL@%
            IF Job = SEEKFIELD THEN%@NL@%
              IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
                PRINT "Type Author name to search for, or TAB to move on"%@NL@%
              ELSE%@NL@%
                PRINT "Sorry, can't search on an unindexed field"%@NL@%
              END IF%@NL@%
            END IF%@NL@%
            IF ConfirmEntry%(Letter$) THEN%@NL@%
              IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
                TablesRec.WhichIndex = "AuthorIndexBS"%@NL@%
              END IF%@NL@%
              OrderCursor = TRUE%@NL@%
              EXIT FUNCTION%@NL@%
            ELSE%@NL@%
              OrderCursor = FALSE%@NL@%
              NextField% = PUBFIELD%@NL@%
            END IF%@NL@%
          CASE PUBFIELD, CITYFIELD%@NL@%
            IF Job = SEEKFIELD THEN%@NL@%
              IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
                PRINT "Type Publisher name to search for, or TAB to move on"%@NL@%
              ELSE%@NL@%
                PRINT "Sorry, can't search on an unindexed field"%@NL@%
              END IF%@NL@%
            END IF%@NL@%
            IF ConfirmEntry%(Letter$) THEN%@NL@%
              IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
                TablesRec.WhichIndex = "PubIndexBS"%@NL@%
              END IF%@NL@%
              OrderCursor = TRUE%@NL@%
              EXIT FUNCTION%@NL@%
            ELSE%@NL@%
              OrderCursor = FALSE%@NL@%
              NextField% = EDFIELD%@NL@%
            END IF%@NL@%
          CASE EDFIELD, STATEFIELD%@NL@%
            IF Job = SEEKFIELD THEN%@NL@%
              IF TablesRec.TableNum = cCardHoldersTableNum THEN%@NL@%
                PRINT "Type State (2 letters), or TAB to move on"%@NL@%
              ELSE%@NL@%
                PRINT "Sorry, can't search on an unindexed field"%@NL@%
              END IF%@NL@%
            END IF%@NL@%
            IF ConfirmEntry%(Letter$) THEN%@NL@%
              IF TablesRec.TableNum = cCardHoldersTableNum THEN%@NL@%
                TablesRec.WhichIndex = "StateIndexCH"%@NL@%
              END IF%@NL@%
              OrderCursor = TRUE%@NL@%
              EXIT FUNCTION%@NL@%
            ELSE%@NL@%
              OrderCursor = FALSE%@NL@%
              NextField% = PRICEFIELD%@NL@%
            END IF%@NL@%
          CASE PRICEFIELD, ZIPFIELD%@NL@%
            IF Job = SEEKFIELD THEN%@NL@%
              IF TablesRec.TableNum = cCardHoldersTableNum THEN%@NL@%
                PRINT "Type Zipcode to search for, or TAB to move on"%@NL@%
              ELSE%@NL@%
                LOCATE PRICEFIELD, 20%@NL@%
                PRINT "Sorry, can't search on an unindexed field"%@NL@%
              END IF%@NL@%
            END IF%@NL@%
            IF ConfirmEntry%(Letter$) THEN%@NL@%
              IF TablesRec.TableNum = cCardHoldersTableNum THEN%@NL@%
                TablesRec.WhichIndex = "ZipIndexCH"%@NL@%
              END IF%@NL@%
              OrderCursor = TRUE%@NL@%
              EXIT FUNCTION%@NL@%
            ELSE%@NL@%
              OrderCursor = FALSE%@NL@%
              NextField% = IDFIELD%@NL@%
            END IF%@NL@%
          CASE IDFIELD, CARDNUMFIELD%@NL@%
            IF Job = SEEKFIELD THEN%@NL@%
              IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
                PRINT "Type ID number to search for, or TAB to move on"%@NL@%
              ELSE%@NL@%
                PRINT "Type Card number to seek, or press TAB to move on"%@NL@%
              END IF%@NL@%
            END IF%@NL@%
%@AB@%            ' Setting Letter$ to "" may be unnecessary now%@AE@%%@NL@%
            Letter$ = ""%@NL@%
            IF ConfirmEntry%(Letter$) THEN%@NL@%
              IF TablesRec.TableNum = cBookStockTableNum THEN%@NL@%
                TablesRec.WhichIndex = "IDIndex"%@NL@%
              ELSE%@NL@%
                TablesRec.WhichIndex = "CardNumIndexCH"%@NL@%
              END IF%@NL@%
              OrderCursor = TRUE%@NL@%
              EXIT FUNCTION%@NL@%
            ELSE%@NL@%
              OrderCursor = FALSE%@NL@%
              NextField% = BIGINDEX%@NL@%
            END IF%@NL@%
        END SELECT%@NL@%
 IF Letter$ = "eScApE" THEN OrderCursor = 3: FirstLetter$ = ""%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The PlaceCursor FUNCTION lets the user tab around on the displayed form*%@AE@%%@NL@%
%@AB@%'*  when performing field-specific operations on the table. Since this     *%@AE@%%@NL@%
%@AB@%'*  function is recursive it keeps track of available stack space. The two *%@AE@%%@NL@%
%@AB@%'*  major possibilities are SEEKs/REORDERs (for which OrderCursor is then  *%@AE@%%@NL@%
%@AB@%'*  called) and EDIT/ADD records (for which EdAddCursor is called. Note    *%@AE@%%@NL@%
%@AB@%'*  the combined index (BigIndex) and the default index are handled as     *%@AE@%%@NL@%
%@AB@%'*  special cases, since they don't correspond to a single field.Recursive *%@AE@%%@NL@%
%@AB@%'*  construction lets the user cycle through the fields as long as         *%@AE@%%@NL@%
%@AB@%'*  sufficient stack remains to keep calling PlaceCursor. Note that since  *%@AE@%%@NL@%
%@AB@%'*  it is recursive, it may take while to step out while stepping with F8. *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  WhichField    Integer identifier specifying current field on form      *%@AE@%%@NL@%
%@AB@%'*  TablesRec     Variable of type RecStruct holding all table information *%@AE@%%@NL@%
%@AB@%'*  FirstLetter$  Carries user response to initial prompt shown            *%@AE@%%@NL@%
%@AB@%'*  FirstTime     Boolean telling whether this is first cal or recursion   *%@AE@%%@NL@%
%@AB@%'*  Task          Tells operation being performed                          *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION PlaceCursor% (WhichField, TablesRec AS RecStruct, FirstLetter$, FirstTime AS INTEGER, Task AS INTEGER)%@NL@%
STATIC ReturnValue, InitialLetter$, GetOut, counter, WhichOne%@NL@%
WhichTable = TablesRec.TableNum%@NL@%
IF ExitFlag THEN EXIT FUNCTION%@NL@%
%@NL@%
ReturnValue = WhichField%@NL@%
%@AB@%' Keep tabs on the stack and exit and reset it if it gets too low%@AE@%%@NL@%
IF FRE(-2) < 400 THEN%@NL@%
  WhichField = 0%@NL@%
  PlaceCursor = 0%@NL@%
  GetOut = -1%@NL@%
  EXIT FUNCTION%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Set up for each of the possible operations that use PlaceCursor%@AE@%%@NL@%
IF Task = REORDER THEN%@NL@%
   COLOR FOREGROUND, BACKGROUND%@NL@%
   CALL ShowMessage("Press TAB to choose field to sort on, ESC to escape", 0)%@NL@%
   IF WhichField = TITLEFIELD THEN WhichOne = 0%@NL@%
ELSEIF Task = SEEKFIELD THEN%@NL@%
   CALL ShowMessage("TAB to a field, then enter a value to search", 0)%@NL@%
ELSEIF Task = ADDRECORD THEN%@NL@%
  IF FirstTime THEN FirstLetter$ = CHR$(TABKEY) ELSE FirstLetter$ = ""%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' The following IF... lets function handle either an entered letter or TAB%@AE@%%@NL@%
IF FirstLetter$ <> "" THEN%@NL@%
    Answer$ = FirstLetter$%@NL@%
ELSEIF FirstTime THEN%@NL@%
  IF Task = EDITRECORD THEN%@NL@%
    Answer$ = CHR$(TABKEY)%@NL@%
  END IF%@NL@%
ELSE%@NL@%
  DO%@NL@%
  Answer$ = INKEY$%@NL@%
  LOOP WHILE Answer$ = EMPTYSTRING%@NL@%
END IF%@NL@%
%@NL@%
IF LEN(Answer$) = 1 THEN%@NL@%
%@NL@%
%@AB@%' Clear the fields for the appropriate messages%@AE@%%@NL@%
IF Task <> EDITRECORD AND Task <> ADDRECORD THEN%@NL@%
CALL ClearEm(TablesRec.TableNum, 1, 1, 1, 1, 1, 1)%@NL@%
END IF%@NL@%
%@NL@%
   SELECT CASE ASC(Answer$)%@NL@%
    CASE IS = TABKEY, ENTER%@NL@%
           SELECT CASE WhichField%@NL@%
            CASE TITLEFIELD, AUTHORFIELD, PUBFIELD, EDFIELD, PRICEFIELD, IDFIELD%@NL@%
              IF Task = REORDER OR Task = SEEKFIELD THEN%@NL@%
                RetVal = OrderCursor(WhichOne, WhichField, Task, TablesRec, FirstLetter$)%@NL@%
                IF RetVal THEN%@NL@%
%@AB@%                  ' trap a magic value for an escape here then call the Draw stuff%@AE@%%@NL@%
                  IF RetVal <> 3 THEN%@NL@%
                    WhichOne = 0: EXIT FUNCTION%@NL@%
                  ELSE%@NL@%
                    WhichOne = 0%@NL@%
                    WhichField = 0%@NL@%
                    PlaceCursor = 0%@NL@%
                    CALL ShowRecord(TablesRec)%@NL@%
                    CALL ShowMessage("You've escaped! Try again", 0)%@NL@%
                    CALL DrawTable(WhichTable)%@NL@%
                    CALL DrawHelpKeys(WhichTable)%@NL@%
                    CALL ShowKeys(TablesRec, FOREGROUND + BRIGHT, 0, 0)%@NL@%
                    EXIT FUNCTION%@NL@%
                  END IF%@NL@%
                END IF%@NL@%
              ELSEIF Task = EDITRECORD OR Task = ADDRECORD THEN%@NL@%
                Placed = EdAddCursor(WhichField, Task, TablesRec, FirstTime)%@NL@%
              END IF%@NL@%
%@NL@%
            CASE BIGINDEX%@NL@%
                CALL Indexbox(TablesRec, WhichOne)%@NL@%
                IF WhichTable = cBookStockTableNum THEN%@NL@%
                  COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
                  IF Task = REORDER THEN%@NL@%
                    LOCATE TITLEFIELD, 18%@NL@%
                    PRINT "Press ENTER to sort first by Title..."%@NL@%
                    LOCATE AUTHORFIELD, 18%@NL@%
                    PRINT "... then subsort by Author..."%@NL@%
                    LOCATE IDFIELD, 18%@NL@%
                    PRINT "... then subsort again by ID "%@NL@%
                    SLEEP%@NL@%
                  ELSEIF Task = SEEKFIELD THEN%@NL@%
                    LOCATE TITLEFIELD, 18%@NL@%
                    PRINT "First, type in the Title to search for,"%@NL@%
                    LOCATE AUTHORFIELD, 18%@NL@%
                    PRINT "... then type in the Author's name"%@NL@%
                    LOCATE IDFIELD, 18%@NL@%
                    PRINT "... then type in the ID number "%@NL@%
                    CALL ShowMessage("Typing in a value for a combined index is tricky...", 0)%@NL@%
                    SLEEP%@NL@%
                  END IF%@NL@%
                  COLOR FOREGROUND, BACKGROUND%@NL@%
                  IF ConfirmEntry%(FirstLetter$) THEN%@NL@%
                    TablesRec.WhichIndex = "BigIndex"%@NL@%
                    IF Task = SEEKFIELD THEN%@NL@%
                      WhichOne = 0%@NL@%
                      WhichField = TITLEFIELD%@NL@%
                    END IF%@NL@%
                    EXIT FUNCTION%@NL@%
                  END IF%@NL@%
                END IF%@NL@%
                CALL ClearEm(TablesRec.TableNum, 1, 1, 0, 0, 1, 0)%@NL@%
                WhichField = NULLINDEX   ' TITLEFIELD%@NL@%
%@NL@%
            CASE NULLINDEX%@NL@%
                CALL Indexbox(TablesRec, WhichOne)%@NL@%
                IF Task = SEEKFIELD THEN%@NL@%
                  CALL ShowMessage("Can't SEEK on the default index", 0)%@NL@%
                  DO%@NL@%
                    KeyIn$ = INKEY$%@NL@%
                    IF KeyIn$ <> "" THEN%@NL@%
                      IF ASC(KeyIn$) = ESCAPE THEN EXIT FUNCTION%@NL@%
                    END IF%@NL@%
                  LOOP WHILE KeyIn$ = ""%@NL@%
%@AB@%                  'SLEEP%@AE@%%@NL@%
%@AB@%                '  EXIT FUNCTION%@AE@%%@NL@%
%@AB@%                'END IF%@AE@%%@NL@%
                ELSEIF ConfirmEntry%(FirstLetter$) THEN%@NL@%
                  TablesRec.WhichIndex = "NULL"%@NL@%
                  EXIT FUNCTION%@NL@%
                END IF%@NL@%
                WhichField = TITLEFIELD%@NL@%
%@NL@%
            CASE ELSE%@NL@%
                EraseMessage%@NL@%
                 CALL ShowMessage("Not a valid key --- press Space bar", 0)%@NL@%
                EXIT FUNCTION%@NL@%
          END SELECT%@NL@%
%@AB@%        ' Placecursor calls itself for next user response%@AE@%%@NL@%
        Value = PlaceCursor(WhichField, TablesRec, FirstLetter$, 0, Task)%@NL@%
%@NL@%
    CASE ESCAPE%@NL@%
      WhichOne = 0%@NL@%
      WhichField = 0%@NL@%
      PlaceCursor = 0%@NL@%
      CALL ShowRecord(TablesRec)%@NL@%
      CALL ShowMessage("You've escaped! Try again", 0)%@NL@%
      CALL DrawTable(WhichTable)%@NL@%
      CALL DrawHelpKeys(WhichTable)%@NL@%
      CALL ShowKeys(TablesRec, FOREGROUND + BRIGHT, 0, 0)%@NL@%
      EXIT FUNCTION%@NL@%
    CASE 32 TO 127                        ' Acceptable ASCII characters%@NL@%
     InitialLetter$ = Answer$%@NL@%
     FirstLetter$ = InitialLetter$%@NL@%
     EXIT FUNCTION%@NL@%
    CASE ELSE%@NL@%
        BEEP%@NL@%
        EraseMessage%@NL@%
         CALL ShowMessage("Not a valid key --- press Space bar", 0)%@NL@%
        WhichField = 0%@NL@%
        PlaceCursor = 0%@NL@%
        EXIT FUNCTION%@NL@%
    END SELECT%@NL@%
ELSEIF Answer$ <> CHR$(9) THEN%@NL@%
  EraseMessage%@NL@%
  CALL ShowMessage("Not a valid key --- press Space bar", 0)%@NL@%
  WhichField = 0%@NL@%
  EXIT FUNCTION%@NL@%
ELSE%@NL@%
     CALL ShowMessage("  Press TAB key or ENTER  ", 0)%@NL@%
END IF%@NL@%
%@NL@%
IF GetOut THEN%@NL@%
  counter = counter + 1%@NL@%
  IF counter < 15 THEN%@NL@%
    WhichField = 0%@NL@%
    WhichOne = 0%@NL@%
    EXIT FUNCTION%@NL@%
  ELSE%@NL@%
    GetOut = 0%@NL@%
    counter = 0%@NL@%
 END IF%@NL@%
END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The TransposeName FUNCTION takes a  string and decideds whether it is  *%@AE@%%@NL@%
%@AB@%'*  a comma-delimited, last-name-first name, a first-name-first name or a  *%@AE@%%@NL@%
%@AB@%'*  single word name. In the last case, the string is returned unchanged.  *%@AE@%%@NL@%
%@AB@%'*  In either of the other cases, the string is translated to the comple-  *%@AE@%%@NL@%
%@AB@%'*  mentary format.                                                        *%@AE@%%@NL@%
%@AB@%'*                              Parameters                                 *%@AE@%%@NL@%
%@AB@%'*  TheName   A string representing a CardHolders table TheName element,   *%@AE@%%@NL@%
%@AB@%'*            or a BookStock table Author Element                          *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION TransposeName$ (TheName AS STRING)%@NL@%
SubStrLen = (INSTR(TheName, ","))%@NL@%
IF SubStrLen = 0 THEN%@NL@%
  SubStrLen = INSTR(TheName, " ")%@NL@%
  IF SubStrLen = 0 THEN TransposeName$ = TheName: EXIT FUNCTION%@NL@%
END IF%@NL@%
TheName = LTRIM$(RTRIM$(TheName))%@NL@%
  IF INSTR(TheName, ",") THEN%@NL@%
    LastNameLen = INSTR(TheName, ",")%@NL@%
    LastName$ = LTRIM$(RTRIM$(LEFT$(TheName, LastNameLen - 1)))%@NL@%
    FirstName$ = LTRIM$(RTRIM$(MID$(TheName, LastNameLen + 1)))%@NL@%
    TransposeName$ = LTRIM$(RTRIM$(FirstName$ + " " + LastName$))%@NL@%
  ELSE%@NL@%
    FirstNameLen = INSTR(TheName, " ")%@NL@%
    IF FirstNameLen THEN%@NL@%
      FirstName$ = LTRIM$(RTRIM$(LEFT$(TheName, FirstNameLen - 1)))%@NL@%
      LastName$ = LTRIM$(RTRIM$(MID$(TheName, FirstNameLen + 1)))%@NL@%
    ELSE%@NL@%
      LastName$ = LTRIM$(RTRIM$(TheName))%@NL@%
    END IF%@NL@%
    TransposeName$ = LTRIM$(RTRIM$(LastName$ + ", " + FirstName$))%@NL@%
  END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'****************************** ValuesOK FUNCTION **************************%@AE@%%@NL@%
%@AB@%'* The ValuesOK FUNCTION checks the values input by the user for various   *%@AE@%%@NL@%
%@AB@%'* purposes. The checking is very minimal and checks the format of what is *%@AE@%%@NL@%
%@AB@%'* entered. For example, the IDnum field needs a double value, but the form*%@AE@%%@NL@%
%@AB@%'* (5 digits, followed by a decimal point, followed by 4 digits) is more   *%@AE@%%@NL@%
%@AB@%'* important than the data type.                                           *%@AE@%%@NL@%
%@AB@%'*                                Parameters:                              *%@AE@%%@NL@%
%@AB@%'*   Big Rec      User-defined type containing all table information       *%@AE@%%@NL@%
%@AB@%'*   Key1, Key2   Represent strings to check                               *%@AE@%%@NL@%
%@AB@%'*   ValueToSeek  Represents the final value of a combined index           *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION ValuesOK (BigRec AS RecStruct, Key1$, Key2$, ValueToSeek$)%@NL@%
  IndexName$ = BigRec.WhichIndex%@NL@%
  ValueToSeek$ = LTRIM$(RTRIM$(ValueToSeek$))%@NL@%
  SELECT CASE RTRIM$(LTRIM$(IndexName$))%@NL@%
    CASE "TitleIndexBS", "PubIndexBS"       ' LEN <= 50%@NL@%
      IF LEN(Key1$) > 50 THEN ValuesOK = FALSE: EXIT FUNCTION%@NL@%
%@NL@%
    CASE "AuthorIndexBS", "NameIndexCH"     ' LEN <= 36%@NL@%
      IF LEN(Key1$) > 36 THEN ValuesOK = FALSE: EXIT FUNCTION%@NL@%
%@NL@%
    CASE "StateIndexCH"                     ' LEN = 2%@NL@%
      IF LEN(Key1$) > 2 THEN ValuesOK = FALSE: EXIT FUNCTION%@NL@%
%@NL@%
    CASE "IDIndex", "IDIndexBO"             ' 5 digits befor d.p., 4 after%@NL@%
      IF LEN(ValueToSeek$) <> 10 THEN ValuesOK = FALSE: EXIT FUNCTION%@NL@%
      IF MID$(ValueToSeek$, 6, 1) <> "." THEN%@NL@%
        ValuesOK = FALSE: EXIT FUNCTION%@NL@%
      END IF%@NL@%
    CASE "CardNumIndexCH", "CardNumIndexBO" ' 5 digits, value <= LONG%@NL@%
      IF LEN(ValueToSeek$) <> 5 THEN ValuesOK = FALSE: EXIT FUNCTION%@NL@%
%@NL@%
    CASE "ZipIndexCH"                       ' 5 digits, value <= LONG%@NL@%
      IF LEN(ValueToSeek$) <> 5 THEN ValuesOK = FALSE: EXIT FUNCTION%@NL@%
%@NL@%
    CASE "BigIndex"                         ' Key1$ <= 50, Key2$ <= 36%@NL@%
      IF LEN(Key1$) > 50 THEN ValuesOK = FALSE: EXIT FUNCTION%@NL@%
      IF LEN(Key2$) > 36 THEN ValuesOK = FALSE: EXIT FUNCTION%@NL@%
      IF MID$(ValueToSeek$, 6, 1) <> "." THEN%@NL@%
        ValuesOK = FALSE: EXIT FUNCTION%@NL@%
      END IF%@NL@%
  END SELECT%@NL@%
  ValuesOK = TRUE%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BOOKMOD3.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\BOOKMOD3.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'* This is module level code for BOOKMOD3.BAS, the fourth                  *%@AE@%%@NL@%
%@AB@%'* module of BOOKLOOK.BAS.                                                 *%@AE@%%@NL@%
%@AB@%'*                                                                         *%@AE@%%@NL@%
%@AB@%'* The module contains a procedure, MakeOver, you can use to convert text  *%@AE@%%@NL@%
%@AB@%'* files containing the right format and type of information for the tables*%@AE@%%@NL@%
%@AB@%'* used by the BOOKLOOK program to a .MDB file. However, you need to call  *%@AE@%%@NL@%
%@AB@%'* MakeOver from the Immediate Window, and in order for it to work, you    *%@AE@%%@NL@%
%@AB@%'* must use the PROISAMD version of the TSR, because MakeOver needs the    *%@AE@%%@NL@%
%@AB@%'* data dictionary functionality for creating indexes, etc.                *%@AE@%%@NL@%
%@AB@%'* If you use the DTFMTER.QLB library functions you must include the files *%@AE@%%@NL@%
%@AB@%'* DATIM.BI and FORMAT.BI at this level, using syntax as shown below.      *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
DEFINT A-Z%@NL@%
%@AB@%'$INCLUDE: 'booklook.bi'%@AE@%%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The BooksBorrowed SUB takes the CardNum in BooksOut associated with the*%@AE@%%@NL@%
%@AB@%'*  currently displayed CardHolder, then looks up each book in BooksOut    *%@AE@%%@NL@%
%@AB@%'*  assigned to that CardNum. Note that you can use SEEKoperand to find the*%@AE@%%@NL@%
%@AB@%'*  first matching record, but thereafter you need to MOVENEXT and check   *%@AE@%%@NL@%
%@AB@%'*  each succeeding record to see if the CardNum matches. When a match is  *%@AE@%%@NL@%
%@AB@%'*  made, look up the IDnum in the BooksOut table and retrieve the title.  *%@AE@%%@NL@%
%@AB@%'*  Put all the titles in the Titles array, then display with PeekWindow.  *%@AE@%%@NL@%
%@AB@%'*                                   Parameters                            *%@AE@%%@NL@%
%@AB@%'*  TablesRec   Structure containing information on all database tables    *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB BooksBorrowed (TablesRec AS RecStruct)%@NL@%
        DIM Titles(50) AS STRING%@NL@%
%@AB@%        ' First, get the card number of the current record in Bookstock - then%@AE@%%@NL@%
%@AB@%        ' at the end of this procedure, restore that book%@AE@%%@NL@%
        IF LOF(cBooksOutTableNum) = 0 THEN EXIT SUB%@NL@%
        IF GETINDEX$(cBooksOutTableNum) <> "CardNumIndexBO" THEN%@NL@%
                SETINDEX cBooksOutTableNum, "CardNumIndexBO"%@NL@%
        END IF%@NL@%
        RevName$ = TransposeName$(TablesRec.Lendee.TheName)%@NL@%
        SEEKEQ cBooksOutTableNum, TablesRec.Lendee.CardNum%@NL@%
         IF NOT EOF(cBooksOutTableNum) THEN%@NL@%
                DO%@NL@%
                        RETRIEVE cBooksOutTableNum, TablesRec.OutBooks%@NL@%
                         IF TablesRec.OutBooks.CardNum = TablesRec.Lendee.CardNum THEN%@NL@%
                                        IF GETINDEX$(cBookStockTableNum) <> "IDIndex" THEN%@NL@%
                                                SETINDEX cBookStockTableNum, "IDIndex"%@NL@%
                                        END IF%@NL@%
                                        SEEKEQ cBookStockTableNum, TablesRec.OutBooks.IDnum%@NL@%
                                        IF NOT EOF(cBookStockTableNum) THEN%@NL@%
                                                RETRIEVE cBookStockTableNum, TablesRec.Inventory%@NL@%
                                                Titles(Index) = RTRIM$(TablesRec.Inventory.Title)%@NL@%
                                                ThisSize = LEN(RTRIM$(Titles(Index)))%@NL@%
                                                        IF ThisSize > Biggest THEN%@NL@%
                                                                Biggest = ThisSize%@NL@%
                                                        END IF%@NL@%
                                         Index = Index + 1%@NL@%
                                        END IF%@NL@%
                                END IF%@NL@%
                MOVENEXT cBooksOutTableNum%@NL@%
                LOOP UNTIL EOF(cBooksOutTableNum)%@NL@%
        ELSE%@NL@%
                Alert$ = RevName$ + " currently has no books checked out"%@NL@%
                CALL ShowMessage(Alert$, 0)%@NL@%
        END IF%@NL@%
        IF Index <> 0 THEN%@NL@%
                HeadMessage$ = " Books borrowed by " + RevName$ + " "%@NL@%
                FootMessage$ = " Press a key to continue "%@NL@%
                CALL PeekWindow(Titles(), HeadMessage$, FootMessage$, Biggest)%@NL@%
                CALL DrawTable(TablesRec.TableNum)%@NL@%
                CALL ShowMessage(KEYSMESSAGE, 0)%@NL@%
        END IF%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The BorrowBook SUB prompts the user to enter the name of the Cardholder*%@AE@%%@NL@%
%@AB@%'*  who wants to borrow the book, then updates all the other tables accord-*%@AE@%%@NL@%
%@AB@%'*  ingly. The name or cardnumber can be entered --- if conversion to a    *%@AE@%%@NL@%
%@AB@%'*  number fails, the user entered a name. If the name isn't of the right  *%@AE@%%@NL@%
%@AB@%'*  format, it is transposed to last-first, comma delimited. If no exact   *%@AE@%%@NL@%
%@AB@%'*  match is found, the next best match is attempted and presented for the *%@AE@%%@NL@%
%@AB@%'*  approval of the user.%@AE@%%@NL@%
%@AB@%'*                                  Parameter                              *%@AE@%%@NL@%
%@AB@%'*  TablesRec   RecStruct type variable holding current table information  *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB BorrowBook (TablesRec AS RecStruct)%@NL@%
%@NL@%
DIM SaveBook AS RecStruct%@NL@%
DIM PeekString(10) AS STRING%@NL@%
%@NL@%
Prompt$ = "Name or Card Number to Seek: "%@NL@%
SaveBook = TablesRec                          ' Save book information%@NL@%
%@AB@%        ' Prompt user and catch keystroke%@AE@%%@NL@%
CALL ShowMessage("Enter borrower cardnumber or name: ", 1)%@NL@%
FirstChar = ASC(ReturnKey$)                   ' ReturnKey$ is a function%@NL@%
IF FirstChar = ESCAPE THEN CALL ShowMessage("", 0): EXIT SUB%@NL@%
Answer$ = MakeString$(FirstChar, Prompt$)%@NL@%
IF FirstChar = ESCAPE THEN CALL ShowMessage("", 0): EXIT SUB%@NL@%
NumToCheck& = VAL(Answer$)%@NL@%
IF NumToCheck& = 0 THEN%@NL@%
        IF INSTR(Answer$, ",") = 0 THEN%@NL@%
                StraightName$ = Answer$%@NL@%
                Answer$ = TransposeName$(Answer$)%@NL@%
        ELSE%@NL@%
                StraightName$ = TransposeName$(Answer$)%@NL@%
        END IF%@NL@%
%@NL@%
        SETINDEX cCardHoldersTableNum, "NameIndexCH"%@NL@%
        SEEKEQ cCardHoldersTableNum, Answer$%@NL@%
        IF EOF(cCardHoldersTableNum) THEN%@NL@%
                MOVEFIRST cCardHoldersTableNum%@NL@%
                SEEKGE cCardHoldersTableNum, Answer$     ' If EQ fails, try GE%@NL@%
                IF EOF(cCardHoldersTableNum) THEN%@NL@%
                        Alert$ = "Sorry, couldn't find " + StraightName$ + " in CardHolders table..."%@NL@%
                        CALL ShowMessage(Alert$, 0)%@NL@%
                        EXIT SUB%@NL@%
                END IF%@NL@%
        END IF%@NL@%
        IF NOT EOF(cCardHoldersTableNum) THEN%@NL@%
                RETRIEVE cCardHoldersTableNum, SaveBook.Lendee%@NL@%
                IF TEXTCOMP(LEFT$(SaveBook.Lendee.TheName, 2), LEFT$(Answer$, 2)) = 0 THEN%@NL@%
                        NumToCheck& = SaveBook.Lendee.CardNum%@NL@%
                ELSE%@NL@%
                        Alert$ = "Sorry, couldn't match " + StraightName$ + " in CardHolders table..."%@NL@%
                        CALL ShowMessage(Alert$, 0): ' SLEEP: EraseMessage%@NL@%
                        EXIT SUB%@NL@%
                END IF%@NL@%
        END IF%@NL@%
ELSE%@NL@%
        SETINDEX cCardHoldersTableNum, "CardNumIndexCH"%@NL@%
        SEEKEQ cCardHoldersTableNum, NumToCheck&%@NL@%
        IF EOF(cCardHoldersTableNum) THEN%@NL@%
                Alert$ = "Sorry, could not match " + Answer$%@NL@%
                CALL ShowMessage(Alert$, 0):  ' SLEEP: EraseMessage%@NL@%
                EXIT SUB%@NL@%
        ELSE%@NL@%
                RETRIEVE cCardHoldersTableNum, SaveBook.Lendee%@NL@%
                NumToCheck& = SaveBook.Lendee.CardNum%@NL@%
        END IF%@NL@%
END IF%@NL@%
%@AB@%                                                                                                ' You can replace this phoney date with a call to%@AE@%%@NL@%
DateDue# = 32950#     ' the Date/Time library as shown on these 2 lines:%@NL@%
%@AB@%'DateDue# = Now# + 30#%@AE@%%@NL@%
%@AB@%'DateDue$ = STR$(Month&(DateDue#)) + "/" + LTRIM$(STR$(Day&(DateDue#))) + "/" + LTRIM$(STR$(Year&(DateDue#)))%@AE@%%@NL@%
%@NL@%
%@AB@%' Show the information on the Cardholder you found...%@AE@%%@NL@%
DO%@NL@%
        PeekString(0) = " This book will be checked out to: "%@NL@%
        PeekString(1) = ""%@NL@%
        PeekString(2) = RTRIM$(SaveBook.Lendee.TheName)%@NL@%
        PeekString(3) = RTRIM$(SaveBook.Lendee.Street)%@NL@%
        PeekString(4) = RTRIM$(SaveBook.Lendee.City) + ", " + RTRIM$(SaveBook.Lendee.State)%@NL@%
        PeekString(5) = "Card number: " + STR$(SaveBook.Lendee.CardNum)%@NL@%
        PeekString(6) = ""%@NL@%
        PeekString(7) = "The Due Date will be " + STR$(DateDue# + 30)%@NL@%
        IF LEN(DateDue$) THEN PeekString(7) = "The Due Date will be " + DateDue$%@NL@%
        FOR Index = 0 TO 8%@NL@%
                ThisSize = LEN(RTRIM$(PeekString(Index)))%@NL@%
                IF ThisSize > Biggest THEN%@NL@%
                        Biggest = ThisSize%@NL@%
                END IF%@NL@%
        NEXT Index%@NL@%
%@NL@%
        HeadMessage$ = " Cardholder checking out this book "%@NL@%
        FootMessage$ = " Press ENTER to confirm this checkout "%@NL@%
        Alert$ = "Press N seek next similar match, ESC to abort checkout"%@NL@%
        CALL ShowMessage(Alert$, 0)%@NL@%
        CALL PeekWindow(PeekString(), HeadMessage$, FootMessage$, Biggest)%@NL@%
%@NL@%
%@AB@%        ' Let the user press "N" to see the next best match, ESC to abort checkout%@AE@%%@NL@%
%@AB@%        ' anything else to confirm this as person to whom to check book out to%@AE@%%@NL@%
%@NL@%
        Reply$ = ReturnKey$%@NL@%
        SELECT CASE Reply$%@NL@%
                CASE CHR$(ESCAPE)%@NL@%
                        DoneFlag = TRUE%@NL@%
                CASE "N", "n"%@NL@%
                        MOVENEXT cCardHoldersTableNum%@NL@%
                        IF EOF(cCardHoldersTableNum) THEN%@NL@%
                                DoneFlag = TRUE%@NL@%
                        ELSE%@NL@%
                                RETRIEVE cCardHoldersTableNum, SaveBook.Lendee%@NL@%
                                NumToCheck& = SaveBook.Lendee.CardNum%@NL@%
                                IF LEFT$(SaveBook.Lendee.TheName, 2) <> LEFT$(Answer$, 2) THEN%@NL@%
                                        DoneFlag = TRUE%@NL@%
                                END IF%@NL@%
                        END IF%@NL@%
                CASE ELSE%@NL@%
                                TablesRec.OutBooks.CardNum = NumToCheck&%@NL@%
                                TablesRec.OutBooks.IDnum = SaveBook.Inventory.IDnum%@NL@%
                                TablesRec.OutBooks.DueDate = DateDue#%@NL@%
                                DoneFlag = TRUE%@NL@%
                                MOVEFIRST (cBooksOutTableNum)%@NL@%
                                INSERT cBooksOutTableNum, TablesRec.OutBooks%@NL@%
                                CALL ShowMessage("", 0)%@NL@%
        END SELECT%@NL@%
LOOP UNTIL DoneFlag%@NL@%
%@NL@%
CALL DrawTable(TablesRec.TableNum)%@NL@%
CALL ShowMessage(KEYSMESSAGE, 0)%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
%@AB@%'*  The Borrowed FUNCTION simply makes sure there are records in the      *%@AE@%%@NL@%
%@AB@%'*  BooksOut table. If there are none, a message is displayed             *%@AE@%%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
FUNCTION Borrowed%@NL@%
        IF LOF(cBooksOutTableNum) = 0 THEN%@NL@%
                CALL ShowMessage("Sorry, no records in the BooksOut table", 0): SLEEP%@NL@%
                Borrowed = FALSE%@NL@%
        ELSE%@NL@%
                Borrowed = TRUE%@NL@%
        END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'* The CatchKey function gets a keystroke and returns TRUE if it was ENTER,*%@AE@%%@NL@%
%@AB@%'* otherwise it returns FALSE.                                             *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION CatchKey%%@NL@%
        DO%@NL@%
        Answer$ = INKEY$%@NL@%
        LOOP WHILE Answer$ = ""%@NL@%
        SELECT CASE ASC(Answer$)%@NL@%
                CASE ENTER%@NL@%
                        CatchKey% = -1%@NL@%
                CASE ELSE%@NL@%
                        CatchKey% = 0%@NL@%
        END SELECT%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The GetStatus FUNCTION looks up the status of a book in the BooksOut   *%@AE@%%@NL@%
%@AB@%'*  table. If the SEEK fails it means the book isn't checked out, and that *%@AE@%%@NL@%
%@AB@%'*  message is displayed. Otherwise, it is placed in DateToShow parameter. *%@AE@%%@NL@%
%@AB@%'*  The final message about retrieving borrow info relates to LendeeProfile*%@AE@%%@NL@%
%@AB@%'*                                   Parameters                            *%@AE@%%@NL@%
%@AB@%'*  TablesRec     Structure containing the information about all the tables*%@AE@%%@NL@%
%@AB@%'*  DateToShow    The due date to show in the ShowStatus SUB               *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION GetStatus (TablesRec AS RecStruct, DateToShow#)%@NL@%
                IF GETINDEX$(cBooksOutTableNum) <> "IDIndexBO" THEN%@NL@%
                        SETINDEX cBooksOutTableNum, "IDIndexBO"%@NL@%
                END IF%@NL@%
                SEEKEQ cBooksOutTableNum, TablesRec.Inventory.IDnum%@NL@%
                IF NOT EOF(cBooksOutTableNum) THEN%@NL@%
                        RETRIEVE cBooksOutTableNum, TablesRec.OutBooks%@NL@%
                ELSE%@NL@%
                        Alert$ = "This book is not checked out"   ' the book wasn't in BooksOut%@NL@%
                        CALL ShowMessage(Alert$, 0)               ' table, so it wasn't out%@NL@%
                        DateToShow# = 0: GetStatus = FALSE%@NL@%
                        EXIT FUNCTION%@NL@%
                END IF%@NL@%
                DateToShow# = TablesRec.OutBooks.DueDate#%@NL@%
                GetStatus = TRUE%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The LendeeProfile takes the IDnum of the currently displayed book, then*%@AE@%%@NL@%
%@AB@%'*  looks that up in the BooksOut table and fetches the CardHolder record  *%@AE@%%@NL@%
%@AB@%'*  that corresponds to the CardNum entry in BooksOut. Then the CardNum is *%@AE@%%@NL@%
%@AB@%'*  looked up in the CardHolders table and the borrower information shown. *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  TablesRec   Contains information on all the tables in the database     *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB LendeeProfile (TablesRec AS RecStruct)%@NL@%
%@AB@%        ' Make sure the CardHolders table actually has records%@AE@%%@NL@%
        IF LOF(cCardHoldersTableNum) = 0 THEN%@NL@%
                CALL ShowMessage("Sorry, there are no cardholder records", 0): SLEEP%@NL@%
                EXIT SUB%@NL@%
        END IF%@NL@%
%@AB@%        ' Create an array to hold information from CardHolders table%@AE@%%@NL@%
        DIM LendeeInfo(10)  AS STRING%@NL@%
%@AB@%        ' Set the index if it is not the one you want%@AE@%%@NL@%
        IF GETINDEX$(cBooksOutTableNum) <> "IDIndexBO" THEN%@NL@%
                SETINDEX cBooksOutTableNum, "IDIndexBO"%@NL@%
        END IF%@NL@%
        SEEKEQ cBooksOutTableNum, TablesRec.Inventory.IDnum    ' Seek the record.%@NL@%
        IF EOF(cBooksOutTableNum) THEN                         ' If you find it,%@NL@%
                CALL ShowMessage("This book is not checked out", 0)  ' the book is out,%@NL@%
                EXIT SUB                                             ' otherwise not.%@NL@%
        ELSE                                                   ' If it's there,%@NL@%
                RETRIEVE cBooksOutTableNum, TablesRec.OutBooks       ' fetch it.%@NL@%
%@NL@%
%@AB@%                ' If the CardNum exists, set an index in CardHolders and SEEK the%@AE@%%@NL@%
%@AB@%                ' CardNum. If SEEK fails, print a warning; if it succeeds, get the%@AE@%%@NL@%
%@AB@%                ' information about the borrower, and display it using PeekWindow%@AE@%%@NL@%
%@NL@%
                IF TablesRec.OutBooks.CardNum <> 0 THEN%@NL@%
                        IF GETINDEX$(cCardHoldersTableNum) <> "CardNumIndexCH" THEN%@NL@%
                                SETINDEX cCardHoldersTableNum, "CardNumIndexCH"%@NL@%
                        END IF%@NL@%
                        SEEKEQ cCardHoldersTableNum, TablesRec.OutBooks.CardNum%@NL@%
                        IF EOF(cBooksOutTableNum) THEN%@NL@%
                                Alert$ = "Cardholder number associated with book ID is not valid"%@NL@%
                                CALL ShowMessage(Alert$, 0)%@NL@%
                                EXIT SUB%@NL@%
                        ELSE%@NL@%
                                RETRIEVE cCardHoldersTableNum, TablesRec.Lendee%@NL@%
                                LendeeInfo(0) = RTRIM$(TablesRec.Lendee.TheName)%@NL@%
                                LendeeInfo(1) = ""%@NL@%
                                LendeeInfo(2) = RTRIM$(TablesRec.Lendee.Street)%@NL@%
                                LendeeInfo(3) = RTRIM$(TablesRec.Lendee.City)%@NL@%
                                LendeeInfo(4) = RTRIM$(TablesRec.Lendee.State)%@NL@%
                                LendeeInfo(5) = LTRIM$(STR$(TablesRec.Lendee.Zip))%@NL@%
                                LendeeInfo(7) = STR$(TablesRec.Lendee.CardNum)%@NL@%
                                LendeeInfo(6) = ""%@NL@%
                                LendeeInfo(7) = "Card number: " + LendeeInfo(7)%@NL@%
                                LendeeInfo(8) = ""%@NL@%
                                FOR Index = 1 TO 6%@NL@%
                                        ThisBig = LEN(LendeeInfo(Index))%@NL@%
                                        IF ThisBig > BiggestYet THEN%@NL@%
                                                BiggestYet = ThisBig%@NL@%
                                        END IF%@NL@%
                                NEXT Index%@NL@%
                                Alert$ = "Press V to access the record for this cardholder"%@NL@%
                                CALL ShowMessage(Alert$, 0)%@NL@%
                                HeadMessage$ = "Borrower of this Book"%@NL@%
                                FootMessage$ = "Press a key to clear box"%@NL@%
                                CALL ClearEm(TablesRec.TableNum, 1, 1, 1, 1, 1, 1)%@NL@%
                                CALL PeekWindow(LendeeInfo(), HeadMessage$, FootMessage$, BiggestYet)%@NL@%
                                CALL DrawTable(TablesRec.TableNum)%@NL@%
                                CALL ShowMessage(KEYSMESSAGE, 0)%@NL@%
                        END IF%@NL@%
                END IF%@NL@%
        END IF%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'* The MakeOver SUB lets the user input the names of properly formatted    *%@AE@%%@NL@%
%@AB@%'* text files, then creates a database file of the same type as BOOKS.MDB. *%@AE@%%@NL@%
%@AB@%'* There is also a prompt for the new database name. The text files must   *%@AE@%%@NL@%
%@AB@%'* contain comma-delimited fields, with strings within double quote marks. *%@AE@%%@NL@%
%@AB@%'* The last part of this SUB demonstrates how indexes are created. You need*%@AE@%%@NL@%
%@AB@%'* to have loaded PROISAMD.EXE to run this procedure.                      *%@AE@%%@NL@%
%@AB@%'*                            Parameters:                                  *%@AE@%%@NL@%
%@AB@%'*   Big Rec      User-defined type containing all table information       *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB MakeOver (BigRec AS RecStruct)%@NL@%
        CLOSE%@NL@%
        Alert$ = "Type name of file containing Cardholders table data: "%@NL@%
        CALL ShowMessage(Alert$, 1)%@NL@%
        INPUT "", CardFile$%@NL@%
        Alert$ = "Type name of file containing BooksOut table data: "%@NL@%
        CALL ShowMessage(Alert$, 1)%@NL@%
        INPUT "", OutBooks$%@NL@%
        Alert$ = "Type name of file containing BookStock table data: "%@NL@%
        CALL ShowMessage(Alert$, 1)%@NL@%
        INPUT "", BookFile$%@NL@%
        Alert$ = "Type name of ISAM file to create: "%@NL@%
        CALL ShowMessage(Alert$, 1)%@NL@%
        INPUT "", IsamFile$%@NL@%
        IF UCASE$(IsamFile$) = "BOOKS.MDB" THEN KILL "BOOKS.MDB"%@NL@%
        CALL ShowMessage("Loading database...", 0)%@NL@%
%@NL@%
        CLOSE%@NL@%
        ON LOCAL ERROR GOTO FileHandler%@NL@%
        LenFileNo% = 10%@NL@%
        OPEN CardFile$ FOR INPUT AS LenFileNo%%@NL@%
        OutFileNo% = 11%@NL@%
        OPEN OutBooks$ FOR INPUT AS OutFileNo%%@NL@%
        RecFileNo% = 12%@NL@%
        OPEN BookFile$ FOR INPUT AS RecFileNo%%@NL@%
        ON ERROR GOTO 0%@NL@%
%@NL@%
%@AB@%        ' Open the database and the BookStock table%@AE@%%@NL@%
        OPEN IsamFile$ FOR ISAM Books "BookStock" AS cBookStockTableNum%@NL@%
        OPEN IsamFile$ FOR ISAM Borrowers "CardHolders" AS cCardHoldersTableNum%@NL@%
        OPEN IsamFile$ FOR ISAM BookStatus "BooksOut" AS cBooksOutTableNum%@NL@%
        CALL ShowMessage(" Opened all isam tables", 0)%@NL@%
%@NL@%
        SeqFile% = LenFileNo%@NL@%
        DO WHILE (Reader%(BigRec, SeqFile%))%@NL@%
         INSERT cCardHoldersTableNum, BigRec.Lendee%@NL@%
        LOOP%@NL@%
        SeqFile% = OutFileNo%@NL@%
        DO WHILE (Reader%(BigRec, SeqFile))%@NL@%
         INSERT cBooksOutTableNum, BigRec.OutBooks%@NL@%
        LOOP%@NL@%
        SeqFile = RecFileNo%@NL@%
        DO WHILE (Reader%(BigRec, SeqFile))%@NL@%
         INSERT cBookStockTableNum, BigRec.Inventory%@NL@%
        LOOP%@NL@%
        CALL ShowMessage("Finished reading in records---Indexes next", 0)%@NL@%
%@AB@%' These indexes are already in the BOOKS.MDB database --- the following%@AE@%%@NL@%
%@AB@%' is the syntax that was used to create them%@AE@%%@NL@%
%@NL@%
        ON LOCAL ERROR GOTO FileHandler%@NL@%
        CREATEINDEX cBookStockTableNum, "TitleIndexBS", 0, "Title"%@NL@%
        CREATEINDEX cBookStockTableNum, "AuthorIndexBS", 0, "Author"%@NL@%
        CREATEINDEX cBookStockTableNum, "PubIndexBS", 0, "Publisher"%@NL@%
        CREATEINDEX cBookStockTableNum, "IDIndex", 1, "IDnum"     ' Note unique index%@NL@%
        CREATEINDEX cBookStockTableNum, "BigIndex", 0, "Title", "Author", "IDnum"%@NL@%
%@NL@%
        CREATEINDEX cBooksOutTableNum, "IDIndexBO", 0, "IDnum"%@NL@%
        CREATEINDEX cBooksOutTableNum, "CardNumIndexBO", 0, "CardNum"%@NL@%
%@NL@%
        CREATEINDEX cCardHoldersTableNum, "NameIndexCH", 0, "TheName"%@NL@%
        CREATEINDEX cCardHoldersTableNum, "StateIndexCH", 0, "State"%@NL@%
        CREATEINDEX cCardHoldersTableNum, "ZipIndexCH", 0, "Zip"%@NL@%
        CREATEINDEX cCardHoldersTableNum, "CardNumIndexCH", 1, "CardNum"  ' Unique index%@NL@%
        ON ERROR GOTO 0%@NL@%
        CALL ShowMessage(" All done with indexes...", 0)%@NL@%
%@AB@%        'CLOSE%@AE@%%@NL@%
%@NL@%
        EXIT SUB%@NL@%
%@NL@%
FileHandler:%@NL@%
        IF ERR = 73 THEN%@NL@%
                CALL ShowMessage("You need to Exit QBX and load PROISAMD /Ib:24 /Ii:16", 0)%@NL@%
        ELSEIF ERR = 10 THEN%@NL@%
                Alert$ = "Finished appending the records to " + IsamFile$%@NL@%
                CALL ShowMessage(Alert$, 0)%@NL@%
                END%@NL@%
        ELSEIF ERR = 86 THEN%@NL@%
                Alert$ = "Tried to add record with duplicate value on a unique index"%@NL@%
                CALL ShowMessage(Alert$, 0)%@NL@%
                ELSE%@NL@%
                CALL ShowMessage("Can't find textfiles needed to make the database", 0)%@NL@%
        END IF%@NL@%
        END%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The PeekWindow SUB displays the elements of the OutBookNames array in  *%@AE@%%@NL@%
%@AB@%'*  a window on top of the currently displayed table.                      *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  OutBookNames    Array of strings containing lines displayed in window  *%@AE@%%@NL@%
%@AB@%'*  Header$         String to show at top of window                        *%@AE@%%@NL@%
%@AB@%'*  Footer$         String to show at bottom of window                     *%@AE@%%@NL@%
%@AB@%'*  BiggestYet      Length of the longest string to be shown               *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB PeekWindow (OutBookNames() AS STRING, Header$, Footer$, BiggestYet%)%@NL@%
HeadLen = LEN(Header$)        ' + 4%@NL@%
FootLen = LEN(Footer$)        ' + 4%@NL@%
IF HeadLen > FootLen THEN Bigger = HeadLen ELSE Bigger = FootLen%@NL@%
IF Bigger > BiggestYet THEN BiggestYet = Bigger%@NL@%
%@NL@%
InnerBox = 9          ' InnerBox is total number of lines allowed inside box%@NL@%
first = 0: last = 8%@NL@%
DO%@NL@%
%@NL@%
%@AB@%        ' Calculate header and footer placement%@AE@%%@NL@%
%@NL@%
                IF (HeadLen MOD 2) THEN%@NL@%
                        HeadStart = ((BiggestYet - HeadLen) \ 2) + 13%@NL@%
                ELSE%@NL@%
                        HeadStart = ((BiggestYet - HeadLen) \ 2) + 12%@NL@%
                END IF%@NL@%
                IF (FootLen MOD 2) THEN%@NL@%
                        FootStart = ((BiggestYet - FootLen) \ 2) + 13%@NL@%
                ELSE%@NL@%
                        FootStart = ((BiggestYet - FootLen) \ 2) + 12%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Print a box and fill it with titles%@AE@%%@NL@%
                Inset = TABLETOP + 2%@NL@%
%@NL@%
                Lines = Inset + 1%@NL@%
                IF MoreBoxes = FALSE THEN%@NL@%
                        LOCATE Inset, 3%@NL@%
                        PRINT "       "; STRING$(BiggestYet + 2, CHR$(205)); ""%@NL@%
                END IF%@NL@%
                FOR PrintEm = first TO last%@NL@%
                        LOCATE Lines + NextSpace, 3%@NL@%
                        PRINT "        "; OutBookNames(Total); SPACE$(BiggestYet - LEN((OutBookNames(Total)))); " "%@NL@%
                        Total = Total + 1: NextSpace = NextSpace + 1%@NL@%
                NEXT PrintEm%@NL@%
                IF MoreBoxes = FALSE THEN                       ' Means first group%@NL@%
                        LOCATE Lines + NextSpace, 3%@NL@%
                        PRINT "       "; STRING$(BiggestYet + 2, CHR$(205)); ""%@NL@%
                        COLOR BACKGROUND, FOREGROUND + BRIGHT%@NL@%
                        LOCATE Inset, HeadStart%@NL@%
                        PRINT Header$;                          '" "; Header$; " "%@NL@%
                        LOCATE Lines + NextSpace, FootStart%@NL@%
                        PRINT Footer$                           '" "; Footer$; " "%@NL@%
                        COLOR FOREGROUND, BACKGROUND%@NL@%
                END IF%@NL@%
                SLEEP%@NL@%
        first = first + InnerBox: last = last + InnerBox%@NL@%
        NextSpace = 0: HowMany = 0%@NL@%
%@NL@%
        MoreBoxes = TRUE%@NL@%
%@NL@%
LOOP UNTIL LEN(RTRIM$(OutBookNames(Total))) = 0%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The Reader FUNCTION reads specified text files and returns each line   *%@AE@%%@NL@%
%@AB@%'*  as a separate record for the corresponding table.                      *%@AE@%%@NL@%
%@AB@%'*                               Parameters                                *%@AE@%%@NL@%
%@AB@%'*  BigRec    RecStruct variable containing information on tables          *%@AE@%%@NL@%
%@AB@%'*  SeqFile   File number used to open the text file to be read%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
FUNCTION Reader% (BigRec AS RecStruct, SeqFile%)%@NL@%
        SELECT CASE SeqFile%@NL@%
                CASE 10%@NL@%
                        IF NOT EOF(SeqFile) THEN%@NL@%
                         INPUT #SeqFile, BigRec.Lendee.CardNum, BigRec.Lendee.Zip, BigRec.Lendee.TheName, BigRec.Lendee.City, BigRec.Lendee.Street, BigRec.Lendee.State%@NL@%
                         Reader = -1%@NL@%
                        ELSE%@NL@%
                                Reader = 0%@NL@%
                        END IF%@NL@%
                CASE 11%@NL@%
                        IF NOT EOF(SeqFile) THEN%@NL@%
                         INPUT #SeqFile, BigRec.OutBooks.IDnum, BigRec.OutBooks.CardNum, BigRec.OutBooks.DueDate%@NL@%
                         Reader = -1%@NL@%
                        ELSE%@NL@%
                         Reader = 0%@NL@%
                        END IF%@NL@%
                CASE 12%@NL@%
                        IF NOT EOF(SeqFile) THEN%@NL@%
                                INPUT #SeqFile, BigRec.Inventory.IDnum, BigRec.Inventory.Price, BigRec.Inventory.Edition, BigRec.Inventory.Title, BigRec.Inventory.Author, BigRec.Inventory.Publisher%@NL@%
                                Reader = -1%@NL@%
                         ELSE%@NL@%
                                Reader = 0%@NL@%
                         END IF%@NL@%
        END SELECT%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'*  The ReturnBook SUB checks the book currently being displayed back into *%@AE@%%@NL@%
%@AB@%'*  the library --- that is, it eliminates the appropriate entry from the  *%@AE@%%@NL@%
%@AB@%'*  BooksOut table. It checks to see if the book is overdue, and if so, it *%@AE@%%@NL@%
%@AB@%'*  displays the amount of the fine to be paid.                            *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  TablesRec   RecStruct type variable holding current table information  *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB ReturnBook (TablesRec AS RecStruct, DueDate#)%@NL@%
%@NL@%
DIM ReturnLines(10) AS STRING%@NL@%
%@NL@%
Alert$ = "Press ENTER to check current book in, N to abort checkin..."%@NL@%
CALL ShowMessage(Alert$, 0)%@NL@%
%@NL@%
SETINDEX cBooksOutTableNum, "IDIndexBO"%@NL@%
SEEKEQ cBooksOutTableNum, TablesRec.Inventory.IDnum%@NL@%
IF NOT EOF(cBooksOutTableNum) THEN%@NL@%
        RETRIEVE cBooksOutTableNum, TablesRec.OutBooks%@NL@%
END IF%@NL@%
SETINDEX cCardHoldersTableNum, "CardNumIndexCH"%@NL@%
SEEKEQ cCardHoldersTableNum, TablesRec.OutBooks.CardNum%@NL@%
%@NL@%
IF NOT EOF(cBooksOutTableNum) THEN%@NL@%
        IF LOF(cCardHoldersTableNum) THEN%@NL@%
                RETRIEVE cCardHoldersTableNum, TablesRec.Lendee%@NL@%
        END IF%@NL@%
END IF%@NL@%
%@NL@%
Today# = 32000    'Replace this with call to DTFMTER.QLB library routine%@NL@%
%@AB@%                                                                        'as shown on the next 2 lines%@AE@%%@NL@%
%@AB@%'Today# = Now#%@AE@%%@NL@%
%@AB@%'ShowDate$ = STR$(Month&(Today#)) + "/" + LTRIM$(STR$(Day&(Today#))) + "/" + LTRIM$(STR$(Year&(Today#)))%@AE@%%@NL@%
IF Today# > TablesRec.OutBooks.DueDate THEN%@NL@%
        Fine = Today# - TablesRec.OutBooks.DueDate%@NL@%
END IF%@NL@%
%@NL@%
DateDue# = (TablesRec.OutBooks.DueDate)%@NL@%
%@AB@%' If you have DTFMTER.QLB loaded, use in to get date to display%@AE@%%@NL@%
%@AB@%' DateDue$ = STR$(Month&(DateDue#)) + "/" + LTRIM$(STR$(Day&(DateDue#))) + "/" + LTRIM$(STR$(Year&(DateDue#)))%@AE@%%@NL@%
ReturnLines(0) = ""%@NL@%
ReturnLines(1) = RTRIM$(TablesRec.Inventory.Title)%@NL@%
ReturnLines(2) = "is checked out to card number: " + STR$(TablesRec.OutBooks.CardNum)%@NL@%
ReturnLines(3) = RTRIM$(TablesRec.Lendee.TheName)%@NL@%
ReturnLines(4) = ""%@NL@%
ReturnLines(5) = "Today's Date:     " + STR$(Today#) + " - A phoney date"%@NL@%
IF LEN(ShowDate$) THEN ReturnLines(5) = "Today's Date:     " + ShowDate$%@NL@%
ReturnLines(6) = "Due Date of Book: " + STR$(TablesRec.OutBooks.DueDate)%@NL@%
IF LEN(DateDue$) THEN ReturnLines(6) = "Due Date of Book: " + DateDue$%@NL@%
ReturnLines(7) = "Fine Payable:     $" + STR$(ABS(Fine / 100))%@NL@%
ReturnLines(8) = ""%@NL@%
ReturnLines(9) = ""%@NL@%
FOR Index = 0 TO 10%@NL@%
        ThisOne = LEN(ReturnLines(Index))%@NL@%
        IF ThisOne > BiggestYet THEN BiggestYet = ThisOne%@NL@%
NEXT Index%@NL@%
Header$ = "Press ENTER to check book in..."%@NL@%
Footer$ = "Press N or n to abort checkin..."%@NL@%
CALL PeekWindow(ReturnLines(), Header$, Footer$, BiggestYet%)%@NL@%
%@NL@%
IF CatchKey THEN                              ' If user confirms, delete%@NL@%
        IF LOF(cBooksOutTableNum) <> 0 THEN         ' the entry to BooksOut table%@NL@%
                DELETE cBooksOutTableNum%@NL@%
        END IF%@NL@%
END IF%@NL@%
CALL DrawTable(TablesRec.TableNum)%@NL@%
CALL EraseMessage%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
%@AB@%'* The ShowStatus SUB uses the due date associated with the book IDnum from*%@AE@%%@NL@%
%@AB@%'* of the BooksOut table. This date is in serial form which is not decoded *%@AE@%%@NL@%
%@AB@%'* here, but can be decoded with the date/time function library supplied   *%@AE@%%@NL@%
%@AB@%'* with BASIC 7.0. The due date is displayed centered on the top line of   *%@AE@%%@NL@%
%@AB@%'* the ShowMessage box.                                                    *%@AE@%%@NL@%
%@AB@%'*                                Parameters                               *%@AE@%%@NL@%
%@AB@%'*  Stat$       Message introducing the due date when displayed in its box *%@AE@%%@NL@%
%@AB@%'*  ValueToShow The due date of the book from the BooksOut table           *%@AE@%%@NL@%
%@AB@%'***************************************************************************%@AE@%%@NL@%
SUB ShowStatus (Stat$, ValueToShow AS DOUBLE)%@NL@%
%@NL@%
COLOR FOREGROUND, BACKGROUND%@NL@%
DataEndLine$ = STRING$(60, 205)       'redraw the bottom line%@NL@%
%@NL@%
StringToShow$ = Stat$       ' Figure out where to locate the text%@NL@%
IF ValueToShow = 0 THEN%@NL@%
        LOCATE TABLEEND, 4%@NL@%
        PRINT DataEndLine$%@NL@%
        EXIT SUB%@NL@%
ELSE%@NL@%
%@AB@%        ' The dates in the file are in serial form. Use the DTFMTER.QLB library%@AE@%%@NL@%
%@AB@%        ' to decode serial dates for normal display. In the code below, the%@AE@%%@NL@%
%@AB@%        ' calls to the library are commented out.%@AE@%%@NL@%
%@NL@%
%@AB@%        'TheDate$ = STR$(Month&(ValueToShow)) + "/" + LTRIM$(STR$(Day&(ValueToShow))) + "/" + LTRIM$(STR$(Year&(ValueToShow)))%@AE@%%@NL@%
        IF Stat$ = " Total records in table: " OR LEN(TheDate$) = 0 THEN%@NL@%
                StringToShow$ = StringToShow$ + " " + STR$(ValueToShow)%@NL@%
        ELSE%@NL@%
                StringToShow$ = StringToShow$ + " " + TheDate$%@NL@%
        END IF%@NL@%
        HowLong = LEN(StringToShow$)%@NL@%
        PlaceStatus = (73 \ 2) - (HowLong \ 2)%@NL@%
        StatusSpace$ = CHR$(181) + STRING$(HowLong, 32) + CHR$(198)%@NL@%
END IF%@NL@%
LOCATE TABLEEND, PlaceStatus%@NL@%
PRINT StatusSpace$%@NL@%
COLOR BACKGROUND, BRIGHT + FOREGROUND%@NL@%
LOCATE TABLEEND, PlaceStatus + 1%@NL@%
PRINT StringToShow$%@NL@%
COLOR FOREGROUND, BACKGROUND%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CAL.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\CAL.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z      ' Default variable type is integer.%@NL@%
%@NL@%
%@AB@%' Define a data type for the names of the months and the%@AE@%%@NL@%
%@AB@%' number of days in each:%@AE@%%@NL@%
TYPE MonthType%@NL@%
        Number AS INTEGER  ' Number of days in the month%@NL@%
        MName AS STRING * 9   ' Name  of the month%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' Declare procedures used:%@AE@%%@NL@%
DECLARE FUNCTION IsLeapYear% (N%)%@NL@%
DECLARE FUNCTION GetInput% (Prompt$, Row%, LowVal%, HighVal%)%@NL@%
%@NL@%
DECLARE SUB PrintCalendar (Year%, Month%)%@NL@%
DECLARE SUB ComputeMonth (Year%, Month%, StartDay%, TotalDays%)%@NL@%
%@NL@%
DIM MonthData(1 TO 12)   AS MonthType%@NL@%
%@NL@%
%@AB@%' Initialize month definitions from DATA statements below:%@AE@%%@NL@%
FOR I = 1 TO 12%@NL@%
        READ MonthData(I).MName, MonthData(I).Number%@NL@%
NEXT%@NL@%
%@NL@%
%@AB@%' Main loop, repeat for as many months as desired:%@AE@%%@NL@%
DO%@NL@%
        CLS%@NL@%
%@NL@%
%@AB@%        ' Get year and month as input:%@AE@%%@NL@%
        Year = GetInput("Year (1899 to 2099): ", 1, 1899, 2099)%@NL@%
        Month = GetInput("Month (1 to 12): ", 2, 1, 12)%@NL@%
%@NL@%
%@AB@%        ' Print the calendar:%@AE@%%@NL@%
        PrintCalendar Year, Month%@NL@%
%@AB@%' Another Date?%@AE@%%@NL@%
        LOCATE 13, 1      ' Locate in 13th row, 1st column.%@NL@%
        PRINT "New Date? ";  ' Keep cursor on same line.%@NL@%
        LOCATE , , 1, 0, 13  ' Turn cursor on and make it one%@NL@%
%@AB@%                        ' character high.%@AE@%%@NL@%
        Resp$ = INPUT$(1) ' Wait for a key press.%@NL@%
        PRINT Resp$    ' Print  the key  pressed.%@NL@%
%@NL@%
LOOP WHILE UCASE$(Resp$) = "Y"%@NL@%
END%@NL@%
%@NL@%
%@AB@%' Data for the months of a year:%@AE@%%@NL@%
DATA January, 31, February, 28,  March, 31%@NL@%
DATA April, 30,   May, 31, June, 30, July, 31, August, 31%@NL@%
DATA September,   30, October, 31, November, 30, December, 31%@NL@%
%@NL@%
%@AB@%' ====================== COMPUTEMONTH =====================%@AE@%%@NL@%
%@AB@%'  Computes the first day and the total days in a month%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ComputeMonth (Year, Month, StartDay, TotalDays) STATIC%@NL@%
        SHARED MonthData() AS MonthType%@NL@%
%@NL@%
        CONST LEAP = 366 MOD 7%@NL@%
        CONST NORMAL = 365 MOD 7%@NL@%
%@NL@%
%@AB@%        ' Calculate total number of days (NumDays) since 1/1/1899:%@AE@%%@NL@%
%@NL@%
%@AB@%        ' Start with whole years:%@AE@%%@NL@%
        NumDays = 0%@NL@%
        FOR I = 1899 TO Year - 1%@NL@%
                IF IsLeapYear(I) THEN              ' If leap year,%@NL@%
                        NumDays = NumDays + LEAP   ' add 366 MOD 7.%@NL@%
                ELSE                               ' If normal year,%@NL@%
                        NumDays = NumDays + NORMAL ' add 365 MOD 7.%@NL@%
                END IF%@NL@%
        NEXT%@NL@%
%@NL@%
%@AB@%        ' Next, add in days from whole months:%@AE@%%@NL@%
        FOR I = 1 TO Month - 1%@NL@%
                NumDays = NumDays + MonthData(I).Number%@NL@%
        NEXT%@NL@%
%@NL@%
%@AB@%        ' Set the number of days in the requested month:%@AE@%%@NL@%
        TotalDays = MonthData(Month).Number%@NL@%
%@NL@%
%@AB@%        ' Compensate if requested year is a leap year:%@AE@%%@NL@%
        IF IsLeapYear(Year) THEN%@NL@%
%@NL@%
%@AB@%                ' If after February, add one to total days:%@AE@%%@NL@%
                IF Month > 2 THEN%@NL@%
                        NumDays = NumDays + 1%@NL@%
%@NL@%
%@AB@%                ' If February, add one to the month's days:%@AE@%%@NL@%
                ELSEIF Month = 2 THEN%@NL@%
                        TotalDays = TotalDays + 1%@NL@%
                END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' 1/1/1899 was a Sunday, so calculating "NumDays MOD 7"%@AE@%%@NL@%
%@AB@%        ' gives the day of week (Sunday = 0, Monday = 1, Tuesday%@AE@%%@NL@%
%@AB@%        ' = 2, and so on) for the first day of the input month:%@AE@%%@NL@%
        StartDay = NumDays MOD 7%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%' ======================== GETINPUT =======================%@AE@%%@NL@%
%@AB@%'  Prompts for input, then tests for a valid range%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION GetInput (Prompt$, Row, LowVal, HighVal) STATIC%@NL@%
%@NL@%
%@AB@%        ' Locate prompt at specified row, turn cursor on and%@AE@%%@NL@%
%@AB@%        ' make it one character high:%@AE@%%@NL@%
        LOCATE Row, 1, 1, 0, 13%@NL@%
        PRINT Prompt$;%@NL@%
%@NL@%
%@AB@%        ' Save column position:%@AE@%%@NL@%
        Column = POS(0)%@NL@%
%@NL@%
%@AB@%        ' Input value until it's within range:%@AE@%%@NL@%
        DO%@NL@%
                LOCATE Row, Column   ' Locate cursor at end of prompt.%@NL@%
                PRINT SPACE$(10)     ' Erase anything already there.%@NL@%
                LOCATE Row, Column   ' Relocate cursor at end of prompt.%@NL@%
                INPUT "", Value      ' Input value with no prompt.%@NL@%
        LOOP WHILE (Value < LowVal OR Value > HighVal)%@NL@%
%@NL@%
%@AB@%        ' Return valid input as value of function:%@AE@%%@NL@%
        GetInput = Value%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%' ====================== ISLEAPYEAR =======================%@AE@%%@NL@%
%@AB@%'   Determines if a year is a leap year or not%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION IsLeapYear (N) STATIC%@NL@%
%@NL@%
%@AB@%        ' If the year is evenly divisible by 4 and not divisible%@AE@%%@NL@%
%@AB@%        ' by 100, or if the year is evenly divisible by 400,%@AE@%%@NL@%
%@AB@%        ' then it's a leap year:%@AE@%%@NL@%
        IsLeapYear = (N MOD 4 = 0 AND N MOD 100 <> 0) OR (N MOD 400 = 0)%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%' ===================== PRINTCALENDAR =====================%@AE@%%@NL@%
%@AB@%'   Prints a formatted calendar given the year and month%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB PrintCalendar (Year, Month) STATIC%@NL@%
SHARED MonthData() AS MonthType%@NL@%
%@NL@%
%@AB@%        ' Compute starting day (Su M Tu ...)%@AE@%%@NL@%
%@AB@%        ' and total days for the month:%@AE@%%@NL@%
        ComputeMonth Year, Month, StartDay, TotalDays%@NL@%
        CLS%@NL@%
        Header$ = RTRIM$(MonthData(Month).MName) + "," + STR$(Year)%@NL@%
%@NL@%
%@AB@%        ' Calculate location for centering month and year:%@AE@%%@NL@%
        LeftMargin = (35 - LEN(Header$)) \ 2%@NL@%
%@AB@%' Print header:%@AE@%%@NL@%
        PRINT TAB(LeftMargin); Header$%@NL@%
        PRINT%@NL@%
        PRINT "Su    M   Tu    W   Th    F   Sa"%@NL@%
        PRINT%@NL@%
%@NL@%
%@AB@%        ' Recalculate and print tab%@AE@%%@NL@%
%@AB@%        ' to the first day of the month (Su M Tu ...):%@AE@%%@NL@%
        LeftMargin = 5 * StartDay + 1%@NL@%
        PRINT TAB(LeftMargin);%@NL@%
%@NL@%
%@AB@%        ' Print out the days of the month:%@AE@%%@NL@%
        FOR I = 1 TO TotalDays%@NL@%
                PRINT USING "##_   "; I;%@NL@%
%@NL@%
%@AB@%                ' Advance to the next line%@AE@%%@NL@%
%@AB@%                ' when the cursor is past column 32:%@AE@%%@NL@%
                IF POS(0) > 32 THEN PRINT%@NL@%
        NEXT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CHECK.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\CHECK.BAS%@AE@%%@NL@%
%@NL@%
DIM Amount(1 TO 100) AS CURRENCY, Balance AS CURRENCY%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE%@NL@%
CLS%@NL@%
%@AB@%' Get account's starting balance:%@AE@%%@NL@%
INPUT "Type starting balance, then press <ENTER>: ", Balance%@NL@%
%@AB@%' Get transactions. Continue accepting input%@AE@%%@NL@%
%@AB@%' until the input is zero for a transaction,%@AE@%%@NL@%
%@AB@%' or until 100 transactions have been entered:%@AE@%%@NL@%
FOR TransacNum% = 1 TO 100%@NL@%
   PRINT TransacNum%;%@NL@%
   PRINT ") Enter transaction amount (0 to end): ";%@NL@%
   INPUT "", Amount(TransacNum%)%@NL@%
   IF Amount(TransacNum%) = 0 THEN%@NL@%
      TransacNum% = TransacNum% - 1%@NL@%
      EXIT FOR%@NL@%
   END IF%@NL@%
NEXT%@NL@%
%@NL@%
%@AB@%' Sort transactions in ascending order,%@AE@%%@NL@%
%@AB@%' using a "bubble sort":%@AE@%%@NL@%
Limit% = TransacNum%%@NL@%
DO%@NL@%
   Swaps% = FALSE%@NL@%
   FOR I% = 1 TO (Limit% - 1)%@NL@%
%@AB@%      ' If two adjacent elements are out of order,%@AE@%%@NL@%
%@AB@%      ' switch those elements:%@AE@%%@NL@%
      IF Amount(I%) < Amount(I% + 1) THEN%@NL@%
         SWAP Amount(I%), Amount(I% + 1)%@NL@%
         Swaps% = I%%@NL@%
      END IF%@NL@%
   NEXT I%%@NL@%
%@AB@%  ' Sort on next pass only to where last switch was made:%@AE@%%@NL@%
  Limit% = Swaps%%@NL@%
%@NL@%
%@AB@%' Sort until no elements are exchanged:%@AE@%%@NL@%
LOOP WHILE Swaps%%@NL@%
%@AB@%' Print the sorted transaction array. If a transaction%@AE@%%@NL@%
%@AB@%' is greater than zero, print it as a "CREDIT"; if a%@AE@%%@NL@%
%@AB@%' transaction is less than zero, print it as a "DEBIT":%@AE@%%@NL@%
FOR I% = 1 TO TransacNum%%@NL@%
   IF Amount(I%) > 0 THEN%@NL@%
      PRINT USING "CREDIT: $$#####.##"; Amount(I%)%@NL@%
   ELSEIF Amount(I%) < 0 THEN%@NL@%
      PRINT USING "DEBIT: $$#####.##"; Amount(I%)%@NL@%
   END IF%@NL@%
%@AB@%   ' Update balance:%@AE@%%@NL@%
   Balance = Balance + Amount(I%)%@NL@%
NEXT I%%@NL@%
%@AB@%' Print the final balance:%@AE@%%@NL@%
PRINT%@NL@%
PRINT "--------------------------"%@NL@%
PRINT USING "Final Balance: $$######.##"; Balance%@NL@%
END%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CHRTASM.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\CHRTASM.ASM%@AE@%%@NL@%
%@NL@%
.MODEL medium%@NL@%
%@AB@%;********************************************************%@AE@%%@NL@%
%@AB@%;CHRTASM.ASM - assembly routines for the BASIC chart toolbox%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;  Copyright (C) 1989 Microsoft Corporation, All Rights Reserved%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   DefaultFont - provides the segment:offset address for%@AE@%%@NL@%
%@AB@%;                  the default font%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;********************************************************%@AE@%%@NL@%
%@NL@%
.FARDATA%@NL@%
_IBM8_def label byte%@NL@%
%@NL@%
      db   000h,000h,07Eh,00Ch,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,008h,000h,030h,000h%@NL@%
      db   060h,000h,007h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,090h,001h,000h,008h,000h%@NL@%
      db   008h,000h,000h,008h,000h,008h,000h,000h%@NL@%
      db   0FFh,02Eh,020h,0FFh,000h,000h,000h,000h%@NL@%
      db   000h,07Ah,004h,000h,000h,000h,000h,000h%@NL@%
      db   000h,07Eh,004h,000h,000h,000h,008h,000h%@NL@%
      db   07Eh,004h,008h,000h,086h,004h,008h,000h%@NL@%
      db   08Eh,004h,008h,000h,096h,004h,008h,000h%@NL@%
      db   09Eh,004h,008h,000h,0A6h,004h,008h,000h%@NL@%
      db   0AEh,004h,008h,000h,0B6h,004h,008h,000h%@NL@%
      db   0BEh,004h,008h,000h,0C6h,004h,008h,000h%@NL@%
      db   0CEh,004h,008h,000h,0D6h,004h,008h,000h%@NL@%
      db   0DEh,004h,008h,000h,0E6h,004h,008h,000h%@NL@%
      db   0EEh,004h,008h,000h,0F6h,004h,008h,000h%@NL@%
      db   0FEh,004h,008h,000h,006h,005h,008h,000h%@NL@%
      db   00Eh,005h,008h,000h,016h,005h,008h,000h%@NL@%
      db   01Eh,005h,008h,000h,026h,005h,008h,000h%@NL@%
      db   02Eh,005h,008h,000h,036h,005h,008h,000h%@NL@%
      db   03Eh,005h,008h,000h,046h,005h,008h,000h%@NL@%
      db   04Eh,005h,008h,000h,056h,005h,008h,000h%@NL@%
      db   05Eh,005h,008h,000h,066h,005h,008h,000h%@NL@%
      db   06Eh,005h,008h,000h,076h,005h,008h,000h%@NL@%
      db   07Eh,005h,008h,000h,086h,005h,008h,000h%@NL@%
      db   08Eh,005h,008h,000h,096h,005h,008h,000h%@NL@%
      db   09Eh,005h,008h,000h,0A6h,005h,008h,000h%@NL@%
      db   0AEh,005h,008h,000h,0B6h,005h,008h,000h%@NL@%
      db   0BEh,005h,008h,000h,0C6h,005h,008h,000h%@NL@%
      db   0CEh,005h,008h,000h,0D6h,005h,008h,000h%@NL@%
      db   0DEh,005h,008h,000h,0E6h,005h,008h,000h%@NL@%
      db   0EEh,005h,008h,000h,0F6h,005h,008h,000h%@NL@%
      db   0FEh,005h,008h,000h,006h,006h,008h,000h%@NL@%
      db   00Eh,006h,008h,000h,016h,006h,008h,000h%@NL@%
      db   01Eh,006h,008h,000h,026h,006h,008h,000h%@NL@%
      db   02Eh,006h,008h,000h,036h,006h,008h,000h%@NL@%
      db   03Eh,006h,008h,000h,046h,006h,008h,000h%@NL@%
      db   04Eh,006h,008h,000h,056h,006h,008h,000h%@NL@%
      db   05Eh,006h,008h,000h,066h,006h,008h,000h%@NL@%
      db   06Eh,006h,008h,000h,076h,006h,008h,000h%@NL@%
      db   07Eh,006h,008h,000h,086h,006h,008h,000h%@NL@%
      db   08Eh,006h,008h,000h,096h,006h,008h,000h%@NL@%
      db   09Eh,006h,008h,000h,0A6h,006h,008h,000h%@NL@%
      db   0AEh,006h,008h,000h,0B6h,006h,008h,000h%@NL@%
      db   0BEh,006h,008h,000h,0C6h,006h,008h,000h%@NL@%
      db   0CEh,006h,008h,000h,0D6h,006h,008h,000h%@NL@%
      db   0DEh,006h,008h,000h,0E6h,006h,008h,000h%@NL@%
      db   0EEh,006h,008h,000h,0F6h,006h,008h,000h%@NL@%
      db   0FEh,006h,008h,000h,006h,007h,008h,000h%@NL@%
      db   00Eh,007h,008h,000h,016h,007h,008h,000h%@NL@%
      db   01Eh,007h,008h,000h,026h,007h,008h,000h%@NL@%
      db   02Eh,007h,008h,000h,036h,007h,008h,000h%@NL@%
      db   03Eh,007h,008h,000h,046h,007h,008h,000h%@NL@%
      db   04Eh,007h,008h,000h,056h,007h,008h,000h%@NL@%
      db   05Eh,007h,008h,000h,066h,007h,008h,000h%@NL@%
      db   06Eh,007h,008h,000h,076h,007h,008h,000h%@NL@%
      db   07Eh,007h,008h,000h,086h,007h,008h,000h%@NL@%
      db   08Eh,007h,008h,000h,096h,007h,008h,000h%@NL@%
      db   09Eh,007h,008h,000h,0A6h,007h,008h,000h%@NL@%
      db   0AEh,007h,008h,000h,0B6h,007h,008h,000h%@NL@%
      db   0BEh,007h,008h,000h,0C6h,007h,008h,000h%@NL@%
      db   0CEh,007h,008h,000h,0D6h,007h,008h,000h%@NL@%
      db   0DEh,007h,008h,000h,0E6h,007h,008h,000h%@NL@%
      db   0EEh,007h,008h,000h,0F6h,007h,008h,000h%@NL@%
      db   0FEh,007h,008h,000h,006h,008h,008h,000h%@NL@%
      db   00Eh,008h,008h,000h,016h,008h,008h,000h%@NL@%
      db   01Eh,008h,008h,000h,026h,008h,008h,000h%@NL@%
      db   02Eh,008h,008h,000h,036h,008h,008h,000h%@NL@%
      db   03Eh,008h,008h,000h,046h,008h,008h,000h%@NL@%
      db   04Eh,008h,008h,000h,056h,008h,008h,000h%@NL@%
      db   05Eh,008h,008h,000h,066h,008h,008h,000h%@NL@%
      db   06Eh,008h,008h,000h,076h,008h,008h,000h%@NL@%
      db   07Eh,008h,008h,000h,086h,008h,008h,000h%@NL@%
      db   08Eh,008h,008h,000h,096h,008h,008h,000h%@NL@%
      db   09Eh,008h,008h,000h,0A6h,008h,008h,000h%@NL@%
      db   0AEh,008h,008h,000h,0B6h,008h,008h,000h%@NL@%
      db   0BEh,008h,008h,000h,0C6h,008h,008h,000h%@NL@%
      db   0CEh,008h,008h,000h,0D6h,008h,008h,000h%@NL@%
      db   0DEh,008h,008h,000h,0E6h,008h,008h,000h%@NL@%
      db   0EEh,008h,008h,000h,0F6h,008h,008h,000h%@NL@%
      db   0FEh,008h,008h,000h,006h,009h,008h,000h%@NL@%
      db   00Eh,009h,008h,000h,016h,009h,008h,000h%@NL@%
      db   01Eh,009h,008h,000h,026h,009h,008h,000h%@NL@%
      db   02Eh,009h,008h,000h,036h,009h,008h,000h%@NL@%
      db   03Eh,009h,008h,000h,046h,009h,008h,000h%@NL@%
      db   04Eh,009h,008h,000h,056h,009h,008h,000h%@NL@%
      db   05Eh,009h,008h,000h,066h,009h,008h,000h%@NL@%
      db   06Eh,009h,008h,000h,076h,009h,008h,000h%@NL@%
      db   07Eh,009h,008h,000h,086h,009h,008h,000h%@NL@%
      db   08Eh,009h,008h,000h,096h,009h,008h,000h%@NL@%
      db   09Eh,009h,008h,000h,0A6h,009h,008h,000h%@NL@%
      db   0AEh,009h,008h,000h,0B6h,009h,008h,000h%@NL@%
      db   0BEh,009h,008h,000h,0C6h,009h,008h,000h%@NL@%
      db   0CEh,009h,008h,000h,0D6h,009h,008h,000h%@NL@%
      db   0DEh,009h,008h,000h,0E6h,009h,008h,000h%@NL@%
      db   0EEh,009h,008h,000h,0F6h,009h,008h,000h%@NL@%
      db   0FEh,009h,008h,000h,006h,00Ah,008h,000h%@NL@%
      db   00Eh,00Ah,008h,000h,016h,00Ah,008h,000h%@NL@%
      db   01Eh,00Ah,008h,000h,026h,00Ah,008h,000h%@NL@%
      db   02Eh,00Ah,008h,000h,036h,00Ah,008h,000h%@NL@%
      db   03Eh,00Ah,008h,000h,046h,00Ah,008h,000h%@NL@%
      db   04Eh,00Ah,008h,000h,056h,00Ah,008h,000h%@NL@%
      db   05Eh,00Ah,008h,000h,066h,00Ah,008h,000h%@NL@%
      db   06Eh,00Ah,008h,000h,076h,00Ah,008h,000h%@NL@%
      db   07Eh,00Ah,008h,000h,086h,00Ah,008h,000h%@NL@%
      db   08Eh,00Ah,008h,000h,096h,00Ah,008h,000h%@NL@%
      db   09Eh,00Ah,008h,000h,0A6h,00Ah,008h,000h%@NL@%
      db   0AEh,00Ah,008h,000h,0B6h,00Ah,008h,000h%@NL@%
      db   0BEh,00Ah,008h,000h,0C6h,00Ah,008h,000h%@NL@%
      db   0CEh,00Ah,008h,000h,0D6h,00Ah,008h,000h%@NL@%
      db   0DEh,00Ah,008h,000h,0E6h,00Ah,008h,000h%@NL@%
      db   0EEh,00Ah,008h,000h,0F6h,00Ah,008h,000h%@NL@%
      db   0FEh,00Ah,008h,000h,006h,00Bh,008h,000h%@NL@%
      db   00Eh,00Bh,008h,000h,016h,00Bh,008h,000h%@NL@%
      db   01Eh,00Bh,008h,000h,026h,00Bh,008h,000h%@NL@%
      db   02Eh,00Bh,008h,000h,036h,00Bh,008h,000h%@NL@%
      db   03Eh,00Bh,008h,000h,046h,00Bh,008h,000h%@NL@%
      db   04Eh,00Bh,008h,000h,056h,00Bh,008h,000h%@NL@%
      db   05Eh,00Bh,008h,000h,066h,00Bh,008h,000h%@NL@%
      db   06Eh,00Bh,008h,000h,076h,00Bh,008h,000h%@NL@%
      db   07Eh,00Bh,008h,000h,086h,00Bh,008h,000h%@NL@%
      db   08Eh,00Bh,008h,000h,096h,00Bh,008h,000h%@NL@%
      db   09Eh,00Bh,008h,000h,0A6h,00Bh,008h,000h%@NL@%
      db   0AEh,00Bh,008h,000h,0B6h,00Bh,008h,000h%@NL@%
      db   0BEh,00Bh,008h,000h,0C6h,00Bh,008h,000h%@NL@%
      db   0CEh,00Bh,008h,000h,0D6h,00Bh,008h,000h%@NL@%
      db   0DEh,00Bh,008h,000h,0E6h,00Bh,008h,000h%@NL@%
      db   0EEh,00Bh,008h,000h,0F6h,00Bh,008h,000h%@NL@%
      db   0FEh,00Bh,008h,000h,006h,00Ch,008h,000h%@NL@%
      db   00Eh,00Ch,008h,000h,016h,00Ch,008h,000h%@NL@%
      db   01Eh,00Ch,008h,000h,026h,00Ch,008h,000h%@NL@%
      db   02Eh,00Ch,008h,000h,036h,00Ch,008h,000h%@NL@%
      db   03Eh,00Ch,008h,000h,046h,00Ch,008h,000h%@NL@%
      db   04Eh,00Ch,008h,000h,056h,00Ch,008h,000h%@NL@%
      db   05Eh,00Ch,008h,000h,066h,00Ch,008h,000h%@NL@%
      db   06Eh,00Ch,008h,000h,076h,00Ch,008h,000h%@NL@%
      db   07Eh,005h,049h,042h,04Dh,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,07Eh,081h%@NL@%
      db   0A5h,081h,0BDh,099h,081h,07Eh,07Eh,0FFh%@NL@%
      db   0DBh,0FFh,0C3h,0E7h,0FFh,07Eh,06Ch,0FEh%@NL@%
      db   0FEh,0FEh,07Ch,038h,010h,000h,010h,038h%@NL@%
      db   07Ch,0FEh,07Ch,038h,010h,000h,038h,07Ch%@NL@%
      db   038h,0FEh,0FEh,07Ch,038h,07Ch,010h,010h%@NL@%
      db   038h,07Ch,0FEh,07Ch,038h,07Ch,010h,010h%@NL@%
      db   038h,07Ch,0FEh,07Ch,038h,07Ch,0FFh,0FFh%@NL@%
      db   0E7h,0C3h,0C3h,0E7h,0FFh,0FFh,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,07Fh,063h%@NL@%
      db   07Fh,063h,063h,067h,0E6h,0C0h,099h,05Ah%@NL@%
      db   03Ch,0E7h,0E7h,03Ch,05Ah,099h,080h,0E0h%@NL@%
      db   0F8h,0FEh,0F8h,0E0h,080h,000h,002h,00Eh%@NL@%
      db   03Eh,0FEh,03Eh,00Eh,002h,000h,018h,03Ch%@NL@%
      db   07Eh,018h,018h,07Eh,03Ch,018h,066h,066h%@NL@%
      db   066h,066h,066h,000h,066h,000h,07Fh,0DBh%@NL@%
      db   0DBh,07Bh,01Bh,01Bh,01Bh,000h,03Eh,063h%@NL@%
      db   038h,06Ch,06Ch,038h,0CCh,078h,000h,000h%@NL@%
      db   000h,000h,07Eh,07Eh,07Eh,000h,018h,03Ch%@NL@%
      db   07Eh,018h,07Eh,03Ch,018h,0FFh,018h,03Ch%@NL@%
      db   07Eh,018h,018h,018h,018h,000h,018h,018h%@NL@%
      db   018h,018h,07Eh,03Ch,018h,000h,000h,018h%@NL@%
      db   00Ch,0FEh,00Ch,018h,000h,000h,000h,030h%@NL@%
      db   060h,0FEh,060h,030h,000h,000h,000h,030h%@NL@%
      db   060h,0FEh,060h,030h,000h,000h,000h,030h%@NL@%
      db   060h,0FEh,060h,030h,000h,000h,000h,030h%@NL@%
      db   060h,0FEh,060h,030h,000h,000h,000h,030h%@NL@%
      db   060h,0FEh,060h,030h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h,030h,078h%@NL@%
      db   078h,030h,030h,000h,030h,000h,06Ch,06Ch%@NL@%
      db   06Ch,000h,000h,000h,000h,000h,06Ch,06Ch%@NL@%
      db   0FEh,06Ch,0FEh,06Ch,06Ch,000h,030h,07Ch%@NL@%
      db   0C0h,078h,00Ch,0F8h,030h,000h,000h,0C6h%@NL@%
      db   0CCh,018h,030h,066h,0C6h,000h,038h,06Ch%@NL@%
      db   038h,076h,0DCh,0CCh,076h,000h,060h,060h%@NL@%
      db   0C0h,000h,000h,000h,000h,000h,018h,030h%@NL@%
      db   060h,060h,060h,030h,018h,000h,060h,030h%@NL@%
      db   018h,018h,018h,030h,060h,000h,000h,066h%@NL@%
      db   03Ch,0FFh,03Ch,066h,000h,000h,000h,030h%@NL@%
      db   030h,0FCh,030h,030h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,030h,030h,060h,000h,000h%@NL@%
      db   000h,0FCh,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,030h,030h,000h,006h,00Ch%@NL@%
      db   018h,030h,060h,0C0h,080h,000h,07Ch,0C6h%@NL@%
      db   0CEh,0DEh,0F6h,0E6h,07Ch,000h,030h,070h%@NL@%
      db   030h,030h,030h,030h,0FCh,000h,078h,0CCh%@NL@%
      db   00Ch,038h,060h,0CCh,0FCh,000h,078h,0CCh%@NL@%
      db   00Ch,038h,00Ch,0CCh,078h,000h,01Ch,03Ch%@NL@%
      db   06Ch,0CCh,0FEh,00Ch,01Eh,000h,0FCh,0C0h%@NL@%
      db   0F8h,00Ch,00Ch,0CCh,078h,000h,038h,060h%@NL@%
      db   0C0h,0F8h,0CCh,0CCh,078h,000h,0FCh,0CCh%@NL@%
      db   00Ch,018h,030h,030h,030h,000h,078h,0CCh%@NL@%
      db   0CCh,078h,0CCh,0CCh,078h,000h,078h,0CCh%@NL@%
      db   0CCh,07Ch,00Ch,018h,070h,000h,000h,030h%@NL@%
      db   030h,000h,000h,030h,030h,000h,000h,030h%@NL@%
      db   030h,000h,000h,030h,030h,060h,018h,030h%@NL@%
      db   060h,0C0h,060h,030h,018h,000h,000h,000h%@NL@%
      db   0FCh,000h,000h,0FCh,000h,000h,060h,030h%@NL@%
      db   018h,00Ch,018h,030h,060h,000h,078h,0CCh%@NL@%
      db   00Ch,018h,030h,000h,030h,000h,07Ch,0C6h%@NL@%
      db   0DEh,0DEh,0DEh,0C0h,078h,000h,030h,078h%@NL@%
      db   0CCh,0CCh,0FCh,0CCh,0CCh,000h,0FCh,066h%@NL@%
      db   066h,07Ch,066h,066h,0FCh,000h,03Ch,066h%@NL@%
      db   0C0h,0C0h,0C0h,066h,03Ch,000h,0F8h,06Ch%@NL@%
      db   066h,066h,066h,06Ch,0F8h,000h,0FEh,062h%@NL@%
      db   068h,078h,068h,062h,0FEh,000h,0FEh,062h%@NL@%
      db   068h,078h,068h,060h,0F0h,000h,03Ch,066h%@NL@%
      db   0C0h,0C0h,0CEh,066h,03Eh,000h,0CCh,0CCh%@NL@%
      db   0CCh,0FCh,0CCh,0CCh,0CCh,000h,078h,030h%@NL@%
      db   030h,030h,030h,030h,078h,000h,01Eh,00Ch%@NL@%
      db   00Ch,00Ch,0CCh,0CCh,078h,000h,0E6h,066h%@NL@%
      db   06Ch,078h,06Ch,066h,0E6h,000h,0F0h,060h%@NL@%
      db   060h,060h,062h,066h,0FEh,000h,0C6h,0EEh%@NL@%
      db   0FEh,0FEh,0D6h,0C6h,0C6h,000h,0C6h,0E6h%@NL@%
      db   0F6h,0DEh,0CEh,0C6h,0C6h,000h,038h,06Ch%@NL@%
      db   0C6h,0C6h,0C6h,06Ch,038h,000h,0FCh,066h%@NL@%
      db   066h,07Ch,060h,060h,0F0h,000h,078h,0CCh%@NL@%
      db   0CCh,0CCh,0DCh,078h,01Ch,000h,0FCh,066h%@NL@%
      db   066h,07Ch,06Ch,066h,0E6h,000h,078h,0CCh%@NL@%
      db   0E0h,070h,01Ch,0CCh,078h,000h,0FCh,0B4h%@NL@%
      db   030h,030h,030h,030h,078h,000h,0CCh,0CCh%@NL@%
      db   0CCh,0CCh,0CCh,0CCh,0FCh,000h,0CCh,0CCh%@NL@%
      db   0CCh,0CCh,0CCh,078h,030h,000h,0C6h,0C6h%@NL@%
      db   0C6h,0D6h,0FEh,0EEh,0C6h,000h,0C6h,0C6h%@NL@%
      db   06Ch,038h,038h,06Ch,0C6h,000h,0CCh,0CCh%@NL@%
      db   0CCh,078h,030h,030h,078h,000h,0FEh,0C6h%@NL@%
      db   08Ch,018h,032h,066h,0FEh,000h,078h,060h%@NL@%
      db   060h,060h,060h,060h,078h,000h,0C0h,060h%@NL@%
      db   030h,018h,00Ch,006h,002h,000h,078h,018h%@NL@%
      db   018h,018h,018h,018h,078h,000h,010h,038h%@NL@%
      db   06Ch,0C6h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,0FFh,030h,030h%@NL@%
      db   018h,000h,000h,000h,000h,000h,000h,000h%@NL@%
      db   078h,00Ch,07Ch,0CCh,076h,000h,0E0h,060h%@NL@%
      db   060h,07Ch,066h,066h,0DCh,000h,000h,000h%@NL@%
      db   078h,0CCh,0C0h,0CCh,078h,000h,01Ch,00Ch%@NL@%
      db   00Ch,07Ch,0CCh,0CCh,076h,000h,000h,000h%@NL@%
      db   078h,0CCh,0FCh,0C0h,078h,000h,038h,06Ch%@NL@%
      db   060h,0F0h,060h,060h,0F0h,000h,000h,000h%@NL@%
      db   076h,0CCh,0CCh,07Ch,00Ch,0F8h,0E0h,060h%@NL@%
      db   06Ch,076h,066h,066h,0E6h,000h,030h,000h%@NL@%
      db   070h,030h,030h,030h,078h,000h,00Ch,000h%@NL@%
      db   00Ch,00Ch,00Ch,0CCh,0CCh,078h,0E0h,060h%@NL@%
      db   066h,06Ch,078h,06Ch,0E6h,000h,070h,030h%@NL@%
      db   030h,030h,030h,030h,078h,000h,000h,000h%@NL@%
      db   0CCh,0FEh,0FEh,0D6h,0C6h,000h,000h,000h%@NL@%
      db   0F8h,0CCh,0CCh,0CCh,0CCh,000h,000h,000h%@NL@%
      db   078h,0CCh,0CCh,0CCh,078h,000h,000h,000h%@NL@%
      db   0DCh,066h,066h,07Ch,060h,0F0h,000h,000h%@NL@%
      db   076h,0CCh,0CCh,07Ch,00Ch,01Eh,000h,000h%@NL@%
      db   0DCh,076h,066h,060h,0F0h,000h,000h,000h%@NL@%
      db   07Ch,0C0h,078h,00Ch,0F8h,000h,010h,030h%@NL@%
      db   07Ch,030h,030h,034h,018h,000h,000h,000h%@NL@%
      db   0CCh,0CCh,0CCh,0CCh,076h,000h,000h,000h%@NL@%
      db   0CCh,0CCh,0CCh,078h,030h,000h,000h,000h%@NL@%
      db   0C6h,0D6h,0FEh,0FEh,06Ch,000h,000h,000h%@NL@%
      db   0C6h,06Ch,038h,06Ch,0C6h,000h,000h,000h%@NL@%
      db   0CCh,0CCh,0CCh,07Ch,00Ch,0F8h,000h,000h%@NL@%
      db   0FCh,098h,030h,064h,0FCh,000h,01Ch,030h%@NL@%
      db   030h,0E0h,030h,030h,01Ch,000h,018h,018h%@NL@%
      db   018h,000h,018h,018h,018h,000h,0E0h,030h%@NL@%
      db   030h,01Ch,030h,030h,0E0h,000h,076h,0DCh%@NL@%
      db   000h,000h,000h,000h,000h,000h,000h,010h%@NL@%
      db   038h,06Ch,0C6h,0C6h,0FEh,000h,078h,0CCh%@NL@%
      db   0C0h,0CCh,078h,018h,00Ch,078h,000h,0CCh%@NL@%
      db   000h,0CCh,0CCh,0CCh,07Eh,000h,01Ch,000h%@NL@%
      db   078h,0CCh,0FCh,0C0h,078h,000h,07Eh,0C3h%@NL@%
      db   03Ch,006h,03Eh,066h,03Fh,000h,0CCh,000h%@NL@%
      db   078h,00Ch,07Ch,0CCh,07Eh,000h,0E0h,000h%@NL@%
      db   078h,00Ch,07Ch,0CCh,07Eh,000h,030h,030h%@NL@%
      db   078h,00Ch,07Ch,0CCh,07Eh,000h,000h,000h%@NL@%
      db   078h,0C0h,0C0h,078h,00Ch,038h,07Eh,0C3h%@NL@%
      db   03Ch,066h,07Eh,060h,03Ch,000h,0CCh,000h%@NL@%
      db   078h,0CCh,0FCh,0C0h,078h,000h,0E0h,000h%@NL@%
      db   078h,0CCh,0FCh,0C0h,078h,000h,0CCh,000h%@NL@%
      db   070h,030h,030h,030h,078h,000h,07Ch,0C6h%@NL@%
      db   038h,018h,018h,018h,03Ch,000h,0E0h,000h%@NL@%
      db   070h,030h,030h,030h,078h,000h,0C6h,038h%@NL@%
      db   06Ch,0C6h,0FEh,0C6h,0C6h,000h,030h,030h%@NL@%
      db   000h,078h,0CCh,0FCh,0CCh,000h,01Ch,000h%@NL@%
      db   0FCh,060h,078h,060h,0FCh,000h,000h,000h%@NL@%
      db   07Fh,00Ch,07Fh,0CCh,07Fh,000h,03Eh,06Ch%@NL@%
      db   0CCh,0FEh,0CCh,0CCh,0CEh,000h,078h,0CCh%@NL@%
      db   000h,078h,0CCh,0CCh,078h,000h,000h,0CCh%@NL@%
      db   000h,078h,0CCh,0CCh,078h,000h,000h,0E0h%@NL@%
      db   000h,078h,0CCh,0CCh,078h,000h,078h,0CCh%@NL@%
      db   000h,0CCh,0CCh,0CCh,07Eh,000h,000h,0E0h%@NL@%
      db   000h,0CCh,0CCh,0CCh,07Eh,000h,000h,0CCh%@NL@%
      db   000h,0CCh,0CCh,07Ch,00Ch,0F8h,0C3h,018h%@NL@%
      db   03Ch,066h,066h,03Ch,018h,000h,0CCh,000h%@NL@%
      db   0CCh,0CCh,0CCh,0CCh,078h,000h,018h,018h%@NL@%
      db   07Eh,0C0h,0C0h,07Eh,018h,018h,038h,06Ch%@NL@%
      db   064h,0F0h,060h,0E6h,0FCh,000h,0CCh,0CCh%@NL@%
      db   078h,0FCh,030h,0FCh,030h,030h,0F8h,0CCh%@NL@%
      db   0CCh,0FAh,0C6h,0CFh,0C6h,0C7h,00Eh,01Bh%@NL@%
      db   018h,03Ch,018h,018h,0D8h,070h,01Ch,000h%@NL@%
      db   078h,00Ch,07Ch,0CCh,07Eh,000h,038h,000h%@NL@%
      db   070h,030h,030h,030h,078h,000h,000h,01Ch%@NL@%
      db   000h,078h,0CCh,0CCh,078h,000h,000h,01Ch%@NL@%
      db   000h,0CCh,0CCh,0CCh,07Eh,000h,000h,0F8h%@NL@%
      db   000h,0F8h,0CCh,0CCh,0CCh,000h,0FCh,000h%@NL@%
      db   0CCh,0ECh,0FCh,0DCh,0CCh,000h,03Ch,06Ch%@NL@%
      db   06Ch,03Eh,000h,07Eh,000h,000h,038h,06Ch%@NL@%
      db   06Ch,038h,000h,07Ch,000h,000h,030h,000h%@NL@%
      db   030h,060h,0C0h,0CCh,078h,000h,000h,000h%@NL@%
      db   000h,0FCh,0C0h,0C0h,000h,000h,000h,000h%@NL@%
      db   000h,0FCh,00Ch,00Ch,000h,000h,0C3h,0C6h%@NL@%
      db   0CCh,0DEh,033h,066h,0CCh,00Fh,0C3h,0C6h%@NL@%
      db   0CCh,0DBh,037h,06Fh,0CFh,003h,018h,018h%@NL@%
      db   000h,018h,018h,018h,018h,000h,000h,033h%@NL@%
      db   066h,0CCh,066h,033h,000h,000h,000h,0CCh%@NL@%
      db   066h,033h,066h,0CCh,000h,000h,022h,088h%@NL@%
      db   022h,088h,022h,088h,022h,088h,055h,0AAh%@NL@%
      db   055h,0AAh,055h,0AAh,055h,0AAh,0DBh,077h%@NL@%
      db   0DBh,0EEh,0DBh,077h,0DBh,0EEh,018h,018h%@NL@%
      db   018h,018h,018h,018h,018h,018h,018h,018h%@NL@%
      db   018h,018h,0F8h,018h,018h,018h,018h,018h%@NL@%
      db   0F8h,018h,0F8h,018h,018h,018h,036h,036h%@NL@%
      db   036h,036h,0F6h,036h,036h,036h,000h,000h%@NL@%
      db   000h,000h,0FEh,036h,036h,036h,000h,000h%@NL@%
      db   0F8h,018h,0F8h,018h,018h,018h,036h,036h%@NL@%
      db   0F6h,006h,0F6h,036h,036h,036h,036h,036h%@NL@%
      db   036h,036h,036h,036h,036h,036h,000h,000h%@NL@%
      db   0FEh,006h,0F6h,036h,036h,036h,036h,036h%@NL@%
      db   0F6h,006h,0FEh,000h,000h,000h,036h,036h%@NL@%
      db   036h,036h,0FEh,000h,000h,000h,018h,018h%@NL@%
      db   0F8h,018h,0F8h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,0F8h,018h,018h,018h,018h,018h%@NL@%
      db   018h,018h,01Fh,000h,000h,000h,018h,018h%@NL@%
      db   018h,018h,0FFh,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,0FFh,018h,018h,018h,018h,018h%@NL@%
      db   018h,018h,01Fh,018h,018h,018h,000h,000h%@NL@%
      db   000h,000h,0FFh,000h,000h,000h,018h,018h%@NL@%
      db   018h,018h,0FFh,018h,018h,018h,018h,018h%@NL@%
      db   01Fh,018h,01Fh,018h,018h,018h,036h,036h%@NL@%
      db   036h,036h,037h,036h,036h,036h,036h,036h%@NL@%
      db   037h,030h,03Fh,000h,000h,000h,000h,000h%@NL@%
      db   03Fh,030h,037h,036h,036h,036h,036h,036h%@NL@%
      db   0F7h,000h,0FFh,000h,000h,000h,000h,000h%@NL@%
      db   0FFh,000h,0F7h,036h,036h,036h,036h,036h%@NL@%
      db   037h,030h,037h,036h,036h,036h,000h,000h%@NL@%
      db   0FFh,000h,0FFh,000h,000h,000h,036h,036h%@NL@%
      db   0F7h,000h,0F7h,036h,036h,036h,018h,018h%@NL@%
      db   0FFh,000h,0FFh,000h,000h,000h,036h,036h%@NL@%
      db   036h,036h,0FFh,000h,000h,000h,000h,000h%@NL@%
      db   0FFh,000h,0FFh,018h,018h,018h,000h,000h%@NL@%
      db   000h,000h,0FFh,036h,036h,036h,036h,036h%@NL@%
      db   036h,036h,03Fh,000h,000h,000h,018h,018h%@NL@%
      db   01Fh,018h,01Fh,000h,000h,000h,000h,000h%@NL@%
      db   01Fh,018h,01Fh,018h,018h,018h,000h,000h%@NL@%
      db   000h,000h,03Fh,036h,036h,036h,036h,036h%@NL@%
      db   036h,036h,0FFh,036h,036h,036h,018h,018h%@NL@%
      db   0FFh,018h,0FFh,018h,018h,018h,018h,018h%@NL@%
      db   018h,018h,0F8h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,01Fh,018h,018h,018h,0FFh,0FFh%@NL@%
      db   0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,000h,000h%@NL@%
      db   000h,000h,0FFh,0FFh,0FFh,0FFh,0F0h,0F0h%@NL@%
      db   0F0h,0F0h,0F0h,0F0h,0F0h,0F0h,00Fh,00Fh%@NL@%
      db   00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,0FFh,0FFh%@NL@%
      db   0FFh,0FFh,000h,000h,000h,000h,000h,000h%@NL@%
      db   076h,0DCh,0C8h,0DCh,076h,000h,000h,078h%@NL@%
      db   0CCh,0F8h,0CCh,0F8h,0C0h,0C0h,000h,0FCh%@NL@%
      db   0CCh,0C0h,0C0h,0C0h,0C0h,000h,000h,0FEh%@NL@%
      db   06Ch,06Ch,06Ch,06Ch,06Ch,000h,0FCh,0CCh%@NL@%
      db   060h,030h,060h,0CCh,0FCh,000h,000h,000h%@NL@%
      db   07Eh,0D8h,0D8h,0D8h,070h,000h,000h,066h%@NL@%
      db   066h,066h,066h,07Ch,060h,0C0h,000h,076h%@NL@%
      db   0DCh,018h,018h,018h,018h,000h,0FCh,030h%@NL@%
      db   078h,0CCh,0CCh,078h,030h,0FCh,038h,06Ch%@NL@%
      db   0C6h,0FEh,0C6h,06Ch,038h,000h,038h,06Ch%@NL@%
      db   0C6h,0C6h,06Ch,06Ch,0EEh,000h,01Ch,030h%@NL@%
      db   018h,07Ch,0CCh,0CCh,078h,000h,000h,000h%@NL@%
      db   07Eh,0DBh,0DBh,07Eh,000h,000h,006h,00Ch%@NL@%
      db   07Eh,0DBh,0DBh,07Eh,060h,0C0h,038h,060h%@NL@%
      db   0C0h,0F8h,0C0h,060h,038h,000h,078h,0CCh%@NL@%
      db   0CCh,0CCh,0CCh,0CCh,0CCh,000h,000h,0FCh%@NL@%
      db   000h,0FCh,000h,0FCh,000h,000h,030h,030h%@NL@%
      db   0FCh,030h,030h,000h,0FCh,000h,060h,030h%@NL@%
      db   018h,030h,060h,000h,0FCh,000h,018h,030h%@NL@%
      db   060h,030h,018h,000h,0FCh,000h,00Eh,01Bh%@NL@%
      db   01Bh,018h,018h,018h,018h,018h,018h,018h%@NL@%
      db   018h,018h,018h,0D8h,0D8h,070h,030h,030h%@NL@%
      db   000h,0FCh,000h,030h,030h,000h,000h,076h%@NL@%
      db   0DCh,000h,076h,0DCh,000h,000h,038h,06Ch%@NL@%
      db   06Ch,038h,000h,000h,000h,000h,000h,000h%@NL@%
      db   000h,018h,018h,000h,000h,000h,000h,000h%@NL@%
      db   000h,000h,018h,000h,000h,000h,00Fh,00Ch%@NL@%
      db   00Ch,00Ch,0ECh,06Ch,03Ch,01Ch,078h,06Ch%@NL@%
      db   06Ch,06Ch,06Ch,000h,000h,000h,070h,018h%@NL@%
      db   030h,060h,078h,000h,000h,000h,000h,000h%@NL@%
      db   03Ch,03Ch,03Ch,03Ch,000h,000h,000h,000h%@NL@%
      db   000h,000h,000h,000h,000h,000h%@NL@%
%@NL@%
%@AB@%;=====End of Font%@AE@%%@NL@%
%@NL@%
.CODE%@NL@%
%@NL@%
%@AB@%;********************************************************%@AE@%%@NL@%
%@AB@%;DefaultFont - Returns the Segment:Offset address of the%@AE@%%@NL@%
%@AB@%;               default font%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; DefaultFont Segment%, Offset%%@AE@%%@NL@%
%@NL@%
PUBLIC DefaultFont%@NL@%
DefaultFont PROC%@NL@%
   push  bp%@NL@%
   mov   bp,sp%@NL@%
%@NL@%
   les         bx,[bp+10]                %@AB@%;put address of first arg in es:si%@AE@%%@NL@%
   mov         es:[bx],SEG _IBM8_def        %@AB@%;move segment address to first arg of call%@AE@%%@NL@%
%@NL@%
   les         bx,[bp+6]                %@AB@%;repeat above for offset address of font%@AE@%%@NL@%
   mov         word ptr es:[bx],OFFSET _IBM8_def%@NL@%
%@NL@%
   pop   bp%@NL@%
   ret   8%@NL@%
DefaultFont ENDP%@NL@%
%@NL@%
      END%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CHRTB.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\CHRTB.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'*** CHRTB.BAS - Chart Routines for the Presentation Graphics Toolbox in%@AE@%%@NL@%
%@AB@%'           Microsoft BASIC 7.0, Professional Development System%@AE@%%@NL@%
%@AB@%'              Copyright (C) 1987-1989, Microsoft Corporation%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  NOTE:  This sample source code toolbox is intended to demonstrate some%@AE@%%@NL@%
%@AB@%'  of the extended capabilities of Microsoft BASIC 7.0 Professional Development%@AE@%%@NL@%
%@AB@%'  system that can help to leverage the professional developer's time more%@AE@%%@NL@%
%@AB@%'  effectively.  While you are free to use, modify, or distribute the routines%@AE@%%@NL@%
%@AB@%'  in this module in any way you find useful, it should be noted that these are%@AE@%%@NL@%
%@AB@%'  examples only and should not be relied upon as a fully-tested "add-on"%@AE@%%@NL@%
%@AB@%'  library.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  PURPOSE: This file contains the BASIC source code for the Presentation%@AE@%%@NL@%
%@AB@%'           Graphics Toolbox Chart Routines.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  To create a library and QuickLib containing the charting routines found%@AE@%%@NL@%
%@AB@%'  in this file, follow these steps:%@AE@%%@NL@%
%@AB@%'       BC /X/FS chrtb.bas%@AE@%%@NL@%
%@AB@%'       LIB chrtb.lib + chrtb + chrtasm + qbx.lib;%@AE@%%@NL@%
%@AB@%'       LINK /Q chrtb.lib, chrtb.qlb,,qbxqlb.lib;%@AE@%%@NL@%
%@AB@%'  If you are going to use this CHRTB.QLB QuickLib in conjunction with%@AE@%%@NL@%
%@AB@%'  the font source code (FONTB.BAS) or the UI toobox source code%@AE@%%@NL@%
%@AB@%'  (GENERAL.BAS, WINDOW.BAS, MENU.BAS and MOUSE.BAS), you need to%@AE@%%@NL@%
%@AB@%'  include the assembly code routines referenced in these files.  For the%@AE@%%@NL@%
%@AB@%'  font routines, create CHRTB.LIB as follows before you create the%@AE@%%@NL@%
%@AB@%'  QuickLib:%@AE@%%@NL@%
%@AB@%'       LIB chrtb.lib + chrtb + chrtasm + fontasm + qbx.lib;%@AE@%%@NL@%
%@AB@%'  For the UI toolbox routines, create the library as follows:%@AE@%%@NL@%
%@AB@%'       LIB chrtb.lib + chrtb + chrtasm + uiasm + qbx.lib;%@AE@%%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
%@NL@%
%@AB@%' Constants:%@AE@%%@NL@%
%@NL@%
CONST cTicSize = .02            ' Percent of axis length to use for tic length%@NL@%
CONST cMaxChars = 255           ' Maximum ASCII value allowed for character%@NL@%
CONST cBarWid = .8              ' Percent of category width to use for bar%@NL@%
CONST cPiVal = 3.141592         ' A value for PI%@NL@%
CONST cFalse = 0                ' Logical false%@NL@%
CONST cTrue = NOT cFalse        ' Logical true%@NL@%
%@NL@%
%@AB@%' CHRTB.BI contains all of the TYPE definitions and SUB declarations%@AE@%%@NL@%
%@AB@%' that are accessible to the library user as well as CONST definitions for%@AE@%%@NL@%
%@AB@%' some routine parameters and error messages:%@AE@%%@NL@%
%@NL@%
%@AB@%'$INCLUDE: 'CHRTB.BI'%@AE@%%@NL@%
%@NL@%
%@AB@%' FONTB.BI contains all of the TYPE definitions and SUB declarations%@AE@%%@NL@%
%@AB@%' required for graphics text:%@AE@%%@NL@%
%@NL@%
%@AB@%'$INCLUDE: 'FONTB.BI'%@AE@%%@NL@%
%@NL@%
%@AB@%' Below are TYPE definitions local to this module:%@AE@%%@NL@%
%@NL@%
%@AB@%' TYPE for recording information on title spacing:%@AE@%%@NL@%
TYPE TitleLayout%@NL@%
        Top         AS INTEGER        ' Space above first title%@NL@%
        TitleOne    AS INTEGER        ' Height of first title%@NL@%
        Middle      AS INTEGER        ' Space between first and second titles%@NL@%
        TitleTwo    AS INTEGER        ' Height of second title%@NL@%
        Bottom      AS INTEGER        ' Space below second title%@NL@%
        TotalSize   AS INTEGER        ' Sum of all the above%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' TYPE for recording information on the legend layout:%@AE@%%@NL@%
TYPE LegendLayout%@NL@%
        NumCol      AS INTEGER        ' Number of columns in legend%@NL@%
        NumRow      AS INTEGER        ' Number of rows in legend%@NL@%
        SymbolSize  AS INTEGER        ' Height of symbol%@NL@%
        LabelOffset AS INTEGER        ' Space between start of symbol and label%@NL@%
        RowSpacing  AS INTEGER        ' Space between tops of rows%@NL@%
        ColSpacing  AS INTEGER        ' Spacing between beginnings of columns%@NL@%
        HorizBorder AS INTEGER        ' Top and bottom border%@NL@%
        VertBorder  AS INTEGER        ' Left and right border%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' TYPE for a group of global parameters:%@AE@%%@NL@%
TYPE GlobalParams%@NL@%
        SysFlag     AS INTEGER        ' cYes means Analyze call is from system%@NL@%
        Initialized AS INTEGER        ' cYes means clInitChart has been called%@NL@%
%@NL@%
        PaletteScrn AS INTEGER        ' Screen mode for which palette is set%@NL@%
        PaletteBits AS INTEGER        ' Bits per pixel for current screen mode%@NL@%
        PaletteSet  AS INTEGER        ' cYes means palette has been initialized%@NL@%
        White       AS INTEGER        ' White attribute in current screen mode%@NL@%
%@NL@%
        Aspect      AS SINGLE         ' Current screen aspect%@NL@%
        MaxXPix     AS INTEGER        ' Screen size along X axis%@NL@%
        MaxYPix     AS INTEGER        ' Screen size along Y axis%@NL@%
        MaxColor    AS INTEGER        ' Maximum color number for current screen%@NL@%
%@NL@%
        ChartWid    AS INTEGER        ' Width of chart window%@NL@%
        ChartHgt    AS INTEGER        ' Height of chart window%@NL@%
        CwX1        AS INTEGER        ' Left side of chart window%@NL@%
        CwY1        AS INTEGER        ' Top edge of chart window%@NL@%
        CwX2        AS INTEGER        ' Right side of chart window%@NL@%
        CwY2        AS INTEGER        ' Bottom edge of chart window%@NL@%
%@NL@%
        XStagger    AS INTEGER        ' Boolean, true if category labels overflow%@NL@%
        ValLenX     AS INTEGER        ' Maximum length of value labels on X-axis%@NL@%
        ValLenY     AS INTEGER        ' Maximum length of value labels on Y-axis%@NL@%
%@NL@%
        NVals       AS INTEGER        ' Number of data values in data series%@NL@%
        NSeries     AS INTEGER        ' Number of series of data%@NL@%
        MSeries     AS INTEGER        ' If multiple-series chart then cYes, else%@NL@%
%@AB@%                                                                                        ' cNo%@AE@%%@NL@%
        XMode       AS INTEGER        ' Axis mode of x axis%@NL@%
        YMode       AS INTEGER        ' Axis mode of y axis%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' FUNCTION and SUB declarations for procedures local to this module:%@AE@%%@NL@%
%@NL@%
DECLARE FUNCTION clBuildBitP$ (Bits%, C%, InP$)%@NL@%
DECLARE FUNCTION clBuildPlaneP$ (Bits%, C%, InP$)%@NL@%
DECLARE FUNCTION clColorMaskL% (Bits%, Colr%)%@NL@%
DECLARE FUNCTION clGetStyle% (StyleNum%)%@NL@%
DECLARE FUNCTION clMaxVal (A, B)%@NL@%
DECLARE FUNCTION clMap2Pal% (N%)%@NL@%
DECLARE FUNCTION clMap2Attrib% (N%)%@NL@%
DECLARE FUNCTION clMaxStrLen% (Txt$(), First%, Last%)%@NL@%
DECLARE FUNCTION clVal2Str$ (X, Places%, Format%)%@NL@%
%@NL@%
DECLARE SUB clAdjustScale (Axis AS AxisType)%@NL@%
DECLARE SUB clAnalyzeC (Cat$(), N%, SLabels$(), First%, Last%)%@NL@%
DECLARE SUB clAnalyzeS (N%, SLabels$(), First%, Last%)%@NL@%
DECLARE SUB clBuildPalette (ScrnMode%, Bits%)%@NL@%
DECLARE SUB clChkInit ()%@NL@%
DECLARE SUB clChkFonts ()%@NL@%
DECLARE SUB clChkForErrors (Env AS ChartEnvironment, TypeMin%, TypeMax%, N%, First%, Last%)%@NL@%
DECLARE SUB clChkChartWindow (Env AS ChartEnvironment)%@NL@%
DECLARE SUB clChkPalettes (C%(), s%(), P$(), Char%(), B%())%@NL@%
DECLARE SUB clClearError ()%@NL@%
DECLARE SUB clColorMaskH (Bits%, Colr%, CMask%())%@NL@%
DECLARE SUB clDrawAxes (Cat$())%@NL@%
DECLARE SUB clDrawDataWindow ()%@NL@%
DECLARE SUB clDrawChartWindow ()%@NL@%
DECLARE SUB clDrawTitles ()%@NL@%
DECLARE SUB clDrawLegend (SeriesLabel$(), First AS INTEGER, Last AS INTEGER)%@NL@%
DECLARE SUB clDrawBarData ()%@NL@%
DECLARE SUB clDrawColumnData ()%@NL@%
DECLARE SUB clDrawLineData ()%@NL@%
DECLARE SUB clDrawPieData (value(), Expl%(), N%)%@NL@%
DECLARE SUB clDrawScatterData ()%@NL@%
DECLARE SUB clFilter (A AS AxisType, AxisMode%, D1(), D2(), N%)%@NL@%
DECLARE SUB clFilterMS (A AS AxisType, AxisMode%, D1(), D2(), N%, First%, Last%)%@NL@%
DECLARE SUB clFlagSystem ()%@NL@%
DECLARE SUB clFormatTics (A AS AxisType)%@NL@%
DECLARE SUB clHPrint (X%, Y%, Txt$)%@NL@%
DECLARE SUB clInitChart ()%@NL@%
DECLARE SUB clInitStdStruc ()%@NL@%
DECLARE SUB clLabelXTics (Axis AS AxisType, Cat$(), TicX, TicTotX%, TicY, YBoundry%)%@NL@%
DECLARE SUB clLabelYTics (Axis AS AxisType, Cat$(), TicX, TicY, TicTotY%)%@NL@%
DECLARE SUB clLayoutTitle (TL AS ANY, T1 AS ANY, T2 AS ANY)%@NL@%
DECLARE SUB clPrintTitle (TitleVar AS TitleType, Y%)%@NL@%
DECLARE SUB clRenderBar (X1, Y1, X2, Y2, C%)%@NL@%
DECLARE SUB clRenderWindow (W AS RegionType)%@NL@%
DECLARE SUB clScaleAxis (A AS AxisType, AxisMode%, D1())%@NL@%
DECLARE SUB clSelectChartWindow ()%@NL@%
DECLARE SUB clSelectRelWindow (W AS RegionType)%@NL@%
DECLARE SUB clSetAxisModes ()%@NL@%
DECLARE SUB clSetChartFont (N AS INTEGER)%@NL@%
DECLARE SUB clSetError (ErrNo AS INTEGER)%@NL@%
DECLARE SUB clSetCharColor (N%)%@NL@%
DECLARE SUB clSetGlobalParams ()%@NL@%
DECLARE SUB clSizeDataWindow (Cat$())%@NL@%
DECLARE SUB clLayoutLegend (SeriesLabel$(), First%, Last%)%@NL@%
DECLARE SUB clSpaceTics ()%@NL@%
DECLARE SUB clSpaceTicsA (A AS AxisType, AxisMode%, AxisLen%, TicWid%)%@NL@%
DECLARE SUB clTitleXAxis (A AS AxisType, X1%, X2%, YBoundry%)%@NL@%
DECLARE SUB clTitleYAxis (A AS AxisType, Y1%, Y2%)%@NL@%
DECLARE SUB clUnFlagSystem ()%@NL@%
DECLARE SUB clVPrint (X%, Y%, Txt$)%@NL@%
%@NL@%
%@NL@%
%@AB@%' Variable definitions local to this module:%@AE@%%@NL@%
%@NL@%
DIM PaletteC%(0 TO cPalLen)            ' List of colors     for drawing data%@NL@%
DIM PaletteS%(0 TO cPalLen)            ' List of styles     for drawing data%@NL@%
DIM PaletteP$(0 TO cPalLen)            ' List of patterns   for drawing data%@NL@%
DIM PaletteCh%(0 TO cPalLen)           ' List of plot chars for drawing data%@NL@%
DIM PaletteB%(0 TO cPalLen)            ' List of patterns   for borders%@NL@%
%@NL@%
DIM StdChars%(0 TO cPalLen)            ' Holds default plot characters%@NL@%
%@NL@%
DIM DAxis         AS AxisType          ' Default axis settings%@NL@%
DIM DWindow       AS RegionType        ' Default window settings%@NL@%
DIM DLegend       AS LegendType        ' Default legend settings%@NL@%
DIM DTitle        AS TitleType         ' Default title settings%@NL@%
%@NL@%
DIM XTitleLayout  AS TitleLayout       ' X-axis layout information%@NL@%
DIM YTitleLayout  AS TitleLayout       ' Y-axis layout information%@NL@%
DIM TTitleLayout  AS TitleLayout       ' Main/Sub layout information%@NL@%
%@NL@%
DIM LLayout       AS LegendLayout      ' Legend layout information%@NL@%
%@NL@%
DIM GFI           AS FontInfo          ' Global font information%@NL@%
DIM GE            AS ChartEnvironment  ' An internal global chart environment%@NL@%
DIM GP            AS GlobalParams      ' Holds a number of global parameters%@NL@%
%@AB@%                                                                                                        ' used in the charting routines.  See%@AE@%%@NL@%
%@AB@%                                                                                                        ' TYPE definition for details.%@AE@%%@NL@%
%@NL@%
%@AB@%'$DYNAMIC%@AE@%%@NL@%
DIM V1(1, 1), V2(1, 1)                 ' Internal dynamic data arrays.%@NL@%
%@AB@%'$STATIC%@AE@%%@NL@%
%@NL@%
%@AB@%'============================================================%@AE@%%@NL@%
%@AB@%'==============      Main Level Code     ====================%@AE@%%@NL@%
%@AB@%'============================================================%@AE@%%@NL@%
%@NL@%
%@AB@%' This error trap is set in the ChartScreen routine and will%@AE@%%@NL@%
%@AB@%' be evoked if an invalid screen mode is used:%@AE@%%@NL@%
ScreenErr:%@NL@%
        clSetError cBadScreen%@NL@%
        RESUME NEXT%@NL@%
%@NL@%
%@AB@%' This error trap should catch all errors that arise in using%@AE@%%@NL@%
%@AB@%' the charting library that are not expected:%@AE@%%@NL@%
UnexpectedErr:%@NL@%
        clSetError cCLUnexpectedOff + ERR%@NL@%
        RESUME NEXT%@NL@%
%@NL@%
%@AB@%'=== AnalyzeChart - Sets up scales and data window sizes%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env        - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Cat$(1)    - One-dimensional array of category labels%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Value(1)   - One-dimensional array of values to chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%         - The number of data values in data series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Scale and Data-Window values are changed as appropriate.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB AnalyzeChart (Env AS ChartEnvironment, Cat$(), value(), N AS INTEGER)%@NL@%
%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED V1()%@NL@%
REDIM V1(1 TO N%, 1 TO 1)%@NL@%
DIM Dum$(1 TO 1)%@NL@%
%@NL@%
%@AB@%        ' Check initialization and fonts:%@AE@%%@NL@%
        clClearError%@NL@%
        clChkInit%@NL@%
        clChkFonts%@NL@%
        IF ChartErr >= 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Set a global flag to indicate that this isn't a multiple-series chart:%@AE@%%@NL@%
        GP.MSeries = cNo%@NL@%
%@NL@%
%@AB@%        ' Check for obvious parameter and ChartEnvironment errors:%@AE@%%@NL@%
        clChkForErrors Env, 1, 3, N, 0, 0%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Make a copy of the user's ChartEnvironment variable to the library's%@AE@%%@NL@%
%@AB@%        ' global environment variable:%@AE@%%@NL@%
        GE = Env%@NL@%
%@NL@%
%@AB@%        ' Set the correct axis modes for the type of chart specified in the%@AE@%%@NL@%
%@AB@%        ' chart environment:%@AE@%%@NL@%
        clSetAxisModes%@NL@%
%@NL@%
%@AB@%        ' Transfer the input data to the dynamic working data array.  Do this%@AE@%%@NL@%
%@AB@%        ' for each axis because, depending on the chart type, either one may be%@AE@%%@NL@%
%@AB@%        ' the value axis.  The Filter routine automatically ignores the call if%@AE@%%@NL@%
%@AB@%        ' the axis is a category axis:%@AE@%%@NL@%
        clFilter GE.XAxis, GP.XMode, value(), V1(), N%@NL@%
        clFilter GE.YAxis, GP.YMode, value(), V1(), N%@NL@%
%@NL@%
%@AB@%        ' Analyze the data for scale-maximum and -minimum and set the scale-%@AE@%%@NL@%
%@AB@%        ' factor, etc. depending on the options set in the chart environment:%@AE@%%@NL@%
        clAnalyzeC Cat$(), N, Dum$(), 1, 1%@NL@%
%@NL@%
%@AB@%        ' Copy the global chart environment back to the user's ChartEnvironment%@AE@%%@NL@%
%@AB@%        ' variable so that the settings that were calculated by the library are%@AE@%%@NL@%
%@AB@%        ' accessible.  Then, if this routine wasn't called by the library itself,%@AE@%%@NL@%
%@AB@%        ' in the course of drawing a bar, column or line chart, deallocate the%@AE@%%@NL@%
%@AB@%        ' working data array:%@AE@%%@NL@%
        Env = GE%@NL@%
        IF GP.SysFlag = cNo THEN ERASE V1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== AnalyzeChartMS - Analyzes multiple-series data for scale/window size.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env             - ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Cat$(1)         - One-dimensional array of category labels%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Value(2)        - Two-dimensional array of values to chart.  First%@AE@%%@NL@%
%@AB@%'                       dimension (rows) represents different values within%@AE@%%@NL@%
%@AB@%'                       a series.  Second dimension (columns) represents%@AE@%%@NL@%
%@AB@%'                       different series.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%              - Number of values (beginning with 1) to chart per%@AE@%%@NL@%
%@AB@%'                       series.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     First%          - First series to analyze%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Last%           - Last series to analyze%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     SeriesLabel$(1) - Labels for the different series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Various settings in the Env variable are altered in accordance with%@AE@%%@NL@%
%@AB@%'     the analysis.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB AnalyzeChartMS (Env AS ChartEnvironment, Cat$(), value() AS SINGLE, N AS INTEGER, First AS INTEGER, Last AS INTEGER, SeriesLabel$())%@NL@%
%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED V1()%@NL@%
REDIM V1(1 TO N, 1 TO Last - First + 1)%@NL@%
%@NL@%
%@AB@%        ' Check initialization and fonts:%@AE@%%@NL@%
        clClearError%@NL@%
        clChkInit%@NL@%
        clChkFonts%@NL@%
        IF ChartErr >= 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Set a global flag to indicate that this is a multiple-series chart:%@AE@%%@NL@%
        GP.MSeries = cYes%@NL@%
%@NL@%
%@AB@%        ' Check for obvious parameter and ChartEnvironment errors:%@AE@%%@NL@%
        clChkForErrors Env, 1, 3, N, 0, 0%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Make a copy of the user's ChartEnvironment variable to the library's%@AE@%%@NL@%
%@AB@%        ' global environment variable:%@AE@%%@NL@%
        GE = Env%@NL@%
%@NL@%
%@AB@%        ' Set the correct axis modes for the type of chart specified in the%@AE@%%@NL@%
%@AB@%        ' chart environment:%@AE@%%@NL@%
        clSetAxisModes%@NL@%
%@NL@%
%@AB@%        ' Transfer the input data to the dynamic working data array.  Do this%@AE@%%@NL@%
%@AB@%        ' for each axis because, depending on the chart type, either one may be%@AE@%%@NL@%
%@AB@%        ' the value axis.  The Filter routine automatically ignores the call if%@AE@%%@NL@%
%@AB@%        ' the axis is a category axis:%@AE@%%@NL@%
        clFilterMS GE.XAxis, GP.XMode, value(), V1(), N, First, Last%@NL@%
        clFilterMS GE.YAxis, GP.YMode, value(), V1(), N, First, Last%@NL@%
%@NL@%
%@AB@%        ' Analyze the data for scale maximums and minimums and set the scale%@AE@%%@NL@%
%@AB@%        ' factor, etc. depending on the options set in the chart environment:%@AE@%%@NL@%
        clAnalyzeC Cat$(), N, SeriesLabel$(), First, Last%@NL@%
%@NL@%
%@AB@%        ' Copy the global chart environment back to the user's ChartEnvironment%@AE@%%@NL@%
%@AB@%        ' variable so that the settings that were calculated by the library are%@AE@%%@NL@%
%@AB@%        ' accessible.  Then, if this routine wasn't called by the library itself,%@AE@%%@NL@%
%@AB@%        ' in the course of drawing a bar, column or line chart, deallocate the%@AE@%%@NL@%
%@AB@%        ' working data array:%@AE@%%@NL@%
        Env = GE%@NL@%
        IF GP.SysFlag = cNo THEN ERASE V1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== AnalyzePie - Analyzes data for a pie chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env      - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Cat$()   - One-dimensional array of category names%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Value()  - One-dimensional array of values to chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Expl()   - One dimensional array of flags indicating whether slices%@AE@%%@NL@%
%@AB@%'                are to be "exploded" (0 means no, 1 means yes).%@AE@%%@NL@%
%@AB@%'                Ignored if Env.ChartStyle <> 1.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N        - The number of values to chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB AnalyzePie (Env AS ChartEnvironment, Cat$(), value() AS SINGLE, Expl() AS INTEGER, N AS INTEGER)%@NL@%
SHARED GE AS ChartEnvironment%@NL@%
SHARED GP AS GlobalParams%@NL@%
SHARED TTitleLayout AS TitleLayout%@NL@%
SHARED XTitleLayout AS TitleLayout%@NL@%
SHARED YTitleLayout AS TitleLayout%@NL@%
SHARED V1()%@NL@%
DIM EmptyTitle AS TitleType%@NL@%
%@NL@%
%@AB@%        ' Check initialization and fonts:%@AE@%%@NL@%
        clClearError%@NL@%
        clChkInit%@NL@%
        clChkFonts%@NL@%
        IF ChartErr >= 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' This is a multiple series chart (a pie chart is treated as a%@AE@%%@NL@%
%@AB@%        ' multiple series chart with each series having one value):%@AE@%%@NL@%
        GP.MSeries = cYes%@NL@%
        GP.NSeries = N%@NL@%
%@NL@%
%@AB@%        ' Check for obvious parameter and ChartEnvironment errors:%@AE@%%@NL@%
        clChkForErrors Env, cPie, cPie, 2, 1, N%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Make a copy of the user's ChartEnvironment variable to the library's%@AE@%%@NL@%
%@AB@%        ' global environment variable:%@AE@%%@NL@%
        GE = Env%@NL@%
%@NL@%
%@AB@%        ' Set the correct axis modes for the type of chart specified in the%@AE@%%@NL@%
%@AB@%        ' chart environment:%@AE@%%@NL@%
        clSetAxisModes%@NL@%
%@NL@%
%@AB@%        ' Set global parameters and layout main title:%@AE@%%@NL@%
        clSetGlobalParams%@NL@%
%@NL@%
%@AB@%        ' Layout titles (ignore X and Y axis titles):%@AE@%%@NL@%
        clLayoutTitle TTitleLayout, GE.MainTitle, GE.SubTitle%@NL@%
        EmptyTitle.Title = ""%@NL@%
        clLayoutTitle XTitleLayout, EmptyTitle, EmptyTitle%@NL@%
        clLayoutTitle YTitleLayout, EmptyTitle, EmptyTitle%@NL@%
%@NL@%
%@AB@%        ' Calculate the size for LegendWindow and DataWindow:%@AE@%%@NL@%
        clLayoutLegend Cat$(), 1, N%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
        clSizeDataWindow Cat$()%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Copy the global chart environment back to the user's ChartEnvironment%@AE@%%@NL@%
%@AB@%        ' variable so that the settings that were calculated by the library are%@AE@%%@NL@%
%@AB@%        ' accessible.  Then, if this routine wasn't called by the library itself,%@AE@%%@NL@%
%@AB@%        ' in the course of drawing a pie chart, deallocate the working data array:%@AE@%%@NL@%
        Env = GE%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== AnalyzeScatter - Sets up scales and data-window sizes for scatter chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env        - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ValX(1)    - One-dimensional array of values for X axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ValY(1)    - One-dimensional array of values for Y axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%         - The number of data values in data series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Scale and data-window values are changed as appropriate.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB AnalyzeScatter (Env AS ChartEnvironment, ValX() AS SINGLE, ValY() AS SINGLE, N AS INTEGER)%@NL@%
%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED V1(), V2()%@NL@%
REDIM V1(1 TO N, 1 TO 1), V2(1 TO N, 1 TO 1)%@NL@%
DIM Dum$(1 TO 1)%@NL@%
%@NL@%
%@AB@%        ' Check initialization and fonts:%@AE@%%@NL@%
        clClearError%@NL@%
        clChkInit%@NL@%
        clChkFonts%@NL@%
        IF ChartErr >= 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Set a global flag to indicate that this isn't a multiple-series chart:%@AE@%%@NL@%
        GP.MSeries = cNo%@NL@%
%@NL@%
%@AB@%        ' Check for obvious parameter and ChartEnvironment errors:%@AE@%%@NL@%
        clChkForErrors Env, 4, 4, N%, 0, 0%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Make a copy of the user's ChartEnvironment variable to the library's%@AE@%%@NL@%
%@AB@%        ' global environment variable:%@AE@%%@NL@%
        GE = Env%@NL@%
%@NL@%
%@AB@%        ' Set the correct axis modes for the type of chart specified in the%@AE@%%@NL@%
%@AB@%        ' chart environment:%@AE@%%@NL@%
        clSetAxisModes%@NL@%
%@NL@%
%@AB@%        ' Transfer the input data to the dynamic working data arrays (one%@AE@%%@NL@%
%@AB@%        ' for each axis):%@AE@%%@NL@%
        clFilter GE.XAxis, GP.XMode, ValX(), V1(), N%@NL@%
        clFilter GE.YAxis, GP.YMode, ValY(), V2(), N%@NL@%
%@NL@%
%@AB@%        ' Analyze the data for scale-maximum and -minimum and set the scale-%@AE@%%@NL@%
%@AB@%        ' factor, etc. depending on the options set in the chart environment:%@AE@%%@NL@%
        clAnalyzeS N, Dum$(), 1, 1%@NL@%
%@NL@%
%@AB@%        ' Copy the global chart environment back to the user's ChartEnvironment%@AE@%%@NL@%
%@AB@%        ' variable so that the settings that were calculated by the library are%@AE@%%@NL@%
%@AB@%        ' accessible.  Then, if this routine wasn't called by the library itself,%@AE@%%@NL@%
%@AB@%        ' in the course of drawing a scatter chart, deallocate the working%@AE@%%@NL@%
%@AB@%        ' data arrays:%@AE@%%@NL@%
        Env = GE%@NL@%
        IF GP.SysFlag = cNo THEN ERASE V1, V2%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== AnalyzeScatterMS - Analyzes multiple-series data for scale/window size%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env             - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ValX(2)         - Two-dimensional array of values for X axis.  First%@AE@%%@NL@%
%@AB@%'                       dimension (rows) represents different values within%@AE@%%@NL@%
%@AB@%'                       a series.  Second dimension (columns) represents%@AE@%%@NL@%
%@AB@%'                       different series.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ValY(2)         - Two-dimensional array of values for Y axis.  Above%@AE@%%@NL@%
%@AB@%'                       comments apply%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%              - Number of values (beginning with 1) to chart per%@AE@%%@NL@%
%@AB@%'                       series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     First%          - First series to analyze%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Last%           - Last series to analyze%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     SeriesLabel$(1) - Labels for the different series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Various settings in the Env variable are altered in accordance with%@AE@%%@NL@%
%@AB@%'     the analysis.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB AnalyzeScatterMS (Env AS ChartEnvironment, ValX() AS SINGLE, ValY() AS SINGLE, N AS INTEGER, First AS INTEGER, Last AS INTEGER, SeriesLabel$())%@NL@%
%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED V1(), V2()%@NL@%
REDIM V1(1 TO N, 1 TO Last - First + 1), V2(1 TO N, 1 TO Last - First + 1)%@NL@%
DIM Dum$(1 TO 1)%@NL@%
%@NL@%
%@AB@%        ' Check initialization and fonts:%@AE@%%@NL@%
        clClearError%@NL@%
        clChkInit%@NL@%
        clChkFonts%@NL@%
        IF ChartErr >= 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Set a global flag to indicate that this is a multiple-series chart:%@AE@%%@NL@%
        GP.MSeries = cYes%@NL@%
%@NL@%
%@AB@%        ' Check for obvious parameter and ChartEnvironment errors:%@AE@%%@NL@%
        clChkForErrors Env, 4, 4, N%, 0, 0%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Make a copy of the user's ChartEnvironment variable to the library's%@AE@%%@NL@%
%@AB@%        ' global environment variable:%@AE@%%@NL@%
        GE = Env%@NL@%
%@NL@%
%@AB@%        ' Set the correct axis modes for the type of chart specified in the%@AE@%%@NL@%
%@AB@%        ' chart environment:%@AE@%%@NL@%
        clSetAxisModes%@NL@%
%@NL@%
%@AB@%        ' Transfer the input data to the dynamic working data arrays (one%@AE@%%@NL@%
%@AB@%        ' for each axis):%@AE@%%@NL@%
        clFilterMS GE.XAxis, GP.XMode, ValX(), V1(), N, First, Last%@NL@%
        clFilterMS GE.YAxis, GP.YMode, ValY(), V2(), N, First, Last%@NL@%
%@NL@%
%@AB@%        ' Analyze the data for scale-maximum and -minimum and set the scale-%@AE@%%@NL@%
%@AB@%        ' factor, etc. depending on the options set in the chart environment:%@AE@%%@NL@%
        clAnalyzeS N, SeriesLabel$(), First%, Last%%@NL@%
%@NL@%
%@AB@%        ' Copy the global chart environment back to the user's ChartEnvironment%@AE@%%@NL@%
%@AB@%        ' variable so that the settings that were calculated by the library are%@AE@%%@NL@%
%@AB@%        ' accessible.  Then, if this routine wasn't called by the library itself,%@AE@%%@NL@%
%@AB@%        ' in the course of drawing a scatter chart, deallocate the working%@AE@%%@NL@%
%@AB@%        ' data arrays:%@AE@%%@NL@%
        Env = GE%@NL@%
        IF GP.SysFlag = cNo THEN ERASE V1, V2%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== Chart - Draws a single-series category/value chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env        - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Cat$(1)    - One-dimensional array of category labels%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Value(1)   - One-dimensional array of values to plot%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N          - The number of data values in data series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Some elements of the Env variable are altered by plotting routines%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     This routine takes all of the parameters set in the Env variable%@AE@%%@NL@%
%@AB@%'     and draws a single-series chart of type Bar, Column, or Line%@AE@%%@NL@%
%@AB@%'     depending on the chart type specified in the Env variable.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB Chart (Env AS ChartEnvironment, Cat$(), value() AS SINGLE, N AS INTEGER)%@NL@%
%@NL@%
SHARED V1()%@NL@%
%@NL@%
%@AB@%        ' Analyze data for scale and window settings:%@AE@%%@NL@%
        clFlagSystem%@NL@%
        AnalyzeChart Env, Cat$(), value(), N%@NL@%
        clUnFlagSystem%@NL@%
        IF ChartErr < 100 THEN%@NL@%
%@NL@%
%@AB@%                ' Draw the different elements of the chart:%@AE@%%@NL@%
                clDrawChartWindow%@NL@%
                clDrawTitles%@NL@%
                clDrawDataWindow%@NL@%
                clDrawAxes Cat$()%@NL@%
%@NL@%
%@AB@%                ' Call appropriate Draw...Data routine for chart type:%@AE@%%@NL@%
                SELECT CASE Env.ChartType%@NL@%
                        CASE 1: clDrawBarData%@NL@%
                        CASE 2: clDrawColumnData%@NL@%
                        CASE 3: clDrawLineData%@NL@%
                END SELECT%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Deallocate the data array:%@AE@%%@NL@%
        ERASE V1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== ChartMS - Draws a multiple-series category/value chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env               - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Cat$(1)           - A one-dimensional array of category names for the%@AE@%%@NL@%
%@AB@%'                         different data values%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Value(2)          - A two-dimensional array of values--one column for%@AE@%%@NL@%
%@AB@%'                         each series of data%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%                - The number of data points in each series of data%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     First%            - The first series to be plotted%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Last%             - The last series to be plotted%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     SeriesLabel$(1)   - Labels used for each series in the legend%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Some elements of the Env variable are altered by plotting routines%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     This routine takes all of the parameters set in the Env variable%@AE@%%@NL@%
%@AB@%'     and draws a multiple-series chart of type Bar, Column, or Line%@AE@%%@NL@%
%@AB@%'     depending on the chart type specified in the Env variable.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB ChartMS (Env AS ChartEnvironment, Cat$(), value() AS SINGLE, N AS INTEGER, First AS INTEGER, Last AS INTEGER, SeriesLabel$())%@NL@%
%@NL@%
SHARED V1()%@NL@%
%@NL@%
%@AB@%        ' Analyze data for scale settings:%@AE@%%@NL@%
        clFlagSystem%@NL@%
        AnalyzeChartMS Env, Cat$(), value(), N, First, Last, SeriesLabel$()%@NL@%
        clUnFlagSystem%@NL@%
        IF ChartErr < 100 THEN%@NL@%
%@NL@%
%@AB@%                ' Draw the different elements of the chart:%@AE@%%@NL@%
                clDrawChartWindow%@NL@%
                clDrawTitles%@NL@%
                clDrawDataWindow%@NL@%
                clDrawAxes Cat$()%@NL@%
%@NL@%
%@AB@%                ' Call appropriate Draw...DataMS routine for chart type:%@AE@%%@NL@%
                SELECT CASE Env.ChartType%@NL@%
                        CASE 1: clDrawBarData%@NL@%
                        CASE 2: clDrawColumnData%@NL@%
                        CASE 3: clDrawLineData%@NL@%
                END SELECT%@NL@%
%@NL@%
%@AB@%                ' Lastly, add the legend:%@AE@%%@NL@%
                clDrawLegend SeriesLabel$(), First, Last%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Deallocate the data array:%@AE@%%@NL@%
        ERASE V1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== ChartPie - Draws a pie chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env      - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Cat$()   - One-dimensional array of category names%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Value()  - One-dimensional array of values to chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Expl%()  - One-dimensional array of flags indicating whether slices%@AE@%%@NL@%
%@AB@%'                are to be "exploded" or not (0 means no, 1 means yes),%@AE@%%@NL@%
%@AB@%'                ignored if ChartStyle <> 1%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%       - The number of values to chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     No return values%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB ChartPie (Env AS ChartEnvironment, Cat$(), value() AS SINGLE, Expl() AS INTEGER, N AS INTEGER)%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@AB@%        ' Set the global system flag to tell the AnalyzePie routine that it%@AE@%%@NL@%
%@AB@%        ' is being called by the system and not the user:%@AE@%%@NL@%
        clFlagSystem%@NL@%
%@NL@%
%@AB@%        ' Calculate the size of the Data- and Legend-window:%@AE@%%@NL@%
        AnalyzePie Env, Cat$(), value(), Expl(), N%@NL@%
%@NL@%
%@AB@%        ' Remove the system flag:%@AE@%%@NL@%
        clUnFlagSystem%@NL@%
%@NL@%
%@AB@%        ' If there were no errors during analysis draw the chart:%@AE@%%@NL@%
        IF ChartErr < 100 THEN%@NL@%
%@NL@%
%@AB@%                ' Draw the different chart elements:%@AE@%%@NL@%
                clDrawChartWindow%@NL@%
                clDrawTitles%@NL@%
                clDrawDataWindow%@NL@%
                clDrawPieData value(), Expl(), N%@NL@%
                IF ChartErr <> 0 THEN EXIT SUB%@NL@%
                clDrawLegend Cat$(), 1, N%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== ChartScatter - Draws a single-series scatter chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env      - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ValX(1)  - One-dimensional array of values for X axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ValY(1)  - One-dimensional array of values for Y axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%       - The number of values to chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Some elements of Env variable may be changed by drawing routines%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     ChartScatter should be called when a chart with two value axes is%@AE@%%@NL@%
%@AB@%'     desired%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB ChartScatter (Env AS ChartEnvironment, ValX() AS SINGLE, ValY() AS SINGLE, N AS INTEGER)%@NL@%
DIM Dum$(1 TO 1)%@NL@%
SHARED V1(), V2()%@NL@%
%@NL@%
%@AB@%        ' Set the global system flag to tell the AnalyzeScatter routine that it%@AE@%%@NL@%
%@AB@%        ' is being called by the system and not the user:%@AE@%%@NL@%
        clFlagSystem%@NL@%
%@NL@%
%@AB@%        ' Calculate the scale maximums and minimums and scale factor. Also%@AE@%%@NL@%
%@AB@%        ' calculate the sizes for the Data- and Legend-windows:%@AE@%%@NL@%
        AnalyzeScatter Env, ValX(), ValY(), N%@NL@%
%@NL@%
%@AB@%        ' Remove the system flag:%@AE@%%@NL@%
        clUnFlagSystem%@NL@%
%@NL@%
%@AB@%        ' If there were no errors during analysis draw the chart:%@AE@%%@NL@%
        IF ChartErr < 100 THEN%@NL@%
%@NL@%
%@AB@%                ' Draw the different elements of the chart:%@AE@%%@NL@%
                clDrawChartWindow%@NL@%
                clDrawTitles%@NL@%
                clDrawDataWindow%@NL@%
                clDrawAxes Dum$()%@NL@%
                clDrawScatterData%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Deallocate the dynamic working data arrays:%@AE@%%@NL@%
        ERASE V1, V2%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== ChartScatterMS - Draws a multiple-series scatter chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env            - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ValX(2)        - Two-dimensional array of values for X axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ValY(2)        - Two-dimensional array of values for Y axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%             - The number of values in each series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     First%         - First series to chart (first column)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Last%          - Last series to chart (last column)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     SeriesLabel$() - Label used for each series in legend%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Some elements in Env variable may be changed by drawing routines%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     A scatter chart uses two value axes so it must have values for both%@AE@%%@NL@%
%@AB@%'     the X and Y axes (ValX(), ValY()).  The first dimension denotes%@AE@%%@NL@%
%@AB@%'     the different values within a series.  The second dimension specifies%@AE@%%@NL@%
%@AB@%'     different data series (e.g. ValX(4,3) would represent the fourth value%@AE@%%@NL@%
%@AB@%'     in the third series of data).%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB ChartScatterMS (Env AS ChartEnvironment, ValX() AS SINGLE, ValY() AS SINGLE, N AS INTEGER, First AS INTEGER, Last AS INTEGER, SeriesLabel$())%@NL@%
DIM Dum$(1 TO 1)%@NL@%
SHARED V1(), V2()%@NL@%
%@NL@%
%@AB@%        ' Set the global system flag to tell the AnalyzeScatterMS routine that it%@AE@%%@NL@%
%@AB@%        ' is being called by the system and not the user:%@AE@%%@NL@%
        clFlagSystem%@NL@%
%@NL@%
%@AB@%        ' Calculate the scale maximums and minimums and scale factor. Also%@AE@%%@NL@%
%@AB@%        ' calculate the sizes for the Data- and Legend-windows:%@AE@%%@NL@%
        AnalyzeScatterMS Env, ValX(), ValY(), N, First, Last, SeriesLabel$()%@NL@%
%@NL@%
%@AB@%        ' Remove the system flag:%@AE@%%@NL@%
        clUnFlagSystem%@NL@%
%@NL@%
%@AB@%        ' If there were no errors during analysis draw the chart:%@AE@%%@NL@%
        IF ChartErr < 100 THEN%@NL@%
%@NL@%
%@AB@%                ' Draw the different elements of the chart:%@AE@%%@NL@%
                clDrawChartWindow%@NL@%
                clDrawTitles%@NL@%
                clDrawDataWindow%@NL@%
                clDrawAxes Dum$()%@NL@%
                clDrawScatterData%@NL@%
                clDrawLegend SeriesLabel$(), First, Last%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Deallocate the dynamic working data arrays:%@AE@%%@NL@%
        ERASE V1, V2%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== ChartScreen - Sets the SCREEN mode and default palettes%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     N%    - A valid BASIC graphic mode, or mode 0%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     All palettes may be altered%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB ChartScreen (N AS INTEGER)%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' Check initialization and fonts:%@AE@%%@NL@%
        clClearError%@NL@%
        clChkInit%@NL@%
%@NL@%
%@AB@%        ' Set up branch to error processor and attempt to set the specified%@AE@%%@NL@%
%@AB@%        ' screen mode and draw to it:%@AE@%%@NL@%
        ON ERROR GOTO ScreenErr%@NL@%
        SCREEN N%@NL@%
        IF N <> 0 THEN PRESET (0, 0)%@NL@%
        ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%        ' If the above PRESET failed, then the TestScreen error processor will%@AE@%%@NL@%
%@AB@%        ' have set the ChartErr error variable to a nonzero value.  If the last%@AE@%%@NL@%
%@AB@%        ' call to ChartScreen used the same mode, GP.PaletteScrn will equal N; and%@AE@%%@NL@%
%@AB@%        ' there is no need to rebuild palettes.  In either case there is no need%@AE@%%@NL@%
%@AB@%        ' to do anything else, so exit:%@AE@%%@NL@%
        IF ChartErr <> 0 OR (GP.PaletteScrn = N AND GP.PaletteSet) THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' This is a new screen mode so use the SELECT CASE statement below%@AE@%%@NL@%
%@AB@%        ' to handle it.  It sets the number of bits per pixel for a screen%@AE@%%@NL@%
%@AB@%        ' mode so that the palettes can be built properly:%@AE@%%@NL@%
        SELECT CASE N%@NL@%
%@NL@%
%@AB@%                ' Screen mode 0 is not a graphics mode and is included mainly for%@AE@%%@NL@%
%@AB@%                ' completeness.  The actual screen mode has been set above, so exit:%@AE@%%@NL@%
                CASE 0:%@NL@%
                        EXIT SUB%@NL@%
%@NL@%
                CASE 1:  Bits% = 2%@NL@%
                CASE 2:  Bits% = 1%@NL@%
                CASE 3:  Bits% = 1%@NL@%
                CASE 4:  Bits% = 1%@NL@%
                CASE 7:  Bits% = 4%@NL@%
                CASE 8:  Bits% = 4%@NL@%
                CASE 9:%@NL@%
%@AB@%                                        ' For screen mode 9, assume a 256K EGA and try setting%@AE@%%@NL@%
%@AB@%                                        ' a color to 63.  If that fails, assume it is a 64K EGA%@AE@%%@NL@%
%@AB@%                                        ' (the number of bit planes is four for 256K and two for%@AE@%%@NL@%
%@AB@%                                        ' 64K):%@AE@%%@NL@%
                                        Bits% = 4%@NL@%
                                        ON ERROR GOTO ScreenErr%@NL@%
                                        clClearError%@NL@%
                                        COLOR 15%@NL@%
                                        IF ChartErr <> 0 THEN Bits% = 2%@NL@%
                                        clClearError%@NL@%
                                        ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
                CASE 10: Bits% = 2%@NL@%
                CASE 11: Bits% = 1%@NL@%
                CASE 12: Bits% = 4%@NL@%
                CASE 13: Bits% = 8%@NL@%
%@NL@%
%@AB@%                ' If none of the above match then a valid screen mode was specified;%@AE@%%@NL@%
%@AB@%                ' however the mode is un-supported so set error and exit:%@AE@%%@NL@%
                CASE ELSE: clSetError cBadScreen%@NL@%
                                          EXIT SUB%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' The screen aspect is 4/3 * MaxY/MaxX:%@AE@%%@NL@%
        VIEW%@NL@%
        WINDOW (0, 0)-(1, 1)%@NL@%
        GP.MaxXPix% = PMAP(1, 0) + 1%@NL@%
        GP.MaxYPix% = PMAP(0, 1) + 1%@NL@%
        GP.Aspect = 1.33333 * (GP.MaxYPix% - 1) / (GP.MaxXPix% - 1)%@NL@%
        WINDOW%@NL@%
%@NL@%
%@AB@%        ' The number of colors available:%@AE@%%@NL@%
        GP.MaxColor = 2 ^ Bits% - 1%@NL@%
%@NL@%
%@AB@%        ' Specify which color to use for white:%@AE@%%@NL@%
        SELECT CASE N%@NL@%
                CASE 13: GP.White = 15%@NL@%
                CASE ELSE: GP.White = GP.MaxColor%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Build palette for this screen mode:%@AE@%%@NL@%
        clBuildPalette N, Bits%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clAdjustScale - Calculates scaling factor for an axis and adjusts max-min%@AE@%%@NL@%
%@AB@%'                  as appropriate for scale factor and log base if log axis:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Axis  -  AxisType variable describing axis to be scaled.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     May set the ScaleFactor and ScaleTitle elements and alter%@AE@%%@NL@%
%@AB@%'     ScaleMin and ScaleMax elements of the Axis variable.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clAdjustScale (Axis AS AxisType)%@NL@%
%@NL@%
%@AB@%        ' Don't try to scale a log axis:%@AE@%%@NL@%
        IF Axis.RangeType = cLog THEN%@NL@%
%@NL@%
                Axis.ScaleFactor = 1%@NL@%
                Axis.ScaleTitle.Title = "Log" + STR$(Axis.LogBase)%@NL@%
%@NL@%
%@AB@%        ' For a linear axis, choose a scale factor up to Trillions depending%@AE@%%@NL@%
%@AB@%        ' on the size of the axis limits:%@AE@%%@NL@%
        ELSE%@NL@%
%@NL@%
%@AB@%                ' Choose the largest ABS from Max and Min for the axis:%@AE@%%@NL@%
                IF ABS(Axis.ScaleMax) > ABS(Axis.ScaleMin) THEN%@NL@%
                        Max = ABS(Axis.ScaleMax)%@NL@%
                ELSE%@NL@%
                        Max = ABS(Axis.ScaleMin)%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Find out power of three by which to scale:%@AE@%%@NL@%
                Power% = INT((LOG(Max) / LOG(10)) / 3)%@NL@%
%@NL@%
%@AB@%                ' And, choose the correct title to go with it:%@AE@%%@NL@%
                SELECT CASE Power%%@NL@%
                        CASE -4:     Axis.ScaleTitle.Title = "Trillionths"%@NL@%
                        CASE -3:     Axis.ScaleTitle.Title = "Billionths"%@NL@%
                        CASE -2:     Axis.ScaleTitle.Title = "Millionths"%@NL@%
                        CASE -1:     Axis.ScaleTitle.Title = "Thousandths"%@NL@%
                        CASE 0:     Axis.ScaleTitle.Title = ""%@NL@%
                        CASE 1:     Axis.ScaleTitle.Title = "Thousands"%@NL@%
                        CASE 2:     Axis.ScaleTitle.Title = "Millions"%@NL@%
                        CASE 3:     Axis.ScaleTitle.Title = "Billions"%@NL@%
                        CASE 4:     Axis.ScaleTitle.Title = "Trillions"%@NL@%
                        CASE ELSE:  Axis.ScaleTitle.Title = "10^" + LTRIM$(STR$(Power% * 3))%@NL@%
                END SELECT%@NL@%
%@NL@%
%@AB@%                ' Calculate the actual scale factor:%@AE@%%@NL@%
                Axis.ScaleFactor = 10 ^ (3 * Power%)%@NL@%
%@NL@%
%@AB@%                ' Finally, scale Max and Min by ScaleFactor:%@AE@%%@NL@%
                Axis.ScaleMin = Axis.ScaleMin / Axis.ScaleFactor%@NL@%
                Axis.ScaleMax = Axis.ScaleMax / Axis.ScaleFactor%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clAnalyzeC - Does analysis of category/value data%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Cat$(1)     -  List of category names%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%          -  Number of data values per series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     SLabels$    -  Labels for the different data series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     First%      -  First series to chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Last%       -  Last series to chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Some values in GE are altered.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clAnalyzeC (Cat$(), N%, SLabels$(), First%, Last%)%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED TTitleLayout AS TitleLayout%@NL@%
SHARED XTitleLayout AS TitleLayout%@NL@%
SHARED YTitleLayout AS TitleLayout%@NL@%
SHARED V1()%@NL@%
%@NL@%
%@AB@%        ' Save the number of values and the number of series in the chart in%@AE@%%@NL@%
%@AB@%        ' the global parameter variables:%@AE@%%@NL@%
        GP.NVals = N%%@NL@%
        GP.NSeries = Last% - First% + 1%@NL@%
%@NL@%
%@AB@%        ' Analyze data for scale-maximim and -minimum and scale-factor:%@AE@%%@NL@%
        clScaleAxis GE.XAxis, GP.XMode, V1()%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
        clScaleAxis GE.YAxis, GP.YMode, V1()%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Format tic labels (needed for sizing routines) and set global%@AE@%%@NL@%
%@AB@%        ' parameters (again used by sizing and other routines):%@AE@%%@NL@%
        clFormatTics GE.XAxis%@NL@%
        clFormatTics GE.YAxis%@NL@%
        clSetGlobalParams%@NL@%
%@NL@%
%@AB@%        ' Layout Titles%@AE@%%@NL@%
        clLayoutTitle TTitleLayout, GE.MainTitle, GE.SubTitle%@NL@%
        clLayoutTitle YTitleLayout, GE.YAxis.AxisTitle, GE.YAxis.ScaleTitle%@NL@%
        clLayoutTitle XTitleLayout, GE.XAxis.AxisTitle, GE.XAxis.ScaleTitle%@NL@%
%@NL@%
%@AB@%        ' If this is a multiple-series chart, calculate the legend size:%@AE@%%@NL@%
        IF GP.MSeries = cYes THEN clLayoutLegend SLabels$(), First%, Last%%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Calculate the data-window size:%@AE@%%@NL@%
        clSizeDataWindow Cat$()%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Finally, figure out the distance between tic marks:%@AE@%%@NL@%
        clSpaceTics%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clAnalyzeS - Does actual analysis of scatter data%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     N%          -  Number of values per data series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     SLabels$(1) -  Labels for the data series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     First%      -  First series to analyze%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Last%       -  Last series to analyze%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Values in GE are altered.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clAnalyzeS (N%, SLabels$(), First%, Last%)%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED TTitleLayout AS TitleLayout%@NL@%
SHARED XTitleLayout AS TitleLayout%@NL@%
SHARED YTitleLayout AS TitleLayout%@NL@%
SHARED V1(), V2()%@NL@%
DIM Dum$(1 TO 1)%@NL@%
%@NL@%
%@AB@%        ' Save the number of values and the number of series in the chart in%@AE@%%@NL@%
%@AB@%        ' the global parameter variables:%@AE@%%@NL@%
        GP.NVals = N%%@NL@%
        GP.NSeries = Last% - First% + 1%@NL@%
%@NL@%
%@AB@%        ' Analyze data for scale-maximim and -minimum and scale-factor:%@AE@%%@NL@%
        clScaleAxis GE.XAxis, GP.XMode, V1()%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
        clScaleAxis GE.YAxis, GP.YMode, V2()%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Format tic labels (needed for sizing routines) and set global%@AE@%%@NL@%
%@AB@%        ' parameters (again used by sizing and other routines):%@AE@%%@NL@%
        clFormatTics GE.XAxis%@NL@%
        clFormatTics GE.YAxis%@NL@%
        clSetGlobalParams%@NL@%
%@NL@%
%@AB@%        ' Layout Titles%@AE@%%@NL@%
        clLayoutTitle TTitleLayout, GE.MainTitle, GE.SubTitle%@NL@%
        clLayoutTitle YTitleLayout, GE.YAxis.AxisTitle, GE.YAxis.ScaleTitle%@NL@%
        clLayoutTitle XTitleLayout, GE.XAxis.AxisTitle, GE.XAxis.ScaleTitle%@NL@%
%@NL@%
%@AB@%        ' If this is a multiple-series chart, calculate the legend size:%@AE@%%@NL@%
        IF GP.MSeries = cYes THEN clLayoutLegend SLabels$(), First%, Last%%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Calculate the data window size:%@AE@%%@NL@%
        clSizeDataWindow Dum$()%@NL@%
        IF ChartErr > 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Finally, figure out the distance between tic marks:%@AE@%%@NL@%
        clSpaceTics%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clBuildBitP$ - Builds a pattern tile for a one bit-plane screen mode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Bits%    =  Number of bits per pixel in this screen mode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     C%       =  The color used to make the pattern.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     InP$     =  Reference pattern%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Returns the specified pattern in specified color.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     In screen modes where a pixel on the screen is represented by 1 or%@AE@%%@NL@%
%@AB@%'     more bits that are adjacent in memory, a byte of memory represents%@AE@%%@NL@%
%@AB@%'     one or more pixels depending on the number of bits per pixel the%@AE@%%@NL@%
%@AB@%'     mode uses (e.g. screen mode 1 uses 2 bits per pixel so each byte%@AE@%%@NL@%
%@AB@%'     contains 4 pixels).  To make a pattern tile in a specific color%@AE@%%@NL@%
%@AB@%'     you first decide which pixels should be on and which ones off.%@AE@%%@NL@%
%@AB@%'     Then, you set the corresponding two-bit pixels in the tile bytes%@AE@%%@NL@%
%@AB@%'     to the value of the color you want the pattern to be.  This routine%@AE@%%@NL@%
%@AB@%'     does this semi-automatically.  First it inputs a reference pattern that%@AE@%%@NL@%
%@AB@%'     contains the pattern defined in the highest color available for a%@AE@%%@NL@%
%@AB@%'     screen mode (all bits in a pixel set to one).  Then a color mask byte%@AE@%%@NL@%
%@AB@%'     is prepared with each pixel set to the color that was specified as%@AE@%%@NL@%
%@AB@%'     input to the routine.  When these two components (reference pattern%@AE@%%@NL@%
%@AB@%'     and color mask) are combined using a logical "AND" any pixel in the%@AE@%%@NL@%
%@AB@%'     reference pattern that was black (all zero) will remain black and any%@AE@%%@NL@%
%@AB@%'     pixel that was white will be of the input color.  The nice feature of%@AE@%%@NL@%
%@AB@%'     this scheme is that you can use one pattern set for any color%@AE@%%@NL@%
%@AB@%'     available for the screen mode.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Example: Screen mode 1; 2 bits per pixel; to build a pattern%@AE@%%@NL@%
%@AB@%'              with pixels alternating on and off in color 2:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Reference pattern:   11 00 11 00    (8 bits = 1 byte)%@AE@%%@NL@%
%@AB@%'     Color mask:          10 10 10 10    (each pixel set to color 2)%@AE@%%@NL@%
%@AB@%'                         -------------%@AE@%%@NL@%
%@AB@%'     Result of "AND"      10 00 10 00    (pattern in color 2)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION clBuildBitP$ (Bits%, C%, InP$)%@NL@%
%@NL@%
%@AB@%        ' First get color mask to match this color and pixel size (bits per pixel):%@AE@%%@NL@%
        CMask% = clColorMaskL%(Bits%, C%)%@NL@%
%@NL@%
%@AB@%        ' Initialize the output pattern to empty then combine the color%@AE@%%@NL@%
%@AB@%        ' mask with each byte in the input tile using a logical "AND":%@AE@%%@NL@%
        OutP$ = ""%@NL@%
        FOR i% = 1 TO LEN(InP$)%@NL@%
                NxtCH% = CMask% AND ASC(MID$(InP$, i%, 1))%@NL@%
                OutP$ = OutP$ + CHR$(NxtCH%)%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' Return the completed pattern:%@AE@%%@NL@%
        clBuildBitP$ = OutP$%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== clBuildPalette - Builds the five chart palettes%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     N           -  Screen mode for which to build palettes%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Values in chart palettes set to standard ones for this mode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     The following code sets up the palettes that are referenced when the%@AE@%%@NL@%
%@AB@%'     different chart elements are drawn.  See the charting library%@AE@%%@NL@%
%@AB@%'     documentation for a complete description of how these palettes are%@AE@%%@NL@%
%@AB@%'     used in drawing different portions of a chart.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clBuildPalette (ScrnMode AS INTEGER, Bits AS INTEGER)%@NL@%
SHARED PaletteC%(), PaletteS%(), PaletteP$(), PaletteCh%(), PaletteB%()%@NL@%
SHARED StdChars%()%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' Flag palette set and record the screen mode:%@AE@%%@NL@%
        GP.PaletteSet = cYes%@NL@%
        GP.PaletteScrn = ScrnMode%@NL@%
        GP.PaletteBits = Bits%@NL@%
%@NL@%
%@AB@%        ' The first palettes to set are the character palette and the border%@AE@%%@NL@%
%@AB@%        ' style palette:%@AE@%%@NL@%
        PaletteCh%(0) = 0%@NL@%
        PaletteB%(0) = &HFFFF%@NL@%
        FOR i% = 1 TO cPalLen%@NL@%
                PaletteCh%(i%) = StdChars%(i%)%@NL@%
                PaletteB%(i%) = clGetStyle(i%)%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' The next palette to set is the color palette, which is made up of%@AE@%%@NL@%
%@AB@%        ' a list of 10 (maybe repeating) colors.  Begin by setting the first%@AE@%%@NL@%
%@AB@%        ' two colors.  The first color (position 0) is always black and the%@AE@%%@NL@%
%@AB@%        ' second color is always white (or whatever the maximum color number%@AE@%%@NL@%
%@AB@%        ' is mapped to in the graphics-card palette).  Cycle through setting%@AE@%%@NL@%
%@AB@%        ' other colors.  They will be entered in order starting with color 1%@AE@%%@NL@%
%@AB@%        ' until the maximum number of colors is reached or the palette is filled%@AE@%%@NL@%
%@AB@%        ' (size governed by the cPalLen CONST).  If the maximum color is reached%@AE@%%@NL@%
%@AB@%        ' before the palette is filled then repeat the cycle again excluding%@AE@%%@NL@%
%@AB@%        ' color 0, and so on, until the color palette is filled:%@AE@%%@NL@%
%@NL@%
        PaletteC%(0) = 0        ' Black%@NL@%
        PaletteC%(1) = GP.White ' White%@NL@%
%@NL@%
        FOR i% = 2 TO cPalLen%@NL@%
                MappedI% = ((i% - 2) MOD GP.MaxColor) + 1%@NL@%
                PaletteC%(i%) = MappedI%%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' Setting the line styles is almost the inverse of setting the colors%@AE@%%@NL@%
%@AB@%        ' in that each color within a cycle has the same line style.  When a%@AE@%%@NL@%
%@AB@%        ' new cycle of colors begins, though, the line style changes to%@AE@%%@NL@%
%@AB@%        ' differentiate the new cycle from previous ones.  The line style%@AE@%%@NL@%
%@AB@%        ' begins as &HFFFF or a solid line:%@AE@%%@NL@%
%@NL@%
%@AB@%        ' The pattern component of the palette contains fill patterns for use in%@AE@%%@NL@%
%@AB@%        ' filling bars and pie slices.  Fill patterns are "bit" oriented whereas%@AE@%%@NL@%
%@AB@%        ' line styles are "pixel" oriented.  What this means is that a fill%@AE@%%@NL@%
%@AB@%        ' pattern of CHR$(&HFF) will be white regardless of what the current%@AE@%%@NL@%
%@AB@%        ' color is.  If you know that each pixel on the screen is represented by%@AE@%%@NL@%
%@AB@%        ' 2 bits in RAM and you want a solid fill with color 2, the corresponding%@AE@%%@NL@%
%@AB@%        ' definition would be CHR$(&HAA) (in binary 10 10 10 10 -- notice, four%@AE@%%@NL@%
%@AB@%        ' pixels of two bits each set to 2).  The following code automatically%@AE@%%@NL@%
%@AB@%        ' takes a fill pattern defined in terms of pixels, and by masking it%@AE@%%@NL@%
%@AB@%        ' with the current color generates the same fill pattern in the%@AE@%%@NL@%
%@AB@%        ' specified color.  Start with solid black (color 0):%@AE@%%@NL@%
%@NL@%
        PaletteS%(0) = &HFFFF%@NL@%
        PaletteP$(0) = CHR$(0)%@NL@%
%@NL@%
        FOR i% = 1 TO cPalLen%@NL@%
%@NL@%
%@AB@%                ' The cycle number starts at one and is incremented each time%@AE@%%@NL@%
%@AB@%                ' the maximum number of colors for the current screen mode is reached:%@AE@%%@NL@%
                Cycle% = ((i% - 1) \ GP.MaxColor) + 1%@NL@%
%@NL@%
%@AB@%                ' Set the style palette from the standard styles (which have%@AE@%%@NL@%
%@AB@%                ' previously been placed in the border palette):%@AE@%%@NL@%
                PaletteS%(i%) = PaletteB%(Cycle%)%@NL@%
%@NL@%
%@AB@%                ' Get the default pattern and put it into the palette:%@AE@%%@NL@%
                SELECT CASE ScrnMode%@NL@%
%@NL@%
%@AB@%                        ' One bit plane modes:%@AE@%%@NL@%
                        CASE 1, 2, 11, 13: RefPattern$ = GetPattern$(Bits, Cycle%)%@NL@%
%@NL@%
%@AB@%                        ' Multiple bit plane modes:%@AE@%%@NL@%
                        CASE ELSE: RefPattern$ = GetPattern$(1, Cycle%)%@NL@%
%@NL@%
                END SELECT%@NL@%
                PaletteP$(i%) = MakeChartPattern$(RefPattern$, PaletteC%(i%), 0)%@NL@%
%@NL@%
        NEXT i%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clBuildPlaneP$ - Builds a pattern tile for multiple bit-plane screen modes%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Bits%    =  Number of planes in this screen mode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     C%       =  The color used to make the pattern%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     InP$     =  Reference pattern%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Returns the specified pattern in specified color%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     PAINT tiles are different for screen modes that use 2 or more%@AE@%%@NL@%
%@AB@%'     bit-planes than for the modes that use only one (see remarks for%@AE@%%@NL@%
%@AB@%'     clBuildBitP$()).  When bit-planes are used each pixel requires only%@AE@%%@NL@%
%@AB@%'     one bit per byte, but, there needs to be one byte for each bit-%@AE@%%@NL@%
%@AB@%'     plane.  The process for building a pattern from a reference pattern%@AE@%%@NL@%
%@AB@%'     and color mask are logically the same as in the one bit-plane modes%@AE@%%@NL@%
%@AB@%'     the only difference is that a color mask requires several bytes%@AE@%%@NL@%
%@AB@%'     (one for each bit-plane) rather than one.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Example: Screen mode 9 with 2 bit planes; pattern with alternating%@AE@%%@NL@%
%@AB@%'           pixels on and off; color 2:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'           Reference pattern:   1 0 1 0 1 0 1 0%@AE@%%@NL@%
%@AB@%'           Color mask:          0 0 0 0 0 0 0 0   (plane 1)%@AE@%%@NL@%
%@AB@%'                                1 1 1 1 1 1 1 1   (plane 2)%@AE@%%@NL@%
%@AB@%'                               -----------------%@AE@%%@NL@%
%@AB@%'           Result of "AND"      0 0 0 0 0 0 0 0   (plane 1)%@AE@%%@NL@%
%@AB@%'                                1 0 1 0 1 0 1 0   (plane 2)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION clBuildPlaneP$ (Bits%, C%, InP$)%@NL@%
DIM CMask%(1 TO 4)%@NL@%
%@NL@%
%@AB@%        ' First get color mask to match this color and pixel size (bits per pixel):%@AE@%%@NL@%
        clColorMaskH Bits%, C%, CMask%()%@NL@%
%@NL@%
%@AB@%        ' Initialize the output pattern to empty then combine the color%@AE@%%@NL@%
%@AB@%        ' mask with each byte in the input tile using a logical "AND":%@AE@%%@NL@%
        OutP$ = ""%@NL@%
        FOR TileByte% = 1 TO LEN(InP$)%@NL@%
                RefTile% = ASC(MID$(InP$, TileByte%, 1))%@NL@%
%@NL@%
%@AB@%                ' Combine each bit-plane in the color mask with the pattern byte:%@AE@%%@NL@%
                FOR Plane% = 1 TO Bits%%@NL@%
                        OutP$ = OutP$ + CHR$(RefTile% AND CMask%(Plane%))%@NL@%
                NEXT Plane%%@NL@%
        NEXT TileByte%%@NL@%
%@NL@%
%@AB@%        ' Return the completed pattern:%@AE@%%@NL@%
        clBuildPlaneP$ = OutP$%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== clChkChartWindow - Makes sure the chart window is valid%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env   -  A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Changes global parameters for chart window%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     This routine forces the chart window to be valid.  If the input%@AE@%%@NL@%
%@AB@%'     values are invalid a full screen is chosen.  The valid chart window%@AE@%%@NL@%
%@AB@%'     is stored in the global parameter set and used by other charting%@AE@%%@NL@%
%@AB@%'     routines.  The last valid screen set by ChartScreen is used as%@AE@%%@NL@%
%@AB@%'     reference.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clChkChartWindow (Env AS ChartEnvironment)%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' Make sure X1 < X2:%@AE@%%@NL@%
        IF Env.ChartWindow.X1 < Env.ChartWindow.X2 THEN%@NL@%
                GP.CwX1 = Env.ChartWindow.X1%@NL@%
                GP.CwX2 = Env.ChartWindow.X2%@NL@%
        ELSE%@NL@%
                GP.CwX1 = Env.ChartWindow.X2%@NL@%
                GP.CwX2 = Env.ChartWindow.X1%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Make sure Y1 < Y2:%@AE@%%@NL@%
        IF Env.ChartWindow.Y1 < Env.ChartWindow.Y2 THEN%@NL@%
                GP.CwY1 = Env.ChartWindow.Y1%@NL@%
                GP.CwY2 = Env.ChartWindow.Y2%@NL@%
        ELSE%@NL@%
                GP.CwY1 = Env.ChartWindow.Y2%@NL@%
                GP.CwY2 = Env.ChartWindow.Y1%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' If the X coordinates of the chart window are invalid,%@AE@%%@NL@%
%@AB@%        ' set them to full screen:%@AE@%%@NL@%
        IF GP.CwX1 < 0 OR GP.CwX2 >= GP.MaxXPix OR GP.CwX1 = GP.CwX2 THEN%@NL@%
                GP.CwX1 = 0%@NL@%
                GP.CwX2 = GP.MaxXPix - 1%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' If the Y coordinates of the chart window are invalid,%@AE@%%@NL@%
%@AB@%        ' set them to full screen:%@AE@%%@NL@%
        IF GP.CwY1 < 0 OR GP.CwY2 >= GP.MaxYPix OR GP.CwY1 = GP.CwY2 THEN%@NL@%
                GP.CwY1 = 0%@NL@%
                GP.CwY2 = GP.MaxYPix - 1%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Set chart height and width for use later:%@AE@%%@NL@%
        GP.ChartWid = GP.CwX2 - GP.CwX1 + 1%@NL@%
        GP.ChartHgt = GP.CwY2 - GP.CwY1 + 1%@NL@%
%@NL@%
%@AB@%        ' Put the valid coordinates in Env:%@AE@%%@NL@%
        Env.ChartWindow.X1 = GP.CwX1%@NL@%
        Env.ChartWindow.Y1 = GP.CwY1%@NL@%
        Env.ChartWindow.X2 = GP.CwX2%@NL@%
        Env.ChartWindow.Y2 = GP.CwY2%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clChkFonts - Checks that there is at least one loaded font%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Chart error set if no room for a font%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clChkFonts%@NL@%
%@NL@%
%@AB@%        ' See if a font is loaded:%@AE@%%@NL@%
        GetTotalFonts Reg%, Load%%@NL@%
%@NL@%
%@AB@%        ' If not then find out the maximum number of fonts allowed and if%@AE@%%@NL@%
%@AB@%        ' there's room, then load the default font:%@AE@%%@NL@%
        IF Load% <= 0 THEN%@NL@%
                GetMaxFonts MReg%, MLoad%%@NL@%
                IF Reg% < MReg% AND Load% < MLoad% THEN%@NL@%
                        DefaultFont Segment%, Offset%%@NL@%
                        FontNum% = RegisterMemFont(Segment%, Offset%)%@NL@%
                        FontNum% = LoadFont("N" + STR$(Load% + 1))%@NL@%
%@NL@%
%@AB@%                ' If there's no room, then set an error:%@AE@%%@NL@%
                ELSE%@NL@%
                        clSetError cNoFontSpace%@NL@%
                END IF%@NL@%
        END IF%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== CheckForErrors - Checks for and tries to fix a variety of errors%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env      -  ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     TypeMin% -  Minimum allowable ChartType%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     TypeMax% -  Maximum allowable ChartType%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%       -  Number of data values per series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     First%   -  Column of data representing first series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Last%    -  Column of data representing last series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     This routine is the main one that checks for errors of input in%@AE@%%@NL@%
%@AB@%'     the ChartEnvironment variable and routine parameters.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clChkForErrors (Env AS ChartEnvironment, TypeMin%, TypeMax%, N%, First%, Last%)%@NL@%
%@NL@%
%@AB@%        ' Clear any previous error:%@AE@%%@NL@%
        clClearError%@NL@%
%@NL@%
%@AB@%        ' Check for correct chart type:%@AE@%%@NL@%
        IF Env.ChartType < TypeMin% OR Env.ChartType > TypeMax% THEN%@NL@%
                clSetError cBadType%@NL@%
                EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Check for valid chart style:%@AE@%%@NL@%
        IF Env.ChartStyle < 1 OR Env.ChartStyle > 2 THEN%@NL@%
                clSetError cBadStyle%@NL@%
                Env.ChartStyle = 1%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' The following things are not relevant for pie charts:%@AE@%%@NL@%
        IF Env.ChartType <> cPie THEN%@NL@%
%@NL@%
%@AB@%                ' Check LogBase for the X axis (default to 10):%@AE@%%@NL@%
                IF Env.XAxis.RangeType = cLog AND Env.XAxis.LogBase <= 0 THEN%@NL@%
                        clSetError cBadLogBase%@NL@%
                        Env.XAxis.LogBase = 10%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Check LogBase for the Y axis (default to 10):%@AE@%%@NL@%
                IF Env.YAxis.RangeType = cLog AND Env.YAxis.LogBase <= 0 THEN%@NL@%
                        clSetError cBadLogBase%@NL@%
                        Env.YAxis.LogBase = 10%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Check X axis ScaleFactor:%@AE@%%@NL@%
                IF Env.XAxis.AutoScale <> cYes AND Env.XAxis.ScaleFactor = 0 THEN%@NL@%
                        clSetError cBadScaleFactor%@NL@%
                        Env.XAxis.ScaleFactor = 1%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Check Y axis ScaleFactor:%@AE@%%@NL@%
                IF Env.YAxis.AutoScale <> cYes AND Env.YAxis.ScaleFactor = 0 THEN%@NL@%
                        clSetError cBadScaleFactor%@NL@%
                        Env.YAxis.ScaleFactor = 1%@NL@%
                END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Make sure N > 0:%@AE@%%@NL@%
        IF N% <= 0 THEN%@NL@%
                clSetError cTooSmallN%@NL@%
                EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Check that First series <= Last one:%@AE@%%@NL@%
        IF First% > Last% THEN%@NL@%
                clSetError cTooFewSeries%@NL@%
                EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Force ChartWindow to be valid:%@AE@%%@NL@%
        clChkChartWindow Env%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clChkInit - Check that chartlib has been initialized%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clChkInit%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
        IF NOT GP.Initialized THEN clInitChart%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clChkPalettes - Makes sure that palettes are dimensioned correctly%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     C%()     -  Color palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     S%()     -  Style palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     P$()     -  Pattern palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Char%()  -  Plot character palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     B%()     -  Border pattern palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Chart error may be set to cBadPalette%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clChkPalettes (C() AS INTEGER, s() AS INTEGER, P$(), Char() AS INTEGER, B() AS INTEGER)%@NL@%
%@NL@%
%@AB@%        ' Check each palette array to be sure it is dimensioned from 0%@AE@%%@NL@%
%@AB@%        ' to cPalLen:%@AE@%%@NL@%
        FOR i% = 1 TO 5%@NL@%
                SELECT CASE i%%@NL@%
                        CASE 1:  L% = LBOUND(C, 1): U% = UBOUND(C, 1)%@NL@%
                        CASE 2:  L% = LBOUND(s, 1): U% = UBOUND(s, 1)%@NL@%
                        CASE 3:  L% = LBOUND(P$, 1): U% = UBOUND(P$, 1)%@NL@%
                        CASE 4:  L% = LBOUND(Char, 1): U% = UBOUND(Char, 1)%@NL@%
                        CASE 5:  L% = LBOUND(B, 1): U% = UBOUND(B, 1)%@NL@%
                END SELECT%@NL@%
%@NL@%
%@AB@%                ' If incorrectly dimensioned then set error:%@AE@%%@NL@%
                IF (L% <> 0) OR (U% <> cPalLen) THEN%@NL@%
                        clSetError cBadPalette%@NL@%
                        EXIT SUB%@NL@%
                END IF%@NL@%
        NEXT i%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clClearError - Clears ChartErr, the ChartLib error variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Sets ChartErr to 0%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clClearError%@NL@%
%@NL@%
        ChartErr = 0%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clColorMaskH% - Function to generate a byte with each pixel set to%@AE@%%@NL@%
%@AB@%'                  some color - for high-res modes (7,8,9,10)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Bits%    -  Number of bits per pixel in current screen mode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Colr%    -  Color to make the mask%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     CMask%() -  One dimensional array to place mask values in%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Screen modes 7, 8, 9 and 10 use bit planes.  Rather than using%@AE@%%@NL@%
%@AB@%'     adjacent bits in one byte to determine a color, they use bits%@AE@%%@NL@%
%@AB@%'     "stacked" on top of each other in different bytes.  This routine%@AE@%%@NL@%
%@AB@%'     generates one byte of a particular color by setting the different%@AE@%%@NL@%
%@AB@%'     levels of the stack to &H00 and &HFF to represent eight pixels%@AE@%%@NL@%
%@AB@%'     of a particular color.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clColorMaskH (Bits%, Colr%, CMask%())%@NL@%
%@NL@%
%@AB@%        ' Copy the color to a local variable:%@AE@%%@NL@%
        RefColor% = Colr%%@NL@%
%@NL@%
%@AB@%        ' Bits% is the number of bit planes, set a mask for each one:%@AE@%%@NL@%
        FOR i% = 1 TO Bits%%@NL@%
%@NL@%
%@AB@%                ' Check rightmost bit in color, if it is set to 1 then this plane is%@AE@%%@NL@%
%@AB@%                ' "on" (it equals &HFF):%@AE@%%@NL@%
                IF RefColor% MOD 2 <> 0 THEN%@NL@%
                        CMask%(i%) = &HFF%@NL@%
%@NL@%
%@AB@%                ' If the bit is 0, the plane is off (it equals &H0):%@AE@%%@NL@%
                ELSE%@NL@%
                        CMask%(i%) = &H0%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Shift the reference color right by one bit:%@AE@%%@NL@%
                RefColor% = RefColor% \ 2%@NL@%
        NEXT i%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clColorMaskL% - Function to generate a byte with each pixel set to%@AE@%%@NL@%
%@AB@%'                 some color.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Bits%    -  Number of bits per pixel in current screen mode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Colr%    -  Color to make the mask%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Returns integer with low byte that contains definitions for%@AE@%%@NL@%
%@AB@%'     pixels of specified color.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION clColorMaskL% (Bits%, Colr%)%@NL@%
%@NL@%
%@AB@%        ' Initialize the mask to zero:%@AE@%%@NL@%
        M% = 0%@NL@%
%@NL@%
%@AB@%        ' Multiplying a number by (2 ^ Bits%) will shift it left by "Bits%" bits:%@AE@%%@NL@%
        LShift% = 2 ^ Bits%%@NL@%
%@NL@%
%@AB@%        ' Create a byte in which each pixel (of "Bits%" bits) is set to%@AE@%%@NL@%
%@AB@%        ' Colr%.  This is done by setting the mask to "Colr%" then shifting%@AE@%%@NL@%
%@AB@%        ' it left by "Bits%" and repeating until the byte is full:%@AE@%%@NL@%
        FOR i% = 0 TO 7 \ Bits%%@NL@%
                M% = M% * LShift% + Colr%%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' Return the mask as the value of the function:%@AE@%%@NL@%
        clColorMaskL% = M% MOD 256%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== clDrawAxes - Draws the axes for a chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Cat$(1)  -  One-dimensional array or category names for use in%@AE@%%@NL@%
%@AB@%'                 labeling the category axis (ignored if category%@AE@%%@NL@%
%@AB@%'                 axis not used)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     No return values%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clDrawAxes (Cat$())%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED GFI AS FontInfo%@NL@%
SHARED PaletteC%(), PaletteB%()%@NL@%
%@NL@%
%@AB@%        ' Use temporary variables to refer to axis limits:%@AE@%%@NL@%
        X1 = GE.XAxis.ScaleMin%@NL@%
        X2 = GE.XAxis.ScaleMax%@NL@%
        Y1 = GE.YAxis.ScaleMin%@NL@%
        Y2 = GE.YAxis.ScaleMax%@NL@%
%@NL@%
%@AB@%        ' To draw the tic/grid lines it is necessary to know where the line%@AE@%%@NL@%
%@AB@%        ' starts and ends.  If tic marks are specified (by setting%@AE@%%@NL@%
%@AB@%        ' the "labeled" flag in the axis definition) then the%@AE@%%@NL@%
%@AB@%        ' tic lines start "ticwidth" below or to the left of the X and%@AE@%%@NL@%
%@AB@%        ' Y axis respectively.  If grid lines are specified then the%@AE@%%@NL@%
%@AB@%        ' tic/grid line ends at ScaleMax for the respective axis.  The%@AE@%%@NL@%
%@AB@%        ' case statements below calculate where the tic/grid lines start%@AE@%%@NL@%
%@AB@%        ' based on the above criteria.%@AE@%%@NL@%
%@NL@%
%@AB@%        ' Check for tic marks first (X Axis):%@AE@%%@NL@%
        SELECT CASE GE.XAxis.Labeled%@NL@%
                CASE cNo:  XTicMinY = Y1%@NL@%
                CASE ELSE%@NL@%
                        XTicMinY = Y1 - cTicSize * (Y2 - Y1)%@NL@%
                        IF GP.XStagger = cYes THEN%@NL@%
                                clSetChartFont GE.XAxis.TicFont%@NL@%
                                XTicDropY = GFI.PixHeight * (Y2 - Y1) / (GE.DataWindow.Y2 - GE.DataWindow.Y1)%@NL@%
                        ELSE%@NL@%
                                XTicDropY = 0%@NL@%
                        END IF%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' (Y Axis):%@AE@%%@NL@%
        SELECT CASE GE.YAxis.Labeled%@NL@%
                CASE cNo:  YTicMinX = X1%@NL@%
                CASE ELSE: YTicMinX = X1 - cTicSize * (X2 - X1)%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Now for the other end of the tic/grid lines check for%@AE@%%@NL@%
%@AB@%        ' the grid flag (X axis):%@AE@%%@NL@%
        SELECT CASE GE.XAxis.grid%@NL@%
                CASE cNo:  XTicMaxY = Y1%@NL@%
                CASE ELSE: XTicMaxY = Y2%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' (Y Axis):%@AE@%%@NL@%
        SELECT CASE GE.YAxis.grid%@NL@%
                CASE cNo:  YTicMaxX = X1%@NL@%
                CASE ELSE: YTicMaxX = X2%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Now that the beginning and end of the tic/grid lines has been%@AE@%%@NL@%
%@AB@%        ' calculated, it is necessary to figure out where they fall along the%@AE@%%@NL@%
%@AB@%        ' axes.  This depends on the type of axis: category or value.  On a%@AE@%%@NL@%
%@AB@%        ' category axis the tic/grid lines should fall in the middle of each%@AE@%%@NL@%
%@AB@%        ' bar set.  This is calculated by adding 1/2 of TicInterval to%@AE@%%@NL@%
%@AB@%        ' the beginning of the axis.  On a value axis the tic/grid line%@AE@%%@NL@%
%@AB@%        ' falls at the beginning of the axis.  It is also necessary to know%@AE@%%@NL@%
%@AB@%        ' the total number of tics per axis.  The following CASE statements%@AE@%%@NL@%
%@AB@%        ' calculate this.  Once the first tic/grid location on an axis is%@AE@%%@NL@%
%@AB@%        ' calculated the others can be calculated as they are drawn by adding%@AE@%%@NL@%
%@AB@%        ' TicInterval each time to the position of the previous tic mark:%@AE@%%@NL@%
%@NL@%
%@AB@%        ' Location of the first (leftmost) tic/grid line on the X axis:%@AE@%%@NL@%
        TicTotX% = CINT((X2 - X1) / GE.XAxis.TicInterval)%@NL@%
        SELECT CASE GP.XMode%@NL@%
                CASE cCategory: TicX = X1 + GE.XAxis.TicInterval / 2%@NL@%
                CASE ELSE%@NL@%
                        TicX = X1%@NL@%
                        TicTotX% = TicTotX% + 1%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Location of the first (top) tic/grid line on the Y axis:%@AE@%%@NL@%
        TicTotY% = CINT((Y2 - Y1) / GE.YAxis.TicInterval)%@NL@%
        SELECT CASE GP.YMode%@NL@%
                CASE cCategory: TicY = Y1 + GE.YAxis.TicInterval / 2%@NL@%
                CASE ELSE%@NL@%
                        TicY = Y1%@NL@%
                        TicTotY% = TicTotY% + 1%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Now it's time to draw the axes; first the X then the Y axis.%@AE@%%@NL@%
%@AB@%        ' There's a small complexity that has to be dealt with first, though.%@AE@%%@NL@%
%@AB@%        ' The tic/grid lines are specified in "world" coordinates since that%@AE@%%@NL@%
%@AB@%        ' is easier to calculate but the current VIEW (the DataWindow) would%@AE@%%@NL@%
%@AB@%        ' clip them since tic marks (and also labels) lie outside of that%@AE@%%@NL@%
%@AB@%        ' region.  The solution is to extrapolate the DataWindow "world" to the%@AE@%%@NL@%
%@AB@%        ' ChartWindow region and set our VIEW to the ChartWindow.  This will%@AE@%%@NL@%
%@AB@%        ' clip labels if they are too long and try to go outside the Chart%@AE@%%@NL@%
%@AB@%        ' Window but still allow use of world coordinates for specifying%@AE@%%@NL@%
%@AB@%        ' locations.  To extrapolate the world coordinates to the ChartWindow,%@AE@%%@NL@%
%@AB@%        ' PMAP can be used.  This works since PMAP can take pixel coordinates%@AE@%%@NL@%
%@AB@%        ' outside of the current VIEW and map them to the appropriate world%@AE@%%@NL@%
%@AB@%        ' coordinates.  The DataWindow coordinates (calculated in the routine%@AE@%%@NL@%
%@AB@%        ' clSizeDataWindow) are expressed relative to the ChartWindow so%@AE@%%@NL@%
%@AB@%        ' it can be somewhat complicated trying to understand what to use with%@AE@%%@NL@%
%@AB@%        ' PMAP.  If you draw a picture of it things will appear more straight%@AE@%%@NL@%
%@AB@%        ' forward.%@AE@%%@NL@%
%@NL@%
%@AB@%        ' To make sure that bars and columns aren't drawn over the axis lines%@AE@%%@NL@%
%@AB@%        ' temporarily move the left DataWindow border left by one and the bottom%@AE@%%@NL@%
%@AB@%        ' border down by one pixel:%@AE@%%@NL@%
        GE.DataWindow.X1 = GE.DataWindow.X1 - 1%@NL@%
        GE.DataWindow.Y2 = GE.DataWindow.Y2 + 1%@NL@%
%@NL@%
%@AB@%        ' Select the DataWindow view and assign the "world" to it:%@AE@%%@NL@%
        clSelectRelWindow GE.DataWindow%@NL@%
        WINDOW (X1, Y1)-(X2, Y2)%@NL@%
        GTextWindow X1, Y1, X2, Y2, cFalse%@NL@%
%@NL@%
%@AB@%        ' Next, use PMAP to extrapolate to ChartWindow:%@AE@%%@NL@%
        WorldX1 = PMAP(-GE.DataWindow.X1, 2)%@NL@%
        WorldX2 = PMAP(GP.ChartWid - 1 - GE.DataWindow.X1, 2)%@NL@%
%@NL@%
        WorldY1 = PMAP(GP.ChartHgt - 1 - GE.DataWindow.Y1, 3)%@NL@%
        WorldY2 = PMAP(-GE.DataWindow.Y1, 3)%@NL@%
%@NL@%
%@AB@%        ' Reset the DataWindow borders back to their original settings:%@AE@%%@NL@%
        GE.DataWindow.X1 = GE.DataWindow.X1 + 1%@NL@%
        GE.DataWindow.Y2 = GE.DataWindow.Y2 - 1%@NL@%
%@NL@%
%@AB@%        ' Finally, select the ChartWindow VIEW and apply the extrapolated%@AE@%%@NL@%
%@AB@%        ' window to it:%@AE@%%@NL@%
        clSelectChartWindow%@NL@%
        WINDOW (WorldX1, WorldY1)-(WorldX2, WorldY2)%@NL@%
        GTextWindow WorldX1, WorldY1, WorldX2, WorldY2, cFalse%@NL@%
%@NL@%
%@AB@%         ' Draw the X and Y axes (one pixel to left and bottom of window):%@AE@%%@NL@%
        CX% = PaletteC%(clMap2Pal%(GE.XAxis.AxisColor))  ' Color of X axis%@NL@%
        CY% = PaletteC%(clMap2Pal%(GE.YAxis.AxisColor))  ' Color of Y axis%@NL@%
%@NL@%
        SX% = PaletteB%(clMap2Pal%(GE.XAxis.GridStyle)) ' Line styles; X grid%@NL@%
        SY% = PaletteB%(clMap2Pal%(GE.YAxis.GridStyle)) ' Line styles; Y grid%@NL@%
%@NL@%
        LINE (X1, Y1)-(X2, Y1), CX%%@NL@%
        LINE (X1, Y1)-(X1, Y2), CY%%@NL@%
%@NL@%
%@AB@%        ' X-Axis...Draw styled grid line then solid tic mark:%@AE@%%@NL@%
        TicLoc = TicX%@NL@%
        Stagger% = cFalse%@NL@%
        FOR i% = 1 TO TicTotX%%@NL@%
                LINE (TicLoc, Y1)-(TicLoc, XTicMaxY), CY%, , SX%%@NL@%
                IF Stagger% THEN%@NL@%
                        LINE (TicLoc, XTicMinY - XTicDropY)-(TicLoc, Y1), CX%%@NL@%
                        Stagger% = cFalse%@NL@%
                ELSE%@NL@%
                        LINE (TicLoc, XTicMinY)-(TicLoc, Y1), CX%%@NL@%
                        Stagger% = cTrue%@NL@%
                END IF%@NL@%
                TicLoc = TicLoc + GE.XAxis.TicInterval%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' Y-Axis...Draw styled grid line then solid tic mark:%@AE@%%@NL@%
        TicLoc = TicY%@NL@%
        FOR i% = 1 TO TicTotY%%@NL@%
                LINE (X1, TicLoc)-(YTicMaxX, TicLoc), CX%, , SY%%@NL@%
                LINE (YTicMinX, TicLoc)-(X1, TicLoc), CY%%@NL@%
                TicLoc = TicLoc + GE.YAxis.TicInterval%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' Label X tic marks and print titles:%@AE@%%@NL@%
        clLabelXTics GE.XAxis, Cat$(), TicX, TicTotX%, XTicMinY, YBoundry%%@NL@%
        clTitleXAxis GE.XAxis, GE.DataWindow.X1, GE.DataWindow.X2, YBoundry%%@NL@%
%@NL@%
%@AB@%        ' Label Y tic marks and print titles:%@AE@%%@NL@%
        clLabelYTics GE.YAxis, Cat$(), YTicMinX, TicY, TicTotY%%@NL@%
        clTitleYAxis GE.YAxis, GE.DataWindow.Y1, GE.DataWindow.Y2%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clDrawBarData - Draws data portion of multi-series bar chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clDrawBarData%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED PaletteC%()%@NL@%
SHARED V1()%@NL@%
%@NL@%
%@AB@%        ' Set the VIEW to the DataWindow:%@AE@%%@NL@%
        clSelectRelWindow GE.DataWindow%@NL@%
%@NL@%
%@AB@%        ' Set the WINDOW to match:%@AE@%%@NL@%
        WINDOW (GE.XAxis.ScaleMin, GE.YAxis.ScaleMin)-(GE.XAxis.ScaleMax, GE.YAxis.ScaleMax)%@NL@%
        GTextWindow GE.XAxis.ScaleMin, GE.YAxis.ScaleMin, GE.XAxis.ScaleMax, GE.YAxis.ScaleMax, cFalse%@NL@%
%@NL@%
%@AB@%        ' If this is a linear axis then determine where the bars should grow from:%@AE@%%@NL@%
        IF GE.XAxis.RangeType = cLinear THEN%@NL@%
%@NL@%
%@AB@%                ' If the scale minimum and maximum are on opposite sides of zero%@AE@%%@NL@%
%@AB@%                ' set the bar starting point to zero:%@AE@%%@NL@%
                IF GE.XAxis.ScaleMin < 0 AND GE.XAxis.ScaleMax > 0 THEN%@NL@%
                        BarMin = 0%@NL@%
%@NL@%
%@AB@%                ' If the axis range is all negative the the bars should grow from%@AE@%%@NL@%
%@AB@%                ' the right to the left so make the bar starting point the scale%@AE@%%@NL@%
%@AB@%                ' maximum:%@AE@%%@NL@%
                ELSEIF GE.XAxis.ScaleMin < 0 THEN%@NL@%
                        BarMin = GE.XAxis.ScaleMax%@NL@%
%@NL@%
%@AB@%                ' The axis range is all positive so the bar starting point is the%@AE@%%@NL@%
%@AB@%                ' scale minimum:%@AE@%%@NL@%
                ELSE%@NL@%
                        BarMin = GE.XAxis.ScaleMin%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%        ' The bar starting point for log axes should always be the scale minimum%@AE@%%@NL@%
%@AB@%        ' since only positive numbers are represented on a log axis (even though%@AE@%%@NL@%
%@AB@%        ' the log of small numbers is negative):%@AE@%%@NL@%
        ELSE%@NL@%
                BarMin = GE.XAxis.ScaleMin%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Calculate the width of a bar.  Divide by the number of%@AE@%%@NL@%
%@AB@%        ' series if it's a plain (not stacked) chart:%@AE@%%@NL@%
        BarWid = GE.YAxis.TicInterval * cBarWid%@NL@%
        IF GE.ChartStyle = cPlain THEN BarWid = BarWid / GP.NSeries%@NL@%
%@NL@%
%@AB@%        ' Calculate the beginning Y value of first bar then loop drawing%@AE@%%@NL@%
%@AB@%        ' all the bars:%@AE@%%@NL@%
        SpaceWid = GE.YAxis.TicInterval * (1 - cBarWid)%@NL@%
        StartLoc = GE.YAxis.ScaleMax - SpaceWid / 2%@NL@%
%@NL@%
        FOR i% = 1 TO GP.NVals%@NL@%
%@NL@%
%@AB@%                ' Reset sum variables for positive and negative stacked bars:%@AE@%%@NL@%
                RSumPos = 0%@NL@%
                RSumNeg = 0%@NL@%
%@NL@%
%@AB@%                ' Reset the bar starting points:%@AE@%%@NL@%
                BarStartPos = BarMin%@NL@%
                BarStartNeg = BarMin%@NL@%
%@NL@%
%@AB@%                ' Reset starting Y location of this bar set:%@AE@%%@NL@%
                BarLoc = StartLoc%@NL@%
%@NL@%
%@AB@%                ' Now, chart the different series for this category:%@AE@%%@NL@%
                FOR J% = 1 TO GP.NSeries%@NL@%
%@NL@%
%@AB@%                        ' Get the value to chart from the data array:%@AE@%%@NL@%
                        V = V1(i%, J%)%@NL@%
%@NL@%
%@AB@%                        ' If the value isn't a missing one then try to chart it:%@AE@%%@NL@%
                        IF V <> cMissingValue THEN%@NL@%
%@NL@%
%@AB@%                                ' If the X-axis has the AutoScale flag set then divide%@AE@%%@NL@%
%@AB@%                                ' the value by the axis' ScaleFactor variable:%@AE@%%@NL@%
                                IF GE.XAxis.AutoScale = cYes THEN V = V / GE.XAxis.ScaleFactor%@NL@%
%@NL@%
%@AB@%                                ' If this is a plain chart then calculate the bar's location%@AE@%%@NL@%
%@AB@%                                ' and draw it:%@AE@%%@NL@%
                                IF GE.ChartStyle = cPlain THEN%@NL@%
%@NL@%
                                        BarLoc = StartLoc - (J% - 1) * BarWid%@NL@%
                                        clRenderBar BarMin, BarLoc, V, BarLoc - BarWid, J%%@NL@%
%@NL@%
%@AB@%                                ' If the bars should be stacked then draw either a positive or%@AE@%%@NL@%
%@AB@%                                ' negative portion of a bar depending on whether the data value%@AE@%%@NL@%
%@AB@%                                ' is positive or negative:%@AE@%%@NL@%
                                ELSE%@NL@%
%@NL@%
%@AB@%                                        ' If the value is positive:%@AE@%%@NL@%
                                        IF V > 0 THEN%@NL@%
%@NL@%
%@AB@%                                                ' Add the value to the current sum for the bar and draw%@AE@%%@NL@%
%@AB@%                                                ' the bar from the top of the last portion:%@AE@%%@NL@%
                                                RSumPos = RSumPos + V%@NL@%
                                                clRenderBar BarStartPos, BarLoc, RSumPos, BarLoc - BarWid, J%%@NL@%
                                                BarStartPos = RSumPos%@NL@%
%@NL@%
%@AB@%                                        ' If the value is negative:%@AE@%%@NL@%
                                        ELSE%@NL@%
%@NL@%
%@AB@%                                                ' Add the value to the current sum for the bar and draw%@AE@%%@NL@%
%@AB@%                                                ' the bar from the bottom of the last portion:%@AE@%%@NL@%
                                                RSumNeg = RSumNeg + V%@NL@%
                                                clRenderBar BarStartNeg, BarLoc, RSumNeg, BarLoc - BarWid, J%%@NL@%
                                                BarStartNeg = RSumNeg%@NL@%
%@NL@%
                                        END IF%@NL@%
                                END IF%@NL@%
                        END IF%@NL@%
%@NL@%
                NEXT J%%@NL@%
%@NL@%
%@AB@%                ' Update the bar cluster's starting location:%@AE@%%@NL@%
                StartLoc = StartLoc - GE.YAxis.TicInterval%@NL@%
%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' If BarMin isn't the axis minimum then draw a reference line:%@AE@%%@NL@%
        IF BarMin <> GE.XAxis.ScaleMin THEN%@NL@%
                LINE (BarMin, GE.YAxis.ScaleMin)-(BarMin, GE.YAxis.ScaleMax), PaletteC%(clMap2Pal%(GE.YAxis.AxisColor))%@NL@%
        END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clDrawChartWindow - Draws the Chart window%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     This routine erases any previous viewport%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clDrawChartWindow%@NL@%
SHARED GE AS ChartEnvironment%@NL@%
%@NL@%
%@AB@%        ' Define viewport then render window:%@AE@%%@NL@%
        clSelectChartWindow%@NL@%
        clRenderWindow GE.ChartWindow%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clDrawColumnData - Draws data portion of MS Column chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clDrawColumnData%@NL@%
SHARED GP AS GlobalParams, GE AS ChartEnvironment%@NL@%
SHARED PaletteC%(), V1()%@NL@%
%@NL@%
%@AB@%        ' First, set the VIEW to DataWindow:%@AE@%%@NL@%
        clSelectRelWindow GE.DataWindow%@NL@%
%@NL@%
%@AB@%        ' Set the WINDOW to match:%@AE@%%@NL@%
        WINDOW (GE.XAxis.ScaleMin, GE.YAxis.ScaleMin)-(GE.XAxis.ScaleMax, GE.YAxis.ScaleMax)%@NL@%
        GTextWindow GE.XAxis.ScaleMin, GE.YAxis.ScaleMin, GE.XAxis.ScaleMax, GE.YAxis.ScaleMax, cFalse%@NL@%
%@NL@%
%@AB@%        ' If this is a linear axis then determine where the bars should grow from:%@AE@%%@NL@%
        IF GE.YAxis.RangeType = cLinear THEN%@NL@%
%@NL@%
%@AB@%                ' Draw 0 reference line if the scale minimum and maximum are on%@AE@%%@NL@%
%@AB@%                ' opposite sides of zero.  Also set the bar starting point to zero%@AE@%%@NL@%
%@AB@%                ' so that bars grow from the zero line:%@AE@%%@NL@%
                IF GE.YAxis.ScaleMin < 0 AND GE.YAxis.ScaleMax > 0 THEN%@NL@%
                        BarMin = 0%@NL@%
%@NL@%
%@AB@%                ' If the axis range is all negative the the bars should grow from%@AE@%%@NL@%
%@AB@%                ' the right to the left so make the bar starting point the scale%@AE@%%@NL@%
%@AB@%                ' maximum:%@AE@%%@NL@%
                ELSEIF GE.YAxis.ScaleMin < 0 THEN%@NL@%
                        BarMin = GE.YAxis.ScaleMax%@NL@%
%@NL@%
%@AB@%                ' The axis range is all positive so the bar starting point is the%@AE@%%@NL@%
%@AB@%                ' scale minimum:%@AE@%%@NL@%
                ELSE%@NL@%
                        BarMin = GE.YAxis.ScaleMin%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%        ' The bar starting point for log axes should always be the scale minimum%@AE@%%@NL@%
%@AB@%        ' since only positive numbers are represented on a log axis (even though%@AE@%%@NL@%
%@AB@%        ' the log of small numbers is negative):%@AE@%%@NL@%
        ELSE%@NL@%
                BarMin = GE.YAxis.ScaleMin%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Calculate the width of a bar.  Divide by the number of%@AE@%%@NL@%
%@AB@%        ' series if it's a plain (not stacked) chart:%@AE@%%@NL@%
        BarWid = GE.XAxis.TicInterval * cBarWid%@NL@%
        IF GE.ChartStyle = cPlain THEN BarWid = BarWid / GP.NSeries%@NL@%
%@NL@%
%@AB@%        ' calculate the beginning X value of first bar and loop, drawing all%@AE@%%@NL@%
%@AB@%        ' the bars:%@AE@%%@NL@%
        SpaceWid = GE.XAxis.TicInterval * (1 - cBarWid)%@NL@%
        StartLoc = GE.XAxis.ScaleMin + SpaceWid / 2%@NL@%
%@NL@%
        FOR i% = 1 TO GP.NVals%@NL@%
%@NL@%
%@AB@%                ' Reset sum variables for positive and negative stacked bars:%@AE@%%@NL@%
                RSumPos = 0%@NL@%
                RSumNeg = 0%@NL@%
%@NL@%
                BarStartPos = BarMin%@NL@%
                BarStartNeg = BarMin%@NL@%
%@NL@%
%@AB@%                ' Reset starting Y location of this bar set:%@AE@%%@NL@%
                BarLoc = StartLoc%@NL@%
%@NL@%
%@AB@%                ' Now, go across the rows charting the different series for%@AE@%%@NL@%
%@AB@%                ' this category:%@AE@%%@NL@%
                FOR J% = 1 TO GP.NSeries%@NL@%
%@NL@%
%@AB@%                        ' Get the value to chart from the data array:%@AE@%%@NL@%
                        V = V1(i%, J%)%@NL@%
%@NL@%
%@AB@%                        ' If the value isn't a missing one then try to chart it:%@AE@%%@NL@%
                        IF V <> cMissingValue THEN%@NL@%
%@NL@%
%@AB@%                                ' If the Y-axis has the AutoScale flag set then divide%@AE@%%@NL@%
%@AB@%                                ' the value by the axis' ScaleFactor variable:%@AE@%%@NL@%
                                IF GE.YAxis.AutoScale = cYes THEN V = V / GE.YAxis.ScaleFactor%@NL@%
%@NL@%
%@AB@%                                ' If this is a plain chart then calculate the bar's location%@AE@%%@NL@%
%@AB@%                                ' and draw it:%@AE@%%@NL@%
                                IF GE.ChartStyle = cPlain THEN%@NL@%
%@NL@%
                                        BarLoc = StartLoc + (J% - 1) * BarWid%@NL@%
                                        clRenderBar BarLoc, BarMin, BarLoc + BarWid, V, J%%@NL@%
%@NL@%
%@AB@%                                ' If the bars should be stacked then draw either a positive or%@AE@%%@NL@%
%@AB@%                                ' negative portion of a bar depending on whether the data value%@AE@%%@NL@%
%@AB@%                                ' is positive or negative:%@AE@%%@NL@%
                                ELSE%@NL@%
%@NL@%
%@AB@%                                        ' If the value is positive:%@AE@%%@NL@%
                                        IF V > 0 THEN%@NL@%
%@NL@%
%@AB@%                                                ' Add the value to the current sum for the bar and draw%@AE@%%@NL@%
%@AB@%                                                ' the bar from the top of the last portion:%@AE@%%@NL@%
                                                RSumPos = RSumPos + V%@NL@%
                                                clRenderBar BarLoc, BarStartPos, BarLoc + BarWid, RSumPos, J%%@NL@%
                                                BarStartPos = RSumPos%@NL@%
%@NL@%
%@AB@%                                        ' If the value is negative:%@AE@%%@NL@%
                                        ELSE%@NL@%
%@NL@%
%@AB@%                                                ' Add the value to the current sum for the bar and draw%@AE@%%@NL@%
%@AB@%                                                ' the bar from the bottom of the last portion:%@AE@%%@NL@%
                                                RSumNeg = RSumNeg + V%@NL@%
                                                clRenderBar BarLoc, BarStartNeg, BarLoc + BarWid, RSumNeg, J%%@NL@%
                                                BarStartNeg = RSumNeg%@NL@%
%@NL@%
                                        END IF%@NL@%
                                END IF%@NL@%
                        END IF%@NL@%
%@NL@%
                NEXT J%%@NL@%
%@NL@%
%@AB@%                ' Update the bar cluster's starting location:%@AE@%%@NL@%
                StartLoc = StartLoc + GE.XAxis.TicInterval%@NL@%
%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' If BarMin isn't the axis minimum then draw a reference line:%@AE@%%@NL@%
        IF BarMin <> GE.YAxis.ScaleMin THEN%@NL@%
                LINE (GE.XAxis.ScaleMin, BarMin)-(GE.XAxis.ScaleMax, BarMin), PaletteC%(clMap2Pal%(GE.XAxis.AxisColor))%@NL@%
        END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clDrawDataWindow - Draws the Data window%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     This routine erases any previous viewport or window specification.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clDrawDataWindow%@NL@%
SHARED GE AS ChartEnvironment%@NL@%
%@NL@%
%@AB@%        ' Define viewport then render window:%@AE@%%@NL@%
        clSelectRelWindow GE.DataWindow%@NL@%
        clRenderWindow GE.DataWindow%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clDrawLegend - Draws a legend%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     SeriesLabel$(1)   - Array of labels for the legend%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     First%            - Label number corresponding to first series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Last%             - Label number corresponding to last series%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clDrawLegend (SeriesLabel$(), First AS INTEGER, Last AS INTEGER)%@NL@%
%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED PaletteC%(), PaletteP$(), PaletteCh%()%@NL@%
SHARED GFI AS FontInfo%@NL@%
SHARED LLayout AS LegendLayout%@NL@%
%@NL@%
%@AB@%        ' If legend flag is No then exit:%@AE@%%@NL@%
        IF GE.Legend.Legend = cNo THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Select and render the legend window:%@AE@%%@NL@%
        clSelectRelWindow GE.Legend.LegendWindow%@NL@%
        clRenderWindow GE.Legend.LegendWindow%@NL@%
        WINDOW%@NL@%
        GTextWindow 0, 0, 0, 0, cFalse%@NL@%
%@NL@%
%@AB@%        ' Start with the first label, set the Y position of the first line%@AE@%%@NL@%
%@AB@%        ' of labels and loop through all the rows in the legend:%@AE@%%@NL@%
        clSetChartFont GE.Legend.TextFont%@NL@%
        LabelNum% = First%@NL@%
        YPos% = LLayout.HorizBorder%@NL@%
        FOR i% = 1 TO LLayout.NumRow%@NL@%
%@NL@%
%@AB@%                ' Set position of beginning of row:%@AE@%%@NL@%
                XPos% = LLayout.VertBorder%@NL@%
%@NL@%
                FOR J% = 1 TO LLayout.NumCol%@NL@%
%@NL@%
%@AB@%                        ' Map the label number to a valid palette reference:%@AE@%%@NL@%
                        MJ% = clMap2Pal%(LabelNum% - First + 1)%@NL@%
%@NL@%
%@AB@%                        ' Depending on ChartType draw either a filled box or the%@AE@%%@NL@%
%@AB@%                        ' plot character used for plotting:%@AE@%%@NL@%
                        XStep% = LLayout.SymbolSize / GP.Aspect%@NL@%
                        SELECT CASE GE.ChartType%@NL@%
%@NL@%
                                CASE cBar, cColumn, cPie:%@NL@%
                                        LINE (XPos%, YPos%)-STEP(XStep%, LLayout.SymbolSize), 0, BF%@NL@%
                                        LINE (XPos%, YPos%)-STEP(XStep%, LLayout.SymbolSize), 1, B%@NL@%
                                        PAINT (XPos% + 1, YPos% + 1), PaletteP$(MJ%), 1%@NL@%
                                        LINE (XPos%, YPos%)-STEP(XStep%, LLayout.SymbolSize), PaletteC%(MJ%), B%@NL@%
%@NL@%
                                CASE cLine, cScatter:%@NL@%
                                        clSetCharColor MJ%%@NL@%
                                        PlotChr$ = CHR$(PaletteCh%(MJ%))%@NL@%
                                        clHPrint XPos% + XStep% - GFI.AvgWidth, YPos% - GFI.Leading, PlotChr$%@NL@%
%@NL@%
                        END SELECT%@NL@%
%@NL@%
%@AB@%                        ' Print the label for this entry in the legend:%@AE@%%@NL@%
                        clSetCharColor GE.Legend.TextColor%@NL@%
                        clHPrint XPos% + LLayout.LabelOffset, YPos% - GFI.Leading, SeriesLabel$(LabelNum%)%@NL@%
%@NL@%
%@AB@%                        ' Increment the label count and check count has finished:%@AE@%%@NL@%
                        LabelNum% = LabelNum% + 1%@NL@%
                        IF LabelNum% > Last THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%                        ' Move over to the next column:%@AE@%%@NL@%
                        XPos% = XPos% + LLayout.ColSpacing%@NL@%
%@NL@%
                NEXT J%%@NL@%
%@NL@%
%@AB@%                ' Move position to the next row:%@AE@%%@NL@%
                YPos% = YPos% + LLayout.RowSpacing%@NL@%
%@NL@%
        NEXT i%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clDrawLineData - Draws data portion line chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clDrawLineData%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED PaletteC%(), PaletteS%(), PaletteCh%()%@NL@%
SHARED GFI AS FontInfo%@NL@%
SHARED V1()%@NL@%
%@NL@%
%@AB@%        ' First, set the appropriate font and make text horizontal:%@AE@%%@NL@%
        clSetChartFont GE.DataFont%@NL@%
        SetGTextDir 0%@NL@%
%@NL@%
%@AB@%        ' Then, set the view to DataWindow:%@AE@%%@NL@%
        clSelectRelWindow GE.DataWindow%@NL@%
%@NL@%
%@AB@%        ' Set the window to match:%@AE@%%@NL@%
        WINDOW (GE.XAxis.ScaleMin, GE.YAxis.ScaleMin)-(GE.XAxis.ScaleMax, GE.YAxis.ScaleMax)%@NL@%
        GTextWindow GE.XAxis.ScaleMin, GE.YAxis.ScaleMin, GE.XAxis.ScaleMax, GE.YAxis.ScaleMax, cFalse%@NL@%
%@NL@%
%@AB@%        ' Loop through the series:%@AE@%%@NL@%
        FOR J% = 1 TO GP.NSeries%@NL@%
%@NL@%
%@AB@%                ' Map the series number into a valid palette reference:%@AE@%%@NL@%
                MJ% = clMap2Pal%(J%)%@NL@%
%@NL@%
%@AB@%                ' Calculate starting X location of first point and set%@AE@%%@NL@%
%@AB@%                ' last value to missing (since this is the first value in the%@AE@%%@NL@%
%@AB@%                ' series the last value wasn't there):%@AE@%%@NL@%
                StartLoc = GE.XAxis.ScaleMin + GE.XAxis.TicInterval / 2%@NL@%
                LastMissing% = cYes%@NL@%
%@NL@%
                FOR i% = 1 TO GP.NVals%@NL@%
%@NL@%
%@AB@%                        ' Get a value from the data array:%@AE@%%@NL@%
                        V = V1(i%, J%)%@NL@%
%@NL@%
%@AB@%                        ' If the value is missing, set the LastMissing flag to Yes and%@AE@%%@NL@%
%@AB@%                        ' go to the next value:%@AE@%%@NL@%
                        IF V = cMissingValue THEN%@NL@%
                                LastMissing% = cYes%@NL@%
%@NL@%
%@AB@%                        ' If the value is not missing then try to chart it:%@AE@%%@NL@%
                        ELSE%@NL@%
%@NL@%
%@AB@%                                ' Scale the value (and convert it to a log if this is a%@AE@%%@NL@%
%@AB@%                                ' Log axis):%@AE@%%@NL@%
                                IF GE.YAxis.AutoScale = cYes THEN V = V / GE.YAxis.ScaleFactor%@NL@%
%@NL@%
%@AB@%                                ' If the style dictates lines and the last point wasn't%@AE@%%@NL@%
%@AB@%                                ' missing then draw a line between the last point and this one:%@AE@%%@NL@%
                                IF GE.ChartStyle = cLines AND LastMissing% <> cYes THEN%@NL@%
                                        LINE -(StartLoc, V), PaletteC%(MJ%), , PaletteS%(MJ%)%@NL@%
                                END IF%@NL@%
%@NL@%
%@AB@%                                ' Position and print character:%@AE@%%@NL@%
                                CX% = PMAP(StartLoc, 0) - GetGTextLen(CHR$(PaletteCh%(MJ%))) / 2%@NL@%
                                CY% = PMAP(V, 1) - GFI.Ascent / 2%@NL@%
                                clSetCharColor MJ%%@NL@%
                                clHPrint CX%, CY%, CHR$(PaletteCh%(MJ%))%@NL@%
%@NL@%
                                PSET (StartLoc, V), POINT(StartLoc, V)%@NL@%
%@NL@%
                                LastMissing% = cNo%@NL@%
                        END IF%@NL@%
%@NL@%
%@AB@%                        ' Move to next category position:%@AE@%%@NL@%
                        StartLoc = StartLoc + GE.XAxis.TicInterval%@NL@%
                NEXT i%%@NL@%
        NEXT J%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clDrawPieData - Draws data part of a pie chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Value(1)    -  One-dimensional array of data values%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Expl(1)     -  One-dimensional array of explode flags (1=explode, 0=no)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%          -  The number of data values to plot%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clDrawPieData (value() AS SINGLE, Expl() AS INTEGER, N AS INTEGER)%@NL@%
SHARED GE AS ChartEnvironment%@NL@%
SHARED GP AS GlobalParams%@NL@%
SHARED GFI AS FontInfo%@NL@%
SHARED PaletteC%(), PaletteP$()%@NL@%
%@NL@%
%@AB@%        ' Set the font to use for percent labels:%@AE@%%@NL@%
        clSetChartFont GE.DataFont%@NL@%
%@NL@%
%@AB@%        ' Set up some reference variables:%@AE@%%@NL@%
        Pi2 = 2 * cPiVal                  ' 2*PI for radians conversions%@NL@%
        MinAngle = Pi2 / 120              ' Smallest wedge to try to paint%@NL@%
        A1 = -.0000001                    ' Starting and ending angle (set%@NL@%
        A2 = A1                           ' to very small negative to get%@NL@%
%@AB@%                                                                                                 ' radius line for first wedge)%@AE@%%@NL@%
%@NL@%
%@AB@%        ' Size the pie.%@AE@%%@NL@%
%@AB@%        ' Choose the point in the middle of the data window for the pie center:%@AE@%%@NL@%
        WINDOW (0, 0)-(1, 1)%@NL@%
        X = PMAP(.5, 0)                  ' Distance: left to center%@NL@%
        Y = PMAP(.5, 1)                  ' Distance: bottom to center%@NL@%
        WINDOW                           ' Now, use physical coordinates (pixels)%@NL@%
        GTextWindow 0, 0, 0, 0, cFalse%@NL@%
%@NL@%
%@AB@%        ' Adjust radii for percent labels if required:%@AE@%%@NL@%
        clSetChartFont GE.DataFont%@NL@%
        IF GE.ChartStyle = cPercent THEN%@NL@%
                RadiusX = (X - 6 * GFI.AvgWidth) * GP.Aspect%@NL@%
                RadiusY = Y - 2 * GFI.PixHeight%@NL@%
        ELSE%@NL@%
                RadiusX = X * GP.Aspect%@NL@%
                RadiusY = Y%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Pick the smallest radius (adjusted for screen aspect) then reduce%@AE@%%@NL@%
%@AB@%        ' it by 10% so the pie isn't too close to the window border:%@AE@%%@NL@%
        IF RadiusX < RadiusY THEN%@NL@%
                Radius = RadiusX%@NL@%
        ELSE%@NL@%
                Radius = RadiusY%@NL@%
        END IF%@NL@%
        Radius = (.9 * Radius) / GP.Aspect%@NL@%
%@NL@%
%@AB@%        ' If radius is too small then error:%@AE@%%@NL@%
        IF Radius <= 0 THEN%@NL@%
                clSetError cBadDataWindow%@NL@%
                EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Find the sum of the data values (use double precision Sum variable to%@AE@%%@NL@%
%@AB@%        ' protect against overflow if summing large data values):%@AE@%%@NL@%
        Sum# = 0%@NL@%
        FOR i% = 1 TO GP.NSeries%@NL@%
                IF value(i%) > 0 THEN Sum# = Sum# + value(i%)%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' Loop through drawing and painting the wedges:%@AE@%%@NL@%
        FOR i% = 1 TO N%@NL@%
%@NL@%
%@AB@%                ' Map I% to a valid palette reference:%@AE@%%@NL@%
                MappedI% = clMap2Pal(i%)%@NL@%
%@NL@%
%@AB@%                ' Draw wedges for positive values only:%@AE@%%@NL@%
                IF value(i%) > 0 THEN%@NL@%
%@NL@%
%@AB@%                        ' Calculate wedge percent and wedge ending angle:%@AE@%%@NL@%
                        Percent = value(i%) / Sum#%@NL@%
                        A2 = A1 - Percent * Pi2%@NL@%
%@NL@%
%@AB@%                        ' This locates the angle through the center of the pie wedge and%@AE@%%@NL@%
%@AB@%                        ' calculates X and Y components of the vector headed in that%@AE@%%@NL@%
%@AB@%                        ' direction:%@AE@%%@NL@%
                        Bisect = (A1 + A2) / 2%@NL@%
                        BisectX = Radius * COS(Bisect)%@NL@%
                        BisectY = Radius * SIN(Bisect) * GP.Aspect%@NL@%
%@NL@%
%@AB@%                        ' If the piece is exploded then offset it 1/10th of a radius%@AE@%%@NL@%
%@AB@%                        ' along the bisecting angle calculated above:%@AE@%%@NL@%
                        IF Expl(i%) <> 0 THEN%@NL@%
                                CX = X + .1 * BisectX%@NL@%
                                CY = Y + .1 * BisectY%@NL@%
                        ELSE%@NL@%
                                CX = X%@NL@%
                                CY = Y%@NL@%
                        END IF%@NL@%
%@NL@%
%@AB@%                        ' If the angle is large enough, paint the wedge (if wedges of%@AE@%%@NL@%
%@AB@%                        ' smaller angles are painted, the "paint" will sometimes spill out):%@AE@%%@NL@%
                        IF (A1 - A2) > MinAngle THEN%@NL@%
                                PX = CX + .8 * BisectX%@NL@%
                                PY = CY + .8 * BisectY%@NL@%
%@NL@%
%@AB@%                                ' Outline the wedge in color 1 and paint it black.%@AE@%%@NL@%
                                CIRCLE (CX, CY), Radius, 1, A1, A2, GP.Aspect%@NL@%
                                PAINT (PX, PY), 0, 1%@NL@%
%@AB@%                                ' Paint with the appropriate pattern:%@AE@%%@NL@%
                                PAINT (PX, PY), PaletteP$(MappedI%), 1%@NL@%
                        END IF%@NL@%
%@AB@%                        ' draw the wedge in the correct color:%@AE@%%@NL@%
                        CIRCLE (CX, CY), Radius, PaletteC%(MappedI%), A1, A2, GP.Aspect%@NL@%
%@NL@%
%@AB@%                        ' Label pie wedge with percent if appropriate:%@AE@%%@NL@%
                        IF GE.ChartStyle = cPercent THEN%@NL@%
                                Label$ = clVal2Str$(Percent * 100, 1, 1) + "%"%@NL@%
                                LabelX% = CX + BisectX + (GFI.AvgWidth * COS(Bisect))%@NL@%
                                LabelY% = CY + BisectY + (GFI.AvgWidth * SIN(Bisect)) * GP.Aspect%@NL@%
%@NL@%
%@AB@%                                ' Adjust label location for the quadrant:%@AE@%%@NL@%
                                Quadrant% = FIX((ABS(Bisect / Pi2)) * 4)%@NL@%
                                IF Quadrant% = 0 OR Quadrant% = 1 THEN%@NL@%
                                        LabelY% = LabelY% - GFI.Ascent%@NL@%
                                END IF%@NL@%
                                IF Quadrant% = 1 OR Quadrant% = 2 THEN%@NL@%
                                        LabelX% = LabelX% - GetGTextLen(Label$)%@NL@%
                                END IF%@NL@%
%@NL@%
                                clSetCharColor GE.Legend.TextColor%@NL@%
                                clHPrint LabelX%, LabelY%, Label$%@NL@%
                        END IF%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Set the beginning of next wedge to the end of this one:%@AE@%%@NL@%
                A1 = A2%@NL@%
%@NL@%
        NEXT i%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clDrawScatterData - Draws data portion of Scatter chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clDrawScatterData%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED PaletteC%(), PaletteS%(), PaletteCh%()%@NL@%
SHARED GFI AS FontInfo%@NL@%
SHARED V1(), V2()%@NL@%
%@NL@%
%@AB@%        ' Select the chart font and make text output horizontal:%@AE@%%@NL@%
        clSetChartFont GE.DataFont%@NL@%
        SetGTextDir 0%@NL@%
%@NL@%
%@AB@%        ' Now, loop through all the points charting them:%@AE@%%@NL@%
        FOR Series% = 1 TO GP.NSeries%@NL@%
%@NL@%
%@AB@%                ' Set LastMissing flag to Yes for first point in series:%@AE@%%@NL@%
                LastMissing% = cYes%@NL@%
                MS% = clMap2Pal%(Series%)%@NL@%
%@NL@%
%@AB@%                ' Loop through all the points, charting them:%@AE@%%@NL@%
                FOR DataPoint% = 1 TO GP.NVals%@NL@%
%@NL@%
%@AB@%                        ' Get the X-value and Y-values from the data arrays:%@AE@%%@NL@%
                        VX = V1(DataPoint%, Series%)%@NL@%
                        VY = V2(DataPoint%, Series%)%@NL@%
%@NL@%
%@AB@%                        ' If either of the values to chart is missing set LastMissing%@AE@%%@NL@%
%@AB@%                        ' flag to Yes to indicate a missing point and go to the next point:%@AE@%%@NL@%
                        IF VX = cMissingValue OR VY = cMissingValue THEN%@NL@%
                                LastMissing% = cYes%@NL@%
%@NL@%
                        ELSE%@NL@%
%@NL@%
%@AB@%                                ' Otherwise, scale the X and Y values if AutoScale is set for%@AE@%%@NL@%
%@AB@%                                ' their respective axes:%@AE@%%@NL@%
                                IF GE.XAxis.AutoScale = cYes THEN VX = VX / GE.XAxis.ScaleFactor%@NL@%
                                IF GE.YAxis.AutoScale = cYes THEN VY = VY / GE.YAxis.ScaleFactor%@NL@%
%@NL@%
%@AB@%                                ' If this is a lined chart and the last point wasn't missing,%@AE@%%@NL@%
%@AB@%                                ' then draw a line from last point to the current point:%@AE@%%@NL@%
                                IF GE.ChartStyle = cLines AND LastMissing% <> cYes THEN%@NL@%
                                        LINE -(VX, VY), PaletteC%(MS%), , PaletteS%(MS%)%@NL@%
                                END IF%@NL@%
%@NL@%
%@AB@%                                ' In any case draw the plot character.  Start by getting the%@AE@%%@NL@%
%@AB@%                                ' screen coordinates of the character relative to the point%@AE@%%@NL@%
%@AB@%                                ' just charted:%@AE@%%@NL@%
                                CX% = PMAP(VX, 0) - GetGTextLen(CHR$(PaletteCh%(MS%))) / 2%@NL@%
                                CY% = PMAP(VY, 1) - GFI.Ascent / 2%@NL@%
%@NL@%
%@AB@%                                ' Now, set the character color and print it:%@AE@%%@NL@%
                                clSetCharColor MS%%@NL@%
                                clHPrint CX%, CY%, CHR$(PaletteCh%(MS%))%@NL@%
%@NL@%
%@AB@%                                ' Finally, reset the graphics cursor, since printing the%@AE@%%@NL@%
%@AB@%                                ' character changed it:%@AE@%%@NL@%
                                PSET (VX, VY), POINT(VX, VY)%@NL@%
%@NL@%
                                LastMissing% = cNo%@NL@%
                        END IF%@NL@%
%@NL@%
                NEXT DataPoint%%@NL@%
        NEXT Series%%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clDrawTitles - Draws the main and subtitles on a chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clDrawTitles%@NL@%
SHARED GE AS ChartEnvironment%@NL@%
SHARED TTitleLayout AS TitleLayout%@NL@%
%@NL@%
%@AB@%        ' Bottom of main title line is 1-1/2 character heights from the%@AE@%%@NL@%
%@AB@%        ' top of the chart window:%@AE@%%@NL@%
        YPos% = TTitleLayout.Top%@NL@%
        clPrintTitle GE.MainTitle, YPos%%@NL@%
%@NL@%
%@AB@%        ' Add 1.5 * character height to y position for subtitle line position:%@AE@%%@NL@%
        YPos% = YPos% + TTitleLayout.TitleOne + TTitleLayout.Middle%@NL@%
        clPrintTitle GE.SubTitle, YPos%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clFilter - Filters input data into dynamic working data array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Axis     -  An AxisType variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     AxisMode%-  Mode for this axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     D1(1)    -  One-dimensional array of input data%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     D2(2)    -  Two-dimensional array for filtered data%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%       -  The number of values to transfer%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Alters values in D2()%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clFilter (Axis AS AxisType, AxisMode%, D1(), D2(), N%)%@NL@%
%@NL@%
%@AB@%        ' If the axis is a category one then exit:%@AE@%%@NL@%
        IF AxisMode% = cCategory THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Transfer the data from the input data array to the working data%@AE@%%@NL@%
%@AB@%        ' array:%@AE@%%@NL@%
        FOR i% = 1 TO N%%@NL@%
                D2(i%, 1) = D1(i%)%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' Call FilterMS to go through the data again scaling it and taking%@AE@%%@NL@%
%@AB@%        ' logs depending on the settings for this axis:%@AE@%%@NL@%
        clFilterMS Axis, AxisMode%, D2(), D2(), N%, 1, 1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clFilterMS - Filters two-dimensional input data into the dynamic working%@AE@%%@NL@%
%@AB@%'               data array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Axis     -  An AxisType variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     AxisMode%-  Axis mode for the axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     D1(2)    -  Two-dimensional array of input data%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     D2(2)    -  Two-dimensional array for filtered data%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     N%       -  The number of values to transfer%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     First%   -  First data series to filter%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Last%    -  Last data series to filter%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Alters values in D2()%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clFilterMS (Axis AS AxisType, AxisMode%, D1(), D2(), N%, First%, Last%)%@NL@%
%@NL@%
%@AB@%        ' If the axis is a category axis then exit:%@AE@%%@NL@%
        IF AxisMode% = cCategory THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' If this isn't an autoscale axis, use the scale factor from the%@AE@%%@NL@%
%@AB@%        ' environment.  If it is an autoscale axis don't scale at all now%@AE@%%@NL@%
%@AB@%        ' it will be done when the data is drawn on the screen:%@AE@%%@NL@%
        IF Axis.AutoScale = cNo THEN%@NL@%
                ScaleFactor = Axis.ScaleFactor%@NL@%
        ELSE%@NL@%
                ScaleFactor = 1%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' If this a log axis calculate the log base:%@AE@%%@NL@%
        IF AxisMode% = cLog THEN LogRef = LOG(Axis.LogBase)%@NL@%
%@NL@%
%@AB@%        ' Loop through the data series:%@AE@%%@NL@%
        FOR J% = First% TO Last%%@NL@%
%@NL@%
%@AB@%                ' Loop through the values within the series:%@AE@%%@NL@%
                FOR i% = 1 TO N%%@NL@%
%@NL@%
%@AB@%                        ' Get a data value and if it isn't missing, then scale it:%@AE@%%@NL@%
                        V = D1(i%, J%)%@NL@%
                        IF V <> cMissingValue THEN V = V / ScaleFactor%@NL@%
%@NL@%
%@AB@%                        ' If the axis is a log axis, then if the value is greater than%@AE@%%@NL@%
%@AB@%                        ' it is safe to take it's log.  Otherwise, set the data value to%@AE@%%@NL@%
%@AB@%                        ' missing:%@AE@%%@NL@%
                        IF Axis.RangeType = cLog THEN%@NL@%
                                 IF V > 0 THEN%@NL@%
                                        V = LOG(V) / LogRef%@NL@%
                                ELSE%@NL@%
                                        V = cMissingValue%@NL@%
                                END IF%@NL@%
                        END IF%@NL@%
%@NL@%
%@AB@%                        ' Place the value in the output data array:%@AE@%%@NL@%
                        D2(i%, J% - First% + 1) = V%@NL@%
%@NL@%
                NEXT i%%@NL@%
%@NL@%
        NEXT J%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clFlagSystem - Sets GP.SysFlag to cYes%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Alters the value of GP.SysFlag%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clFlagSystem%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
        GP.SysFlag = cYes%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clFormatTics - Figures out tic label format and TicDecimals.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Axis     -  AxisType variable for which to format tics.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     The TicFormat and Decimals elements may be changed for an axis%@AE@%%@NL@%
%@AB@%'     if AutoTic is cYes.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clFormatTics (Axis AS AxisType)%@NL@%
%@NL@%
%@AB@%        ' If AutoScale isn't Yes then exit%@AE@%%@NL@%
        IF Axis.AutoScale <> cYes THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' If the size of the largest value is bigger than seven decimal%@AE@%%@NL@%
%@AB@%        ' places then set TicFormat to exponential.  Otherwise, set it%@AE@%%@NL@%
%@AB@%        ' to normal:%@AE@%%@NL@%
        IF ABS(Axis.ScaleMin) >= 10 ^ 8 OR ABS(Axis.ScaleMax) >= 10 ^ 8 THEN%@NL@%
                Axis.TicFormat = cExpFormat%@NL@%
        ELSE%@NL@%
                Axis.TicFormat = cNormFormat%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Pick the largest of the scale max and min (in absolute value) and%@AE@%%@NL@%
%@AB@%        ' use that to decide how many decimals to use when displaying the tic%@AE@%%@NL@%
%@AB@%        ' labels:%@AE@%%@NL@%
        Range = ABS(Axis.ScaleMax)%@NL@%
        IF ABS(Axis.ScaleMin) > Range THEN Range = ABS(Axis.ScaleMin)%@NL@%
        IF Range < 10 THEN%@NL@%
                TicResolution = -INT(-ABS(LOG(Range) / LOG(10!))) + 1%@NL@%
                IF TicResolution > 9 THEN TicResolution = 9%@NL@%
                Axis.TicDecimals = TicResolution%@NL@%
        ELSE%@NL@%
                Axis.TicDecimals = 0%@NL@%
        END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clGetStyle - Returns a predefined line-style definition%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     StyleNum%   -  A number identifying the entry to return%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Returns the line-style for the specified style number%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION clGetStyle% (StyleNum%)%@NL@%
%@NL@%
        SELECT CASE StyleNum%%@NL@%
                CASE 1: Style% = &HFFFF%@NL@%
                CASE 2: Style% = &HF0F0%@NL@%
                CASE 3: Style% = &HF060%@NL@%
                CASE 4: Style% = &HCCCC%@NL@%
                CASE 5: Style% = &HC8C8%@NL@%
                CASE 6: Style% = &HEEEE%@NL@%
                CASE 7: Style% = &HEAEA%@NL@%
                CASE 8: Style% = &HF6DE%@NL@%
                CASE 9: Style% = &HF6F6%@NL@%
                CASE 10: Style% = &HF56A%@NL@%
                CASE 11: Style% = &HCECE%@NL@%
                CASE 12: Style% = &HA8A8%@NL@%
                CASE 13: Style% = &HAAAA%@NL@%
                CASE 14: Style% = &HE4E4%@NL@%
                CASE 15: Style% = &HC88C%@NL@%
        END SELECT%@NL@%
        clGetStyle% = Style%%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== clHPrint - Prints text Horizontally on the screen%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     X     -  X position for the lower left of the first character to be%@AE@%%@NL@%
%@AB@%'              printed (in absolute screen coordinates)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y     -  Y position for the lower left of the first character to be%@AE@%%@NL@%
%@AB@%'              printed (in absolute screen coordinates)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Txt$  -  Text to print%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clHPrint (X%, Y%, Txt$)%@NL@%
%@NL@%
%@AB@%        ' Map the input coordinates relative to the current viewport:%@AE@%%@NL@%
        X = PMAP(X%, 2)%@NL@%
        Y = PMAP(Y%, 3)%@NL@%
%@NL@%
%@AB@%        ' Output the text horizontally:%@AE@%%@NL@%
        SetGTextDir 0%@NL@%
        TextLen% = OutGText(X, Y, Txt$)%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clInitChart - Initializes the charting library.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     This routine initializes some default data structures and is%@AE@%%@NL@%
%@AB@%'     called automatically by charting routines if the variable%@AE@%%@NL@%
%@AB@%'     GP.Initialized is cNo (or zero).%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clInitChart%@NL@%
SHARED StdChars%(), GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' Clear any previous errors%@AE@%%@NL@%
        clClearError%@NL@%
%@NL@%
        ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%        ' Initialize PaletteSet to no so palettes will be initialized properly%@AE@%%@NL@%
%@AB@%        ' when ChartScreen is called:%@AE@%%@NL@%
        GP.PaletteSet = cNo%@NL@%
%@NL@%
%@AB@%        ' Set up the list of plotting characters:%@AE@%%@NL@%
        PlotChars$ = "*ox=+/:&#@%![$^"%@NL@%
        StdChars%(0) = 0%@NL@%
        FOR i% = 1 TO cPalLen%@NL@%
                StdChars%(i%) = ASC(MID$(PlotChars$, i%, 1))%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' Initialize standard structures for title, axis, window and legend:%@AE@%%@NL@%
        clInitStdStruc%@NL@%
%@NL@%
        GP.Initialized = cYes%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clInitStdStruc - Initializes structures for standard titles, axes, etc.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clInitStdStruc%@NL@%
SHARED DAxis AS AxisType, DWindow AS RegionType%@NL@%
SHARED DLegend AS LegendType, DTitle AS TitleType%@NL@%
%@NL@%
%@AB@%' Set up default components of the default chart%@AE@%%@NL@%
%@AB@%' environment; start with default title:%@AE@%%@NL@%
%@NL@%
%@AB@%' Default title definition:%@AE@%%@NL@%
DTitle.Title = ""                ' Title text is blank%@NL@%
DTitle.TitleFont = 1             ' Title font is first one%@NL@%
DTitle.TitleColor = 1            ' Title color is white%@NL@%
DTitle.Justify = cCenter         ' Center justified%@NL@%
%@NL@%
%@AB@%' Default axis definition:%@AE@%%@NL@%
DAxis.grid = cNo                 ' No grid%@NL@%
DAxis.GridStyle = 1              ' Solid lines for grid%@NL@%
DAxis.AxisTitle = DTitle         ' Use above to initialize axis title%@NL@%
DAxis.AxisColor = 1              ' Axis color is white%@NL@%
DAxis.Labeled = cYes             ' Label and tic axis%@NL@%
DAxis.RangeType = cLinear        ' Linear axis%@NL@%
DAxis.LogBase = 10               ' Logs to base 10%@NL@%
DAxis.AutoScale = cYes           ' Automatically scale numbers if needed%@NL@%
DAxis.ScaleTitle = DTitle        ' Scale title%@NL@%
DAxis.TicFont = 1                ' Tic font is first one%@NL@%
DAxis.TicDecimals = 0            ' No decimals%@NL@%
%@NL@%
%@AB@%' Default window definition:%@AE@%%@NL@%
DWindow.Background = 0           ' Black background%@NL@%
DWindow.Border = cNo             ' Window will have no border%@NL@%
DWindow.BorderColor = 1          ' Make the borders white%@NL@%
DWindow.BorderStyle = 1          ' Solid-line borders%@NL@%
%@NL@%
%@AB@%' Default legend definition:%@AE@%%@NL@%
DLegend.Legend = cYes            ' Draw a legend if multi-series chart%@NL@%
DLegend.Place = cRight           ' On the right side%@NL@%
DLegend.TextColor = 1            ' Legend text is white on black%@NL@%
DLegend.TextFont = 1             ' Legend text font is first one%@NL@%
DLegend.AutoSize = cYes          ' Figure out size automatically%@NL@%
DLegend.LegendWindow = DWindow   ' Use the default window specification%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clLabelXTics - Labels tic marks for X axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Axis     -  An AxisType variable containing axis specification%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Cat$(1)  -  One-dimensional array of category labels.  Ignored%@AE@%%@NL@%
%@AB@%'                 if axis not category axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     TicX     -  X coordinate of first tic mark%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     TicY     -  Y coordinate of tic tip (portion away from axis)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     YBoundry% -  Y coordinate of bottom of tic labels%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clLabelXTics (Axis AS AxisType, Cat$(), TicX, TicTotX%, TicY, YBoundry%)%@NL@%
SHARED GFI AS FontInfo%@NL@%
SHARED GP AS GlobalParams%@NL@%
SHARED GE AS ChartEnvironment%@NL@%
%@NL@%
%@AB@%        ' If this axis isn't supposed to be labeled then exit:%@AE@%%@NL@%
        IF Axis.Labeled <> cYes THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Set the appropriate color, font, and orientation for tic labels:%@AE@%%@NL@%
        clSetCharColor Axis.AxisColor%@NL@%
        clSetChartFont Axis.TicFont%@NL@%
        SetGTextDir 0%@NL@%
%@NL@%
%@AB@%        ' The Y coordinate of the labels will be a constant .5 character%@AE@%%@NL@%
%@AB@%        ' heights below the end of the tic marks (TicY):%@AE@%%@NL@%
        Y% = PMAP(TicY, 1) + (GFI.Ascent - GFI.Leading) / 2%@NL@%
        IF GP.XStagger = cYes THEN%@NL@%
                YDrop% = (3 * GFI.Ascent - GFI.Leading) / 2%@NL@%
        ELSE%@NL@%
                YDrop% = 0%@NL@%
        END IF%@NL@%
        YBoundry% = Y% + YDrop% + GFI.PixHeight%@NL@%
%@NL@%
%@AB@%        ' Loop through and write labels%@AE@%%@NL@%
        TX = TicX%@NL@%
        CatNum% = 1%@NL@%
        Stagger% = cFalse%@NL@%
        FOR i% = 1 TO TicTotX%%@NL@%
%@NL@%
%@AB@%                ' The label depends on axis mode (category, value):%@AE@%%@NL@%
                SELECT CASE GP.XMode%@NL@%
                        CASE cCategory: Txt$ = Cat$(CatNum%)%@NL@%
                        CASE ELSE:      Txt$ = clVal2Str$(TX, Axis.TicDecimals, Axis.TicFormat)%@NL@%
                END SELECT%@NL@%
                TxtLen% = GetGTextLen(Txt$)%@NL@%
                IF GP.XMode = cCategory THEN%@NL@%
                        MaxLen% = 2 * (GE.DataWindow.X2 - GE.DataWindow.X1) / GP.NVals - GFI.AvgWidth%@NL@%
                        IF MaxLen% < 0 THEN MaxLen% = 0%@NL@%
                        DO UNTIL TxtLen% <= MaxLen%%@NL@%
                                Txt$ = LEFT$(Txt$, LEN(Txt$) - 1)%@NL@%
                                TxtLen% = GetGTextLen(Txt$)%@NL@%
                        LOOP%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Center the label under the tic mark and print it:%@AE@%%@NL@%
                X% = PMAP(TX, 0) - (TxtLen%) / 2%@NL@%
%@NL@%
                IF Stagger% THEN%@NL@%
                        clHPrint X%, Y% + YDrop%, Txt$%@NL@%
                        Stagger% = cFalse%@NL@%
                ELSE%@NL@%
                        clHPrint X%, Y%, Txt$%@NL@%
                        Stagger% = cTrue%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Move to the next tic mark:%@AE@%%@NL@%
                TX = TX + Axis.TicInterval%@NL@%
                CatNum% = CatNum% + 1%@NL@%
        NEXT i%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clLabelYTics - Labels tic marks and draws Y axis title%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Axis     -  An AxisType variable containing axis specification%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Cat$(1)  -  One-dimensional array of category labels.  Ignored%@AE@%%@NL@%
%@AB@%'                 if axis not category axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     TicX     -  X coordinate of first tic's tip (away from axis)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     TicY     -  Y coordinate of first tic%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clLabelYTics (Axis AS AxisType, Cat$(), TicX, TicY, TicTotY%)%@NL@%
SHARED GFI AS FontInfo%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' If axis isn't supposed to be labeled then exit:%@AE@%%@NL@%
        IF Axis.Labeled <> cYes THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Set the appropriate color, font, and orientation for tic labels:%@AE@%%@NL@%
        clSetCharColor Axis.AxisColor%@NL@%
        clSetChartFont Axis.TicFont%@NL@%
        SetGTextDir 0%@NL@%
%@NL@%
%@AB@%        ' Loop through and write labels%@AE@%%@NL@%
        TY = TicY%@NL@%
        CatNum% = 1%@NL@%
        FOR i% = 1 TO TicTotY%%@NL@%
%@NL@%
%@AB@%                ' The label depends on axis mode (category, value):%@AE@%%@NL@%
                SELECT CASE GP.YMode%@NL@%
                        CASE cCategory: Txt$ = Cat$(GP.NVals - CatNum% + 1)%@NL@%
                        CASE ELSE:      Txt$ = clVal2Str$(TY, Axis.TicDecimals, Axis.TicFormat)%@NL@%
                END SELECT%@NL@%
                TxtLen% = GetGTextLen(Txt$)%@NL@%
%@NL@%
%@AB@%                ' Space the label 1/2 character width to the left of the tic%@AE@%%@NL@%
%@AB@%                ' mark and center it vertically on the tic mark (round vertical%@AE@%%@NL@%
%@AB@%                ' location to the next highest integer):%@AE@%%@NL@%
                X% = PMAP(TicX, 0) - TxtLen% - (.5 * GFI.MaxWidth)%@NL@%
                Y% = -INT(-(PMAP(TY, 1) - (GFI.Ascent + GFI.Leading) / 2))%@NL@%
%@NL@%
%@AB@%                ' Print the label:%@AE@%%@NL@%
                clHPrint X%, Y%, Txt$%@NL@%
%@NL@%
%@AB@%                ' Go to the next tic mark:%@AE@%%@NL@%
                TY = TY + Axis.TicInterval%@NL@%
                CatNum% = CatNum% + 1%@NL@%
        NEXT i%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clLayoutLegend - Calculates size of the legend%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     SeriesLabel$(1) - The labels used in the legend%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     First%   - The first series (label) to process%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Last%    - The last series (label) to process%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     The coordinates in the legend window portion of Env are altered%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     Sizing the legend window requires finding out where it goes (right%@AE@%%@NL@%
%@AB@%'     or bottom) and determining how big the labels are and how big%@AE@%%@NL@%
%@AB@%'     the legend needs to be to hold them.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clLayoutLegend (SeriesLabel$(), First%, Last%)%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED GFI AS FontInfo%@NL@%
SHARED LLayout AS LegendLayout%@NL@%
SHARED TTitleLayout AS TitleLayout%@NL@%
DIM W AS RegionType%@NL@%
%@NL@%
%@AB@%        ' If "no legend" is specified, then exit:%@AE@%%@NL@%
        IF GE.Legend.Legend = cNo THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' This may be an auto legend or not, but, in either case we're%@AE@%%@NL@%
%@AB@%        ' going to need the following information:%@AE@%%@NL@%
        clSetChartFont GE.Legend.TextFont%@NL@%
%@NL@%
        LLayout.SymbolSize = GFI.Ascent - GFI.Leading - 1%@NL@%
        LLayout.HorizBorder = GFI.Ascent%@NL@%
        LLayout.VertBorder = GFI.AvgWidth%@NL@%
        LLayout.RowSpacing = 1.75 * (LLayout.SymbolSize + 1)%@NL@%
        LLayout.LabelOffset = LLayout.SymbolSize / GP.Aspect + GFI.AvgWidth%@NL@%
%@NL@%
%@AB@%        'RowLeading% = LLayout.RowSpacing - LLayout.SymbolSize%@AE@%%@NL@%
        RowLeading% = .75 * LLayout.SymbolSize + 1.75%@NL@%
%@NL@%
        ColWid% = clMaxStrLen(SeriesLabel$(), First%, Last%) + LLayout.LabelOffset%@NL@%
        LLayout.ColSpacing = ColWid% + GFI.AvgWidth%@NL@%
%@NL@%
%@AB@%        ' If this isn't an autosize legend:%@AE@%%@NL@%
        IF GE.Legend.AutoSize = cNo THEN%@NL@%
%@NL@%
%@AB@%                ' Check the legend coordinates supplied by the user to make%@AE@%%@NL@%
%@AB@%                ' sure that they are valid.  If they are, exit:%@AE@%%@NL@%
                W = GE.Legend.LegendWindow%@NL@%
                LWid% = W.X2 - W.X1%@NL@%
                LHgt% = W.Y2 - W.Y1%@NL@%
                IF LWid% > 0 AND LHgt% > 0 THEN%@NL@%
%@NL@%
%@AB@%                        ' Calculate the number of columns and rows of labels that will%@AE@%%@NL@%
%@AB@%                        ' fit in the legend:%@AE@%%@NL@%
                        NumCol% = INT((LWid% - LLayout.VertBorder) / (LLayout.ColSpacing))%@NL@%
                        IF NumCol% <= 0 THEN NumCol% = 1%@NL@%
                        IF NumCol% > GP.NSeries THEN NumCol% = GP.NSeries%@NL@%
                        NumRow% = -INT(-GP.NSeries / NumCol%)%@NL@%
                        LLayout.NumRow = NumRow%%@NL@%
                        LLayout.NumCol = NumCol%%@NL@%
%@NL@%
%@AB@%                        ' Re-calculate the column and row spacing:%@AE@%%@NL@%
                        LLayout.ColSpacing = INT((LWid% - LLayout.VertBorder) / NumCol%)%@NL@%
                        LLayout.RowSpacing = INT((LHgt% - 2 * LLayout.HorizBorder + RowLeading%) / NumRow%)%@NL@%
%@NL@%
                        EXIT SUB%@NL@%
%@NL@%
%@AB@%                ' If invalid legend coordinates are discovered set an error and%@AE@%%@NL@%
%@AB@%                ' go on to calculate new ones:%@AE@%%@NL@%
                ELSE%@NL@%
%@NL@%
                  clSetError cBadLegendWindow%@NL@%
%@NL@%
                END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Do remaining calculations according to the legend placement specified%@AE@%%@NL@%
%@AB@%        ' (right, bottom, overlay):%@AE@%%@NL@%
        SELECT CASE GE.Legend.Place%@NL@%
%@NL@%
                CASE cRight, cOverlay:%@NL@%
%@NL@%
%@AB@%                        ' Leave room at top for chart titles:%@AE@%%@NL@%
                        Top% = TTitleLayout.TotalSize%@NL@%
%@NL@%
%@AB@%                        ' Figure out the maximum number of legend rows that will%@AE@%%@NL@%
%@AB@%                        ' fit in the amount of space you have left for the legend%@AE@%%@NL@%
%@AB@%                        ' height.  Then, see how many columns are needed.  Once%@AE@%%@NL@%
%@AB@%                        ' the number of columns is set refigure how many rows are%@AE@%%@NL@%
%@AB@%                        ' required:%@AE@%%@NL@%
                        NumRow% = INT((GP.ChartHgt - Top% - 2 * LLayout.HorizBorder) / LLayout.RowSpacing)%@NL@%
                        IF NumRow% > GP.NSeries THEN NumRow% = GP.NSeries%@NL@%
                        NumCol% = -INT(-GP.NSeries / NumRow%)%@NL@%
                        NumRow% = -INT(-GP.NSeries / NumCol%)%@NL@%
%@NL@%
%@AB@%                        ' Set the width and height:%@AE@%%@NL@%
                        LWid% = NumCol% * LLayout.ColSpacing - GFI.AvgWidth + 2 * LLayout.VertBorder%@NL@%
                        LHgt% = (NumRow% * LLayout.RowSpacing - RowLeading% + 2 * LLayout.HorizBorder)%@NL@%
%@NL@%
%@AB@%                        ' Place the legend one character width from right and even with%@AE@%%@NL@%
%@AB@%                        ' what will be the top of the data window:%@AE@%%@NL@%
                        LLft% = GP.ChartWid - 1 - LWid% - GFI.AvgWidth%@NL@%
                        LTop% = Top%%@NL@%
%@NL@%
                CASE cBottom:%@NL@%
%@NL@%
%@AB@%                        ' The number of label columns that will fit (using the same%@AE@%%@NL@%
%@AB@%                        ' procedure as above except figure columns first):%@AE@%%@NL@%
                        NumCol% = INT((GP.ChartWid - 2 * LLayout.HorizBorder) / LLayout.ColSpacing)%@NL@%
                        IF NumCol% > GP.NSeries THEN NumCol% = GP.NSeries%@NL@%
                        NumRow% = -INT(-GP.NSeries / NumCol%)%@NL@%
                        NumCol% = -INT(-GP.NSeries / NumRow%)%@NL@%
%@NL@%
%@AB@%                        ' Set the width and height:%@AE@%%@NL@%
                        LWid% = NumCol% * LLayout.ColSpacing - GFI.AvgWidth + 2 * LLayout.VertBorder%@NL@%
                        LHgt% = (NumRow% * LLayout.RowSpacing - RowLeading% + 2 * LLayout.HorizBorder)%@NL@%
%@NL@%
%@AB@%                        ' Center the legend horizontally one character from the bottom:%@AE@%%@NL@%
                        LLft% = (GP.ChartWid - 1 - LWid%) / 2%@NL@%
                        LTop% = GP.ChartHgt - 1 - LHgt% - GFI.Ascent%@NL@%
%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Record legend columns and rows:%@AE@%%@NL@%
        LLayout.NumRow = NumRow%%@NL@%
        LLayout.NumCol = NumCol%%@NL@%
%@NL@%
%@AB@%        ' Finally, place the legend coordinates in GE:%@AE@%%@NL@%
        GE.Legend.LegendWindow.X1 = LLft%%@NL@%
        GE.Legend.LegendWindow.Y1 = LTop%%@NL@%
        GE.Legend.LegendWindow.X2 = LLft% + LWid%%@NL@%
        GE.Legend.LegendWindow.Y2 = LTop% + LHgt%%@NL@%
%@NL@%
%@AB@%        ' If, after all this, the legend window is invalid, set error:%@AE@%%@NL@%
        IF LLft% < 0 OR LTop% < 0 OR LWid% <= 0 OR LHgt% <= 0 THEN%@NL@%
                clSetError cBadLegendWindow%@NL@%
        END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clLayoutTitle - Figures out title layouts for Top, X-axis and%@AE@%%@NL@%
%@AB@%'                      Y-axis titles%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     TL    -  Layout variable into which to place titles%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     T1    -  First title%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     T2    -  Second Title%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clLayoutTitle (TL AS TitleLayout, T1 AS TitleType, T2 AS TitleType)%@NL@%
SHARED GFI AS FontInfo%@NL@%
%@NL@%
%@AB@%        ' Set the title heights initially to 0:%@AE@%%@NL@%
        TL.TitleOne = 0%@NL@%
        TL.TitleTwo = 0%@NL@%
%@NL@%
%@AB@%        ' If the first title is set then get its height:%@AE@%%@NL@%
        Total% = 0%@NL@%
        IF LTRIM$(T1.Title) <> "" THEN%@NL@%
                clSetChartFont T1.TitleFont%@NL@%
                TL.TitleOne = GFI.PixHeight%@NL@%
                Total% = Total% + 1%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' If the second title is set then get it's height:%@AE@%%@NL@%
        IF LTRIM$(T2.Title) <> "" THEN%@NL@%
                clSetChartFont T2.TitleFont%@NL@%
                TL.TitleTwo = GFI.PixHeight%@NL@%
                Lead2% = GFI.Leading%@NL@%
                Total% = Total% + 1%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Set the "leading" values for label spacing depending on how many%@AE@%%@NL@%
%@AB@%        ' of the titles were non-blank:%@AE@%%@NL@%
        TotalHeight% = TL.TitleOne + TL.TitleTwo%@NL@%
        SELECT CASE Total%%@NL@%
                CASE 0:%@NL@%
                        TL.Top = 8%@NL@%
                        TL.Middle = 0%@NL@%
                        TL.Bottom = 4%@NL@%
%@NL@%
                CASE 1:%@NL@%
                        TL.Top = 8 + TotalHeight% / 8%@NL@%
                        TL.Middle = 0%@NL@%
                        TL.Bottom = TL.Top%@NL@%
%@NL@%
                CASE 2:%@NL@%
                        TL.Top = 8 + TotalHeight% / 8%@NL@%
                        TL.Middle = 0: IF Lead2% = 0 THEN TL.Middle = TL.TitleOne / 2%@NL@%
                        TL.Bottom = TL.Top%@NL@%
        END SELECT%@NL@%
%@NL@%
        TL.TotalSize = TL.Top + TL.TitleOne + TL.Middle + TL.TitleTwo + TL.Bottom%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clMap2Attrib% - Maps an integer to a screen attribute for current%@AE@%%@NL@%
%@AB@%'                    screen mode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     N% - The number to map%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     The function returns:%@AE@%%@NL@%
%@AB@%'        0 is mapped to 0, all other numbers are mapped to the range%@AE@%%@NL@%
%@AB@%'        1 to GP.MaxColor%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION clMap2Attrib% (N%)%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
        AbsN% = ABS(N%)%@NL@%
        IF AbsN% = 0 THEN%@NL@%
                clMap2Attrib% = AbsN%%@NL@%
        ELSE%@NL@%
                clMap2Attrib% = (AbsN% - 1) MOD GP.MaxColor + 1%@NL@%
        END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== clMap2Pal% - Maps an integer into a palette reference%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     N% - The number to map%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     The function returns (N%-1) MOD cPalLen + 1%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     This FUNCTION is used in almost every reference to a palette to ensure%@AE@%%@NL@%
%@AB@%'     that an invalid number doesn't cause a reference outside of a palette%@AE@%%@NL@%
%@AB@%'     array (and thus crash the library).  This FUNCTION maps the first%@AE@%%@NL@%
%@AB@%'     cPalLen values to themselves. Numbers above cPalLen are mapped to%@AE@%%@NL@%
%@AB@%'     the values 2..cPalLen.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION clMap2Pal% (N%)%@NL@%
%@NL@%
        AbsN% = ABS(N%)%@NL@%
        IF AbsN% > cPalLen THEN%@NL@%
                clMap2Pal% = (AbsN% - 2) MOD (cPalLen - 1) + 2%@NL@%
        ELSE%@NL@%
                clMap2Pal% = AbsN%%@NL@%
        END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== clMaxStrLen% - Finds the length of the longest string in a list%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Txt$(1)  -  One-dimensional array of strings to search%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     First%   -  First string to consider%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Last%    -  Last string to consider%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     This FUNCTION returns the length of the longest string%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION clMaxStrLen% (Txt$(), First%, Last%)%@NL@%
%@NL@%
%@AB@%        ' Set Max to 0 then loop through each label updating Max if the%@AE@%%@NL@%
%@AB@%        ' label is longer:%@AE@%%@NL@%
        Max% = 0%@NL@%
        FOR Row% = First% TO Last%%@NL@%
                L% = GetGTextLen(Txt$(Row%))%@NL@%
                IF L% > Max% THEN Max% = L%%@NL@%
        NEXT Row%%@NL@%
%@NL@%
%@AB@%        ' Return Max as the value of the FUNCTION:%@AE@%%@NL@%
        clMaxStrLen% = Max%%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== clMaxVal - Returns the maximum of two numbers%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     A  -  The first number%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     B  -  The second number%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     The function returns the maximum of the two values%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION clMaxVal (A, B)%@NL@%
%@NL@%
        IF A > B THEN clMaxVal = A ELSE clMaxVal = B%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== clPrintTitle - Prints title correctly justified and colored%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     TitleVar - A TitleType variable containing specifications for the%@AE@%%@NL@%
%@AB@%'                title to be printed%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y%       - Vertical position in window for bottom of line%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clPrintTitle (TitleVar AS TitleType, Y%)%@NL@%
SHARED GFI AS FontInfo, GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' Calculate width of the title text:%@AE@%%@NL@%
        clSetChartFont TitleVar.TitleFont%@NL@%
%@NL@%
        Txt$ = RTRIM$(TitleVar.Title)%@NL@%
        TxtLen% = GetGTextLen(Txt$)%@NL@%
        IF TxtLen% = 0 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Calculate horizontal position depending on justification style%@AE@%%@NL@%
        SELECT CASE TitleVar.Justify%@NL@%
%@NL@%
                CASE cCenter: X% = (GP.ChartWid - 1 - (TxtLen%)) / 2%@NL@%
                CASE cRight:  X% = GP.ChartWid - 1 - TxtLen% - GFI.AvgWidth%@NL@%
                CASE ELSE:    X% = GFI.AvgWidth%@NL@%
%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Set color of text and print it:%@AE@%%@NL@%
        clSetCharColor TitleVar.TitleColor%@NL@%
        clHPrint X%, Y%, Txt$%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clRenderBar - Renders a bar for a bar or column chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     X1    -  Left side of bar (in data world coordinates)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y1    -  Top of bar (in data world coordinates)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     X2    -  Right side of bar (in data world coordinates)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y2    -  Bottom of bar (in data world coordinates)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     C%    -  Palette entry number to use for border color and fill pattern%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clRenderBar (X1, Y1, X2, Y2, C%)%@NL@%
SHARED PaletteC%(), PaletteP$()%@NL@%
%@NL@%
%@AB@%        ' First clear out space for the bar by drawing a bar in black:%@AE@%%@NL@%
        LINE (X1, Y1)-(X2, Y2), 0, BF%@NL@%
%@NL@%
%@AB@%        ' Put a border around the bar and fill with pattern:%@AE@%%@NL@%
        MC% = clMap2Pal%(C%)%@NL@%
%@NL@%
        LINE (X1, Y1)-(X2, Y2), 1, B%@NL@%
        PAINT ((X1 + X2) / 2, (Y1 + Y2) / 2), PaletteP$(MC%), 1%@NL@%
        LINE (X1, Y1)-(X2, Y2), PaletteC%(MC%), B%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clRenderWindow - Renders a window on the screen%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     W - A RegionType variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     This routine assumes that the viewport is set to the borders of%@AE@%%@NL@%
%@AB@%'     the window to be rendered%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clRenderWindow (W AS RegionType)%@NL@%
SHARED PaletteC%(), PaletteB%()%@NL@%
%@NL@%
%@AB@%        ' Set window since the size of the viewport is unknown and draw%@AE@%%@NL@%
%@AB@%        ' a filled box of the background color specified by the window%@AE@%%@NL@%
%@AB@%        ' definition:%@AE@%%@NL@%
        WINDOW (0, 0)-(1, 1)%@NL@%
        LINE (0, 0)-(1, 1), PaletteC%(clMap2Pal%(W.Background)), BF%@NL@%
%@NL@%
%@AB@%        ' Draw a border if specified:%@AE@%%@NL@%
        IF W.Border = cYes THEN%@NL@%
                LINE (0, 0)-(1, 1), PaletteC%(clMap2Pal%(W.BorderColor)), B, PaletteB%(clMap2Pal%(W.BorderStyle))%@NL@%
        END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clScaleAxis - Calculates minimum, maximum and scale factor for an axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     A        - An AxisType variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     AxisMode%- cCategory or cValue%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     D1(2)    - Two-dimensional array of values to be scaled%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     ScaleMin, ScaleMax, ScaleFactor, and ScaleTitle elements in%@AE@%%@NL@%
%@AB@%'     axis variable will be altered if it is a category axis or%@AE@%%@NL@%
%@AB@%'     AutoScale is Yes.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clScaleAxis (Axis AS AxisType, AxisMode%, D1())%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' If this is a category axis then ignore all the flags and force%@AE@%%@NL@%
%@AB@%        ' scale parameters to those needed by charting routines:%@AE@%%@NL@%
        IF AxisMode% = cCategory THEN%@NL@%
                Axis.ScaleMin = 0%@NL@%
                Axis.ScaleMax = 1%@NL@%
                Axis.ScaleFactor = 1%@NL@%
                Axis.ScaleTitle.Title = ""%@NL@%
                EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' If AutoScale isn't Yes then exit:%@AE@%%@NL@%
        IF Axis.AutoScale <> cYes THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' AutoScale was specified, calculate the different scale variables%@AE@%%@NL@%
%@AB@%        ' Set maximum and minimum to defaults.%@AE@%%@NL@%
%@NL@%
%@AB@%        ' Initialize the value- and row-minimum and maximum values to zero:%@AE@%%@NL@%
        VMin = 0%@NL@%
        VMax = 0%@NL@%
%@NL@%
        RMin = 0%@NL@%
        RMax = 0%@NL@%
%@NL@%
%@AB@%        ' Compare data values for minimum and maximum:%@AE@%%@NL@%
        FOR Row% = 1 TO GP.NVals%@NL@%
%@NL@%
%@AB@%                ' Initialize positive and negative sum variables:%@AE@%%@NL@%
                RSumPos = 0%@NL@%
                RSumNeg = 0%@NL@%
%@NL@%
%@AB@%                ' Evaluate the value from this row in each series:%@AE@%%@NL@%
                FOR Column% = 1 TO GP.NSeries%@NL@%
%@NL@%
%@AB@%                        ' Get the value from the data array:%@AE@%%@NL@%
                        V = D1(Row%, Column%)%@NL@%
%@NL@%
%@AB@%                        ' Process values that aren't missing only:%@AE@%%@NL@%
                        IF V <> cMissingValue THEN%@NL@%
%@NL@%
%@AB@%                                ' Add positive values to positive sum and negative ones to%@AE@%%@NL@%
%@AB@%                                ' negative sum:%@AE@%%@NL@%
                                IF V > 0 THEN RSumPos = RSumPos + V%@NL@%
                                IF V < 0 THEN RSumNeg = RSumNeg + V%@NL@%
%@NL@%
%@AB@%                                ' Compare the value against current maximum and minimum and%@AE@%%@NL@%
%@AB@%                                ' replace them if appropriate:%@AE@%%@NL@%
                                IF V < VMin THEN VMin = V%@NL@%
                                IF V > VMax THEN VMax = V%@NL@%
%@NL@%
                        END IF%@NL@%
%@NL@%
                NEXT Column%%@NL@%
%@NL@%
%@AB@%                ' Compare the positive and negative sums for this row with the%@AE@%%@NL@%
%@AB@%                ' current row maximum and minimum and replace them if appropriate:%@AE@%%@NL@%
                IF RSumNeg < RMin THEN RMin = RSumNeg%@NL@%
                IF RSumPos > RMax THEN RMax = RSumPos%@NL@%
%@NL@%
        NEXT Row%%@NL@%
%@NL@%
%@AB@%        ' If the chart style is one, meaning that the data isn't stacked for%@AE@%%@NL@%
%@AB@%        ' bar and column charts, or it is a line or scatter chart then the scale%@AE@%%@NL@%
%@AB@%        ' minimum and maximum are the minimum and maximum values found.%@AE@%%@NL@%
%@AB@%        ' Each value is adjusted so the data is not drawn on or beyond the%@AE@%%@NL@%
%@AB@%        ' border of the data window:%@AE@%%@NL@%
        IF GE.ChartStyle = 1 OR GE.ChartType = cLine OR GE.ChartType = cScatter THEN%@NL@%
                IF VMin < 0 THEN%@NL@%
                        Axis.ScaleMin = VMin - .01 * (VMax - VMin)%@NL@%
                END IF%@NL@%
                IF VMax > 0 THEN%@NL@%
                        Axis.ScaleMax = VMax + .01 * (VMax - VMin)%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%        ' Otherwise, the scale minimum and maximum are the minimum and maximum%@AE@%%@NL@%
%@AB@%        ' sums of the data for each row:%@AE@%%@NL@%
        ELSE%@NL@%
                IF RMin < 0 THEN%@NL@%
                        Axis.ScaleMin = RMin - .01 * (RMax - RMin)%@NL@%
                END IF%@NL@%
                IF RMax > 0 THEN%@NL@%
                        Axis.ScaleMax = RMax + .01 * (RMax - RMin)%@NL@%
                END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' If no data then force range to be non-zero:%@AE@%%@NL@%
        IF Axis.ScaleMin = Axis.ScaleMax THEN Axis.ScaleMax = 1%@NL@%
%@NL@%
%@AB@%        ' Adjust the scale limits by ScaleFactor if required:%@AE@%%@NL@%
        clAdjustScale Axis%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clSelectChartFont - Selects a font to use and gets info about it%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     N%    -  Font number to use%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clSelectChartFont (N%)%@NL@%
SHARED GFI AS FontInfo%@NL@%
%@NL@%
%@AB@%        ' Select the font and get information about it:%@AE@%%@NL@%
        SelectFont N%%@NL@%
        GetFontInfo GFI%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clSelectChartWindow - Sets viewport to chart window%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env         - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     This routine erases any previous viewport%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clSelectChartWindow%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' Set viewport to chart window:%@AE@%%@NL@%
        VIEW (GP.CwX1, GP.CwY1)-(GP.CwX2, GP.CwY2)%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clSelectRelWindow - Sets viewport to window relative to chart window%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env   - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     W     - RegionType variable of window to set%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     This routine erases any previous viewport%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clSelectRelWindow (W AS RegionType)%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' New viewport is defined relative to the current one:%@AE@%%@NL@%
        VIEW (GP.CwX1 + W.X1, GP.CwY1 + W.Y1)-(GP.CwX1 + W.X2, GP.CwY1 + W.Y2)%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clSetAxisModes - Sets axis modes for X- and Y-axis according to%@AE@%%@NL@%
%@AB@%'                   ChartType%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Alters XAxis and YAxis axis modes%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clSetAxisModes%@NL@%
SHARED GE AS ChartEnvironment%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
        SELECT CASE GE.ChartType%@NL@%
%@NL@%
                CASE cBar:%@NL@%
                        GP.XMode = cValue%@NL@%
                        GP.YMode = cCategory%@NL@%
%@NL@%
                CASE cColumn, cLine:%@NL@%
                        GP.XMode = cCategory%@NL@%
                        GP.YMode = cValue%@NL@%
%@NL@%
                CASE cScatter:%@NL@%
                        GP.XMode = cValue%@NL@%
                        GP.YMode = cValue%@NL@%
%@NL@%
                CASE cPie:%@NL@%
                        GP.XMode = cCategory%@NL@%
                        GP.YMode = cCategory%@NL@%
%@NL@%
        END SELECT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clSetCharColor - Sets color for DRAW characters%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     N%    -  Color number%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clSetCharColor (N%)%@NL@%
SHARED PaletteC%()%@NL@%
%@NL@%
%@AB@%        ' Check for valid color number then set color if correct:%@AE@%%@NL@%
        SetGTextColor PaletteC%(clMap2Pal%(N%))%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clSetChartFont - Selects the specified font%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     N%    -  Number of loaded font to select%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clSetChartFont (N AS INTEGER)%@NL@%
SHARED GFI AS FontInfo%@NL@%
%@NL@%
%@AB@%        ' Select font and get information on it:%@AE@%%@NL@%
        SelectFont N%%@NL@%
        GetFontInfo GFI%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clSetError - Sets the ChartLib error variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     ErrNo    - The error number to set%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Sets ChartErr to ErrNo%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clSetError (ErrNo AS INTEGER)%@NL@%
%@NL@%
        ChartErr = ErrNo%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clSetGlobalParams - Sets some global parameters that other routines use%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     GP.ValLenX and GP.ValLenY are altered%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clSetGlobalParams%@NL@%
SHARED GP AS GlobalParams, GE AS ChartEnvironment%@NL@%
%@NL@%
%@AB@%        ' Figure out longest label on X axis:%@AE@%%@NL@%
        clSetChartFont GE.XAxis.TicFont%@NL@%
        SF = GE.XAxis.ScaleMin%@NL@%
        Len1 = GetGTextLen(clVal2Str$(SF, GE.XAxis.TicDecimals, GE.XAxis.TicFormat))%@NL@%
        SF = GE.XAxis.ScaleMax%@NL@%
        Len2 = GetGTextLen(clVal2Str$(SF, GE.XAxis.TicDecimals, GE.XAxis.TicFormat))%@NL@%
        GP.ValLenX = clMaxVal(Len1, Len2)%@NL@%
%@NL@%
%@AB@%        ' Figure out longest label on Y axis:%@AE@%%@NL@%
        clSetChartFont GE.YAxis.TicFont%@NL@%
        SF = GE.YAxis.ScaleMin%@NL@%
        Len1 = GetGTextLen(clVal2Str$(SF, GE.YAxis.TicDecimals, GE.YAxis.TicFormat))%@NL@%
        SF = GE.YAxis.ScaleMax%@NL@%
        Len2 = GetGTextLen(clVal2Str$(SF, GE.YAxis.TicDecimals, GE.YAxis.TicFormat))%@NL@%
        GP.ValLenY = clMaxVal(Len1, Len2)%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clSizeDataWindow - Calculates general data window size%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Cat$(1)  - One-dimensional array of category labels (only%@AE@%%@NL@%
%@AB@%'                used if one of the axes is a category one)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     The X1, Y1, X2, Y2 elements of the GE variable will be%@AE@%%@NL@%
%@AB@%'     set to the data window coordinates%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clSizeDataWindow (Cat$())%@NL@%
SHARED GE AS ChartEnvironment%@NL@%
SHARED GP AS GlobalParams%@NL@%
SHARED GFI AS FontInfo%@NL@%
SHARED TTitleLayout AS TitleLayout%@NL@%
SHARED XTitleLayout AS TitleLayout%@NL@%
SHARED YTitleLayout AS TitleLayout%@NL@%
%@NL@%
%@AB@%        ' *** TOP%@AE@%%@NL@%
%@AB@%        ' Adjust the top of the data window:%@AE@%%@NL@%
        DTop% = TTitleLayout.TotalSize%@NL@%
%@NL@%
%@AB@%        ' *** LEFT%@AE@%%@NL@%
%@AB@%        ' Do left side:%@AE@%%@NL@%
        DLeft% = YTitleLayout.TotalSize%@NL@%
%@NL@%
%@AB@%        ' Add room for axis labels if the axis is labeled and not a pie chart:%@AE@%%@NL@%
        IF GE.ChartType <> cPie THEN%@NL@%
                IF GE.YAxis.Labeled = cYes THEN%@NL@%
%@NL@%
%@AB@%                        ' Get the correct font:%@AE@%%@NL@%
                        clSetChartFont GE.YAxis.TicFont%@NL@%
%@NL@%
%@AB@%                        ' If it is a category axis then add longest category label:%@AE@%%@NL@%
                        IF GP.YMode = cCategory THEN%@NL@%
                                DLeft% = DLeft% + clMaxStrLen%(Cat$(), 1, GP.NVals) + .5 * GFI.MaxWidth%@NL@%
%@NL@%
%@AB@%                        ' If it a value axis just add characters for label (plus 1/2 for%@AE@%%@NL@%
%@AB@%                        ' spacing):%@AE@%%@NL@%
                        ELSE%@NL@%
                                DLeft% = DLeft% + GP.ValLenY + (.5 * GFI.MaxWidth)%@NL@%
                        END IF%@NL@%
%@NL@%
                ELSEIF GP.XMode = cValue AND GE.XAxis.Labeled = cYes THEN%@NL@%
%@NL@%
%@AB@%                        ' Then space over 1/2 of the leftmost label on the X Axis if it's%@AE@%%@NL@%
%@AB@%                        ' a value axis; if it's a category axis assume the label will be%@AE@%%@NL@%
%@AB@%                        ' correct:%@AE@%%@NL@%
                        DLeft% = DLeft% + GP.ValLenX \ 2%@NL@%
                END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' *** RIGHT%@AE@%%@NL@%
%@AB@%        ' For the right, space over 8 pixels from the right:%@AE@%%@NL@%
        DRight% = 12%@NL@%
%@NL@%
%@AB@%        ' Then space over 1/2 of the rightmost label on the X Axis if it's%@AE@%%@NL@%
%@AB@%        ' a value axis; if it's a category axis assume the label will be%@AE@%%@NL@%
%@AB@%        ' correct:%@AE@%%@NL@%
        IF GP.XMode = cValue AND GE.XAxis.Labeled = cYes THEN%@NL@%
                DRight% = DRight% + (GP.ValLenX) \ 2%@NL@%
        END IF%@NL@%
%@NL@%
        DRight% = GP.ChartWid - DRight%%@NL@%
%@NL@%
%@AB@%        ' *** YTIC MARKS%@AE@%%@NL@%
%@AB@%        ' Finally, adjust the window coordinates for tic marks (if it's not a%@AE@%%@NL@%
%@AB@%        ' pie chart):%@AE@%%@NL@%
        IF GE.ChartType <> cPie THEN%@NL@%
                IF GE.YAxis.Labeled = cYes THEN%@NL@%
                        DLeft% = DRight% - (DRight% - DLeft%) / (1 + cTicSize)%@NL@%
                END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' *** LEGEND%@AE@%%@NL@%
%@AB@%        ' Account for the legend if its on the right:%@AE@%%@NL@%
        IF GE.Legend.Legend = cYes AND GP.MSeries = cYes THEN%@NL@%
                IF GE.Legend.Place = cRight THEN%@NL@%
                        A% = GE.Legend.LegendWindow.X1%@NL@%
                        DRight% = DRight% - ABS(GP.ChartWid - A%)%@NL@%
                END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Now we have DLeft%, DRight% we can check if the labels fit on the%@AE@%%@NL@%
%@AB@%        ' X axis or if we need to put them on two rows:%@AE@%%@NL@%
        GP.XStagger = cFalse%@NL@%
        IF GP.XMode = cCategory AND GE.ChartType <> cPie THEN%@NL@%
                clSetChartFont GE.XAxis.TicFont%@NL@%
                TicInterval% = (DRight% - DLeft%) \ GP.NVals%@NL@%
                IF clMaxStrLen%(Cat$(), 1, GP.NVals) + .5 * GFI.MaxWidth > TicInterval% THEN%@NL@%
                        GP.XStagger = cTrue%@NL@%
                END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' If we do have to stagger, check if there is enough space to the%@AE@%%@NL@%
%@AB@%        ' left and right for long categories.  Make adjustments as necessary:%@AE@%%@NL@%
        IF GP.XStagger THEN%@NL@%
                LenLeft% = GetGTextLen%(Cat$(1)) + GFI.AvgWidth%@NL@%
                LenRight% = GetGTextLen%(Cat$(GP.NVals)) + GFI.AvgWidth%@NL@%
                SizeRight% = cTrue%@NL@%
                SizeLeft% = cTrue%@NL@%
                OldRight% = DRight%%@NL@%
                OldLeft% = DLeft%%@NL@%
                DO WHILE SizeRight% OR SizeLeft%%@NL@%
                        IF LenRight% - TicInterval% > 2 * (GP.ChartWid - DRight%) AND 2 * (GP.ChartWid - DRight%) < TicInterval% THEN%@NL@%
                                SizeRight% = cTrue%@NL@%
                        ELSE%@NL@%
                                SizeRight% = cFalse%@NL@%
                        END IF%@NL@%
                        IF SizeRight% THEN%@NL@%
                                TicInterval% = (2 * (GP.ChartWid - DLeft%) - LenRight%) \ (2 * GP.NVals - 1)%@NL@%
                                IF LenRight% > 2 * TicInterval% THEN%@NL@%
                                        TicInterval% = (GP.ChartWid - DLeft%) / (GP.NVals + .5)%@NL@%
                                END IF%@NL@%
                                DRight% = DLeft% + GP.NVals * TicInterval%%@NL@%
                        END IF%@NL@%
                        IF LenLeft% - TicInterval% > 2 * DLeft% AND 2 * DLeft% < TicInterval% THEN%@NL@%
                                SizeLeft% = cTrue%@NL@%
                        ELSE%@NL@%
                                SizeLeft% = cFalse%@NL@%
                        END IF%@NL@%
                        IF SizeLeft% THEN%@NL@%
                                TicInterval% = (2 * DRight% - LenLeft%) \ (2 * GP.NVals - 1)%@NL@%
                                IF LenLeft% > 2 * TicInterval% THEN%@NL@%
                                        TicInterval% = DRight% / (GP.NVals + .5)%@NL@%
                                END IF%@NL@%
                                DLeft% = DRight% - GP.NVals * TicInterval%%@NL@%
                        END IF%@NL@%
%@NL@%
%@AB@%                        ' Make sure we haven't gone too far on either side:%@AE@%%@NL@%
                        IF DRight% > OldRight% THEN%@NL@%
                                DRight% = OldRight%%@NL@%
                        END IF%@NL@%
                        IF DLeft% < OldLeft% THEN%@NL@%
                                DLeft% = OldLeft%%@NL@%
                        END IF%@NL@%
%@NL@%
%@AB@%                        ' Check if there has been a change, if not, we are done:%@AE@%%@NL@%
                        IF ABS(ChangeRight% - DRight%) + ABS(ChangeLeft% - DLeft%) > 0 THEN%@NL@%
                                EXIT DO%@NL@%
                        ELSE%@NL@%
                                ChangeRight% = DRight%%@NL@%
                                ChangeLeft% = DLeft%%@NL@%
                        END IF%@NL@%
                LOOP%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' *** BOTTOM%@AE@%%@NL@%
        DBot% = XTitleLayout.TotalSize%@NL@%
%@NL@%
%@AB@%        ' If axis is labeled (and not a pie chart), add row for tic%@AE@%%@NL@%
%@AB@%        ' labels + 1/2 row spacing:%@AE@%%@NL@%
        IF GE.XAxis.Labeled = cYes AND GE.ChartType <> cPie THEN%@NL@%
                IF GP.XStagger = cTrue THEN%@NL@%
                        DBot% = DBot% + 3 * GFI.PixHeight%@NL@%
                ELSE%@NL@%
                        DBot% = DBot% + 1.5 * GFI.PixHeight%@NL@%
                END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Make the setting relative to the chart window:%@AE@%%@NL@%
        DBot% = GP.ChartHgt - 1 - DBot%%@NL@%
%@NL@%
%@NL@%
%@AB@%        ' *** XTIC MARKS%@AE@%%@NL@%
%@AB@%        ' Finally, adjust the window coordinates for tic marks (if it's not a%@AE@%%@NL@%
%@AB@%        ' pie chart):%@AE@%%@NL@%
        IF GE.ChartType <> cPie THEN%@NL@%
                IF GE.XAxis.Labeled = cYes THEN%@NL@%
                        DBot% = DTop% + (DBot% - DTop%) / (1 + cTicSize)%@NL@%
                END IF%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' *** LEGEND%@AE@%%@NL@%
%@AB@%        ' Account for the legend if its on the bottom:%@AE@%%@NL@%
        IF GE.Legend.Legend = cYes AND GP.MSeries = cYes THEN%@NL@%
                IF GE.Legend.Place = cBottom THEN%@NL@%
                        A% = GE.Legend.LegendWindow.Y1%@NL@%
                        DBot% = DBot% - ABS(GP.ChartHgt - A%)%@NL@%
                END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Install values in the DataWindow definition:%@AE@%%@NL@%
        GE.DataWindow.X1 = DLeft%%@NL@%
        GE.DataWindow.X2 = DRight%%@NL@%
        GE.DataWindow.Y1 = DTop%%@NL@%
        GE.DataWindow.Y2 = DBot%%@NL@%
%@NL@%
%@AB@%        ' If the window is invalid then set error:%@AE@%%@NL@%
        IF DLeft% >= DRight% OR DTop% >= DBot% THEN%@NL@%
                clSetError cBadDataWindow%@NL@%
        END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clSpaceTics - Calculates TicInterval%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     The TicInterval will be altered%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     The TicInterval is the distance between tic marks in WORLD%@AE@%%@NL@%
%@AB@%'     coordinates (i.e. the coordinates your data are in)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clSpaceTics%@NL@%
SHARED GE AS ChartEnvironment, GP AS GlobalParams%@NL@%
SHARED GFI AS FontInfo%@NL@%
%@NL@%
%@AB@%        ' X-Axis:%@AE@%%@NL@%
%@AB@%        ' Calculate the length of the axis and of the longest tic label.  Then,%@AE@%%@NL@%
%@AB@%        ' use that information to calculate the number of tics that will fit:%@AE@%%@NL@%
        clSetChartFont GE.XAxis.TicFont%@NL@%
        AxisLen% = GE.DataWindow.X2 - GE.DataWindow.X1 + 1%@NL@%
        TicWid% = GP.ValLenX + GFI.MaxWidth%@NL@%
        clSpaceTicsA GE.XAxis, GP.XMode, AxisLen%, TicWid%%@NL@%
%@NL@%
%@AB@%        ' Y-Axis:%@AE@%%@NL@%
%@AB@%        ' Same procedure as above:%@AE@%%@NL@%
        clSetChartFont GE.YAxis.TicFont%@NL@%
        AxisLen% = GE.DataWindow.Y2 - GE.DataWindow.Y1 + 1%@NL@%
        TicWid% = 2 * GFI.Ascent%@NL@%
        clSpaceTicsA GE.YAxis, GP.YMode, AxisLen%, TicWid%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clSpaceTicsA - Figures out TicInterval for an axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Axis     -  An AxisType variable to space tics for%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     AxisMode%-  cCategory or cValue%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     AxisLen% -  Length of the axis in pixels%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     The TicInterval value may be changed for an axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     The TicInterval is the distance between tic marks in adjusted world%@AE@%%@NL@%
%@AB@%'     coordinates (i.e. the coordinates your data are in scaled by%@AE@%%@NL@%
%@AB@%'     ScaleFactor and adjusted by LogBase if it is a log axis).%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clSpaceTicsA (Axis AS AxisType, AxisMode%, AxisLen%, TicWid%)%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' If this is a category axis the tic interval is 1%@AE@%%@NL@%
%@AB@%        ' divided by the number-of-categories:%@AE@%%@NL@%
        IF AxisMode% = cCategory THEN%@NL@%
                Axis.TicInterval = 1 / GP.NVals%@NL@%
                EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Otherwise, if we're supposed to scale this axis then the tic interval%@AE@%%@NL@%
%@AB@%        ' depends on how many will fit and some aesthetic considerations:%@AE@%%@NL@%
        IF Axis.AutoScale = cYes THEN%@NL@%
%@NL@%
%@AB@%                ' Figure which is bigger in absolute value between scale maximum%@AE@%%@NL@%
%@AB@%                ' and minimum:%@AE@%%@NL@%
                MaxRange = ABS(Axis.ScaleMax)%@NL@%
                IF ABS(Axis.ScaleMin) > MaxRange THEN MaxRange = ABS(Axis.ScaleMin)%@NL@%
%@NL@%
%@AB@%                ' Calculate the maximum number of tic marks that will fit:%@AE@%%@NL@%
                MaxTics% = INT(AxisLen% / TicWid%)%@NL@%
%@NL@%
%@AB@%                ' If the maximum number of tics is one or less set the tic%@AE@%%@NL@%
%@AB@%                ' interval to the axis range and the number of tics to one:%@AE@%%@NL@%
                IF MaxTics% <= 1 THEN%@NL@%
                        NumTics% = 1%@NL@%
                        TicInterval = Axis.ScaleMax - Axis.ScaleMin%@NL@%
%@NL@%
                ELSE%@NL@%
%@AB@%                        ' Guess that the tic interval is equal to 1/10th of the order%@AE@%%@NL@%
%@AB@%                        ' of magnitude of the largest of the scale max or min:%@AE@%%@NL@%
                        TicInterval = .1 * 10 ^ INT(LOG(MaxRange) / LOG(10!))%@NL@%
%@NL@%
%@AB@%                        ' If this doesn't result in too many tic marks then OK. Otherwise%@AE@%%@NL@%
%@AB@%                        ' multiply the tic interval by 2 and 5 alternatively until the%@AE@%%@NL@%
%@AB@%                        ' number of tic marks falls into the acceptable range.%@AE@%%@NL@%
                        NextStep% = 2%@NL@%
                        ScaleRange = Axis.ScaleMax - Axis.ScaleMin%@NL@%
                        DO%@NL@%
                                NumTics% = -INT(-ScaleRange / TicInterval)%@NL@%
                                IF (NumTics% <= MaxTics%) THEN EXIT DO%@NL@%
                                TicInterval = TicInterval * NextStep%%@NL@%
                                NextStep% = 7 - NextStep%%@NL@%
                        LOOP UNTIL NumTics% <= MaxTics%%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Set Axis.TicInterval and adjust scale maximum and minimum:%@AE@%%@NL@%
                Axis.TicInterval = TicInterval%@NL@%
                IF ABS(TicInterval) < 1 THEN%@NL@%
                        Axis.TicDecimals = -INT(-ABS(LOG(1.1 * TicInterval) / LOG(10!)))%@NL@%
                END IF%@NL@%
%@NL@%
                Axis.ScaleMax = -INT(-Axis.ScaleMax / TicInterval) * TicInterval%@NL@%
                Axis.ScaleMin = INT(Axis.ScaleMin / TicInterval) * TicInterval%@NL@%
        END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clTitleXAxis - Draws titles on X axis (AxisTitle and ScaleTitle)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Axis  -  AxisType variable describing axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     X1%   -  Left of DataWindow%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     X2%   -  Right of DataWindow%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     YBoundry%   -  Top boundry of title block%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clTitleXAxis (Axis AS AxisType, X1%, X2%, YBoundry%)%@NL@%
SHARED GFI AS FontInfo%@NL@%
SHARED XTitleLayout AS TitleLayout%@NL@%
%@NL@%
        CH% = GFI.PixHeight%@NL@%
        CW% = GFI.MaxWidth%@NL@%
%@NL@%
%@AB@%        ' Set position of first title:%@AE@%%@NL@%
        Y% = YBoundry% + XTitleLayout.Top%@NL@%
%@NL@%
%@AB@%        ' Loop through the two titles (AxisTitle and ScaleTitle), printing%@AE@%%@NL@%
%@AB@%        ' them if they aren't blank:%@AE@%%@NL@%
        FOR i% = 1 TO 2%@NL@%
%@NL@%
%@AB@%                ' Get the test, color, and justification for the title to be printed:%@AE@%%@NL@%
                SELECT CASE i%%@NL@%
%@NL@%
                        CASE 1:  ' AxisTitle%@NL@%
                                Txt$ = Axis.AxisTitle.Title%@NL@%
                                C% = Axis.AxisTitle.TitleColor%@NL@%
                                J% = Axis.AxisTitle.Justify%@NL@%
                                F% = Axis.AxisTitle.TitleFont%@NL@%
                                Lead% = XTitleLayout.Middle%@NL@%
%@NL@%
                        CASE 2:  ' ScaleTitle%@NL@%
                                Txt$ = Axis.ScaleTitle.Title%@NL@%
                                C% = Axis.ScaleTitle.TitleColor%@NL@%
                                J% = Axis.ScaleTitle.Justify%@NL@%
                                F% = Axis.ScaleTitle.TitleFont%@NL@%
                                Lead% = XTitleLayout.Bottom%@NL@%
%@NL@%
                END SELECT%@NL@%
                clSetChartFont F%%@NL@%
                Txt$ = RTRIM$(Txt$)%@NL@%
                TxtLen% = GetGTextLen(Txt$)%@NL@%
%@NL@%
%@AB@%                ' If the title isn't all blank:%@AE@%%@NL@%
                IF TxtLen% <> 0 THEN%@NL@%
%@NL@%
%@AB@%                        ' Set the title's color:%@AE@%%@NL@%
                        clSetCharColor C%%@NL@%
%@NL@%
%@AB@%                        ' Calculate x position of title's first character depending on%@AE@%%@NL@%
%@AB@%                        ' the justification flag:%@AE@%%@NL@%
                        SELECT CASE J%%@NL@%
                                CASE cLeft:   X% = X1%%@NL@%
                                CASE cCenter: X% = ((X1% + X2%) - TxtLen%) / 2%@NL@%
                                CASE ELSE:    X% = X2% - TxtLen%%@NL@%
                        END SELECT%@NL@%
%@NL@%
%@AB@%                        ' Write out the text:%@AE@%%@NL@%
                        clHPrint X%, Y%, Txt$%@NL@%
%@NL@%
%@AB@%                        ' Move down to the next title position:%@AE@%%@NL@%
                        Y% = Y% + GFI.PixHeight + XTitleLayout.Middle%@NL@%
%@NL@%
                END IF%@NL@%
%@NL@%
        NEXT i%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clTitleYAxis - Draws titles on Y axis (AxisTitle and ScaleTitle)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Axis  -  AxisType variable describing axis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y1%   -  Top of DataWindow%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y2%   -  Bottom of DataWindow%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clTitleYAxis (Axis AS AxisType, Y1%, Y2%) STATIC%@NL@%
SHARED GFI AS FontInfo%@NL@%
SHARED YTitleLayout AS TitleLayout%@NL@%
%@NL@%
%@NL@%
%@AB@%        ' Set position for first title:%@AE@%%@NL@%
        X% = YTitleLayout.Top%@NL@%
%@NL@%
%@AB@%        ' Loop through the two titles (AxisTitle and ScaleTitle), printing%@AE@%%@NL@%
%@AB@%        ' them if they aren't blank:%@AE@%%@NL@%
        FOR i% = 1 TO 2%@NL@%
%@NL@%
%@AB@%                ' Get the test, color, and justification for the title to be printed:%@AE@%%@NL@%
                SELECT CASE i%%@NL@%
%@NL@%
                        CASE 1:  ' AxisTitle%@NL@%
                                Txt$ = Axis.AxisTitle.Title%@NL@%
                                C% = Axis.AxisTitle.TitleColor%@NL@%
                                J% = Axis.AxisTitle.Justify%@NL@%
                                F% = Axis.AxisTitle.TitleFont%@NL@%
                                Lead% = YTitleLayout.TitleOne + YTitleLayout.Middle%@NL@%
%@NL@%
                        CASE 2:  ' ScaleTitle%@NL@%
                                Txt$ = Axis.ScaleTitle.Title%@NL@%
                                C% = Axis.ScaleTitle.TitleColor%@NL@%
                                J% = Axis.ScaleTitle.Justify%@NL@%
                                F% = Axis.ScaleTitle.TitleFont%@NL@%
                                Lead% = 0%@NL@%
%@NL@%
                END SELECT%@NL@%
                clSetChartFont F%%@NL@%
                Txt$ = RTRIM$(Txt$)%@NL@%
                TxtLen% = GetGTextLen(Txt$)%@NL@%
%@NL@%
                IF TxtLen% <> 0 THEN%@NL@%
%@NL@%
%@AB@%                        ' Set title's color:%@AE@%%@NL@%
                        clSetCharColor C%%@NL@%
%@NL@%
%@AB@%                        ' Calculate y position of title's first character depending on%@AE@%%@NL@%
%@AB@%                        ' the justification flag:%@AE@%%@NL@%
                        SELECT CASE J%%@NL@%
                                CASE cLeft:   Y% = Y2%%@NL@%
                                CASE cCenter: Y% = ((Y1% + Y2%) + TxtLen%) / 2%@NL@%
                                CASE ELSE:    Y% = Y1% + (TxtLen% - 1)%@NL@%
                        END SELECT%@NL@%
%@NL@%
%@AB@%                        ' Write out the text:%@AE@%%@NL@%
                        clVPrint X%, Y%, Txt$%@NL@%
%@NL@%
%@AB@%                        ' Move to next title position:%@AE@%%@NL@%
                        X% = X% + Lead%%@NL@%
%@NL@%
                END IF%@NL@%
%@NL@%
        NEXT i%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clUnFlagSystem - Sets GP.SysFlag to cNo%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Alters the value of GP.SysFlag%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clUnFlagSystem%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
        GP.SysFlag = cNo%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== clVal2Str$ - Converts a single precision value to a string%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     X        -  The value to convert%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Places%  -  The number of places after the decimal to produce%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Format%  -  1 For normal, other than 1 for exponential%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Returns a string representation of the input number%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION clVal2Str$ (X, Places%, Format%)%@NL@%
%@NL@%
%@AB@%        ' Make a local copy of the value:%@AE@%%@NL@%
        XX = ABS(X)%@NL@%
%@NL@%
%@AB@%        ' Force format to exponential if that is specified or number is%@AE@%%@NL@%
%@AB@%        ' bigger than a long integer will hold (2^31-1):%@AE@%%@NL@%
        IF Format% <> cNormFormat OR XX >= 2 ^ 31 THEN%@NL@%
%@NL@%
%@AB@%                ' For exponential format calculate the exponent that will make%@AE@%%@NL@%
%@AB@%                ' one decimal to left of decimal place.  This is done by truncating%@AE@%%@NL@%
%@AB@%                ' the log (base 10) of XX:%@AE@%%@NL@%
                IF XX = 0 THEN ExpX = 0 ELSE ExpX = INT(LOG(XX) / LOG(10))%@NL@%
                XX = XX / (10 ^ ExpX)%@NL@%
%@NL@%
%@AB@%                ' If no decimals are specified then a number of 9.5x will be%@AE@%%@NL@%
%@AB@%                ' rounded up to 10 leaving two places to left of decimal so check%@AE@%%@NL@%
%@AB@%                ' for that and if that occurs divide number by 10 and add 1 to exponent:%@AE@%%@NL@%
                IF Places% <= 0 AND CLNG(XX) > 9 THEN%@NL@%
                        XX = XX / 10%@NL@%
                        ExpX = ExpX + 1%@NL@%
                END IF%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' If no decimal places are specified then generate a rounded integer:%@AE@%%@NL@%
        IF Places% <= 0 THEN%@NL@%
                ValStr$ = LTRIM$(STR$(CLNG(XX)))%@NL@%
%@NL@%
%@AB@%        ' If decimal places are called for, round number to requisite number of%@AE@%%@NL@%
%@AB@%        ' decimals and generate string:%@AE@%%@NL@%
        ELSE%@NL@%
%@NL@%
%@AB@%                ' Limit places after decimal to six:%@AE@%%@NL@%
                DP% = Places%%@NL@%
                IF DP% > 6 THEN DP% = 6%@NL@%
                RF% = 10 ^ DP%%@NL@%
%@NL@%
%@AB@%                ' Figure out integer portion:%@AE@%%@NL@%
                IntX = FIX(XX)%@NL@%
%@NL@%
%@AB@%                ' Round the fractional part to correct number of decimals.  If%@AE@%%@NL@%
%@AB@%                ' the fraction carries to the 1's place in the rounding%@AE@%%@NL@%
%@AB@%                ' adjust IntX by adding 1:%@AE@%%@NL@%
                FracX = CLNG((1 + XX - IntX) * RF%)%@NL@%
                IF FracX >= 2 * RF% THEN%@NL@%
                        IntX = IntX + 1%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                'Finally, generate the output string:%@AE@%%@NL@%
                ValStr$ = LTRIM$(STR$(IntX)) + "." + MID$(STR$(FracX), 3)%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Add exponent ending if format is exponent:%@AE@%%@NL@%
        IF Format% <> cNormFormat OR ABS(X) > 2 ^ 31 THEN%@NL@%
                ValStr$ = ValStr$ + "E"%@NL@%
                IF ExpX >= 0 THEN ValStr$ = ValStr$ + "+"%@NL@%
                ValStr$ = ValStr$ + LTRIM$(STR$(ExpX))%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Add minus sign if appropriate:%@AE@%%@NL@%
        IF X < 0 AND VAL(ValStr$) <> 0 THEN ValStr$ = "-" + ValStr$%@NL@%
        clVal2Str$ = ValStr$%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== clVPrint - Prints text vertically on the screen%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     X     -  X position of lower left of first char (in absolute screen%@AE@%%@NL@%
%@AB@%'              coordinates)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y     -  Y position of lower left of first char (in absolute screen%@AE@%%@NL@%
%@AB@%'              coordinates)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Txt$  -  Text to print%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB clVPrint (X%, Y%, Txt$)%@NL@%
%@NL@%
%@AB@%        ' Map the input coordinates relative to the current viewport:%@AE@%%@NL@%
        X = PMAP(X%, 2)%@NL@%
        Y = PMAP(Y%, 3)%@NL@%
%@NL@%
%@AB@%        ' Print text out vertically:%@AE@%%@NL@%
        SetGTextDir 1%@NL@%
        TextLen% = OutGText(X, Y, Txt$)%@NL@%
        SetGTextDir 0%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== DefaultChart - Sets up the ChartEnvironment variable to generate a%@AE@%%@NL@%
%@AB@%'                   default chart of the type and style specified%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env        - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ChartType  - The chart type desired: 1=Bar, 2=Column, 3=Line,%@AE@%%@NL@%
%@AB@%'                  4=Scatter, 5=Pie%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ChartStyle - The chart style (depends on type, see README file)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Elements of Env variable are set to default values%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     This subprogram should be called to initialize the ChartEnvironment%@AE@%%@NL@%
%@AB@%'     variable before a charting routine is called.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB DefaultChart (Env AS ChartEnvironment, ChartType AS INTEGER, ChartStyle AS INTEGER)%@NL@%
%@NL@%
SHARED DTitle AS TitleType, DWindow AS RegionType%@NL@%
SHARED DAxis AS AxisType, DLegend AS LegendType%@NL@%
%@NL@%
%@AB@%        ' Clear any previous chart errors:%@AE@%%@NL@%
        clClearError%@NL@%
%@NL@%
%@AB@%        ' Check initialization:%@AE@%%@NL@%
        clChkInit%@NL@%
%@NL@%
%@AB@%  ' Put type in environment:%@AE@%%@NL@%
        IF ChartType < 1 OR ChartType > 5 THEN%@NL@%
                clSetError cBadType%@NL@%
                EXIT SUB%@NL@%
        END IF%@NL@%
        Env.ChartType = ChartType%@NL@%
%@NL@%
%@AB@%        ' Put chart style in environment:%@AE@%%@NL@%
        IF ChartStyle < 1 OR ChartStyle > 2 THEN%@NL@%
                clSetError cBadStyle%@NL@%
                ChartStyle = 1%@NL@%
        END IF%@NL@%
        Env.ChartStyle = ChartStyle%@NL@%
%@NL@%
%@AB@%        ' Set elements of chart to default:%@AE@%%@NL@%
        Env.DataFont = 1%@NL@%
%@NL@%
        Env.MainTitle = DTitle%@NL@%
        Env.SubTitle = DTitle%@NL@%
%@NL@%
        Env.ChartWindow = DWindow           ' Chart window is default window%@NL@%
        Env.ChartWindow.Border = cYes       ' with a border.%@NL@%
%@NL@%
        Env.DataWindow = DWindow%@NL@%
%@NL@%
        Env.XAxis = DAxis%@NL@%
        Env.YAxis = DAxis%@NL@%
%@NL@%
        Env.Legend = DLegend%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== GetPaletteDef - Changes an entry in the internal palette%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     C%()     -  Color palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     S%()     -  Style palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     P$()     -  Pattern palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Char%()  -  Plot character palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     B%()     -  Border style palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Chart error may be set%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB GetPaletteDef (C() AS INTEGER, s() AS INTEGER, P$(), Char() AS INTEGER, B() AS INTEGER)%@NL@%
SHARED GP AS GlobalParams%@NL@%
SHARED PaletteC%(), PaletteS%(), PaletteP$(), PaletteCh%(), PaletteB%()%@NL@%
%@NL@%
%@AB@%        ' Reset any outstanding errors:%@AE@%%@NL@%
        clClearError%@NL@%
%@NL@%
%@AB@%        ' Make sure palettes have been initialized:%@AE@%%@NL@%
        IF NOT GP.PaletteSet THEN%@NL@%
                clSetError cPalettesNotSet%@NL@%
                EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Make sure the user's palettes are the correct size:%@AE@%%@NL@%
        clChkPalettes C(), s(), P$(), Char(), B()%@NL@%
        IF (ChartErr <> 0) THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Replace the palette values with input variables (making sure that%@AE@%%@NL@%
%@AB@%        ' the color and character numbers are in range):%@AE@%%@NL@%
        FOR N% = 0 TO cPalLen%@NL@%
                C(N%) = PaletteC%(N%)%@NL@%
                s(N%) = PaletteS%(N%)%@NL@%
                P$(N%) = PaletteP$(N%)%@NL@%
                Char(N%) = PaletteCh%(N%)%@NL@%
                B(N%) = PaletteB%(N%)%@NL@%
        NEXT N%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== GetPattern - Returns a pattern from among 3 pattern palettes%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Bits%       -  The number of bits per pixel for the pattern%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     PatternNum% -  The pattern number to return%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Returns a pattern tile from the list below.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     Below are three pattern sets.  There is a set of patterns for one, two%@AE@%%@NL@%
%@AB@%'     and eight bit-per-pixel screens.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION GetPattern$ (Bits%, PatternNum%)%@NL@%
%@NL@%
        SELECT CASE Bits%%@NL@%
%@NL@%
%@AB@%                ' One bit-per-pixel patterns:%@AE@%%@NL@%
                CASE 1:%@NL@%
                        SELECT CASE PatternNum%%@NL@%
                                CASE 1: P$ = CHR$(&HFF)%@NL@%
                                CASE 2: P$ = CHR$(&H55) + CHR$(&HAA)%@NL@%
                                CASE 3: P$ = CHR$(&H33) + CHR$(&HCC)%@NL@%
                                CASE 4: P$ = CHR$(&H0) + CHR$(&HE7)%@NL@%
                                CASE 5: P$ = CHR$(&H7F) + CHR$(&HBF) + CHR$(&HDF) + CHR$(&HEF) + CHR$(&HF7) + CHR$(&HFB) + CHR$(&HFD) + CHR$(&HFE)%@NL@%
                                CASE 6: P$ = CHR$(&H7E) + CHR$(&HBD) + CHR$(&HDB) + CHR$(&HE7) + CHR$(&HE7) + CHR$(&HDB) + CHR$(&HBD) + CHR$(&H7E)%@NL@%
                                CASE 7: P$ = CHR$(&HFE) + CHR$(&HFD) + CHR$(&HFB) + CHR$(&HF7) + CHR$(&HEF) + CHR$(&HDF) + CHR$(&HBF) + CHR$(&H7F)%@NL@%
                                CASE 8: P$ = CHR$(&H33) + CHR$(&HCC) + CHR$(&HCC) + CHR$(&H33)%@NL@%
                                CASE 9: P$ = CHR$(&H0) + CHR$(&HFD) + CHR$(&H0) + CHR$(&HF7) + CHR$(&H0) + CHR$(&HDF) + CHR$(&H0) + CHR$(&H7F)%@NL@%
                                CASE 10: P$ = CHR$(&HF) + CHR$(&H87) + CHR$(&HC3) + CHR$(&HE1) + CHR$(&HF0) + CHR$(&H78) + CHR$(&H3C) + CHR$(&H1E)%@NL@%
                                CASE 11: P$ = CHR$(&HA8) + CHR$(&H51) + CHR$(&HA2) + CHR$(&H45) + CHR$(&H8A) + CHR$(&H15) + CHR$(&H2A) + CHR$(&H54)%@NL@%
                                CASE 12: P$ = CHR$(&HAA) + CHR$(&H55) + CHR$(&H0) + CHR$(&H0) + CHR$(&HAA) + CHR$(&H55) + CHR$(&H0) + CHR$(&H0)%@NL@%
                                CASE 13: P$ = CHR$(&H2A) + CHR$(&H15) + CHR$(&H8A) + CHR$(&H45) + CHR$(&HA2) + CHR$(&H51) + CHR$(&HA8) + CHR$(&H54)%@NL@%
                                CASE 14: P$ = CHR$(&H88) + CHR$(&H0) + CHR$(&H22) + CHR$(&H0) + CHR$(&H88) + CHR$(&H0) + CHR$(&H22) + CHR$(&H0)%@NL@%
                                CASE 15: P$ = CHR$(&HFF) + CHR$(&H0) + CHR$(&HFF) + CHR$(&H0) + CHR$(&HFF) + CHR$(&H0) + CHR$(&HFF) + CHR$(&H0)%@NL@%
                        END SELECT%@NL@%
%@NL@%
%@AB@%                ' Two bit-per-pixel patterns:%@AE@%%@NL@%
                CASE 2:%@NL@%
                        SELECT CASE PatternNum%%@NL@%
                                CASE 1: P$ = CHR$(&HFF)%@NL@%
                                CASE 2: P$ = CHR$(&HCC) + CHR$(&H33)%@NL@%
                                CASE 3: P$ = CHR$(&HF0) + CHR$(&H3C) + CHR$(&HF) + CHR$(&HC3)%@NL@%
                                CASE 4: P$ = CHR$(&HF0) + CHR$(&HF)%@NL@%
                                CASE 5: P$ = CHR$(&H3) + CHR$(&HC) + CHR$(&H30) + CHR$(&HC0)%@NL@%
                                CASE 6: P$ = CHR$(&HFF) + CHR$(&HC)%@NL@%
                                CASE 7: P$ = CHR$(&HF0) + CHR$(&HF0) + CHR$(&HF) + CHR$(&HF)%@NL@%
                                CASE 8: P$ = CHR$(&HFF) + CHR$(&HC) + CHR$(&H30) + CHR$(&HC0)%@NL@%
                                CASE 9: P$ = CHR$(&HC0) + CHR$(&H30) + CHR$(&HC) + CHR$(&H3)%@NL@%
                                CASE 10: P$ = CHR$(&HC0) + CHR$(&HC)%@NL@%
                                CASE 11: P$ = CHR$(&HCC) + CHR$(&HCC) + CHR$(&H33) + CHR$(&H33)%@NL@%
                                CASE 12: P$ = CHR$(&HCC) + CHR$(&HCC) + CHR$(&H0) + CHR$(&H0)%@NL@%
                                CASE 13: P$ = CHR$(&HFF) + CHR$(&H33) + CHR$(&H33)%@NL@%
                                CASE 14: P$ = CHR$(&HFF) + CHR$(&H0)%@NL@%
                                CASE 15: P$ = CHR$(&HCC) + CHR$(&H30) + CHR$(&H0)%@NL@%
                        END SELECT%@NL@%
%@NL@%
%@AB@%                ' Eight bit-per-pixel patterns:%@AE@%%@NL@%
                CASE 8:%@NL@%
                        P$ = CHR$(&HFF)%@NL@%
%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Return the pattern as the value of the function:%@AE@%%@NL@%
        GetPattern$ = P$%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== LabelChartH - Prints horizontal text on a chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env        - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     X          - Horizontal position of text relative to the left of%@AE@%%@NL@%
%@AB@%'                  the Chart window (in pixels)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y          - Vertical position of text relative to the top of%@AE@%%@NL@%
%@AB@%'                  the Chart window (in pixels)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Font%      - Font number to use for the text%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     TxtColor   - Color number (in internal color palette) for text%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     TxtString$ - String variable containing text to print%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB LabelChartH (Env AS ChartEnvironment, X AS INTEGER, Y AS INTEGER, Font AS INTEGER, TxtColor AS INTEGER, TxtString$)%@NL@%
%@NL@%
%@AB@%        ' Reset any outstanding errors:%@AE@%%@NL@%
        clClearError%@NL@%
%@NL@%
%@AB@%        ' Check initialization and fonts:%@AE@%%@NL@%
        clChkInit%@NL@%
        clChkFonts%@NL@%
        IF ChartErr >= 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Select ChartWindow as reference viewport:%@AE@%%@NL@%
        clSelectChartWindow%@NL@%
%@NL@%
%@AB@%        ' Select font and set color:%@AE@%%@NL@%
        SelectFont Font%@NL@%
        clSetCharColor TxtColor%@NL@%
%@NL@%
%@AB@%        ' Call internal print routine to print text:%@AE@%%@NL@%
        clHPrint X, Y, TxtString$%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== LabelChartV - Prints vertical text on a chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Env        - A ChartEnvironment variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     X          - Horizontal position of text relative to the left of%@AE@%%@NL@%
%@AB@%'                  the Chart window (in pixels)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y          - Vertical position of text relative to the top of%@AE@%%@NL@%
%@AB@%'                  the Chart window (in pixels)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Font%      - Font number to use for the text%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     TxtColor   - Color number (in internal color palette) for text%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     TxtString$ - String variable containing text to print%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB LabelChartV (Env AS ChartEnvironment, X AS INTEGER, Y AS INTEGER, Font AS INTEGER, TxtColor AS INTEGER, TxtString$)%@NL@%
%@NL@%
%@AB@%        ' Reset any outstanding errors:%@AE@%%@NL@%
        clClearError%@NL@%
%@NL@%
%@AB@%        ' Check initialization and fonts:%@AE@%%@NL@%
        clChkInit%@NL@%
        clChkFonts%@NL@%
        IF ChartErr >= 100 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Select ChartWindow as reference viewport:%@AE@%%@NL@%
        clSelectChartWindow%@NL@%
%@NL@%
%@AB@%        ' Select font and set color:%@AE@%%@NL@%
        SelectFont Font%%@NL@%
        clSetCharColor TxtColor%@NL@%
%@NL@%
%@AB@%        ' Call internal print routine to print text:%@AE@%%@NL@%
        clVPrint X, Y, TxtString$%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== MakeChartPattern$ - Makes a pattern given reference pattern and%@AE@%%@NL@%
%@AB@%'                        foreground and background colors%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     RefPattern$ -  Reference pattern%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     FG%         -  Foreground color%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     BG%         -  Background color%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Returns a pattern in standard PAINT format%@AE@%%@NL@%
%@AB@%'     Sets error cBadScreen if ChartScreen hasn't been called%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION MakeChartPattern$ (RefPattern$, FG AS INTEGER, BG AS INTEGER)%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' Reset any outstanding errors:%@AE@%%@NL@%
        clClearError%@NL@%
%@NL@%
%@AB@%        ' Check initialization:%@AE@%%@NL@%
        clChkInit%@NL@%
        IF ChartErr >= 100 THEN EXIT FUNCTION%@NL@%
        IF NOT GP.PaletteSet THEN%@NL@%
                clSetError cBadScreen%@NL@%
                EXIT FUNCTION%@NL@%
        END IF%@NL@%
%@NL@%
        FGColor% = clMap2Attrib%(FG%)%@NL@%
        BGColor% = clMap2Attrib%(BG%)%@NL@%
%@NL@%
%@AB@%        ' Screens 1, 2, 11 and 13 are 1 bit plane modes and require one method%@AE@%%@NL@%
%@AB@%        ' of generating pattern tiles.  The other modes supported are multiple%@AE@%%@NL@%
%@AB@%        ' bit plane modes and require another method of generating pattern%@AE@%%@NL@%
%@AB@%        ' tiles.  Select the appropriate method for this screen mode:%@AE@%%@NL@%
        SELECT CASE GP.PaletteScrn%@NL@%
%@NL@%
%@AB@%                ' One bit plane modes:%@AE@%%@NL@%
                CASE 1, 2, 11, 13: SinglePlane% = cTrue%@NL@%
                CASE ELSE: SinglePlane% = cFalse%@NL@%
%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Do foreground part of pattern:%@AE@%%@NL@%
        IF SinglePlane% THEN%@NL@%
                        FGPattern$ = clBuildBitP$(GP.PaletteBits, FGColor%, RefPattern$)%@NL@%
        ELSE%@NL@%
                        FGPattern$ = clBuildPlaneP$(GP.PaletteBits, FGColor%, RefPattern$)%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Do background part of pattern (if background color is black then%@AE@%%@NL@%
%@AB@%        ' the pattern is just the foreground pattern):%@AE@%%@NL@%
        IF BGColor% = 0 THEN%@NL@%
                Pattern$ = FGPattern$%@NL@%
%@NL@%
        ELSE%@NL@%
%@AB@%                ' Background reference pattern is inverted foreground pattern:%@AE@%%@NL@%
                BGPattern$ = ""%@NL@%
                FOR i% = 1 TO LEN(RefPattern$)%@NL@%
                        BGPattern$ = BGPattern$ + CHR$(ASC(MID$(RefPattern$, i%, 1)) XOR &HFF)%@NL@%
                NEXT i%%@NL@%
%@NL@%
%@AB@%                ' Build the corresponding PAINT style pattern:%@AE@%%@NL@%
                IF SinglePlane% THEN%@NL@%
                                BGPattern$ = clBuildBitP$(GP.PaletteBits, BGColor%, BGPattern$)%@NL@%
                ELSE%@NL@%
                                BGPattern$ = clBuildPlaneP$(GP.PaletteBits, BGColor%, BGPattern$)%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Put foreground and background patterns back together:%@AE@%%@NL@%
                Pattern$ = ""%@NL@%
                FOR i% = 1 TO LEN(FGPattern$)%@NL@%
                        Pattern$ = Pattern$ + CHR$(ASC(MID$(FGPattern$, i%, 1)) OR ASC(MID$(BGPattern$, i%, 1)))%@NL@%
                NEXT i%%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
        MakeChartPattern$ = Pattern$%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== ResetPaletteDef - Resets charting palettes for last screen%@AE@%%@NL@%
%@AB@%'                      mode set with ChartScreen.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB ResetPaletteDef%@NL@%
SHARED GP AS GlobalParams%@NL@%
%@NL@%
%@AB@%        ' Clear outstanding errors:%@AE@%%@NL@%
        clClearError%@NL@%
%@NL@%
%@AB@%        ' Check initialization:%@AE@%%@NL@%
        clChkInit%@NL@%
%@NL@%
%@AB@%        ' Make sure that ChartScreen has been called at least once:%@AE@%%@NL@%
        IF NOT GP.PaletteSet THEN%@NL@%
                clSetError cBadScreen%@NL@%
                EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Now rebuild the palette with the last set screen mode:%@AE@%%@NL@%
        clBuildPalette GP.PaletteScrn, GP.PaletteBits%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== SetPaletteDef - Changes an entry in the internal palette%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     C%()     -  Color palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     S%()     -  Style palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     P$()     -  Pattern palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Char%()  -  Plot character palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     B%()     -  Border style palette array%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Internal chart palettes may be modified or ChartErr set%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB SetPaletteDef (C() AS INTEGER, s() AS INTEGER, P$(), Char() AS INTEGER, B() AS INTEGER)%@NL@%
SHARED PaletteC%(), PaletteS%(), PaletteP$(), PaletteCh%(), PaletteB%()%@NL@%
%@NL@%
%@AB@%        ' Reset any outstanding errors and check that palettes are dimesioned%@AE@%%@NL@%
%@AB@%        ' correctly:%@AE@%%@NL@%
        clClearError%@NL@%
        clChkPalettes C(), s(), P$(), Char(), B()%@NL@%
        IF (ChartErr <> 0) THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%        ' Check initialization:%@AE@%%@NL@%
        clChkInit%@NL@%
%@NL@%
%@AB@%        ' Replace the palette values with input variables (making sure that%@AE@%%@NL@%
%@AB@%        ' the color and character numbers are in range):%@AE@%%@NL@%
        FOR N% = 0 TO cPalLen%@NL@%
                PaletteC%(N%) = clMap2Attrib%(C%(N%))%@NL@%
                PaletteS%(N%) = s(N%)%@NL@%
                PaletteP$(N%) = P$(N%)%@NL@%
                PaletteCh%(N%) = ABS(Char(N%)) MOD (cMaxChars + 1)%@NL@%
                PaletteB%(N%) = B(N%)%@NL@%
        NEXT N%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CHRTDEM1.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\CHRTDEM1.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'       CHRTDEM1.BAS - second module of the CHRTB demonstration program.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'               Copyright (C) 1989, Microsoft Corporation%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   Main module - CHRTDEMO.BAS%@AE@%%@NL@%
%@AB@%'   Include files - CHRTDEMO.BI%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'chrtdemo.bi'%@AE@%%@NL@%
%@NL@%
%@AB@%'local subs%@AE@%%@NL@%
DECLARE SUB ChangeStyle ()%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ChangeAxis%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Allows user to view and change attributes of either%@AE@%%@NL@%
%@AB@%'              chart axis.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: title$ - window title%@AE@%%@NL@%
%@AB@%'            axis - X or Y axis variable%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ChangeAxis (title$, axis AS AxisType)%@NL@%
%@NL@%
    DIM colorBox AS ListBox%@NL@%
    DIM styleBox AS ListBox%@NL@%
    DIM fontBox AS ListBox%@NL@%
%@NL@%
%@AB@%    ' set up color list box%@AE@%%@NL@%
    colorBox.scrollButton = 2%@NL@%
    colorBox.areaButton = 3%@NL@%
    colorBox.listLen = numColors%@NL@%
    colorBox.topRow = 3%@NL@%
    colorBox.botRow = 16%@NL@%
    colorBox.leftCol = 4%@NL@%
    colorBox.rightCol = 18%@NL@%
    colorBox.listPos = axis.AxisColor + 1%@NL@%
%@NL@%
%@AB@%    ' set up border style list box%@AE@%%@NL@%
    styleBox.scrollButton = 5%@NL@%
    styleBox.areaButton = 6%@NL@%
    styleBox.listLen = MAXSTYLES%@NL@%
    styleBox.topRow = 5%@NL@%
    styleBox.botRow = 16%@NL@%
    styleBox.leftCol = 24%@NL@%
    styleBox.rightCol = 40%@NL@%
    styleBox.listPos = axis.GridStyle%@NL@%
%@NL@%
%@AB@%    ' set up font list box%@AE@%%@NL@%
    fontBox.scrollButton = 8%@NL@%
    fontBox.areaButton = 9%@NL@%
    fontBox.listLen = numFonts%@NL@%
    fontBox.topRow = 5%@NL@%
    fontBox.botRow = 9%@NL@%
    fontBox.leftCol = 46%@NL@%
    fontBox.rightCol = 65%@NL@%
    fontBox.listPos = axis.TicFont%@NL@%
%@NL@%
%@AB@%    ' open window for display%@AE@%%@NL@%
    winRow = 4%@NL@%
    winCol = 6%@NL@%
    WindowOpen 1, winRow, winCol, 22, 73, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 2, title$%@NL@%
    WindowBox 1, 2, 17, 20%@NL@%
    WindowLocate 2, 4%@NL@%
    WindowPrint 2, "Axis Color:"%@NL@%
    WindowBox 1, 22, 17, 42%@NL@%
    WindowLocate 4, 24%@NL@%
    WindowPrint 2, "Grid Style:"%@NL@%
    WindowBox 1, 44, 17, 67%@NL@%
    WindowLocate 4, 46%@NL@%
    WindowPrint 2, "Label Font:"%@NL@%
    WindowLocate 10, 46%@NL@%
    WindowPrint 2, "Range Type:"%@NL@%
    WindowBox 11, 46, 16, 65%@NL@%
    WindowLocate 14, 48%@NL@%
    WindowPrint 2, "Log Base:"%@NL@%
    WindowBox 13, 57, 15, 63%@NL@%
    WindowLine 18%@NL@%
%@NL@%
%@AB@%    ' create list boxes%@AE@%%@NL@%
    CreateListBox colors$(), colorBox, 0%@NL@%
    CreateListBox styles$(), styleBox, 0%@NL@%
    CreateListBox fonts$(), fontBox, 0%@NL@%
%@NL@%
%@AB@%    ' open control buttons%@AE@%%@NL@%
    ButtonOpen 4, 1, "Display Grid", 2, 24, 0, 0, 2%@NL@%
    ButtonOpen 7, 1, "Display Labels", 2, 46, 0, 0, 2%@NL@%
    ButtonOpen 10, 1, "Lin", 12, 48, 0, 0, 3%@NL@%
    ButtonOpen 11, 1, "Log", 12, 57, 0, 0, 3%@NL@%
    ButtonOpen 12, 2, "OK ", 19, 10, 0, 0, 1%@NL@%
    ButtonOpen 13, 1, "Cancel ", 19, 26, 0, 0, 1%@NL@%
    ButtonOpen 14, 1, "Axis Title ", 19, 46, 0, 0, 1%@NL@%
%@NL@%
%@AB@%    ' edit field for log base%@AE@%%@NL@%
    EditFieldOpen 1, LTRIM$(STR$(axis.LogBase)), 14, 58, 0, 7, 5, 20%@NL@%
%@NL@%
%@NL@%
    currButton = 3                                      ' start with cursor on first button (Autoscale)%@NL@%
    currEditField = 0%@NL@%
%@NL@%
    optionButton = axis.RangeType + 9                   ' set proper state for buttons%@NL@%
    ButtonToggle optionButton%@NL@%
    IF axis.Labeled THEN ButtonToggle 7%@NL@%
    IF axis.Grid THEN ButtonToggle 4%@NL@%
%@NL@%
    pushButton = 12                                     ' active command button%@NL@%
%@NL@%
%@AB@%    ' window control loop%@AE@%%@NL@%
    finished = FALSE%@NL@%
    WHILE NOT finished%@NL@%
        WindowDo currButton, currEditField              ' wait for event%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1                                      ' button pressed%@NL@%
                currButton = Dialog(1)%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 4, 7%@NL@%
                        ButtonToggle currButton%@NL@%
                        currEditField = 0%@NL@%
                    CASE 10, 11%@NL@%
                        ButtonToggle optionButton%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonToggle optionButton%@NL@%
                        currEditField = 0%@NL@%
                    CASE 2, 3%@NL@%
                        currEditField = 0%@NL@%
                        ScrollList colors$(), colorBox, currButton, 1, 0, winRow, winCol%@NL@%
                        currButton = 3%@NL@%
                    CASE 5, 6%@NL@%
                        currEditField = 0%@NL@%
                        ScrollList styles$(), styleBox, currButton, 1, 0, winRow, winCol%@NL@%
                        currButton = 6%@NL@%
                    CASE 8, 9%@NL@%
                        currEditField = 0%@NL@%
                        ScrollList fonts$(), fontBox, currButton, 1, 0, winRow, winCol%@NL@%
                        currButton = 9%@NL@%
                    CASE 12, 13%@NL@%
                        pushButton = currButton%@NL@%
                        finished = TRUE%@NL@%
                    CASE 14%@NL@%
                        currEditField = 0%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                        ChangeTitle 2, title$ + " Title", axis.AxisTitle, 6, 14%@NL@%
                END SELECT%@NL@%
            CASE 2                                      ' edit field%@NL@%
                currEditField = 1%@NL@%
                currButton = 0%@NL@%
            CASE 6                                      ' enter%@NL@%
                SELECT CASE pushButton%@NL@%
                    CASE 12, 13: finished = TRUE%@NL@%
                    CASE 14: ChangeTitle 2, title$ + " Title", axis.AxisTitle, 6, 14%@NL@%
                END SELECT%@NL@%
                currButton = pushButton%@NL@%
            CASE 7                                      ' tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0:%@NL@%
                        currEditField = 0%@NL@%
                        currButton = 12%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE 2, 3: currButton = 4%@NL@%
                    CASE 4: currButton = 6%@NL@%
                    CASE 5, 6: currButton = 7%@NL@%
                    CASE 7: currButton = 9%@NL@%
                    CASE 8, 9: currButton = optionButton%@NL@%
                    CASE 10, 11:%@NL@%
                        currButton = 0%@NL@%
                        currEditField = 1%@NL@%
                    CASE 12, 13:%@NL@%
                        currButton = currButton + 1%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE 14:%@NL@%
                        ButtonSetState currButton, 1%@NL@%
                        pushButton = 12%@NL@%
                        ButtonSetState pushButton, 2%@NL@%
                        currButton = 3%@NL@%
                END SELECT%@NL@%
            CASE 8                                      ' back tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0:%@NL@%
                        currEditField = 0%@NL@%
                        currButton = optionButton%@NL@%
                    CASE 2, 3:%@NL@%
                        currButton = 14%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE 4: currButton = 3%@NL@%
                    CASE 5, 6: currButton = 4%@NL@%
                    CASE 7: currButton = 6%@NL@%
                    CASE 8, 9: currButton = 7%@NL@%
                    CASE 10, 11: currButton = 9%@NL@%
                    CASE 12:%@NL@%
                        currButton = 0%@NL@%
                        currEditField = 1%@NL@%
                    CASE 13, 14:%@NL@%
                        currButton = currButton - 1%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                END SELECT%@NL@%
            CASE 9                                      ' escape%@NL@%
                pushButton = 13%@NL@%
                finished = TRUE%@NL@%
            CASE 10, 12                                 ' up, left arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 4, 7: ButtonSetState currButton, 2%@NL@%
                    CASE 2, 3: ScrollList colors$(), colorBox, currButton, 2, 0, winRow, winCol%@NL@%
                    CASE 5, 6: ScrollList styles$(), styleBox, currButton, 2, 0, winRow, winCol%@NL@%
                    CASE 8, 9: ScrollList fonts$(), fontBox, currButton, 2, 0, winRow, winCol%@NL@%
                    CASE 10, 11:%@NL@%
                        ButtonToggle currButton%@NL@%
                        currButton = 21 - currButton%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonToggle optionButton%@NL@%
                END SELECT%@NL@%
            CASE 11, 13                                 ' down, right arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 4, 7: ButtonSetState currButton, 1%@NL@%
                    CASE 2, 3: ScrollList colors$(), colorBox, currButton, 3, 0, winRow, winCol%@NL@%
                    CASE 5, 6: ScrollList styles$(), styleBox, currButton, 3, 0, winRow, winCol%@NL@%
                    CASE 8, 9: ScrollList fonts$(), fontBox, currButton, 3, 0, winRow, winCol%@NL@%
                    CASE 10, 11:%@NL@%
                        ButtonToggle currButton%@NL@%
                        currButton = 21 - currButton%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonToggle optionButton%@NL@%
                END SELECT%@NL@%
            CASE 14                                     ' space bar%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 4, 7: ButtonToggle currButton%@NL@%
                    CASE 12, 13: finished = TRUE%@NL@%
                    CASE 14: ChangeTitle 2, title$ + " Title", axis.AxisTitle, 6, 14%@NL@%
                END SELECT%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' error checking on log base before exiting%@AE@%%@NL@%
        IF finished AND pushButton = 12 THEN%@NL@%
            IF VAL(EditFieldInquire(1)) <= 0 THEN%@NL@%
                PrintError " Log base must be greater than zero."%@NL@%
                currEditField = 1%@NL@%
                currButton = 0%@NL@%
                finished = FALSE%@NL@%
            ELSEIF VAL(EditFieldInquire(1)) = 1 THEN%@NL@%
                PrintError " Log base cannot equal one. Overflow results."%@NL@%
                currEditField = 1%@NL@%
                currButton = 0%@NL@%
                finished = FALSE%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' if not canceled then assign and return new values%@AE@%%@NL@%
    IF pushButton = 12 THEN%@NL@%
        IF setNum > 0 THEN chartChanged = TRUE%@NL@%
%@NL@%
        axis.LogBase = VAL(EditFieldInquire(1))%@NL@%
        axis.Grid = (ButtonInquire(4) = 2)%@NL@%
        axis.Labeled = (ButtonInquire(7) = 2)%@NL@%
        axis.RangeType = optionButton - 9%@NL@%
        axis.AxisColor = colorBox.listPos - 1%@NL@%
        axis.ScaleTitle.TitleColor = axis.AxisTitle.TitleColor%@NL@%
        axis.ScaleTitle.Justify = axis.AxisTitle.Justify%@NL@%
        axis.GridStyle = styleBox.listPos%@NL@%
        axis.TicFont = fontBox.listPos%@NL@%
    END IF%@NL@%
%@NL@%
    WindowClose 1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ChangeChartType%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Changes chart type based on menu selection and%@AE@%%@NL@%
%@AB@%'              allows the user access to changing the chart style.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: ctype - new chart type%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ChangeChartType (ctype)%@NL@%
%@NL@%
%@AB@%    'change type if user selected a different type%@AE@%%@NL@%
    IF CEnv.ChartType <> ctype THEN%@NL@%
        IF setNum > 0 THEN chartChanged = TRUE%@NL@%
%@NL@%
%@AB@%        ' reset chosen type%@AE@%%@NL@%
        MenuItemToggle GALLERYTITLE, CEnv.ChartType%@NL@%
%@AB@%        ' reset other affected menu items%@AE@%%@NL@%
        IF CEnv.ChartType = cPie THEN%@NL@%
            MenuSetState CHARTTITLE, 4, 1%@NL@%
            MenuSetState CHARTTITLE, 5, 1%@NL@%
            MenuSetState TITLETITLE, 3, 1%@NL@%
            MenuSetState TITLETITLE, 4, 1%@NL@%
        END IF%@NL@%
%@NL@%
        CEnv.ChartType = ctype%@NL@%
%@NL@%
%@AB@%        'if new type is pie then turn off some items%@AE@%%@NL@%
        IF CEnv.ChartType = cPie THEN%@NL@%
            MenuSetState CHARTTITLE, 4, 0%@NL@%
            MenuSetState CHARTTITLE, 5, 0%@NL@%
            MenuSetState TITLETITLE, 3, 0%@NL@%
            MenuSetState TITLETITLE, 4, 0%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' set type in menu bar%@AE@%%@NL@%
        MenuItemToggle GALLERYTITLE, CEnv.ChartType%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' allow user to change chart style%@AE@%%@NL@%
    ChangeStyle%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ChangeLegend%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Allows user to view and modify all attributes of the chart%@AE@%%@NL@%
%@AB@%'              legend%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ChangeLegend%@NL@%
%@NL@%
    DIM fgColorBox AS ListBox%@NL@%
    DIM fontBox AS ListBox%@NL@%
%@NL@%
%@AB@%    ' set up foreground color box%@AE@%%@NL@%
    fgColorBox.scrollButton = 6%@NL@%
    fgColorBox.areaButton = 7%@NL@%
    fgColorBox.listLen = numColors%@NL@%
    fgColorBox.topRow = 3%@NL@%
    fgColorBox.botRow = 10%@NL@%
    fgColorBox.leftCol = 27%@NL@%
    fgColorBox.rightCol = 41%@NL@%
    fgColorBox.listPos = CEnv.Legend.TextColor + 1%@NL@%
%@NL@%
%@AB@%    ' set up font box%@AE@%%@NL@%
    fontBox.scrollButton = 8%@NL@%
    fontBox.areaButton = 9%@NL@%
    fontBox.listLen = numFonts%@NL@%
    fontBox.topRow = 3%@NL@%
    fontBox.botRow = 10%@NL@%
    fontBox.leftCol = 43%@NL@%
    fontBox.rightCol = 57%@NL@%
    fontBox.listPos = CEnv.Legend.TextFont%@NL@%
%@NL@%
%@AB@%    ' set up display window%@AE@%%@NL@%
    winRow = 6%@NL@%
    winCol = 10%@NL@%
    WindowOpen 1, winRow, winCol, 18, 69, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 2, "Chart Legend"%@NL@%
    WindowBox 1, 2, 11, 23%@NL@%
    WindowLocate 5, 4%@NL@%
    WindowPrint 2, "Location:"%@NL@%
    WindowBox 6, 4, 10, 21%@NL@%
    WindowBox 1, 25, 11, 59%@NL@%
    WindowLocate 2, 27%@NL@%
    WindowPrint 2, "Text Color:"%@NL@%
    WindowLocate 2, 43%@NL@%
    WindowPrint 2, "Text Font:"%@NL@%
    WindowLine 12%@NL@%
%@NL@%
%@AB@%    ' create list boxes%@AE@%%@NL@%
    CreateListBox colors$(), fgColorBox, 0%@NL@%
    CreateListBox fonts$(), fontBox, 0%@NL@%
%@NL@%
%@AB@%    ' open command buttons%@AE@%%@NL@%
    ButtonOpen 1, 1, "Display Legend", 2, 4, 0, 0, 2%@NL@%
    ButtonOpen 2, 1, "Autosize", 3, 4, 0, 0, 2%@NL@%
    ButtonOpen 3, 1, "Overlay", 7, 6, 0, 0, 3%@NL@%
    ButtonOpen 4, 1, "Bottom", 8, 6, 0, 0, 3%@NL@%
    ButtonOpen 5, 1, "Right", 9, 6, 0, 0, 3%@NL@%
    ButtonOpen 10, 2, "OK ", 13, 8, 0, 0, 1%@NL@%
    ButtonOpen 11, 1, "Cancel ", 13, 21, 0, 0, 1%@NL@%
    ButtonOpen 12, 1, "Legend Window ", 13, 38, 0, 0, 1%@NL@%
%@NL@%
    currButton = 1                                      ' start with cursor on first button%@NL@%
%@NL@%
%@AB@%    ' set button states based on current values%@AE@%%@NL@%
    optionButton = CEnv.Legend.Place + 2%@NL@%
    ButtonToggle optionButton%@NL@%
    IF CEnv.Legend.Legend THEN ButtonToggle 1%@NL@%
    IF CEnv.Legend.AutoSize THEN ButtonToggle 2%@NL@%
    pushButton = 10%@NL@%
%@NL@%
%@AB@%    ' window control loop%@AE@%%@NL@%
    finished = FALSE%@NL@%
    WHILE NOT finished%@NL@%
        WindowDo currButton, 0                          ' wait for event%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1                                      ' button pressed%@NL@%
                currButton = Dialog(1)%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2: ButtonToggle currButton%@NL@%
                    CASE 3, 4, 5%@NL@%
                        ButtonToggle optionButton%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonToggle optionButton%@NL@%
                    CASE 6, 7:%@NL@%
                        ScrollList colors$(), fgColorBox, currButton, 1, 0, winRow, winCol%@NL@%
                        currButton = 7%@NL@%
                    CASE 8, 9:%@NL@%
                        ScrollList fonts$(), fontBox, currButton, 1, 0, winRow, winCol%@NL@%
                        currButton = 9%@NL@%
                    CASE 10, 11%@NL@%
                        pushButton = currButton%@NL@%
                        finished = TRUE%@NL@%
                    CASE 12%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = 12%@NL@%
                        ChangeWindow 2, "Legend Window", CEnv.Legend.LegendWindow%@NL@%
                END SELECT%@NL@%
            CASE 6                                      ' enter%@NL@%
                IF pushButton <> 12 THEN%@NL@%
                    finished = TRUE%@NL@%
                ELSE%@NL@%
                    ChangeWindow 2, "Legend Window", CEnv.Legend.LegendWindow%@NL@%
                END IF%@NL@%
            CASE 7                                      ' tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1: currButton = 2%@NL@%
                    CASE 2: currButton = optionButton%@NL@%
                    CASE 3, 4, 5: currButton = 7%@NL@%
                    CASE 6, 7: currButton = 9%@NL@%
                    CASE 8, 9:%@NL@%
                        currButton = 10%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE 10, 11:%@NL@%
                        currButton = currButton + 1%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE 12:%@NL@%
                        ButtonSetState currButton, 1%@NL@%
                        pushButton = 10%@NL@%
                        ButtonSetState pushButton, 2%@NL@%
                        currButton = 1%@NL@%
                END SELECT%@NL@%
            CASE 8                                      ' back tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1:%@NL@%
                        currButton = 12%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE 2: currButton = 1%@NL@%
                    CASE 3, 4, 5: currButton = 2%@NL@%
                    CASE 6, 7: currButton = optionButton%@NL@%
                    CASE 8, 9: currButton = 7%@NL@%
                    CASE 10: currButton = 9%@NL@%
                    CASE 11, 12:%@NL@%
                        currButton = currButton - 1%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                END SELECT%@NL@%
            CASE 9                                      ' escape%@NL@%
                pushButton = 11%@NL@%
                finished = TRUE%@NL@%
            CASE 10, 12                                 ' up, left arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2: ButtonSetState currButton, 2%@NL@%
                    CASE 3:%@NL@%
                        ButtonToggle currButton%@NL@%
                        currButton = 5%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonToggle optionButton%@NL@%
                    CASE 4, 5:%@NL@%
                        ButtonToggle currButton%@NL@%
                        currButton = currButton - 1%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonToggle optionButton%@NL@%
                    CASE 6, 7: ScrollList colors$(), fgColorBox, currButton, 2, 0, winRow, winCol%@NL@%
                    CASE 8, 9: ScrollList fonts$(), fontBox, currButton, 2, 0, winRow, winCol%@NL@%
                END SELECT%@NL@%
            CASE 11, 13                                 ' down, right arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2: ButtonSetState currButton, 1%@NL@%
                    CASE 3, 4:%@NL@%
                        ButtonToggle currButton%@NL@%
                        currButton = currButton + 1%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonToggle optionButton%@NL@%
                    CASE 5:%@NL@%
                        ButtonToggle currButton%@NL@%
                        currButton = 3%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonToggle optionButton%@NL@%
                    CASE 6, 7: ScrollList colors$(), fgColorBox, currButton, 3, 0, winRow, winCol%@NL@%
                    CASE 8, 9: ScrollList fonts$(), fontBox, currButton, 3, 0, winRow, winCol%@NL@%
                END SELECT%@NL@%
            CASE 14                                     ' space bar%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2: ButtonToggle currButton%@NL@%
                    CASE 10, 11: finished = TRUE%@NL@%
                    CASE 12: ChangeWindow 2, "Legend Window", CEnv.Legend.LegendWindow%@NL@%
               END SELECT%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' if not canceled then return the new values%@AE@%%@NL@%
    IF pushButton = 10 THEN%@NL@%
        IF setNum > 0 THEN chartChanged = TRUE%@NL@%
%@NL@%
        CEnv.Legend.TextColor = fgColorBox.listPos - 1%@NL@%
        CEnv.Legend.TextFont = fontBox.listPos%@NL@%
        CEnv.Legend.AutoSize = (ButtonInquire(2) = 2)%@NL@%
        CEnv.Legend.Legend = (ButtonInquire(1) = 2)%@NL@%
        CEnv.Legend.Place = optionButton - 2%@NL@%
    END IF%@NL@%
%@NL@%
    WindowClose 1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ChangeStyle%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Allows user to view and modify the chart style%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ChangeStyle%@NL@%
DIM fontBox AS ListBox%@NL@%
%@NL@%
%@AB@%    ' determine button labels based on chart type%@AE@%%@NL@%
    SELECT CASE CEnv.ChartType%@NL@%
        CASE cBar, cColumn%@NL@%
            style1$ = "Adjacent"%@NL@%
            style2$ = "Stacked"%@NL@%
        CASE cLine, cScatter%@NL@%
            style1$ = "Lines"%@NL@%
            style2$ = "No Lines"%@NL@%
        CASE cPie%@NL@%
            style1$ = "Percentages"%@NL@%
            style2$ = "No Percentages"%@NL@%
    END SELECT%@NL@%
%@NL@%
    topRow = 8%@NL@%
    leftCol = 26%@NL@%
%@AB@%    ' if pie, line or scatter chart then add data font%@AE@%%@NL@%
    IF CEnv.ChartType > 2 THEN%@NL@%
        WindowOpen 1, topRow, leftCol, 19, 47, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 2, "Chart Style"%@NL@%
        okLine = 12%@NL@%
%@NL@%
        WindowLocate 5, 3%@NL@%
        WindowPrint -2, "Data Font:"%@NL@%
%@AB@%        ' set up list box containing valid fonts%@AE@%%@NL@%
        fontBox.scrollButton = 3%@NL@%
        fontBox.areaButton = 4%@NL@%
        fontBox.listLen = numFonts%@NL@%
        fontBox.topRow = 6%@NL@%
        fontBox.botRow = 10%@NL@%
        fontBox.leftCol = 3%@NL@%
        fontBox.rightCol = 20%@NL@%
        fontBox.listPos = CEnv.DataFont%@NL@%
        CreateListBox fonts$(), fontBox, 0%@NL@%
    ELSE%@NL@%
        WindowOpen 1, topRow, leftCol, 13, 47, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 2, "Chart Style"%@NL@%
        okLine = 6%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' open buttons%@AE@%%@NL@%
    ButtonOpen 1, 1, style1$, 2, 3, 1, 0, 3%@NL@%
    ButtonOpen 2, 1, style2$, 3, 3, 1, 0, 3%@NL@%
    WindowLine okLine - 1%@NL@%
    ButtonOpen 5, 2, "OK", okLine, 3, 1, 0, 1%@NL@%
    ButtonOpen 6, 1, "Cancel", okLine, 11, 1, 0, 1%@NL@%
%@NL@%
    pushButton = 5%@NL@%
    optionButton = CEnv.ChartStyle                     ' set current style%@NL@%
    currButton = optionButton%@NL@%
    ButtonSetState optionButton, 2%@NL@%
%@NL@%
%@AB@%    ' window control loop%@AE@%%@NL@%
    finished = FALSE%@NL@%
    WHILE NOT finished%@NL@%
        WindowDo currButton, 0                          ' wait for event%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1                                      'button pressed%@NL@%
                currButton = Dialog(1)%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2:%@NL@%
                        ButtonSetState optionButton, 1%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonSetState optionButton, 2%@NL@%
                    CASE 3, 4:%@NL@%
                        ScrollList fonts$(), fontBox, currButton, 1, 0, topRow, leftCol%@NL@%
                        currButton = 4%@NL@%
                    CASE 5, 6:%@NL@%
                        finished = TRUE%@NL@%
                END SELECT%@NL@%
            CASE 6                                      'enter%@NL@%
                finished = TRUE%@NL@%
            CASE 7                                      'tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2:%@NL@%
                        IF CEnv.ChartType > 2 THEN%@NL@%
                            currButton = 4%@NL@%
                        ELSE%@NL@%
                            currButton = 5%@NL@%
                            ButtonSetState pushButton, 1%@NL@%
                            pushButton = currButton%@NL@%
                            ButtonSetState pushButton, 2%@NL@%
                        END IF%@NL@%
                    CASE 3, 4:%@NL@%
                        currButton = 5%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        pushButton = currButton%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                    CASE 5:%@NL@%
                        currButton = 6%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        pushButton = currButton%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                    CASE 6:%@NL@%
                        currButton = optionButton%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        pushButton = 5%@NL@%
                        ButtonSetState pushButton, 2%@NL@%
                END SELECT%@NL@%
            CASE 8                                      'back tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2:%@NL@%
                        currButton = 6%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        pushButton = currButton%@NL@%
                        ButtonSetState pushButton, 2%@NL@%
                    CASE 3, 4:%@NL@%
                        currButton = optionButton%@NL@%
                    CASE 5:%@NL@%
                        IF CEnv.ChartType > 2 THEN%@NL@%
                            currButton = 4%@NL@%
                        ELSE%@NL@%
                            currButton = optionButton%@NL@%
                        END IF%@NL@%
                    CASE 6:%@NL@%
                        currButton = 5%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        pushButton = currButton%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                END SELECT%@NL@%
            CASE 9                                      'escape%@NL@%
                finished = TRUE%@NL@%
                pushButton = 5%@NL@%
            CASE 10, 12                                 'up, left arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2:%@NL@%
                        ButtonSetState currButton, 1%@NL@%
                        currButton = 3 - currButton%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                    CASE 3, 4:%@NL@%
                        ScrollList fonts$(), fontBox, currButton, 2, 0, topRow, leftCol%@NL@%
                END SELECT%@NL@%
            CASE 11, 13                                 'down, right arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2:%@NL@%
                        ButtonSetState currButton, 1%@NL@%
                        currButton = 3 - currButton%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                    CASE 3, 4:%@NL@%
                        ScrollList fonts$(), fontBox, currButton, 3, 0, topRow, leftCol%@NL@%
                END SELECT%@NL@%
            CASE 14                                     'space bar%@NL@%
                IF currButton > 4 THEN finished = TRUE%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' if not canceled then set new chart style%@AE@%%@NL@%
    IF pushButton = 5 THEN%@NL@%
        IF setNum > 0 THEN chartChanged = TRUE%@NL@%
        CEnv.ChartStyle = optionButton%@NL@%
        IF CEnv.ChartType > 2 THEN CEnv.DataFont = fontBox.listPos%@NL@%
    END IF%@NL@%
%@NL@%
    WindowClose 1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ChangeTitle%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Allows user to view and modify the chart titles%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: handle - window number%@AE@%%@NL@%
%@AB@%'            wTitle$ - window title%@AE@%%@NL@%
%@AB@%'            title -  chart title%@AE@%%@NL@%
%@AB@%'            topRow - top row of window%@AE@%%@NL@%
%@AB@%'            leftCol - left column of window%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ChangeTitle (handle, wTitle$, title AS TitleType, topRow, leftCol)%@NL@%
SHARED mode$(), numModes AS INTEGER%@NL@%
%@NL@%
    DIM colorBox AS ListBox%@NL@%
    DIM fontBox AS ListBox%@NL@%
%@NL@%
%@AB@%    ' set up foreground color box%@AE@%%@NL@%
    colorBox.scrollButton = 1%@NL@%
    colorBox.areaButton = 2%@NL@%
    colorBox.listLen = numColors%@NL@%
    colorBox.topRow = 6%@NL@%
    colorBox.botRow = 10%@NL@%
    colorBox.leftCol = 2%@NL@%
    colorBox.rightCol = 16%@NL@%
    colorBox.listPos = title.TitleColor + 1%@NL@%
%@NL@%
%@AB@%    ' set up font box%@AE@%%@NL@%
    fontBox.scrollButton = 3%@NL@%
    fontBox.areaButton = 4%@NL@%
    fontBox.listLen = numFonts%@NL@%
    fontBox.topRow = 6%@NL@%
    fontBox.botRow = 10%@NL@%
    fontBox.leftCol = 18%@NL@%
    fontBox.rightCol = 36%@NL@%
    fontBox.listPos = title.TitleFont%@NL@%
%@NL@%
%@AB@%    ' set up display window%@AE@%%@NL@%
    WindowOpen handle, topRow, leftCol, topRow + 11, leftCol + 50, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 2, wTitle$%@NL@%
    WindowLocate 2, 2%@NL@%
    WindowPrint 2, "Title:"%@NL@%
    WindowBox 1, 8, 3, 50%@NL@%
    WindowBox 6, 38, 10, 50%@NL@%
    WindowLine 4%@NL@%
    WindowLine 11%@NL@%
    WindowLocate 5, 1%@NL@%
    WindowPrint -1, " Color:          Font:               Justify:"%@NL@%
%@NL@%
%@AB@%    ' set color attribute for title editfield background to that of the chart background%@AE@%%@NL@%
    IF mode$(1) = "10" OR (mode$(1) = "2" AND mode$(2) <> "1") OR mode$(1) = "3" THEN%@NL@%
        func = 0%@NL@%
        EditFieldOpen 1, RTRIM$(title.title), 2, 9, 0, 7, 41, 70%@NL@%
    ELSE%@NL@%
        SetAtt 5, CEnv.ChartWindow.Background + 1%@NL@%
        EditFieldOpen 1, RTRIM$(title.title), 2, 9, 12, 5, 41, 70%@NL@%
        func = 2%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' create list boxes%@AE@%%@NL@%
    CreateListBox colors$(), colorBox, func%@NL@%
    CreateListBox fonts$(), fontBox, 0%@NL@%
%@NL@%
%@AB@%    ' open buttons%@AE@%%@NL@%
    ButtonOpen 5, 1, "Left", 7, 39, 0, 0, 3%@NL@%
    ButtonOpen 6, 1, "Center", 8, 39, 0, 0, 3%@NL@%
    ButtonOpen 7, 1, "Right", 9, 39, 0, 0, 3%@NL@%
    ButtonOpen 8, 2, "OK ", 12, 10, 0, 0, 1%@NL@%
    ButtonOpen 9, 1, "Cancel ", 12, 33, 0, 0, 1%@NL@%
%@NL@%
    currButton = 0                                      ' start in edit field%@NL@%
    currEditField = 1%@NL@%
    optionButton = 4 + title.Justify                    ' set button state%@NL@%
    ButtonToggle optionButton%@NL@%
    pushButton = 8%@NL@%
%@NL@%
%@AB@%    ' window control loop%@AE@%%@NL@%
    finished = FALSE%@NL@%
    WHILE NOT finished%@NL@%
        WindowDo currButton, currEditField              ' wait for event%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1                                      ' button pressed%@NL@%
                currButton = Dialog(1)%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2%@NL@%
                        currEditField = 0%@NL@%
                        ScrollList colors$(), colorBox, currButton, 1, func, topRow, leftCol%@NL@%
                        currButton = 2%@NL@%
                    CASE 3, 4%@NL@%
                        currEditField = 0%@NL@%
                        ScrollList fonts$(), fontBox, currButton, 1, 0, topRow, leftCol%@NL@%
                        currButton = 4%@NL@%
                    CASE 5, 6, 7%@NL@%
                        ButtonToggle optionButton%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonToggle optionButton%@NL@%
                        currEditField = 0%@NL@%
                    CASE 8, 9%@NL@%
                        pushButton = currButton%@NL@%
                        finished = TRUE%@NL@%
                END SELECT%@NL@%
            CASE 2                                      ' edit field%@NL@%
                currButton = 0%@NL@%
                currEditField = 1%@NL@%
            CASE 6                                      ' enter%@NL@%
                finished = TRUE%@NL@%
            CASE 7                                      ' tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0:%@NL@%
                        currButton = 2%@NL@%
                        currEditField = 0%@NL@%
                    CASE 1, 2: currButton = 4%@NL@%
                    CASE 3, 4: currButton = optionButton%@NL@%
                    CASE 5, 6, 7:%@NL@%
                        currButton = 8%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = 8%@NL@%
                    CASE 8:%@NL@%
                        currButton = currButton + 1%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE 9:%@NL@%
                        ButtonSetState currButton, 1%@NL@%
                        pushButton = 8%@NL@%
                        ButtonSetState pushButton, 2%@NL@%
                        currButton = 0%@NL@%
                        currEditField = 1%@NL@%
                END SELECT%@NL@%
            CASE 8                                      ' back tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0:%@NL@%
                        currButton = 9%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = 9%@NL@%
                        currEditField = 0%@NL@%
                    CASE 1, 2:%@NL@%
                        currButton = 0%@NL@%
                        currEditField = 1%@NL@%
                    CASE 3, 4: currButton = 2%@NL@%
                    CASE 5, 6, 7: currButton = 4%@NL@%
                    CASE 8: currButton = optionButton%@NL@%
                    CASE 9:%@NL@%
                        currButton = currButton - 1%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                END SELECT%@NL@%
            CASE 9                                      ' escape%@NL@%
                pushButton = 9%@NL@%
                finished = TRUE%@NL@%
            CASE 10, 12                                 ' up, left arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2: ScrollList colors$(), colorBox, currButton, 2, func, topRow, leftCol%@NL@%
                    CASE 3, 4: ScrollList fonts$(), fontBox, currButton, 2, 0, topRow, leftCol%@NL@%
                    CASE 5:%@NL@%
                        ButtonToggle currButton%@NL@%
                        currButton = 7%@NL@%
                        optionButton = 7%@NL@%
                        ButtonToggle optionButton%@NL@%
                    CASE 6, 7:%@NL@%
                        ButtonToggle currButton%@NL@%
                        currButton = currButton - 1%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonToggle optionButton%@NL@%
                END SELECT%@NL@%
            CASE 11, 13                                 ' down, right arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2: ScrollList colors$(), colorBox, currButton, 3, func, topRow, leftCol%@NL@%
                    CASE 3, 4: ScrollList fonts$(), fontBox, currButton, 3, 0, topRow, leftCol%@NL@%
                    CASE 5, 6:%@NL@%
                        ButtonToggle currButton%@NL@%
                        currButton = currButton + 1%@NL@%
                        optionButton = currButton%@NL@%
                        ButtonToggle optionButton%@NL@%
                    CASE 7:%@NL@%
                        ButtonToggle currButton%@NL@%
                        currButton = 5%@NL@%
                        optionButton = 5%@NL@%
                        ButtonToggle optionButton%@NL@%
                END SELECT%@NL@%
            CASE 14                                     ' space bar%@NL@%
                IF currButton > 7 THEN%@NL@%
                    pushButton = currButton%@NL@%
                    finished = TRUE%@NL@%
                END IF%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' done and not canceled so return new title information%@AE@%%@NL@%
    IF pushButton = 8 THEN%@NL@%
        IF setNum > 0 THEN chartChanged = TRUE%@NL@%
%@NL@%
        title.title = EditFieldInquire(1)%@NL@%
        title.TitleFont = fontBox.listPos%@NL@%
        title.TitleColor = colorBox.listPos - 1%@NL@%
        title.Justify = optionButton - 4%@NL@%
    END IF%@NL@%
%@NL@%
    WindowClose handle%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ChangeWindow%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Allows user to view and modify any of the chart windows%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: handle - window number%@AE@%%@NL@%
%@AB@%'            wTitle$ - window title%@AE@%%@NL@%
%@AB@%'            win - chart window%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ChangeWindow (handle, title$, win AS RegionType)%@NL@%
%@NL@%
    DIM bgColorBox AS ListBox%@NL@%
    DIM bdColorBox AS ListBox%@NL@%
    DIM bdStyleBox AS ListBox%@NL@%
%@NL@%
%@AB@%    ' set up background color box%@AE@%%@NL@%
    bgColorBox.scrollButton = 1%@NL@%
    bgColorBox.areaButton = 2%@NL@%
    bgColorBox.listLen = numColors%@NL@%
    bgColorBox.topRow = 4%@NL@%
    bgColorBox.botRow = 14%@NL@%
    bgColorBox.leftCol = 4%@NL@%
    bgColorBox.rightCol = 18%@NL@%
    bgColorBox.listPos = win.Background + 1%@NL@%
%@NL@%
%@AB@%    ' set up border color box%@AE@%%@NL@%
    bdColorBox.scrollButton = 3%@NL@%
    bdColorBox.areaButton = 4%@NL@%
    bdColorBox.listLen = numColors%@NL@%
    bdColorBox.topRow = 5%@NL@%
    bdColorBox.botRow = 14%@NL@%
    bdColorBox.leftCol = 24%@NL@%
    bdColorBox.rightCol = 38%@NL@%
    bdColorBox.listPos = win.BorderColor + 1%@NL@%
%@NL@%
%@AB@%    ' set up border style box%@AE@%%@NL@%
    bdStyleBox.scrollButton = 5%@NL@%
    bdStyleBox.areaButton = 6%@NL@%
    bdStyleBox.listLen = MAXSTYLES%@NL@%
    bdStyleBox.topRow = 5%@NL@%
    bdStyleBox.botRow = 14%@NL@%
    bdStyleBox.leftCol = 40%@NL@%
    bdStyleBox.rightCol = 54%@NL@%
    bdStyleBox.listPos = win.BorderStyle%@NL@%
%@NL@%
%@AB@%    ' set up display window%@AE@%%@NL@%
    winRow = 5%@NL@%
    winCol = 3%@NL@%
    WindowOpen handle, winRow, winCol, 21, 76, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 2, title$%@NL@%
    WindowBox 1, 2, 15, 20%@NL@%
    WindowLocate 2, 5%@NL@%
    WindowPrint 2, "Background"%@NL@%
    WindowLocate 3, 5%@NL@%
    WindowPrint 2, "Color:"%@NL@%
    WindowBox 1, 22, 15, 56%@NL@%
    WindowLocate 4, 24%@NL@%
    WindowPrint 2, "Border Color:"%@NL@%
    WindowLocate 4, 40%@NL@%
    WindowPrint 2, "Border Style:"%@NL@%
    WindowBox 1, 58, 15, 73%@NL@%
    WindowLocate 2, 60%@NL@%
    WindowPrint 2, "Coordinates:"%@NL@%
    WindowBox 3, 63, 5, 71%@NL@%
    WindowLocate 4, 60%@NL@%
    WindowPrint 2, "X1:"%@NL@%
    WindowBox 6, 63, 8, 71%@NL@%
    WindowLocate 7, 60%@NL@%
    WindowPrint 2, "Y1:"%@NL@%
    WindowBox 9, 63, 11, 71%@NL@%
    WindowLocate 10, 60%@NL@%
    WindowPrint 2, "X2:"%@NL@%
    WindowBox 12, 63, 14, 71%@NL@%
    WindowLocate 13, 60%@NL@%
    WindowPrint 2, "Y2:"%@NL@%
    WindowLine 16%@NL@%
%@NL@%
    CreateListBox colors$(), bgColorBox, 0%@NL@%
    CreateListBox colors$(), bdColorBox, 0%@NL@%
    CreateListBox styles$(), bdStyleBox, 0%@NL@%
%@NL@%
    ButtonOpen 7, 1, "Display Border", 2, 24, 0, 0, 2%@NL@%
    ButtonOpen 8, 2, "OK ", 17, 14, 0, 0, 1%@NL@%
    ButtonOpen 9, 1, "Cancel ", 17, 51, 0, 0, 1%@NL@%
%@NL@%
    EditFieldOpen 1, LTRIM$(STR$(win.X1)), 4, 64, 0, 7, 7, 10%@NL@%
    EditFieldOpen 2, LTRIM$(STR$(win.Y1)), 7, 64, 0, 7, 7, 10%@NL@%
    EditFieldOpen 3, LTRIM$(STR$(win.X2)), 10, 64, 0, 7, 7, 10%@NL@%
    EditFieldOpen 4, LTRIM$(STR$(win.Y2)), 13, 64, 0, 7, 7, 10%@NL@%
%@NL@%
    currButton = 2                                      ' start in first list box%@NL@%
    currEditField = 0%@NL@%
    IF win.border = TRUE THEN ButtonSetState 7, 2%@NL@%
    pushButton = 8%@NL@%
%@NL@%
%@AB@%    ' window control loop%@AE@%%@NL@%
    finished = FALSE%@NL@%
    WHILE NOT finished%@NL@%
        WindowDo currButton, currEditField              ' wait for event%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1                                      ' button pressed%@NL@%
                currButton = Dialog(1)%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2%@NL@%
                        currEditField = 0%@NL@%
                        ScrollList colors$(), bgColorBox, currButton, 1, 0, winRow, winCol%@NL@%
                        currButton = 2%@NL@%
                    CASE 3, 4%@NL@%
                        currEditField = 0%@NL@%
                        ScrollList colors$(), bdColorBox, currButton, 1, 0, winRow, winCol%@NL@%
                        currButton = 4%@NL@%
                    CASE 5, 6%@NL@%
                        currEditField = 0%@NL@%
                        ScrollList styles$(), bdStyleBox, currButton, 1, 0, winRow, winCol%@NL@%
                        currButton = 6%@NL@%
                    CASE 7%@NL@%
                        ButtonToggle currButton%@NL@%
                        currEditField = 0%@NL@%
                    CASE 8, 9%@NL@%
                        pushButton = currButton%@NL@%
                        finished = TRUE%@NL@%
                END SELECT%@NL@%
            CASE 2                                      ' edit field%@NL@%
                currEditField = Dialog(2)%@NL@%
                currButton = 0%@NL@%
            CASE 6                                      ' enter%@NL@%
                finished = TRUE%@NL@%
            CASE 7                                      ' tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0:%@NL@%
                        SELECT CASE currEditField%@NL@%
                            CASE 1, 2, 3: currEditField = currEditField + 1%@NL@%
                            CASE 4:%@NL@%
                                currEditField = 0%@NL@%
                                currButton = 8%@NL@%
                                ButtonSetState pushButton, 1%@NL@%
                                ButtonSetState currButton, 2%@NL@%
                                pushButton = currButton%@NL@%
                        END SELECT%@NL@%
                    CASE 1, 2: currButton = 7%@NL@%
                    CASE 3, 4: currButton = 6%@NL@%
                    CASE 5, 6:%@NL@%
                        currButton = 0%@NL@%
                        currEditField = 1%@NL@%
                    CASE 7: currButton = 4%@NL@%
                    CASE 8:%@NL@%
                        currButton = currButton + 1%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE 9:%@NL@%
                        ButtonSetState currButton, 1%@NL@%
                        pushButton = 8%@NL@%
                        ButtonSetState pushButton, 2%@NL@%
                        currButton = 2%@NL@%
                        currEditField = 0%@NL@%
                END SELECT%@NL@%
            CASE 8                                      ' back tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0:%@NL@%
                        SELECT CASE currEditField%@NL@%
                            CASE 1:%@NL@%
                                currEditField = 0%@NL@%
                                currButton = 6%@NL@%
                            CASE 2, 3, 4: currEditField = currEditField - 1%@NL@%
                        END SELECT%@NL@%
                    CASE 1, 2:%@NL@%
                        currButton = 9%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE 3, 4: currButton = 7%@NL@%
                    CASE 5, 6: currButton = 4%@NL@%
                    CASE 7: currButton = 2%@NL@%
                    CASE 8:%@NL@%
                        currButton = 0%@NL@%
                        currEditField = 4%@NL@%
                    CASE 9:%@NL@%
                        currButton = currButton - 1%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                END SELECT%@NL@%
            CASE 9                                      ' escape%@NL@%
                pushButton = 9%@NL@%
                finished = TRUE%@NL@%
            CASE 10, 12                                 ' up, left arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2: ScrollList colors$(), bgColorBox, currButton, 2, 0, winRow, winCol%@NL@%
                    CASE 3, 4: ScrollList colors$(), bdColorBox, currButton, 2, 0, winRow, winCol%@NL@%
                    CASE 5, 6: ScrollList styles$(), bdStyleBox, currButton, 2, 0, winRow, winCol%@NL@%
                    CASE 7: ButtonSetState currButton, 2%@NL@%
                END SELECT%@NL@%
            CASE 11, 13                                 ' down, right arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2: ScrollList colors$(), bgColorBox, currButton, 3, 0, winRow, winCol%@NL@%
                    CASE 3, 4: ScrollList colors$(), bdColorBox, currButton, 3, 0, winRow, winCol%@NL@%
                    CASE 5, 6: ScrollList styles$(), bdStyleBox, currButton, 3, 0, winRow, winCol%@NL@%
                    CASE 7: ButtonSetState currButton, 1%@NL@%
                END SELECT%@NL@%
            CASE 14                                     ' space bar%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 7: ButtonToggle currButton%@NL@%
                    CASE 8, 9: finished = TRUE%@NL@%
                END SELECT%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' return new window information%@AE@%%@NL@%
    IF pushButton = 8 THEN%@NL@%
        IF setNum > 0 THEN chartChanged = TRUE%@NL@%
%@NL@%
        win.X1 = VAL(EditFieldInquire(1))%@NL@%
        win.Y1 = VAL(EditFieldInquire(2))%@NL@%
        win.X2 = VAL(EditFieldInquire(3))%@NL@%
        win.Y2 = VAL(EditFieldInquire(4))%@NL@%
        win.Background = bgColorBox.listPos - 1%@NL@%
        win.border = (ButtonInquire(7) = 2)%@NL@%
        win.BorderColor = bdColorBox.listPos - 1%@NL@%
        win.BorderStyle = bdStyleBox.listPos%@NL@%
    END IF%@NL@%
%@NL@%
    WindowClose handle%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CHRTDEM2.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\CHRTDEM2.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'       CHRTDEM2.BAS - third module of the CHRTB demonstration program.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'               Copyright (C) 1989, Microsoft Corporation%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   Main module - CHRTDEMO.BAS%@AE@%%@NL@%
%@AB@%'   Include files - CHRTDEMO.BI%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'chrtdemo.bi'%@AE@%%@NL@%
%@NL@%
%@AB@%' local functions%@AE@%%@NL@%
DECLARE FUNCTION TrueColr% (colr%)%@NL@%
%@NL@%
%@AB@%' local subs%@AE@%%@NL@%
DECLARE SUB OpenChart (newFlag%)%@NL@%
DECLARE SUB Quit ()%@NL@%
DECLARE SUB InitFonts ()%@NL@%
DECLARE SUB InitStyles ()%@NL@%
DECLARE SUB SetDisplayColor ()%@NL@%
DECLARE SUB SetUpBackground ()%@NL@%
DECLARE SUB SetUpMenu ()%@NL@%
DECLARE SUB ViewChart ()%@NL@%
DECLARE SUB ViewFont ()%@NL@%
DECLARE SUB ViewScreenMode ()%@NL@%
%@NL@%
DIM colorDisplay            AS INTEGER%@NL@%
DIM egacolor(0 TO 15)       AS INTEGER%@NL@%
DIM origPath$%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ClearData%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Clears all chart data%@AE@%%@NL@%
%@AB@%' Arguments: None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ClearData%@NL@%
SHARED Cat$(), catLen AS INTEGER%@NL@%
SHARED setVal!(), setLen() AS INTEGER, setName$()%@NL@%
%@NL@%
%@AB@%    ' Can't view  chart when no data present%@AE@%%@NL@%
    MenuSetState VIEWTITLE, 2, 0%@NL@%
%@NL@%
%@AB@%    ' Clear categories%@AE@%%@NL@%
    FOR i = 1 TO cMaxValues%@NL@%
        Cat$(i) = ""%@NL@%
    NEXT i%@NL@%
    catLen = 0%@NL@%
%@NL@%
%@AB@%    ' Clear set names and values%@AE@%%@NL@%
    FOR i = 1 TO cMaxSets%@NL@%
        setName$(i) = ""%@NL@%
        setLen(i) = 0%@NL@%
        FOR j = 1 TO cMaxValues%@NL@%
            setVal!(j, i) = cMissingValue%@NL@%
        NEXT j%@NL@%
    NEXT i%@NL@%
    setNum = 0%@NL@%
%@NL@%
%@AB@%    ' chart not changed%@AE@%%@NL@%
    chartChanged = FALSE%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ClearFonts%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Sets all chart font pointers to 1.  This is called%@AE@%%@NL@%
%@AB@%'              each time new fonts are loaded to ensure that%@AE@%%@NL@%
%@AB@%'              all chart fonts specify a meaningful font%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ClearFonts%@NL@%
%@NL@%
%@AB@%    ' reset all font pointers if don't map to current fonts%@AE@%%@NL@%
    IF CEnv.DataFont > numFonts THEN CEnv.DataFont = 1%@NL@%
    IF CEnv.MainTitle.TitleFont > numFonts THEN CEnv.MainTitle.TitleFont = 1%@NL@%
    IF CEnv.SubTitle.TitleFont > numFonts THEN CEnv.SubTitle.TitleFont = 1%@NL@%
    IF CEnv.XAxis.AxisTitle.TitleFont > numFonts THEN CEnv.XAxis.AxisTitle.TitleFont = 1%@NL@%
    IF CEnv.XAxis.TicFont > numFonts THEN CEnv.XAxis.TicFont = 1%@NL@%
    IF CEnv.YAxis.AxisTitle.TitleFont > numFonts THEN CEnv.YAxis.AxisTitle.TitleFont = 1%@NL@%
    IF CEnv.YAxis.TicFont > numFonts THEN CEnv.YAxis.TicFont = 1%@NL@%
    IF CEnv.Legend.TextFont > numFonts THEN CEnv.Legend.TextFont = 1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: CreateListBox%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Creates a list box within the current window%@AE@%%@NL@%
%@AB@%' Arguments: text$() - the list%@AE@%%@NL@%
%@AB@%'            tbox    - the listBox%@AE@%%@NL@%
%@AB@%'            func    - function flag for DrawList%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB CreateListBox (text$(), tbox AS ListBox, func)%@NL@%
%@NL@%
%@AB@%    ' get box length%@AE@%%@NL@%
    tbox.boxLen = tbox.botRow - tbox.topRow - 1%@NL@%
%@NL@%
%@AB@%    ' get displayable length%@AE@%%@NL@%
    IF tbox.listLen < tbox.boxLen THEN%@NL@%
        tbox.maxLen = tbox.listLen%@NL@%
    ELSE%@NL@%
        tbox.maxLen = tbox.boxLen%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' get box width%@AE@%%@NL@%
    tbox.boxWid = tbox.rightCol - tbox.leftCol - 1%@NL@%
%@NL@%
%@AB@%    ' create box%@AE@%%@NL@%
    WindowBox tbox.topRow, tbox.leftCol, tbox.botRow, tbox.rightCol%@NL@%
%@NL@%
%@AB@%    ' add scroll bar if necessary or if forced (func = 5)%@AE@%%@NL@%
    IF tbox.listLen <> tbox.maxLen OR func = 5 THEN%@NL@%
        ButtonOpen tbox.scrollButton, 1, "", tbox.topRow + 1, tbox.rightCol, tbox.botRow - 1, tbox.rightCol, 6%@NL@%
    ELSE%@NL@%
        tbox.scrollButton = 0%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' open area button%@AE@%%@NL@%
    ButtonOpen tbox.areaButton, 1, "", tbox.topRow + 1, tbox.leftCol + 1, tbox.botRow - 1, tbox.rightCol - 1, 4%@NL@%
%@NL@%
%@AB@%    ' set current list element relative to list box top%@AE@%%@NL@%
    IF tbox.listPos <= tbox.maxLen THEN%@NL@%
        tbox.currTop = 1%@NL@%
        tbox.currPos = tbox.listPos%@NL@%
    ELSEIF tbox.listPos + tbox.maxLen > tbox.listLen + 1 THEN%@NL@%
        tbox.currTop = tbox.listLen - tbox.maxLen + 1%@NL@%
        tbox.currPos = tbox.listPos - tbox.currTop + 1%@NL@%
    ELSE%@NL@%
        tbox.currTop = tbox.listPos%@NL@%
        tbox.currPos = 1%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' Display list within the box%@AE@%%@NL@%
    DrawList text$(), tbox, func%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: DrawList%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Displays a list within the boundaries of a list box%@AE@%%@NL@%
%@AB@%' Arguments: text$() - the list%@AE@%%@NL@%
%@AB@%'            tbox    - the listBox%@AE@%%@NL@%
%@AB@%'            func    - function flag for special operations%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB DrawList (text$(), tbox AS ListBox, func)%@NL@%
%@NL@%
%@AB@%    ' Draw each element of list that should currently appear in box%@AE@%%@NL@%
    FOR i% = 1 TO tbox.boxLen%@NL@%
%@AB@%        ' highlight current list element%@AE@%%@NL@%
        IF i% = tbox.currPos THEN%@NL@%
            WindowColor 7, 0%@NL@%
        ELSE%@NL@%
            WindowColor 0, 7%@NL@%
        END IF%@NL@%
%@NL@%
        WindowLocate tbox.topRow + i%, tbox.leftCol + 1%@NL@%
        IF i <= tbox.maxLen THEN%@NL@%
            WindowPrint -1, LEFT$(text$(tbox.currTop + i% - 1) + STRING$(tbox.boxWid, " "), tbox.boxWid)%@NL@%
        ELSE%@NL@%
            WindowPrint -1, STRING$(tbox.boxWid, " ")%@NL@%
        END IF%@NL@%
    NEXT i%%@NL@%
%@NL@%
%@AB@%    ' update scrollbar position indicator if scrollbar present%@AE@%%@NL@%
    IF tbox.scrollButton <> 0 THEN%@NL@%
        IF tbox.listLen <> 0 THEN%@NL@%
            position = (tbox.currTop + tbox.currPos - 1) * (tbox.maxLen - 2) / tbox.listLen%@NL@%
            IF position < 1 THEN%@NL@%
               position = 1%@NL@%
            ELSEIF position > tbox.maxLen - 2 THEN%@NL@%
              position = tbox.maxLen - 2%@NL@%
            END IF%@NL@%
        ELSE%@NL@%
            position = 1%@NL@%
        END IF%@NL@%
        ButtonSetState tbox.scrollButton, position%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' Reset color in case current element was last to be drawn%@AE@%%@NL@%
    WindowColor 0, 7%@NL@%
%@NL@%
%@AB@%    ' update current position in case list has been scrolled%@AE@%%@NL@%
    tbox.listPos = tbox.currTop + tbox.currPos - 1%@NL@%
%@NL@%
%@AB@%    ' handle special operation of immediately updating colors$ in title editfield%@AE@%%@NL@%
    SELECT CASE func%@NL@%
        CASE 2: SetAtt 12, tbox.listPos          ' update title editfield foreground color%@NL@%
    END SELECT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Func Name: HandleMenuEvent%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Determines the action to be performed when user makes%@AE@%%@NL@%
%@AB@%'              a menu selection.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB HandleMenuEvent%@NL@%
SHARED saveFile$, colorDisplay AS INTEGER%@NL@%
%@NL@%
    menu = MenuCheck(0)%@NL@%
    item = MenuCheck(1)%@NL@%
%@NL@%
    SELECT CASE menu%@NL@%
%@AB@%        ' file menu title selection%@AE@%%@NL@%
        CASE FILETITLE%@NL@%
            SELECT CASE item%@NL@%
%@AB@%                ' new chart%@AE@%%@NL@%
                CASE 1: OpenChart TRUE%@NL@%
%@AB@%                ' open existing chart%@AE@%%@NL@%
                CASE 2: OpenChart FALSE%@NL@%
%@AB@%                ' save current chart%@AE@%%@NL@%
                CASE 3: junk = SaveChart(saveFile$, FALSE)%@NL@%
%@AB@%                ' save current chart under new name%@AE@%%@NL@%
                CASE 4: junk = SaveChart(saveFile$, TRUE)%@NL@%
%@AB@%                ' exit program%@AE@%%@NL@%
                CASE 6: Quit%@NL@%
            END SELECT%@NL@%
%@NL@%
%@AB@%        ' view menu title selection%@AE@%%@NL@%
        CASE VIEWTITLE%@NL@%
            SELECT CASE item%@NL@%
%@AB@%                ' Display and edit existing chart data%@AE@%%@NL@%
                CASE 1: ViewData%@NL@%
%@AB@%                ' Display chart%@AE@%%@NL@%
                CASE 2: ViewChart%@NL@%
%@AB@%                ' Display and load fonts%@AE@%%@NL@%
                CASE 3: ViewFont%@NL@%
%@AB@%                ' Display and edit screen mode%@AE@%%@NL@%
                CASE 4: ViewScreenMode%@NL@%
            END SELECT%@NL@%
%@NL@%
%@AB@%        ' Gallery menu title selection%@AE@%%@NL@%
        CASE GALLERYTITLE%@NL@%
%@AB@%            ' change chart type%@AE@%%@NL@%
            ChangeChartType item%@NL@%
%@NL@%
%@AB@%        ' Chart menu title selection%@AE@%%@NL@%
        CASE CHARTTITLE%@NL@%
            SELECT CASE item%@NL@%
%@AB@%                ' Change chart window%@AE@%%@NL@%
                CASE 1: ChangeWindow 1, "Chart Window", CEnv.ChartWindow%@NL@%
%@AB@%                ' Change data window%@AE@%%@NL@%
                CASE 2: ChangeWindow 1, "Data Window", CEnv.DataWindow%@NL@%
%@AB@%                ' Change legend%@AE@%%@NL@%
                CASE 3: ChangeLegend%@NL@%
%@AB@%                ' Change X axis%@AE@%%@NL@%
                CASE 4: ChangeAxis "X Axis", CEnv.XAxis%@NL@%
%@AB@%                ' Change Y axis%@AE@%%@NL@%
                CASE 5: ChangeAxis "Y Axis", CEnv.YAxis%@NL@%
            END SELECT%@NL@%
%@NL@%
%@AB@%        ' Title menu title selection%@AE@%%@NL@%
        CASE TITLETITLE%@NL@%
            SELECT CASE item%@NL@%
%@AB@%                ' Display and modify main title%@AE@%%@NL@%
                CASE 1: ChangeTitle 1, "Main Title", CEnv.MainTitle, 6, 16%@NL@%
%@AB@%                ' Display and modify sub title%@AE@%%@NL@%
                CASE 2: ChangeTitle 1, "Sub Title", CEnv.SubTitle, 6, 16%@NL@%
%@AB@%                ' Display and modify x axis title%@AE@%%@NL@%
                CASE 3:%@NL@%
                    ChangeTitle 1, "X-axis Title", CEnv.XAxis.AxisTitle, 6, 16%@NL@%
                    CEnv.XAxis.ScaleTitle.TitleColor = CEnv.XAxis.AxisTitle.TitleColor%@NL@%
                    CEnv.XAxis.ScaleTitle.Justify = CEnv.XAxis.AxisTitle.Justify%@NL@%
%@AB@%                ' Display and modify y axis title%@AE@%%@NL@%
                CASE 4:%@NL@%
                    ChangeTitle 1, "Y-axis Title", CEnv.YAxis.AxisTitle, 6, 16%@NL@%
                    CEnv.YAxis.ScaleTitle.TitleColor = CEnv.YAxis.AxisTitle.TitleColor%@NL@%
                    CEnv.YAxis.ScaleTitle.Justify = CEnv.YAxis.AxisTitle.Justify%@NL@%
            END SELECT%@NL@%
%@NL@%
%@AB@%        ' Options menu title selection%@AE@%%@NL@%
        CASE OPTIONSTITLE%@NL@%
            colorDisplay = item - 2%@NL@%
            SetDisplayColor%@NL@%
    END SELECT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Func Name: InitAll%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Performs all initialization for the program%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB InitAll%@NL@%
SHARED finished AS INTEGER, screenMode AS INTEGER, saveFile$%@NL@%
SHARED origPath$, colorDisplay  AS INTEGER%@NL@%
%@NL@%
    saveFile$ = ""                          ' No save file to begin with%@NL@%
    origPath$ = CURDIR$                     ' get working path%@NL@%
    colorDisplay = FALSE                    ' start with mono display%@NL@%
    GetBestMode screenMode                  ' get initial screen mode%@NL@%
%@NL@%
    SCREEN 0                                ' init screen%@NL@%
    WIDTH 80, 25%@NL@%
    CLS%@NL@%
%@NL@%
    MenuInit                                ' init menu routines%@NL@%
    WindowInit                              ' init window routines%@NL@%
    MouseInit                               ' init mouse routines%@NL@%
%@NL@%
%@AB@%    ' exit if no graphic mode available%@AE@%%@NL@%
    IF screenMode = 0 THEN%@NL@%
        PrintError "No graphic screen modes available for charting. Exiting program."%@NL@%
        finished = TRUE%@NL@%
        EXIT SUB%@NL@%
    ELSE%@NL@%
        finished = FALSE%@NL@%
    END IF%@NL@%
%@NL@%
    SetUpMenu                               ' Set up menu bar%@NL@%
    SetUpBackground                         ' Set up screen background%@NL@%
    InitChart                               ' Initialize chart%@NL@%
    InitColors                              ' Set up color list%@NL@%
    InitStyles                              ' Set up border style list%@NL@%
    InitFonts                               ' Set up font lists%@NL@%
%@NL@%
    MenuShow                                ' display menu bar%@NL@%
    MouseShow                               ' display mouse%@NL@%
%@NL@%
%@AB@%    '               display program introduction%@AE@%%@NL@%
    a$ = "Microsoft QuickChart|"%@NL@%
    a$ = a$ + "A Presentation Graphics Toolbox Demo|"%@NL@%
    a$ = a$ + "for|"%@NL@%
    a$ = a$ + "Microsoft BASIC 7.0 Professional Development System|"%@NL@%
    a$ = a$ + "Copyright (c) 1989 Microsoft Corporation|"%@NL@%
%@NL@%
    temp = Alert(4, a$, 9, 12, 15, 68, "Color", "Monochrome", "")%@NL@%
%@NL@%
%@AB@%    ' set display to color or monochrome depending on colorDislay%@AE@%%@NL@%
    IF temp = 1 THEN colorDisplay = TRUE%@NL@%
%@NL@%
    SetDisplayColor%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: InitChart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Initializes chart environment variables and other%@AE@%%@NL@%
%@AB@%'              related information.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB InitChart%@NL@%
%@NL@%
    MenuItemToggle GALLERYTITLE, cBar       ' default chart type is BAR so%@NL@%
%@AB@%                                            ' set up menu that way%@AE@%%@NL@%
%@NL@%
    DefaultChart CEnv, cBar, cPlain         ' Get defaults for chart variable%@NL@%
%@NL@%
    ClearData                               ' Clear all chart data%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: Initcolors%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Creates color list based on screen mode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB InitColors%@NL@%
SHARED screenMode AS INTEGER%@NL@%
SHARED egacolor() AS INTEGER%@NL@%
%@NL@%
%@AB@%    ' init EGA colors$ for SetAtt%@AE@%%@NL@%
    egacolor(0) = 0%@NL@%
    egacolor(1) = 1%@NL@%
    egacolor(2) = 2%@NL@%
    egacolor(3) = 3%@NL@%
    egacolor(4) = 4%@NL@%
    egacolor(5) = 5%@NL@%
    egacolor(6) = 20%@NL@%
    egacolor(7) = 7%@NL@%
    egacolor(8) = 56%@NL@%
    egacolor(9) = 57%@NL@%
    egacolor(10) = 58%@NL@%
    egacolor(11) = 59%@NL@%
    egacolor(12) = 60%@NL@%
    egacolor(13) = 61%@NL@%
    egacolor(14) = 62%@NL@%
    egacolor(15) = 63%@NL@%
%@NL@%
%@AB@%    ' create list of displayable colors$ based on screen mode%@AE@%%@NL@%
    SELECT CASE screenMode%@NL@%
        CASE 1%@NL@%
            numColors = 4%@NL@%
            REDIM color$(numColors)%@NL@%
            colors$(1) = "Black"%@NL@%
            colors$(2) = "White"%@NL@%
            colors$(3) = "Bright Cyan"%@NL@%
            colors$(4) = "Bright Magenta"%@NL@%
        CASE 2, 3, 4, 11%@NL@%
            numColors = 2%@NL@%
            REDIM color$(numColors)%@NL@%
            colors$(1) = "Black"%@NL@%
            colors$(2) = "White"%@NL@%
        CASE 7, 8, 9, 12, 13%@NL@%
            numColors = 16%@NL@%
            REDIM color$(numColors)%@NL@%
            colors$(1) = "Black"%@NL@%
            colors$(2) = "High White"%@NL@%
            colors$(3) = "Blue"%@NL@%
            colors$(4) = "Green"%@NL@%
            colors$(5) = "Cyan"%@NL@%
            colors$(6) = "Red"%@NL@%
            colors$(7) = "Magenta"%@NL@%
            colors$(8) = "Brown"%@NL@%
            colors$(9) = "White"%@NL@%
            colors$(10) = "Gray"%@NL@%
            colors$(11) = "Bright Blue"%@NL@%
            colors$(12) = "Bright Green"%@NL@%
            colors$(13) = "Bright Cyan"%@NL@%
            colors$(14) = "Bright Red"%@NL@%
            colors$(15) = "Bright Magenta"%@NL@%
            colors$(16) = "Yellow"%@NL@%
        CASE 10%@NL@%
            numColors = 4%@NL@%
            REDIM color$(numColors)%@NL@%
            colors$(1) = "Off"%@NL@%
            colors$(2) = "On High"%@NL@%
            colors$(3) = "On Normal"%@NL@%
            colors$(4) = "Blink"%@NL@%
    END SELECT%@NL@%
%@NL@%
%@AB@%    ' reset chart color pointers to default values%@AE@%%@NL@%
    IF numColors < 16 THEN%@NL@%
        CEnv.ChartWindow.Background = 0%@NL@%
        CEnv.ChartWindow.BorderColor = 1%@NL@%
        CEnv.DataWindow.Background = 0%@NL@%
        CEnv.DataWindow.BorderColor = 1%@NL@%
        CEnv.MainTitle.TitleColor = 1%@NL@%
        CEnv.SubTitle.TitleColor = 1%@NL@%
        CEnv.XAxis.AxisColor = 1%@NL@%
        CEnv.XAxis.AxisTitle.TitleColor = 1%@NL@%
        CEnv.YAxis.AxisColor = 1%@NL@%
        CEnv.YAxis.AxisTitle.TitleColor = 1%@NL@%
        CEnv.Legend.TextColor = 1%@NL@%
        CEnv.Legend.LegendWindow.Background = 0%@NL@%
        CEnv.Legend.LegendWindow.BorderColor = 1%@NL@%
    END IF%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: InitFonts%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: sets up default font and initializes font list%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB InitFonts%@NL@%
DIM FI AS FontInfo%@NL@%
%@NL@%
%@AB@%    ' reset%@AE@%%@NL@%
    UnRegisterFonts%@NL@%
    SetMaxFonts 1, 1%@NL@%
%@NL@%
%@AB@%    ' get default font%@AE@%%@NL@%
    DefaultFont Segment%, Offset%%@NL@%
    reg% = RegisterMemFont%(Segment%, Offset%)%@NL@%
%@NL@%
%@AB@%    ' load default font%@AE@%%@NL@%
    numFonts = LoadFont("n1")%@NL@%
%@NL@%
    IF numFonts = 0 THEN numFonts = 1%@NL@%
%@NL@%
    fonts$(numFonts) = "IBM 8 Point"%@NL@%
%@NL@%
    UnRegisterFonts%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: InitStyles%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Initializes border styles list%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB InitStyles%@NL@%
%@NL@%
%@AB@%    ' create list of border styles%@AE@%%@NL@%
    styles$(1) = ""%@NL@%
    styles$(2) = "            "%@NL@%
    styles$(3) = "               "%@NL@%
    styles$(4) = "            "%@NL@%
    styles$(5) = "              "%@NL@%
    styles$(6) = "        "%@NL@%
    styles$(7) = "          "%@NL@%
    styles$(8) = "    "%@NL@%
    styles$(9) = "    "%@NL@%
    styles$(10) = "          "%@NL@%
    styles$(11) = "          "%@NL@%
    styles$(12) = "              "%@NL@%
    styles$(13) = "            "%@NL@%
    styles$(14) = "            "%@NL@%
    styles$(15) = "              "%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Func Name: Min%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Compares two numbers and returns the smallest%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: num1, num2 - numbers to compare%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION Min% (num1, num2)%@NL@%
%@NL@%
    IF num1 <= num2 THEN%@NL@%
        Min% = num1%@NL@%
    ELSE%@NL@%
        Min% = num2%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: Quit%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Exits the program after allowing the user a chance to%@AE@%%@NL@%
%@AB@%'              save the current chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: None%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB Quit%@NL@%
SHARED finished AS INTEGER, saveFile$, origPath$%@NL@%
%@NL@%
%@AB@%    ' Allow user to save chart if necessary%@AE@%%@NL@%
    IF chartChanged THEN%@NL@%
        a$ = "| " + "Current chart has not been saved.  Save now?"%@NL@%
%@NL@%
        status = Alert(4, a$, 8, 15, 12, 65, "Yes", "No", "Cancel")%@NL@%
%@NL@%
%@AB@%        ' save chart%@AE@%%@NL@%
        IF status = OK THEN%@NL@%
            status = SaveChart(saveFile$, FALSE)%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
        status = OK%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' quit if operation has not been canceled.%@AE@%%@NL@%
    IF status <> CANCEL THEN%@NL@%
        CHDRIVE MID$(origPath$, 1, 2)%@NL@%
        CHDIR MID$(origPath$, 3, LEN(origPath$))%@NL@%
        finished = TRUE%@NL@%
        MouseHide%@NL@%
        COLOR 15, 0%@NL@%
        CLS%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ScrollList%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Handles scrolling for a list box.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: text$() - list%@AE@%%@NL@%
%@AB@%'            tbox - list box%@AE@%%@NL@%
%@AB@%'            currButton - current button%@AE@%%@NL@%
%@AB@%'            status - to determine if button was pressed, or up or down arrow%@AE@%%@NL@%
%@AB@%'                     keys were used%@AE@%%@NL@%
%@AB@%'            func - for special operations (passed to DrawList)%@AE@%%@NL@%
%@AB@%'            winRow - top row of current window%@AE@%%@NL@%
%@AB@%'            winCol - left column of current window%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ScrollList (text$(), tbox AS ListBox, currButton, status, func, winRow, winCol)%@NL@%
%@NL@%
%@AB@%    ' scroll using scroll buttons%@AE@%%@NL@%
    IF currButton = tbox.scrollButton AND status = 1 THEN%@NL@%
        SELECT CASE Dialog(19)%@NL@%
%@AB@%            ' scroll up%@AE@%%@NL@%
            CASE -1:%@NL@%
                IF tbox.currTop > 1 THEN%@NL@%
                    tbox.currTop = tbox.currTop - 1%@NL@%
                    tbox.currPos = tbox.currPos + 1%@NL@%
                    IF tbox.currPos > tbox.maxLen THEN tbox.currPos = tbox.maxLen%@NL@%
                END IF%@NL@%
%@AB@%            ' scroll down%@AE@%%@NL@%
            CASE -2:%@NL@%
                IF tbox.currTop + tbox.maxLen <= tbox.listLen THEN%@NL@%
                    tbox.currTop = tbox.currTop + 1%@NL@%
                    tbox.currPos = tbox.currPos - 1%@NL@%
                    IF tbox.currPos < 1 THEN tbox.currPos = 1%@NL@%
                END IF%@NL@%
%@AB@%            ' scroll to position%@AE@%%@NL@%
            CASE ELSE:%@NL@%
                position = Dialog(19)%@NL@%
                IF position > 1 THEN%@NL@%
                    position = position * (tbox.listLen) / (tbox.boxLen - 2)%@NL@%
                    IF position < 1 THEN%@NL@%
                        positon = 1%@NL@%
                    ELSEIF position > tbox.listLen THEN%@NL@%
                        position = tbox.listLen%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
%@NL@%
                IF tbox.currTop <= position AND tbox.currTop + tbox.maxLen > position THEN%@NL@%
                    tbox.currPos = position - tbox.currTop + 1%@NL@%
                ELSEIF position <= tbox.maxLen THEN%@NL@%
                    tbox.currTop = 1%@NL@%
                    tbox.currPos = position%@NL@%
                ELSE%@NL@%
                    tbox.currTop = position - tbox.maxLen + 1%@NL@%
                    tbox.currPos = position - tbox.currTop + 1%@NL@%
                END IF%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%    ' area button chosen%@AE@%%@NL@%
    ELSEIF status = 1 THEN%@NL@%
%@AB@%        ' make selected position the current position%@AE@%%@NL@%
        IF Dialog(17) <= tbox.maxLen THEN%@NL@%
            tbox.currPos = Dialog(17)%@NL@%
            DrawList text$(), tbox, func%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' poll for repeated scrolling while mouse button is down%@AE@%%@NL@%
        DO%@NL@%
            X! = TIMER%@NL@%
            MousePoll r, c, lb, rb              ' poll mouse%@NL@%
            IF lb = TRUE THEN%@NL@%
%@AB@%                ' if below list box then scroll down%@AE@%%@NL@%
                IF r > tbox.botRow + winRow - 2 THEN%@NL@%
                    GOSUB Down1%@NL@%
%@AB@%                ' if above list box then scroll up%@AE@%%@NL@%
                ELSEIF r < tbox.topRow + winRow THEN%@NL@%
                    GOSUB Up1%@NL@%
%@AB@%                ' if to right of list box then scroll down%@AE@%%@NL@%
                ELSEIF c > tbox.rightCol + winCol - 2 THEN%@NL@%
                    GOSUB Down1%@NL@%
%@AB@%                ' if to left of list box then scroll up%@AE@%%@NL@%
                ELSEIF c < tbox.leftCol + winCol THEN%@NL@%
                    GOSUB Up1%@NL@%
%@AB@%                ' inside box%@AE@%%@NL@%
                ELSEIF r - winRow - tbox.topRow + 1 <= tbox.maxLen THEN%@NL@%
                    tbox.currPos = r - winRow - tbox.topRow + 1%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' draw list%@AE@%%@NL@%
                DrawList text$(), tbox, func%@NL@%
            ELSE%@NL@%
                EXIT DO%@NL@%
            END IF%@NL@%
            WHILE TIMER < X! + .05: WEND%@NL@%
        LOOP%@NL@%
%@NL@%
%@AB@%    ' up arrow key hit%@AE@%%@NL@%
    ELSEIF status = 2 THEN%@NL@%
        GOSUB Up1%@NL@%
%@NL@%
%@AB@%    ' down arrow key hit%@AE@%%@NL@%
    ELSEIF status = 3 THEN%@NL@%
        GOSUB Down1%@NL@%
    END IF%@NL@%
%@NL@%
    DrawList text$(), tbox, func                    ' redraw list%@NL@%
%@NL@%
    EXIT SUB%@NL@%
%@NL@%
%@AB@%' scroll list up one%@AE@%%@NL@%
Up1:%@NL@%
    IF tbox.currPos > 1 THEN%@NL@%
        tbox.currPos = tbox.currPos - 1%@NL@%
    ELSEIF tbox.currTop > 1 THEN%@NL@%
        tbox.currTop = tbox.currTop - 1%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' scroll list down one%@AE@%%@NL@%
Down1:%@NL@%
    IF tbox.currPos < tbox.maxLen THEN%@NL@%
        tbox.currPos = tbox.currPos + 1%@NL@%
    ELSEIF tbox.currTop + tbox.maxLen <= tbox.listLen THEN%@NL@%
        tbox.currTop = tbox.currTop + 1%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: Setatt%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Changes a color's attribute to that of another color's.%@AE@%%@NL@%
%@AB@%'              This is used in the ChangeTitle routine to allow user%@AE@%%@NL@%
%@AB@%'              color selections to immediately change the foreground%@AE@%%@NL@%
%@AB@%'              color of the title edit field.  This allows the user%@AE@%%@NL@%
%@AB@%'              to view the colors as they would look on a chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: change - color to change%@AE@%%@NL@%
%@AB@%'            source - color to change to%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB SetAtt (change, source)%@NL@%
SHARED screenMode AS INTEGER%@NL@%
SHARED egacolor() AS INTEGER%@NL@%
%@NL@%
%@AB@%    ' map colors$ based on screen mode%@AE@%%@NL@%
    SELECT CASE screenMode%@NL@%
        CASE 10:%@NL@%
            IF source > 2 THEN%@NL@%
                temp = 9                            ' set "normal" and "blink" to white%@NL@%
            ELSE%@NL@%
                temp = source                       ' off = black; high white = bright white%@NL@%
            END IF%@NL@%
        CASE 1:%@NL@%
            IF source = 3 THEN                      ' map to cyan%@NL@%
                temp = 13%@NL@%
            ELSEIF source = 4 THEN                  ' map to magenta%@NL@%
                temp = 15%@NL@%
            ELSE                                    ' others okay%@NL@%
                temp = source%@NL@%
            END IF%@NL@%
        CASE ELSE%@NL@%
            temp = source                           ' colors$ okay%@NL@%
    END SELECT%@NL@%
%@NL@%
%@AB@%    ' change attribute%@AE@%%@NL@%
    DIM regs AS RegType%@NL@%
    regs.ax = &H1000%@NL@%
    regs.bx = 256 * egacolor(TrueColr(temp)) + change%@NL@%
    CALL INTERRUPT(&H10, regs, regs)%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: SetDisplayColor%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Changes the program's display to monochrome (no colors) or%@AE@%%@NL@%
%@AB@%'              to color (include colors in menu bar) based on the value of%@AE@%%@NL@%
%@AB@%'              colorDisplay.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB SetDisplayColor%@NL@%
SHARED colorDisplay AS INTEGER%@NL@%
%@NL@%
    MouseHide%@NL@%
%@NL@%
%@AB@%    ' redraw background based on display color%@AE@%%@NL@%
    SetUpBackground%@NL@%
%@NL@%
%@AB@%    ' set menu bar to include colors%@AE@%%@NL@%
    IF colorDisplay THEN%@NL@%
        MenuSetState OPTIONSTITLE, 1, 2%@NL@%
        MenuSetState OPTIONSTITLE, 2, 1%@NL@%
        MenuColor 0, 7, 4, 8, 0, 4, 7%@NL@%
%@AB@%    ' set monochrome menu bar%@AE@%%@NL@%
    ELSE%@NL@%
        MenuSetState OPTIONSTITLE, 1, 1%@NL@%
        MenuSetState OPTIONSTITLE, 2, 2%@NL@%
        MenuColor 0, 7, 15, 8, 7, 0, 15%@NL@%
    END IF%@NL@%
%@NL@%
    MenuShow%@NL@%
    MouseShow%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: SetUpBackground%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Creates and displays background screen pattern%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB SetUpBackground%@NL@%
SHARED colorDisplay AS INTEGER%@NL@%
%@NL@%
    MouseHide%@NL@%
%@NL@%
    WIDTH , 25%@NL@%
    IF colorDisplay THEN%@NL@%
        COLOR 15, 1                             ' set color for background%@NL@%
    ELSE%@NL@%
        COLOR 15, 0%@NL@%
    END IF%@NL@%
    CLS%@NL@%
%@NL@%
    FOR a = 2 TO 80 STEP 4                      ' create and display pattern%@NL@%
        FOR b = 2 TO 25 STEP 2%@NL@%
            LOCATE b, a%@NL@%
            PRINT CHR$(250);%@NL@%
        NEXT b%@NL@%
    NEXT a%@NL@%
%@NL@%
    MouseShow%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: SetUpMenu%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Creates menu bar for the program%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB SetUpMenu%@NL@%
%@NL@%
%@AB@%    ' file menu title%@AE@%%@NL@%
    MenuSet FILETITLE, 0, 1, "File", 1%@NL@%
    MenuSet FILETITLE, 1, 1, "New", 1%@NL@%
    MenuSet FILETITLE, 2, 1, "Open ...", 1%@NL@%
    MenuSet FILETITLE, 3, 1, "Save", 1%@NL@%
    MenuSet FILETITLE, 4, 1, "Save As ...", 6%@NL@%
    MenuSet FILETITLE, 5, 1, "-", 1%@NL@%
    MenuSet FILETITLE, 6, 1, "Exit", 2%@NL@%
%@NL@%
%@AB@%    ' view menu title%@AE@%%@NL@%
    MenuSet VIEWTITLE, 0, 1, "View", 1%@NL@%
    MenuSet VIEWTITLE, 1, 1, "Data ...", 1%@NL@%
    MenuSet VIEWTITLE, 2, 1, "Chart        F5", 1%@NL@%
    MenuSet VIEWTITLE, 3, 1, "Fonts ...", 1%@NL@%
    MenuSet VIEWTITLE, 4, 1, "Screen Mode ...", 1%@NL@%
%@NL@%
%@AB@%    ' gallery menu title%@AE@%%@NL@%
    MenuSet GALLERYTITLE, 0, 1, "Gallery", 1%@NL@%
    MenuSet GALLERYTITLE, 1, 1, "Bar ...", 1%@NL@%
    MenuSet GALLERYTITLE, 2, 1, "Column ...", 1%@NL@%
    MenuSet GALLERYTITLE, 3, 1, "Line ...", 1%@NL@%
    MenuSet GALLERYTITLE, 4, 1, "Scatter ...", 1%@NL@%
    MenuSet GALLERYTITLE, 5, 1, "Pie ...", 1%@NL@%
%@NL@%
%@AB@%    ' chart menu title%@AE@%%@NL@%
    MenuSet CHARTTITLE, 0, 1, "Chart", 1%@NL@%
    MenuSet CHARTTITLE, 1, 1, "Chart Window ...", 1%@NL@%
    MenuSet CHARTTITLE, 2, 1, "Data Window ...", 1%@NL@%
    MenuSet CHARTTITLE, 3, 1, "Legend ...", 1%@NL@%
    MenuSet CHARTTITLE, 4, 1, "X Axis ...", 1%@NL@%
    MenuSet CHARTTITLE, 5, 1, "Y Axis ...", 1%@NL@%
%@NL@%
%@AB@%    ' title menu title%@AE@%%@NL@%
    MenuSet TITLETITLE, 0, 1, "Title", 1%@NL@%
    MenuSet TITLETITLE, 1, 1, "Main ...", 1%@NL@%
    MenuSet TITLETITLE, 2, 1, "Sub ...", 1%@NL@%
    MenuSet TITLETITLE, 3, 1, "X Axis ...", 1%@NL@%
    MenuSet TITLETITLE, 4, 1, "Y Axis ...", 1%@NL@%
%@NL@%
%@AB@%    ' options menu title%@AE@%%@NL@%
    MenuSet OPTIONSTITLE, 0, 1, "Options", 1%@NL@%
    MenuSet OPTIONSTITLE, 1, 1, "Color", 1%@NL@%
    MenuSet OPTIONSTITLE, 2, 1, "Monochrome", 1%@NL@%
%@NL@%
%@AB@%    ' setup short cuts for some menu choices%@AE@%%@NL@%
    ShortCutKeySet VIEWTITLE, 2, CHR$(0) + CHR$(63)     ' F5 = View Chart%@NL@%
%@NL@%
%@AB@%    ' set original menu colors for monochrome screen%@AE@%%@NL@%
    MenuColor 0, 7, 15, 8, 7, 0, 15%@NL@%
    MenuPreProcess%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Function Name: TrueColr%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Maps a given chart color to its actual color%@AE@%%@NL@%
%@AB@%'              and returns this color.  This is needed because the chart%@AE@%%@NL@%
%@AB@%'              colors start with BLACK = 1 and HIGH WHITE = 2%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: colr - chart color number%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION TrueColr% (colr)%@NL@%
%@NL@%
    IF colr = 1 THEN                                ' black%@NL@%
        TrueColr% = 0                               ' bright white%@NL@%
    ELSEIF colr = 2 THEN%@NL@%
        TrueColr% = 15%@NL@%
    ELSE%@NL@%
        TrueColr% = colr - 2                        ' all others%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ViewChart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Displays the chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ViewChart%@NL@%
SHARED setVal!(), Cat$(), setLen() AS INTEGER, setName$()%@NL@%
SHARED screenMode AS INTEGER%@NL@%
%@NL@%
%@AB@%    ' When a chart is drawn, data is moved from the 2-dimensional array%@AE@%%@NL@%
%@AB@%    ' into arrays suitable for the charting library routines.  The%@AE@%%@NL@%
%@AB@%    ' following arrays are used directly in calls to the charting routines:%@AE@%%@NL@%
    DIM ValX1!(1 TO cMaxValues)                    ' pass to chart routine%@NL@%
    DIM ValY1!(1 TO cMaxValues)%@NL@%
    DIM ValX2!(1 TO cMaxValues, 1 TO cMaxSeries)   ' pass to chartMS routine%@NL@%
    DIM ValY2!(1 TO cMaxValues, 1 TO cMaxSeries)%@NL@%
%@NL@%
    DIM explode(1 TO cMaxValues)  AS INTEGER       ' explode pie chart pieces%@NL@%
%@NL@%
%@NL@%
%@AB@%   ' Make sure some data exists%@AE@%%@NL@%
   IF setNum <= 0 THEN%@NL@%
       a$ = "|"%@NL@%
       a$ = a$ + "No data available for chart."%@NL@%
       junk = Alert(4, a$, 8, 15, 12, 65, "", "", "")%@NL@%
       EXIT SUB%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' find the longest series%@AE@%%@NL@%
   maxLen% = 0%@NL@%
   FOR i% = 1 TO setNum%@NL@%
      IF setLen(i%) > maxLen% THEN maxLen% = setLen(i%)%@NL@%
   NEXT i%%@NL@%
%@NL@%
%@AB@%   ' Set up the proper screen mode (exit if not valid)%@AE@%%@NL@%
   ChartScreen screenMode%@NL@%
   IF ChartErr = cBadScreen THEN%@NL@%
        PrintError "Invalid screen mode. Can't display chart."%@NL@%
        EXIT SUB%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' Process depending on chart type%@AE@%%@NL@%
   SELECT CASE CEnv.ChartType%@NL@%
      CASE cBar, cColumn, cLine, cPie:%@NL@%
%@AB@%         ' If the chart is a single series one or a pie chart:%@AE@%%@NL@%
         IF setNum = 1 OR CEnv.ChartType = cPie THEN%@NL@%
%@NL@%
%@AB@%            ' Transfer data into a single dimension array:%@AE@%%@NL@%
            FOR i% = 1 TO maxLen%%@NL@%
               ValX1!(i%) = setVal!(i%, 1)%@NL@%
            NEXT i%%@NL@%
%@NL@%
            IF CEnv.ChartType = cPie THEN%@NL@%
%@AB@%                ' determine which pieces to explode%@AE@%%@NL@%
                FOR i% = 1 TO maxLen%%@NL@%
                    IF setVal!(i%, 2) <> 0 THEN%@NL@%
                        explode(i%) = 1%@NL@%
                    ELSE%@NL@%
                        explode(i%) = 0%@NL@%
                    END IF%@NL@%
                NEXT i%%@NL@%
%@NL@%
%@AB@%                ' display pie chart%@AE@%%@NL@%
                ChartPie CEnv, Cat$(), ValX1!(), explode(), maxLen%%@NL@%
            ELSE%@NL@%
                Chart CEnv, Cat$(), ValX1!(), maxLen%%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%         ' If multiple series, then data is OK so just call routine:%@AE@%%@NL@%
         ELSE%@NL@%
            ChartMS CEnv, Cat$(), setVal!(), maxLen%, 1, setNum, setName$()%@NL@%
         END IF%@NL@%
%@NL@%
      CASE cScatter:%@NL@%
%@AB@%         ' Make sure there's enough data sets:%@AE@%%@NL@%
         IF setNum = 1 THEN%@NL@%
            SCREEN 0%@NL@%
            WIDTH 80%@NL@%
            SetUpBackground%@NL@%
            MenuShow%@NL@%
            MouseShow%@NL@%
            a$ = "|"%@NL@%
            a$ = a$ + "Too few data sets for Scatter chart"%@NL@%
            junk = Alert(4, a$, 8, 15, 12, 65, "", "", "")%@NL@%
            EXIT SUB%@NL@%
%@NL@%
%@AB@%         ' If it's a single series scatter, transfer data to one-%@AE@%%@NL@%
%@AB@%         ' dimensional arrays and make chart call:%@AE@%%@NL@%
         ELSEIF setNum = 2 THEN%@NL@%
            FOR i% = 1 TO maxLen%%@NL@%
               ValX1!(i%) = setVal!(i%, 1)%@NL@%
               ValY1!(i%) = setVal!(i%, 2)%@NL@%
            NEXT i%%@NL@%
            ChartScatter CEnv, ValX1!(), ValY1!(), maxLen%%@NL@%
%@NL@%
%@AB@%         ' If it's a multiple series scatter, transfer odd columns to%@AE@%%@NL@%
%@AB@%         ' X-axis data array and even columns to Y-axis array and make%@AE@%%@NL@%
%@AB@%         ' chart call:%@AE@%%@NL@%
         ELSE%@NL@%
            FOR j% = 2 TO setNum STEP 2%@NL@%
               FOR i% = 1 TO maxLen%%@NL@%
                  ValX2!(i%, j% \ 2) = setVal!(i%, j% - 1)%@NL@%
                  ValY2!(i%, j% \ 2) = setVal!(i%, j%)%@NL@%
               NEXT i%%@NL@%
            NEXT j%%@NL@%
%@NL@%
            ChartScatterMS CEnv, ValX2!(), ValY2!(), maxLen%, 1, setNum \ 2, setName$()%@NL@%
         END IF%@NL@%
%@NL@%
   END SELECT%@NL@%
%@NL@%
%@AB@%   ' If there's been a "fatal" error, indicate what it was:%@AE@%%@NL@%
   IF ChartErr <> 0 THEN%@NL@%
       GOSUB ViewError%@NL@%
%@NL@%
%@AB@%   ' Otherwise, just wait for a keypress:%@AE@%%@NL@%
   ELSE%@NL@%
%@AB@%      ' Wait for keypress%@AE@%%@NL@%
      DO%@NL@%
            c$ = INKEY$%@NL@%
            MousePoll r, c, lb, rb%@NL@%
      LOOP UNTIL c$ <> "" OR lb OR rb%@NL@%
      SCREEN 0%@NL@%
      WIDTH 80%@NL@%
      SetUpBackground%@NL@%
      MenuShow%@NL@%
      MouseShow%@NL@%
   END IF%@NL@%
%@NL@%
EXIT SUB%@NL@%
%@NL@%
%@AB@%' handle charting errors%@AE@%%@NL@%
ViewError:%@NL@%
%@NL@%
%@AB@%    ' re-init the display%@AE@%%@NL@%
    SCREEN 0%@NL@%
    WIDTH 80%@NL@%
    SetUpBackground%@NL@%
    MenuShow%@NL@%
    MouseShow%@NL@%
%@NL@%
%@AB@%    ' display appropriate error message%@AE@%%@NL@%
    SELECT CASE ChartErr%@NL@%
        CASE cBadDataWindow:%@NL@%
            PrintError "Data window cannot be displayed in available space."%@NL@%
        CASE cBadLegendWindow:%@NL@%
            PrintError "Invalid legend coordinates."%@NL@%
        CASE cTooFewSeries:%@NL@%
            PrintError "Too few series to plot."%@NL@%
        CASE cTooSmallN:%@NL@%
            PrintError "No data in series."%@NL@%
        CASE IS > 200:                              ' basic error%@NL@%
            PrintError "BASIC error #" + LTRIM$(STR$(ChartErr - 200)) + " occurred."%@NL@%
        CASE ELSE:                                  ' extraneous error%@NL@%
            PrintError "Charting error #" + LTRIM$(STR$(ChartErr)) + " occurred."%@NL@%
    END SELECT%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ViewFont%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Displays list of registered fonts and allows user to%@AE@%%@NL@%
%@AB@%'              select one or more of these fonts to load%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ViewFont%@NL@%
SHARED screenMode AS INTEGER%@NL@%
SHARED origPath$%@NL@%
DIM FI AS FontInfo%@NL@%
DIM rfonts$(1 TO MAXFONTS)%@NL@%
%@NL@%
    SetMaxFonts MAXFONTS, MAXFONTS%@NL@%
%@NL@%
%@AB@%    ' get default font%@AE@%%@NL@%
    DefaultFont Segment%, Offset%%@NL@%
    numReg = RegisterMemFont%(Segment%, Offset%)%@NL@%
%@NL@%
%@AB@%    ' use font files that are best suited for current screen mode%@AE@%%@NL@%
    IF MID$(origPath$, LEN(origPath$), 1) = "\" THEN%@NL@%
        t$ = ""%@NL@%
    ELSE%@NL@%
        t$ = "\"%@NL@%
    END IF%@NL@%
    SELECT CASE screenMode%@NL@%
        CASE 2, 8%@NL@%
            cour$ = origPath$ + t$ + "COURA.FON"%@NL@%
            helv$ = origPath$ + t$ + "HELVA.FON"%@NL@%
            tims$ = origPath$ + t$ + "TMSRA.FON"%@NL@%
        CASE 11, 12%@NL@%
            cour$ = origPath$ + t$ + "COURE.FON"%@NL@%
            helv$ = origPath$ + t$ + "HELVE.FON"%@NL@%
            tims$ = origPath$ + t$ + "TMSRE.FON"%@NL@%
        CASE ELSE%@NL@%
            cour$ = origPath$ + t$ + "COURB.FON"%@NL@%
            helv$ = origPath$ + t$ + "HELVB.FON"%@NL@%
            tims$ = origPath$ + t$ + "TMSRB.FON"%@NL@%
    END SELECT%@NL@%
%@AB@%    ' register courier fonts%@AE@%%@NL@%
    numReg = numReg + RegisterFonts%(cour$)%@NL@%
    fontname$ = cour$%@NL@%
    IF FontErr > 0 THEN GOSUB FontError%@NL@%
%@NL@%
%@AB@%    ' register helvetica fonts%@AE@%%@NL@%
    numReg = numReg + RegisterFonts%(helv$)%@NL@%
    fontname$ = helv$%@NL@%
    IF FontErr > 0 THEN GOSUB FontError%@NL@%
%@NL@%
%@AB@%    ' register times roman fonts%@AE@%%@NL@%
    numReg = numReg + RegisterFonts%(tims$)%@NL@%
    fontname$ = tims$%@NL@%
    IF FontErr > 0 THEN GOSUB FontError%@NL@%
%@NL@%
%@AB@%    ' create a list of registered fonts%@AE@%%@NL@%
    FOR i = 1 TO numReg%@NL@%
        GetRFontInfo i, FI%@NL@%
        rfonts$(i) = RTRIM$(MID$(FI.FaceName, 1, 8)) + STR$(FI.Points) + " Point"%@NL@%
    NEXT i%@NL@%
%@NL@%
%@AB@%    ' set up window display%@AE@%%@NL@%
    winRow = 5%@NL@%
    winCol = 25%@NL@%
    WindowOpen 1, winRow, winCol, winRow + numReg + 1, 51, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 2, "Chart Fonts"%@NL@%
%@NL@%
%@AB@%    ' open buttons for each font in list%@AE@%%@NL@%
    FOR i% = 1 TO numReg%@NL@%
        ButtonOpen i, 1, rfonts$(i), i, 4, 0, 0, 2%@NL@%
        FOR j% = 1 TO numFonts%@NL@%
            IF fonts$(j%) = rfonts$(i%) THEN ButtonSetState i, 2%@NL@%
        NEXT j%%@NL@%
    NEXT i%%@NL@%
%@NL@%
    WindowLine numReg + 1%@NL@%
    ButtonOpen numReg + 1, 2, "Load", numReg + 2, 4, 0, 0, 1%@NL@%
    ButtonOpen numReg + 2, 1, "Cancel ", numReg + 2, 15, 0, 0, 1%@NL@%
%@NL@%
%@AB@%    ' start with cursor on first button%@AE@%%@NL@%
    currButton = 1%@NL@%
    pushButton = numReg + 1%@NL@%
%@NL@%
%@AB@%    ' window control loop%@AE@%%@NL@%
    finished = FALSE%@NL@%
    WHILE NOT finished%@NL@%
        WindowDo currButton, 0%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1                                     ' button pressed%@NL@%
                currButton = Dialog(1)%@NL@%
                IF currButton > numReg THEN%@NL@%
                    pushButton = currButton%@NL@%
                    finished = TRUE%@NL@%
                ELSE%@NL@%
                    ButtonToggle currButton%@NL@%
                END IF%@NL@%
            CASE 6                                      ' enter%@NL@%
                finished = TRUE%@NL@%
            CASE 7                                      ' tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE numReg, numReg + 1:%@NL@%
                        currButton = currButton + 1%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE numReg + 2:%@NL@%
                        currButton = 1%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        pushButton = numReg + 1%@NL@%
                        ButtonSetState pushButton, 2%@NL@%
                    CASE ELSE:%@NL@%
                        currButton = currButton + 1%@NL@%
                END SELECT%@NL@%
            CASE 8                                      ' back tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1:%@NL@%
                        currButton = numReg + 2%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE numReg + 2:%@NL@%
                        currButton = numReg + 1%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = currButton%@NL@%
                    CASE ELSE:%@NL@%
                        currButton = currButton - 1%@NL@%
                    END SELECT%@NL@%
            CASE 9                                      ' escape%@NL@%
                pushButton = numReg + 2%@NL@%
                finished = TRUE%@NL@%
            CASE 10, 12                                 ' up, left arrow%@NL@%
                IF currButton <= numReg THEN ButtonSetState currButton, 2%@NL@%
            CASE 11, 13                                 ' down, right arrow%@NL@%
                IF currButton <= numReg THEN ButtonSetState currButton, 1%@NL@%
            CASE 14                                     ' space bar%@NL@%
                IF currButton <= numReg THEN%@NL@%
                    ButtonToggle currButton%@NL@%
                ELSE%@NL@%
                    finished = TRUE%@NL@%
                END IF%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%    ' finished and not cancelled%@AE@%%@NL@%
    IF finished AND pushButton = numReg + 1 THEN%@NL@%
%@AB@%        ' create font spec for load operation%@AE@%%@NL@%
        FontSpec$ = ""%@NL@%
        FOR i% = 1 TO numReg%@NL@%
            IF ButtonInquire(i) = 2 THEN%@NL@%
                FontSpec$ = FontSpec$ + "/n" + LTRIM$(STR$(i))%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%        ' default if none chosen%@AE@%%@NL@%
        IF FontSpec$ = "" THEN%@NL@%
            PrintError "No fonts selected - using default."%@NL@%
            numFonts = LoadFont%("N1")%@NL@%
            REDIM fonts$(1)%@NL@%
            fonts$(1) = rfonts$(1)%@NL@%
        ELSE%@NL@%
%@AB@%            ' load selected fonts%@AE@%%@NL@%
            numLoaded = LoadFont%(RIGHT$(FontSpec$, LEN(FontSpec$) - 1))%@NL@%
%@NL@%
%@AB@%            ' notify user of error and let them try again.%@AE@%%@NL@%
            IF FontErr <> 0 THEN%@NL@%
                GOSUB FontError%@NL@%
                finished = FALSE%@NL@%
                currButton = 1%@NL@%
            ELSE%@NL@%
                REDIM fonts$(numLoaded)%@NL@%
%@AB@%                ' create a list of loaded fonts%@AE@%%@NL@%
                FOR i = 1 TO numLoaded%@NL@%
                    SelectFont i%@NL@%
                    GetFontInfo FI%@NL@%
                    fonts$(i) = RTRIM$(MID$(FI.FaceName, 1, 8)) + STR$(FI.Points) + " Point"%@NL@%
                NEXT i%@NL@%
                numFonts = numLoaded%@NL@%
                ClearFonts%@NL@%
            END IF%@NL@%
        END IF%@NL@%
%@AB@%    ' reload existing fonts if operation cancelled%@AE@%%@NL@%
    ELSEIF finished = TRUE AND pushButton = numReg + 2 THEN%@NL@%
        FontSpec$ = ""%@NL@%
        FOR i = 1 TO numReg%@NL@%
            FOR j% = 1 TO numFonts%@NL@%
                IF fonts$(j%) = rfonts$(i%) THEN FontSpec$ = FontSpec$ + "/n" + LTRIM$(STR$(i))%@NL@%
            NEXT j%%@NL@%
        NEXT i%@NL@%
        numFonts = LoadFont%(RIGHT$(FontSpec$, LEN(FontSpec$) - 1))%@NL@%
    END IF%@NL@%
%@NL@%
    WEND%@NL@%
%@NL@%
    UnRegisterFonts%@NL@%
%@NL@%
    WindowClose 1%@NL@%
%@NL@%
    EXIT SUB%@NL@%
%@NL@%
%@AB@%' handle font loading errors%@AE@%%@NL@%
FontError:%@NL@%
    SELECT CASE FontErr%@NL@%
        CASE cNoFontMem:%@NL@%
            PrintError "Not enough memory to load selected fonts."%@NL@%
        CASE cFileNotFound:%@NL@%
            PrintError fontname$ + " font file not found."%@NL@%
        CASE cTooManyFonts:%@NL@%
            numReg = MAXFONTS%@NL@%
        CASE cBadFontFile:%@NL@%
            PrintError "Invalid font file format for " + fontname$ + "."%@NL@%
        CASE cNoFonts:%@NL@%
            PrintError "No fonts are loaded."%@NL@%
        CASE cBadFontType:%@NL@%
            PrintError "Font not a bitmap font."%@NL@%
        CASE IS > 200:                                  ' basic error%@NL@%
            PrintError "BASIC error #" + LTRIM$(STR$(FontErr - 200)) + " occurred."%@NL@%
        CASE ELSE                                       ' unplanned font error%@NL@%
            PrintError "Font error #" + LTRIM$(STR$(FontErr)) + " occurred."%@NL@%
    END SELECT%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ViewScreenMode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Displays list of valid screen modes and allows the%@AE@%%@NL@%
%@AB@%'              user to select one for viewing the chart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ViewScreenMode%@NL@%
SHARED screenMode AS INTEGER, numModes AS INTEGER, mode$()%@NL@%
%@NL@%
DIM modeBox AS ListBox%@NL@%
%@NL@%
%@AB@%    ' set up list box containing valid screen modes%@AE@%%@NL@%
    modeBox.scrollButton = 1%@NL@%
    modeBox.areaButton = 2%@NL@%
    modeBox.listLen = numModes%@NL@%
    modeBox.topRow = 1%@NL@%
    modeBox.botRow = numModes + 2%@NL@%
    modeBox.leftCol = 7%@NL@%
    modeBox.rightCol = 21%@NL@%
%@NL@%
%@AB@%    ' determine current screen mode%@AE@%%@NL@%
    FOR i = 1 TO numModes%@NL@%
        IF screenMode = VAL(mode$(i)) THEN modeBox.listPos = i%@NL@%
    NEXT i%@NL@%
%@NL@%
%@AB@%    ' set up display window%@AE@%%@NL@%
    winRow = 6%@NL@%
    winCol = 25%@NL@%
    WindowOpen 1, winRow, winCol, winRow + numModes + 3, 51, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 2, "Screen Mode"%@NL@%
    WindowLine numModes + 3%@NL@%
%@NL@%
%@AB@%    ' create the list box%@AE@%%@NL@%
    CreateListBox mode$(), modeBox, 0%@NL@%
%@NL@%
%@AB@%    ' open command buttons%@AE@%%@NL@%
    ButtonOpen 3, 2, "OK ", numModes + 4, 4, 0, 0, 1%@NL@%
    ButtonOpen 4, 1, "Cancel ", numModes + 4, 16, 0, 0, 1%@NL@%
%@NL@%
%@NL@%
        a$ = "Screen Mode Warning ||"%@NL@%
        a$ = a$ + "Selecting screen modes that support less than |"%@NL@%
        a$ = a$ + "than 16 colors will reset all chart colors to |"%@NL@%
        a$ = a$ + "their black and white defaults.               |"%@NL@%
        a$ = a$ + "|" + " Fonts should be reloaded after screen mode is   |"%@NL@%
        a$ = a$ + " changed to ensure best font match for screen   |"%@NL@%
        a$ = a$ + " resolution.                                     "%@NL@%
        junk = Alert(4, a$, 6, 15, 16, 65, "", "", "")%@NL@%
%@NL@%
%@NL@%
%@AB@%    ' start with cursor in area button%@AE@%%@NL@%
    currButton = 2%@NL@%
    pushButton = 3%@NL@%
%@NL@%
%@AB@%    ' window control loop%@AE@%%@NL@%
    finished = FALSE%@NL@%
    WHILE NOT finished%@NL@%
        WindowDo currButton, 0                         ' wait for event%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1                                     ' button pressed%@NL@%
                currButton = Dialog(1)%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2:%@NL@%
                        ScrollList mode$(), modeBox, currButton, 1, 0, winRow, winCol%@NL@%
                        currButton = 2%@NL@%
                    CASE 3, 4:%@NL@%
                        pushButton = currButton%@NL@%
                        finished = TRUE%@NL@%
                END SELECT%@NL@%
            CASE 6                                      ' enter%@NL@%
                finished = TRUE%@NL@%
            CASE 7                                      ' tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2:%@NL@%
                        currButton = 3%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = 3%@NL@%
                    CASE 3:%@NL@%
                        currButton = 4%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = 4%@NL@%
                    CASE 4:%@NL@%
                        ButtonSetState currButton, 1%@NL@%
                        currButton = 2%@NL@%
                        pushButton = 3%@NL@%
                        ButtonSetState pushButton, 2%@NL@%
                END SELECT%@NL@%
            CASE 8                                      ' back tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2:%@NL@%
                        currButton = 4%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = 4%@NL@%
                    CASE 3: currButton = 2%@NL@%
                    CASE 4:%@NL@%
                        currButton = 3%@NL@%
                        ButtonSetState pushButton, 1%@NL@%
                        ButtonSetState currButton, 2%@NL@%
                        pushButton = 3%@NL@%
                    END SELECT%@NL@%
            CASE 9                                      ' escape%@NL@%
                pushButton = 4%@NL@%
                finished = TRUE%@NL@%
            CASE 10, 12                                 ' up, left arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2: ScrollList mode$(), modeBox, currButton, 2, 0, winRow, winCol%@NL@%
                END SELECT%@NL@%
            CASE 11, 13                                 ' down, right arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2: ScrollList mode$(), modeBox, currButton, 3, 0, winRow, winCol%@NL@%
                END SELECT%@NL@%
            CASE 14                                     ' space bar%@NL@%
                IF currButton > 2 THEN finished = TRUE%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' if not canceled%@AE@%%@NL@%
    IF pushButton = 3 THEN%@NL@%
%@AB@%        ' change screen mode%@AE@%%@NL@%
        IF screenMode <> VAL(mode$(modeBox.listPos)) THEN%@NL@%
            IF setNum > 0 THEN chartChanged = TRUE%@NL@%
%@NL@%
            screenMode = VAL(mode$(modeBox.listPos))%@NL@%
%@NL@%
%@AB@%            ' reset window coords%@AE@%%@NL@%
            CEnv.ChartWindow.X1 = 0%@NL@%
            CEnv.ChartWindow.Y1 = 0%@NL@%
            CEnv.ChartWindow.X2 = 0%@NL@%
            CEnv.ChartWindow.Y2 = 0%@NL@%
%@NL@%
%@AB@%            ' change color list based on new screen mode%@AE@%%@NL@%
            InitColors%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
    WindowClose 1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CHRTDEMO.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\CHRTDEMO.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'       CHRTDEMO.BAS - Main module of CHRTB demonstration program%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'             Copyright (C) 1989, Microsoft Corporation%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   This demo program uses the Presentation Graphics and User Interface%@AE@%%@NL@%
%@AB@%'   toolboxes to implement a general purpose charting package.%@AE@%%@NL@%
%@AB@%'   It consists of three modules (CHRTDEMO.BAS, CHRTDEM1.BAS and CHRTDEM2.BAS)%@AE@%%@NL@%
%@AB@%'   and one include file (CHRTDEMO.BI).  It requires access to both the%@AE@%%@NL@%
%@AB@%'   Presentation Graphics and User Interface toolboxes.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   EMS is needed to load and run the demo under QBX.  If you do not%@AE@%%@NL@%
%@AB@%'   have EMS, refer to the command line compile instructions below which%@AE@%%@NL@%
%@AB@%'   will allow you to run the demo from the DOS prompt.  Running the%@AE@%%@NL@%
%@AB@%'   demo under QBX requires access to the Presentation Graphics and User%@AE@%%@NL@%
%@AB@%'   Interface toolboxes.  This can be done in one of two methods:%@AE@%%@NL@%
%@AB@%'       1) One large QuickLib covering both toolboxes can be created.  The%@AE@%%@NL@%
%@AB@%'          library "CHRTDEM.LIB" and QuickLib "CHRTDEM.QLB" are created%@AE@%%@NL@%
%@AB@%'          as follows:%@AE@%%@NL@%
%@AB@%'           BC /X/FS chrtb.bas;%@AE@%%@NL@%
%@AB@%'           BC /X/FS fontb.bas;%@AE@%%@NL@%
%@AB@%'           LIB chrtdem.lib + uitbefr.lib + fontasm + chrtasm + fontb + chrtb;%@AE@%%@NL@%
%@AB@%'           LINK /Q chrtdem.lib, chrtdem.qlb,,qbxqlb.lib;%@AE@%%@NL@%
%@AB@%'          Once created, just start QBX with this QuickLib and load the%@AE@%%@NL@%
%@AB@%'          demo's modules (chrtdemo.bas, chrtdem1.bas and chrtdem2.bas).%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'       2) Either the Presentation Graphics or User Interface QuickLib%@AE@%%@NL@%
%@AB@%'          may be used alone provided the other's source code files%@AE@%%@NL@%
%@AB@%'          are loaded into the QBX environment.  If CHRTBEFR.QLB is%@AE@%%@NL@%
%@AB@%'          is used then WINDOW.BAS, GENERAL.BAS, MENU.BAS and MOUSE.BAS%@AE@%%@NL@%
%@AB@%'          must be loaded.  If UITBEFR.QLB is used then CHRTB.BAS and%@AE@%%@NL@%
%@AB@%'          FONTB.BAS must be loaded.  Once a QuickLib is specified and%@AE@%%@NL@%
%@AB@%'          all necessary source files are loaded, load the program%@AE@%%@NL@%
%@AB@%'          modules (chrtdemo.bas, chrtdem1.bas and chrtdem2.bas)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   To create a compiled version of the chart demo program perform the%@AE@%%@NL@%
%@AB@%'   following steps:%@AE@%%@NL@%
%@AB@%'       BC /X/FS chrtb.bas;%@AE@%%@NL@%
%@AB@%'       BC /X/FS fontb.bas;%@AE@%%@NL@%
%@AB@%'       LIB chrtdem.lib + uitbefr.lib + fontasm + chrtasm + fontb + chrtb;%@AE@%%@NL@%
%@AB@%'       BC /X/FS chrtdemo.bas;%@AE@%%@NL@%
%@AB@%'       BC /FS chrtdem1.bas;%@AE@%%@NL@%
%@AB@%'       BC /FS chrtdem2.bas;%@AE@%%@NL@%
%@AB@%'       LINK /EX chrtdemo chrtdem1 chrtdem2, chrtdemo.exe,, chrtdem.lib;%@AE@%%@NL@%
%@AB@%'   "CHRTDEMO" can now be run from the command line.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
%@AB@%'$INCLUDE: 'chrtdemo.bi'%@AE@%%@NL@%
%@NL@%
%@AB@%' local functions%@AE@%%@NL@%
DECLARE FUNCTION GetLoadFile% (FileName$)%@NL@%
DECLARE FUNCTION GetSaveFile% (FileName$)%@NL@%
DECLARE FUNCTION GetFileCount% (fileSpec$)%@NL@%
%@NL@%
%@AB@%' local subs%@AE@%%@NL@%
DECLARE SUB LoadChart (fileNum%)%@NL@%
DECLARE SUB ShowError (errorNum%)%@NL@%
%@NL@%
%@NL@%
%@AB@%' necessary variables for the toolboxes%@AE@%%@NL@%
DIM GloTitle(MAXMENU)           AS MenuTitleType%@NL@%
DIM GloItem(MAXMENU, MAXITEM)   AS MenuItemType%@NL@%
DIM GloWindow(MAXWINDOW)        AS windowType%@NL@%
DIM GloButton(MAXBUTTON)        AS buttonType%@NL@%
DIM GloEdit(MAXEDITFIELD)       AS EditFieldType%@NL@%
DIM GloWindowStack(MAXWINDOW)   AS INTEGER%@NL@%
DIM GloBuffer$(MAXWINDOW + 1, 2)%@NL@%
%@NL@%
%@AB@%' variables shared across modules%@AE@%%@NL@%
DIM colors$(1 TO MAXCOLORS)                     'valid colors$%@NL@%
DIM styles$(1 TO MAXSTYLES)                     'border style list%@NL@%
DIM fonts$(1 TO MAXFONTS)                       'fonts list%@NL@%
DIM Cat$(1 TO cMaxValues)                       'category names%@NL@%
DIM setName$(1 TO cMaxSets)                     'set names%@NL@%
DIM setLen(1 TO cMaxSets)   AS INTEGER          '# values per set%@NL@%
DIM setVal!(1 TO cMaxValues, 1 TO cMaxSets)     ' actual values%@NL@%
DIM mode$(1 TO 13)                              'list of modes%@NL@%
%@NL@%
%@NL@%
%@AB@%    ' set up main error handler%@AE@%%@NL@%
    ON ERROR GOTO ErrorHandle%@NL@%
%@NL@%
%@AB@%    ' initialize the program%@AE@%%@NL@%
    InitAll%@NL@%
%@NL@%
%@AB@%    ' Main loop%@AE@%%@NL@%
    WHILE NOT finished%@NL@%
        kbd$ = MenuInkey$%@NL@%
        WHILE MenuCheck(2)%@NL@%
            HandleMenuEvent%@NL@%
        WEND%@NL@%
    WEND%@NL@%
%@NL@%
    END%@NL@%
%@NL@%
%@AB@%'catch all error handler%@AE@%%@NL@%
ErrorHandle:%@NL@%
    ShowError ERR%@NL@%
    WindowClose 1                               ' close any active windows%@NL@%
    WindowClose 2%@NL@%
RESUME NEXT%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Function Name: GetBestMode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Creates a list of valid screen modes for use by charting functions%@AE@%%@NL@%
%@AB@%'              and sets the initial screen mode to the highest resolution%@AE@%%@NL@%
%@AB@%'              possible.  If no graphic screen modes are available then%@AE@%%@NL@%
%@AB@%'              it causes the program to exit.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: screenMode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB GetBestMode (screenMode)%@NL@%
SHARED mode$(), numModes AS INTEGER%@NL@%
%@NL@%
ON LOCAL ERROR GOTO badmode                     ' trap screen mode errors%@NL@%
%@NL@%
%@AB@%    ' test all possible screen modes creating a list of valid ones as we go%@AE@%%@NL@%
    numModes = 0%@NL@%
    FOR i = 13 TO 1 STEP -1%@NL@%
        valid = TRUE%@NL@%
        SCREEN i%@NL@%
        IF valid THEN%@NL@%
            numModes = numModes + 1%@NL@%
            mode$(numModes) = LTRIM$(STR$(i))%@NL@%
        END IF%@NL@%
    NEXT i%@NL@%
%@NL@%
%@AB@%    ' exit if no modes available%@AE@%%@NL@%
    IF numModes = 0 THEN%@NL@%
        screenMode = 0%@NL@%
%@AB@%    ' set current screen mode to best possible%@AE@%%@NL@%
    ELSEIF mode$(1) = "13" THEN%@NL@%
        screenMode = VAL(mode$(2))%@NL@%
    ELSE%@NL@%
        screenMode = VAL(mode$(1))%@NL@%
    END IF%@NL@%
%@NL@%
EXIT SUB%@NL@%
%@NL@%
badmode:%@NL@%
    valid = FALSE%@NL@%
RESUME NEXT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Func Name: GetFileCount%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Returns number of DOS files matching a given file spec%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: fileSpec$ - DOS file spec  (i.e. "*.*")%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION GetFileCount% (fileSpec$)%@NL@%
%@NL@%
ON LOCAL ERROR GOTO GetCountError%@NL@%
%@NL@%
    count = 0%@NL@%
%@NL@%
    FileName$ = DIR$(fileSpec$)             ' Get first match if any%@NL@%
%@NL@%
    DO WHILE FileName$ <> ""                ' continue until no more matches%@NL@%
        count = count + 1%@NL@%
        FileName$ = DIR$%@NL@%
    LOOP%@NL@%
%@NL@%
    GetFileCount = count                    ' return count%@NL@%
%@NL@%
    EXIT FUNCTION%@NL@%
%@NL@%
GetCountError:%@NL@%
%@NL@%
    ShowError ERR                               ' display error message%@NL@%
%@NL@%
RESUME NEXT%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Func Name: GetLoadFile%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Called by OpenChart, this prompts the user for a%@AE@%%@NL@%
%@AB@%'              DOS file to open.  It returns the file number of%@AE@%%@NL@%
%@AB@%'              the chart file with the actual file name being%@AE@%%@NL@%
%@AB@%'              passed back via the argument.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: FileName$ - name of file to open%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION GetLoadFile% (FileName$)%@NL@%
DIM fileList$(1 TO 10)%@NL@%
DIM fileBox AS ListBox%@NL@%
%@NL@%
ON LOCAL ERROR GOTO GetLoadError                ' handle file opening errors%@NL@%
%@NL@%
    fileSpec$ = "*.CHT"                         ' default file spec%@NL@%
    origDir$ = CURDIR$%@NL@%
    origPos = 0                                 ' no file list element selected%@NL@%
%@NL@%
%@AB@%    ' get list of files matching spec%@AE@%%@NL@%
    fileCount = GetFileCount(fileSpec$)%@NL@%
    IF fileCount THEN%@NL@%
        REDIM fileList$(fileCount)%@NL@%
    END IF%@NL@%
    fileList$(1) = DIR$(fileSpec$)%@NL@%
    FOR i% = 2 TO fileCount%@NL@%
        fileList$(i%) = DIR$%@NL@%
    NEXT i%%@NL@%
%@NL@%
%@AB@%    ' set up list box for file list%@AE@%%@NL@%
    fileBox.scrollButton = 1%@NL@%
    fileBox.areaButton = 2%@NL@%
    fileBox.listLen = fileCount%@NL@%
    fileBox.topRow = 8%@NL@%
    fileBox.botRow = 14%@NL@%
    fileBox.leftCol = 7%@NL@%
    fileBox.rightCol = 22%@NL@%
    fileBox.listPos = origPos%@NL@%
%@NL@%
%@AB@%    ' create window for display%@AE@%%@NL@%
    winRow = 6%@NL@%
    winCol = 25%@NL@%
    WindowOpen 1, winRow, winCol, 21, 52, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 2, "Open Chart"%@NL@%
    WindowLocate 2, 2%@NL@%
    WindowPrint 2, "File Name:"%@NL@%
    WindowBox 1, 13, 3, 27%@NL@%
    WindowLocate 5, 2%@NL@%
    WindowPrint -1, origDir$%@NL@%
    WindowLocate 7, 11%@NL@%
    WindowPrint 2, "Files"%@NL@%
    WindowLine 15%@NL@%
%@NL@%
%@AB@%    ' create list box for file list%@AE@%%@NL@%
    CreateListBox fileList$(), fileBox, 5%@NL@%
%@NL@%
%@AB@%    ' open edit field for file spec%@AE@%%@NL@%
    EditFieldOpen 1, fileSpec$, 2, 14, 0, 7, 13, 70%@NL@%
%@NL@%
%@AB@%    ' open command buttons%@AE@%%@NL@%
    ButtonOpen 3, 2, "OK", 16, 5, 0, 0, 1%@NL@%
    ButtonOpen 4, 1, "Cancel", 16, 15, 0, 0, 1%@NL@%
%@NL@%
%@AB@%    ' start with cursor in edit field%@AE@%%@NL@%
    currButton = 0%@NL@%
    currEditField = 1%@NL@%
    pushButton = 3%@NL@%
%@NL@%
%@AB@%    ' control loop%@AE@%%@NL@%
    finished = FALSE%@NL@%
    WHILE NOT finished%@NL@%
        WindowDo currButton, currEditField              ' wait for event%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1                                      ' button pressed%@NL@%
                currButton = Dialog(1)%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2: currEditField = 0%@NL@%
                        ScrollList fileList$(), fileBox, currButton, 1, 0, winRow, winCol%@NL@%
                        currButton = 2%@NL@%
                    CASE 3, 4: pushButton = currButton%@NL@%
                        finished = TRUE%@NL@%
                END SELECT%@NL@%
            CASE 2                                      ' Edit Field%@NL@%
                currButton = 0%@NL@%
                currEditField = 1%@NL@%
            CASE 6                                      ' enter%@NL@%
                IF INSTR(EditFieldInquire$(1), "*") = 0 THEN finished = TRUE%@NL@%
            CASE 7                                      ' tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0: currButton = 2%@NL@%
                        currEditField = 0%@NL@%
                    CASE 1, 2:%@NL@%
                        currButton = 3%@NL@%
                        ButtonSetState 3, 2%@NL@%
                        ButtonSetState 4, 1%@NL@%
                        pushButton = 3%@NL@%
                    CASE 3:%@NL@%
                        currButton = 4%@NL@%
                        ButtonSetState 3, 1%@NL@%
                        ButtonSetState 4, 2%@NL@%
                        pushButton = 4%@NL@%
                    CASE 4:%@NL@%
                        currButton = 0%@NL@%
                        currEditField = 1%@NL@%
                        ButtonSetState 3, 2%@NL@%
                        ButtonSetState 4, 1%@NL@%
                        pushButton = 3%@NL@%
                END SELECT%@NL@%
            CASE 8                                      ' back tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0: currButton = 4%@NL@%
                        currEditField = 0%@NL@%
                        ButtonSetState 3, 1%@NL@%
                        ButtonSetState 4, 2%@NL@%
                        pushButton = 4%@NL@%
                    CASE 1, 2:%@NL@%
                        currButton = 0%@NL@%
                        currEditField = 1%@NL@%
                    CASE 3:%@NL@%
                        currButton = 2%@NL@%
                    CASE 4:%@NL@%
                        currButton = 3%@NL@%
                        ButtonSetState 3, 2%@NL@%
                        ButtonSetState 4, 1%@NL@%
                        pushButton = 3%@NL@%
                END SELECT%@NL@%
            CASE 9                                      ' escape%@NL@%
                pushButton = 4%@NL@%
                finished = TRUE%@NL@%
            CASE 10, 12                                 ' up, left arrow%@NL@%
                IF currButton = 1 OR currButton = 2 THEN ScrollList fileList$(), fileBox, currButton, 2, 0, winRow, winCol%@NL@%
            CASE 11, 13                                 'down, right arrow%@NL@%
                IF currButton = 1 OR currButton = 2 THEN ScrollList fileList$(), fileBox, currButton, 3, 0, winRow, winCol%@NL@%
            CASE 14                                     ' space bar%@NL@%
                IF currButton > 2 THEN%@NL@%
                    pushButton = currButton%@NL@%
                    finished = TRUE%@NL@%
                END IF%@NL@%
        END SELECT%@NL@%
%@NL@%
        temp$ = EditFieldInquire$(1)%@NL@%
%@NL@%
%@AB@%        ' simple error checking before finishing%@AE@%%@NL@%
        IF finished AND pushButton <> 4 THEN%@NL@%
%@AB@%            ' invalid file specified%@AE@%%@NL@%
            IF INSTR(temp$, "*") THEN%@NL@%
                PrintError "Invalid file specification."%@NL@%
                finished = FALSE%@NL@%
            ELSEIF LEN(temp$) = 0 THEN%@NL@%
                PrintError "Must specify a name."%@NL@%
                finished = FALSE%@NL@%
            ELSE%@NL@%
                fileSpec$ = temp$%@NL@%
                fileNum% = FREEFILE%@NL@%
                OPEN fileSpec$ FOR INPUT AS fileNum%%@NL@%
%@NL@%
            END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' more processing to do%@AE@%%@NL@%
        IF NOT finished THEN%@NL@%
%@AB@%            ' update edit field display based on list box selection%@AE@%%@NL@%
            IF fileBox.listPos <> origPos THEN%@NL@%
                fileSpec$ = fileList$(fileBox.listPos)%@NL@%
                origPos = fileBox.listPos%@NL@%
                EditFieldClose 1%@NL@%
                EditFieldOpen 1, fileSpec$, 2, 14, 0, 7, 13, 70%@NL@%
%@AB@%            ' update list box contents based on new edit field contents%@AE@%%@NL@%
            ELSEIF LTRIM$(RTRIM$(fileSpec$)) <> LTRIM$(RTRIM$(temp$)) THEN%@NL@%
                fileSpec$ = UCASE$(temp$)%@NL@%
                IF fileSpec$ <> "" THEN%@NL@%
                    IF MID$(fileSpec$, 2, 1) = ":" THEN%@NL@%
                        CHDRIVE MID$(fileSpec$, 1, 2)%@NL@%
                        fileSpec$ = MID$(fileSpec$, 3, LEN(fileSpec$))%@NL@%
                    END IF%@NL@%
                    position = 0%@NL@%
                    WHILE INSTR(position + 1, fileSpec$, "\") <> 0%@NL@%
                        position = INSTR(position + 1, fileSpec$, "\")%@NL@%
                    WEND%@NL@%
                    IF position = 1 THEN%@NL@%
                        CHDIR "\"%@NL@%
                    ELSEIF position > 0 THEN%@NL@%
                        CHDIR LEFT$(fileSpec$, position - 1)%@NL@%
                    END IF%@NL@%
                    fileSpec$ = MID$(fileSpec$, position + 1, LEN(fileSpec$))%@NL@%
                    WindowLocate 5, 2%@NL@%
                    IF LEN(CURDIR$) > 26 THEN%@NL@%
                        direct$ = LEFT$(CURDIR$, 26)%@NL@%
                    ELSE%@NL@%
                        direct$ = CURDIR$%@NL@%
                    END IF%@NL@%
                    WindowPrint -1, direct$ + STRING$(26 - LEN(direct$), " ")%@NL@%
%@NL@%
                    fileCount = GetFileCount(fileSpec$)%@NL@%
                ELSE%@NL@%
                    fileCount = 0%@NL@%
                END IF%@NL@%
%@NL@%
                EditFieldClose 1%@NL@%
                EditFieldOpen 1, fileSpec$, 2, 14, 0, 7, 13, 70%@NL@%
%@NL@%
                fileBox.listLen = fileCount%@NL@%
                fileBox.maxLen = Min(fileCount, fileBox.boxLen)%@NL@%
                origPos = 0%@NL@%
                fileBox.listPos = origPos%@NL@%
                fileBox.currTop = 1%@NL@%
                fileBox.currPos = 0%@NL@%
%@AB@%                ' get new file list%@AE@%%@NL@%
                IF fileCount = 0 THEN%@NL@%
                    REDIM fileList$(10)%@NL@%
                ELSE%@NL@%
                    REDIM fileList$(fileCount)%@NL@%
                    fileList$(1) = DIR$(fileSpec$)%@NL@%
                    FOR i% = 2 TO fileCount%@NL@%
                        fileList$(i%) = DIR$%@NL@%
                    NEXT i%%@NL@%
                END IF%@NL@%
%@NL@%
                DrawList fileList$(), fileBox, 0   ' redraw file list%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' if operation not canceled return file name and file number%@AE@%%@NL@%
    IF pushButton = 3 THEN%@NL@%
        FileName$ = fileSpec$%@NL@%
        GetLoadFile% = fileNum%%@NL@%
    ELSE%@NL@%
        GetLoadFile% = 0%@NL@%
%@NL@%
        CHDRIVE MID$(origDir$, 1, 2)%@NL@%
        CHDIR MID$(origDir$, 3, LEN(origDir$))%@NL@%
    END IF%@NL@%
%@NL@%
    WindowClose 1%@NL@%
%@NL@%
    EXIT FUNCTION%@NL@%
%@NL@%
%@AB@%' handle any file opening errors%@AE@%%@NL@%
GetLoadError:%@NL@%
    CLOSE fileNum%%@NL@%
    finished = FALSE                            ' don't allow exit until valid file chosen%@NL@%
%@NL@%
    ShowError ERR                               ' display error message%@NL@%
RESUME NEXT%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Func Name: GetSaveFile%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Prompts the user for a DOS file to save the current%@AE@%%@NL@%
%@AB@%'              chart data and settings in.  It returns the file number%@AE@%%@NL@%
%@AB@%'              with the actual file name being passed back via the%@AE@%%@NL@%
%@AB@%'              argument.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: fileName$ - name of save file%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION GetSaveFile% (FileName$)%@NL@%
%@NL@%
ON LOCAL ERROR GOTO GetSaveError                    ' handle file open errors%@NL@%
%@NL@%
%@AB@%    ' Open window for display%@AE@%%@NL@%
    WindowOpen 1, 8, 20, 12, 58, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 1, "Save Chart As"%@NL@%
    WindowLocate 2, 2%@NL@%
    WindowPrint 2, "File Name:"%@NL@%
    WindowBox 1, 13, 3, 38%@NL@%
    WindowLine 4%@NL@%
%@NL@%
%@AB@%    ' open edit field for file name%@AE@%%@NL@%
    EditFieldOpen 1, RTRIM$(FileName$), 2, 14, 0, 7, 24, 70%@NL@%
%@NL@%
%@AB@%    ' open command buttons%@AE@%%@NL@%
    ButtonOpen 1, 2, "OK", 5, 6, 0, 0, 1%@NL@%
    ButtonOpen 2, 1, "Cancel", 5, 25, 0, 0, 1%@NL@%
%@NL@%
%@AB@%    ' start with cursor in edit field%@AE@%%@NL@%
    currButton = 0%@NL@%
    currEditField = 1%@NL@%
    pushButton = 1%@NL@%
%@NL@%
%@AB@%    ' control loop for window%@AE@%%@NL@%
    finished = FALSE%@NL@%
    WHILE NOT finished%@NL@%
        WindowDo currButton, currEditField              ' wait for event%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1                                      ' Button pressed%@NL@%
                pushButton = Dialog(1)%@NL@%
                finished = TRUE%@NL@%
            CASE 2                                      ' Edit Field%@NL@%
                currButton = 0%@NL@%
                currEditField = 1%@NL@%
            CASE 6                                      ' enter%@NL@%
                finished = TRUE%@NL@%
            CASE 7                                      ' tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0, 1:%@NL@%
                        ButtonSetState currButton, 1%@NL@%
                        currButton = currButton + 1%@NL@%
                        pushButton = currButton%@NL@%
                        ButtonSetState pushButton, 2%@NL@%
                        currEditField = 0%@NL@%
                    CASE 2%@NL@%
                        currButton = 0%@NL@%
                        pushButton = 1%@NL@%
                        currEditField = 1%@NL@%
                        ButtonSetState 1, 2%@NL@%
                        ButtonSetState 2, 1%@NL@%
                END SELECT%@NL@%
            CASE 8                                      ' back tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0:%@NL@%
                        currButton = 2%@NL@%
                        pushButton = 2%@NL@%
                        currEditField = 0%@NL@%
                        ButtonSetState 1, 1%@NL@%
                        ButtonSetState 2, 2%@NL@%
                    CASE 1%@NL@%
                        currButton = 0%@NL@%
                        currEditField = 1%@NL@%
                    CASE 2%@NL@%
                        currButton = 1%@NL@%
                        pushButton = 1%@NL@%
                        ButtonSetState 1, 2%@NL@%
                        ButtonSetState 2, 1%@NL@%
                END SELECT%@NL@%
            CASE 9                                      ' escape%@NL@%
                pushButton = 2%@NL@%
                finished = TRUE%@NL@%
            CASE 14                                     ' space bar%@NL@%
                IF currButton <> 0 THEN%@NL@%
                    finished = TRUE%@NL@%
                END IF%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' simple error checking before finishing%@AE@%%@NL@%
        IF finished = TRUE AND pushButton = 1 THEN%@NL@%
            temp$ = EditFieldInquire$(1)%@NL@%
%@AB@%            ' must specify a file%@AE@%%@NL@%
            IF temp$ = "" THEN%@NL@%
                PrintError "Must specify a name."%@NL@%
                finished = FALSE%@NL@%
%@AB@%            ' check if file is valid and can be opened%@AE@%%@NL@%
            ELSE%@NL@%
%@AB@%                ' open file%@AE@%%@NL@%
                fileNum% = FREEFILE%@NL@%
                OPEN temp$ FOR OUTPUT AS fileNum%%@NL@%
%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' if operation not canceled return file name and file number%@AE@%%@NL@%
    IF pushButton = 1 THEN%@NL@%
        FileName$ = EditFieldInquire$(1)%@NL@%
        GetSaveFile% = fileNum%%@NL@%
    ELSE%@NL@%
        GetSaveFile% = 0%@NL@%
    END IF%@NL@%
%@NL@%
    WindowClose 1%@NL@%
%@NL@%
    EXIT FUNCTION%@NL@%
%@NL@%
%@AB@%' local error handler%@AE@%%@NL@%
GetSaveError:%@NL@%
      finished = FALSE                              ' don't exit until valid file specified%@NL@%
      CLOSE fileNum%%@NL@%
%@NL@%
      ShowError ERR                                 ' display errors%@NL@%
RESUME NEXT%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: LoadChart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Loads chart data and settings from the given file.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: fileNum%  - file number%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB LoadChart (fileNum%)%@NL@%
SHARED Cat$(), catLen AS INTEGER%@NL@%
SHARED setLen() AS INTEGER, setName$(), setVal!()%@NL@%
SHARED screenMode AS INTEGER, numModes AS INTEGER, mode$()%@NL@%
%@NL@%
ON LOCAL ERROR GOTO LoadError                       ' handle file loading errors%@NL@%
%@NL@%
%@AB@%    ' Read file until EOF is reached:%@AE@%%@NL@%
    DO UNTIL EOF(fileNum%)%@NL@%
%@AB@%        ' get data type from file (C=category, V=value, T=title, S=setting):%@AE@%%@NL@%
        INPUT #fileNum%, type$%@NL@%
%@NL@%
%@AB@%        ' category data%@AE@%%@NL@%
        IF UCASE$(type$) = "C" THEN%@NL@%
            INPUT #fileNum%, catLen%@NL@%
            FOR i% = 1 TO catLen%@NL@%
                INPUT #fileNum%, Cat$(i%)%@NL@%
            NEXT i%%@NL@%
%@NL@%
%@AB@%        ' value data%@AE@%%@NL@%
        ELSEIF UCASE$(type$) = "V" THEN%@NL@%
%@AB@%            ' too many sets in file%@AE@%%@NL@%
            IF setNum >= cMaxSets THEN%@NL@%
                PrintError "Too many data sets in file. Extra sets lost."%@NL@%
                EXIT DO%@NL@%
            END IF%@NL@%
%@NL@%
            setNum = setNum + 1%@NL@%
            INPUT #fileNum%, setName$(setNum)         ' get set name%@NL@%
            INPUT #fileNum%, setLen(setNum)           ' get set length%@NL@%
            FOR i% = 1 TO setLen(setNum)%@NL@%
                INPUT #fileNum%, setVal!(i%, setNum)  ' get set values%@NL@%
            NEXT i%%@NL@%
%@NL@%
%@AB@%        ' title data%@AE@%%@NL@%
        ELSEIF UCASE$(type$) = "T" THEN%@NL@%
            INPUT #fileNum%, CEnv.MainTitle.title%@NL@%
            INPUT #fileNum%, CEnv.SubTitle.title%@NL@%
            INPUT #fileNum%, CEnv.XAxis.AxisTitle.title%@NL@%
            INPUT #fileNum%, CEnv.YAxis.AxisTitle.title%@NL@%
%@NL@%
%@AB@%        ' chart settings%@AE@%%@NL@%
        ELSEIF UCASE$(type$) = "S" THEN%@NL@%
            INPUT #fileNum%, screenMode%@NL@%
%@AB@%            ' test for valid screen mode%@AE@%%@NL@%
            valid = FALSE%@NL@%
            FOR i = 1 TO numModes%@NL@%
                IF screenMode = VAL(mode$(i)) THEN valid = TRUE%@NL@%
            NEXT i%@NL@%
            IF NOT valid THEN%@NL@%
                IF mode$(1) = "13" THEN%@NL@%
                    screenMode = VAL(mode$(2))%@NL@%
                ELSE%@NL@%
                    screenMode = VAL(mode$(1))%@NL@%
                END IF%@NL@%
            END IF%@NL@%
%@NL@%
            INPUT #fileNum%, CEnv.ChartType, CEnv.ChartStyle, CEnv.DataFont%@NL@%
%@NL@%
            INPUT #fileNum%, CEnv.ChartWindow.X1, CEnv.ChartWindow.Y1, CEnv.ChartWindow.X2, CEnv.ChartWindow.Y2%@NL@%
            INPUT #fileNum%, CEnv.ChartWindow.Background, CEnv.ChartWindow.border, CEnv.ChartWindow.BorderStyle, CEnv.ChartWindow.BorderColor%@NL@%
            INPUT #fileNum%, CEnv.DataWindow.X1, CEnv.DataWindow.Y1, CEnv.DataWindow.X2, CEnv.DataWindow.Y2%@NL@%
            INPUT #fileNum%, CEnv.DataWindow.Background, CEnv.DataWindow.border, CEnv.DataWindow.BorderStyle, CEnv.DataWindow.BorderColor%@NL@%
%@NL@%
            INPUT #fileNum%, CEnv.MainTitle.TitleFont, CEnv.MainTitle.TitleColor, CEnv.MainTitle.Justify%@NL@%
            INPUT #fileNum%, CEnv.SubTitle.TitleFont, CEnv.SubTitle.TitleColor, CEnv.SubTitle.Justify%@NL@%
%@NL@%
            INPUT #fileNum%, CEnv.XAxis.Grid, CEnv.XAxis.GridStyle, CEnv.XAxis.AxisColor, CEnv.XAxis.Labeled%@NL@%
            INPUT #fileNum%, CEnv.XAxis.AxisTitle.TitleFont, CEnv.XAxis.AxisTitle.TitleColor, CEnv.XAxis.AxisTitle.Justify%@NL@%
            INPUT #fileNum%, CEnv.XAxis.RangeType, CEnv.XAxis.LogBase, CEnv.XAxis.AutoScale, CEnv.XAxis.ScaleMin%@NL@%
            INPUT #fileNum%, CEnv.XAxis.ScaleMax, CEnv.XAxis.ScaleFactor, CEnv.XAxis.TicFont, CEnv.XAxis.TicInterval, CEnv.XAxis.TicFormat, CEnv.XAxis.TicDecimals%@NL@%
            INPUT #fileNum%, CEnv.XAxis.ScaleTitle.title%@NL@%
            INPUT #fileNum%, CEnv.XAxis.ScaleTitle.TitleFont, CEnv.XAxis.ScaleTitle.TitleColor, CEnv.XAxis.ScaleTitle.Justify%@NL@%
%@NL@%
            INPUT #fileNum%, CEnv.YAxis.Grid, CEnv.YAxis.GridStyle, CEnv.YAxis.AxisColor, CEnv.YAxis.Labeled%@NL@%
            INPUT #fileNum%, CEnv.YAxis.AxisTitle.TitleFont, CEnv.YAxis.AxisTitle.TitleColor, CEnv.YAxis.AxisTitle.Justify%@NL@%
            INPUT #fileNum%, CEnv.YAxis.RangeType, CEnv.YAxis.LogBase, CEnv.YAxis.AutoScale, CEnv.YAxis.ScaleMin%@NL@%
            INPUT #fileNum%, CEnv.YAxis.ScaleMax, CEnv.YAxis.ScaleFactor, CEnv.YAxis.TicFont, CEnv.YAxis.TicInterval, CEnv.YAxis.TicFormat, CEnv.YAxis.TicDecimals%@NL@%
            INPUT #fileNum%, CEnv.YAxis.ScaleTitle.title%@NL@%
            INPUT #fileNum%, CEnv.YAxis.ScaleTitle.TitleFont, CEnv.YAxis.ScaleTitle.TitleColor, CEnv.YAxis.ScaleTitle.Justify%@NL@%
%@NL@%
            INPUT #fileNum%, CEnv.Legend.Legend, CEnv.Legend.Place, CEnv.Legend.TextColor, CEnv.Legend.TextFont, CEnv.Legend.AutoSize%@NL@%
            INPUT #fileNum%, CEnv.Legend.LegendWindow.X1, CEnv.Legend.LegendWindow.Y1, CEnv.Legend.LegendWindow.X2, CEnv.Legend.LegendWindow.Y2%@NL@%
            INPUT #fileNum%, CEnv.Legend.LegendWindow.Background, CEnv.Legend.LegendWindow.border, CEnv.Legend.LegendWindow.BorderStyle, CEnv.Legend.LegendWindow.BorderColor%@NL@%
        ELSE%@NL@%
            GOSUB LoadError%@NL@%
        END IF%@NL@%
    LOOP%@NL@%
%@NL@%
%@AB@%    ' close the file%@AE@%%@NL@%
    CLOSE fileNum%%@NL@%
%@NL@%
%@AB@%    ' clear any font pointers that don't map to current fonts%@AE@%%@NL@%
    ClearFonts%@NL@%
%@NL@%
%@AB@%    ' initialize color list depending on newly loaded screen mode%@AE@%%@NL@%
    InitColors%@NL@%
%@NL@%
    EXIT SUB%@NL@%
%@NL@%
%@AB@%' handle any file format errors%@AE@%%@NL@%
LoadError:%@NL@%
%@NL@%
    IF ERR THEN%@NL@%
        ShowError ERR%@NL@%
    ELSE%@NL@%
        PrintError "Invalid file format.  Can't continue loading."%@NL@%
    END IF%@NL@%
%@NL@%
    CLOSE fileNum%                              ' close and exit%@NL@%
    EXIT SUB%@NL@%
%@NL@%
RESUME NEXT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: OpenChart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Handles both the "New" and "Open" operations from the%@AE@%%@NL@%
%@AB@%'              "File" menu title.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: newFlag - flag for determining which operation (New or Open)%@AE@%%@NL@%
%@AB@%'                      to perform.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB OpenChart (newFlag)%@NL@%
SHARED saveFile$%@NL@%
%@NL@%
%@AB@%    ' allow user to save current chart if necessary%@AE@%%@NL@%
    IF chartChanged THEN%@NL@%
        a$ = "|"%@NL@%
        a$ = a$ + "Current chart has not been saved.  Save now?"%@NL@%
%@NL@%
        status = Alert(4, a$, 8, 15, 12, 65, "Yes", "No", "Cancel")%@NL@%
%@NL@%
%@AB@%        ' save current chart%@AE@%%@NL@%
        IF status = OK THEN%@NL@%
            status = SaveChart(saveFile$, FALSE)%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
        status = OK%@NL@%
    END IF%@NL@%
%@NL@%
    IF status <> CANCEL THEN%@NL@%
%@AB@%        ' New option chosen so clear existing data, leave chart settings alone.%@AE@%%@NL@%
        IF newFlag = TRUE THEN%@NL@%
            MenuItemToggle GALLERYTITLE, CEnv.ChartType%@NL@%
            IF CEnv.ChartType = cPie THEN%@NL@%
                MenuSetState CHARTTITLE, 4, 1%@NL@%
                MenuSetState CHARTTITLE, 5, 1%@NL@%
                MenuSetState TITLETITLE, 3, 1%@NL@%
                MenuSetState TITLETITLE, 4, 1%@NL@%
            END IF%@NL@%
            InitChart%@NL@%
            saveFile$ = ""%@NL@%
%@AB@%        ' Open operation chosen so get file and load data%@AE@%%@NL@%
        ELSE%@NL@%
            fileNum% = GetLoadFile(saveFile$)%@NL@%
%@AB@%            ' if no errors opening file and operation not canceled then load data%@AE@%%@NL@%
            IF fileNum <> 0 THEN%@NL@%
%@AB@%                ' reset menu bar to nothing selected%@AE@%%@NL@%
                MenuItemToggle GALLERYTITLE, CEnv.ChartType%@NL@%
                IF CEnv.ChartType = cPie THEN%@NL@%
                    MenuSetState CHARTTITLE, 4, 1%@NL@%
                    MenuSetState CHARTTITLE, 5, 1%@NL@%
                    MenuSetState TITLETITLE, 3, 1%@NL@%
                    MenuSetState TITLETITLE, 4, 1%@NL@%
                END IF%@NL@%
%@NL@%
                ClearData                       'clear current data%@NL@%
%@NL@%
                setNum = 0%@NL@%
                LoadChart fileNum%             ' load the data%@NL@%
%@NL@%
%@AB@%                ' set menu bar according to new chart settings%@AE@%%@NL@%
                MenuItemToggle GALLERYTITLE, CEnv.ChartType%@NL@%
                IF CEnv.ChartType = cPie THEN%@NL@%
                    MenuSetState CHARTTITLE, 4, 0%@NL@%
                    MenuSetState CHARTTITLE, 5, 0%@NL@%
                    MenuSetState TITLETITLE, 3, 0%@NL@%
                    MenuSetState TITLETITLE, 4, 0%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' new chart not changed%@AE@%%@NL@%
                chartChanged = FALSE%@NL@%
%@NL@%
%@AB@%                ' chart data exists so allow user to view chart%@AE@%%@NL@%
                IF setNum > 0 THEN%@NL@%
                    MenuSetState VIEWTITLE, 2, 1%@NL@%
                END IF%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: PrintError%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Prints error messages on the screen in an Alert box.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: text$ - error message%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB PrintError (text$)%@NL@%
%@NL@%
    textLen = LEN(text$) + 2%@NL@%
    lefCol = ((80 - textLen) / 2) - 1%@NL@%
    a$ = "| " + text$%@NL@%
    junk = Alert(4, a$, 8, lefCol, 12, textLen + lefCol, "", "", "")%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Func Name: SaveChart%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Performs both the "Save" and "Save AS" operations from%@AE@%%@NL@%
%@AB@%'              the "File" menu title.  If "Save As" was chosen or if%@AE@%%@NL@%
%@AB@%'              "Save" was chosen and no save file has been previously%@AE@%%@NL@%
%@AB@%'              specified, it prompts the user for a new file in%@AE@%%@NL@%
%@AB@%'              which to save the current chart.  Also returns the status of%@AE@%%@NL@%
%@AB@%'              save operation for use in other routines%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: fileName$ - name of previously specified save file (may be nil)%@AE@%%@NL@%
%@AB@%'            saveAsFlag - flag for invoking the "Save As" operation.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION SaveChart% (FileName$, saveAsFlag)%@NL@%
SHARED Cat$(), catLen AS INTEGER%@NL@%
SHARED setLen() AS INTEGER, setName$(), setVal!()%@NL@%
SHARED screenMode AS INTEGER%@NL@%
%@NL@%
ON LOCAL ERROR GOTO SaveError                   ' handle file errors%@NL@%
%@NL@%
%@AB@%    ' get new file name if necessary%@AE@%%@NL@%
    IF FileName$ = "" OR saveAsFlag THEN%@NL@%
        fileNum% = GetSaveFile(FileName$)%@NL@%
%@AB@%    ' otherwise just open the file%@AE@%%@NL@%
    ELSE%@NL@%
        fileNum% = FREEFILE%@NL@%
        OPEN FileName$ FOR OUTPUT AS fileNum%%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' quit save if cancel chosen above or error occurred during open.%@AE@%%@NL@%
    IF fileNum% = 0 THEN%@NL@%
        SaveChart% = CANCEL                     ' return status%@NL@%
        EXIT FUNCTION%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' save category data%@AE@%%@NL@%
    IF catLen > 0 THEN%@NL@%
        PRINT #fileNum%, "C"%@NL@%
        PRINT #fileNum%, catLen%@NL@%
%@NL@%
        FOR i% = 1 TO catLen%@NL@%
            PRINT #fileNum%, Cat$(i%)%@NL@%
        NEXT i%%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' save value data%@AE@%%@NL@%
    IF setNum > 0 THEN%@NL@%
        FOR j% = 1 TO setNum%@NL@%
            PRINT #fileNum%, "V"%@NL@%
            PRINT #fileNum%, setName$(j%)%@NL@%
            PRINT #fileNum%, setLen(j%)%@NL@%
%@NL@%
            FOR i% = 1 TO setLen(j%)%@NL@%
                PRINT #fileNum%, setVal!(i%, j%)%@NL@%
            NEXT i%%@NL@%
        NEXT j%%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' save titles%@AE@%%@NL@%
    PRINT #fileNum%, "T"%@NL@%
    PRINT #fileNum%, CEnv.MainTitle.title%@NL@%
    PRINT #fileNum%, CEnv.SubTitle.title%@NL@%
    PRINT #fileNum%, CEnv.XAxis.AxisTitle.title%@NL@%
    PRINT #fileNum%, CEnv.YAxis.AxisTitle.title%@NL@%
%@NL@%
%@AB@%    'save chart settings%@AE@%%@NL@%
    PRINT #fileNum%, "S"%@NL@%
    PRINT #fileNum%, screenMode%@NL@%
%@NL@%
    PRINT #fileNum%, CEnv.ChartType, CEnv.ChartStyle, CEnv.DataFont%@NL@%
%@NL@%
    PRINT #fileNum%, CEnv.ChartWindow.X1, CEnv.ChartWindow.Y1, CEnv.ChartWindow.X2, CEnv.ChartWindow.Y2%@NL@%
    PRINT #fileNum%, CEnv.ChartWindow.Background, CEnv.ChartWindow.border, CEnv.ChartWindow.BorderStyle, CEnv.ChartWindow.BorderColor%@NL@%
    PRINT #fileNum%, CEnv.DataWindow.X1, CEnv.DataWindow.Y1, CEnv.DataWindow.X2, CEnv.DataWindow.Y2%@NL@%
    PRINT #fileNum%, CEnv.DataWindow.Background, CEnv.DataWindow.border, CEnv.DataWindow.BorderStyle, CEnv.DataWindow.BorderColor%@NL@%
%@NL@%
    PRINT #fileNum%, CEnv.MainTitle.TitleFont, CEnv.MainTitle.TitleColor, CEnv.MainTitle.Justify%@NL@%
    PRINT #fileNum%, CEnv.SubTitle.TitleFont, CEnv.SubTitle.TitleColor, CEnv.SubTitle.Justify%@NL@%
%@NL@%
    PRINT #fileNum%, CEnv.XAxis.Grid, CEnv.XAxis.GridStyle, CEnv.XAxis.AxisColor, CEnv.XAxis.Labeled%@NL@%
    PRINT #fileNum%, CEnv.XAxis.AxisTitle.TitleFont, CEnv.XAxis.AxisTitle.TitleColor, CEnv.XAxis.AxisTitle.Justify%@NL@%
    PRINT #fileNum%, CEnv.XAxis.RangeType, CEnv.XAxis.LogBase, CEnv.XAxis.AutoScale, CEnv.XAxis.ScaleMin%@NL@%
    PRINT #fileNum%, CEnv.XAxis.ScaleMax, CEnv.XAxis.ScaleFactor, CEnv.XAxis.TicFont, CEnv.XAxis.TicInterval, CEnv.XAxis.TicFormat, CEnv.XAxis.TicDecimals%@NL@%
    PRINT #fileNum%, CEnv.XAxis.ScaleTitle.title%@NL@%
    PRINT #fileNum%, CEnv.XAxis.ScaleTitle.TitleFont, CEnv.XAxis.ScaleTitle.TitleColor, CEnv.XAxis.ScaleTitle.Justify%@NL@%
%@NL@%
    PRINT #fileNum%, CEnv.YAxis.Grid, CEnv.YAxis.GridStyle, CEnv.YAxis.AxisColor, CEnv.YAxis.Labeled%@NL@%
    PRINT #fileNum%, CEnv.YAxis.AxisTitle.TitleFont, CEnv.YAxis.AxisTitle.TitleColor, CEnv.YAxis.AxisTitle.Justify%@NL@%
    PRINT #fileNum%, CEnv.YAxis.RangeType, CEnv.YAxis.LogBase, CEnv.YAxis.AutoScale, CEnv.YAxis.ScaleMin%@NL@%
    PRINT #fileNum%, CEnv.YAxis.ScaleMax, CEnv.YAxis.ScaleFactor, CEnv.YAxis.TicFont, CEnv.YAxis.TicInterval, CEnv.YAxis.TicFormat, CEnv.YAxis.TicDecimals%@NL@%
    PRINT #fileNum%, CEnv.YAxis.ScaleTitle.title%@NL@%
    PRINT #fileNum%, CEnv.YAxis.ScaleTitle.TitleFont, CEnv.YAxis.ScaleTitle.TitleColor, CEnv.YAxis.ScaleTitle.Justify%@NL@%
%@NL@%
    PRINT #fileNum%, CEnv.Legend.Legend, CEnv.Legend.Place, CEnv.Legend.TextColor, CEnv.Legend.TextFont, CEnv.Legend.AutoSize%@NL@%
    PRINT #fileNum%, CEnv.Legend.LegendWindow.X1, CEnv.Legend.LegendWindow.Y1, CEnv.Legend.LegendWindow.X2, CEnv.Legend.LegendWindow.Y2%@NL@%
    PRINT #fileNum%, CEnv.Legend.LegendWindow.Background, CEnv.Legend.LegendWindow.border, CEnv.Legend.LegendWindow.BorderStyle, CEnv.Legend.LegendWindow.BorderColor%@NL@%
%@NL@%
    CLOSE fileNum%%@NL@%
%@NL@%
    SaveChart% = OK                             ' return status%@NL@%
%@NL@%
    chartChanged = FALSE                        ' reset global change flag%@NL@%
%@NL@%
    EXIT FUNCTION%@NL@%
%@NL@%
%@AB@%' local error handler%@AE@%%@NL@%
SaveError:%@NL@%
      SaveChart% = CANCEL                       ' return cancel status%@NL@%
      CLOSE fileNum%%@NL@%
%@NL@%
      ShowError ERR                             ' display error message%@NL@%
%@NL@%
      EXIT FUNCTION                             ' exit on error%@NL@%
RESUME NEXT%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ShowError%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Displays an appropriate error message for the given error%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: errorNum - error number%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ShowError (errorNum)%@NL@%
      SELECT CASE errorNum%@NL@%
        CASE 6:                                 ' overflow%@NL@%
            PrintError "Overflow occurred."%@NL@%
        CASE 14:                                ' out of space%@NL@%
            PrintError "Out of string space.  Please restart."%@NL@%
        CASE 53:                                ' file not found%@NL@%
            PrintError "File not found."%@NL@%
        CASE 62:                                ' input past end of file%@NL@%
            PrintError "Invalid file format. Can't continue loading."%@NL@%
        CASE 64:                                ' bad file name%@NL@%
            PrintError "Invalid file name."%@NL@%
        CASE 68:                                ' device unavailable%@NL@%
            PrintError "Selected device unavailable."%@NL@%
        CASE 71:                                ' disk not ready%@NL@%
            PrintError "Disk not ready."%@NL@%
        CASE 75:                                ' path access error%@NL@%
            PrintError "Invalid path."%@NL@%
        CASE 76:                                ' path not found%@NL@%
            PrintError "Path not found."%@NL@%
        CASE ELSE                               ' catch all%@NL@%
            PrintError "BASIC error #" + LTRIM$(STR$(ERR)) + " occurred."%@NL@%
     END SELECT%@NL@%
%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Sub Name: ViewData%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Description: Displays the current chart data and allows the user to%@AE@%%@NL@%
%@AB@%'              modify, delete or add to that data.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Arguments: none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ViewData%@NL@%
SHARED setVal!(), setLen()  AS INTEGER, setName$()%@NL@%
SHARED Cat$(), catLen AS INTEGER%@NL@%
SHARED GloEdit() AS EditFieldType%@NL@%
%@NL@%
%@AB@%    ' temporary data storage that allows user to cancel all changes and%@AE@%%@NL@%
%@AB@%    ' restore original data%@AE@%%@NL@%
    DIM tsetVal$(1 TO 15, 1 TO 15), tCat$(1 TO 15), tsetName$(1 TO 15)%@NL@%
    DIM tsetNum AS INTEGER%@NL@%
    DIM tsetLen(1 TO 15) AS INTEGER%@NL@%
    DIM tcatLen  AS INTEGER%@NL@%
%@NL@%
    ON LOCAL ERROR GOTO ViewDatError%@NL@%
%@NL@%
%@AB@%    ' fill out temp data%@AE@%%@NL@%
    FOR i = 1 TO cMaxSets%@NL@%
        tsetName$(i) = setName$(i)%@NL@%
        tCat$(i) = Cat$(i)%@NL@%
        tsetLen(i) = setLen(i)%@NL@%
        FOR j = 1 TO tsetLen(i)%@NL@%
            tsetVal$(j, i) = LTRIM$(STR$(setVal!(j, i)))%@NL@%
        NEXT j%@NL@%
        FOR j = tsetLen(i) + 1 TO cMaxValues%@NL@%
            tsetVal$(j, i) = ""%@NL@%
        NEXT j%@NL@%
    NEXT i%@NL@%
    tsetNum = setNum%@NL@%
    tcatLen = catLen%@NL@%
%@NL@%
%@AB@%    ' set up window%@AE@%%@NL@%
    winRow = 4%@NL@%
    winCol = 8%@NL@%
    WindowOpen 1, winRow, winCol, 23, 74, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 2, "Chart Data"%@NL@%
    WindowLocate 1, 2%@NL@%
    WindowPrint 2, "Series Name:"%@NL@%
    WindowBox 2, 2, 18, 24%@NL@%
    WindowLocate 1, 26%@NL@%
    WindowPrint 2, "Categories:"%@NL@%
    WindowBox 2, 26, 18, 48%@NL@%
    WindowLocate 1, 50%@NL@%
    WindowPrint 2, "Values:"%@NL@%
    WindowBox 2, 50, 18, 66%@NL@%
    WindowLine 19%@NL@%
%@NL@%
%@AB@%    ' display chart data%@AE@%%@NL@%
    FOR i = 1 TO 15%@NL@%
        IF i < 10 THEN%@NL@%
            a$ = " "%@NL@%
        ELSE%@NL@%
            a$ = ""%@NL@%
        END IF%@NL@%
        a$ = a$ + LTRIM$(STR$(i)) + ". "%@NL@%
        WindowLocate i + 2, 3%@NL@%
        WindowPrint 2, a$ + tsetName$(i)%@NL@%
        WindowLocate i + 2, 27%@NL@%
        WindowPrint 2, a$ + tCat$(i)%@NL@%
        WindowLocate i + 2, 51%@NL@%
        WindowPrint 2, a$ + MID$(tsetVal$(i, 1), 1, 10)%@NL@%
    NEXT i%@NL@%
%@AB@%    ' highlight first set name%@AE@%%@NL@%
    EditFieldOpen 1, tsetName$(1), 3, 7, 7, 0, 17, 16%@NL@%
%@NL@%
    IF tsetNum < cMaxSets THEN tsetNum = tsetNum + 1%@NL@%
    IF tcatLen < cMaxValues THEN tcatLen = tcatLen + 1%@NL@%
    IF tsetLen(1) < cMaxValues THEN tsetLen(1) = tsetLen(1) + 1%@NL@%
%@NL@%
%@AB@%    ' area buttons%@AE@%%@NL@%
    ButtonOpen 1, 1, "", 3, 3, 17, 23, 4%@NL@%
    ButtonOpen 2, 1, "", 3, 27, 17, 47, 4%@NL@%
    ButtonOpen 3, 1, "", 3, 51, 17, 65, 4%@NL@%
%@NL@%
%@AB@%    ' command buttons%@AE@%%@NL@%
    ButtonOpen 4, 1, "OK", 20, 15, 0, 0, 1%@NL@%
    ButtonOpen 5, 1, "Cancel", 20, 45, 0, 0, 1%@NL@%
%@NL@%
%@AB@%    ' start with cursor in first set name edit field%@AE@%%@NL@%
    currButton = 1%@NL@%
    prevButton = 1%@NL@%
    currRow = 1%@NL@%
    currEditField = 1%@NL@%
    currCat = 1%@NL@%
    currVal = 1%@NL@%
    currSet = 1%@NL@%
%@NL@%
    IF CEnv.ChartType = cPie THEN%@NL@%
        a$ = " Pie chart information||"%@NL@%
        a$ = a$ + " Only data values from the first series are plotted in pie charts. |"%@NL@%
        a$ = a$ + " Data values from the second series are used in determining whether|"%@NL@%
        a$ = a$ + " or not pie pieces are exploded.  Non-zero values in this series   |"%@NL@%
        a$ = a$ + " will cause corresponding pie pieces to be exploded.  All other    |"%@NL@%
        a$ = a$ + "  series will be ignored.                                           "%@NL@%
%@NL@%
        junk = Alert(4, a$, 8, 7, 17, 75, "", "", "")%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' window control loop%@AE@%%@NL@%
    finished = FALSE%@NL@%
    WHILE NOT finished%@NL@%
        WindowDo currButton, currEditField%@NL@%
%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1                                      ' button pressed%@NL@%
                currButton = Dialog(1)%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1, 2, 3%@NL@%
                        currRow = Dialog(17)%@NL@%
                    CASE 4, 5%@NL@%
                        finished = TRUE%@NL@%
                END SELECT%@NL@%
                GOSUB UpdateEdit%@NL@%
            CASE 2                                      ' Edit Field%@NL@%
                currEditField = Dialog(2)%@NL@%
            CASE 6, 11                                  ' enter, down arrow%@NL@%
                IF currButton > 3 AND Dialog(0) = 6 THEN%@NL@%
                    finished = TRUE%@NL@%
                ELSE%@NL@%
                    currRow = currRow + 1%@NL@%
                    GOSUB UpdateEdit%@NL@%
                END IF%@NL@%
            CASE 7                                      'tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1:%@NL@%
                        currButton = 2%@NL@%
                        currRow = currCat%@NL@%
                        GOSUB UpdateEdit%@NL@%
                    CASE 2:%@NL@%
                        currButton = 3%@NL@%
                        currRow = currVal%@NL@%
                        GOSUB UpdateEdit%@NL@%
                    CASE 3:%@NL@%
                        currButton = 4%@NL@%
                        ButtonToggle 4%@NL@%
                        GOSUB UpdateEdit%@NL@%
                    CASE 4:%@NL@%
                        currButton = 5%@NL@%
                        ButtonToggle 4%@NL@%
                        ButtonToggle 5%@NL@%
                    CASE 5:%@NL@%
                        currButton = 1%@NL@%
                        currRow = currSet%@NL@%
                        ButtonToggle 5%@NL@%
                        GOSUB UpdateEdit%@NL@%
                END SELECT%@NL@%
            CASE 8                                      'back tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1:%@NL@%
                        currButton = 5%@NL@%
                        ButtonToggle 5%@NL@%
                        GOSUB UpdateEdit%@NL@%
                    CASE 2:%@NL@%
                        currButton = 1%@NL@%
                        currRow = currSet%@NL@%
                        GOSUB UpdateEdit%@NL@%
                    CASE 3:%@NL@%
                        currButton = 2%@NL@%
                        currRow = currCat%@NL@%
                        GOSUB UpdateEdit%@NL@%
                    CASE 4:%@NL@%
                        currButton = 3%@NL@%
                        currRow = currVal%@NL@%
                        ButtonToggle 4%@NL@%
                        GOSUB UpdateEdit%@NL@%
                    CASE 5:%@NL@%
                        currButton = 4%@NL@%
                        ButtonToggle 5%@NL@%
                        ButtonToggle 4%@NL@%
                END SELECT%@NL@%
            CASE 9                                      'escape%@NL@%
                currButton = 5%@NL@%
                finished = TRUE%@NL@%
            CASE 10:                                    'up arrow%@NL@%
                IF currButton < 4 THEN%@NL@%
                    currRow = currRow - 1%@NL@%
                    GOSUB UpdateEdit%@NL@%
                END IF%@NL@%
            CASE 14                                     'space%@NL@%
                IF currButton > 3 THEN finished = TRUE%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' give delete warning before exit%@AE@%%@NL@%
        IF finished = TRUE AND currButton = 4 THEN%@NL@%
            temp = FALSE%@NL@%
            FOR i = 1 TO tsetNum%@NL@%
                IF tsetName$(i) = "" AND tsetLen(i) > 0 AND NOT (tsetLen(i) = 1 AND tsetVal$(1, i) = "") THEN temp = TRUE%@NL@%
            NEXT i%@NL@%
            IF temp = TRUE THEN%@NL@%
                a$ = "|"%@NL@%
                a$ = a$ + "Series without names will be deleted upon exit."%@NL@%
                reply = Alert(4, a$, 8, 10, 12, 70, "OK", "Cancel", "")%@NL@%
                IF reply <> 1 THEN finished = FALSE%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' finished so save new data%@AE@%%@NL@%
    IF currButton = 4 THEN%@NL@%
        ClearData                                       ' clear existing data%@NL@%
%@NL@%
%@AB@%        ' copy temporary values to permanent locations%@AE@%%@NL@%
        indx = 0%@NL@%
        FOR i = 1 TO tsetNum%@NL@%
            IF tsetName$(i) <> "" THEN%@NL@%
                indx = indx + 1%@NL@%
                setName$(indx) = tsetName$(i)              ' store set names%@NL@%
                indx2 = 0%@NL@%
                FOR j = 1 TO tsetLen(i)%@NL@%
                    IF tsetVal$(j, i) <> "" THEN%@NL@%
                        indx2 = indx2 + 1%@NL@%
                        setVal!(indx2, i) = VAL(tsetVal$(j, i))   ' store set values%@NL@%
                    END IF%@NL@%
                NEXT j%@NL@%
                setLen(indx) = indx2                     ' get set lengths%@NL@%
            END IF%@NL@%
        NEXT i%@NL@%
        setNum = indx%@NL@%
%@NL@%
%@AB@%        ' clear leftover names and set lengths%@AE@%%@NL@%
        FOR i = setNum + 1 TO cMaxSets%@NL@%
            setName$(i) = ""%@NL@%
            setLen(i) = 0%@NL@%
        NEXT i%@NL@%
%@NL@%
%@AB@%        ' store category names%@AE@%%@NL@%
        FOR i = 1 TO tcatLen%@NL@%
            Cat$(i) = tCat$(i)%@NL@%
        NEXT i%@NL@%
        catLen = tcatLen%@NL@%
%@NL@%
        FOR i = tcatLen TO 1 STEP -1%@NL@%
            IF Cat$(i) = "" THEN%@NL@%
                catLen = catLen - 1%@NL@%
                IF catLen <= 0 THEN EXIT FOR%@NL@%
            ELSE%@NL@%
                EXIT FOR%@NL@%
            END IF%@NL@%
        NEXT i%@NL@%
%@NL@%
%@AB@%        ' clear leftover category names%@AE@%%@NL@%
        FOR i = catLen + 1 TO cMaxValues%@NL@%
            Cat$(i) = ""%@NL@%
        NEXT i%@NL@%
%@NL@%
%@AB@%        ' update active menu titles based on current data%@AE@%%@NL@%
        IF setNum > 0 THEN%@NL@%
            MenuSetState VIEWTITLE, 2, 1%@NL@%
            chartChanged = TRUE%@NL@%
        ELSE%@NL@%
            MenuSetState VIEWTITLE, 2, 0%@NL@%
        END IF%@NL@%
    END IF%@NL@%
    WindowClose 1%@NL@%
%@NL@%
%@NL@%
    EXIT SUB%@NL@%
%@NL@%
ViewDatError:%@NL@%
    PrintError "BASIC error #" + LTRIM$(STR$(ERR)) + " occurred."%@NL@%
RESUME NEXT%@NL@%
%@NL@%
%@AB@%' redraws the value edit column so it displays the current set's values%@AE@%%@NL@%
ResetVal:%@NL@%
%@AB@%    ' display new values%@AE@%%@NL@%
    FOR i = 1 TO cMaxValues%@NL@%
        WindowLocate i + 2, 55%@NL@%
        WindowPrint 2, tsetVal$(i, currSet) + STRING$(10 - LEN(tsetVal$(i, currSet)), " ")%@NL@%
    NEXT i%@NL@%
%@NL@%
    IF tsetLen(currSet) = 0 THEN%@NL@%
        tsetLen(currSet) = tsetLen(currSet) + 1%@NL@%
    ELSEIF tsetLen(currSet) < cMaxValues AND tsetVal$(tsetLen(currSet), currSet) <> "" THEN%@NL@%
        tsetLen(currSet) = tsetLen(currSet) + 1%@NL@%
    END IF%@NL@%
%@NL@%
    currVal = 31%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
UpdateEdit:%@NL@%
    IF prevButton < 4 THEN GOSUB ClosePrevEdit%@NL@%
%@NL@%
    SELECT CASE currButton%@NL@%
        CASE 1:%@NL@%
            IF currRow <= 0 THEN%@NL@%
                currRow = tsetNum%@NL@%
            ELSEIF currRow > 15 THEN%@NL@%
                currRow = 1%@NL@%
            ELSEIF currRow = tsetNum + 1 AND tsetName$(tsetNum) <> "" THEN%@NL@%
                tsetNum = tsetNum + 1%@NL@%
            ELSEIF currRow > tsetNum THEN%@NL@%
                currRow = 1%@NL@%
            END IF%@NL@%
            WindowColor 0, 7%@NL@%
            WindowLocate currSet + 2, 7%@NL@%
            WindowPrint 2, tsetName$(currSet) + STRING$(17 - LEN(tsetName$(currSet)), " ")%@NL@%
%@NL@%
            FG = 7%@NL@%
            BG = 0%@NL@%
            vislen = 17%@NL@%
            totlen = 16%@NL@%
            currSet = currRow%@NL@%
            currCol = 7%@NL@%
            temp$ = tsetName$(currSet)%@NL@%
            IF prevButton = 1 THEN GOSUB ResetVal%@NL@%
        CASE 2:%@NL@%
            IF currRow <= 0 THEN%@NL@%
                currRow = tcatLen%@NL@%
            ELSEIF currRow > 15 THEN%@NL@%
                currRow = 1%@NL@%
            ELSEIF currRow > tcatLen THEN%@NL@%
                tcatLen = currRow%@NL@%
            END IF%@NL@%
            FG = 0%@NL@%
            BG = 7%@NL@%
            vislen = 17%@NL@%
            totlen = 16%@NL@%
            currCat = currRow%@NL@%
            currCol = 31%@NL@%
            temp$ = tCat$(currCat)%@NL@%
        CASE 3:%@NL@%
            IF currRow <= 0 THEN%@NL@%
                currRow = tsetLen(currSet)%@NL@%
            ELSEIF currRow > 15 THEN%@NL@%
                currRow = 1%@NL@%
            ELSEIF currRow = tsetLen(currSet) + 1 AND tsetVal$(tsetLen(currSet), currSet) <> "" AND currRow THEN%@NL@%
                tsetLen(currSet) = tsetLen(currSet) + 1%@NL@%
            ELSEIF currRow > tsetLen(currSet) THEN%@NL@%
                currRow = 1%@NL@%
            END IF%@NL@%
            FG = 0%@NL@%
            BG = 7%@NL@%
            vislen = 11%@NL@%
            totlen = 20%@NL@%
            currVal = currRow%@NL@%
            currCol = 55%@NL@%
            temp$ = tsetVal$(currVal, currSet)%@NL@%
        CASE ELSE%@NL@%
            prevButton = currButton%@NL@%
            RETURN%@NL@%
    END SELECT%@NL@%
%@NL@%
    EditFieldOpen 1, temp$, currRow + 2, currCol, FG, BG, vislen, totlen%@NL@%
    currEditField = 1%@NL@%
    prevButton = currButton%@NL@%
RETURN%@NL@%
%@NL@%
ClosePrevEdit:%@NL@%
    temp$ = RTRIM$(EditFieldInquire$(1))%@NL@%
    EditFieldClose 1%@NL@%
    currEditField = 0%@NL@%
    IF prevButton = 1 THEN%@NL@%
        WindowColor 7, 0%@NL@%
    ELSE%@NL@%
        WindowColor 0, 7%@NL@%
    END IF%@NL@%
%@NL@%
    SELECT CASE prevButton%@NL@%
        CASE 1:%@NL@%
            tsetName$(currSet) = temp$%@NL@%
            temp$ = temp$ + STRING$(17 - LEN(temp$), " ")%@NL@%
            editRow = currSet + 2%@NL@%
            editCol = 7%@NL@%
        CASE 2:%@NL@%
            tCat$(currCat) = temp$%@NL@%
            editRow = currCat + 2%@NL@%
            editCol = 31%@NL@%
        CASE 3:%@NL@%
            tsetVal$(currVal, currSet) = temp$%@NL@%
            tval# = VAL(temp$)%@NL@%
            IF tval# = 0 AND temp$ <> "0" AND LEN(RTRIM$(temp$)) <> 0 THEN%@NL@%
                PrintError "Warning: Non-numeric values will default to zero for charting."%@NL@%
            END IF%@NL@%
            temp$ = MID$(temp$, 1, 10)%@NL@%
            editRow = currVal + 2%@NL@%
            editCol = 55%@NL@%
    END SELECT%@NL@%
%@NL@%
    WindowLocate editRow, editCol%@NL@%
    WindowPrint 2, temp$%@NL@%
    WindowColor 0, 7%@NL@%
RETURN%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%COLORS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\COLORS.BAS%@AE@%%@NL@%
%@NL@%
SCREEN 1%@NL@%
%@NL@%
Esc$ = CHR$(27)%@NL@%
%@AB@%' Draw three boxes and paint the interior%@AE@%%@NL@%
%@AB@%' of each box with a different color:%@AE@%%@NL@%
FOR ColorVal = 1 TO 3%@NL@%
   LINE (X, Y) -STEP(60, 50), ColorVal, BF%@NL@%
   X = X + 61%@NL@%
   Y = Y + 51%@NL@%
NEXT ColorVal%@NL@%
%@NL@%
LOCATE 21, 1%@NL@%
PRINT "Press ESC to end."%@NL@%
PRINT "Press any other key to continue."%@NL@%
%@NL@%
%@AB@%' Restrict additional printed output to the 23rd line:%@AE@%%@NL@%
VIEW PRINT 23 TO 23%@NL@%
DO%@NL@%
   PaletteVal = 1%@NL@%
   DO%@NL@%
%@NL@%
%@AB@%      ' PaletteVal is either 1 or 0:%@AE@%%@NL@%
      PaletteVal = 1 - PaletteVal%@NL@%
%@NL@%
%@AB@%      ' Set the background color and choose the palette:%@AE@%%@NL@%
      COLOR BackGroundVal, PaletteVal%@NL@%
      PRINT "Background ="; BackGroundVal;%@NL@%
      PRINT "Palette ="; PaletteVal;%@NL@%
%@NL@%
      Pause$ = INPUT$(1)        ' Wait for a keystroke.%@NL@%
      PRINT%@NL@%
%@AB@%   ' Exit the loop if both palettes have been shown,%@AE@%%@NL@%
%@AB@%   ' or if the user pressed the ESC key:%@AE@%%@NL@%
   LOOP UNTIL PaletteVal = 1 OR Pause$ = Esc$%@NL@%
%@NL@%
   BackGroundVal = BackGroundVal + 1%@NL@%
%@NL@%
%@AB@%' Exit this loop if all 16 background colors have%@AE@%%@NL@%
%@AB@%' been shown, or if the user pressed the ESC key:%@AE@%%@NL@%
LOOP UNTIL BackGroundVal > 15 OR Pause$ = Esc$%@NL@%
%@NL@%
SCREEN 0                     ' Restore text mode and%@NL@%
WIDTH 80                     ' 80-column screen width.%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CRLF.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\CRLF.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z             ' Default variable type is integer.%@NL@%
%@NL@%
%@AB@%' The Backup$ FUNCTION makes a backup file with%@AE@%%@NL@%
%@AB@%' the same base as FileName$ plus a .BAK extension:%@AE@%%@NL@%
DECLARE FUNCTION Backup$ (FileName$)%@NL@%
%@NL@%
%@AB@%' Initialize symbolic constants and variables:%@AE@%%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE%@NL@%
%@NL@%
CarReturn$ = CHR$(13)%@NL@%
LineFeed$ = CHR$(10)%@NL@%
%@NL@%
DO%@NL@%
   CLS%@NL@%
%@NL@%
%@AB@%   ' Input the name of the file to change:%@AE@%%@NL@%
   INPUT "Which file do you want to convert"; OutFile$%@NL@%
%@NL@%
   InFile$ = Backup$(OutFile$)  ' Get backup file's name.%@NL@%
%@NL@%
   ON ERROR GOTO ErrorHandler   ' Turn on error trapping.%@NL@%
%@NL@%
   NAME OutFile$ AS InFile$     ' Rename input file as%@NL@%
%@AB@%                                ' backup file.%@AE@%%@NL@%
%@NL@%
   ON ERROR GOTO 0              ' Turn off error trapping.%@NL@%
%@NL@%
%@AB@%   ' Open backup file for input and old file for output:%@AE@%%@NL@%
   OPEN InFile$ FOR INPUT AS #1%@NL@%
   OPEN OutFile$ FOR OUTPUT AS #2%@NL@%
%@NL@%
%@AB@%   ' The PrevCarReturn variable is a flag set to TRUE%@AE@%%@NL@%
%@AB@%   ' whenever the program reads a carriage-return character:%@AE@%%@NL@%
   PrevCarReturn = FALSE%@NL@%
%@AB@%' Read from input file until reaching end of file:%@AE@%%@NL@%
   DO UNTIL EOF(1)%@NL@%
%@NL@%
%@AB@%      ' This is not end of file, so read a character:%@AE@%%@NL@%
      FileChar$ = INPUT$(1, #1)%@NL@%
%@NL@%
      SELECT CASE FileChar$%@NL@%
%@NL@%
         CASE CarReturn$        ' The character is a CR.%@NL@%
%@NL@%
%@AB@%            ' If the previous character was also a%@AE@%%@NL@%
%@AB@%            ' CR, put a LF before the character:%@AE@%%@NL@%
            IF PrevCarReturn THEN%@NL@%
                FileChar$ = LineFeed$ + FileChar$%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%            ' In any case, set the PrevCarReturn%@AE@%%@NL@%
%@AB@%            ' variable to TRUE:%@AE@%%@NL@%
            PrevCarReturn = TRUE%@NL@%
%@NL@%
         CASE LineFeed$         ' The character is a LF.%@NL@%
%@NL@%
%@AB@%            ' If the previous character was not a%@AE@%%@NL@%
%@AB@%            ' CR, put a CR before the character:%@AE@%%@NL@%
            IF NOT PrevCarReturn THEN%@NL@%
                FileChar$ = CarReturn$ + FileChar$%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%            ' Set the PrevCarReturn variable to FALSE:%@AE@%%@NL@%
            PrevCarReturn = FALSE%@NL@%
%@NL@%
         CASE ELSE              ' Neither a CR nor a LF.%@NL@%
%@NL@%
%@AB@%            ' If the previous character was a CR,%@AE@%%@NL@%
%@AB@%            ' set the PrevCarReturn variable to FALSE%@AE@%%@NL@%
%@AB@%            ' and put a LF before the current character:%@AE@%%@NL@%
            IF PrevCarReturn THEN%@NL@%
               PrevCarReturn = FALSE%@NL@%
               FileChar$ = LineFeed$ + FileChar$%@NL@%
            END IF%@NL@%
%@NL@%
      END SELECT%@NL@%
%@NL@%
%@AB@%      ' Write the character(s) to the new file:%@AE@%%@NL@%
      PRINT #2, FileChar$;%@NL@%
   LOOP%@NL@%
%@NL@%
%@AB@%   ' Write a LF if the last character in the file was a CR:%@AE@%%@NL@%
   IF PrevCarReturn THEN PRINT #2, LineFeed$;%@NL@%
CLOSE                        ' Close both files.%@NL@%
   PRINT "Another file (Y/N)?"  ' Prompt to continue.%@NL@%
%@NL@%
%@AB@%   ' Change the input to uppercase (capital letter):%@AE@%%@NL@%
   More$ = UCASE$(INPUT$(1))%@NL@%
%@NL@%
%@AB@%' Continue the program if the user entered a "Y" or a "Y":%@AE@%%@NL@%
LOOP WHILE More$ = "Y"%@NL@%
END%@NL@%
%@NL@%
ErrorHandler:           ' Error-handling routine%@NL@%
   CONST NOFILE = 53, FILEEXISTS = 58%@NL@%
%@NL@%
%@AB@%   ' The ERR function returns the error code for last error:%@AE@%%@NL@%
   SELECT CASE ERR%@NL@%
      CASE NOFILE       ' Program couldn't find file%@NL@%
%@AB@%                        ' with input name.%@AE@%%@NL@%
%@NL@%
         PRINT "No such file in current directory."%@NL@%
         INPUT "Enter new name: ", OutFile$%@NL@%
         InFile$ = Backup$(OutFile$)%@NL@%
         RESUME%@NL@%
      CASE FILEEXISTS   ' There is already a file named%@NL@%
%@AB@%                        ' <filename>.BAK in this directory:%@AE@%%@NL@%
%@AB@%                        ' remove it, then continue.%@AE@%%@NL@%
         KILL InFile$%@NL@%
         RESUME%@NL@%
      CASE ELSE         ' An unanticipated error occurred:%@NL@%
%@AB@%                        ' stop the program.%@AE@%%@NL@%
         ON ERROR GOTO 0%@NL@%
   END SELECT%@NL@%
%@NL@%
%@AB@%' ======================== BACKUP$ =========================%@AE@%%@NL@%
%@AB@%'   This procedure returns a file name that consists of the%@AE@%%@NL@%
%@AB@%'   base name of the input file (everything before the ".")%@AE@%%@NL@%
%@AB@%'   plus the extension ".BAK"%@AE@%%@NL@%
%@AB@%' ==========================================================%@AE@%%@NL@%
%@NL@%
FUNCTION Backup$ (FileName$) STATIC%@NL@%
%@NL@%
%@AB@%   ' Look for a period:%@AE@%%@NL@%
   Extension = INSTR(FileName$, ".")%@NL@%
%@NL@%
%@AB@%   ' If there is a period, add .BAK to the base:%@AE@%%@NL@%
   IF Extension > 0 THEN%@NL@%
      Backup$ = LEFT$(FileName$, Extension - 1) + ".BAK"%@NL@%
%@AB@%   ' Otherwise, add .BAK to the whole name:%@AE@%%@NL@%
   ELSE%@NL@%
      Backup$ = FileName$ + ".BAK"%@NL@%
   END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CUBE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\CUBE.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' Define the macro string used to draw the cube%@AE@%%@NL@%
%@AB@%' and paint its sides:%@AE@%%@NL@%
One$ =        "BR30 BU25 C1 R54 U45 L54 D45 BE20 P1,1        G20 C2 G20"%@NL@%
Two$ =        "R54 E20 L54 BD5 P2,2 U5 C4 G20 U45 E20 D45 BL5 P4,4"%@NL@%
Plot$ = One$ + Two$%@NL@%
%@NL@%
APage% = 1        ' Initialize values for the active and visual%@NL@%
VPage% = 0        ' pages as well as the angle of rotation.%@NL@%
Angle% = 0%@NL@%
%@NL@%
DO%@NL@%
   SCREEN 7, , APage%, VPage% ' Draw to the active page%@NL@%
%@AB@%                                 ' while showing the visual page.%@AE@%%@NL@%
%@NL@%
   CLS 1                      ' Clear the active page.%@NL@%
%@NL@%
%@AB@%   ' Rotate the        cube "Angle%" degrees:%@AE@%%@NL@%
   DRAW        "TA" + STR$(Angle%) + Plot$%@NL@%
%@NL@%
%@AB@%   ' Angle% is some multiple of        15 degrees:%@AE@%%@NL@%
   Angle% = (Angle% + 15) MOD 360%@NL@%
%@NL@%
%@AB@%   ' Drawing is complete, so make the cube visible in its%@AE@%%@NL@%
%@AB@%   ' new position by switching the active and visual pages:%@AE@%%@NL@%
   SWAP        APage%,        VPage%%@NL@%
%@NL@%
LOOP WHILE INKEY$ = ""              ' A keystroke ends the program.%@NL@%
%@NL@%
END%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EDPAT.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\EDPAT.BAS%@AE@%%@NL@%
%@NL@%
DECLARE SUB DrawPattern ()%@NL@%
DECLARE SUB EditPattern ()%@NL@%
DECLARE SUB Initialize ()%@NL@%
DECLARE SUB ShowPattern (OK$)%@NL@%
%@NL@%
DIM Bit%(0 TO 7), Pattern$, PatternSize%%@NL@%
DO%@NL@%
   Initialize%@NL@%
   EditPattern%@NL@%
   ShowPattern OK$%@NL@%
LOOP WHILE OK$ = "Y"%@NL@%
%@NL@%
END%@NL@%
%@AB@%' ======================= DRAWPATTERN ====================%@AE@%%@NL@%
%@AB@%'  Draws a patterned rectangle on the right side of screen%@AE@%%@NL@%
%@AB@%' ========================================================%@AE@%%@NL@%
%@NL@%
%@AB@%' ======================= EDITPATTERN =====================%@AE@%%@NL@%
%@AB@%'                  Edits a tile-byte pattern%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%' ======================= INITIALIZE ======================%@AE@%%@NL@%
%@AB@%'             Sets up starting pattern and screen%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
%@AB@%' ======================== SHOWPATTERN ====================%@AE@%%@NL@%
%@AB@%'   Prints the CHR$ values used by PAINT to make pattern%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
SUB DrawPattern STATIC%@NL@%
SHARED Pattern$%@NL@%
   VIEW (320, 24)-(622, 160), 0, 1  ' Set view to rectangle.%@NL@%
   PAINT (1, 1), Pattern$       ' Use PAINT to fill it.%@NL@%
   VIEW                 ' Set view to full screen.%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB EditPattern STATIC%@NL@%
SHARED Pattern$, Bit%(), PatternSize%%@NL@%
%@NL@%
   ByteNum% = 1     ' Starting position.%@NL@%
   BitNum% = 7%@NL@%
   Null$ = CHR$(0)  ' CHR$(0) is the first byte of the%@NL@%
%@AB@%                                        ' two-byte string returned when a%@AE@%%@NL@%
%@AB@%                                        ' direction key such as UP or DOWN is%@AE@%%@NL@%
%@AB@%                                        ' pressed.%@AE@%%@NL@%
   DO%@NL@%
%@NL@%
%@AB@%          ' Calculate starting location on screen of this bit:%@AE@%%@NL@%
          X% = ((7 - BitNum%) * 16) + 80%@NL@%
          Y% = (ByteNum% + 2) * 8%@NL@%
%@NL@%
%@AB@%          ' Wait for a key press (flash cursor each 3/10 second):%@AE@%%@NL@%
          State% = 0%@NL@%
          RefTime = 0%@NL@%
          DO%@NL@%
%@NL@%
%@AB@%         ' Check timer and switch cursor state if 3/10 second:%@AE@%%@NL@%
         IF ABS(TIMER - RefTime) > .3 THEN%@NL@%
                RefTime = TIMER%@NL@%
                State% = 1 - State%%@NL@%
%@NL@%
%@AB@%                ' Turn the  border of bit on and off:%@AE@%%@NL@%
                LINE (X% - 1, Y% - 1)-STEP(15, 8), State%, B%@NL@%
         END IF%@NL@%
%@NL@%
         Check$ = INKEY$    ' Check for keystroke.%@NL@%
%@NL@%
          LOOP WHILE Check$ = ""    ' Loop until a key is pressed.%@NL@%
%@NL@%
%@AB@%          ' Erase cursor:%@AE@%%@NL@%
          LINE (X% - 1, Y% - 1)-STEP(15, 8), 0, B%@NL@%
%@NL@%
          SELECT CASE Check$    ' Respond to keystroke.%@NL@%
%@NL@%
          CASE CHR$(27)     ' ESC key pressed:%@NL@%
                 EXIT SUB       ' exit this subprogram.%@NL@%
          CASE CHR$(32)     ' SPACEBAR pressed:%@NL@%
%@AB@%                                                ' reset state of bit.%@AE@%%@NL@%
%@NL@%
%@AB@%                 ' Invert bit in pattern string:%@AE@%%@NL@%
                 CurrentByte% = ASC(MID$(Pattern$, ByteNum%, 1))%@NL@%
                 CurrentByte% = CurrentByte% XOR Bit%(BitNum%)%@NL@%
                 MID$(Pattern$, ByteNum%) = CHR$(CurrentByte%)%@NL@%
%@NL@%
%@AB@%                 ' Redraw bit on screen:%@AE@%%@NL@%
                 IF (CurrentByte% AND Bit%(BitNum%)) <> 0 THEN%@NL@%
                         CurrentColor% = 1%@NL@%
                 ELSE%@NL@%
                         CurrentColor% = 0%@NL@%
                 END IF%@NL@%
                 LINE (X% + 1, Y% + 1)-STEP(11, 4), CurrentColor%, BF%@NL@%
%@NL@%
          CASE CHR$(13)      ' ENTER key pressed: draw%@NL@%
                 DrawPattern         ' pattern in box on right.%@NL@%
%@NL@%
          CASE Null$ + CHR$(75)  ' LEFT key: move cursor left.%@NL@%
%@NL@%
                 BitNum% = BitNum% + 1%@NL@%
                 IF BitNum% > 7 THEN BitNum% = 0%@NL@%
%@NL@%
          CASE Null$ + CHR$(77)  ' RIGHT key: move cursor right.%@NL@%
%@NL@%
                 BitNum% = BitNum% - 1%@NL@%
                 IF BitNum% < 0 THEN BitNum% = 7%@NL@%
%@NL@%
          CASE Null$ + CHR$(72)  ' UP key: move cursor up.%@NL@%
%@NL@%
                 ByteNum% = ByteNum% - 1%@NL@%
                 IF ByteNum% < 1 THEN ByteNum% = PatternSize%%@NL@%
%@NL@%
          CASE Null$ + CHR$(80)  ' DOWN key: move cursor down.%@NL@%
%@NL@%
                 ByteNum% = ByteNum% + 1%@NL@%
                 IF ByteNum% > PatternSize% THEN ByteNum% = 1%@NL@%
          END SELECT%@NL@%
   LOOP%@NL@%
END SUB%@NL@%
%@NL@%
SUB Initialize STATIC%@NL@%
SHARED Pattern$, Bit%(), PatternSize%%@NL@%
%@NL@%
%@AB@%   ' Set up an array holding bits in positions 0 to 7:%@AE@%%@NL@%
   FOR I% = 0 TO 7%@NL@%
          Bit%(I%) = 2 ^ I%%@NL@%
   NEXT I%%@NL@%
%@NL@%
   CLS%@NL@%
%@NL@%
%@AB@%   ' Input the pattern size (in number of bytes):%@AE@%%@NL@%
   LOCATE 5, 5%@NL@%
   PRINT "Enter pattern size (1-16 rows):";%@NL@%
   DO%@NL@%
          LOCATE 5, 38%@NL@%
          PRINT "         ";%@NL@%
          LOCATE 5, 38%@NL@%
          INPUT "", PatternSize%%@NL@%
   LOOP WHILE PatternSize% < 1 OR PatternSize% > 16%@NL@%
%@NL@%
%@AB@%   ' Set initial pattern to all bits set:%@AE@%%@NL@%
   Pattern$ = STRING$(PatternSize%, 255)%@NL@%
%@NL@%
   SCREEN 2     ' 640 x 200 monochrome graphics mode%@NL@%
%@NL@%
%@AB@%   ' Draw dividing lines:%@AE@%%@NL@%
   LINE (0, 10)-(635, 10), 1%@NL@%
   LINE (300, 0)-(300, 199)%@NL@%
   LINE (302, 0)-(302, 199)%@NL@%
%@NL@%
%@AB@%   ' Print titles:%@AE@%%@NL@%
   LOCATE 1, 13: PRINT "Pattern Bytes"%@NL@%
   LOCATE 1, 53: PRINT "Pattern View"%@NL@%
%@NL@%
%@NL@%
%@AB@%' Draw editing screen for pattern:%@AE@%%@NL@%
   FOR I% = 1 TO PatternSize%%@NL@%
%@NL@%
%@AB@%          ' Print label on left of each line:%@AE@%%@NL@%
          LOCATE I% + 3, 8%@NL@%
          PRINT USING "##:"; I%%@NL@%
%@NL@%
%@AB@%          ' Draw "bit" boxes:%@AE@%%@NL@%
          X% = 80%@NL@%
          Y% = (I% + 2) * 8%@NL@%
          FOR J% = 1 TO 8%@NL@%
                LINE (X%, Y%)-STEP(13, 6), 1, BF%@NL@%
                X% = X% + 16%@NL@%
          NEXT J%%@NL@%
   NEXT I%%@NL@%
%@NL@%
   DrawPattern      ' Draw  "Pattern View" box.%@NL@%
%@NL@%
   LOCATE 21, 1%@NL@%
   PRINT "DIRECTION keys........Move cursor"%@NL@%
   PRINT "SPACEBAR............Changes point"%@NL@%
   PRINT "ENTER............Displays pattern"%@NL@%
   PRINT "ESC.........................Quits";%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB ShowPattern (OK$) STATIC%@NL@%
SHARED Pattern$, PatternSize%%@NL@%
%@NL@%
%@AB@%   ' Return screen to 80-column text mode:%@AE@%%@NL@%
   SCREEN 0, 0%@NL@%
   WIDTH 80%@NL@%
%@NL@%
   PRINT "The following characters make up your pattern:"%@NL@%
   PRINT%@NL@%
%@NL@%
%@AB@%   ' Print out the value for each pattern byte:%@AE@%%@NL@%
   FOR I% = 1 TO PatternSize%%@NL@%
          PatternByte% = ASC(MID$(Pattern$, I%, 1))%@NL@%
          PRINT "CHR$("; LTRIM$(STR$(PatternByte%)); ")"%@NL@%
   NEXT I%%@NL@%
   PRINT%@NL@%
   LOCATE , , 1%@NL@%
   PRINT "New pattern? ";%@NL@%
   OK$ = UCASE$(INPUT$(1))%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ENTAB.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\ENTAB.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' ENTAB.BAS%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Replace runs of spaces in a file with tabs.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
DECLARE SUB SetTabPos ()%@NL@%
DECLARE SUB StripCommand (CLine$)%@NL@%
%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
DECLARE FUNCTION ThisIsATab (Column AS INTEGER)%@NL@%
%@NL@%
CONST MAXLINE = 255%@NL@%
CONST TABSPACE = 8%@NL@%
CONST NO = 0, YES = NOT NO%@NL@%
%@NL@%
DIM SHARED TabStops(MAXLINE) AS INTEGER%@NL@%
%@NL@%
StripCommand (COMMAND$)%@NL@%
%@NL@%
%@AB@%' Set the tab positions (uses the global array TabStops).%@AE@%%@NL@%
SetTabPos%@NL@%
%@NL@%
LastColumn = 1%@NL@%
%@NL@%
DO%@NL@%
%@NL@%
   CurrentColumn = LastColumn%@NL@%
%@NL@%
%@AB@%' Replace a run of blanks with a tab when you reach a tab%@AE@%%@NL@%
%@AB@%' column. CurrentColumn is the current column read.%@AE@%%@NL@%
%@AB@%' LastColumn is the last column that was printed.%@AE@%%@NL@%
   DO%@NL@%
      C$ = INPUT$(1,#1)%@NL@%
      IF C$ <> " " AND C$ <> CHR$(9) THEN EXIT DO%@NL@%
      CurrentColumn = CurrentColumn + 1%@NL@%
      IF C$=CHR$(9) OR ThisIsATab(CurrentColumn) THEN%@NL@%
%@AB@%         ' Go to a tab column if we have a tab and this%@AE@%%@NL@%
%@AB@%         ' is not a tab column.%@AE@%%@NL@%
         DO WHILE NOT ThisIsATab(CurrentColumn)%@NL@%
            CurrentColumn=CurrentColumn+1%@NL@%
         LOOP%@NL@%
         PRINT #2, CHR$(9);%@NL@%
         LastColumn = CurrentColumn%@NL@%
      END IF%@NL@%
   LOOP%@NL@%
%@NL@%
%@AB@%' Print out any blanks left over.%@AE@%%@NL@%
   DO WHILE LastColumn < CurrentColumn%@NL@%
      PRINT #2, " ";%@NL@%
      LastColumn = LastColumn + 1%@NL@%
   LOOP%@NL@%
%@NL@%
%@AB@%' Print the non-blank character.%@AE@%%@NL@%
   PRINT #2, C$;%@NL@%
%@NL@%
%@AB@%' Reset the column position if this is the end of a line.%@AE@%%@NL@%
   IF C$ = CHR$(10) THEN%@NL@%
      LastColumn = 1%@NL@%
   ELSE%@NL@%
      LastColumn = LastColumn + 1%@NL@%
   END IF%@NL@%
%@NL@%
LOOP UNTIL EOF(1)%@NL@%
CLOSE #1, #2%@NL@%
END%@NL@%
%@NL@%
%@AB@%'------------------SUB SetTabPos-------------------------%@AE@%%@NL@%
%@AB@%' Set the tab positions in the array TabStops.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB SetTabPos STATIC%@NL@%
   FOR I = 1 TO 255%@NL@%
      TabStops(I) = ((I MOD TABSPACE) = 1)%@NL@%
   NEXT I%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'------------------SUB StripCommand----------------------%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB StripCommand (CommandLine$) STATIC%@NL@%
   IF CommandLine$ = "" THEN%@NL@%
      INPUT "File to entab:   ", InFileName$%@NL@%
      INPUT "Store entabbed file in:   ", OutFileName$%@NL@%
   ELSE%@NL@%
      SpacePos = INSTR(CommandLine$, " ")%@NL@%
      IF SpacePos > 0 THEN%@NL@%
         InFileName$ = LEFT$(CommandLine$, SpacePos - 1)%@NL@%
         OutFileName$ = LTRIM$(MID$(CommandLine$, SpacePos))%@NL@%
      ELSE%@NL@%
         InFileName$ = CommandLine$%@NL@%
         INPUT "Store entabbed file in:   ", OutFileName$%@NL@%
      END IF%@NL@%
   END IF%@NL@%
   OPEN InFileName$ FOR INPUT AS #1%@NL@%
   OPEN OutFileName$ FOR OUTPUT AS #2%@NL@%
END SUB%@NL@%
%@AB@%'---------------FUNCTION ThisIsATab----------------------%@AE@%%@NL@%
%@AB@%' Answer the question, "Is this a tab position?"%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION ThisIsATab (LastColumn AS INTEGER) STATIC%@NL@%
   IF LastColumn > MAXLINE THEN%@NL@%
      ThisIsATab = YES%@NL@%
   ELSE%@NL@%
      ThisIsATab = TabStops(LastColumn)%@NL@%
   END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FLPT.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\FLPT.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' FLPT.BAS%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Displays how a given real value is stored in memory.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
DEFINT A-Z%@NL@%
DECLARE FUNCTION MHex$ (X AS INTEGER)%@NL@%
DIM Bytes(3)%@NL@%
%@NL@%
CLS%@NL@%
PRINT "Internal format of IEEE number (all values in hexadecimal)"%@NL@%
PRINT%@NL@%
DO%@NL@%
%@NL@%
%@AB@%   ' Get the value and calculate the address of the variable.%@AE@%%@NL@%
   INPUT "Enter a real number (or END to quit): ", A$%@NL@%
   IF UCASE$(A$) = "END" THEN EXIT DO%@NL@%
   RealValue! = VAL(A$)%@NL@%
%@AB@%   ' Convert the real value to a long without changing any of%@AE@%%@NL@%
%@AB@%   ' the bits.%@AE@%%@NL@%
   AsLong& = CVL(MKS$(RealValue!))%@NL@%
%@AB@%   ' Make a string of hex digits, and add leading zeroes.%@AE@%%@NL@%
   Strout$ = HEX$(AsLong&)%@NL@%
   Strout$ = STRING$(8 - LEN(Strout$), "0") + Strout$%@NL@%
%@NL@%
%@AB@%   ' Save the sign bit, and then eliminate it so it doesn't%@AE@%%@NL@%
%@AB@%   ' affect breaking out the bytes%@AE@%%@NL@%
   SignBit& = AsLong& AND &H80000000%@NL@%
   AsLong& = AsLong& AND &H7FFFFFFF%@NL@%
%@AB@%   ' Split the real value into four separate bytes%@AE@%%@NL@%
%@AB@%   ' --the AND removes unwanted bits; dividing by 256 shifts%@AE@%%@NL@%
%@AB@%   ' the value right 8 bit positions.%@AE@%%@NL@%
   FOR I = 0 TO 3%@NL@%
      Bytes(I) = AsLong& AND &HFF&%@NL@%
      AsLong& = AsLong& \ 256&%@NL@%
   NEXT I%@NL@%
%@AB@%   ' Display how the value appears in memory.%@AE@%%@NL@%
   PRINT%@NL@%
   PRINT "Bytes in Memory"%@NL@%
   PRINT " High    Low"%@NL@%
   FOR I = 1 TO 7 STEP 2%@NL@%
      PRINT " "; MID$(Strout$, I, 2);%@NL@%
   NEXT I%@NL@%
   PRINT : PRINT%@NL@%
%@NL@%
%@AB@%   ' Set the value displayed for the sign bit.%@AE@%%@NL@%
   Sign = ABS(SignBit& <> 0)%@NL@%
%@NL@%
%@AB@%   ' The exponent is the right seven bits of byte 3 and the%@AE@%%@NL@%
%@AB@%   ' leftmost bit of byte 2. Multiplying by 2 shifts left and%@AE@%%@NL@%
%@AB@%   ' makes room for the additional bit from byte 2.%@AE@%%@NL@%
   Exponent = Bytes(3) * 2 + Bytes(2) \ 128%@NL@%
%@NL@%
%@AB@%   ' The first part of the mantissa is the right seven bits%@AE@%%@NL@%
%@AB@%   ' of byte 2.  The OR operation makes sure the implied bit%@AE@%%@NL@%
%@AB@%   ' is displayed by setting the leftmost bit.%@AE@%%@NL@%
   Mant1 = (Bytes(2) OR &H80)%@NL@%
   PRINT " Bit 31    Bits 30-23  Implied Bit & Bits 22-0"%@NL@%
   PRINT "Sign Bit  Exponent Bits     Mantissa Bits"%@NL@%
   PRINT TAB(4); Sign; TAB(17); MHex$(Exponent);%@NL@%
   PRINT TAB(33); MHex$(Mant1); MHex$(Bytes(1)); MHex$(Bytes(0))%@NL@%
   PRINT%@NL@%
%@NL@%
LOOP%@NL@%
%@NL@%
%@AB@%' MHex$ makes sure we always get two hex digits.%@AE@%%@NL@%
FUNCTION MHex$ (X AS INTEGER) STATIC%@NL@%
   D$ = HEX$(X)%@NL@%
   IF LEN(D$) < 2 THEN D$ = "0" + D$%@NL@%
   MHex$ = D$%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FONTASM.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\FONTASM.ASM%@AE@%%@NL@%
%@NL@%
.MODEL        MEDIUM%@NL@%
%@AB@%;************************************************************%@AE@%%@NL@%
%@AB@%; FONTASM.ASM - assembly lang routines for Font Toolbox%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;  Copyright (C) 1989 Microsoft Corporation, All Rights Reserved%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   fl_SetBltDir    - Sets bltchar direction increments%@AE@%%@NL@%
%@AB@%;   fl_SetBltColor  - Sets color parameter for bltchar%@AE@%%@NL@%
%@AB@%;   fl_SetBltParams - Sets font related parameters for bltchar%@AE@%%@NL@%
%@AB@%;   fl_BltChar            - Character output routine%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   fl_MovMem            - Moves memory%@AE@%%@NL@%
%@AB@%;   fl_ansi            - Maps IBM chars to Windows ANSI;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;************************************************************%@AE@%%@NL@%
%@NL@%
%@AB@%; BltChar data block%@AE@%%@NL@%
.DATA%@NL@%
%@NL@%
%@AB@%; These are set by fl_SetBltParams%@AE@%%@NL@%
HdrLen            dw            0            %@AB@%;length of windows font file header%@AE@%%@NL@%
CharHeight  dw            0            %@AB@%;character height%@AE@%%@NL@%
FirstChar   dw            0            %@AB@%;first character defined in font%@AE@%%@NL@%
LastChar    dw            0            %@AB@%;last character defined in font%@AE@%%@NL@%
DefaultChar dw            0            %@AB@%;default character to use%@AE@%%@NL@%
%@NL@%
%@AB@%; This is set by fl_SetBltColor%@AE@%%@NL@%
CharColor   dw            0            %@AB@%;current character color%@AE@%%@NL@%
%@NL@%
%@AB@%; These are set by fl_SetBltDir%@AE@%%@NL@%
XPixInc     dw            1            %@AB@%;x inc for each pixel in character bitmap%@AE@%%@NL@%
YPixInc     dw            0            %@AB@%;y inc for each pixel in character bitmap%@AE@%%@NL@%
XRowInc     dw            0            %@AB@%;x inc for each row in character bitmap%@AE@%%@NL@%
YRowInc     dw            1            %@AB@%;y inc for each row in character bitmap%@AE@%%@NL@%
XColInc     dw            8            %@AB@%;x inc for each column (8 bits) in char bitmap%@AE@%%@NL@%
YColInc     dw            0            %@AB@%;y inc for each column (8 bits) in char bitmap%@AE@%%@NL@%
%@NL@%
.CODE%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
%@AB@%; fl_SetBltDir - Sets pixel, row, and column step values for bltchar%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   BASIC CALL:%@AE@%%@NL@%
%@AB@%;        fl.SetBltDir XPixInc%, YPixInc%, XRowInc%, YRowInc%%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   Comments:%@AE@%%@NL@%
%@AB@%;        When bltchar is blt-ing a bitmap to allow the different%@AE@%%@NL@%
%@AB@%;        directions to be output it uses preset counter increments%@AE@%%@NL@%
%@AB@%;        for moving a pixel, to the next row, and to the next column%@AE@%%@NL@%
%@AB@%;        of the bitmap. The pixel and row increments are input to this%@AE@%%@NL@%
%@AB@%;        routine. The column increments are calculates as 8 times the%@AE@%%@NL@%
%@AB@%;        pixel increment.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
%@NL@%
%@AB@%; Parameters%@AE@%%@NL@%
pXPixInc    equ     WORD PTR [bp+12]%@NL@%
pYPixInc    equ     WORD PTR [bp+10]%@NL@%
pXRowInc    equ     WORD PTR [bp+8]%@NL@%
pYRowInc    equ     WORD PTR [bp+6]%@NL@%
%@NL@%
            PUBLIC  fl_SetBltDir%@NL@%
fl_SetBltDir PROC%@NL@%
%@NL@%
            push    bp                %@AB@%;Entry%@AE@%%@NL@%
            mov     bp,sp%@NL@%
%@NL@%
            mov     ax,pXRowInc %@AB@%;Save input parameters%@AE@%%@NL@%
            mov     XRowInc,ax%@NL@%
            mov     ax,pYRowInc%@NL@%
            mov     YRowInc,ax%@NL@%
%@NL@%
            mov     ax,pXPixInc%@NL@%
            mov     XPixInc,ax%@NL@%
            mov     cl,3%@NL@%
            shl     ax,cl%@NL@%
            mov     XColInc,ax        %@AB@%;Column increment = Pix Inc * 8%@AE@%%@NL@%
%@NL@%
            mov     ax,pYPixInc%@NL@%
            mov     YPixInc,ax%@NL@%
            mov     cl,3%@NL@%
            shl     ax,cl%@NL@%
            mov     YColInc,ax        %@AB@%;Column increment = Pix Inc * 8%@AE@%%@NL@%
%@NL@%
            pop     bp                %@AB@%;Exit%@AE@%%@NL@%
            ret     8%@NL@%
fl_SetBltDir ENDP%@NL@%
%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
%@AB@%; fl_SetBltColor - Sets the color of blt-ed characters%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   BASIC CALL:%@AE@%%@NL@%
%@AB@%;        fl.SetBltColor color%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
%@NL@%
%@AB@%; Parameters%@AE@%%@NL@%
pColor            EQU     WORD PTR [bp+6]%@NL@%
%@NL@%
            PUBLIC  fl_SetBltColor%@NL@%
fl_SetBltColor PROC%@NL@%
%@NL@%
            push    bp                    %@AB@%;Entry%@AE@%%@NL@%
            mov     bp,sp%@NL@%
%@NL@%
            mov     ax,pColor            %@AB@%;Save color in data block%@AE@%%@NL@%
            mov     CharColor,ax%@NL@%
%@NL@%
            pop     bp                    %@AB@%;Exit%@AE@%%@NL@%
            ret     2%@NL@%
%@NL@%
fl_SetBltColor        ENDP%@NL@%
%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
%@AB@%; fl_SetBltParams - Sets font-related params for bltchar%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   BASIC CALL:%@AE@%%@NL@%
%@AB@%;        fl.SetBltParams HdrLen%, CharHgt%, FirstChar%, LastChar%, DefChar%%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
%@NL@%
%@AB@%; Parameters%@AE@%%@NL@%
pHdrLen     equ     WORD PTR [bp+14]%@NL@%
pCharHgt    equ     WORD PTR [bp+12]%@NL@%
pFirstChar  equ     WORD PTR [bp+10]%@NL@%
pLastChar   equ     WORD PTR [bp+8]%@NL@%
pDefChar    equ     WORD PTR [bp+6]%@NL@%
%@NL@%
            PUBLIC  fl_SetBltParams%@NL@%
fl_SetBltParams PROC%@NL@%
%@NL@%
            push    bp                    %@AB@%;Entry%@AE@%%@NL@%
            mov     bp,sp%@NL@%
%@NL@%
            mov     ax,pHdrLen%@NL@%
            mov     HdrLen,ax%@NL@%
%@NL@%
            mov     ax,pCharHgt%@NL@%
            mov     CharHeight,ax%@NL@%
%@NL@%
            mov     ax,pFirstChar%@NL@%
            mov     FirstChar,ax%@NL@%
%@NL@%
            mov     ax,pLastChar%@NL@%
            mov     LastChar,ax%@NL@%
%@NL@%
            mov     ax,pDefChar%@NL@%
            mov     DefaultChar,ax%@NL@%
%@NL@%
            pop     bp                    %@AB@%;Exit%@AE@%%@NL@%
            ret     10%@NL@%
%@NL@%
fl_SetBltParams ENDP%@NL@%
%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
%@AB@%; fl_BltChar - Outputs a character's bitmap to the screen%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   BASIC CALL:%@AE@%%@NL@%
%@AB@%;        fl.BltChar FontAddr(far), Char%, X%, Y%%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
%@NL@%
%@AB@%; BASIC Procedures%@AE@%%@NL@%
EXTRN            B$N1I2:far, B$PSTC:far%@NL@%
%@NL@%
%@AB@%; Parameters%@AE@%%@NL@%
pFASeg            equ     WORD PTR [bp+14]%@NL@%
pFAOffset   equ     WORD PTR [bp+12]%@NL@%
pChar            equ     WORD PTR [bp+10]%@NL@%
pX            equ     WORD PTR [bp+8]%@NL@%
pY            equ     WORD PTR [bp+6]%@NL@%
%@NL@%
%@AB@%; Local Variables%@AE@%%@NL@%
.RowX            equ     WORD PTR [bp-2]%@NL@%
.RowY            equ     WORD PTR [bp-4]%@NL@%
.CharWid    equ     WORD PTR [bp-6]%@NL@%
.ColWid     equ     WORD PTR [bp-8]%@NL@%
%@NL@%
            PUBLIC  fl_BltChar%@NL@%
fl_BltChar  PROC%@NL@%
%@NL@%
            push    bp                    %@AB@%;Entry%@AE@%%@NL@%
            mov     bp,sp%@NL@%
            sub     sp,8            %@AB@%;Make room for local variables%@AE@%%@NL@%
            push    di%@NL@%
            push    si%@NL@%
%@NL@%
            %@AB@%;Normalize font address (make offset as small as possible)%@AE@%%@NL@%
            mov     ax,pFAOffset%@NL@%
            mov     bx,pFASeg%@NL@%
            push    ax%@NL@%
            mov     cl,4%@NL@%
            shr     ax,cl            %@AB@%;offset = offset div 16%@AE@%%@NL@%
            add     bx,ax            %@AB@%;seg = seg + offset%@AE@%%@NL@%
            pop     ax%@NL@%
            and     ax,0Fh            %@AB@%;offset = original offset mod 16%@AE@%%@NL@%
            mov     si,ax%@NL@%
            mov     es,bx%@NL@%
%@NL@%
            %@AB@%;Calculate character number%@AE@%%@NL@%
            mov     bx,pChar%@NL@%
            cmp     bx,LastChar%@NL@%
            ja            usedefchar            %@AB@%;Char is > last char, use default%@AE@%%@NL@%
            sub     bx,FirstChar%@NL@%
            jnc     getsize            %@AB@%;Char is > first char, is OK%@AE@%%@NL@%
usedefchar: mov     bx,DefaultChar%@NL@%
%@NL@%
            %@AB@%;Get character width from character table in font%@AE@%%@NL@%
getsize:    shl     bx,1%@NL@%
            shl     bx,1            %@AB@%;char = char * 4%@AE@%%@NL@%
            add     bx,si            %@AB@%;offset into char table%@AE@%%@NL@%
            mov     cx,es:[bx]            %@AB@%;cx = character width%@AE@%%@NL@%
            mov     .CharWid,cx%@NL@%
%@NL@%
            %@AB@%;Calculate character bitmap address%@AE@%%@NL@%
            inc     bx                    %@AB@%;move to next two bytes in char table%@AE@%%@NL@%
            inc     bx%@NL@%
            mov     cx,es:[bx]%@NL@%
            add     si,cx            %@AB@%;add bitmap offset into font index%@AE@%%@NL@%
            sub     si,HdrLen            %@AB@%;subtract length of header%@AE@%%@NL@%
            dec     si                    %@AB@%;decrement for use in output algorithm%@AE@%%@NL@%
%@NL@%
            %@AB@%;Blt character%@AE@%%@NL@%
            mov     cx,pX            %@AB@%;cx = x coord%@AE@%%@NL@%
            mov     dx,pY            %@AB@%;dx = y coord%@AE@%%@NL@%
%@NL@%
            mov     bx,.CharWid%@NL@%
%@NL@%
colloop:    mov     .RowX,cx            %@AB@%;save coordinates of this row%@AE@%%@NL@%
            mov     .RowY,dx%@NL@%
            push    bx                    %@AB@%;save remaining bits in character%@AE@%%@NL@%
            cmp     bx,8            %@AB@%;limit to 8 for this column%@AE@%%@NL@%
            jle     colloop2%@NL@%
            mov     bx,8%@NL@%
%@NL@%
colloop2:   mov     .ColWid,bx            %@AB@%;save width of this column for other rows%@AE@%%@NL@%
            mov     ax,CharHeight   %@AB@%;counter for number of rows%@AE@%%@NL@%
%@NL@%
rowloop:    push    ax%@NL@%
            inc     si                    %@AB@%;increment bitmap pointer%@AE@%%@NL@%
            mov     al,es:[si]            %@AB@%;get byte from bitmap%@AE@%%@NL@%
%@NL@%
pixloop:    shl     al,1            %@AB@%;check next bit (from left to right)%@AE@%%@NL@%
            jnc     nextpixel            %@AB@%;skip this pixel%@AE@%%@NL@%
%@NL@%
            push    ax                    %@AB@%;save registers%@AE@%%@NL@%
            push    bx%@NL@%
            push    cx%@NL@%
            push    dx%@NL@%
            push    es%@NL@%
            push    si%@NL@%
%@NL@%
            mov     ax,CharColor    %@AB@%;set up params for pset call%@AE@%%@NL@%
            push    ax                    %@AB@%;color%@AE@%%@NL@%
            push    cx                    %@AB@%;x-coordinate%@AE@%%@NL@%
            push    dx                    %@AB@%;y-coordinate%@AE@%%@NL@%
            call    B$N1I2            %@AB@%;set graphics cursor location%@AE@%%@NL@%
            call    B$PSTC            %@AB@%;call PSET%@AE@%%@NL@%
%@NL@%
            pop     si                    %@AB@%;restore registers%@AE@%%@NL@%
            pop     es%@NL@%
            pop     dx%@NL@%
            pop     cx%@NL@%
            pop     bx%@NL@%
            pop     ax%@NL@%
%@NL@%
nextpixel:  jz            nextrow            %@AB@%;skip remaining zero bits%@AE@%%@NL@%
            add     cx,XPixInc            %@AB@%;increment x and y coordinates%@AE@%%@NL@%
            add     dx,YPixInc%@NL@%
            dec     bx                    %@AB@%;check for end of byte%@AE@%%@NL@%
            jnz     pixloop            %@AB@%;go for another pixel%@AE@%%@NL@%
%@NL@%
nextrow:    mov     cx,.RowX            %@AB@%;retrieve the start coord of this row%@AE@%%@NL@%
            mov     dx,.RowY%@NL@%
            add     cx,XRowInc            %@AB@%;increment counters for next row%@AE@%%@NL@%
            add     dx,YRowInc%@NL@%
            mov     .RowX,cx            %@AB@%;save 'em back again%@AE@%%@NL@%
            mov     .RowY,dx%@NL@%
            mov     bx,.ColWid            %@AB@%;reset the column width%@AE@%%@NL@%
            pop     ax                    %@AB@%;check for the end of this column%@AE@%%@NL@%
            dec     ax%@NL@%
            jnz     rowloop            %@AB@%;repeat for another row%@AE@%%@NL@%
%@NL@%
nextcol:    mov     cx,pX            %@AB@%;retrieve the start coord of this column%@AE@%%@NL@%
            mov     dx,pY%@NL@%
            add     cx,XColInc            %@AB@%;increment coordinates for next column%@AE@%%@NL@%
            add     dx,YColInc%@NL@%
            mov     pX,cx            %@AB@%;save coordinates to use after next column%@AE@%%@NL@%
            mov     pY,dx%@NL@%
            pop     bx                    %@AB@%;check for end of the bitmap%@AE@%%@NL@%
            sub     bx,8%@NL@%
            ja            colloop            %@AB@%;repeat for another column%@AE@%%@NL@%
%@NL@%
            %@AB@%;Done%@AE@%%@NL@%
            mov     ax,.CharWid     %@AB@%;return value%@AE@%%@NL@%
%@NL@%
            pop     si                    %@AB@%;Exit%@AE@%%@NL@%
            pop     di%@NL@%
            mov     sp,bp%@NL@%
            pop     bp%@NL@%
            ret     10%@NL@%
fl_BltChar  ENDP%@NL@%
%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
%@AB@%; fl_MovMem - Moves memory bytes%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   BASIC CALL:%@AE@%%@NL@%
%@AB@%;        fl.MovMem source, dest, nbytes%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
            PUBLIC  fl_MovMem%@NL@%
fl_MovMem   PROC%@NL@%
            push    bp%@NL@%
            mov     bp,sp%@NL@%
            push    si%@NL@%
            push    ds%@NL@%
            push    di%@NL@%
%@NL@%
            les     di,[bp+12]%@NL@%
            lds     si,[bp+8]%@NL@%
            mov     cx,[bp+6]%@NL@%
            rep            movsb%@NL@%
%@NL@%
            pop     di%@NL@%
            pop     ds%@NL@%
            pop     si%@NL@%
            pop     bp%@NL@%
            ret     10%@NL@%
fl_MovMem   ENDP%@NL@%
%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
%@AB@%; fl_ansi - Converts IBM char to Windows ANSI mapping%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   BASIC CALL:%@AE@%%@NL@%
%@AB@%;        ansi_byte = fl_ansi (ibm_char%)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;********************************************************************%@AE@%%@NL@%
.CODE%@NL@%
            PUBLIC  fl_ansi%@NL@%
fl_ansi     PROC%@NL@%
            push    bp%@NL@%
            mov     bp,sp%@NL@%
%@NL@%
            xor     ax,ax            %@AB@%; zero ax%@AE@%%@NL@%
            mov     al,[bp+6]            %@AB@%; move input byte to ax%@AE@%%@NL@%
            mov     bx,ax            %@AB@%; copy byte to bx%@AE@%%@NL@%
            and     al,7FH            %@AB@%; mask off high bit%@AE@%%@NL@%
            test    bl,80H            %@AB@%; test bx to see it high bit set%@AE@%%@NL@%
            jz            fl_a_2            %@AB@%; if so then byte < 128, no translation%@AE@%%@NL@%
%@NL@%
            mov     bx,OFFSET _OemToAnsiTable%@NL@%
            xlat%@NL@%
%@NL@%
fl_a_2:     pop     bp%@NL@%
            ret     2%@NL@%
fl_ansi     ENDP%@NL@%
%@NL@%
%@NL@%
%@AB@%;***************************************************************************%@AE@%%@NL@%
%@AB@%;   USA OEM/ANSI translation tables.                                       *%@AE@%%@NL@%
%@AB@%;***************************************************************************%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
%@AB@%; This translation table is used by U.S.A. and some European countries.%@AE@%%@NL@%
%@AB@%; The original IBM extended character set is now addressed as Code Page 437.%@AE@%%@NL@%
%@AB@%; With DOS 3.3 or later, IBM introduced Code Page 850 as the preeminent%@AE@%%@NL@%
%@AB@%; multilingual character set.%@AE@%%@NL@%
%@NL@%
%@AB@%; this translates Oem codes >= 128 to ANSI.%@AE@%%@NL@%
%@AB@%; there are 128 entries.%@AE@%%@NL@%
%@NL@%
.DATA%@NL@%
_OemToAnsiTable  label   byte%@NL@%
%@NL@%
        db   0C7H     %@AB@%; 80h  C cedilla%@AE@%%@NL@%
        db   0FCh     %@AB@%; 81h  u umlaut%@AE@%%@NL@%
        db   0E9h     %@AB@%; 82h  e acute%@AE@%%@NL@%
        db   0E2h     %@AB@%; 83h  a circumflex%@AE@%%@NL@%
        db   0E4h     %@AB@%; 84h  a umlaut%@AE@%%@NL@%
        db   0E0h     %@AB@%; 85h  a grave%@AE@%%@NL@%
        db   0E5h     %@AB@%; 86h  a ring%@AE@%%@NL@%
        db   0E7h     %@AB@%; 87h  c cedilla%@AE@%%@NL@%
        db   0EAh     %@AB@%; 88h  e circumflex%@AE@%%@NL@%
        db   0EBh     %@AB@%; 89h  e umlaut%@AE@%%@NL@%
        db   0E8h     %@AB@%; 8Ah  e grave%@AE@%%@NL@%
        db   0EFh     %@AB@%; 8Bh  i umlaut%@AE@%%@NL@%
        db   0EEh     %@AB@%; 8Ch  i circumflex%@AE@%%@NL@%
        db   0ECh     %@AB@%; 8Dh  i grave%@AE@%%@NL@%
        db   0C4h     %@AB@%; 8Eh  A umlaut%@AE@%%@NL@%
        db   0C5h     %@AB@%; 8Fh  A ring%@AE@%%@NL@%
%@NL@%
        db   0C9h     %@AB@%; 90h  E acute%@AE@%%@NL@%
        db   0E6h     %@AB@%; 91h  ae%@AE@%%@NL@%
        db   0C6h     %@AB@%; 92h  AE%@AE@%%@NL@%
        db   0F4h     %@AB@%; 93h  o circumflex%@AE@%%@NL@%
        db   0F6h     %@AB@%; 94h  o umlaut%@AE@%%@NL@%
        db   0F2h     %@AB@%; 95h  o grave%@AE@%%@NL@%
        db   0FBh     %@AB@%; 96h  u circumflex%@AE@%%@NL@%
        db   0F9h     %@AB@%; 97h  u grave%@AE@%%@NL@%
        db   0FFh     %@AB@%; 98h  y umlaut%@AE@%%@NL@%
        db   0D6h     %@AB@%; 99h  O umlaut%@AE@%%@NL@%
        db   0DCh     %@AB@%; 9Ah  U umlaut%@AE@%%@NL@%
        db   0A2h     %@AB@%; 9Bh  cent%@AE@%%@NL@%
        db   0A3h     %@AB@%; 9Ch  british pound%@AE@%%@NL@%
        db   0A5h     %@AB@%; 9Dh  yen%@AE@%%@NL@%
        db   070h     %@AB@%; 9Eh  Pesetas%@AE@%%@NL@%
        db   066h     %@AB@%; 9Fh  florin (dutch)%@AE@%%@NL@%
%@NL@%
        db   0E1h     %@AB@%; A0h  a acute%@AE@%%@NL@%
        db   0EDh     %@AB@%; A1h  i acute%@AE@%%@NL@%
        db   0F3h     %@AB@%; A2h  o acute%@AE@%%@NL@%
        db   0FAh     %@AB@%; A3h  u acute%@AE@%%@NL@%
        db   0F1h     %@AB@%; A4h  n tilde%@AE@%%@NL@%
        db   0D1h     %@AB@%; A5h  N tilde%@AE@%%@NL@%
        db   0AAh     %@AB@%; A6h  a underlined superscript%@AE@%%@NL@%
        db   0BAh     %@AB@%; A7h  o underlined superscript%@AE@%%@NL@%
        db   0BFh     %@AB@%; A8h  inverted question mark%@AE@%%@NL@%
        db   05Fh     %@AB@%; A9h  left top corner%@AE@%%@NL@%
        db   0ACh     %@AB@%; AAh  right top corner%@AE@%%@NL@%
        db   0BDh     %@AB@%; ABh  1/2%@AE@%%@NL@%
        db   0BCh     %@AB@%; ACh  1/4%@AE@%%@NL@%
        db   0A1h     %@AB@%; ADh  inverted point%@AE@%%@NL@%
        db   0ABh     %@AB@%; AEh  <<%@AE@%%@NL@%
        db   0BBh     %@AB@%; AFh  >>%@AE@%%@NL@%
%@NL@%
        db   05Fh     %@AB@%; B0h  here begins semigraphic characters%@AE@%%@NL@%
        db   05Fh     %@AB@%; B1h%@AE@%%@NL@%
        db   05Fh     %@AB@%; B2h%@AE@%%@NL@%
        db   0A6h     %@AB@%; B3h  Vertical bar%@AE@%%@NL@%
        db   05Fh     %@AB@%; B4h%@AE@%%@NL@%
        db   05Fh     %@AB@%; B5h%@AE@%%@NL@%
        db   05Fh     %@AB@%; B6h%@AE@%%@NL@%
        db   05Fh     %@AB@%; B7h%@AE@%%@NL@%
        db   05Fh     %@AB@%; B8h%@AE@%%@NL@%
        db   05Fh     %@AB@%; B9h%@AE@%%@NL@%
        db   05Fh     %@AB@%; BAh%@AE@%%@NL@%
        db   05Fh     %@AB@%; BBh%@AE@%%@NL@%
        db   05Fh     %@AB@%; BCh%@AE@%%@NL@%
        db   05Fh     %@AB@%; BDh%@AE@%%@NL@%
        db   05Fh     %@AB@%; BEh%@AE@%%@NL@%
        db   05Fh     %@AB@%; BFh%@AE@%%@NL@%
%@NL@%
        db   05Fh     %@AB@%; C0h%@AE@%%@NL@%
        db   05Fh     %@AB@%; C1h%@AE@%%@NL@%
        db   05Fh     %@AB@%; C2h%@AE@%%@NL@%
        db   05Fh     %@AB@%; C3h%@AE@%%@NL@%
        db   05Fh     %@AB@%; C4h%@AE@%%@NL@%
        db   05Fh     %@AB@%; C5h%@AE@%%@NL@%
        db   05Fh     %@AB@%; C6h%@AE@%%@NL@%
        db   05Fh     %@AB@%; C7h%@AE@%%@NL@%
        db   05Fh     %@AB@%; C8h%@AE@%%@NL@%
        db   05Fh     %@AB@%; C9h%@AE@%%@NL@%
        db   05Fh     %@AB@%; CAh%@AE@%%@NL@%
        db   05Fh     %@AB@%; CBh%@AE@%%@NL@%
        db   05Fh     %@AB@%; CCh%@AE@%%@NL@%
        db   05Fh     %@AB@%; CDh%@AE@%%@NL@%
        db   05Fh     %@AB@%; CEh%@AE@%%@NL@%
        db   05Fh     %@AB@%; CFh%@AE@%%@NL@%
%@NL@%
        db   05Fh     %@AB@%; D0h%@AE@%%@NL@%
        db   05Fh     %@AB@%; D1h%@AE@%%@NL@%
        db   05Fh     %@AB@%; D2h%@AE@%%@NL@%
        db   05Fh     %@AB@%; D3h%@AE@%%@NL@%
        db   05Fh     %@AB@%; D4h%@AE@%%@NL@%
        db   05Fh     %@AB@%; D5h%@AE@%%@NL@%
        db   05Fh     %@AB@%; D6h%@AE@%%@NL@%
        db   05Fh     %@AB@%; D7h%@AE@%%@NL@%
        db   05Fh     %@AB@%; D8h%@AE@%%@NL@%
        db   05Fh     %@AB@%; D9h%@AE@%%@NL@%
        db   05Fh     %@AB@%; DAh%@AE@%%@NL@%
        db   05Fh     %@AB@%; DBh%@AE@%%@NL@%
        db   05Fh     %@AB@%; DCh%@AE@%%@NL@%
        db   05Fh     %@AB@%; DDh%@AE@%%@NL@%
        db   05Fh     %@AB@%; DEh%@AE@%%@NL@%
        db   05Fh     %@AB@%; DFh  end of semigraphic characters%@AE@%%@NL@%
%@NL@%
        db   05Fh     %@AB@%; E0h  alpha%@AE@%%@NL@%
        db   0DFh     %@AB@%; E1h  german sharp S or greek beta%@AE@%%@NL@%
        db   05Fh     %@AB@%; E2h  lambda%@AE@%%@NL@%
        db   0B6h     %@AB@%; E3h  pi%@AE@%%@NL@%
        db   05Fh     %@AB@%; E4h  sigma uc%@AE@%%@NL@%
        db   05Fh     %@AB@%; E5h  sigma lc%@AE@%%@NL@%
        db   0B5h     %@AB@%; E6h  mu%@AE@%%@NL@%
        db   05Fh     %@AB@%; E7h  tau%@AE@%%@NL@%
        db   05Fh     %@AB@%; E8h  phi uc%@AE@%%@NL@%
        db   05Fh     %@AB@%; E9h  theta%@AE@%%@NL@%
        db   05Fh     %@AB@%; EAh  omega%@AE@%%@NL@%
        db   05Fh     %@AB@%; EBh  delta%@AE@%%@NL@%
        db   05Fh     %@AB@%; ECh  infinite%@AE@%%@NL@%
        db   0D8h     %@AB@%; EDh  math empty set or phi lc%@AE@%%@NL@%
        db   05Fh     %@AB@%; EEh  math own sign%@AE@%%@NL@%
        db   05Fh     %@AB@%; EFh  math include sign%@AE@%%@NL@%
%@NL@%
        db   05Fh     %@AB@%; F0h  math equivalence sign%@AE@%%@NL@%
        db   0B1h     %@AB@%; F1h  + underlined%@AE@%%@NL@%
        db   05Fh     %@AB@%; F2h  greater equal%@AE@%%@NL@%
        db   05Fh     %@AB@%; F3h  less equal%@AE@%%@NL@%
        db   05Fh     %@AB@%; F4h  math integral upper part%@AE@%%@NL@%
        db   05Fh     %@AB@%; F5h  math integral lower part%@AE@%%@NL@%
        db   05Fh     %@AB@%; F6h  math divide%@AE@%%@NL@%
        db   05Fh     %@AB@%; F7h  math approximately (~)%@AE@%%@NL@%
        db   0B0h     %@AB@%; F8h  degree%@AE@%%@NL@%
        db   0B7h     %@AB@%; F9h  period accent (bold)%@AE@%%@NL@%
        db   0B7h     %@AB@%; FAh  period accent%@AE@%%@NL@%
        db   05Fh     %@AB@%; FBh  math root%@AE@%%@NL@%
        db   06Eh     %@AB@%; FCh  n superscript%@AE@%%@NL@%
        db   0B2h     %@AB@%; FDh  2 superscript%@AE@%%@NL@%
        db   05Fh     %@AB@%; FEh%@AE@%%@NL@%
        db   05Fh     %@AB@%; FFh  blank%@AE@%%@NL@%
%@NL@%
        END%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FONTB.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\FONTB.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'*** FONTB.BAS - Font Routines for the Presentation Graphics Toolbox in%@AE@%%@NL@%
%@AB@%'           Microsoft BASIC 7.0, Professional Development System%@AE@%%@NL@%
%@AB@%'              Copyright (C) 1987-1989, Microsoft Corporation%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  NOTE:  This sample source code toolbox is intended to demonstrate some%@AE@%%@NL@%
%@AB@%'  of the extended capabilities of Microsoft BASIC 7.0 Professional Development%@AE@%%@NL@%
%@AB@%'  system that can help to leverage the professional developer's time more%@AE@%%@NL@%
%@AB@%'  effectively.  While you are free to use, modify, or distribute the routines%@AE@%%@NL@%
%@AB@%'  in this module in any way you find useful, it should be noted that these are%@AE@%%@NL@%
%@AB@%'  examples only and should not be relied upon as a fully-tested "add-on"%@AE@%%@NL@%
%@AB@%'  library.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  PURPOSE:  These are the toolbox routines to handle graphics text using%@AE@%%@NL@%
%@AB@%'            Windows format raster font files:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  To create a library and QuickLib containing the font routines found%@AE@%%@NL@%
%@AB@%'  in this file, follow these steps:%@AE@%%@NL@%
%@AB@%'       BC /X/FS fontb.bas%@AE@%%@NL@%
%@AB@%'       LIB fontb.lib + fontb + fontasm + qbx.lib;%@AE@%%@NL@%
%@AB@%'       LINK /Q fontb.lib, fontb.qlb,,qbxqlb.lib;%@AE@%%@NL@%
%@AB@%'  If you are going to use this FONTB.QLB QuickLib in conjunction with%@AE@%%@NL@%
%@AB@%'  the charting source code (CHRTB.BAS) or the UI toobox source code%@AE@%%@NL@%
%@AB@%'  (GENERAL.BAS, WINDOW.BAS, MENU.BAS and MOUSE.BAS), you need to%@AE@%%@NL@%
%@AB@%'  include the assembly code routines referenced in these files.  For the%@AE@%%@NL@%
%@AB@%'  charting routines, create FONTB.LIB as follows before you create the%@AE@%%@NL@%
%@AB@%'  QuickLib:%@AE@%%@NL@%
%@AB@%'       LIB fontb.lib + fontb + fontasm + chrtasm + qbx.lib;%@AE@%%@NL@%
%@AB@%'  For the UI toolbox routines, create the library as follows:%@AE@%%@NL@%
%@AB@%'       LIB fontb.lib + fontb + fontasm + uiasm + qbx.lib;%@AE@%%@NL@%
%@AB@%'**************************************************************************%@AE@%%@NL@%
%@NL@%
%@AB@%' $INCLUDE: 'QBX.BI'%@AE@%%@NL@%
%@AB@%' $INCLUDE: 'FONTB.BI'%@AE@%%@NL@%
%@NL@%
CONST cFALSE = 0              ' Logical False%@NL@%
CONST cTRUE = NOT cFALSE      ' Logical True%@NL@%
%@NL@%
CONST cDefaultColor = 15      ' Default character color (white in all modes)%@NL@%
CONST cDefaultDir = 0         ' Default character direction%@NL@%
CONST cDefaultFont = 1        ' Default font selected in LoadFont%@NL@%
%@NL@%
CONST cMaxFaceName = 32       ' Maximum length of a font name%@NL@%
CONST cMaxFileName = 66       ' Maximum length of a font file name%@NL@%
CONST cFontResource = &H8008  ' Identifies a font resource%@NL@%
CONST cBitMapType = 0         ' Bitmap font type%@NL@%
%@NL@%
CONST cFileFont = 0           ' Font comes from file%@NL@%
CONST cMemFont = 1            ' Font comes from memory%@NL@%
%@NL@%
CONST cSizeFontHeader = 118   ' Size of Windows font header%@NL@%
%@NL@%
%@AB@%' *********************************************************************%@AE@%%@NL@%
%@AB@%' Data Types:%@AE@%%@NL@%
%@NL@%
%@AB@%' Some global variables used:%@AE@%%@NL@%
TYPE GlobalParams%@NL@%
        MaxRegistered     AS INTEGER     ' Max number of registered fonts allowed%@NL@%
        MaxLoaded         AS INTEGER     ' Max number of loaded fonts allowed%@NL@%
        TotalRegistered   AS INTEGER     ' Number of fonts actually registered%@NL@%
        TotalLoaded       AS INTEGER     ' Number of fonts actually loaded%@NL@%
%@NL@%
        NextDataBlock     AS INTEGER     ' Next available block in font buffer%@NL@%
%@NL@%
        CurrentFont       AS INTEGER     ' Current font number in loaded fonts%@NL@%
        CHeight           AS INTEGER     ' Character height of current font%@NL@%
        FChar             AS INTEGER     ' First char in font%@NL@%
        LChar             AS INTEGER     ' Last char in font%@NL@%
        DChar             AS INTEGER     ' Default char for font%@NL@%
        DSeg              AS INTEGER     ' Segment of current font%@NL@%
        DOffset           AS INTEGER     ' Offset of current font%@NL@%
        FontSource        AS INTEGER     ' Source of current font (File or Mem)%@NL@%
%@NL@%
        CharColorInit     AS INTEGER     ' cFALSE (0) means color not initialized%@NL@%
        CharColor         AS INTEGER     ' Character color%@NL@%
        CharDirInit       AS INTEGER     ' cFALSE (0) means dir not initialized%@NL@%
        CharDir           AS INTEGER     ' Character direction%@NL@%
        CharSet           AS INTEGER     ' Character mappings to use%@NL@%
%@NL@%
        XPixInc           AS INTEGER     ' X increment direction (0, 1, -1)%@NL@%
        YPixInc           AS INTEGER     ' Y increment direction (0, 1, -1)%@NL@%
%@NL@%
        WindowSet         AS INTEGER     ' cTRUE if GTextWindow has been called%@NL@%
        WX1               AS SINGLE      ' Minimum WINDOW X%@NL@%
        WY1               AS SINGLE      ' Minimum WINDOW Y%@NL@%
        WX2               AS SINGLE      ' Maximum WINDOW X%@NL@%
        WY2               AS SINGLE      ' Maximum WINDOW Y%@NL@%
        WScrn             AS INTEGER     ' cTRUE means Y increases top to bottom%@NL@%
%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' The following 3 types are needed to read .FON files. They are documented%@AE@%%@NL@%
%@AB@%' in chapter 7 of the MS Windows Programmer's Reference:%@AE@%%@NL@%
%@NL@%
%@AB@%' Windows font file header:%@AE@%%@NL@%
TYPE WFHeader%@NL@%
        dfVersion         AS INTEGER%@NL@%
        dfSize            AS LONG%@NL@%
        dfCopyright       AS STRING * 60%@NL@%
        dfType            AS INTEGER%@NL@%
        dfPoints          AS INTEGER%@NL@%
        dfVertRes         AS INTEGER%@NL@%
        dfHorizRes        AS INTEGER%@NL@%
        dfAscent          AS INTEGER%@NL@%
        dfInternalLeading AS INTEGER%@NL@%
        dfExternalLeading AS INTEGER%@NL@%
        dfItalic          AS STRING * 1%@NL@%
        dfUnderline       AS STRING * 1%@NL@%
        dfStrikeOut       AS STRING * 1%@NL@%
        dfWeight          AS INTEGER%@NL@%
        dfCharSet         AS STRING * 1%@NL@%
        dfPixWidth        AS INTEGER%@NL@%
        dfPixHeight       AS INTEGER%@NL@%
        dfPitchAndFamily  AS STRING * 1%@NL@%
        dfAvgWidth        AS INTEGER%@NL@%
        dfMaxWidth        AS INTEGER%@NL@%
        dfFirstChar       AS STRING * 1%@NL@%
        dfLastChar        AS STRING * 1%@NL@%
        dfDefaultChar     AS STRING * 1%@NL@%
        dfBreakChar       AS STRING * 1%@NL@%
        dfWidthBytes      AS INTEGER%@NL@%
        dfDevice          AS LONG%@NL@%
        dfFace            AS LONG%@NL@%
        dfBitsPointer     AS LONG%@NL@%
        dfBitsOffset      AS LONG%@NL@%
        pad               AS STRING * 1  ' To ensure word boundry%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' Structure for reading resource type and number from a resource%@AE@%%@NL@%
%@AB@%' table:%@AE@%%@NL@%
TYPE ResType%@NL@%
        TypeID            AS INTEGER%@NL@%
        NumResource       AS INTEGER%@NL@%
        Reserved          AS LONG%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' Structure for reading an actual resource entry:%@AE@%%@NL@%
TYPE ResEntry%@NL@%
        AddrOffset        AS INTEGER%@NL@%
        Length            AS INTEGER%@NL@%
        ResourceKeywd     AS INTEGER%@NL@%
        ResID             AS INTEGER%@NL@%
        Reserved1         AS LONG%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' Internal font header data type:%@AE@%%@NL@%
TYPE IFontInfo%@NL@%
        Status            AS INTEGER  ' Processing status. 0=unproc. else <>0%@NL@%
        FontHeader        AS WFHeader ' The Windows font header%@NL@%
        FaceName          AS STRING * cMaxFaceName   ' Font name%@NL@%
        FileName          AS STRING * cMaxFileName   ' File name%@NL@%
        FontSource        AS INTEGER  ' 0=file, 1=memory%@NL@%
        FileLoc           AS LONG     ' Location in resource file of font file%@NL@%
        DataSeg           AS INTEGER  ' FontData index or Segment address of font%@NL@%
        DataOffset        AS INTEGER  ' Offset  address of font if in memory%@NL@%
        BitsOffset        AS INTEGER  ' Offset from beginning of data to bitmaps%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' Type for selecting registered fonts via LoadFont:%@AE@%%@NL@%
TYPE FontSpec%@NL@%
        FaceName    AS STRING * cMaxFaceName%@NL@%
        Pitch       AS STRING * 1%@NL@%
        PointSize   AS INTEGER     ' Fonts point size%@NL@%
        HorizRes    AS INTEGER     ' Horizontal resolution of font%@NL@%
        VertRes     AS INTEGER     ' Vertical resolution of font%@NL@%
        ScrnMode    AS INTEGER     ' Screen mode%@NL@%
        Height      AS INTEGER     ' Pixel height of font%@NL@%
%@NL@%
        Best        AS INTEGER     ' "Best" flag (true/false)%@NL@%
%@NL@%
        RegNum      AS INTEGER     ' Number of font in registered list%@NL@%
%@NL@%
        InMemory    AS INTEGER     ' Whether font is in memory (true/false)%@NL@%
        HdrSeg      AS INTEGER     ' Segment of font in memory%@NL@%
        HdrOff      AS INTEGER     ' Offset of font in segment%@NL@%
        DataSeg     AS INTEGER     ' Segment of data in memory%@NL@%
        DataOff     AS INTEGER     ' Offset of data in segment%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' *********************************************************************%@AE@%%@NL@%
%@AB@%' Routine Declarations:%@AE@%%@NL@%
%@NL@%
DECLARE SUB flSetFontErr (ErrNum AS INTEGER)%@NL@%
DECLARE SUB flClearFontErr ()%@NL@%
DECLARE SUB flRegisterFont (FileName$, FileNum%)%@NL@%
DECLARE SUB flReadFont (I%)%@NL@%
DECLARE SUB flSizeFontBuffer (NFonts%)%@NL@%
DECLARE SUB flInitSpec (Spec AS ANY)%@NL@%
DECLARE SUB flClearFontStatus ()%@NL@%
DECLARE SUB flGetCurrentScrnSize (XPixels%, YPixels%)%@NL@%
DECLARE SUB flGetBASICScrnSize (ScrnMode%, XPixels%, YPixels%)%@NL@%
DECLARE SUB flInitMask ()%@NL@%
DECLARE SUB flPSET (X%, Y%, Colr%)%@NL@%
DECLARE SUB flChkMax ()%@NL@%
%@NL@%
DECLARE FUNCTION flGetFonts! (NFonts%)%@NL@%
DECLARE FUNCTION flMatchFont! (FSpec AS ANY)%@NL@%
DECLARE FUNCTION flGetNum! (Txt$, ChPos%, Default!, ErrV!)%@NL@%
DECLARE FUNCTION flGetNextSpec! (SpecTxt$, ChPos%, Spec AS ANY)%@NL@%
DECLARE FUNCTION flDoNextResource! (Align%, FileName$, FileNum%)%@NL@%
DECLARE FUNCTION flOutGChar% (X%, Y%, ChVal%)%@NL@%
%@NL@%
%@AB@%' -- Assembly language routines%@AE@%%@NL@%
DECLARE SUB flMovMem ALIAS "fl_MovMem" (SEG dest AS ANY, BYVAL SrcSeg AS INTEGER, BYVAL SrcOffset AS INTEGER, BYVAL Count AS INTEGER)%@NL@%
DECLARE FUNCTION flANSI% ALIAS "fl_ansi" (BYVAL I%)%@NL@%
%@NL@%
DECLARE SUB flSetBltDir ALIAS "fl_SetBltDir" (BYVAL XPixInc%, BYVAL YPixInc%, BYVAL XRowInc%, BYVAL YRowInc%)%@NL@%
DECLARE SUB flSetBltColor ALIAS "fl_SetBltColor" (BYVAL CharColor%)%@NL@%
DECLARE SUB flSetBltParams ALIAS "fl_SetBltParams" (BYVAL HdrLen%, BYVAL CharHgt%, BYVAL FirstChar%, BYVAL LastChar%, BYVAL DefaultChar%)%@NL@%
DECLARE FUNCTION flbltchar% ALIAS "fl_BltChar" (BYVAL FASeg%, BYVAL FAOffset%, BYVAL Char%, BYVAL X%, BYVAL Y%)%@NL@%
%@NL@%
%@AB@%' *********************************************************************%@AE@%%@NL@%
%@AB@%' Variable Definitions:%@AE@%%@NL@%
%@NL@%
%@AB@%' The following arrays hold font headers and font data as fonts are%@AE@%%@NL@%
%@AB@%' registered and loaded. They are dynamically allocated so they can be%@AE@%%@NL@%
%@AB@%' changed in size to accomodate the number of fonts a program will be%@AE@%%@NL@%
%@AB@%' using:%@AE@%%@NL@%
%@NL@%
%@AB@%' $DYNAMIC%@AE@%%@NL@%
%@NL@%
%@AB@%' Array to hold header information for registered fonts:%@AE@%%@NL@%
DIM SHARED FontHdrReg(1 TO 10)  AS IFontInfo%@NL@%
%@NL@%
%@AB@%' Arrays to hold header information and registered font numbers%@AE@%%@NL@%
%@AB@%' for loaded fonts:%@AE@%%@NL@%
DIM SHARED FontHdrLoaded(1 TO 10) AS IFontInfo%@NL@%
DIM SHARED FontLoadList(1 TO 10) AS INTEGER%@NL@%
%@NL@%
%@AB@%' Array to hold font data information:%@AE@%%@NL@%
DIM SHARED FontData(1 TO 1) AS FontDataBlock%@NL@%
%@NL@%
%@AB@%' $STATIC%@AE@%%@NL@%
%@NL@%
%@AB@%' Structure holding global parameters:%@AE@%%@NL@%
DIM SHARED FGP AS GlobalParams%@NL@%
%@NL@%
%@AB@%' Error handler for flChkMax so these arrays will be dimensioned%@AE@%%@NL@%
%@AB@%' to 10 by default:%@AE@%%@NL@%
SetMax:%@NL@%
        REDIM FontHdrLoaded(1 TO 10) AS IFontInfo%@NL@%
        REDIM FontHdrReg(1 TO 10) AS IFontInfo%@NL@%
        REDIM FontLoadList(1 TO 10) AS INTEGER%@NL@%
        RESUME%@NL@%
%@NL@%
%@AB@%' Error handler for out of memory error:%@AE@%%@NL@%
MemErr:%@NL@%
        flSetFontErr cNoFontMem%@NL@%
        RESUME NEXT%@NL@%
%@NL@%
%@AB@%' Error handler for unexpected errors:%@AE@%%@NL@%
UnexpectedErr:%@NL@%
        flSetFontErr cFLUnexpectedErr + ERR%@NL@%
        RESUME NEXT%@NL@%
%@NL@%
%@AB@%' File not found error: RegisterFonts%@AE@%%@NL@%
NoFileErr:%@NL@%
        flSetFontErr cFileNotFound%@NL@%
        RESUME NEXT%@NL@%
%@NL@%
%@AB@%'=== flChkMax - Makes sure that max font settings are correct and%@AE@%%@NL@%
%@AB@%'                enforces default of 10 for max loaded and registered%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB flChkMax STATIC%@NL@%
SHARED FontHdrLoaded() AS IFontInfo%@NL@%
SHARED FontHdrReg() AS IFontInfo%@NL@%
SHARED FGP AS GlobalParams%@NL@%
%@NL@%
%@AB@%' Make sure that GP.MaxLoaded and GP.MaxRegistered match array dimensions%@AE@%%@NL@%
%@AB@%' this will only happen if user hasn't used SetMaxFonts and allows Fontlib%@AE@%%@NL@%
%@AB@%' to set a default of 10 since that is what the arrays are first DIM'd%@AE@%%@NL@%
%@AB@%' to:%@AE@%%@NL@%
%@NL@%
ON ERROR GOTO SetMax%@NL@%
FGP.MaxLoaded = UBOUND(FontHdrLoaded)%@NL@%
FGP.MaxRegistered = UBOUND(FontHdrReg)%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== flClearFontErr - Sets the FontErr variable to 0%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB flClearFontErr STATIC%@NL@%
%@NL@%
        FontErr = 0%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== flClearFontStatus - Clears the status field in the registered font list%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     none%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB flClearFontStatus STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
SHARED FontHdrReg() AS IFontInfo%@NL@%
%@NL@%
FOR I% = 1 TO FGP.TotalRegistered%@NL@%
        FontHdrReg(I%).Status = 0%@NL@%
NEXT I%%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== flDoNextResource - Processes resource from resource table:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Align%      - Alignment shift count for finding resource data%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     FileName$   - Name of font file (passed to routine that actually%@AE@%%@NL@%
%@AB@%'                   registers resource entry)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     FileNum%    - File number for reading%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Value:%@AE@%%@NL@%
%@AB@%'     The number of fonts actually registered%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION flDoNextResource (Align%, FileName$, FileNum%) STATIC%@NL@%
DIM ResID AS ResType, Entry AS ResEntry%@NL@%
%@NL@%
%@AB@%' Get the first few bytes identifying the resource type and the number%@AE@%%@NL@%
%@AB@%' of this type:%@AE@%%@NL@%
GET FileNum%, , ResID%@NL@%
%@NL@%
%@AB@%' If this is not the last resource then process it:%@AE@%%@NL@%
IF ResID.TypeID <> 0 THEN%@NL@%
%@NL@%
%@AB@%        ' Loop through the entries of this resource and if an entry happens to be%@AE@%%@NL@%
%@AB@%        ' a font resource then register it. The file location must be saved%@AE@%%@NL@%
%@AB@%        ' for each entry in the resource table since the flRegisterFont%@AE@%%@NL@%
%@AB@%        ' routine may go to some other part of the file to read the resource:%@AE@%%@NL@%
        FOR ResourceEntry = 1 TO ResID.NumResource%@NL@%
%@NL@%
                GET FileNum%, , Entry%@NL@%
                NextResLoc# = SEEK(FileNum%)%@NL@%
                IF ResID.TypeID = cFontResource THEN%@NL@%
%@NL@%
%@AB@%                        ' Seek to font information, register it, then seek back to%@AE@%%@NL@%
%@AB@%                        ' the next resource table entry:%@AE@%%@NL@%
                        SEEK FileNum%, Entry.AddrOffset * 2 ^ Align% + 1%@NL@%
                        flRegisterFont FileName$, FileNum%%@NL@%
                        SEEK FileNum%, NextResLoc#%@NL@%
                        IF FontErr <> 0 THEN EXIT FUNCTION%@NL@%
%@NL@%
                END IF%@NL@%
%@NL@%
        NEXT ResourceEntry%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Return the current resource type so that RegisterFonts knows when the%@AE@%%@NL@%
%@AB@%' last resource has been read:%@AE@%%@NL@%
flDoNextResource = ResID.TypeID%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== flGetBASICScrnSize - Returns screen size for specified BASIC screen mode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ScrnMode%   -  BASIC screen mode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     XPixels%    -  Number of pixels in horizontal direction%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     YPixels%    -  Number of pixels in vertical direction%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB flGetBASICScrnSize (ScrnMode%, XPixels%, YPixels%) STATIC%@NL@%
        SELECT CASE ScrnMode%%@NL@%
                CASE 1: XPixels% = 320: YPixels% = 200%@NL@%
                CASE 2: XPixels% = 640: YPixels% = 200%@NL@%
                CASE 3: XPixels% = 720: YPixels% = 348%@NL@%
                CASE 4: XPixels% = 640: YPixels% = 400%@NL@%
                CASE 7: XPixels% = 320: YPixels% = 200%@NL@%
                CASE 8: XPixels% = 640: YPixels% = 200%@NL@%
                CASE 9: XPixels% = 640: YPixels% = 350%@NL@%
                CASE 10: XPixels% = 640: YPixels% = 350%@NL@%
                CASE 11: XPixels% = 640: YPixels% = 480%@NL@%
                CASE 12: XPixels% = 640: YPixels% = 480%@NL@%
                CASE 13: XPixels% = 320: YPixels% = 200%@NL@%
                CASE ELSE: XPixels% = 0: YPixels% = 0%@NL@%
        END SELECT%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== flGetCurrentScrnSize - Returns screen size for current screen mode%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     XPixels%    -  Number of pixels in horizontal direction%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     YPixels%    -  Number of pixels in vertical direction%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB flGetCurrentScrnSize (XPixels%, YPixels%) STATIC%@NL@%
DIM Regs AS RegType%@NL@%
%@NL@%
%@AB@%' Use DOS interrupt to get current video display mode:%@AE@%%@NL@%
Regs.ax = &HF00%@NL@%
CALL INTERRUPT(&H10, Regs, Regs)%@NL@%
%@NL@%
%@AB@%' Set screen size based on mode:%@AE@%%@NL@%
SELECT CASE Regs.ax MOD 256%@NL@%
        CASE &H4: XPixels% = 320: YPixels% = 200%@NL@%
        CASE &H5: XPixels% = 320: YPixels% = 200%@NL@%
        CASE &H6: XPixels% = 640: YPixels% = 200%@NL@%
        CASE &H7: XPixels% = 720: YPixels% = 350%@NL@%
        CASE &H8: XPixels% = 720: YPixels% = 348     ' Hercules%@NL@%
        CASE &HD: XPixels% = 320: YPixels% = 200%@NL@%
        CASE &HE: XPixels% = 640: YPixels% = 200%@NL@%
        CASE &HF: XPixels% = 640: YPixels% = 350%@NL@%
        CASE &H10: XPixels% = 640: YPixels% = 350%@NL@%
        CASE &H11: XPixels% = 640: YPixels% = 480%@NL@%
        CASE &H12: XPixels% = 640: YPixels% = 480%@NL@%
        CASE &H13: XPixels% = 320: YPixels% = 200%@NL@%
        CASE &H40: XPixels% = 640: YPixels% = 400    ' Olivetti%@NL@%
        CASE ELSE: XPixels% = 0: YPixels = 0%@NL@%
END SELECT%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== flGetFonts - Gets fonts specified in FontLoadList%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     NFonts%  -  Number of fonts to load%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Number of fonts successfully loaded%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION flGetFonts (NFonts%) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
SHARED FontHdrReg() AS IFontInfo%@NL@%
SHARED FontHdrLoaded() AS IFontInfo%@NL@%
SHARED FontLoadList() AS INTEGER%@NL@%
%@NL@%
%@AB@%' Re-dimension font data buffer to fit all the fonts:%@AE@%%@NL@%
flSizeFontBuffer (NFonts%)%@NL@%
IF FontErr = cNoFontMem THEN EXIT FUNCTION%@NL@%
%@NL@%
%@AB@%' Clear the font status variables then load the fonts (the status variable%@AE@%%@NL@%
%@AB@%' is used to record which ones have already been loaded so they aren't%@AE@%%@NL@%
%@AB@%' loaded more than once):%@AE@%%@NL@%
flClearFontStatus%@NL@%
FOR Font% = 1 TO NFonts%%@NL@%
        FontNum% = FontLoadList(Font%)%@NL@%
%@NL@%
%@AB@%        ' If font already loaded then just copy the already-filled-out header%@AE@%%@NL@%
%@AB@%        ' to the new slot:%@AE@%%@NL@%
        IF FontHdrReg(FontNum%).Status <> 0 THEN%@NL@%
                FontHdrLoaded(Font%) = FontHdrLoaded(FontHdrReg(FontNum%).Status)%@NL@%
%@NL@%
%@AB@%        ' Otherwise, read the font and update status in registered version%@AE@%%@NL@%
%@AB@%        ' to point to the first slot it was loaded into (so we can go get%@AE@%%@NL@%
%@AB@%        ' an already-filled-out header from there):%@AE@%%@NL@%
        ELSE%@NL@%
                FontHdrLoaded(Font%) = FontHdrReg(FontNum%)%@NL@%
%@NL@%
%@AB@%                ' Hold any existing errors:%@AE@%%@NL@%
                HoldErr% = FontErr%@NL@%
                flClearFontErr%@NL@%
%@NL@%
                flReadFont Font%%@NL@%
%@NL@%
%@AB@%                ' If there was an error in reading font, exit. Otherwise,%@AE@%%@NL@%
%@AB@%                ' reset the error to what it was before and continue:%@AE@%%@NL@%
                IF FontErr <> 0 THEN%@NL@%
                        flGetFonts = FontNum% - 1%@NL@%
                        EXIT FUNCTION%@NL@%
                ELSE%@NL@%
                        flSetFontErr HoldErr%%@NL@%
                END IF%@NL@%
%@NL@%
                FontHdrReg(FontNum%).Status = Font%%@NL@%
        END IF%@NL@%
NEXT Font%%@NL@%
%@NL@%
flGetFonts = NFonts%%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== flGetNextSpec - Parses the next spec from the spec string%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     SpecTxt$ -  String containing font specifications%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ChPos%   -  Current position in string (updated in this routine)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Spec     -  Structure to contain parsed values%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     0    -  Spec was found%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     1    -  No spec found%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     2    -  Invalid spec found%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION flGetNextSpec (SpecTxt$, ChPos%, Spec AS FontSpec) STATIC%@NL@%
%@NL@%
%@AB@%' Initialize some things:%@AE@%%@NL@%
SpecErr = cFALSE%@NL@%
SpecLen% = LEN(SpecTxt$)%@NL@%
%@NL@%
%@AB@%' If character pos starts past end of spec then we're done:%@AE@%%@NL@%
IF ChPos% > SpecLen% THEN%@NL@%
        flGetNextSpec = 1%@NL@%
        EXIT FUNCTION%@NL@%
END IF%@NL@%
%@NL@%
DO UNTIL ChPos% > SpecLen%%@NL@%
%@NL@%
        Param$ = UCASE$(MID$(SpecTxt$, ChPos%, 1))%@NL@%
        ChPos% = ChPos% + 1%@NL@%
%@NL@%
        SELECT CASE Param$%@NL@%
%@NL@%
%@AB@%                ' Skip blanks:%@AE@%%@NL@%
                CASE " ":%@NL@%
%@NL@%
%@AB@%                ' Font title:%@AE@%%@NL@%
                CASE "T":%@NL@%
%@NL@%
%@AB@%                        ' Scan for font title until blank or end of string:%@AE@%%@NL@%
                        StartPos% = ChPos%%@NL@%
                        DO UNTIL ChPos% > SpecLen%%@NL@%
                                Char$ = MID$(SpecTxt$, ChPos%, 1)%@NL@%
                                ChPos% = ChPos% + 1%@NL@%
                        LOOP%@NL@%
%@NL@%
%@AB@%                        ' Extract the title:%@AE@%%@NL@%
                        TitleLen% = ChPos% - StartPos%%@NL@%
                        IF TitleLen% <= 0 THEN%@NL@%
                                SpecErr = cTRUE%@NL@%
                        ELSE%@NL@%
                                Spec.FaceName = MID$(SpecTxt$, StartPos%, TitleLen%)%@NL@%
                        END IF%@NL@%
%@NL@%
%@AB@%                ' Fixed or Proportional font:%@AE@%%@NL@%
                CASE "F", "P":%@NL@%
                        Spec.Pitch = Param$%@NL@%
%@NL@%
%@AB@%                ' Font Size (default to 12 points):%@AE@%%@NL@%
                CASE "S":%@NL@%
                        Spec.PointSize = flGetNum(SpecTxt$, ChPos%, 12, SpecErr)%@NL@%
%@NL@%
%@AB@%                ' Screen Mode:%@AE@%%@NL@%
                CASE "M":%@NL@%
                        Spec.ScrnMode = flGetNum(SpecTxt$, ChPos%, -1, SpecErr)%@NL@%
%@NL@%
%@AB@%                ' Pixel Height:%@AE@%%@NL@%
                CASE "H":%@NL@%
                        Spec.Height = flGetNum(SpecTxt$, ChPos%, 0, SpecErr)%@NL@%
%@NL@%
%@AB@%                ' Best fit:%@AE@%%@NL@%
                CASE "B":%@NL@%
                        Spec.Best = cTRUE%@NL@%
%@NL@%
%@AB@%                ' Registered font number:%@AE@%%@NL@%
                CASE "N":%@NL@%
                        Spec.RegNum = flGetNum(SpecTxt$, ChPos%, 0, SpecErr)%@NL@%
%@NL@%
%@AB@%                ' Font in memory:%@AE@%%@NL@%
                CASE "R":%@NL@%
                        Spec.InMemory = cTRUE%@NL@%
%@NL@%
%@AB@%                ' Spec separator:%@AE@%%@NL@%
                CASE "/":%@NL@%
                        EXIT DO%@NL@%
%@NL@%
%@AB@%                ' Anything else is an error:%@AE@%%@NL@%
                CASE ELSE:%@NL@%
                        SpecErr = cTRUE%@NL@%
                        ChPos% = ChPos% + 1%@NL@%
        END SELECT%@NL@%
LOOP%@NL@%
%@NL@%
%@AB@%' Spec is parsed, make sure a valid screen mode has been specified and%@AE@%%@NL@%
%@AB@%' adjust point sizes for 320x200 screens if necessary:%@AE@%%@NL@%
IF Spec.PointSize <> 0 THEN%@NL@%
%@NL@%
%@AB@%        ' Get screen size for specified mode (with "M" param) or current%@AE@%%@NL@%
%@AB@%        ' screen mode:%@AE@%%@NL@%
        IF Spec.ScrnMode < 0 THEN%@NL@%
                flGetCurrentScrnSize XPixels%, YPixels%%@NL@%
        ELSE%@NL@%
                flGetBASICScrnSize Spec.ScrnMode, XPixels%, YPixels%%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' If this isn't a graphics mode then set an error and skip the rest:%@AE@%%@NL@%
        IF XPixels% = 0 THEN%@NL@%
                SpecErr = cTRUE%@NL@%
                Spec.PointSize = 0%@NL@%
%@NL@%
%@AB@%        ' If this is a 320x200 screen mode adjust point sizes to the%@AE@%%@NL@%
%@AB@%        ' equivalent EGA font point sizes. Also set the horizontal%@AE@%%@NL@%
%@AB@%        ' a vertical resolutions to search for in fonts (horizontal is%@AE@%%@NL@%
%@AB@%        ' 96 for all modes, vertical varies):%@AE@%%@NL@%
        ELSE%@NL@%
%@NL@%
%@AB@%                ' Use a horizontal resolution of 96 for all screens:%@AE@%%@NL@%
                Spec.HorizRes = 96%@NL@%
%@NL@%
                IF XPixels% = 320 THEN%@NL@%
                        Spec.VertRes = 72%@NL@%
%@NL@%
%@AB@%                        ' In a 320x200 mode scale point sizes to their equivalent%@AE@%%@NL@%
%@AB@%                        ' EGA fonts (special case 14 and 24 point fonts to map them%@AE@%%@NL@%
%@AB@%                        ' to the closest EGA font otherwise multiply point size by%@AE@%%@NL@%
%@AB@%                        ' 2/3:%@AE@%%@NL@%
                        SELECT CASE Spec.PointSize%@NL@%
                                CASE 14: Spec.PointSize = 10%@NL@%
                                CASE 24: Spec.PointSize = 18%@NL@%
                                CASE ELSE: Spec.PointSize = Spec.PointSize * 2 / 3%@NL@%
                        END SELECT%@NL@%
%@NL@%
                ELSE%@NL@%
%@NL@%
%@AB@%                        ' Other screen modes vary only in vertical resolution:%@AE@%%@NL@%
                        SELECT CASE YPixels%%@NL@%
                                CASE 200: Spec.VertRes = 48%@NL@%
                                CASE 350: Spec.VertRes = 72%@NL@%
                                CASE 480: Spec.VertRes = 96%@NL@%
                        END SELECT%@NL@%
                END IF%@NL@%
        END IF%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' If an error was found somewhere then pass it on and set-up to load%@AE@%%@NL@%
%@AB@%' first font:%@AE@%%@NL@%
IF SpecErr THEN%@NL@%
        flGetNextSpec = 2%@NL@%
        Spec.RegNum = 1%@NL@%
ELSE%@NL@%
        flGetNextSpec = 0%@NL@%
END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== flGetNum - Parses number from string%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Txt$     -  String from which to parse number%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ChPos%   -  Character position on which to start%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Default  -  Default value if number not found%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     ErrV     -  Returns error as cTrue or cFalse%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Returns value found or default%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Notes:%@AE@%%@NL@%
%@AB@%'     Simple state machine:%@AE@%%@NL@%
%@AB@%'        state 0: Looking for first char%@AE@%%@NL@%
%@AB@%'        state 1: Found start (+, -, or digit)%@AE@%%@NL@%
%@AB@%'        state 2: Done%@AE@%%@NL@%
%@AB@%'        state 3: Error%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION flGetNum (Txt$, ChPos%, Default, ErrV) STATIC%@NL@%
%@NL@%
%@AB@%' Start in state 0%@AE@%%@NL@%
State = 0%@NL@%
%@NL@%
%@AB@%' Loop until done%@AE@%%@NL@%
DO%@NL@%
        Char$ = MID$(Txt$, ChPos%, 1)%@NL@%
        SELECT CASE Char$%@NL@%
%@NL@%
%@AB@%                ' Plus and minus are only OK at the beginning:%@AE@%%@NL@%
                CASE "+", "-":%@NL@%
                        SELECT CASE State%@NL@%
                                CASE 0: Start% = ChPos%: State = 1%@NL@%
                                CASE ELSE: State = 3%@NL@%
                        END SELECT%@NL@%
%@NL@%
%@AB@%                ' Digits are OK at the beginning of after plus and minus:%@AE@%%@NL@%
                CASE "0" TO "9":%@NL@%
                        SELECT CASE State%@NL@%
                                CASE 0: Start% = ChPos%: State = 1%@NL@%
                                CASE ELSE:%@NL@%
                        END SELECT%@NL@%
%@NL@%
%@AB@%                ' Spaces are skipped:%@AE@%%@NL@%
                CASE " ":%@NL@%
%@NL@%
%@AB@%                ' Anything else is an error at the beginning or marks the end:%@AE@%%@NL@%
                CASE ELSE:%@NL@%
                        SELECT CASE State%@NL@%
                                CASE 0: State = 3%@NL@%
                                CASE 1: State = 2%@NL@%
                        END SELECT%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Go to next character:%@AE@%%@NL@%
        ChPos% = ChPos% + 1%@NL@%
LOOP UNTIL State = 2 OR State = 3%@NL@%
%@NL@%
%@AB@%' Scanning is complete; adjust ChPos% to mark last character processed:%@AE@%%@NL@%
ChPos% = ChPos% - 1%@NL@%
%@NL@%
%@AB@%' If error then set default number:%@AE@%%@NL@%
IF State = 3 THEN%@NL@%
        flGetNum = Default%@NL@%
        ErrV = cTRUE%@NL@%
%@NL@%
%@AB@%' Otherwise, extract number and get its value:%@AE@%%@NL@%
ELSE%@NL@%
        EndPos% = ChPos% - 1%@NL@%
        flGetNum = VAL(MID$(Txt$, Start%, EndPos%))%@NL@%
        ErrV = cFALSE%@NL@%
END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== flInitSpec - Initializes font specification structure%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Spec     -  FontSpec variable to initialize%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB flInitSpec (Spec AS FontSpec) STATIC%@NL@%
%@NL@%
        Spec.FaceName = ""%@NL@%
        Spec.Pitch = ""%@NL@%
        Spec.PointSize = 0%@NL@%
        Spec.ScrnMode = -1%@NL@%
        Spec.Height = 0%@NL@%
        Spec.Best = cFALSE%@NL@%
        Spec.RegNum = 0%@NL@%
        Spec.InMemory = cFALSE%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== flMatchFont - Finds first registered font that matches FontSpec%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     FSpec -  FontSpec variable containing specification to match%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Number of registered font matched, -1 if no match.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION flMatchFont (FSpec AS FontSpec) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
SHARED FontHdrReg() AS IFontInfo%@NL@%
%@NL@%
%@AB@%' Match a specific registered font:%@AE@%%@NL@%
IF FSpec.RegNum > 0 AND FSpec.RegNum <= FGP.TotalRegistered THEN%@NL@%
        flMatchFont = FSpec.RegNum%@NL@%
        EXIT FUNCTION%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' If this is an invalid spec. then no fonts matched:%@AE@%%@NL@%
IF FontErr <> 0 THEN%@NL@%
        flMatchFont = -1%@NL@%
        EXIT FUNCTION%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Scan font for first one that matches the rest of the specs:%@AE@%%@NL@%
SelectedFont% = -1%@NL@%
BestSizeDiff = 3.402823E+38%@NL@%
BestFontNum% = -1%@NL@%
FOR FontNum% = 1 TO FGP.TotalRegistered%@NL@%
%@NL@%
%@AB@%        ' Match a font from memory:%@AE@%%@NL@%
        MemOK% = cTRUE%@NL@%
        IF FSpec.InMemory AND FontHdrReg(FontNum%).FontSource <> cMemFont THEN%@NL@%
                MemOK% = cFALSE%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Match name:%@AE@%%@NL@%
        IF FSpec.FaceName = FontHdrReg(FontNum%).FaceName OR LTRIM$(FSpec.FaceName) = "" THEN%@NL@%
                NameOK% = cTRUE%@NL@%
        ELSE%@NL@%
                NameOK% = cFALSE%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Match pitch (fixed or proportional):%@AE@%%@NL@%
        Pitch$ = "F"%@NL@%
        IF FontHdrReg(FontNum%).FontHeader.dfPixWidth = 0 THEN Pitch$ = "P"%@NL@%
        IF FSpec.Pitch = Pitch$ OR FSpec.Pitch = " " THEN%@NL@%
                PitchOK% = cTRUE%@NL@%
        ELSE%@NL@%
                PitchOK% = cFALSE%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Match font size (if neither point or pixel size specified then%@AE@%%@NL@%
%@AB@%        ' this font is OK):%@AE@%%@NL@%
        IF FSpec.PointSize = 0 AND FSpec.Height = 0 THEN%@NL@%
                SizeOK% = cTRUE%@NL@%
%@NL@%
%@AB@%        ' Otherwise, if point size specified (note that point size overrides%@AE@%%@NL@%
%@AB@%        ' the pixel height if they were both specified)...%@AE@%%@NL@%
        ELSEIF FSpec.PointSize <> 0 THEN%@NL@%
%@NL@%
%@AB@%                ' Make sure the font resolution matches the screen resolution%@AE@%%@NL@%
%@AB@%                ' (pass over this font if not):%@AE@%%@NL@%
                IF FSpec.HorizRes <> FontHdrReg(FontNum%).FontHeader.dfHorizRes THEN%@NL@%
                        SizeOK% = cFALSE%@NL@%
                ELSEIF FSpec.VertRes <> FontHdrReg(FontNum%).FontHeader.dfVertRes THEN%@NL@%
                        SizeOK% = cFALSE%@NL@%
%@NL@%
%@AB@%                ' Font has made it past the resolution check, now try to match size:%@AE@%%@NL@%
                ELSE%@NL@%
                        SizeDiff = ABS(FSpec.PointSize - FontHdrReg(FontNum%).FontHeader.dfPoints)%@NL@%
                        IF SizeDiff = 0 THEN%@NL@%
                                SizeOK% = cTRUE%@NL@%
                        ELSE%@NL@%
                                SizeOK% = cFALSE%@NL@%
                        END IF%@NL@%
                END IF%@NL@%
%@NL@%
%@NL@%
%@AB@%        ' Now, the case where height was specified and not point size:%@AE@%%@NL@%
        ELSEIF FSpec.Height <> 0 THEN%@NL@%
                SizeDiff = ABS(FSpec.Height - FontHdrReg(FontNum%).FontHeader.dfPixHeight)%@NL@%
                IF SizeDiff = 0 THEN%@NL@%
                        SizeOK% = cTRUE%@NL@%
                ELSE%@NL@%
                        SizeOK% = cFALSE%@NL@%
                END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Do record keeping if best-fit was specified:%@AE@%%@NL@%
        IF NOT SizeOK% AND PitchOK% AND FSpec.Best AND SizeDiff < BestSizeDiff THEN%@NL@%
                BestSizeDiff = SizeDiff%@NL@%
                BestFontNum% = FontNum%%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' See if this font is OK:%@AE@%%@NL@%
        IF MemOK% AND NameOK% AND PitchOK% AND SizeOK% THEN%@NL@%
                SelectedFont% = FontNum%%@NL@%
                EXIT FOR%@NL@%
        END IF%@NL@%
NEXT FontNum%%@NL@%
%@NL@%
%@AB@%' If no font was matched and best-fit was specified then select the%@AE@%%@NL@%
%@AB@%' best font:%@AE@%%@NL@%
IF SelectedFont% < 0 AND FSpec.Best THEN SelectedFont% = BestFontNum%%@NL@%
%@NL@%
%@AB@%' Return the font matched:%@AE@%%@NL@%
flMatchFont = SelectedFont%%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== flReadFont - Reads font data and sets up font header%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     I%    -  Slot in loaded fonts to process%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB flReadFont (I%) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
SHARED FontHdrLoaded() AS IFontInfo%@NL@%
SHARED FontData() AS FontDataBlock%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' If memory font then it's already in memory:%@AE@%%@NL@%
IF FontHdrLoaded(I%).FontSource = cMemFont THEN%@NL@%
        EXIT SUB%@NL@%
%@NL@%
%@AB@%' For a font from a file, read it in:%@AE@%%@NL@%
ELSE%@NL@%
        DataSize# = FontHdrLoaded(I%).FontHeader.dfSize - cSizeFontHeader%@NL@%
        NumBlocks% = -INT(-DataSize# / cFontBlockSize)%@NL@%
        FontHdrLoaded(I%).DataSeg = FGP.NextDataBlock%@NL@%
%@NL@%
%@AB@%        ' Get next available file number and open file:%@AE@%%@NL@%
        FileNum% = FREEFILE%@NL@%
        OPEN FontHdrLoaded(I%).FileName FOR BINARY AS FileNum%%@NL@%
%@NL@%
%@AB@%        ' Read blocks from the font file:%@AE@%%@NL@%
        DataLoc# = FontHdrLoaded(I%).FileLoc + cSizeFontHeader%@NL@%
        SEEK FileNum%, DataLoc#%@NL@%
        FOR BlockNum% = 0 TO NumBlocks% - 1%@NL@%
                GET FileNum%, , FontData(FGP.NextDataBlock + BlockNum%)%@NL@%
        NEXT BlockNum%%@NL@%
%@NL@%
%@AB@%        ' Close the file:%@AE@%%@NL@%
        CLOSE FileNum%%@NL@%
%@NL@%
%@AB@%        ' Update the next data block pointer:%@AE@%%@NL@%
        FGP.NextDataBlock = FGP.NextDataBlock + NumBlocks%%@NL@%
END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== flRegisterFont - Actually registers a font resource:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     FileName$   - Name of font file (passed to routine that actually%@AE@%%@NL@%
%@AB@%'                   registers resource entry)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     FileNum%    - File number for reading%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB flRegisterFont (FileName$, FileNum%) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
SHARED FontHdrReg() AS IFontInfo%@NL@%
%@NL@%
DIM Byte AS STRING * 1, FontHeader AS WFHeader%@NL@%
%@NL@%
%@AB@%' Read the font header:%@AE@%%@NL@%
FontLoc# = SEEK(FileNum%)%@NL@%
GET FileNum%, , FontHeader%@NL@%
%@NL@%
%@AB@%' Only register vector fonts:%@AE@%%@NL@%
IF FontHeader.dfType AND &H1 <> cBitMapType THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%' See that we're still within MaxRegistered limits:%@AE@%%@NL@%
IF FGP.TotalRegistered >= FGP.MaxRegistered THEN%@NL@%
        flSetFontErr cTooManyFonts%@NL@%
        EXIT SUB%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Go to next "registered" font slot:%@AE@%%@NL@%
FGP.TotalRegistered = FGP.TotalRegistered + 1%@NL@%
%@NL@%
%@AB@%' Set font source and save the header and file location:%@AE@%%@NL@%
FontHdrReg(FGP.TotalRegistered).FontSource = cFileFont%@NL@%
FontHdrReg(FGP.TotalRegistered).FontHeader = FontHeader%@NL@%
FontHdrReg(FGP.TotalRegistered).FileLoc = FontLoc#%@NL@%
%@NL@%
%@AB@%' Get the face name (scan characters until zero byte):%@AE@%%@NL@%
SEEK FileNum%, FontLoc# + FontHeader.dfFace%@NL@%
FaceName$ = ""%@NL@%
FOR Char% = 0 TO cMaxFaceName - 1%@NL@%
        GET FileNum%, , Byte%@NL@%
        IF ASC(Byte) = 0 THEN EXIT FOR%@NL@%
        FaceName$ = FaceName$ + Byte%@NL@%
NEXT Char%%@NL@%
FontHdrReg(FGP.TotalRegistered).FaceName = FaceName$%@NL@%
%@NL@%
%@AB@%' Finally, save the file name:%@AE@%%@NL@%
FontHdrReg(FGP.TotalRegistered).FileName = FileName$%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== flSetFontErr - Sets the FontErr variable to an error value:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     ErrNum   -  The error number to set FontErr variable to%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB flSetFontErr (ErrNum AS INTEGER) STATIC%@NL@%
%@NL@%
         FontErr = ErrNum%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== flSizeFontBuffer - Calculate the FontBuffer size required for all fonts%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     NFonts%  -  Number of font to be loaded%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Notes:%@AE@%%@NL@%
%@AB@%'     The use of -INT(-N) in the following code rounds N to the next%@AE@%%@NL@%
%@AB@%'     larger integer%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB flSizeFontBuffer (NFonts%) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
SHARED FontHdrReg() AS IFontInfo%@NL@%
SHARED FontLoadList() AS INTEGER%@NL@%
SHARED FontData() AS FontDataBlock%@NL@%
%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
IF NFonts% = 0 THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%' Clear font status variables so we know what has been processed:%@AE@%%@NL@%
flClearFontStatus%@NL@%
%@NL@%
%@AB@%' Add sizes of all unique fonts together to get total size (each font%@AE@%%@NL@%
%@AB@%' begins on a new font block so the size of each font is calculated in%@AE@%%@NL@%
%@AB@%' terms of the number of font blocks it will take up):%@AE@%%@NL@%
Size = 0%@NL@%
FOR I% = 1 TO NFonts%%@NL@%
        FontNum% = FontLoadList(I%)%@NL@%
        IF FontHdrReg(FontNum%).Status = 0 THEN%@NL@%
                FontSize = FontHdrReg(FontNum%).FontHeader.dfSize - cSizeFontHeader%@NL@%
                Size = Size - INT(-FontSize / cFontBlockSize)%@NL@%
                FontHdrReg(FontNum%).Status = 1%@NL@%
        END IF%@NL@%
NEXT I%%@NL@%
%@NL@%
%@AB@%' Dimension the FontData array to hold everything:%@AE@%%@NL@%
ON ERROR GOTO MemErr%@NL@%
REDIM FontData(1 TO Size) AS FontDataBlock%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Set the next font block to the start for when flReadFont begins%@AE@%%@NL@%
%@AB@%' putting data in the font buffer:%@AE@%%@NL@%
FGP.NextDataBlock = 1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== GetFontInfo - Returns useful information about current font%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     FI    -  FontInfo type variable to receive info%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB GetFontInfo (FI AS FontInfo) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
SHARED FontHdrLoaded() AS IFontInfo%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
%@AB@%' Check that some fonts are loaded:%@AE@%%@NL@%
IF FGP.TotalLoaded <= 0 THEN%@NL@%
        flSetFontErr cNoFonts%@NL@%
        EXIT SUB%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' All OK, assign values from internal font header:%@AE@%%@NL@%
FI.FontNum = FGP.CurrentFont%@NL@%
FI.Ascent = FontHdrLoaded(FGP.CurrentFont).FontHeader.dfAscent%@NL@%
FI.Points = FontHdrLoaded(FGP.CurrentFont).FontHeader.dfPoints%@NL@%
FI.PixWidth = FontHdrLoaded(FGP.CurrentFont).FontHeader.dfPixWidth%@NL@%
FI.PixHeight = FontHdrLoaded(FGP.CurrentFont).FontHeader.dfPixHeight%@NL@%
FI.Leading = FontHdrLoaded(FGP.CurrentFont).FontHeader.dfInternalLeading%@NL@%
FI.MaxWidth = FontHdrLoaded(FGP.CurrentFont).FontHeader.dfMaxWidth%@NL@%
FI.AvgWidth = FontHdrLoaded(FGP.CurrentFont).FontHeader.dfAvgWidth%@NL@%
FI.FileName = FontHdrLoaded(FGP.CurrentFont).FileName%@NL@%
FI.FaceName = FontHdrLoaded(FGP.CurrentFont).FaceName%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== GetGTextLen - Returns bit length of string%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Text$ -  String for which to return length%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     -1    -  Error (No fonts loaded, probably)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     >=0   -  Length of string%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION GetGTextLen% (Text$) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
SHARED FontHdrLoaded() AS IFontInfo%@NL@%
SHARED FontData() AS FontDataBlock%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
%@AB@%' Make sure some fonts are loaded:%@AE@%%@NL@%
IF FGP.TotalLoaded <= 0 THEN%@NL@%
        flSetFontErr cNoFonts%@NL@%
        GetGTextLen = -1%@NL@%
        EXIT FUNCTION%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Assume this is a memory font (may override this later):%@AE@%%@NL@%
CharTblPtr% = FontHdrLoaded(FGP.CurrentFont).DataOffset%@NL@%
CharTblSeg% = FontHdrLoaded(FGP.CurrentFont).DataSeg%@NL@%
%@NL@%
%@AB@%' Index into font data array:%@AE@%%@NL@%
CharTable% = FontHdrLoaded(FGP.CurrentFont).DataSeg%@NL@%
%@NL@%
%@AB@%' Add together the character lengths from the character table:%@AE@%%@NL@%
TextLen% = 0%@NL@%
FOR I% = 1 TO LEN(Text$)%@NL@%
%@NL@%
%@AB@%        ' Get character code and translate to Ansi if IBM char set is specified:%@AE@%%@NL@%
        ChVal% = ASC(MID$(Text$, I%, 1))%@NL@%
        IF FGP.CharSet = cIBMChars THEN ChVal% = flANSI(ChVal%)%@NL@%
%@NL@%
%@AB@%        ' Convert to default char if out of range:%@AE@%%@NL@%
        IF ChVal% < FGP.FChar OR ChVal% > FGP.LChar THEN ChVal% = FGP.DChar%%@NL@%
%@NL@%
%@AB@%        ' Offset into character table for length word:%@AE@%%@NL@%
        CharOffset% = (ChVal% - FGP.FChar) * 4%@NL@%
%@NL@%
%@AB@%        ' Peek the data and add it to the text length:%@AE@%%@NL@%
        IF FontHdrLoaded(FGP.CurrentFont).FontSource = cFileFont THEN%@NL@%
                CharTblPtr% = VARPTR(FontData(CharTable%))%@NL@%
                CharTblSeg% = VARSEG(FontData(CharTable%))%@NL@%
        END IF%@NL@%
        DEF SEG = CharTblSeg%%@NL@%
        CharLen% = PEEK(CharTblPtr% + CharOffset%) + PEEK(CharTblPtr% + CharOffset% + 1) * 256%@NL@%
        TextLen% = TextLen% + CharLen%%@NL@%
NEXT I%%@NL@%
%@NL@%
GetGTextLen = TextLen%%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== GetMaxFonts - Gets the maximum number of fonts that can be registered%@AE@%%@NL@%
%@AB@%'                  and loaded by the font library:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Registered  -  The maximum number of fonts that can be registered%@AE@%%@NL@%
%@AB@%'                    by the font library%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Loaded      -  The maximum number of fonts that can be loaded by%@AE@%%@NL@%
%@AB@%'                    by the font library%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB GetMaxFonts (Registered AS INTEGER, Loaded AS INTEGER)%@NL@%
SHARED FGP AS GlobalParams%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
%@AB@%' If SetMaxFonts hasn't been called then make sure the default is%@AE@%%@NL@%
%@AB@%' correct:%@AE@%%@NL@%
flChkMax%@NL@%
%@NL@%
%@AB@%' Simply return the values of the internal variables for maximum%@AE@%%@NL@%
%@AB@%' fonts registered and loaded:%@AE@%%@NL@%
Registered = FGP.MaxRegistered%@NL@%
Loaded = FGP.MaxLoaded%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== GetFontInfo - Returns useful information about current font%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Font  -  Font number (in list of registered fonts) on which to get%@AE@%%@NL@%
%@AB@%'              information%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     FI    -  FontInfo type variable to receive info%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB GetRFontInfo (Font AS INTEGER, FI AS FontInfo) STATIC%@NL@%
SHARED FontHdrReg() AS IFontInfo%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
%@AB@%' See that they've specified a valid font:%@AE@%%@NL@%
IF Font < 0 OR Font > FGP.TotalRegistered THEN%@NL@%
        flSetFontErr cBadFontNumber%@NL@%
        EXIT SUB%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' All OK, assign values from internal font header:%@AE@%%@NL@%
FI.FontNum = Font%@NL@%
FI.Ascent = FontHdrReg(Font).FontHeader.dfAscent%@NL@%
FI.Points = FontHdrReg(Font).FontHeader.dfPoints%@NL@%
FI.PixWidth = FontHdrReg(Font).FontHeader.dfPixWidth%@NL@%
FI.PixHeight = FontHdrReg(Font).FontHeader.dfPixHeight%@NL@%
FI.Leading = FontHdrReg(Font).FontHeader.dfInternalLeading%@NL@%
FI.MaxWidth = FontHdrReg(Font).FontHeader.dfMaxWidth%@NL@%
FI.AvgWidth = FontHdrReg(Font).FontHeader.dfAvgWidth%@NL@%
FI.FileName = FontHdrReg(Font).FileName%@NL@%
FI.FaceName = FontHdrReg(Font).FaceName%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== GetTotalFonts - Gets the total number of fonts that currently registered%@AE@%%@NL@%
%@AB@%'                    and loaded by the font library:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Registered  -  The total number of fonts registered by the font%@AE@%%@NL@%
%@AB@%'                    library%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Loaded      -  The total number of fonts loaded by the font library%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB GetTotalFonts (Registered AS INTEGER, Loaded AS INTEGER)%@NL@%
SHARED FGP AS GlobalParams%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
%@AB@%' Simply return the values of internal variables:%@AE@%%@NL@%
Registered = FGP.TotalRegistered%@NL@%
Loaded = FGP.TotalLoaded%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== GTextWindow - Communicates the current WINDOW to fontlib%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     X1    -  Minimum X value%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y1    -  Minimum Y value%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     X2    -  Maximum X value%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y2    -  Maximum Y value%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Scrn% -  cTRUE means that window Y values increase top to bottom%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Remarks:%@AE@%%@NL@%
%@AB@%'     Calling this with X1=X2 or Y1=Y2 will clear the current%@AE@%%@NL@%
%@AB@%'     window.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB GTextWindow (X1 AS SINGLE, Y1 AS SINGLE, X2 AS SINGLE, Y2 AS SINGLE, Scrn%)%@NL@%
SHARED FGP AS GlobalParams%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
%@AB@%' Save the window values in global variable:%@AE@%%@NL@%
FGP.WX1 = X1%@NL@%
FGP.WY1 = Y1%@NL@%
FGP.WX2 = X2%@NL@%
FGP.WY2 = Y2%@NL@%
FGP.WScrn = Scrn%%@NL@%
%@NL@%
%@AB@%' If window is valid then flag it as set:%@AE@%%@NL@%
FGP.WindowSet = ((X2 - X1) <> 0) AND ((Y2 - Y1) <> 0)%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== LoadFont - Loads one or more fonts according to specification string%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     SpecTxt$ -  String containing parameters specifying one or more%@AE@%%@NL@%
%@AB@%'                 fonts to load (see notes below)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     The number of fonts loaded%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Notes:%@AE@%%@NL@%
%@AB@%'     A spec. can contain the following parameters in any order.%@AE@%%@NL@%
%@AB@%'     Parameters are each one character immediately followed by a value%@AE@%%@NL@%
%@AB@%'     if called for. Multiple specifications may be entered separated%@AE@%%@NL@%
%@AB@%'     by slash (/) characters. Loadfont will search for the FIRST font in%@AE@%%@NL@%
%@AB@%'     the list of registered fonts that matches each spec. and load it. If%@AE@%%@NL@%
%@AB@%'     no font matches a specification registered font number one will be%@AE@%%@NL@%
%@AB@%'     used. If a given font is selected by more than one spec in the list%@AE@%%@NL@%
%@AB@%'     it will only be loaded once. When this routine is called all%@AE@%%@NL@%
%@AB@%'     previous fonts will be discarded:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'        T  -  followed by a blank-terminated name loads font by%@AE@%%@NL@%
%@AB@%'              specified name%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'        F  -  No value. Selects only fixed pitch fonts%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'        P  -  No value. Selects only proportional fonts%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'        S  -  Followed by number specifies desired point size%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'        M  -  Followed by number specifies the screen mode font will be%@AE@%%@NL@%
%@AB@%'              used on. This is used in conjunction with the "S" parameter%@AE@%%@NL@%
%@AB@%'              above to select appropriately sized font.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'        H  -  Followed by number specifies the pixel height of%@AE@%%@NL@%
%@AB@%'              font to select. "S" overrides this.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'        N  -  Followed by number selects specific font number%@AE@%%@NL@%
%@AB@%'              from the list of currently registered fonts.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'        R  -  Selects font stored in RAM memory%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION LoadFont% (SpecTxt$) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
DIM FSpec AS FontSpec%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding errors and check for valid max limits:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
flChkMax%@NL@%
%@NL@%
%@AB@%' Make sure there's room to load a font:%@AE@%%@NL@%
IF FGP.TotalLoaded >= FGP.MaxLoaded THEN%@NL@%
        flSetFontErr cTooManyFonts%@NL@%
        EXIT FUNCTION%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Make sure there are some registered fonts to look through:%@AE@%%@NL@%
IF FGP.TotalRegistered <= 0 THEN%@NL@%
        flSetFontErr cNoFonts%@NL@%
        EXIT FUNCTION%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Process each spec in the spec string:%@AE@%%@NL@%
Slot% = 1%@NL@%
ChPos% = 1%@NL@%
DO UNTIL Slot% > FGP.MaxLoaded%@NL@%
%@NL@%
%@AB@%        ' Initialize the spec structure:%@AE@%%@NL@%
        flInitSpec FSpec%@NL@%
%@NL@%
%@AB@%        ' Get next spec from string (Found will be false if no spec found):%@AE@%%@NL@%
        SpecStatus% = flGetNextSpec(SpecTxt$, ChPos%, FSpec)%@NL@%
        SELECT CASE SpecStatus%%@NL@%
                CASE 0:%@NL@%
                CASE 1: EXIT DO%@NL@%
                CASE 2: flSetFontErr cBadFontSpec%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Try to match font. Set font to one if none match:%@AE@%%@NL@%
        FontNum% = flMatchFont(FSpec)%@NL@%
        IF FontNum% < 1 THEN%@NL@%
                flSetFontErr cFontNotFound%@NL@%
                FontNum% = 1%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' Record font in font load list:%@AE@%%@NL@%
        FontLoadList(Slot%) = FontNum%%@NL@%
        Slot% = Slot% + 1%@NL@%
LOOP%@NL@%
%@NL@%
%@AB@%' Now actually get the fonts in the load list:%@AE@%%@NL@%
FGP.TotalLoaded = flGetFonts(Slot% - 1)%@NL@%
FGP.CurrentFont = 1%@NL@%
%@NL@%
%@AB@%' Select the first font by default (pass outstanding font errors around%@AE@%%@NL@%
%@AB@%' it):%@AE@%%@NL@%
HoldErr% = FontErr%@NL@%
SelectFont cDefaultFont%@NL@%
IF HoldErr% <> 0 THEN flSetFontErr HoldErr%%@NL@%
%@NL@%
LoadFont = FGP.TotalLoaded%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== OutGText - Outputs graphics text to the screen%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     X        -  X location of upper left of char box%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Y        -  Y location of upper left of char box%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Text$    -  Text string to output%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Length of text output, Values of X and Y are updated%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION OutGText% (X AS SINGLE, Y AS SINGLE, Text$) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
SHARED FontHdrLoaded() AS IFontInfo%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
%@AB@%' Make sure fonts are loaded:%@AE@%%@NL@%
IF FGP.TotalLoaded <= 0 THEN%@NL@%
        flSetFontErr cNoFonts%@NL@%
        EXIT FUNCTION%@NL@%
END IF%@NL@%
%@NL@%
IF NOT FGP.CharColorInit THEN SetGTextColor cDefaultColor%@NL@%
IF NOT FGP.CharDirInit THEN SetGTextDir cDefaultDir%@NL@%
%@NL@%
%@AB@%' Make sure a graphic mode is set:%@AE@%%@NL@%
flGetCurrentScrnSize XP%, YP%%@NL@%
IF XP% = 0 THEN EXIT FUNCTION%@NL@%
%@NL@%
%@AB@%' Save input location to working variables and erase any window setting:%@AE@%%@NL@%
IX% = PMAP(X, 0)%@NL@%
IY% = PMAP(Y, 1)%@NL@%
WINDOW%@NL@%
%@NL@%
%@AB@%' Map chars to valid ones and output them adding their lengths:%@AE@%%@NL@%
TextLen% = 0%@NL@%
FOR Char% = 1 TO LEN(Text$)%@NL@%
        ChVal% = ASC(MID$(Text$, Char%, 1))%@NL@%
        IF FGP.CharSet = cIBMChars THEN ChVal% = flANSI(ChVal%)%@NL@%
%@NL@%
        IF FGP.FontSource = cFileFont THEN%@NL@%
                BitMapPtr% = VARPTR(FontData(FGP.DSeg))%@NL@%
                BitMapSeg% = VARSEG(FontData(FGP.DSeg))%@NL@%
        ELSE%@NL@%
                BitMapPtr% = FGP.DOffset%@NL@%
                BitMapSeg% = FGP.DSeg%@NL@%
        END IF%@NL@%
%@NL@%
        CharLen% = flbltchar%(BitMapSeg%, BitMapPtr%, ChVal%, IX%, IY%)%@NL@%
%@NL@%
        IX% = IX% + FGP.XPixInc * CharLen%%@NL@%
        IY% = IY% + FGP.YPixInc * CharLen%%@NL@%
%@NL@%
        TextLen% = TextLen% + CharLen%%@NL@%
NEXT Char%%@NL@%
%@NL@%
%@AB@%' Reset window:%@AE@%%@NL@%
IF FGP.WindowSet THEN%@NL@%
        IF FGP.WScrn% THEN%@NL@%
                WINDOW SCREEN (FGP.WX1, FGP.WY1)-(FGP.WX2, FGP.WY2)%@NL@%
        ELSE%@NL@%
                WINDOW (FGP.WX1, FGP.WY1)-(FGP.WX2, FGP.WY2)%@NL@%
        END IF%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Update locations%@AE@%%@NL@%
X = PMAP(IX%, 2)%@NL@%
Y = PMAP(IY%, 3)%@NL@%
%@NL@%
%@AB@%' Return total character length:%@AE@%%@NL@%
OutGText = TextLen%%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== RegisterFonts - Loads header information from font resources:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     FileName$   -  Path name for font file to register%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Value:%@AE@%%@NL@%
%@AB@%'     The number of fonts actually registered%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Notes:%@AE@%%@NL@%
%@AB@%'     Offsets documented in Windows document assume the file's first%@AE@%%@NL@%
%@AB@%'     byte is byte 0 (zero) and GET assumes the first byte is byte 1 so%@AE@%%@NL@%
%@AB@%'     many GET locations are expressed in the following code as%@AE@%%@NL@%
%@AB@%'     a documented offset + 1.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION RegisterFonts% (FileName$) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
DIM Byte AS STRING * 1%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear errors and make sure things are initialized:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
flChkMax%@NL@%
%@NL@%
%@AB@%' Get next available file number:%@AE@%%@NL@%
FileNum% = FREEFILE%@NL@%
%@NL@%
%@AB@%' Try to open the file for input first to make sure the file exists. This%@AE@%%@NL@%
%@AB@%' is done to avoid creating a zero length file if the file doesn't exist.%@AE@%%@NL@%
ON ERROR GOTO NoFileErr%@NL@%
OPEN FileName$ FOR INPUT AS FileNum%%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
IF FontErr <> 0 THEN%@NL@%
        RegisterFonts = 0%@NL@%
        EXIT FUNCTION%@NL@%
END IF%@NL@%
CLOSE FileNum%%@NL@%
%@NL@%
%@AB@%' File seems to exist, so open it in binary mode:%@AE@%%@NL@%
OPEN FileName$ FOR BINARY ACCESS READ AS FileNum%%@NL@%
%@NL@%
%@AB@%' Get the byte that indicates whether this file has a new-style%@AE@%%@NL@%
%@AB@%' header on it. If not, then error:%@AE@%%@NL@%
GET FileNum%, &H18 + 1, Byte%@NL@%
IF ASC(Byte) <> &H40 THEN%@NL@%
        flSetFontErr cBadFontFile%@NL@%
        CLOSE FileNum%%@NL@%
        EXIT FUNCTION%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Save the number of fonts currently registered for use later in%@AE@%%@NL@%
%@AB@%' calculating the number of fonts registered by this call:%@AE@%%@NL@%
OldTotal = FGP.TotalRegistered%@NL@%
%@NL@%
%@AB@%' Get the pointer to the new-style header:%@AE@%%@NL@%
GET FileNum%, &H3C + 1, Word%%@NL@%
NewHdr% = Word%%@NL@%
%@NL@%
%@AB@%' Get pointer to resource table:%@AE@%%@NL@%
GET FileNum%, Word% + &H22 + 1, Word%%@NL@%
ResourceEntry# = NewHdr% + Word% + 1%@NL@%
%@NL@%
%@AB@%' Get the alignment shift count from beginning of table:%@AE@%%@NL@%
GET FileNum%, ResourceEntry#, Align%%@NL@%
%@NL@%
%@AB@%' Loop, registering font resources until they have run out:%@AE@%%@NL@%
DO%@NL@%
        ResType% = flDoNextResource(Align%, FileName$, FileNum%)%@NL@%
        IF FontErr <> 0 THEN EXIT DO%@NL@%
LOOP UNTIL ResType% = 0%@NL@%
%@NL@%
CLOSE FileNum%%@NL@%
%@NL@%
%@AB@%' Finally, return number of fonts actually registered:%@AE@%%@NL@%
RegisterFonts = FGP.TotalRegistered - OldTotal%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== RegisterMemFont - Loads header information from a memory-resident font%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     FontSeg%    -  Segment address of font to register%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     FontOffset% -  Offset address of font to register%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Value:%@AE@%%@NL@%
%@AB@%'     The number of fonts actually registered (0 or 1)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Notes:%@AE@%%@NL@%
%@AB@%'     Memory resident fonts cannot be stored in BASIC relocatable data%@AE@%%@NL@%
%@AB@%'     structures (like arrays or non-fixed strings).%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
FUNCTION RegisterMemFont% (FontSeg AS INTEGER, FontOffset AS INTEGER) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
SHARED FontHdrReg() AS IFontInfo%@NL@%
DIM FontHeader AS WFHeader%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear error and check max limits:%@AE@%%@NL@%
flClearFontErr%@NL@%
flChkMax%@NL@%
%@NL@%
%@AB@%' Get the font header:%@AE@%%@NL@%
flMovMem FontHeader, FontSeg, FontOffset, cSizeFontHeader%@NL@%
%@NL@%
%@AB@%' Only register vector fonts:%@AE@%%@NL@%
IF FontHeader.dfType AND &H1 <> cBitMapType THEN%@NL@%
        flSetFontErr cBadFontType%@NL@%
        RegisterMemFont = 0%@NL@%
        EXIT FUNCTION%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' See that we're still within MaxRegistered limits:%@AE@%%@NL@%
IF FGP.TotalRegistered >= FGP.MaxRegistered THEN%@NL@%
        flSetFontErr cTooManyFonts%@NL@%
        RegisterMemFont = 0%@NL@%
        EXIT FUNCTION%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Go to next "registered" font slot:%@AE@%%@NL@%
FGP.TotalRegistered = FGP.TotalRegistered + 1%@NL@%
%@NL@%
%@AB@%' Set font source and save the header:%@AE@%%@NL@%
FontHdrReg(FGP.TotalRegistered).FontSource = cMemFont%@NL@%
FontHdrReg(FGP.TotalRegistered).FontHeader = FontHeader%@NL@%
%@NL@%
%@AB@%' Set font location in memory:%@AE@%%@NL@%
FontHdrReg(FGP.TotalRegistered).DataSeg = FontSeg%@NL@%
FontHdrReg(FGP.TotalRegistered).DataOffset = FontOffset + cSizeFontHeader%@NL@%
%@NL@%
%@AB@%' Get the face name (scan characters until zero byte):%@AE@%%@NL@%
FaceLoc% = FontOffset + FontHeader.dfFace%@NL@%
FaceName$ = ""%@NL@%
DEF SEG = FontSeg%@NL@%
FOR Char% = 0 TO cMaxFaceName - 1%@NL@%
        Byte% = PEEK(FaceLoc% + Char%)%@NL@%
        IF Byte% = 0 THEN EXIT FOR%@NL@%
        FaceName$ = FaceName$ + CHR$(Byte%)%@NL@%
NEXT Char%%@NL@%
FontHdrReg(FGP.TotalRegistered).FaceName = FaceName$%@NL@%
%@NL@%
%@AB@%' Finally, return number of fonts actually registered:%@AE@%%@NL@%
RegisterMemFont = 1%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=== SelectFont - Selects current font from among loaded fonts%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     FontNum% -  Font number to select%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB SelectFont (FontNum AS INTEGER) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
%@AB@%' If no fonts are loaded then error:%@AE@%%@NL@%
IF FGP.TotalLoaded <= 0 THEN%@NL@%
        flSetFontErr cNoFonts%@NL@%
        EXIT SUB%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Now, map the font number to an acceptable one and select it:%@AE@%%@NL@%
IF FontNum <= 0 THEN%@NL@%
        FGP.CurrentFont = 1%@NL@%
ELSE%@NL@%
        FGP.CurrentFont = (ABS(FontNum - 1) MOD (FGP.TotalLoaded)) + 1%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Get First, Last and Default character params from header:%@AE@%%@NL@%
FGP.FChar = ASC(FontHdrLoaded(FGP.CurrentFont).FontHeader.dfFirstChar)%@NL@%
FGP.LChar = ASC(FontHdrLoaded(FGP.CurrentFont).FontHeader.dfLastChar)%@NL@%
FGP.DChar = ASC(FontHdrLoaded(FGP.CurrentFont).FontHeader.dfDefaultChar)%@NL@%
FGP.CHeight = FontHdrLoaded(FGP.CurrentFont).FontHeader.dfPixHeight%@NL@%
flSetBltParams cSizeFontHeader, FGP.CHeight, FGP.FChar, FGP.LChar, FGP.DChar%@NL@%
%@NL@%
%@AB@%' Set some other commonly used elements of font info:%@AE@%%@NL@%
FGP.DSeg = FontHdrLoaded(FGP.CurrentFont).DataSeg%@NL@%
FGP.DOffset = FontHdrLoaded(FGP.CurrentFont).DataOffset%@NL@%
FGP.FontSource = FontHdrLoaded(FGP.CurrentFont).FontSource%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== SetGCharset - Specifies IBM or Windows char set%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Charset%    -  cIBMChars for IBM character mappings%@AE@%%@NL@%
%@AB@%'                    cWindowsChars for Windows character mappings%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB SetGCharset (CharSet AS INTEGER) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
IF CharSet = cWindowsChars THEN%@NL@%
        FGP.CharSet = cWindowsChars%@NL@%
ELSE%@NL@%
        FGP.CharSet = cIBMChars%@NL@%
END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== SetGTextColor - Sets color for drawing characters%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     FColor   -  Color number%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB SetGTextColor (FColor AS INTEGER) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
FGP.CharColor = ABS(FColor)%@NL@%
flSetBltColor FGP.CharColor%@NL@%
FGP.CharColorInit = cTRUE%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== SetGTextDir - Sets character direction for OutGText%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Dir   -  Character direction:%@AE@%%@NL@%
%@AB@%'              0 = Horizontal-Right%@AE@%%@NL@%
%@AB@%'              1 = Vertical-Up%@AE@%%@NL@%
%@AB@%'              2 = Horizontal-Left%@AE@%%@NL@%
%@AB@%'              3 = Vertical-Down%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB SetGTextDir (Dir AS INTEGER) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
SELECT CASE Dir%@NL@%
%@NL@%
%@AB@%        ' Vertical - up%@AE@%%@NL@%
        CASE 1:  FGP.XPixInc% = 0%@NL@%
                                FGP.YPixInc% = -1%@NL@%
                                XRowInc% = 1%@NL@%
                                YRowInc% = 0%@NL@%
                                FGP.CharDir = 1%@NL@%
%@NL@%
%@AB@%        ' Horizontal -left%@AE@%%@NL@%
        CASE 2:  FGP.XPixInc% = -1%@NL@%
                                FGP.YPixInc% = 0%@NL@%
                                XRowInc% = 0%@NL@%
                                YRowInc% = -1%@NL@%
                                FGP.CharDir = 2%@NL@%
%@NL@%
%@AB@%        ' Vertical - down%@AE@%%@NL@%
        CASE 3:  FGP.XPixInc% = 0%@NL@%
                                FGP.YPixInc% = 1%@NL@%
                                XRowInc% = -1%@NL@%
                                YRowInc% = 0%@NL@%
                                FGP.CharDir = 3%@NL@%
%@NL@%
%@AB@%        ' Horizontal - right%@AE@%%@NL@%
        CASE ELSE:  FGP.XPixInc% = 1%@NL@%
                                        FGP.YPixInc% = 0%@NL@%
                                        XRowInc% = 0%@NL@%
                                        YRowInc% = 1%@NL@%
                                        FGP.CharDir = 0%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%        ' Call routine to set these increments in the char output routine%@AE@%%@NL@%
        flSetBltDir FGP.XPixInc%, FGP.YPixInc%, XRowInc%, YRowInc%%@NL@%
        FGP.CharDirInit = cTRUE%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== SetMaxFonts - Sets the maximum number of fonts that can be registered%@AE@%%@NL@%
%@AB@%'                  and loaded by the font library:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     Registered  -  The maximum number of fonts that can be registered%@AE@%%@NL@%
%@AB@%'                    by the font library%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     Loaded      -  The maximum number of fonts that can be loaded by%@AE@%%@NL@%
%@AB@%'                    by the font library%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Return Values:%@AE@%%@NL@%
%@AB@%'     Sets error if values are not positive. Adjusts MaxReg and MaxLoad%@AE@%%@NL@%
%@AB@%'     internal values and resets the length of FontHdrReg and FontHdrLoad%@AE@%%@NL@%
%@AB@%'     arrays if the new value is different from previous one%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB SetMaxFonts (Registered AS INTEGER, Loaded AS INTEGER) STATIC%@NL@%
SHARED FGP AS GlobalParams%@NL@%
SHARED FontHdrReg() AS IFontInfo%@NL@%
SHARED FontHdrLoaded() AS IFontInfo%@NL@%
SHARED FontLoadList() AS INTEGER%@NL@%
SHARED FontData() AS FontDataBlock%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
%@AB@%' Check to see that values are within range:%@AE@%%@NL@%
IF Registered <= 0 OR Loaded <= 0 THEN%@NL@%
        flSetFontErr cBadFontLimit%@NL@%
        EXIT SUB%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Values are ostensibly OK. Reset values and redimension arrays:%@AE@%%@NL@%
%@AB@%' Reset values for registered fonts:%@AE@%%@NL@%
FGP.TotalRegistered = 0%@NL@%
FGP.MaxRegistered = Registered%@NL@%
%@NL@%
ON ERROR GOTO MemErr%@NL@%
REDIM FontHdrReg(1 TO FGP.MaxRegistered) AS IFontInfo%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Reset values for loaded fonts:%@AE@%%@NL@%
FGP.TotalLoaded = 0%@NL@%
FGP.MaxLoaded = Loaded%@NL@%
%@NL@%
ON ERROR GOTO MemErr%@NL@%
REDIM FontLoadList(1 TO FGP.MaxLoaded) AS INTEGER%@NL@%
REDIM FontHdrLoaded(1 TO FGP.MaxLoaded) AS IFontInfo%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear font data array:%@AE@%%@NL@%
ERASE FontData%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'=== UnRegisterFonts - Erases registered font header array and resets%@AE@%%@NL@%
%@AB@%'                      total registered fonts to 0:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Arguments:%@AE@%%@NL@%
%@AB@%'     ErrNum   -  The error number to set FontErr variable to%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'=================================================================%@AE@%%@NL@%
SUB UnRegisterFonts STATIC%@NL@%
SHARED FontHdrReg() AS IFontInfo, FGP AS GlobalParams%@NL@%
%@NL@%
ON ERROR GOTO UnexpectedErr%@NL@%
%@NL@%
%@AB@%' Clear outstanding font errors:%@AE@%%@NL@%
flClearFontErr%@NL@%
%@NL@%
REDIM FontHdrReg(1 TO 1)  AS IFontInfo%@NL@%
FGP.MaxRegistered = UBOUND(FontHdrReg, 1)%@NL@%
FGP.TotalRegistered = 0%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FONTDEMO.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\FONTDEMO.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'       FONTDEMO.BAS - FONTB demonstration program.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Copyright (C) 1989 Microsoft Corporation, All Rights Reserved%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  This program demonstrates some of the capabilities of the fonts%@AE@%%@NL@%
%@AB@%'  toolbox.  It loads font files found in the current directory and%@AE@%%@NL@%
%@AB@%'  and allows you to select a font for display.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  The following font files are provided with BASIC 7.0:%@AE@%%@NL@%
%@AB@%'     - Raster fonts designed for screen resolution of 640x200%@AE@%%@NL@%
%@AB@%'           COURA.FON%@AE@%%@NL@%
%@AB@%'           HELVA.FON%@AE@%%@NL@%
%@AB@%'           TMSRA.FON%@AE@%%@NL@%
%@AB@%'     - Raster fonts designed for screen resolution of 640x350%@AE@%%@NL@%
%@AB@%'           COURB.FON%@AE@%%@NL@%
%@AB@%'           HELVB.FON%@AE@%%@NL@%
%@AB@%'           TMSRB.FON%@AE@%%@NL@%
%@AB@%'     - Raster fonts designed for screen resolution of 640x480%@AE@%%@NL@%
%@AB@%'           COURE.FON%@AE@%%@NL@%
%@AB@%'           HELVE.FON%@AE@%%@NL@%
%@AB@%'           TMSRE.FON%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' $INCLUDE: 'FONTB.BI'%@AE@%%@NL@%
CONST TRUE = -1%@NL@%
CONST FALSE = 0%@NL@%
DECLARE SUB DriveScreen ()%@NL@%
DECLARE SUB GetFiles ()%@NL@%
DECLARE SUB GetModes ()%@NL@%
DECLARE SUB ShowScreen ()%@NL@%
%@NL@%
DIM SHARED FI AS FontInfo%@NL@%
DIM SHARED totalmodes AS INTEGER%@NL@%
DIM SHARED modes(1 TO 13) AS INTEGER%@NL@%
DIM SHARED fontfiles(1 TO 18) AS STRING%@NL@%
DIM SHARED totalfonts AS INTEGER%@NL@%
DIM SHARED currentfont AS INTEGER%@NL@%
DIM SHARED currentmode AS INTEGER%@NL@%
GetModes%@NL@%
GetFiles%@NL@%
currentfont = 1%@NL@%
DO%@NL@%
    DriveScreen%@NL@%
    ShowScreen%@NL@%
LOOP%@NL@%
END%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'DriveScreen displays the lists of available fonts and screen modes and%@AE@%%@NL@%
%@AB@%'scrolls through them with arrow keys.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB DriveScreen STATIC%@NL@%
IF init% = 0 THEN%@NL@%
    set$ = "f"%@NL@%
    max% = totalfonts%@NL@%
    posit% = currentfont%@NL@%
    modedim$ = "320x200640x200720x348640x400              320x200"%@NL@%
    modedim$ = modedim$ + "640x200640x350640x350640x480640x480320x200"%@NL@%
%@NL@%
%@AB@%    'Check if monitor supports color or mono.%@AE@%%@NL@%
%@NL@%
    SELECT CASE modes(1)%@NL@%
        CASE 13, 9, 8, 7%@NL@%
            mode$ = "color"%@NL@%
        CASE 3, 4, 10%@NL@%
            mode$ = "mono"%@NL@%
        CASE 2%@NL@%
            IF modes(2) = 1 THEN%@NL@%
                mode$ = "color"%@NL@%
            ELSE%@NL@%
                mode$ = "mono"%@NL@%
            END IF%@NL@%
    END SELECT%@NL@%
    FOR i% = 1 TO totalmodes%@NL@%
        IF modes(i%) = 4 THEN mode$ = "mono"%@NL@%
    NEXT i%%@NL@%
%@NL@%
%@AB@%    'Set colors based on type of monitor.%@AE@%%@NL@%
%@NL@%
    SELECT CASE mode$%@NL@%
        CASE "color"%@NL@%
            listfore% = 7%@NL@%
            listback% = 0%@NL@%
            titleon% = 15%@NL@%
            titleoff% = 7%@NL@%
            titleback% = 1%@NL@%
            back% = 1%@NL@%
            high% = 15%@NL@%
        CASE "mono"%@NL@%
            listfore% = 7%@NL@%
            listback% = 0%@NL@%
            titleon% = 0%@NL@%
            titleoff% = 2%@NL@%
            titleback% = 7%@NL@%
            back% = 0%@NL@%
            high% = 7%@NL@%
    END SELECT%@NL@%
    init% = 1%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%'Display the screen with the current selections.%@AE@%%@NL@%
%@NL@%
SCREEN 0%@NL@%
WIDTH 80, 25%@NL@%
LOCATE , , 0: COLOR 0, back%%@NL@%
PRINT SPACE$(1920)%@NL@%
LOCATE 2, 1: COLOR high%, back%%@NL@%
PRINT "  Font Toolbox Demo"%@NL@%
COLOR titleoff%, back%%@NL@%
PRINT "  Copyright (C) 1989 Microsoft Corporation"%@NL@%
LOCATE 22, 1: COLOR titleoff%, back%%@NL@%
PRINT SPC(55); "<CR> to view fontfile"%@NL@%
PRINT SPC(55); "ESC to exit"%@NL@%
%@NL@%
GOSUB swaptitles%@NL@%
GOSUB swaptitles%@NL@%
FOR i% = 1 TO totalfonts%@NL@%
    LOCATE 5 + i%, 20%@NL@%
    COLOR listfore%, listback%%@NL@%
    PRINT LEFT$(fontfiles(i%) + "       ", 12)%@NL@%
NEXT i%%@NL@%
LOCATE 5 + currentfont, 20%@NL@%
COLOR listback%, listfore%%@NL@%
PRINT LEFT$(fontfiles(currentfont) + "       ", 12)%@NL@%
%@NL@%
FOR i% = 1 TO totalmodes%@NL@%
    LOCATE 5 + i%, 50%@NL@%
    COLOR listfore%, listback%%@NL@%
    PRINT LEFT$(STR$(modes(i%)) + "   ", 4) + MID$(modedim$, 7 * modes(i%) - 6, 7)%@NL@%
NEXT i%%@NL@%
LOCATE 5 + currentmode, 50%@NL@%
COLOR listback%, listfore%%@NL@%
PRINT LEFT$(STR$(modes(currentmode)) + "   ", 4) + MID$(modedim$, 7 * modes(currentmode) - 6, 7)%@NL@%
%@NL@%
%@AB@%'Scroll through choices%@AE@%%@NL@%
%@NL@%
DO%@NL@%
    SELECT CASE INKEY$%@NL@%
        CASE CHR$(0) + CHR$(72)%@NL@%
            GOSUB upone%@NL@%
        CASE CHR$(0) + CHR$(80)%@NL@%
            GOSUB downone%@NL@%
        CASE CHR$(9), CHR$(0) + CHR$(15), CHR$(0) + CHR$(75), CHR$(0) + CHR$(77)%@NL@%
            GOSUB swaptitles%@NL@%
        CASE CHR$(13), CHR$(32): EXIT DO%@NL@%
        CASE CHR$(27)%@NL@%
          COLOR 15, 0%@NL@%
          CLS%@NL@%
          END%@NL@%
    END SELECT%@NL@%
LOOP%@NL@%
EXIT SUB%@NL@%
%@NL@%
swaptitles:%@NL@%
    IF set$ = "f" THEN%@NL@%
        set$ = "m"%@NL@%
        max% = totalmodes%@NL@%
        posit% = currentmode%@NL@%
        LOCATE 5, 20: COLOR titleoff%, back%%@NL@%
        PRINT "Font files:"%@NL@%
        LOCATE 5, 50: COLOR titleon%, titleback%%@NL@%
        PRINT "Screen Modes:"%@NL@%
    ELSEIF set$ = "m" THEN%@NL@%
        set$ = "f"%@NL@%
        max% = totalfonts%@NL@%
        posit% = currentfont%@NL@%
        LOCATE 5, 20: COLOR titleon%, titleback%%@NL@%
        PRINT "Font files:"%@NL@%
        LOCATE 5, 50: COLOR titleoff%, back%%@NL@%
        PRINT "Screen Modes:"%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
upone:%@NL@%
    oldpos% = posit%%@NL@%
    posit% = (posit% + max% - 2) MOD max% + 1%@NL@%
    GOSUB redraw%@NL@%
RETURN%@NL@%
%@NL@%
downone:%@NL@%
    oldpos% = posit%%@NL@%
    posit% = posit% MOD max% + 1%@NL@%
    GOSUB redraw%@NL@%
RETURN%@NL@%
%@NL@%
redraw:%@NL@%
    IF set$ = "f" THEN%@NL@%
        LOCATE 5 + oldpos%, 20%@NL@%
        COLOR listfore%, listback%%@NL@%
        PRINT LEFT$(fontfiles(oldpos%) + "       ", 12)%@NL@%
        LOCATE 5 + posit%, 20%@NL@%
        COLOR listback%, listfore%%@NL@%
        PRINT LEFT$(fontfiles(posit%) + "       ", 12)%@NL@%
        currentfont = posit%%@NL@%
    ELSE%@NL@%
        LOCATE 5 + oldpos%, 50%@NL@%
        COLOR listfore%, listback%%@NL@%
        PRINT LEFT$(STR$(modes(oldpos%)) + "   ", 4) + MID$(modedim$, 7 * modes(oldpos%) - 6, 7)%@NL@%
        LOCATE 5 + posit%, 50%@NL@%
        COLOR listback%, listfore%%@NL@%
        PRINT LEFT$(STR$(modes(posit%)) + "   ", 4) + MID$(modedim$, 7 * modes(posit%) - 6, 7)%@NL@%
        currentmode = posit%%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'GetFiles finds all *.fon files in the current working directory and checks%@AE@%%@NL@%
%@AB@%'if they are legitimate.  If the files are ok, they are added to files list.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB GetFiles%@NL@%
SCREEN 0%@NL@%
WIDTH 80, 25%@NL@%
tryagain:%@NL@%
CLS%@NL@%
PRINT "Checking fontfiles..."%@NL@%
totalfonts = 0%@NL@%
X$ = DIR$("*.fon")%@NL@%
IF X$ = "" THEN%@NL@%
    PRINT "No font files found in current directory."%@NL@%
    PRINT "Push a shell to change directories? [yn]"%@NL@%
    try$ = "a"%@NL@%
    DO UNTIL INSTR(1, "NYny", try$)%@NL@%
        try$ = INPUT$(1)%@NL@%
    LOOP%@NL@%
    SELECT CASE UCASE$(try$)%@NL@%
        CASE "Y"%@NL@%
            PRINT "Type 'EXIT' to return to demo."%@NL@%
            SHELL%@NL@%
            GOTO tryagain%@NL@%
        CASE "N"%@NL@%
            END%@NL@%
    END SELECT%@NL@%
ELSE%@NL@%
    DO WHILE X$ <> ""%@NL@%
        PRINT "   "; UCASE$(X$); "--";%@NL@%
        SetMaxFonts 10, 10%@NL@%
        Reg% = RegisterFonts(X$)%@NL@%
        IF Reg% = 0 THEN%@NL@%
            PRINT "bad font file"%@NL@%
        ELSE%@NL@%
            totalfonts = totalfonts + 1%@NL@%
            fontfiles(totalfonts) = UCASE$(X$)%@NL@%
            PRINT "OK"%@NL@%
            IF totalfonts = 18 THEN EXIT DO%@NL@%
        END IF%@NL@%
        X$ = DIR$%@NL@%
    LOOP%@NL@%
END IF%@NL@%
SLEEP 1%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'GetModes tries all screen modes from 1-13 to see if they are supported.%@AE@%%@NL@%
%@AB@%'If a mode is supported, it is added to the list of available modes.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB GetModes%@NL@%
ON LOCAL ERROR GOTO badmode%@NL@%
nextactive% = 1%@NL@%
totalmodes = 0%@NL@%
FOR i% = 13 TO 1 STEP -1%@NL@%
    good% = TRUE%@NL@%
    SCREEN i%%@NL@%
    IF good% THEN%@NL@%
        modes(nextactive%) = i%%@NL@%
        nextactive% = nextactive% + 1%@NL@%
        totalmodes = totalmodes + 1%@NL@%
    END IF%@NL@%
NEXT i%%@NL@%
IF totalmodes = 0 THEN%@NL@%
    PRINT "No graphics modes available"%@NL@%
    END%@NL@%
END IF%@NL@%
%@NL@%
IF modes(1) = 13 THEN%@NL@%
    currentmode = 2%@NL@%
ELSE%@NL@%
    currentmode = 1%@NL@%
END IF%@NL@%
EXIT SUB%@NL@%
badmode:%@NL@%
    good% = FALSE%@NL@%
    RESUME NEXT%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'ShowScreen displays all the fonts in the current font file and current%@AE@%%@NL@%
%@AB@%'graphics mode.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ShowScreen%@NL@%
    SetMaxFonts 10, 10%@NL@%
    TotalReg% = RegisterFonts(fontfiles(currentfont))%@NL@%
    SCREEN modes(currentmode)%@NL@%
    PRINT "Please wait..."%@NL@%
%@NL@%
    IF FontErr THEN%@NL@%
        CLS%@NL@%
        PRINT "Unable to continue, FontErr ="; FontErr%@NL@%
        C$ = INPUT$(1)%@NL@%
        EXIT SUB%@NL@%
    END IF%@NL@%
    IF TotalReg% > 10 THEN TotalReg% = 10%@NL@%
%@NL@%
    StrLen% = TotalReg% * 3 - 1%@NL@%
    IF TotalReg% > 9 THEN StrLen% = StrLen% + TotalReg% - 9%@NL@%
    LoadStr$ = LEFT$("N1/N2/N3/N4/N5/N6/N7/N8/N9/N10", StrLen%)%@NL@%
    TotalLoad% = LoadFont(LoadStr$)%@NL@%
%@NL@%
    SELECT CASE modes(currentmode)%@NL@%
        CASE 1: XS% = 160: YS% = 100%@NL@%
        CASE 2: XS% = 320: YS% = 100%@NL@%
        CASE 3: XS% = 360: YS% = 174%@NL@%
        CASE 4: XS% = 320: YS% = 200%@NL@%
        CASE 7: XS% = 160: YS% = 100%@NL@%
        CASE 8: XS% = 320: YS% = 100%@NL@%
        CASE 9: XS% = 320: YS% = 175%@NL@%
        CASE 10: XS% = 320: YS% = 175%@NL@%
        CASE 11: XS% = 320: YS% = 240%@NL@%
        CASE 12: XS% = 320: YS% = 240%@NL@%
        CASE 13: XS% = 160: YS% = 100%@NL@%
    END SELECT%@NL@%
%@NL@%
    prompt$ = "Press any key."%@NL@%
    FOR i% = 1 TO TotalLoad%%@NL@%
        CLS%@NL@%
        SelectFont INT(i%)%@NL@%
        GetFontInfo FI%@NL@%
        SetGTextDir 0%@NL@%
        SetGTextColor 14%@NL@%
        Length% = OutGText(1, 1, RTRIM$(FI.FaceName))%@NL@%
        Length% = OutGText(1, 1 + FI.PixHeight, LTRIM$(STR$(FI.Points) + " Point"))%@NL@%
        FOR Dir% = 0 TO 3%@NL@%
            SetGTextDir Dir%%@NL@%
            SetGTextColor 15 - Dir%%@NL@%
            SELECT CASE Dir%%@NL@%
                CASE 0: X% = XS%: Y% = YS% - FI.PixHeight%@NL@%
                CASE 1: X% = XS% - FI.PixHeight: Y% = YS%%@NL@%
                CASE 2: X% = XS%: Y% = YS% + FI.PixHeight%@NL@%
                CASE 3: X% = XS% + FI.PixHeight: Y% = YS%%@NL@%
            END SELECT%@NL@%
            Length% = OutGText(CSNG(X%), CSNG(Y%), "Microsoft")%@NL@%
        NEXT Dir%%@NL@%
        SelectFont 2%@NL@%
        GetFontInfo FI%@NL@%
        SetGTextColor 14%@NL@%
        SetGTextDir 0%@NL@%
        IF i% = TotalLoad% THEN prompt$ = "Press ESC to go on."%@NL@%
        Length% = GetGTextLen(prompt$)%@NL@%
        Length% = OutGText(2 * XS% - Length% - 10, 2 * YS% - FI.PixHeight - 1, prompt$)%@NL@%
        IF i% = TotalLoad% THEN%@NL@%
            DO UNTIL INKEY$ = CHR$(27): LOOP%@NL@%
        ELSE%@NL@%
            a$ = INPUT$(1)%@NL@%
        END IF%@NL@%
    NEXT i%%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%GENERAL.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\GENERAL.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'============================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     GENERAL.BAS - General Routines for the User Interface Toolbox in%@AE@%%@NL@%
%@AB@%'           Microsoft BASIC 7.0, Professional Development System%@AE@%%@NL@%
%@AB@%'              Copyright (C) 1987-1989, Microsoft Corporation%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  NOTE:    This sample source code toolbox is intended to demonstrate some%@AE@%%@NL@%
%@AB@%'           of the extended capabilities of Microsoft BASIC 7.0 Professional%@AE@%%@NL@%
%@AB@%'           Development system that can help to leverage the professional%@AE@%%@NL@%
%@AB@%'           developer's time more effectively.  While you are free to use,%@AE@%%@NL@%
%@AB@%'           modify, or distribute the routines in this module in any way you%@AE@%%@NL@%
%@AB@%'           find useful, it should be noted that these are examples only and%@AE@%%@NL@%
%@AB@%'           should not be relied upon as a fully-tested "add-on" library.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  PURPOSE: These are the general purpose routines needed by the other%@AE@%%@NL@%
%@AB@%'           modules in the user interface toolbox.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  To create a library and QuickLib containing the routines found%@AE@%%@NL@%
%@AB@%'  in this file, follow these steps:%@AE@%%@NL@%
%@AB@%'       BC /X/FS general.bas%@AE@%%@NL@%
%@AB@%'       LIB general.lib + general + uiasm + qbx.lib;%@AE@%%@NL@%
%@AB@%'       LINK /Q general.lib, general.qlb,,qbxqlb.lib;%@AE@%%@NL@%
%@AB@%'  Creating a library and QuickLib for any of the other UI toolbox files%@AE@%%@NL@%
%@AB@%'  (WINDOW.BAS, MENU.BAS and MOUSE.BAS) is done this way also.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  To create a library and QuickLib containing all routines from%@AE@%%@NL@%
%@AB@%'  the User Interface toolbox follow these steps:%@AE@%%@NL@%
%@AB@%'       BC /X/FS general.bas%@AE@%%@NL@%
%@AB@%'       BC /X/FS window.bas%@AE@%%@NL@%
%@AB@%'       BC /X/FS mouse.bas%@AE@%%@NL@%
%@AB@%'       BC /X/FS menu.bas%@AE@%%@NL@%
%@AB@%'       LIB uitb.lib + general + window + mouse + menu + uiasm + qbx.lib;%@AE@%%@NL@%
%@AB@%'       LINK /Q uitb.lib, uitb.qlb,,qbxqlb.lib;%@AE@%%@NL@%
%@AB@%'  If you are going to use this QuickLib in conjunction with the font source%@AE@%%@NL@%
%@AB@%'  code (FONTB.BAS) or the charting source code (CHRTB.BAS), you need to%@AE@%%@NL@%
%@AB@%'  include the assembly code routines referenced in these files.  For the font%@AE@%%@NL@%
%@AB@%'  routines, perform the following LIB command after creating the library but%@AE@%%@NL@%
%@AB@%'  before creating the QuickLib as described above:%@AE@%%@NL@%
%@AB@%'       LIB uitb.lib + fontasm;%@AE@%%@NL@%
%@AB@%'  For the charting routines, perform the following LIB command after creating%@AE@%%@NL@%
%@AB@%'  the library but before creating the QuickLib as described above:%@AE@%%@NL@%
%@AB@%'       LIB uitb.lib + chrtasm;%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'============================================================================%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
%@AB@%'$INCLUDE: 'general.bi'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'mouse.bi'%@AE@%%@NL@%
%@NL@%
FUNCTION AltToASCII$ (kbd$)%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Converts Alt+A to A,Alt+B to B, etc.  You send it a string.  The right%@AE@%%@NL@%
%@AB@%    ' most character is compared to the string below, and is converted to%@AE@%%@NL@%
%@AB@%    ' the proper character.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
    index = INSTR("xyz{|}~ !" + CHR$(34) + "#$%&,-./012", RIGHT$(kbd$, 1))%@NL@%
%@NL@%
    IF index = 0 THEN%@NL@%
        AltToASCII = ""%@NL@%
    ELSE%@NL@%
        AltToASCII = MID$("1234567890QWERTYUIOPASDFGHJKLZXCVBNM-=", index, 1)%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB Box (row1, col1, row2, col2, fore, back, border$, fillFlag) STATIC%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    '  Use default border if an illegal border$ is passed%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    IF LEN(border$) < 9 THEN%@NL@%
        t$ = " "%@NL@%
    ELSE%@NL@%
        t$ = border$%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Check coordinates for validity, then draw box%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF col1 <= (col2 - 2) AND row1 <= (row2 - 2) AND col1 >= MINCOL AND row1 >= MINROW AND col2 <= MAXCOL AND row2 <= MAXROW THEN%@NL@%
        MouseHide%@NL@%
        BoxWidth = col2 - col1 + 1%@NL@%
        BoxHeight = row2 - row1 + 1%@NL@%
        LOCATE row1, col1%@NL@%
        COLOR fore, back%@NL@%
        PRINT LEFT$(t$, 1); STRING$(BoxWidth - 2, MID$(t$, 2, 1)); MID$(t$, 3, 1)%@NL@%
        LOCATE row2, col1%@NL@%
        PRINT MID$(t$, 7, 1); STRING$(BoxWidth - 2, MID$(t$, 8, 1)); MID$(t$, 9, 1);%@NL@%
%@NL@%
        FOR a = row1 + 1 TO row1 + BoxHeight - 2%@NL@%
            LOCATE a, col1%@NL@%
            PRINT MID$(t$, 4, 1);%@NL@%
%@NL@%
            IF fillFlag THEN%@NL@%
                PRINT STRING$(BoxWidth - 2, MID$(t$, 5, 1));%@NL@%
            ELSE%@NL@%
                LOCATE a, col1 + BoxWidth - 1%@NL@%
            END IF%@NL@%
%@NL@%
            PRINT MID$(t$, 6, 1);%@NL@%
        NEXT a%@NL@%
        LOCATE row1 + 1, col1 + 1%@NL@%
        MouseShow%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB GetBackground (row1, col1, row2, col2, buffer$) STATIC%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Create enough space in buffer$ to hold the screen info behind the box%@AE@%%@NL@%
%@AB@%    ' Then, call GetCopyBox to store the background in buffer$%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF row1 >= 1 AND row2 <= MAXROW AND col1 >= 1 AND col2 <= MAXCOL THEN%@NL@%
        Wid = col2 - col1 + 1%@NL@%
        Hei = row2 - row1 + 1%@NL@%
        size = 4 + (2 * Wid * Hei)%@NL@%
        buffer$ = SPACE$(size)%@NL@%
%@NL@%
        CALL GetCopyBox(row1, col1, row2, col2, buffer$)%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
FUNCTION GetShiftState (bit)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Returns the shift state after calling interrupt 22%@AE@%%@NL@%
%@AB@%    '    bit 0 : right shift%@AE@%%@NL@%
%@AB@%    '        1 : left shift%@AE@%%@NL@%
%@AB@%    '        2 : ctrl key%@AE@%%@NL@%
%@AB@%    '        3 : alt key%@AE@%%@NL@%
%@AB@%    '        4 : scroll lock%@AE@%%@NL@%
%@AB@%    '        5 : num lock%@AE@%%@NL@%
%@AB@%    '        6 : caps lock%@AE@%%@NL@%
%@AB@%    '        7 : insert state%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF bit >= 0 AND bit <= 7 THEN%@NL@%
        DIM regs AS RegType%@NL@%
        regs.ax = 2 * 256%@NL@%
        INTERRUPT 22, regs, regs%@NL@%
%@NL@%
        IF regs.ax AND 2 ^ bit THEN%@NL@%
            GetShiftState = TRUE%@NL@%
        ELSE%@NL@%
            GetShiftState = FALSE%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
        GetShiftState = FALSE%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB PutBackground (row, col, buffer$)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' This sub checks the boundries before executing the put command%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF row >= 1 AND row <= MAXROW AND col >= 1 AND col <= MAXCOL THEN%@NL@%
        CALL PutCopyBox(row, col, buffer$)%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB scroll (row1, col1, row2, col2, lines, attr)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Make sure coordinates are in proper order%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF row1 > row2 THEN%@NL@%
        SWAP row1, row2%@NL@%
    END IF%@NL@%
%@NL@%
    IF col1 > col2 THEN%@NL@%
        SWAP col1, col2%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%     ' ======================================================================%@AE@%%@NL@%
%@AB@%     ' If coordinates are valid, prepare registers, and call interrupt%@AE@%%@NL@%
%@AB@%     ' ======================================================================%@AE@%%@NL@%
%@NL@%
    IF row1 >= MINROW AND row2 <= MAXROW AND col1 >= MINCOL AND col2 <= MAXCOL THEN%@NL@%
        DIM regs AS RegType%@NL@%
%@NL@%
        IF lines < 0 THEN%@NL@%
            regs.ax = 256 * 7 + (-lines)%@NL@%
            regs.bx = 256 * attr%@NL@%
            regs.cx = 256 * (row1 - 1) + (col1 - 1)%@NL@%
            regs.dx = 256 * (row2 - 1) + (col2 - 1)%@NL@%
        ELSE%@NL@%
            regs.ax = 256 * 6 + lines%@NL@%
            regs.bx = 256 * (attr MOD 8) * 16%@NL@%
            regs.cx = 256 * (row1 - 1) + (col1 - 1)%@NL@%
            regs.dx = 256 * (row2 - 1) + (col2 - 1)%@NL@%
        END IF%@NL@%
%@NL@%
        INTERRUPT 16, regs, regs%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%INDEX.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\INDEX.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
%@AB@%' Define the symbolic constants used globally in the program:%@AE@%%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%' Define a record structure for random-file records:%@AE@%%@NL@%
TYPE StockItem%@NL@%
        PartNumber AS STRING * 6%@NL@%
        Description AS STRING * 20%@NL@%
        UnitPrice AS SINGLE%@NL@%
        Quantity AS INTEGER%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' Define a record structure for each element of the index:%@AE@%%@NL@%
TYPE IndexType%@NL@%
        RecordNumber AS INTEGER%@NL@%
        PartNumber AS STRING * 6%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' Declare procedures that will be called:%@AE@%%@NL@%
DECLARE FUNCTION Filter$ (Prompt$)%@NL@%
DECLARE FUNCTION FindRecord% (PartNumber$, RecordVar AS StockItem)%@NL@%
%@NL@%
DECLARE SUB AddRecord (RecordVar AS StockItem)%@NL@%
DECLARE SUB InputRecord (RecordVar AS StockItem)%@NL@%
DECLARE SUB PrintRecord (RecordVar AS StockItem)%@NL@%
DECLARE SUB SortIndex ()%@NL@%
DECLARE SUB ShowPartNumbers ()%@NL@%
%@AB@%' Define a buffer (using the StockItem type)%@AE@%%@NL@%
%@AB@%' and define and dimension the index array:%@AE@%%@NL@%
DIM StockRecord AS StockItem, index(1 TO 100) AS IndexType%@NL@%
%@NL@%
%@AB@%' Open the random-access file:%@AE@%%@NL@%
OPEN "STOCK.DAT" FOR RANDOM AS #1 LEN = LEN(StockRecord)%@NL@%
%@NL@%
%@AB@%' Calculate number of records in the file:%@AE@%%@NL@%
NumberOfRecords = LOF(1) \ LEN(StockRecord)%@NL@%
%@NL@%
%@AB@%' If there are records, read them and build the index:%@AE@%%@NL@%
IF NumberOfRecords <> 0 THEN%@NL@%
        FOR RecordNumber = 1 TO NumberOfRecords%@NL@%
%@NL@%
%@AB@%                ' Read the data from a new record in the file:%@AE@%%@NL@%
                GET #1, RecordNumber, StockRecord%@NL@%
%@NL@%
%@AB@%                ' Place part number and record number in index:%@AE@%%@NL@%
                index(RecordNumber).RecordNumber = RecordNumber%@NL@%
                index(RecordNumber).PartNumber = StockRecord.PartNumber%@NL@%
        NEXT%@NL@%
%@NL@%
        SortIndex            ' Sort index in part-number order.%@NL@%
END IF%@NL@%
%@NL@%
DO                      ' Main-menu loop.%@NL@%
        CLS%@NL@%
        PRINT "(A)dd records."%@NL@%
        PRINT "(L)ook up records."%@NL@%
        PRINT "(Q)uit program."%@NL@%
        PRINT%@NL@%
        LOCATE , , 1%@NL@%
        PRINT "Type your choice (A, L, or Q) here: ";%@NL@%
%@NL@%
%@AB@%        ' Loop until user presses, A, L, or Q:%@AE@%%@NL@%
        DO%@NL@%
                Choice$ = UCASE$(INPUT$(1))%@NL@%
        LOOP WHILE INSTR("ALQ", Choice$) = 0%@NL@%
%@NL@%
%@AB@%        ' Branch according to choice:%@AE@%%@NL@%
        SELECT CASE Choice$%@NL@%
                CASE "A"%@NL@%
         AddRecord StockRecord%@NL@%
                CASE "L"%@NL@%
         IF NumberOfRecords = 0 THEN%@NL@%
                 PRINT : PRINT "No records in file yet. ";%@NL@%
                 PRINT "Press any key to continue.";%@NL@%
                 Pause$ = INPUT$(1)%@NL@%
         ELSE%@NL@%
                 InputRecord StockRecord%@NL@%
         END IF%@NL@%
                CASE "Q"          ' End program.%@NL@%
        END SELECT%@NL@%
LOOP UNTIL Choice$ = "Q"%@NL@%
%@NL@%
CLOSE #1                ' All done, close file and end.%@NL@%
END%@NL@%
%@AB@%' ======================== ADDRECORD ======================%@AE@%%@NL@%
%@AB@%' Adds records to the file from input typed at the keyboard%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@AB@%' ========================= FILTER ========================%@AE@%%@NL@%
%@AB@%'       Filters all non-numeric characters from a string%@AE@%%@NL@%
%@AB@%'       and returns the filtered string%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@AB@%' ======================= FINDRECORD ===================%@AE@%%@NL@%
%@AB@%'  Uses a binary search to locate a record in the index%@AE@%%@NL@%
%@AB@%' ======================================================%@AE@%%@NL@%
%@AB@%' ======================= PRINTRECORD =====================%@AE@%%@NL@%
%@AB@%'                Prints a record on the screen%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@AB@%' ===================== SHOWPARTNUMBERS ===================%@AE@%%@NL@%
%@AB@%' Prints an index of all the part numbers in the upper part%@AE@%%@NL@%
%@AB@%' of the screen%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@AB@%' ========================= SORTINDEX =====================%@AE@%%@NL@%
%@AB@%'                Sorts the index by part number%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
%@NL@%
SUB AddRecord (RecordVar AS StockItem) STATIC%@NL@%
        SHARED index() AS IndexType, NumberOfRecords%@NL@%
        DO%@NL@%
                CLS%@NL@%
                INPUT "Part Number: ", RecordVar.PartNumber%@NL@%
                INPUT "Description: ", RecordVar.Description%@NL@%
%@NL@%
%@AB@%                ' Call the Filter$ FUNCTION to input price & quantity:%@AE@%%@NL@%
                RecordVar.UnitPrice = VAL(Filter$("Unit Price : "))%@NL@%
                RecordVar.Quantity = VAL(Filter$("Quantity   : "))%@NL@%
%@NL@%
                NumberOfRecords = NumberOfRecords + 1%@NL@%
%@NL@%
                PUT #1, NumberOfRecords, RecordVar%@NL@%
%@NL@%
                index(NumberOfRecords).RecordNumber = NumberOfRecords%@NL@%
                index(NumberOfRecords).PartNumber = RecordVar.PartNumber%@NL@%
                PRINT : PRINT "Add another? ";%@NL@%
                OK$ = UCASE$(INPUT$(1))%@NL@%
        LOOP WHILE OK$ = "Y"%@NL@%
%@NL@%
        SortIndex            ' Sort index file again.%@NL@%
END SUB%@NL@%
%@NL@%
FUNCTION Filter$ (Prompt$) STATIC%@NL@%
        ValTemp2$ = ""%@NL@%
        PRINT Prompt$;                    ' Print the prompt passed.%@NL@%
        INPUT "", ValTemp1$               ' Input a number as%@NL@%
%@AB@%                                                                                                 ' a string.%@AE@%%@NL@%
        StringLength = LEN(ValTemp1$)     ' Get the string's length.%@NL@%
        FOR I% = 1 TO StringLength        ' Go through the string,%@NL@%
                Char$ = MID$(ValTemp1$, I%, 1) ' one character at a time.%@NL@%
%@NL@%
%@AB@%                ' Is the character a valid part of a number (i.e.,%@AE@%%@NL@%
%@AB@%                ' a digit or a decimal point)?  If yes, add it to%@AE@%%@NL@%
%@AB@%                ' the end of a new string:%@AE@%%@NL@%
                IF INSTR(".0123456789", Char$) > 0 THEN%@NL@%
                        ValTemp2$ = ValTemp2$ + Char$%@NL@%
%@NL@%
%@AB@%                ' Otherwise, check to see if it's a lowercase "l",%@AE@%%@NL@%
%@AB@%                ' since typewriter users may enter a one that way:%@AE@%%@NL@%
                ELSEIF Char$ = "l" THEN%@NL@%
                        ValTemp2$ = ValTemp2$ + "1" ' Change the "l" to a "1".%@NL@%
                END IF%@NL@%
        NEXT I%%@NL@%
%@NL@%
        Filter$ = ValTemp2$               ' Return filtered string.%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
FUNCTION FindRecord% (Part$, RecordVar AS StockItem) STATIC%@NL@%
        SHARED index() AS IndexType, NumberOfRecords%@NL@%
%@NL@%
%@AB@%        ' Set top and bottom bounds of search:%@AE@%%@NL@%
        TopRecord = NumberOfRecords%@NL@%
        BottomRecord = 1%@NL@%
%@NL@%
%@AB@%        ' Search until top of range is less than bottom:%@AE@%%@NL@%
        DO UNTIL (TopRecord < BottomRecord)%@NL@%
%@NL@%
%@AB@%                ' Choose midpoint:%@AE@%%@NL@%
                Midpoint = (TopRecord + BottomRecord) \ 2%@NL@%
%@NL@%
%@AB@%                ' Test to see if it's the one wanted (RTRIM$()%@AE@%%@NL@%
%@AB@%                ' trims trailing blanks from a fixed string):%@AE@%%@NL@%
                Test$ = RTRIM$(index(Midpoint).PartNumber)%@NL@%
%@NL@%
%@AB@%                ' If it is, exit loop:%@AE@%%@NL@%
                IF Test$ = Part$ THEN%@NL@%
         EXIT DO%@NL@%
%@NL@%
%@AB@%                ' Otherwise, if what we're looking for is greater,%@AE@%%@NL@%
%@AB@%                ' move bottom up:%@AE@%%@NL@%
                ELSEIF Part$ > Test$ THEN%@NL@%
         BottomRecord = Midpoint + 1%@NL@%
%@NL@%
%@AB@%                ' Otherwise, move the top down:%@AE@%%@NL@%
                ELSE%@NL@%
         TopRecord = Midpoint - 1%@NL@%
                END IF%@NL@%
        LOOP%@NL@%
%@NL@%
%@AB@%        ' If part was found, input record from file using%@AE@%%@NL@%
%@AB@%        ' pointer in index and set FindRecord% to TRUE:%@AE@%%@NL@%
        IF Test$ = Part$ THEN%@NL@%
                GET #1, index(Midpoint).RecordNumber, RecordVar%@NL@%
                FindRecord% = TRUE%@NL@%
%@NL@%
%@AB@%        ' Otherwise, if part was not found, set FindRecord%%@AE@%%@NL@%
%@AB@%        ' to FALSE:%@AE@%%@NL@%
        ELSE%@NL@%
                FindRecord% = FALSE%@NL@%
        END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%' ======================= INPUTRECORD =====================%@AE@%%@NL@%
%@AB@%'    First, INPUTRECORD calls SHOWPARTNUMBERS, which prints%@AE@%%@NL@%
%@AB@%'    a menu of part numbers on the top of the screen. Next,%@AE@%%@NL@%
%@AB@%'    INPUTRECORD prompts the user to enter a part number.%@AE@%%@NL@%
%@AB@%'    Finally, it calls the FINDRECORD and PRINTRECORD%@AE@%%@NL@%
%@AB@%'    procedures to find and print the given record.%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
SUB InputRecord (RecordVar AS StockItem) STATIC%@NL@%
        CLS%@NL@%
        ShowPartNumbers      ' Call the ShowPartNumbers SUB.%@NL@%
%@NL@%
%@AB@%        ' Print data from specified records%@AE@%%@NL@%
%@AB@%        ' on the bottom part of the screen:%@AE@%%@NL@%
        DO%@NL@%
                PRINT "Type a part number listed above ";%@NL@%
                INPUT "(or Q to quit) and press <ENTER>: ", Part$%@NL@%
                IF UCASE$(Part$) <> "Q" THEN%@NL@%
         IF FindRecord(Part$, RecordVar) THEN%@NL@%
                 PrintRecord RecordVar%@NL@%
         ELSE%@NL@%
                 PRINT "Part not found."%@NL@%
         END IF%@NL@%
                END IF%@NL@%
                PRINT STRING$(40, "_")%@NL@%
        LOOP WHILE UCASE$(Part$) <> "Q"%@NL@%
%@NL@%
        VIEW PRINT   ' Restore the text viewport to entire screen.%@NL@%
END SUB%@NL@%
%@NL@%
SUB PrintRecord (RecordVar AS StockItem) STATIC%@NL@%
        PRINT "Part Number: "; RecordVar.PartNumber%@NL@%
        PRINT "Description: "; RecordVar.Description%@NL@%
        PRINT USING "Unit Price :$$###.##"; RecordVar.UnitPrice%@NL@%
        PRINT "Quantity   :"; RecordVar.Quantity%@NL@%
END SUB%@NL@%
%@NL@%
SUB ShowPartNumbers STATIC%@NL@%
        SHARED index() AS IndexType, NumberOfRecords%@NL@%
%@NL@%
        CONST NUMCOLS = 8, COLWIDTH = 80 \ NUMCOLS%@NL@%
%@NL@%
%@AB@%        ' At the top of the screen, print a menu indexing all%@AE@%%@NL@%
%@AB@%        ' the part numbers for records in the file. This menu is%@AE@%%@NL@%
%@AB@%        ' printed in columns of equal length (except possibly the%@AE@%%@NL@%
%@AB@%        ' last column, which may be shorter than the others):%@AE@%%@NL@%
        ColumnLength = NumberOfRecords%@NL@%
        DO WHILE ColumnLength MOD NUMCOLS%@NL@%
                ColumnLength = ColumnLength + 1%@NL@%
        LOOP%@NL@%
        ColumnLength = ColumnLength \ NUMCOLS%@NL@%
        Column = 1%@NL@%
        RecordNumber = 1%@NL@%
DO UNTIL RecordNumber > NumberOfRecords%@NL@%
                FOR Row = 1 TO ColumnLength%@NL@%
         LOCATE Row, Column%@NL@%
         PRINT index(RecordNumber).PartNumber%@NL@%
         RecordNumber = RecordNumber + 1%@NL@%
         IF RecordNumber > NumberOfRecords THEN EXIT FOR%@NL@%
                NEXT Row%@NL@%
                Column = Column + COLWIDTH%@NL@%
        LOOP%@NL@%
%@NL@%
        LOCATE ColumnLength + 1, 1%@NL@%
        PRINT STRING$(80, "_")       ' Print separator line.%@NL@%
%@NL@%
%@AB@%        ' Scroll information about records below the part-number%@AE@%%@NL@%
%@AB@%        ' menu (this way, the part numbers are not erased):%@AE@%%@NL@%
        VIEW PRINT ColumnLength + 2 TO 24%@NL@%
END SUB%@NL@%
%@NL@%
SUB SortIndex STATIC%@NL@%
        SHARED index() AS IndexType, NumberOfRecords%@NL@%
%@NL@%
%@AB@%        ' Set comparison offset to half the number of records%@AE@%%@NL@%
%@AB@%        ' in index:%@AE@%%@NL@%
        Offset = NumberOfRecords \ 2%@NL@%
%@NL@%
%@AB@%        ' Loop until offset gets to zero:%@AE@%%@NL@%
        DO WHILE Offset > 0%@NL@%
                Limit = NumberOfRecords - Offset%@NL@%
                DO%@NL@%
%@NL@%
%@AB@%         ' Assume no switches at this offset:%@AE@%%@NL@%
         Switch = FALSE%@NL@%
%@NL@%
%@AB@%         ' Compare elements and switch ones out of order:%@AE@%%@NL@%
         FOR I = 1 TO Limit%@NL@%
                 IF index(I).PartNumber > index(I + Offset).PartNumber THEN%@NL@%
                         SWAP index(I), index(I + Offset)%@NL@%
                         Switch = I%@NL@%
                 END IF%@NL@%
         NEXT I%@NL@%
%@NL@%
%@AB@%         ' Sort on next pass only to where%@AE@%%@NL@%
%@AB@%         ' last switch was made:%@AE@%%@NL@%
         Limit = Switch%@NL@%
                LOOP WHILE Switch%@NL@%
%@NL@%
%@AB@%                ' No switches at last offset, try one half as big:%@AE@%%@NL@%
                Offset = Offset \ 2%@NL@%
        LOOP%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MANDEL.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MANDEL.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z           ' Default variable type is integer.%@NL@%
%@NL@%
DECLARE        SUB ShiftPalette ()%@NL@%
DECLARE        SUB WindowVals (WL%, WR%, WT%, WB%)%@NL@%
DECLARE        SUB ScreenTest (EM%, CR%, VL%, VR%, VT%, VB%)%@NL@%
%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE ' Boolean constants%@NL@%
%@NL@%
%@AB@%' Set maximum number of iterations per point:%@AE@%%@NL@%
CONST MAXLOOP =        30, MAXSIZE = 1000000%@NL@%
%@NL@%
DIM PaletteArray(15)%@NL@%
FOR I =        0 TO 15: PaletteArray(I) = I: NEXT I%@NL@%
%@NL@%
%@AB@%' Call WindowVals to get coordinates of window corners:%@AE@%%@NL@%
WindowVals WLeft, WRight, WTop,        WBottom%@NL@%
%@NL@%
%@AB@%' Call ScreenTest to find out if this is an EGA machine%@AE@%%@NL@%
%@AB@%' and get coordinates of viewport corners:%@AE@%%@NL@%
ScreenTest EgaMode, ColorRange,        VLeft, VRight, VTop, VBottom%@NL@%
%@NL@%
%@AB@%' Define viewport and corresponding window:%@AE@%%@NL@%
VIEW (VLeft, VTop)-(VRight, VBottom), 0, ColorRange%@NL@%
WINDOW (WLeft, WTop)-(WRight, WBottom)%@NL@%
%@NL@%
LOCATE 24, 10 : PRINT "Press any key to quit.";%@NL@%
%@NL@%
XLength        = VRight - VLeft%@NL@%
YLength        = VBottom - VTop%@NL@%
ColorWidth = MAXLOOP \ ColorRange%@NL@%
%@NL@%
%@AB@%' Loop through each pixel in viewport and calculate%@AE@%%@NL@%
%@AB@%' whether or not it is in the Mandelbrot Set:%@AE@%%@NL@%
FOR Y =        0 TO YLength           ' Loop through every line%@NL@%
%@AB@%                           ' in the viewport.%@AE@%%@NL@%
   LogicY = PMAP(Y, 3)           ' Get the pixel's view%@NL@%
%@AB@%                           ' y-coordinate.%@AE@%%@NL@%
   PSET        (WLeft,        LogicY)           ' Plot leftmost pixel in the line.%@NL@%
   OldColor = 0                   ' Start with background color.%@NL@%
%@NL@%
   FOR X = 0 TO        XLength           ' Loop through every pixel%@NL@%
%@AB@%                           ' in the line.%@AE@%%@NL@%
      LogicX = PMAP(X, 2)  ' Get the pixel's view%@NL@%
%@AB@%                           ' x-coordinate.%@AE@%%@NL@%
      MandelX& = LogicX%@NL@%
      MandelY& = LogicY%@NL@%
%@AB@%      ' Do the calculations to see if this point%@AE@%%@NL@%
%@AB@%      ' is in the Mandelbrot Set:%@AE@%%@NL@%
      FOR I = 1        TO MAXLOOP%@NL@%
         RealNum& = MandelX& * MandelX&%@NL@%
         ImagNum& = MandelY& * MandelY&%@NL@%
         IF (RealNum& + ImagNum&) >= MAXSIZE THEN EXIT FOR%@NL@%
         MandelY& = (MandelX& * MandelY&) \ 250 + LogicY%@NL@%
         MandelX& = (RealNum& - ImagNum&) \ 500 + LogicX%@NL@%
      NEXT I%@NL@%
%@NL@%
%@AB@%      '        Assign a color to the point:%@AE@%%@NL@%
      PColor = I \ ColorWidth%@NL@%
%@NL@%
%@AB@%      '        If color has changed, draw a line from%@AE@%%@NL@%
%@AB@%      ' the last point referenced to the new point,%@AE@%%@NL@%
%@AB@%      '        using the old color:%@AE@%%@NL@%
      IF PColor        <> OldColor THEN%@NL@%
         LINE -(LogicX, LogicY), (ColorRange - OldColor)%@NL@%
         OldColor = PColor%@NL@%
      END IF%@NL@%
%@NL@%
      IF INKEY$        <> "" THEN END%@NL@%
   NEXT        X%@NL@%
%@NL@%
%@AB@%   ' Draw the last line        segment        to the right edge%@AE@%%@NL@%
%@AB@%   ' of the viewport:%@AE@%%@NL@%
   LINE        -(LogicX, LogicY), (ColorRange - OldColor)%@NL@%
%@NL@%
%@AB@%   ' If        this is        an EGA machine,        shift the palette after%@AE@%%@NL@%
%@AB@%   ' drawing each line:%@AE@%%@NL@%
   IF EgaMode THEN ShiftPalette%@NL@%
NEXT Y%@NL@%
%@NL@%
DO%@NL@%
%@AB@%   ' Continue shifting the palette%@AE@%%@NL@%
%@AB@%   ' until the user presses a key:%@AE@%%@NL@%
   IF EgaMode THEN ShiftPalette%@NL@%
LOOP WHILE INKEY$ = ""%@NL@%
%@NL@%
SCREEN 0, 0                ' Restore the screen to text mode,%@NL@%
WIDTH 80                ' 80 columns.%@NL@%
END%@NL@%
%@NL@%
BadScreen:                ' Error handler that is invoked if%@NL@%
   EgaMode = FALSE        ' there is no EGA graphics card%@NL@%
   RESUME NEXT%@NL@%
%@AB@%' ====================== ShiftPalette =====================%@AE@%%@NL@%
%@AB@%'    Rotates the palette by one each time it is called%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
SUB ShiftPalette STATIC%@NL@%
   SHARED PaletteArray(), ColorRange%@NL@%
%@NL@%
   FOR I = 1 TO        ColorRange%@NL@%
      PaletteArray(I) =        (PaletteArray(I) MOD ColorRange) + 1%@NL@%
   NEXT        I%@NL@%
   PALETTE USING PaletteArray(0)%@NL@%
%@NL@%
END SUB%@NL@%
%@AB@%' ======================= ScreenTest ======================%@AE@%%@NL@%
%@AB@%'    Uses a SCREEN 8 statement as a test to see if user has%@AE@%%@NL@%
%@AB@%'    EGA hardware. If this causes an error, the EM flag is%@AE@%%@NL@%
%@AB@%'    set to FALSE, and the screen is set with SCREEN 1.%@AE@%%@NL@%
%@NL@%
%@AB@%'    Also sets values for corners of viewport (VL = left,%@AE@%%@NL@%
%@AB@%'    VR = right, VT = top, VB = bottom), scaled with the%@AE@%%@NL@%
%@AB@%'    correct aspect ratio so viewport is a perfect square.%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
SUB ScreenTest (EM, CR,        VL, VR,        VT, VB) STATIC%@NL@%
   EM =        TRUE%@NL@%
   ON ERROR GOTO BadScreen%@NL@%
   SCREEN 8, 1%@NL@%
   ON ERROR GOTO 0%@NL@%
%@NL@%
   IF EM THEN                        ' No error, SCREEN 8 is OK.%@NL@%
      VL = 110: VR = 529%@NL@%
      VT = 5: VB = 179%@NL@%
      CR = 15                        ' 16 colors (0 - 15)%@NL@%
%@NL@%
   ELSE                                ' Error, so use SCREEN 1.%@NL@%
      SCREEN 1,        1%@NL@%
      VL = 55: VR = 264%@NL@%
      VT = 5: VB = 179%@NL@%
      CR = 3                        ' 4 colors (0 - 3)%@NL@%
   END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@AB@%' ======================= WindowVals ======================%@AE@%%@NL@%
%@AB@%'     Gets window corners as input from the user, or sets%@AE@%%@NL@%
%@AB@%'     values for the corners if there is no input%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
SUB WindowVals (WL, WR,        WT, WB)        STATIC%@NL@%
   CLS%@NL@%
   PRINT "This program prints the graphic representation of"%@NL@%
   PRINT "the complete Mandelbrot Set. The default window"%@NL@%
   PRINT "is from (-1000,625) to (250,-625). To zoom in on"%@NL@%
   PRINT "part of the figure, input coordinates inside"%@NL@%
   PRINT "this window."%@NL@%
   PRINT "Press <ENTER> to see the default window or"%@NL@%
   PRINT "any other key to input window coordinates: ";%@NL@%
   LOCATE , , 1%@NL@%
   Resp$ = INPUT$(1)%@NL@%
%@NL@%
%@AB@%   ' User didn't press ENTER, so input window corners:%@AE@%%@NL@%
   IF Resp$ <> CHR$(13)        THEN%@NL@%
      PRINT%@NL@%
      INPUT "x-coordinate of upper-left corner: ", WL%@NL@%
      DO%@NL@%
         INPUT "x-coordinate of lower-right corner: ", WR%@NL@%
         IF WR <= WL THEN%@NL@%
            PRINT "Right corner must be greater than left corner."%@NL@%
         END IF%@NL@%
      LOOP WHILE WR <= WL%@NL@%
      INPUT "y-coordinate of upper-left corner: ", WT%@NL@%
      DO%@NL@%
         INPUT "y-coordinate of lower-right corner: ", WB%@NL@%
         IF WB >= WT THEN%@NL@%
            PRINT "Bottom corner must be less than top corner."%@NL@%
         END IF%@NL@%
      LOOP WHILE WB >= WT%@NL@%
%@NL@%
%@AB@%   ' User pressed ENTER, so set default values:%@AE@%%@NL@%
   ELSE%@NL@%
      WL = -1000%@NL@%
      WR = 250%@NL@%
      WT = 625%@NL@%
      WB = -625%@NL@%
   END IF%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MATB.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MATB.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'*** MATB.BAS - Matrix Math Routines for the Matrix Math Toolbox in%@AE@%%@NL@%
%@AB@%'           Microsoft BASIC 7.0, Professional Development System%@AE@%%@NL@%
%@AB@%'              Copyright (C) 1987-1989, Microsoft Corporation%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  NOTE:  This sample source code toolbox is intended to demonstrate some%@AE@%%@NL@%
%@AB@%'  of the extended capabilities of Microsoft BASIC 7.0 Professional Development%@AE@%%@NL@%
%@AB@%'  system that can help to leverage the professional developer's time more%@AE@%%@NL@%
%@AB@%'  effectively.  While you are free to use, modify, or distribute the routines%@AE@%%@NL@%
%@AB@%'  in this module in any way you find useful, it should be noted that these are%@AE@%%@NL@%
%@AB@%'  examples only and should not be relied upon as a fully-tested "add-on"%@AE@%%@NL@%
%@AB@%'  library.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  Purpose:%@AE@%%@NL@%
%@AB@%'This toolbox contains routines which perform elementary operations on systems%@AE@%%@NL@%
%@AB@%'of linear equations represented as matrices.  The functions return integer%@AE@%%@NL@%
%@AB@%'error codes in the name and results in the parameter list.  The functions%@AE@%%@NL@%
%@AB@%'matbs?% and matlu?% found in this module are intended for internal use only.%@AE@%%@NL@%
%@AB@%'Error codes returned:%@AE@%%@NL@%
%@AB@%'     0  no error                     -1  matrix not invertible%@AE@%%@NL@%
%@AB@%'    -2  matrix not square            -3  inner dimensions different%@AE@%%@NL@%
%@AB@%'    -4  matrix dimensions different  -5  result matrix dimensioned incorrectly%@AE@%%@NL@%
%@AB@%'    any other codes returned are standard BASIC errors%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'-------------------------------------------------------------------%@AE@%%@NL@%
%@AB@%'MatDet, MatSEqn, and MatInv all use LU-decomposition to implement Gaussian%@AE@%%@NL@%
%@AB@%'elimination.  A brief explanation of what is meant by an LU matrix is given%@AE@%%@NL@%
%@AB@%'below, followed by simplified versions of the two internal routines used to%@AE@%%@NL@%
%@AB@%'do all elimination.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'What is meant by an LU matrix:%@AE@%%@NL@%
%@AB@%'An upper triangle matrix (one with all nonzero entries on or above the main%@AE@%%@NL@%
%@AB@%'diagonal) can be solved immediately.  The goal of Gaussian elimination is to%@AE@%%@NL@%
%@AB@%'transform a non upper triangle system into an equivalent triangular one.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Given a system of equations represented in matrix form by Ax=b, we need a%@AE@%%@NL@%
%@AB@%'linear transformation L such that LA=U where U is and upper triangular matrix.%@AE@%%@NL@%
%@AB@%'Then Ux=LAx=Lb and Ux=Lb is an upper triangular system.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'This library explicitly calculates U, but L is never saved in its own array.%@AE@%%@NL@%
%@AB@%'When we do a row operation to create a zero below the main diagonal, we no%@AE@%%@NL@%
%@AB@%'longer need to save that value because we know it is zero.  This leaves the%@AE@%%@NL@%
%@AB@%'space available to save the multiplier used in the row operation.  When%@AE@%%@NL@%
%@AB@%'elimination is completed (ie, when the matrix is upper triangular), these%@AE@%%@NL@%
%@AB@%'multipliers give us a complete record of what we did to A to make it upper%@AE@%%@NL@%
%@AB@%'triangular.  This is equivalent to saying the multipliers represent L.  We now%@AE@%%@NL@%
%@AB@%'have a U and an L stored in the same matrix!  This type of matrix will be%@AE@%%@NL@%
%@AB@%'referred to as an LU matrix, or just LU.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'The following code fragments get LU and backsolve Ux=Lb.  The actual routines%@AE@%%@NL@%
%@AB@%'used in the toolbox are much more involved because they implement total%@AE@%%@NL@%
%@AB@%'pivoting and implicit row scaling to reduce round off errors.  However, all the%@AE@%%@NL@%
%@AB@%'extras (pivoting, scaling, error checking) are extraneous to the main routines,%@AE@%%@NL@%
%@AB@%'which total only 20 lines.  If you are unfamilar with this type of matrix math,%@AE@%%@NL@%
%@AB@%'gaining an understanding of these 20 lines is a very good introduction.  Try%@AE@%%@NL@%
%@AB@%'working through a 2x2 or 3x3 example by hand to see what is happening.  The%@AE@%%@NL@%
%@AB@%'numerical techniques used to reduce round off error will not be discussed.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'-------------------------------------------------------------------%@AE@%%@NL@%
%@AB@%'Given the coefficient matrix A(1 TO N, 1 TO N) and the vector b(1 TO N),%@AE@%%@NL@%
%@AB@%'the following fragments will find x(1 TO N) satisfying Ax=b using Gaussian%@AE@%%@NL@%
%@AB@%'elimination.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'matlu:%@AE@%%@NL@%
%@AB@%'Perform row operations to get all zeroes below the main diagonal.%@AE@%%@NL@%
%@AB@%'Define Rj(1 TO N) to be the vector corresponding to the jth row of A.%@AE@%%@NL@%
%@AB@%'Let Rrow = Rrow + m*Rpvt where m = -Rrow(pvt)/Rpvt(pvt).%@AE@%%@NL@%
%@AB@%'Then A(row, pvt)=0.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'** FOR pvt = 1 TO (N - 1)%@AE@%%@NL@%
%@AB@%'**    FOR row = (pvt + 1) TO N%@AE@%%@NL@%
%@AB@%'**       'Save m for later use in the space just made 0.%@AE@%%@NL@%
%@AB@%'**       A(row, pvt) = -A(row, pvt) / A(pvt, pvt)%@AE@%%@NL@%
%@AB@%'**       'Do the row operation.%@AE@%%@NL@%
%@AB@%'**       FOR col = (pvt + 1) TO N%@AE@%%@NL@%
%@AB@%'**          A(row, col) = A(row, col) + A(row, pvt) * A(pvt, col)%@AE@%%@NL@%
%@AB@%'**       NEXT col%@AE@%%@NL@%
%@AB@%'**    NEXT row%@AE@%%@NL@%
%@AB@%'** NEXT pvt%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'matbs:%@AE@%%@NL@%
%@AB@%'Do the same row operations on b using the multipliers saved in A.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'** FOR pvt = 1 TO (N - 1)%@AE@%%@NL@%
%@AB@%'**    FOR row = (pvt + 1) TO N%@AE@%%@NL@%
%@AB@%'**       b(row) = b(row) + A(row, pvt) * b(pvt)%@AE@%%@NL@%
%@AB@%'**    NEXT row%@AE@%%@NL@%
%@AB@%'** NEXT pvt%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Backsolve Ux=Lb to find x.%@AE@%%@NL@%
%@AB@%'                               N%@AE@%%@NL@%
%@AB@%'For r = N to 1, x(r) = [b(r) -  (A(r,c)*x(c))]/A(r,r)%@AE@%%@NL@%
%@AB@%'                              c=r+1%@AE@%%@NL@%
%@AB@%'** FOR row = N TO 1 STEP -1%@AE@%%@NL@%
%@AB@%'**    x(row) = b(row)%@AE@%%@NL@%
%@AB@%'**    FOR col = (row + 1) TO N%@AE@%%@NL@%
%@AB@%'**       x(row) = x(row) - A(row, col) * x(col)%@AE@%%@NL@%
%@AB@%'**    NEXT col%@AE@%%@NL@%
%@AB@%'**    x(row) = x(row) / A(row, row)%@AE@%%@NL@%
%@AB@%'** NEXT row%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'matb.bi'%@AE@%%@NL@%
DECLARE FUNCTION matbsD% (A() AS DOUBLE, b() AS DOUBLE, x() AS DOUBLE)%@NL@%
DECLARE FUNCTION matbsS% (A() AS SINGLE, b() AS SINGLE, x() AS SINGLE)%@NL@%
DECLARE FUNCTION matluD% (A() AS DOUBLE)%@NL@%
DECLARE FUNCTION matluS% (A() AS SINGLE)%@NL@%
DIM SHARED lo AS INTEGER, up AS INTEGER%@NL@%
DIM SHARED continue AS INTEGER, count AS INTEGER%@NL@%
DIM SHARED rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
END%@NL@%
%@NL@%
%@AB@%'=======================MatAddC%====================================%@AE@%%@NL@%
%@AB@%'MatAddC% adds two currency type matrices and places the sum in%@AE@%%@NL@%
%@AB@%'the first.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Alpha() = Alpha() + Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatAddC% (Alpha() AS CURRENCY, Beta() AS CURRENCY)%@NL@%
ON LOCAL ERROR GOTO cadderr: MatAddC% = 0%@NL@%
%@AB@%'check if Alpha, Beta have same dimensions if not, exit and send back error%@AE@%%@NL@%
IF (LBOUND(Alpha, 1) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Beta, 1)) OR (LBOUND(Alpha, 2) <> LBOUND(Beta, 2)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 2)) THEN ERROR 196%@NL@%
%@AB@%'loop through and add elements%@AE@%%@NL@%
FOR row% = LBOUND(Alpha, 1) TO UBOUND(Alpha, 1)%@NL@%
   FOR col% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
      Alpha(row%, col%) = Alpha(row%, col%) + Beta(row%, col%)%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
caddexit:%@NL@%
EXIT FUNCTION%@NL@%
cadderr:%@NL@%
   MatAddC% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME caddexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatAddD%====================================%@AE@%%@NL@%
%@AB@%'MatAddD% adds two double precision matrices and places the sum in%@AE@%%@NL@%
%@AB@%'the first.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Alpha() = Alpha() + Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatAddD% (Alpha() AS DOUBLE, Beta() AS DOUBLE)%@NL@%
ON LOCAL ERROR GOTO dadderr: MatAddD% = 0%@NL@%
%@AB@%'check if Alpha, Beta have same dimensions if not, exit and send back error%@AE@%%@NL@%
IF (LBOUND(Alpha, 1) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Beta, 1)) OR (LBOUND(Alpha, 2) <> LBOUND(Beta, 2)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 2)) THEN ERROR 196%@NL@%
%@AB@%'loop through and add elements%@AE@%%@NL@%
FOR row% = LBOUND(Alpha, 1) TO UBOUND(Alpha, 1)%@NL@%
   FOR col% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
      Alpha(row%, col%) = Alpha(row%, col%) + Beta(row%, col%)%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
daddexit:%@NL@%
EXIT FUNCTION%@NL@%
dadderr:%@NL@%
   MatAddD% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME daddexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatAddI%====================================%@AE@%%@NL@%
%@AB@%'MatAddI% adds two integer matrices and places the sum in%@AE@%%@NL@%
%@AB@%'the first.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Alpha() = Alpha() + Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatAddI% (Alpha() AS INTEGER, Beta() AS INTEGER)%@NL@%
ON LOCAL ERROR GOTO iadderr: MatAddI% = 0%@NL@%
%@AB@%'check if Alpha, Beta have same dimensions if not, exit and send back error%@AE@%%@NL@%
IF (LBOUND(Alpha, 1) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Beta, 1)) OR (LBOUND(Alpha, 2) <> LBOUND(Beta, 2)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 2)) THEN ERROR 196%@NL@%
%@AB@%'loop through and add elements%@AE@%%@NL@%
FOR row% = LBOUND(Alpha, 1) TO UBOUND(Alpha, 1)%@NL@%
   FOR col% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
      Alpha(row%, col%) = Alpha(row%, col%) + Beta(row%, col%)%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
iaddexit:%@NL@%
EXIT FUNCTION%@NL@%
iadderr:%@NL@%
   MatAddI% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME iaddexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatAddL%====================================%@AE@%%@NL@%
%@AB@%'MatAddL% adds two long integer matrices and places the sum in%@AE@%%@NL@%
%@AB@%'the first.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Alpha() = Alpha() + Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatAddL% (Alpha() AS LONG, Beta() AS LONG)%@NL@%
ON LOCAL ERROR GOTO ladderr: MatAddL% = 0%@NL@%
%@AB@%'check if Alpha, Beta have same dimensions if not, exit and send back error%@AE@%%@NL@%
IF (LBOUND(Alpha, 1) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Beta, 1)) OR (LBOUND(Alpha, 2) <> LBOUND(Beta, 2)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 2)) THEN ERROR 196%@NL@%
%@AB@%'loop through and add elements%@AE@%%@NL@%
FOR row% = LBOUND(Alpha, 1) TO UBOUND(Alpha, 1)%@NL@%
   FOR col% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
      Alpha(row%, col%) = Alpha(row%, col%) + Beta(row%, col%)%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
laddexit:%@NL@%
EXIT FUNCTION%@NL@%
ladderr:%@NL@%
   MatAddL% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME laddexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatAddS%====================================%@AE@%%@NL@%
%@AB@%'MatAddS% adds two single precision matrices and places the sum in%@AE@%%@NL@%
%@AB@%'the first.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Alpha() = Alpha() + Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatAddS% (Alpha() AS SINGLE, Beta() AS SINGLE)%@NL@%
ON LOCAL ERROR GOTO sadderr: MatAddS% = 0%@NL@%
%@AB@%'check if Alpha, Beta have same dimensions if not, exit and send back error%@AE@%%@NL@%
IF (LBOUND(Alpha, 1) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Beta, 1)) OR (LBOUND(Alpha, 2) <> LBOUND(Beta, 2)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 2)) THEN ERROR 196%@NL@%
%@AB@%'loop through and add elements%@AE@%%@NL@%
FOR row% = LBOUND(Alpha, 1) TO UBOUND(Alpha, 1)%@NL@%
   FOR col% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
      Alpha(row%, col%) = Alpha(row%, col%) + Beta(row%, col%)%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
saddexit:%@NL@%
EXIT FUNCTION%@NL@%
sadderr:%@NL@%
   MatAddS% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME saddexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================matbsD=====================================%@AE@%%@NL@%
%@AB@%'matbsD% takes a matrix in LU form, found by matluD%, and a vector b%@AE@%%@NL@%
%@AB@%'and solves the system Ux=Lb for x. matrices A,b,x are double precision.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: LU matrix in A, corresponding pivot vectors in rpvt and cpvt,%@AE@%%@NL@%
%@AB@%'            right side in b%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: solution in x, b is modified, rest unchanged%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION matbsD% (A() AS DOUBLE, b() AS DOUBLE, x() AS DOUBLE)%@NL@%
ON LOCAL ERROR GOTO dbserr: matbsD% = 0%@NL@%
%@AB@%'do row operations on b using the multipliers in L to find Lb%@AE@%%@NL@%
FOR pvt% = lo TO (up - 1)%@NL@%
   c% = cpvt(pvt%)%@NL@%
   FOR row% = (pvt% + 1) TO up%@NL@%
      r% = rpvt(row%)%@NL@%
      b(r%) = b(r%) + A(r%, c%) * b(rpvt(pvt%))%@NL@%
   NEXT row%%@NL@%
NEXT pvt%%@NL@%
%@AB@%'backsolve Ux=Lb to find x%@AE@%%@NL@%
FOR row% = up TO lo STEP -1%@NL@%
   c% = cpvt(row%)%@NL@%
   r% = rpvt(row%)%@NL@%
   x(c%) = b(r%)%@NL@%
   FOR col% = (row% + 1) TO up%@NL@%
      x(c%) = x(c%) - A(r%, cpvt(col%)) * x(cpvt(col%))%@NL@%
   NEXT col%%@NL@%
   x(c%) = x(c%) / A(r%, c%)%@NL@%
NEXT row%%@NL@%
dbsexit:%@NL@%
EXIT FUNCTION%@NL@%
dbserr:%@NL@%
   matbsD% = ERR%@NL@%
   RESUME dbsexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================matbsS=====================================%@AE@%%@NL@%
%@AB@%'matbsS% takes a matrix in LU form, found by matluS%, and a vector b%@AE@%%@NL@%
%@AB@%'and solves the system Ux=Lb for x. matrices A,b,x are single precision.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: LU matrix in A, corresponding pivot vectors in rpvt and cpvt,%@AE@%%@NL@%
%@AB@%'            right side in b%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: solution in x, b is modified, rest unchanged%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION matbsS% (A() AS SINGLE, b() AS SINGLE, x() AS SINGLE)%@NL@%
ON LOCAL ERROR GOTO sbserr: matbsS% = 0%@NL@%
%@AB@%'do row operations on b using the multipliers in L to find Lb%@AE@%%@NL@%
FOR pvt% = lo TO (up - 1)%@NL@%
   c% = cpvt(pvt%)%@NL@%
   FOR row% = (pvt% + 1) TO up%@NL@%
      r% = rpvt(row%)%@NL@%
      b(r%) = b(r%) + A(r%, c%) * b(rpvt(pvt%))%@NL@%
   NEXT row%%@NL@%
NEXT pvt%%@NL@%
%@AB@%'backsolve Ux=Lb to find x%@AE@%%@NL@%
FOR row% = up TO lo STEP -1%@NL@%
   c% = cpvt(row%)%@NL@%
   r% = rpvt(row%)%@NL@%
   x(c%) = b(r%)%@NL@%
   FOR col% = (row% + 1) TO up%@NL@%
      x(c%) = x(c%) - A(r%, cpvt(col%)) * x(cpvt(col%))%@NL@%
   NEXT col%%@NL@%
   x(c%) = x(c%) / A(r%, c%)%@NL@%
NEXT row%%@NL@%
sbsexit:%@NL@%
EXIT FUNCTION%@NL@%
sbserr:%@NL@%
   matbsS% = ERR%@NL@%
   RESUME sbsexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================MatDetC%===================================%@AE@%%@NL@%
%@AB@%'MatDetC% finds the determinant of a square, currency type matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) matrix, det@ to return the determinant%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: matrix A in LU form, determinant%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatDetC% (A() AS CURRENCY, det@)%@NL@%
ON LOCAL ERROR GOTO cdeterr: errcode% = 0%@NL@%
lo = LBOUND(A, 1)%@NL@%
up = UBOUND(A, 1)%@NL@%
REDIM rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
%@AB@%'make temporary double precision matrix to find pivots%@AE@%%@NL@%
DIM Tmp(lo TO up, LBOUND(A, 2) TO UBOUND(A, 2)) AS DOUBLE%@NL@%
FOR row% = lo TO up%@NL@%
   FOR col% = LBOUND(A, 2) TO UBOUND(A, 2)%@NL@%
      Tmp(row%, col%) = CDBL(A(row%, col%))%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
errcode% = matluD%(Tmp())              'Get LU matrix%@NL@%
IF NOT continue THEN%@NL@%
   IF errcode% = 199 THEN det@ = 0@%@NL@%
   ERROR errcode%%@NL@%
ELSE%@NL@%
   detD# = 1#                          '+/- determinant = product of the pivots%@NL@%
   FOR pvt% = lo TO up%@NL@%
      detD# = detD# * Tmp(rpvt(pvt%), cpvt(pvt%))%@NL@%
   NEXT pvt%                           'count contains the total number of row%@NL@%
   det@ = (-1@) ^ count * CCUR(detD#)  'and column switches due to pivoting.%@NL@%
   IF errcode% THEN ERROR errcode%     'multiply the determinant by -1 for%@NL@%
END IF                                 'each switch.%@NL@%
cdetexit:%@NL@%
ERASE rpvt, cpvt, Tmp%@NL@%
MatDetC% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
cdeterr:%@NL@%
   errcode% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME cdetexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================MatDetD%===================================%@AE@%%@NL@%
%@AB@%'MatDetD% finds the determinant of a square, double precision matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) matrix, det# to return the determinant%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: matrix A in LU form, determinant%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatDetD% (A() AS DOUBLE, det#)%@NL@%
ON LOCAL ERROR GOTO ddeterr: errcode% = 0%@NL@%
lo = LBOUND(A, 1)%@NL@%
up = UBOUND(A, 1)%@NL@%
REDIM rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
errcode% = matluD%(A())             'Get LU matrix%@NL@%
IF NOT continue THEN%@NL@%
   IF errcode% = 199 THEN det# = 0#%@NL@%
   ERROR errcode%%@NL@%
ELSE%@NL@%
   det# = 1#                        '+/- determinant = product of the pivots%@NL@%
   FOR pvt% = lo TO up%@NL@%
      det# = det# * A(rpvt(pvt%), cpvt(pvt%))%@NL@%
   NEXT pvt%                         'count contains the total number of row%@NL@%
   det# = (-1) ^ count * det#        'and column switches due to pivoting.%@NL@%
   IF errcode% THEN ERROR errcode%   'multiply the determinant by -1 for%@NL@%
END IF                               'each switch%@NL@%
ddetexit:%@NL@%
ERASE rpvt, cpvt%@NL@%
MatDetD% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
ddeterr:%@NL@%
   errcode% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME ddetexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================MatDetI%===================================%@AE@%%@NL@%
%@AB@%'MatDetI% finds the determinant of a square, integer matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) matrix, det% to return the determinant%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: matrix A unchanged, determinant%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatDetI% (A() AS INTEGER, det%)%@NL@%
ON LOCAL ERROR GOTO ideterr: errcode% = 0%@NL@%
lo = LBOUND(A, 1)%@NL@%
up = UBOUND(A, 1)%@NL@%
REDIM rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
%@AB@%'make temporary single precision matrix to find pivots%@AE@%%@NL@%
DIM Tmp(lo TO up, LBOUND(A, 2) TO UBOUND(A, 2)) AS SINGLE%@NL@%
FOR row% = lo TO up%@NL@%
   FOR col% = LBOUND(A, 2) TO UBOUND(A, 2)%@NL@%
      Tmp(row%, col%) = CSNG(A(row%, col%))%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
errcode% = matluS%(Tmp())              'Get LU matrix%@NL@%
IF NOT continue THEN%@NL@%
   IF errcode% = 199 THEN det% = 0%@NL@%
   ERROR errcode%%@NL@%
ELSE%@NL@%
   detS! = 1!                          '+/- determinant = product of the pivots%@NL@%
   FOR pvt% = lo TO up%@NL@%
      detS! = detS! * Tmp(rpvt(pvt%), cpvt(pvt%))%@NL@%
   NEXT pvt%                           'count contains the total number of row%@NL@%
   det% = (-1) ^ count * CINT(detS!)   'and column switches due to pivoting.%@NL@%
   IF errcode% THEN ERROR errcode%     'multiply the determinant by -1 for%@NL@%
END IF                                 'each switch%@NL@%
idetexit:%@NL@%
ERASE rpvt, cpvt, Tmp%@NL@%
MatDetI% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
ideterr:%@NL@%
   errcode% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME idetexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================MatDetL%===================================%@AE@%%@NL@%
%@AB@%'MatDetL% finds the determinant of a square, long integer matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) matrix, det& to return the determinant%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: matrix A unchanged, determinant%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatDetL% (A() AS LONG, det&)%@NL@%
ON LOCAL ERROR GOTO ldeterr: errcode% = 0%@NL@%
lo = LBOUND(A, 1)%@NL@%
up = UBOUND(A, 1)%@NL@%
REDIM rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
%@AB@%'make temporary double precision matrix to find pivots%@AE@%%@NL@%
DIM Tmp(lo TO up, LBOUND(A, 2) TO UBOUND(A, 2)) AS DOUBLE%@NL@%
FOR row% = lo TO up%@NL@%
   FOR col% = LBOUND(A, 2) TO UBOUND(A, 2)%@NL@%
      Tmp(row%, col%) = CDBL(A(row%, col%))%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
errcode% = matluD%(Tmp())              'Get LU matrix%@NL@%
IF NOT continue THEN%@NL@%
   IF errcode% = 199 THEN det& = 0&%@NL@%
   ERROR errcode%%@NL@%
ELSE%@NL@%
   detD# = 1#                          '+/- determinant = product of the pivots%@NL@%
   FOR pvt% = lo TO up%@NL@%
      detD# = detD# * Tmp(rpvt(pvt%), cpvt(pvt%))%@NL@%
   NEXT pvt%                           'count contains the total number of row%@NL@%
   det& = (-1&) ^ count * CLNG(detD#)  'and column switches due to pivoting.%@NL@%
   IF errcode% THEN ERROR errcode%     'multiply the determinant by -1 for%@NL@%
END IF                                 'each switch%@NL@%
ldetexit:%@NL@%
ERASE rpvt, cpvt, Tmp%@NL@%
MatDetL% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
ldeterr:%@NL@%
   errcode% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME ldetexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================MatDetS%===================================%@AE@%%@NL@%
%@AB@%'MatDetS% finds the determinant of a square, single precision matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) matrix, det! to return the determinant%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: matrix A in LU form, determinant%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatDetS% (A() AS SINGLE, det!)%@NL@%
ON LOCAL ERROR GOTO sdeterr: errcode% = 0%@NL@%
lo = LBOUND(A, 1)%@NL@%
up = UBOUND(A, 1)%@NL@%
REDIM rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
errcode% = matluS%(A())                'Get LU matrix%@NL@%
IF NOT continue THEN%@NL@%
   IF errcode% = 199 THEN det! = 0!%@NL@%
   ERROR errcode%%@NL@%
ELSE%@NL@%
   det! = 1!                           '+/- determinant = product of the pivots%@NL@%
   FOR pvt% = lo TO up%@NL@%
      det! = det! * A(rpvt(pvt%), cpvt(pvt%))%@NL@%
   NEXT pvt%                           'count contains the total number of row%@NL@%
   det! = (-1) ^ count * det!          'and column switches due to pivoting.%@NL@%
   IF errcode% THEN ERROR errcode%     'multiply the determinant by -1 for%@NL@%
END IF                                 'each switch%@NL@%
sdetexit:%@NL@%
ERASE rpvt, cpvt%@NL@%
MatDetS% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
sdeterr:%@NL@%
   errcode% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME sdetexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================MatInvC%===================================%@AE@%%@NL@%
%@AB@%'MatInvC% uses the matluD% and matbsD procedures to invert a square, currency%@AE@%%@NL@%
%@AB@%'type matrix.  Let e(N) contain all zeroes except for the jth position, which%@AE@%%@NL@%
%@AB@%'is 1.  Then the jth column of A^-1 is x, where Ax=e.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: A^-1%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatInvC% (A() AS CURRENCY)%@NL@%
ON LOCAL ERROR GOTO cinverr: errcode% = 0%@NL@%
lo = LBOUND(A, 1)%@NL@%
up = UBOUND(A, 1)%@NL@%
REDIM rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
%@AB@%'duplicate A() in a double precision work matrix, Tmp()%@AE@%%@NL@%
DIM Tmp(lo TO up, LBOUND(A, 2) TO UBOUND(A, 2)) AS DOUBLE%@NL@%
DIM e(lo TO up) AS DOUBLE, x(lo TO up) AS DOUBLE%@NL@%
FOR row% = lo TO up%@NL@%
   FOR col% = LBOUND(A, 2) TO UBOUND(A, 2)%@NL@%
      Tmp(row%, col%) = CDBL(A(row%, col%))%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
errcode% = matluD%(Tmp())                    'Put LU in Tmp%@NL@%
IF NOT continue THEN ERROR errcode%%@NL@%
FOR col% = lo TO up                          'Find A^-1 one column at a time%@NL@%
   e(col%) = 1#%@NL@%
   bserrcode% = matbsD%(Tmp(), e(), x())%@NL@%
   IF bserrcode% THEN ERROR bserrcode%%@NL@%
   FOR row% = lo TO up%@NL@%
      A(row%, col%) = CCUR(x(row%))          'Put the column into A%@NL@%
      e(row%) = 0#%@NL@%
   NEXT row%%@NL@%
NEXT col%%@NL@%
IF errcode% THEN ERROR errcode%%@NL@%
cinvexit:%@NL@%
ERASE Tmp, e, x, rpvt, cpvt%@NL@%
MatInvC% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
cinverr:%@NL@%
   errcode% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME cinvexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================MatInvD%===================================%@AE@%%@NL@%
%@AB@%'MatInvD% uses the matluD% and matbsD procedures to invert a square, double%@AE@%%@NL@%
%@AB@%'precision matrix.  Let e(N) contain all zeroes except for the jth position,%@AE@%%@NL@%
%@AB@%'which is 1.  Then the jth column of A^-1 is x, where Ax=e.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: A^-1%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatInvD% (A() AS DOUBLE)%@NL@%
ON LOCAL ERROR GOTO dinverr: errcode% = 0%@NL@%
lo = LBOUND(A, 1)%@NL@%
up = UBOUND(A, 1)%@NL@%
DIM Ain(lo TO up, lo TO up) AS DOUBLE%@NL@%
DIM e(lo TO up) AS DOUBLE, x(lo TO up) AS DOUBLE%@NL@%
REDIM rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
errcode% = matluD%(A())                     'Get LU matrix%@NL@%
IF NOT continue THEN ERROR errcode%%@NL@%
FOR col% = lo TO up                         'Find A^-1 one column at a time%@NL@%
   e(col%) = 1#%@NL@%
   bserrcode% = matbsD%(A(), e(), x())%@NL@%
   IF bserrcode% THEN ERROR bserrcode%%@NL@%
   FOR row% = lo TO up%@NL@%
      Ain(row%, col%) = x(row%)%@NL@%
      e(row%) = 0#%@NL@%
   NEXT row%%@NL@%
NEXT col%%@NL@%
FOR col% = lo TO up                         'Put A^-1 in A%@NL@%
   FOR row% = lo TO up%@NL@%
      A(row%, col%) = Ain(row%, col%)%@NL@%
   NEXT row%%@NL@%
NEXT col%%@NL@%
IF errcode% THEN ERROR errcode%%@NL@%
dinvexit:%@NL@%
ERASE e, x, Ain, rpvt, cpvt%@NL@%
MatInvD% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
dinverr:%@NL@%
   errcode% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME dinvexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================MatInvS%===================================%@AE@%%@NL@%
%@AB@%'MatInvS% uses the matluS% and matbsS procedures to invert a square, single%@AE@%%@NL@%
%@AB@%'precision matrix.  Let e(N) contain all zeroes except for the jth position,%@AE@%%@NL@%
%@AB@%'which is 1. Then the jth column of A^-1 is x, where Ax=e.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: A^-1%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatInvS% (A() AS SINGLE)%@NL@%
ON LOCAL ERROR GOTO sinverr: errcode% = 0%@NL@%
lo = LBOUND(A, 1)%@NL@%
up = UBOUND(A, 1)%@NL@%
DIM Ain(lo TO up, lo TO up) AS SINGLE%@NL@%
DIM e(lo TO up) AS SINGLE, x(lo TO up) AS SINGLE%@NL@%
REDIM rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
errcode% = matluS%(A())                     'Get LU matrix%@NL@%
IF NOT continue THEN ERROR errcode%%@NL@%
FOR col% = lo TO up                         'find A^-1 one column at a time%@NL@%
   e(col%) = 1!%@NL@%
   bserrcode% = matbsS%(A(), e(), x())%@NL@%
   IF bserrcode% THEN ERROR bserrcode%%@NL@%
   FOR row% = lo TO up%@NL@%
      Ain(row%, col%) = x(row%)%@NL@%
      e(row%) = 0!%@NL@%
   NEXT row%%@NL@%
NEXT col%%@NL@%
FOR col% = lo TO up                         'put A^-1 in A%@NL@%
   FOR row% = lo TO up%@NL@%
      A(row%, col%) = Ain(row%, col%)%@NL@%
   NEXT row%%@NL@%
NEXT col%%@NL@%
IF errcode% THEN ERROR errcode%%@NL@%
sinvexit:%@NL@%
ERASE e, x, Ain, rpvt, cpvt%@NL@%
MatInvS% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
sinverr:%@NL@%
   errcode% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME sinvexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================matluD%====================================%@AE@%%@NL@%
%@AB@%'matluD% does Gaussian elimination with total pivoting to put a square, double%@AE@%%@NL@%
%@AB@%'precision matrix in LU form. The multipliers used in the row operations to%@AE@%%@NL@%
%@AB@%'create zeroes below the main diagonal are saved in the zero spaces.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) matrix, rpvt(n) and cpvt(n) permutation vectors%@AE@%%@NL@%
%@AB@%'            used to index the row and column pivots%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: A in LU form with corresponding pivot vectors; the total number of%@AE@%%@NL@%
%@AB@%'         pivots in count, which is used to find the sign of the determinant.%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION matluD% (A() AS DOUBLE)%@NL@%
ON LOCAL ERROR GOTO dluerr: errcode% = 0%@NL@%
%@AB@%'Checks if A is square, returns error code if not%@AE@%%@NL@%
IF NOT (lo = LBOUND(A, 2) AND up = UBOUND(A, 2)) THEN ERROR 198%@NL@%
DIM rownorm(lo TO up) AS DOUBLE%@NL@%
count = 0                            'initialize count, continue%@NL@%
continue = -1%@NL@%
FOR row% = lo TO up                  'initialize rpvt and cpvt%@NL@%
   rpvt(row%) = row%%@NL@%
   cpvt(row%) = row%%@NL@%
   rownorm(row%) = 0#                'find the row norms of A()%@NL@%
   FOR col% = lo TO up%@NL@%
      rownorm(row%) = rownorm(row%) + ABS(A(row%, col%))%@NL@%
   NEXT col%%@NL@%
   IF rownorm(row%) = 0# THEN        'if any rownorm is zero, the matrix%@NL@%
      continue = 0                   'is singular, set error, exit and%@NL@%
      ERROR 199                      'do not continue%@NL@%
   END IF%@NL@%
NEXT row%%@NL@%
FOR pvt% = lo TO (up - 1)%@NL@%
%@AB@%'Find best available pivot%@AE@%%@NL@%
   max# = 0#                         'checks all values in rows and columns not%@NL@%
   FOR row% = pvt% TO up             'already used for pivoting and saves the%@NL@%
      r% = rpvt(row%)                'largest absolute number and its position%@NL@%
      FOR col% = pvt% TO up%@NL@%
         c% = cpvt(col%)%@NL@%
         temp# = ABS(A(r%, c%)) / rownorm(r%)%@NL@%
         IF temp# > max# THEN%@NL@%
            max# = temp#%@NL@%
            bestrow% = row%          'save the position of new max#%@NL@%
            bestcol% = col%%@NL@%
         END IF%@NL@%
      NEXT col%%@NL@%
   NEXT row%%@NL@%
   IF max# = 0# THEN                 'if no nonzero number is found, A is%@NL@%
      continue = 0                   'singular, send back error, do not continue%@NL@%
      ERROR 199%@NL@%
   ELSEIF pvt% > 1 THEN              'check if drop in pivots is too much%@NL@%
      IF max# < (deps# * oldmax#) THEN errcode% = 199%@NL@%
   END IF%@NL@%
   oldmax# = max#%@NL@%
   IF rpvt(pvt%) <> rpvt(bestrow%) THEN%@NL@%
      count = count + 1                    'if a row or column pivot is%@NL@%
      SWAP rpvt(pvt%), rpvt(bestrow%)      'necessary, count it and permute%@NL@%
   END IF                                  'rpvt or cpvt. Note: the rows and%@NL@%
   IF cpvt(pvt%) <> cpvt(bestcol%) THEN    'columns are not actually switched,%@NL@%
      count = count + 1                    'only the order in which they are%@NL@%
      SWAP cpvt(pvt%), cpvt(bestcol%)      'used.%@NL@%
   END IF%@NL@%
%@AB@%'Eliminate all values below the pivot%@AE@%%@NL@%
   rp% = rpvt(pvt%)%@NL@%
   cp% = cpvt(pvt%)%@NL@%
   FOR row% = (pvt% + 1) TO up%@NL@%
      r% = rpvt(row%)%@NL@%
      A(r%, cp%) = -A(r%, cp%) / A(rp%, cp%)  'save multipliers%@NL@%
      FOR col% = (pvt% + 1) TO up%@NL@%
         c% = cpvt(col%)                      'complete row operations%@NL@%
         A(r%, c%) = A(r%, c%) + A(r%, cp%) * A(rp%, c%)%@NL@%
      NEXT col%%@NL@%
   NEXT row%%@NL@%
NEXT pvt%%@NL@%
IF A(rpvt(up), cpvt(up)) = 0# THEN%@NL@%
   continue = 0                      'if last pivot is zero or pivot drop is%@NL@%
   ERROR 199                         'too large, A is singular, send back error%@NL@%
ELSEIF (ABS(A(rpvt(up), cpvt(up))) / rownorm(rpvt(up))) < (deps# * oldmax#) THEN%@NL@%
   errcode% = 199                    'if pivot is not identically zero then%@NL@%
END IF                               'continue remains TRUE%@NL@%
IF errcode% THEN ERROR errcode%%@NL@%
dluexit:%@NL@%
matluD% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
dluerr:%@NL@%
   IF errcode% < 199 THEN continue = 0%@NL@%
   errcode% = ERR%@NL@%
   RESUME dluexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================matluS%====================================%@AE@%%@NL@%
%@AB@%'matluS% does Gaussian elimination with total pivoting to put a square, single%@AE@%%@NL@%
%@AB@%'precision matrix in LU form. The multipliers used in the row operations to%@AE@%%@NL@%
%@AB@%'create zeroes below the main diagonal are saved in the zero spaces.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) matrix, rpvt(n) and cpvt(n) permutation vectors%@AE@%%@NL@%
%@AB@%'            used to index the row and column pivots%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: A in LU form with corresponding pivot vectors; the total number of%@AE@%%@NL@%
%@AB@%'         pivots in count, which is used to find the sign of the determinant.%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION matluS% (A() AS SINGLE)%@NL@%
ON LOCAL ERROR GOTO sluerr: errcode% = 0%@NL@%
%@AB@%'Checks if A is square, returns error code if not%@AE@%%@NL@%
IF NOT (lo = LBOUND(A, 2) AND up = UBOUND(A, 2)) THEN ERROR 198%@NL@%
DIM rownorm(lo TO up) AS SINGLE%@NL@%
count = 0                            'initialize count, continue%@NL@%
continue = -1%@NL@%
FOR row% = lo TO up                  'initialize rpvt and cpvt%@NL@%
   rpvt(row%) = row%%@NL@%
   cpvt(row%) = row%%@NL@%
   rownorm(row%) = 0!                'find the row norms of A()%@NL@%
   FOR col% = lo TO up%@NL@%
      rownorm(row%) = rownorm(row%) + ABS(A(row%, col%))%@NL@%
   NEXT col%%@NL@%
   IF rownorm(row%) = 0! THEN        'if any rownorm is zero, the matrix%@NL@%
      continue = 0                   'is singular, set error, exit and do%@NL@%
      ERROR 199                      'not continue%@NL@%
   END IF%@NL@%
NEXT row%%@NL@%
FOR pvt% = lo TO (up - 1)%@NL@%
%@AB@%'Find best available pivot%@AE@%%@NL@%
   max! = 0!                         'checks all values in rows and columns not%@NL@%
   FOR row% = pvt% TO up             'already used for pivoting and finds the%@NL@%
      r% = rpvt(row%)                'number largest in absolute value relative%@NL@%
      FOR col% = pvt% TO up          'to its row norm%@NL@%
         c% = cpvt(col%)%@NL@%
         temp! = ABS(A(r%, c%)) / rownorm(r%)%@NL@%
         IF temp! > max! THEN%@NL@%
            max! = temp!%@NL@%
            bestrow% = row%          'save the position of new max!%@NL@%
            bestcol% = col%%@NL@%
         END IF%@NL@%
      NEXT col%%@NL@%
   NEXT row%%@NL@%
   IF max! = 0! THEN                 'if no nonzero number is found, A is%@NL@%
      continue = 0                   'singular, send back error, do not continue%@NL@%
      ERROR 199%@NL@%
   ELSEIF pvt% > 1 THEN              'check if drop in pivots is too much%@NL@%
      IF max! < (seps! * oldmax!) THEN errcode% = 199%@NL@%
   END IF%@NL@%
   oldmax! = max!%@NL@%
   IF rpvt(pvt%) <> rpvt(bestrow%) THEN%@NL@%
      count = count + 1                    'if a row or column pivot is%@NL@%
      SWAP rpvt(pvt%), rpvt(bestrow%)      'necessary, count it and permute%@NL@%
   END IF                                  'rpvt or cpvt. Note: the rows and%@NL@%
   IF cpvt(pvt%) <> cpvt(bestcol%) THEN    'columns are not actually switched,%@NL@%
      count = count + 1                    'only the order in which they are%@NL@%
      SWAP cpvt(pvt%), cpvt(bestcol%)      'used.%@NL@%
   END IF%@NL@%
%@AB@%'Eliminate all values below the pivot%@AE@%%@NL@%
   rp% = rpvt(pvt%)%@NL@%
   cp% = cpvt(pvt%)%@NL@%
   FOR row% = (pvt% + 1) TO up%@NL@%
      r% = rpvt(row%)%@NL@%
      A(r%, cp%) = -A(r%, cp%) / A(rp%, cp%)  'save multipliers%@NL@%
      FOR col% = (pvt% + 1) TO up%@NL@%
         c% = cpvt(col%)                      'complete row operations%@NL@%
         A(r%, c%) = A(r%, c%) + A(r%, cp%) * A(rp%, c%)%@NL@%
      NEXT col%%@NL@%
   NEXT row%%@NL@%
NEXT pvt%%@NL@%
IF A(rpvt(up), cpvt(up)) = 0! THEN%@NL@%
   continue = 0                      'if last pivot is zero or pivot drop is%@NL@%
   ERROR 199                         'too large, A is singular, send back error%@NL@%
ELSEIF (ABS(A(rpvt(up), cpvt(up))) / rownorm(rpvt(up))) < (seps! * oldmax!) THEN%@NL@%
   errcode% = 199                    'if pivot is not identically zero then%@NL@%
END IF                               'continue remains TRUE%@NL@%
IF errcode% THEN ERROR errcode%%@NL@%
sluexit:%@NL@%
matluS% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
sluerr:%@NL@%
   errcode% = ERR%@NL@%
   IF errcode% < 199 THEN continue = 0%@NL@%
   RESUME sluexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatMultC%===================================%@AE@%%@NL@%
%@AB@%'MatMultC% multiplies two currency type matrices and places the%@AE@%%@NL@%
%@AB@%'product in a result matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta,Gamma%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Gamma() = Alpha() * Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatMultC% (Alpha() AS CURRENCY, Beta() AS CURRENCY, Gamma() AS CURRENCY)%@NL@%
ON LOCAL ERROR GOTO cmulterr: MatMultC% = 0%@NL@%
IF (LBOUND(Alpha, 2) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 1)) THEN%@NL@%
   ERROR 197                   'check inside dimensions%@NL@%
ELSEIF (LBOUND(Alpha, 1) <> LBOUND(Gamma, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Gamma, 1)) OR (LBOUND(Beta, 2) <> LBOUND(Gamma, 2)) OR (UBOUND(Beta, 2) <> UBOUND(Gamma, 2)) THEN%@NL@%
   ERROR 195                   'check dimensions of result matrix%@NL@%
END IF%@NL@%
%@AB@%'loop through, Gamma(row,col)=inner product of Alpha(row,*) and Beta(*,col)%@AE@%%@NL@%
FOR row% = LBOUND(Gamma, 1) TO UBOUND(Gamma, 1)%@NL@%
   FOR col% = LBOUND(Gamma, 2) TO UBOUND(Gamma, 2)%@NL@%
      Gamma(row%, col%) = 0@%@NL@%
      FOR inside% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
         Gamma(row%, col%) = Gamma(row%, col%) + Alpha(row%, inside%) * Beta(inside%, col%)%@NL@%
      NEXT inside%%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
cmultexit:%@NL@%
EXIT FUNCTION%@NL@%
cmulterr:%@NL@%
   MatMultC% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME cmultexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatMultD%===================================%@AE@%%@NL@%
%@AB@%'MatMultD% multiplies two double precision matrices and places the%@AE@%%@NL@%
%@AB@%'product in a result matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta,Gamma%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Gamma() = Alpha() * Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatMultD% (Alpha() AS DOUBLE, Beta() AS DOUBLE, Gamma() AS DOUBLE)%@NL@%
ON LOCAL ERROR GOTO dmulterr: MatMultD% = 0%@NL@%
IF (LBOUND(Alpha, 2) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 1)) THEN%@NL@%
   ERROR 197                   'check inside dimensions%@NL@%
ELSEIF (LBOUND(Alpha, 1) <> LBOUND(Gamma, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Gamma, 1)) OR (LBOUND(Beta, 2) <> LBOUND(Gamma, 2)) OR (UBOUND(Beta, 2) <> UBOUND(Gamma, 2)) THEN%@NL@%
   ERROR 195                   'check dimensions of result matrix%@NL@%
END IF%@NL@%
%@AB@%'loop through, Gamma(row,col)=inner product of Alpha(row,*) and Beta(*,col)%@AE@%%@NL@%
FOR row% = LBOUND(Gamma, 1) TO UBOUND(Gamma, 1)%@NL@%
   FOR col% = LBOUND(Gamma, 2) TO UBOUND(Gamma, 2)%@NL@%
      Gamma(row%, col%) = 0#%@NL@%
      FOR inside% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
         Gamma(row%, col%) = Gamma(row%, col%) + Alpha(row%, inside%) * Beta(inside%, col%)%@NL@%
      NEXT inside%%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
dmultexit:%@NL@%
EXIT FUNCTION%@NL@%
dmulterr:%@NL@%
   MatMultD% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME dmultexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatMultI%===================================%@AE@%%@NL@%
%@AB@%'MatMultI% multiplies two integer matrices and places the product in%@AE@%%@NL@%
%@AB@%'a result matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta,Gamma%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Gamma() = Alpha() * Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatMultI% (Alpha() AS INTEGER, Beta() AS INTEGER, Gamma() AS INTEGER)%@NL@%
ON LOCAL ERROR GOTO imulterr: MatMultI% = 0%@NL@%
IF (LBOUND(Alpha, 2) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 1)) THEN%@NL@%
   ERROR 197                   'check inside dimensions%@NL@%
ELSEIF (LBOUND(Alpha, 1) <> LBOUND(Gamma, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Gamma, 1)) OR (LBOUND(Beta, 2) <> LBOUND(Gamma, 2)) OR (UBOUND(Beta, 2) <> UBOUND(Gamma, 2)) THEN%@NL@%
   ERROR 195                   'check dimensions of result matrix%@NL@%
END IF%@NL@%
%@AB@%'loop through, Gamma(row,col)=inner product of Alpha(row,*) and Beta(*,col)%@AE@%%@NL@%
FOR row% = LBOUND(Gamma, 1) TO UBOUND(Gamma, 1)%@NL@%
   FOR col% = LBOUND(Gamma, 2) TO UBOUND(Gamma, 2)%@NL@%
      Gamma(row%, col%) = 0%@NL@%
      FOR inside% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
         Gamma(row%, col%) = Gamma(row%, col%) + Alpha(row%, inside%) * Beta(inside%, col%)%@NL@%
      NEXT inside%%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
imultexit:%@NL@%
EXIT FUNCTION%@NL@%
imulterr:%@NL@%
   MatMultI% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME imultexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatMultL%===================================%@AE@%%@NL@%
%@AB@%'MatMultL% multiplies two long integer matrices and places the product%@AE@%%@NL@%
%@AB@%'in a result matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta,Gamma%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Gamma() = Alpha() * Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatMultL% (Alpha() AS LONG, Beta() AS LONG, Gamma() AS LONG)%@NL@%
ON LOCAL ERROR GOTO lmulterr: MatMultL% = 0%@NL@%
IF (LBOUND(Alpha, 2) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 1)) THEN%@NL@%
   ERROR 197                   'check inside dimensions%@NL@%
ELSEIF (LBOUND(Alpha, 1) <> LBOUND(Gamma, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Gamma, 1)) OR (LBOUND(Beta, 2) <> LBOUND(Gamma, 2)) OR (UBOUND(Beta, 2) <> UBOUND(Gamma, 2)) THEN%@NL@%
   ERROR 195                   'check dimensions of result matrix%@NL@%
END IF%@NL@%
%@AB@%'loop through, Gamma(row,col)=inner product of Alpha(row,*) and Beta(*,col)%@AE@%%@NL@%
FOR row% = LBOUND(Gamma, 1) TO UBOUND(Gamma, 1)%@NL@%
   FOR col% = LBOUND(Gamma, 2) TO UBOUND(Gamma, 2)%@NL@%
      Gamma(row%, col%) = 0&%@NL@%
      FOR inside% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
         Gamma(row%, col%) = Gamma(row%, col%) + Alpha(row%, inside%) * Beta(inside%, col%)%@NL@%
      NEXT inside%%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
lmultexit:%@NL@%
EXIT FUNCTION%@NL@%
lmulterr:%@NL@%
   MatMultL% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME lmultexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatMultS%===================================%@AE@%%@NL@%
%@AB@%'MatMultS% multiplies two single precision matrices and places the%@AE@%%@NL@%
%@AB@%'product in a result matrix%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta,Gamma%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Gamma() = Alpha() * Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatMultS% (Alpha() AS SINGLE, Beta() AS SINGLE, Gamma() AS SINGLE)%@NL@%
ON LOCAL ERROR GOTO smulterr: MatMultS% = 0%@NL@%
IF (LBOUND(Alpha, 2) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 1)) THEN%@NL@%
   ERROR 197                   'check inside dimensions%@NL@%
ELSEIF (LBOUND(Alpha, 1) <> LBOUND(Gamma, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Gamma, 1)) OR (LBOUND(Beta, 2) <> LBOUND(Gamma, 2)) OR (UBOUND(Beta, 2) <> UBOUND(Gamma, 2)) THEN%@NL@%
   ERROR 195                   'check dimensions of result matrix%@NL@%
END IF%@NL@%
%@AB@%'loop through, Gamma(row,col)=inner product of Alpha(row,*) and Beta(*,col)%@AE@%%@NL@%
FOR row% = LBOUND(Gamma, 1) TO UBOUND(Gamma, 1)%@NL@%
   FOR col% = LBOUND(Gamma, 2) TO UBOUND(Gamma, 2)%@NL@%
      Gamma(row%, col%) = 0!%@NL@%
      FOR inside% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
         Gamma(row%, col%) = Gamma(row%, col%) + Alpha(row%, inside%) * Beta(inside%, col%)%@NL@%
      NEXT inside%%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
smultexit:%@NL@%
EXIT FUNCTION%@NL@%
smulterr:%@NL@%
   MatMultS% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME smultexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================MatSEqnC%==================================%@AE@%%@NL@%
%@AB@%'MatSEqnC% solves a system of n linear equations, Ax=b, and puts the%@AE@%%@NL@%
%@AB@%'answer in b. A is first put in LU form by matluC%, then matbsC is called%@AE@%%@NL@%
%@AB@%'to solve the system.  matrices A,b are currency type.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) contains coefficient matrix, b(N) contains the right side%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: A in LU form, solution in b%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatSEqnC% (A() AS CURRENCY, b() AS CURRENCY)%@NL@%
ON LOCAL ERROR GOTO cseqnerr: errcode% = 0%@NL@%
lo = LBOUND(A, 1)%@NL@%
up = UBOUND(A, 1)%@NL@%
REDIM rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
%@AB@%'duplicate A(), b() in temporary double precision matrices Tmp(), btmp()%@AE@%%@NL@%
DIM Tmp(lo TO up, LBOUND(A, 2) TO UBOUND(A, 2)) AS DOUBLE%@NL@%
DIM x(lo TO up) AS DOUBLE, btmp(lo TO up) AS DOUBLE%@NL@%
FOR row% = lo TO up%@NL@%
   FOR col% = LBOUND(A, 2) TO UBOUND(A, 2)%@NL@%
      Tmp(row%, col%) = CDBL(A(row%, col%))%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
errcode% = matluD%(Tmp())                   'Get LU matrix%@NL@%
IF NOT continue THEN ERROR errcode%%@NL@%
%@AB@%'check dimensions of b, make double precision copy if ok.%@AE@%%@NL@%
IF (lo <> LBOUND(b)) OR (up <> UBOUND(b)) THEN ERROR 197%@NL@%
FOR row% = lo TO up%@NL@%
   btmp(row%) = CDBL(b(row%))%@NL@%
NEXT row%%@NL@%
bserrcode% = matbsD%(Tmp(), btmp(), x())    'Backsolve system%@NL@%
IF bserrcode% THEN ERROR bserrcode%%@NL@%
FOR row% = lo TO up%@NL@%
   b(row%) = CCUR(x(row%))                  'Put solution in b for return%@NL@%
NEXT row%%@NL@%
IF errcode% THEN ERROR errcode%%@NL@%
cseqnexit:%@NL@%
ERASE Tmp, btmp, x, rpvt, cpvt%@NL@%
MatSEqnC% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
cseqnerr:%@NL@%
   errcode% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME cseqnexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================MatSEqnD%==================================%@AE@%%@NL@%
%@AB@%'MatSEqnD% solves a system of n linear equations, Ax=b, and puts the%@AE@%%@NL@%
%@AB@%'answer in b. A is first put in LU form by matluD%, then matbsD is called%@AE@%%@NL@%
%@AB@%'to solve the system.  matrices A,b are double precision.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) contains coefficient matrix, b(N) contains the right side%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: A in LU form, solution in b%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatSEqnD% (A() AS DOUBLE, b() AS DOUBLE)%@NL@%
ON LOCAL ERROR GOTO dseqnerr: errcode% = 0%@NL@%
lo = LBOUND(A, 1)%@NL@%
up = UBOUND(A, 1)%@NL@%
DIM x(lo TO up) AS DOUBLE%@NL@%
REDIM rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
errcode% = matluD%(A())                      'Get LU matrix%@NL@%
IF NOT continue THEN ERROR errcode%%@NL@%
%@AB@%'check dimensions of b%@AE@%%@NL@%
IF (lo <> LBOUND(b)) OR (up <> UBOUND(b)) THEN ERROR 197%@NL@%
bserrcode% = matbsD%(A(), b(), x())          'Backsolve system%@NL@%
IF bserrcode% THEN ERROR bserrcode%%@NL@%
FOR row% = lo TO up%@NL@%
   b(row%) = x(row%)                         'Put solution in b for return%@NL@%
NEXT row%%@NL@%
IF errcode% THEN ERROR errcode%%@NL@%
dseqnexit:%@NL@%
ERASE x, rpvt, cpvt%@NL@%
MatSEqnD% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
dseqnerr:%@NL@%
   errcode% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME dseqnexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'========================MatSEqnS%==================================%@AE@%%@NL@%
%@AB@%'MatSEqnS% solves a system of n linear equations, Ax=b, and puts the%@AE@%%@NL@%
%@AB@%'answer in b. A is first put in LU form by matluS%, then matbsS is called%@AE@%%@NL@%
%@AB@%'to solve the system.  matrices A,b are single precision.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: A(n x n) contains coefficient matrix, b(N) contains the right side%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: A in LU form, solution in b%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatSEqnS% (A() AS SINGLE, b() AS SINGLE)%@NL@%
ON LOCAL ERROR GOTO sseqnerr: errcode% = 0%@NL@%
lo = LBOUND(A, 1)%@NL@%
up = UBOUND(A, 1)%@NL@%
DIM x(lo TO up) AS SINGLE%@NL@%
REDIM rpvt(lo TO up) AS INTEGER, cpvt(lo TO up) AS INTEGER%@NL@%
errcode% = matluS%(A())                      'Get LU matrix%@NL@%
IF NOT continue THEN ERROR errcode%%@NL@%
%@AB@%'check dimensions of b%@AE@%%@NL@%
IF (lo <> LBOUND(b)) OR (up <> UBOUND(b)) THEN ERROR 197%@NL@%
bserrcode% = matbsS%(A(), b(), x())          'Backsolve system%@NL@%
IF bserrcode% THEN ERROR bserrcode%%@NL@%
FOR row% = lo TO up%@NL@%
   b(row%) = x(row%)                         'Put solution in b for return%@NL@%
NEXT row%%@NL@%
IF errcode% THEN ERROR errcode%%@NL@%
sseqnexit:%@NL@%
ERASE x, rpvt, cpvt%@NL@%
MatSEqnS% = errcode%%@NL@%
EXIT FUNCTION%@NL@%
sseqnerr:%@NL@%
   errcode% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME sseqnexit%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatSubC%====================================%@AE@%%@NL@%
%@AB@%'MatSubC% takes the difference of two currency type matrices and%@AE@%%@NL@%
%@AB@%'places the result in the first.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Params: matrices Alpha,Beta%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Alpha=Alpha-Beta%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatSubC% (Alpha() AS CURRENCY, Beta() AS CURRENCY)%@NL@%
ON LOCAL ERROR GOTO csuberr: MatSubC% = 0%@NL@%
%@AB@%'check if Alpha, Beta have same dimensions if not, exit and send back error%@AE@%%@NL@%
IF (LBOUND(Alpha, 1) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Beta, 1)) OR (LBOUND(Alpha, 2) <> LBOUND(Beta, 2)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 2)) THEN ERROR 196%@NL@%
%@AB@%'loop through and subtract elements%@AE@%%@NL@%
FOR row% = LBOUND(Alpha, 1) TO UBOUND(Alpha, 1)%@NL@%
   FOR col% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
      Alpha(row%, col%) = Alpha(row%, col%) - Beta(row%, col%)%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
csubexit:%@NL@%
EXIT FUNCTION%@NL@%
csuberr:%@NL@%
   MatSubC% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME csubexit:%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatSubD%====================================%@AE@%%@NL@%
%@AB@%'MatSubD% takes the difference of two double precision matrices and%@AE@%%@NL@%
%@AB@%'places the result in the first.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Alpha() = Alpha() - Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatSubD% (Alpha() AS DOUBLE, Beta() AS DOUBLE)%@NL@%
ON LOCAL ERROR GOTO dsuberr: MatSubD% = 0%@NL@%
%@AB@%'check if Alpha, Beta have same dimensions if not, exit and send back error%@AE@%%@NL@%
IF (LBOUND(Alpha, 1) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Beta, 1)) OR (LBOUND(Alpha, 2) <> LBOUND(Beta, 2)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 2)) THEN ERROR 196%@NL@%
%@AB@%'loop through and subtract elements%@AE@%%@NL@%
FOR row% = LBOUND(Alpha, 1) TO UBOUND(Alpha, 1)%@NL@%
   FOR col% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
      Alpha(row%, col%) = Alpha(row%, col%) - Beta(row%, col%)%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
dsubexit:%@NL@%
EXIT FUNCTION%@NL@%
dsuberr:%@NL@%
   MatSubD% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME dsubexit:%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatSubI%====================================%@AE@%%@NL@%
%@AB@%'MatSubI% takes the difference of two integer matrices and places the%@AE@%%@NL@%
%@AB@%'result in the first.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Alpha() = Alpha() - Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatSubI% (Alpha() AS INTEGER, Beta() AS INTEGER)%@NL@%
ON LOCAL ERROR GOTO isuberr: MatSubI% = 0%@NL@%
%@AB@%'check if Alpha, Beta have same dimensions if not, exit and send back error%@AE@%%@NL@%
IF (LBOUND(Alpha, 1) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Beta, 1)) OR (LBOUND(Alpha, 2) <> LBOUND(Beta, 2)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 2)) THEN ERROR 196%@NL@%
%@AB@%'loop through and subtract elements%@AE@%%@NL@%
FOR row% = LBOUND(Alpha, 1) TO UBOUND(Alpha, 1)%@NL@%
   FOR col% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
      Alpha(row%, col%) = Alpha(row%, col%) - Beta(row%, col%)%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
isubexit:%@NL@%
EXIT FUNCTION%@NL@%
isuberr:%@NL@%
   MatSubI% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME isubexit:%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatSubL%====================================%@AE@%%@NL@%
%@AB@%'MatSubL% takes the difference of two long integer matrices and places%@AE@%%@NL@%
%@AB@%'the result in the first.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Alpha() = Alpha() - Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatSubL% (Alpha() AS LONG, Beta() AS LONG)%@NL@%
ON LOCAL ERROR GOTO lsuberr: MatSubL% = 0%@NL@%
%@AB@%'check if Alpha, Beta have same dimensions if not, exit and send back error%@AE@%%@NL@%
IF (LBOUND(Alpha, 1) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Beta, 1)) OR (LBOUND(Alpha, 2) <> LBOUND(Beta, 2)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 2)) THEN ERROR 196%@NL@%
%@AB@%'loop through and subtract elements%@AE@%%@NL@%
FOR row% = LBOUND(Alpha, 1) TO UBOUND(Alpha, 1)%@NL@%
   FOR col% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
      Alpha(row%, col%) = Alpha(row%, col%) - Beta(row%, col%)%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
lsubexit:%@NL@%
EXIT FUNCTION%@NL@%
lsuberr:%@NL@%
   MatSubL% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME lsubexit:%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'=======================MatSubS%====================================%@AE@%%@NL@%
%@AB@%'MatSubS% takes the difference of two single precision matrices and%@AE@%%@NL@%
%@AB@%'places the result in the first.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Parameters: matrices Alpha,Beta%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'Returns: Alpha() = Alpha() - Beta()%@AE@%%@NL@%
%@AB@%'===================================================================%@AE@%%@NL@%
FUNCTION MatSubS% (Alpha() AS SINGLE, Beta() AS SINGLE)%@NL@%
ON LOCAL ERROR GOTO ssuberr: MatSubS% = 0%@NL@%
%@AB@%'check if Alpha, Beta have same dimensions if not, exit and send back error%@AE@%%@NL@%
IF (LBOUND(Alpha, 1) <> LBOUND(Beta, 1)) OR (UBOUND(Alpha, 1) <> UBOUND(Beta, 1)) OR (LBOUND(Alpha, 2) <> LBOUND(Beta, 2)) OR (UBOUND(Alpha, 2) <> UBOUND(Beta, 2)) THEN ERROR 196%@NL@%
%@AB@%'loop through and subtract elements%@AE@%%@NL@%
FOR row% = LBOUND(Alpha, 1) TO UBOUND(Alpha, 1)%@NL@%
   FOR col% = LBOUND(Alpha, 2) TO UBOUND(Alpha, 2)%@NL@%
      Alpha(row%, col%) = Alpha(row%, col%) - Beta(row%, col%)%@NL@%
   NEXT col%%@NL@%
NEXT row%%@NL@%
ssubexit:%@NL@%
EXIT FUNCTION%@NL@%
ssuberr:%@NL@%
   MatSubS% = (ERR + 5) MOD 200 - 5%@NL@%
   RESUME ssubexit:%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MENU.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MENU.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'============================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     MENU.BAS - Pull-down Menu Routines for the User Interface Toolbox in%@AE@%%@NL@%
%@AB@%'           Microsoft BASIC 7.0, Professional Development System%@AE@%%@NL@%
%@AB@%'              Copyright (C) 1987-1989, Microsoft Corporation%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  NOTE:    This sample source code toolbox is intended to demonstrate some%@AE@%%@NL@%
%@AB@%'           of the extended capabilities of Microsoft BASIC 7.0 Professional%@AE@%%@NL@%
%@AB@%'           Development system that can help to leverage the professional%@AE@%%@NL@%
%@AB@%'           developer's time more effectively.  While you are free to use,%@AE@%%@NL@%
%@AB@%'           modify, or distribute the routines in this module in any way you%@AE@%%@NL@%
%@AB@%'           find useful, it should be noted that these are examples only and%@AE@%%@NL@%
%@AB@%'           should not be relied upon as a fully-tested "add-on" library.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  PURPOSE: These are the routines which provide support for the pull-down%@AE@%%@NL@%
%@AB@%'           menus in the user interface toolbox.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  For information on creating a library and QuickLib from the routines%@AE@%%@NL@%
%@AB@%'  contained in this file, read the comment header of GENERAL.BAS.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'============================================================================%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
%@AB@%'$INCLUDE: 'general.bi'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'mouse.bi'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'menu.bi'%@AE@%%@NL@%
%@NL@%
COMMON SHARED /uitools/ GloMenu    AS MenuMiscType%@NL@%
COMMON SHARED /uitools/ GloTitle() AS MenuTitleType%@NL@%
COMMON SHARED /uitools/ GloItem()  AS MenuItemType%@NL@%
%@NL@%
FUNCTION MenuCheck (action%) STATIC%@NL@%
%@NL@%
    SELECT CASE action%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' This simulates "polling" for a menu event.  If a menu event occured,%@AE@%%@NL@%
%@AB@%    ' GloMenu.currMenu and .currItem are set.  When MenuCheck(0) is%@AE@%%@NL@%
%@AB@%    ' called, these values are transfered to .lastMenu and .lastItem.%@AE@%%@NL@%
%@AB@%    ' MenuCheck(0) then returns the menu number, or 0 (FALSE) if none%@AE@%%@NL@%
%@AB@%    ' selected as of last call%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
        CASE 0%@NL@%
            GloMenu.lastMenu = GloMenu.currMenu%@NL@%
            GloMenu.lastItem = GloMenu.currItem%@NL@%
            GloMenu.currMenu = 0%@NL@%
            GloMenu.currItem = 0%@NL@%
            MenuCheck = GloMenu.lastMenu%@NL@%
%@NL@%
%@AB@%        '===================================================================%@AE@%%@NL@%
%@AB@%        ' Returns the menu item last selected.  Functions only after a call%@AE@%%@NL@%
%@AB@%        ' to MenuCheck(0)%@AE@%%@NL@%
%@AB@%        '===================================================================%@AE@%%@NL@%
%@NL@%
        CASE 1%@NL@%
            MenuCheck = GloMenu.lastItem%@NL@%
%@NL@%
%@AB@%        '===================================================================%@AE@%%@NL@%
%@AB@%        ' Checks GloMenu.currMenu and .currItem.  If both are not 0, this%@AE@%%@NL@%
%@AB@%        ' returns TRUE meaning a menu has been selected since MenuCheck(0)%@AE@%%@NL@%
%@AB@%        ' was last called.  This does not change any values, it simply%@AE@%%@NL@%
%@AB@%        ' reports on the current state.%@AE@%%@NL@%
%@AB@%        '===================================================================%@AE@%%@NL@%
%@NL@%
        CASE 2%@NL@%
            IF GloMenu.currMenu = 0 OR GloMenu.currItem = 0 THEN%@NL@%
                MenuCheck = FALSE%@NL@%
            ELSE%@NL@%
                MenuCheck = TRUE%@NL@%
            END IF%@NL@%
        CASE ELSE%@NL@%
            MenuCheck = 0%@NL@%
    END SELECT%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB MenuColor (fore, back, highlight, disabled, cursorFore, cursorBack, cursorHi)%@NL@%
%@NL@%
    GloMenu.fore = fore%@NL@%
    GloMenu.back = back%@NL@%
    GloMenu.highlight = highlight%@NL@%
    GloMenu.disabled = disabled%@NL@%
    GloMenu.cursorFore = cursorFore%@NL@%
    GloMenu.cursorBack = cursorBack%@NL@%
    GloMenu.cursorHi = cursorHi%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB MenuDo STATIC%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' If menu event trapping turned off, return immediately%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    IF NOT GloMenu.MenuOn THEN%@NL@%
        EXIT SUB%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' Initialize MenuDo's variables, and then enter the main loop%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    GOSUB MenuDoInit%@NL@%
%@NL@%
    WHILE NOT MenuDoDone%@NL@%
%@NL@%
%@AB@%        '===================================================================%@AE@%%@NL@%
%@AB@%        ' If in MouseMode then%@AE@%%@NL@%
%@AB@%        '   if button is pressed, check where mouse is and react acccordingly.%@AE@%%@NL@%
%@AB@%        '   if button not pressed, switch to keyboard mode.%@AE@%%@NL@%
%@AB@%        '===================================================================%@AE@%%@NL@%
        IF mouseMode THEN%@NL@%
            MousePoll mouseRow, mouseCol, lButton, rButton%@NL@%
            IF lButton THEN%@NL@%
                IF mouseRow = 1 THEN%@NL@%
                    GOSUB MenuDoGetMouseMenu%@NL@%
                ELSE%@NL@%
                    GOSUB MenuDoGetMouseItem%@NL@%
                END IF%@NL@%
            ELSE%@NL@%
                mouseMode = FALSE%@NL@%
                GOSUB MenuDoMouseRelease%@NL@%
                IF NOT pulldown THEN%@NL@%
                    GOSUB MenuDoShowTitleAccessKeys%@NL@%
                END IF%@NL@%
            END IF%@NL@%
        ELSE%@NL@%
%@NL@%
%@AB@%            '===============================================================%@AE@%%@NL@%
%@AB@%            ' If in keyboard mode, show the cursor, wait for key, hide cursor%@AE@%%@NL@%
%@AB@%            ' Perform the desired action based on what key was pressed.%@AE@%%@NL@%
%@AB@%            '===============================================================%@AE@%%@NL@%
%@NL@%
            GOSUB MenuDoShowCursor%@NL@%
            GOSUB MenuDoGetKey%@NL@%
            GOSUB MenuDoHideCursor%@NL@%
%@NL@%
            SELECT CASE kbd$%@NL@%
                CASE "enter":       GOSUB MenuDoEnter%@NL@%
                CASE "up":          GOSUB MenuDoUp%@NL@%
                CASE "down":        GOSUB menuDoDown%@NL@%
                CASE "left":        GOSUB MenuDoLeft%@NL@%
                CASE "right":       GOSUB MenuDoRight%@NL@%
                CASE "escape":      GOSUB MenuDoEscape%@NL@%
                CASE "altReleased": GOSUB MenuDoAltReleased%@NL@%
                CASE "mouse":       GOSUB MenuDoMousePress%@NL@%
                CASE ELSE:          GOSUB MenuDoAccessKey%@NL@%
            END SELECT%@NL@%
        END IF%@NL@%
    WEND%@NL@%
    GOSUB MenuDoHideTitleAccessKeys%@NL@%
    EXIT SUB%@NL@%
%@NL@%
%@AB@%'===========================================================================%@AE@%%@NL@%
%@AB@%' Initialize variables for proper MenuDo execution.%@AE@%%@NL@%
%@AB@%'===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoInit:%@NL@%
    REDIM buffer$(MAXMENU), copyFlag(MAXMENU)             'Stores screen backround%@NL@%
%@NL@%
    FOR a = 1 TO MAXMENU%@NL@%
        buffer$(a) = ""                         '1 buffer per menu%@NL@%
        copyFlag(a) = FALSE                     'FALSE means not copied yet%@NL@%
    NEXT a%@NL@%
%@NL@%
    pulldown = FALSE                            'FALSE means no menu is shown%@NL@%
    MenuDoDone = FALSE                          'FALSE means keep going in loop%@NL@%
%@NL@%
    altWasReleased = FALSE                      'Set to TRUE if ALT is pressed%@NL@%
%@AB@%                                                'and then released%@AE@%%@NL@%
%@NL@%
    altWasPressedAgain = FALSE                  'Set to TRUE is ALT is pressed%@NL@%
%@AB@%                                                'and then released, and then%@AE@%%@NL@%
%@AB@%                                                'pressed again.%@AE@%%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' If mouse installed and button is pressed, then set MouseMode to TRUE%@AE@%%@NL@%
%@AB@%    ' Else, set MouseMode to FALSE%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    MousePoll mouseRow, mouseCol, lButton, rButton%@NL@%
    IF lButton THEN%@NL@%
        mouseMode = TRUE%@NL@%
        currMenu = 0%@NL@%
        currItem = 0%@NL@%
    ELSE%@NL@%
        mouseMode = FALSE%@NL@%
        currMenu = 1%@NL@%
        currItem = 0%@NL@%
        GOSUB MenuDoShowTitleAccessKeys%@NL@%
    END IF%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%'===========================================================================%@AE@%%@NL@%
%@AB@%' This shows the cursor at the location CurrMenu,CurrItem.%@AE@%%@NL@%
%@AB@%'===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoShowCursor:%@NL@%
%@NL@%
    MouseHide%@NL@%
    IF currMenu <> 0 AND RTRIM$(GloItem(currMenu, currItem).text) <> "-" THEN%@NL@%
        IF currItem = 0 THEN%@NL@%
            COLOR GloMenu.cursorFore, GloMenu.cursorBack%@NL@%
            LOCATE 1, GloTitle(currMenu).lColTitle%@NL@%
            PRINT " "; RTRIM$(GloTitle(currMenu).text); " ";%@NL@%
            IF NOT mouseMode THEN%@NL@%
               COLOR GloMenu.cursorHi, GloMenu.cursorBack%@NL@%
               LOCATE 1, GloTitle(currMenu).lColTitle + GloTitle(currMenu).accessKey%@NL@%
               PRINT MID$(GloTitle(currMenu).text, GloTitle(currMenu).accessKey, 1);%@NL@%
            END IF%@NL@%
        ELSE%@NL@%
            IF GloItem(currMenu, currItem).state = 2 THEN%@NL@%
                chk$ = CHR$(175)%@NL@%
            ELSE%@NL@%
                chk$ = " "%@NL@%
            END IF%@NL@%
%@NL@%
            COLOR GloMenu.cursorFore, GloMenu.cursorBack%@NL@%
            LOCATE GloItem(currMenu, currItem).row, GloTitle(currMenu).lColItem + 1%@NL@%
            PRINT chk$; LEFT$(GloItem(currMenu, currItem).text, GloTitle(currMenu).itemLength); " ";%@NL@%
%@NL@%
            IF GloItem(currMenu, currItem).state > 0 THEN%@NL@%
                COLOR GloMenu.cursorHi, GloMenu.cursorBack%@NL@%
                LOCATE GloItem(currMenu, currItem).row, col + GloItem(currMenu, currItem).accessKey + 1%@NL@%
                PRINT MID$(GloItem(currMenu, currItem).text, GloItem(currMenu, currItem).accessKey, 1);%@NL@%
            END IF%@NL@%
%@NL@%
        END IF%@NL@%
    END IF%@NL@%
    MouseShow%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%'===========================================================================%@AE@%%@NL@%
%@AB@%' This hides the cursor at the location CurrMenu,CurrItem.%@AE@%%@NL@%
%@AB@%'===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoHideCursor:%@NL@%
%@NL@%
    MouseHide%@NL@%
    IF currMenu <> 0 AND RTRIM$(GloItem(currMenu, currItem).text) <> "-" THEN%@NL@%
        IF currItem = 0 THEN%@NL@%
            SELECT CASE GloTitle(currMenu).state%@NL@%
                CASE 0: COLOR GloMenu.disabled, GloMenu.back%@NL@%
                CASE 1, 2: COLOR GloMenu.fore, GloMenu.back%@NL@%
                CASE ELSE%@NL@%
            END SELECT%@NL@%
            LOCATE 1, GloTitle(currMenu).lColTitle%@NL@%
            PRINT " "; RTRIM$(GloTitle(currMenu).text); " ";%@NL@%
%@NL@%
            IF GloTitle(currMenu).state > 0 THEN%@NL@%
                COLOR GloMenu.highlight, GloMenu.back%@NL@%
                LOCATE 1, GloTitle(currMenu).lColTitle + GloTitle(currMenu).accessKey%@NL@%
                PRINT MID$(GloTitle(currMenu).text, GloTitle(currMenu).accessKey, 1);%@NL@%
            END IF%@NL@%
        ELSE%@NL@%
            IF GloItem(currMenu, currItem).state = 2 THEN%@NL@%
                chk$ = CHR$(175)%@NL@%
            ELSE%@NL@%
                chk$ = " "%@NL@%
            END IF%@NL@%
            SELECT CASE GloItem(currMenu, currItem).state%@NL@%
                CASE 0: COLOR GloMenu.disabled, GloMenu.back%@NL@%
                CASE 1, 2: COLOR GloMenu.fore, GloMenu.back%@NL@%
                CASE ELSE%@NL@%
            END SELECT%@NL@%
            LOCATE GloItem(currMenu, currItem).row, GloTitle(currMenu).lColItem + 1%@NL@%
            PRINT chk$; LEFT$(GloItem(currMenu, currItem).text, GloTitle(currMenu).itemLength); " ";%@NL@%
%@NL@%
            IF GloItem(currMenu, currItem).state > 0 THEN%@NL@%
                COLOR GloMenu.highlight, GloMenu.back%@NL@%
                LOCATE GloItem(currMenu, currItem).row, col + GloItem(currMenu, currItem).accessKey + 1%@NL@%
                PRINT MID$(GloItem(currMenu, currItem).text, GloItem(currMenu, currItem).accessKey, 1);%@NL@%
            END IF%@NL@%
%@NL@%
        END IF%@NL@%
    END IF%@NL@%
    MouseShow%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%'===========================================================================%@AE@%%@NL@%
%@AB@%' Handles state where mouse is at row #1.%@AE@%%@NL@%
%@AB@%'===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoGetMouseMenu:%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' Computes the menu number based on mouse column location.  Uses info%@AE@%%@NL@%
%@AB@%    ' calculated in MenuShow()%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    newMenu = CVI(MID$(GloMenu.menuIndex, mouseCol * 2 - 1, 2))%@NL@%
%@NL@%
    IF GloTitle(newMenu).state <> 1 THEN%@NL@%
        newMenu = 0%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' If new menu<>current menu, hide current menu, show new menu, assign new%@AE@%%@NL@%
%@AB@%    ' menu to current menu%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    IF newMenu <> currMenu THEN%@NL@%
        GOSUB MenuDoHidePullDown%@NL@%
        currMenu = newMenu%@NL@%
        currItem = 0%@NL@%
        GOSUB menuDoShowPullDown%@NL@%
    END IF%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%'===========================================================================%@AE@%%@NL@%
%@AB@%' Handles state where mouse is not in row #1.  If a menu is down, it picks%@AE@%%@NL@%
%@AB@%' the proper menu item based on which row the mouse is located%@AE@%%@NL@%
%@AB@%'===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoGetMouseItem:%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' If pulldown, and mouse column is within the menu area, then compute new%@AE@%%@NL@%
%@AB@%    ' item  based on computations done in MenuShow.  If not in box, then new%@AE@%%@NL@%
%@AB@%    ' item = 0%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    IF pulldown THEN%@NL@%
        IF mouseCol >= GloTitle(currMenu).lColItem AND mouseCol <= GloTitle(currMenu).rColItem AND mouseRow <= GloTitle(currMenu).lowestRow AND mouseRow - 2 <= MAXITEM THEN%@NL@%
            newItem = GloItem(currMenu, mouseRow - 2).index%@NL@%
        ELSE%@NL@%
            newItem = 0%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If current item <> new item, hide old cursor, show new cursor,%@AE@%%@NL@%
%@AB@%        ' assign new item to current item.%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF currItem <> newItem THEN%@NL@%
            IF currItem <> 0 THEN%@NL@%
                GOSUB MenuDoHideCursor%@NL@%
            END IF%@NL@%
            currItem = newItem%@NL@%
            GOSUB MenuDoShowCursor%@NL@%
        END IF%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Handles state when MenuDo is in mouse mode, and mouse button is released.%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoMouseRelease:%@NL@%
    menuMode = FALSE%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If no menu selected, then exit MenuDo returning 0s for menu and item%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF currMenu = 0 THEN%@NL@%
        GloMenu.currMenu = 0%@NL@%
        GloMenu.currItem = 0%@NL@%
        MenuDoDone = TRUE%@NL@%
    ELSE%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If menu is down, but no item is selected then%@AE@%%@NL@%
%@AB@%        '    if mouse is on the top row, simply gosub the MenuDoDown routine%@AE@%%@NL@%
%@AB@%        '    else hide menu then exit MenuDo returning 0's for menu and item%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF currItem = 0 THEN%@NL@%
            IF mouseRow = 1 THEN%@NL@%
                GOSUB menuDoDown%@NL@%
            ELSE%@NL@%
                GOSUB MenuDoHidePullDown%@NL@%
                GloMenu.currMenu = 0%@NL@%
                GloMenu.currItem = 0%@NL@%
                MenuDoDone = TRUE%@NL@%
            END IF%@NL@%
        ELSE%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' If current (menu,item)'s state is disabled, then just beep%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            IF GloItem(currMenu, currItem).state = 0 THEN%@NL@%
                BEEP%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' If current (menu,item)'s state is a line%@AE@%%@NL@%
%@AB@%            ' then exit MenuDo returning 0s for menu and item%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            ELSEIF RTRIM$(GloItem(currMenu, currItem).text) = "-" THEN%@NL@%
                GOSUB MenuDoHidePullDown%@NL@%
                GloMenu.currMenu = 0%@NL@%
                GloMenu.currItem = 0%@NL@%
                MenuDoDone = TRUE%@NL@%
            ELSE%@NL@%
%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
%@AB@%                ' Otherwise, selection must be valid, exit MenuDo, returning%@AE@%%@NL@%
%@AB@%                ' proper menu,item pair in the proper global variables%@AE@%%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
                GOSUB MenuDoHidePullDown%@NL@%
                GloMenu.currMenu = currMenu%@NL@%
                GloMenu.currItem = currItem%@NL@%
                MenuDoDone = TRUE%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ==========================================================================%@AE@%%@NL@%
%@AB@%' This routine shows the menu bar's access keys%@AE@%%@NL@%
%@AB@%' ==========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoShowTitleAccessKeys:%@NL@%
    MouseHide%@NL@%
    COLOR GloMenu.highlight, GloMenu.back%@NL@%
    FOR menu = 1 TO MAXMENU%@NL@%
        IF GloTitle(menu).state = 1 THEN%@NL@%
            LOCATE 1, GloTitle(menu).lColTitle + GloTitle(menu).accessKey%@NL@%
            PRINT MID$(GloTitle(menu).text, GloTitle(menu).accessKey, 1);%@NL@%
        END IF%@NL@%
    NEXT menu%@NL@%
    MouseShow%@NL@%
RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' This routine hides the menu bar's access keys%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoHideTitleAccessKeys:%@NL@%
    MouseHide%@NL@%
    COLOR GloMenu.fore, GloMenu.back%@NL@%
    FOR menu = 1 TO MAXMENU%@NL@%
        IF GloTitle(menu).state = 1 THEN%@NL@%
            LOCATE 1, GloTitle(menu).lColTitle + GloTitle(menu).accessKey%@NL@%
            PRINT MID$(GloTitle(menu).text, GloTitle(menu).accessKey, 1);%@NL@%
        END IF%@NL@%
    NEXT menu%@NL@%
    MouseShow%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Waits for key press, then returns the key press.  It also returns several%@AE@%%@NL@%
%@AB@%' tokens such as "menu", or "altReleased" in special cases.  Read on...%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoGetKey:%@NL@%
    DO%@NL@%
        kbd$ = INKEY$%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If ALT key pressed, then if it was a access key (Alt+A..) reduce%@AE@%%@NL@%
%@AB@%        '  the Alt+A to A.%@AE@%%@NL@%
%@AB@%        '  Also set the altPressed flags to reflect the current state of the%@AE@%%@NL@%
%@AB@%        '  ALT key.%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF GetShiftState(3) THEN%@NL@%
            IF kbd$ = "" THEN%@NL@%
                IF altWasReleased THEN%@NL@%
                    altWasPressedAgain = TRUE%@NL@%
                END IF%@NL@%
            ELSE%@NL@%
                altWasPressedAgain = FALSE%@NL@%
                kbd$ = AltToASCII(kbd$)%@NL@%
            END IF%@NL@%
            altWasReleased = FALSE%@NL@%
        ELSE%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' If ALT key is released (initially), then pressed, then released%@AE@%%@NL@%
%@AB@%            ' again with no other action in between, then return the%@AE@%%@NL@%
%@AB@%            ' token "altReleased"%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            IF altWasPressedAgain THEN%@NL@%
                kbd$ = "altReleased"%@NL@%
                altWasPressedAgain = FALSE%@NL@%
            ELSE%@NL@%
%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
%@AB@%                ' Based on the key that was pressed, return the proper token%@AE@%%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
%@NL@%
                altWasReleased = TRUE%@NL@%
%@NL@%
                SELECT CASE kbd$%@NL@%
                    CASE CHR$(27) + "": kbd$ = "escape"%@NL@%
                    CASE CHR$(32) + "": kbd$ = ""%@NL@%
                    CASE CHR$(13) + "": kbd$ = "enter"%@NL@%
                    CASE CHR$(0) + "H": kbd$ = "up"%@NL@%
                    CASE CHR$(0) + "P": kbd$ = "down"%@NL@%
                    CASE CHR$(0) + "K": kbd$ = "left"%@NL@%
                    CASE CHR$(0) + "M": kbd$ = "right"%@NL@%
                    CASE ELSE%@NL@%
                        IF LEN(kbd$) = 1 THEN%@NL@%
                            kbd$ = UCASE$(kbd$)%@NL@%
                        END IF%@NL@%
                END SELECT%@NL@%
            END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If mouse button is pressed, it overrides all key actions, and%@AE@%%@NL@%
%@AB@%        ' the token "mouse" is returned%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        MousePoll mouseRow, mouseCol, lButton, rButton%@NL@%
        IF lButton THEN%@NL@%
            kbd$ = "mouse"%@NL@%
        END IF%@NL@%
%@NL@%
    LOOP UNTIL kbd$ <> ""%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Handles the state where the up arrow is pressed.  It searches for the%@AE@%%@NL@%
%@AB@%' first non empty, non "-" (dashed) item.%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoUp:%@NL@%
    IF currItem <> 0 THEN%@NL@%
        DO%@NL@%
            currItem = (currItem + MAXITEM - 2) MOD MAXITEM + 1%@NL@%
        LOOP UNTIL GloItem(currMenu, currItem).state >= 0 AND RTRIM$(GloItem(currMenu, currItem).text) <> "-"%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Handles 2 different states:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  State 1: Menu is open, and the down arrow is pressed.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  State 2: Any time a new menu is opened, and the top item%@AE@%%@NL@%
%@AB@%'      is to be the current item.  Specifically:%@AE@%%@NL@%
%@AB@%'          - When no menu is opened, and the down arrow is pressed%@AE@%%@NL@%
%@AB@%'          - When the mouse is released over the menu title%@AE@%%@NL@%
%@AB@%'          - When a menu is opened, and the user hits right/left arrow%@AE@%%@NL@%
%@AB@%'          - When enter is pressed while cursor is on title bar%@AE@%%@NL@%
%@AB@%'          - When a access key is used on the title bar.%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
menuDoDown:%@NL@%
    DO%@NL@%
        IF currItem = 0 THEN%@NL@%
            GOSUB MenuDoHideTitleAccessKeys%@NL@%
            GOSUB menuDoShowPullDown%@NL@%
            currItem = (currItem) MOD MAXITEM + 1%@NL@%
        ELSEIF currItem > 0 THEN%@NL@%
            currItem = (currItem) MOD MAXITEM + 1%@NL@%
        END IF%@NL@%
%@NL@%
    LOOP UNTIL GloItem(currMenu, currItem).state >= 0 AND RTRIM$(GloItem(currMenu, currItem).text) <> "-"%@NL@%
RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Handles state when the left arrow is pressed.  If a menu is down, it%@AE@%%@NL@%
%@AB@%' hides it.  It then finds the first valid menu to the left.  If the menu%@AE@%%@NL@%
%@AB@%' was initially down, then the new menu is pulled down as well%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoLeft:%@NL@%
    IF pulldown THEN%@NL@%
        GOSUB MenuDoHidePullDown%@NL@%
        pulldown = TRUE%@NL@%
    END IF%@NL@%
%@NL@%
    DO%@NL@%
        currMenu = (currMenu + MAXMENU - 2) MOD MAXMENU + 1%@NL@%
    LOOP UNTIL GloTitle(currMenu).state = 1%@NL@%
%@NL@%
    IF pulldown THEN%@NL@%
        currItem = 0%@NL@%
        GOSUB menuDoDown%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Handles state when the right arrow is pressed.  If a menu is down, it%@AE@%%@NL@%
%@AB@%' hides it.  It then finds the first valid menu to the right.  If the menu%@AE@%%@NL@%
%@AB@%' was initially down, then the new menu is pulled down as well%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoRight:%@NL@%
    IF pulldown THEN%@NL@%
        GOSUB MenuDoHidePullDown%@NL@%
        pulldown = TRUE%@NL@%
    END IF%@NL@%
%@NL@%
    DO%@NL@%
        currMenu = (currMenu) MOD MAXMENU + 1%@NL@%
    LOOP UNTIL GloTitle(currMenu).state = 1%@NL@%
%@NL@%
    IF pulldown THEN%@NL@%
        currItem = 0%@NL@%
        GOSUB menuDoDown%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Handles state when the ESC key is pressed.  First hides the menu, and%@AE@%%@NL@%
%@AB@%' then exits menuDo, returning 0's in the proper global variables%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoEscape:%@NL@%
    GOSUB MenuDoHidePullDown%@NL@%
    GloMenu.currMenu = 0%@NL@%
    GloMenu.currItem = 0%@NL@%
    MenuDoDone = TRUE%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Handles state when Enter is pressed.  If on a valid item, return the%@AE@%%@NL@%
%@AB@%' proper (menu,item) pair and exit.  Else beep.  If on a valid menu%@AE@%%@NL@%
%@AB@%' this will open the menu by calling MenuDoDown%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoEnter:%@NL@%
    IF currItem = 0 THEN%@NL@%
        IF GloTitle(currMenu).state = 0 THEN%@NL@%
            BEEP%@NL@%
        ELSE%@NL@%
            GOSUB menuDoDown%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
        IF GloItem(currMenu, currItem).state <= 0 THEN%@NL@%
            BEEP%@NL@%
        ELSE%@NL@%
            GOSUB MenuDoHidePullDown%@NL@%
            GloMenu.currMenu = currMenu%@NL@%
            GloMenu.currItem = currItem%@NL@%
            MenuDoDone = TRUE%@NL@%
        END IF%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' If ALT pressed and released with nothing else happening in between, it%@AE@%%@NL@%
%@AB@%' will exit if no menu is open, or close the menu if one is open.%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoAltReleased:%@NL@%
    IF pulldown THEN%@NL@%
        GOSUB MenuDoHidePullDown%@NL@%
        currItem = 0%@NL@%
        GOSUB MenuDoShowTitleAccessKeys%@NL@%
    ELSE%@NL@%
        GloMenu.currMenu = 0%@NL@%
        GloMenu.currItem = 0%@NL@%
        MenuDoDone = TRUE%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' If mouse is pressed while in keyboard mode, this routine assigns%@AE@%%@NL@%
%@AB@%' TRUE to MouseMode, resets the item, and hides the access keys%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoMousePress:%@NL@%
    mouseMode = TRUE%@NL@%
    currItem = 0%@NL@%
    IF NOT pulldown THEN%@NL@%
        GOSUB MenuDoHideTitleAccessKeys%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' If a access key is pressed%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoAccessKey:%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If an access key is pressed%@AE@%%@NL@%
%@AB@%    '   If no menu selected, search titles for matching access key, and open%@AE@%%@NL@%
%@AB@%    '      than menu.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF currItem = 0 THEN%@NL@%
        newMenu = (currMenu + MAXMENU - 2) MOD MAXMENU + 1%@NL@%
        loopEnd = (currMenu + MAXMENU - 2) MOD MAXMENU + 1%@NL@%
        DO%@NL@%
            newMenu = (newMenu) MOD MAXMENU + 1%@NL@%
        LOOP UNTIL (UCASE$(MID$(GloTitle(newMenu).text, GloTitle(newMenu).accessKey, 1)) = kbd$ AND GloTitle(newMenu).state = 1) OR newMenu = loopEnd%@NL@%
%@NL@%
        IF kbd$ = UCASE$(MID$(GloTitle(newMenu).text, GloTitle(newMenu).accessKey, 1)) THEN%@NL@%
            currMenu = newMenu%@NL@%
            GOSUB menuDoDown%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If menu is selected, search items for matching access key, and%@AE@%%@NL@%
%@AB@%        ' select that (menu,item) and exit MenuDo if item is enabled%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        newItem = (currItem + MAXITEM - 2) MOD MAXITEM + 1%@NL@%
        loopEnd = (currItem + MAXITEM - 2) MOD MAXITEM + 1%@NL@%
        DO%@NL@%
            newItem = (newItem) MOD MAXITEM + 1%@NL@%
        LOOP UNTIL (UCASE$(MID$(GloItem(currMenu, newItem).text, GloItem(currMenu, newItem).accessKey, 1)) = kbd$ AND GloItem(currMenu, newItem).state > 0 AND RTRIM$(GloItem(currMenu, newItem).text) <> "-") OR newItem = loopEnd%@NL@%
%@NL@%
%@NL@%
        IF kbd$ = UCASE$(MID$(GloItem(currMenu, newItem).text, GloItem(currMenu, newItem).accessKey, 1)) THEN%@NL@%
            currItem = newItem%@NL@%
%@NL@%
            IF GloItem(currMenu, currItem).state <= 0 THEN%@NL@%
                BEEP%@NL@%
            ELSE%@NL@%
                GOSUB MenuDoHidePullDown%@NL@%
                GloMenu.currMenu = currMenu%@NL@%
                GloMenu.currItem = currItem%@NL@%
                MenuDoDone = TRUE%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Draws the menu -- only if menu is enabled.%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
menuDoShowPullDown:%@NL@%
    IF currMenu <> 0 AND GloTitle(currMenu).state = 1 THEN%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Copies the background if this is the first time this particular%@AE@%%@NL@%
%@AB@%        ' menu is being drawn%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        MouseHide%@NL@%
        IF NOT copyFlag(currMenu) THEN%@NL@%
            IF GloTitle(currMenu).rColItem - GloTitle(currMenu).lColItem < LEN(GloTitle(currMenu).text) THEN%@NL@%
                GloTitle(currMenu).rColItem = GloTitle(currMenu).lColItem + LEN(GloTitle(currMenu).text)%@NL@%
            END IF%@NL@%
%@NL@%
            GetBackground 1, GloTitle(currMenu).lColItem, GloTitle(currMenu).lowestRow, GloTitle(currMenu).rColItem + 2, buffer$(currMenu)%@NL@%
            copyFlag(currMenu) = TRUE%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Draw the menu, this is pretty straight forward%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
        pulldown = TRUE%@NL@%
        length = GloTitle(currMenu).itemLength%@NL@%
        IF length = 0 THEN length = 6%@NL@%
        lowestRow = 3%@NL@%
        col = GloTitle(currMenu).lColItem%@NL@%
%@NL@%
        COLOR GloMenu.cursorFore, GloMenu.cursorBack%@NL@%
        LOCATE 1, GloTitle(currMenu).lColTitle%@NL@%
        PRINT " "; RTRIM$(GloTitle(currMenu).text); " ";%@NL@%
%@NL@%
        COLOR GloMenu.fore, GloMenu.back%@NL@%
        LOCATE 2, col%@NL@%
        PRINT ""; STRING$(length + 2, ""); ""%@NL@%
%@NL@%
        FOR item = 1 TO MAXITEM%@NL@%
            IF GloItem(currMenu, item).state >= 0 THEN%@NL@%
                IF GloItem(currMenu, item).state = 2 THEN%@NL@%
                    chk$ = CHR$(175)%@NL@%
                ELSE%@NL@%
                    chk$ = " "%@NL@%
                END IF%@NL@%
%@NL@%
                LOCATE GloItem(currMenu, item).row, col%@NL@%
                COLOR GloMenu.fore, GloMenu.back%@NL@%
%@NL@%
                IF RTRIM$(GloItem(currMenu, item).text) = "-" THEN%@NL@%
                    PRINT ""; STRING$(length + 2, ""); ""%@NL@%
                ELSE%@NL@%
                    PRINT ""; chk$;%@NL@%
                    IF GloItem(currMenu, item).state > 0 THEN%@NL@%
                        COLOR GloMenu.fore, GloMenu.back%@NL@%
                    ELSE%@NL@%
                        COLOR GloMenu.disabled, GloMenu.back%@NL@%
                    END IF%@NL@%
                    PRINT LEFT$(GloItem(currMenu, item).text + SPACE$(20), length);%@NL@%
                    COLOR GloMenu.fore, GloMenu.back%@NL@%
                    PRINT " ";%@NL@%
%@NL@%
                    IF GloItem(currMenu, item).state > 0 THEN%@NL@%
                        COLOR GloMenu.highlight, GloMenu.back%@NL@%
                        LOCATE GloItem(currMenu, item).row, col + GloItem(currMenu, item).accessKey + 1%@NL@%
                        PRINT MID$(GloItem(currMenu, item).text, GloItem(currMenu, item).accessKey, 1);%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
                lowestRow = GloItem(currMenu, item).row + 1%@NL@%
            END IF%@NL@%
        NEXT item%@NL@%
%@NL@%
        COLOR GloMenu.fore, GloMenu.back%@NL@%
        LOCATE lowestRow, col%@NL@%
        PRINT ""; STRING$(length + 2, ""); "";%@NL@%
%@NL@%
        rCol = col + length + 5%@NL@%
%@NL@%
        AttrBox 3, rCol - 1, lowestRow, rCol, 8%@NL@%
        AttrBox lowestRow + 1, col + 2, lowestRow + 1, rCol, 8%@NL@%
    END IF%@NL@%
%@NL@%
    MouseShow%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Replace the background over the menu%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuDoHidePullDown:%@NL@%
    IF pulldown THEN%@NL@%
        MouseHide%@NL@%
%@NL@%
        PutBackground 1, GloTitle(currMenu).lColItem, buffer$(currMenu)%@NL@%
%@NL@%
        MouseShow%@NL@%
        pulldown = FALSE%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB MenuEvent%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If ALT key is pressed, let MenuDo take over.  NOTE:  This will%@AE@%%@NL@%
%@AB@%    ' not call MenuDo if the ALT key has not been released at least%@AE@%%@NL@%
%@AB@%    ' once since the last time MenuDo was called.  This prevents the menu%@AE@%%@NL@%
%@AB@%    ' from flashing if the user simply holds down the ALT key.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GetShiftState(3) THEN%@NL@%
        IF GloMenu.altKeyReset THEN%@NL@%
            MenuDo%@NL@%
            GloMenu.altKeyReset = FALSE%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
        GloMenu.altKeyReset = TRUE%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Call MenuDo if the mouse button is down, and the cursor is on the top row%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    MousePoll mouseRow, mouseCol, lButton, rButton%@NL@%
    IF mouseRow = 1 AND lButton THEN%@NL@%
        MenuDo%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB MenuInit%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    '  Initialize global menu arrays%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    FOR menu = 1 TO MAXMENU%@NL@%
        GloTitle(menu).text = ""%@NL@%
        GloTitle(menu).state = -1            'state of -1 means "empty"%@NL@%
        GloTitle(menu).rColItem = 0           'These get set in MenuShow%@NL@%
        GloTitle(menu).lColItem = 0           ' |%@NL@%
        GloTitle(menu).rColTitle = 0          ' |%@NL@%
        GloTitle(menu).lColTitle = 0          ' |%@NL@%
        GloTitle(menu).itemLength = 0         ' |%@NL@%
        GloTitle(menu).accessKey = 1            'Initial AccessKey of 1%@NL@%
%@NL@%
        FOR item = 1 TO MAXITEM%@NL@%
            GloItem(menu, item).text = ""%@NL@%
            GloItem(menu, item).state = -1      'state of -1 means "empty"%@NL@%
            GloItem(menu, item).index = 0       'These get set in MenuShow%@NL@%
            GloItem(menu, item).row = 0         '  |%@NL@%
            GloItem(menu, item).accessKey = 1   'Initial AccessKey of 1%@NL@%
        NEXT item%@NL@%
    NEXT menu%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Initialize mouse%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    MouseInit%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Set initial state of ALT key to "reset"%@AE@%%@NL@%
%@AB@%    ' Clear out shortcut key index%@AE@%%@NL@%
%@AB@%    ' Set initial state of menu to ON%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    GloMenu.altKeyReset = TRUE%@NL@%
    GloMenu.shortcutKeyIndex = STRING$(100, 0)%@NL@%
    GloMenu.MenuOn = TRUE%@NL@%
%@NL@%
    GloMenu.fore = 0%@NL@%
    GloMenu.back = 7%@NL@%
    GloMenu.highlight = 15%@NL@%
    GloMenu.disabled = 8%@NL@%
    GloMenu.cursorFore = 7%@NL@%
    GloMenu.cursorBack = 0%@NL@%
    GloMenu.cursorHi = 15%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
FUNCTION MenuInkey$ STATIC%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Scan keyboard, return KBD$ by default -- unless it is over written below%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    kbd$ = INKEY$%@NL@%
    MenuInkey$ = kbd$%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Check if KBD$ matches a shortcut key.  If it does, return "menu" instead%@AE@%%@NL@%
%@AB@%    ' of the key that was pressed%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    ShortCutKeyEvent kbd$%@NL@%
    IF MenuCheck(2) THEN%@NL@%
        MenuInkey$ = "menu"%@NL@%
    ELSE%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Call menu event, which looks at mouse, and state of ALT key%@AE@%%@NL@%
%@AB@%        ' If a menu item is selected, return "menu" instead of KBD$%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        MenuEvent%@NL@%
        IF MenuCheck(2) THEN%@NL@%
            MenuInkey$ = "menu"%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB MenuItemToggle (menu, item)%@NL@%
%@NL@%
    IF item >= 0 AND menu >= 1 AND item <= MAXITEM AND menu <= MAXMENU THEN%@NL@%
%@NL@%
        IF item = 0 OR GloItem(menu, item).state < 1 OR GloItem(menu, item).state > 2 THEN%@NL@%
            SOUND 2000, 40%@NL@%
        ELSE%@NL@%
            GloItem(menu, item).state = 3 - GloItem(menu, item).state%@NL@%
        END IF%@NL@%
%@NL@%
    END IF%@NL@%
END SUB%@NL@%
%@NL@%
DEFSNG A-Z%@NL@%
SUB MenuOff%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Simply assigns FALSE to the proper global variable%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    GloMenu.MenuOn = FALSE%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
SUB MenuOn%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Simply assigns TRUE to the proper global variable%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    GloMenu.MenuOn = TRUE%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB MenuPreProcess STATIC%@NL@%
%@NL@%
    currCol = 2     'Represents the col where first menu title is located%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Menu index is a fast way of decoding which menu the mouse cursor%@AE@%%@NL@%
%@AB@%    ' is pointing to based on the col of the cursor.  See MENU.BI for details.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    GloMenu.menuIndex = STRING$(160, 0)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Process each menu, one at a time%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    FOR menu = 1 TO MAXMENU%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If state is empty, or text is "" then clear out data for that menu%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF GloTitle(menu).state < 0 OR LEN(RTRIM$(GloTitle(menu).text)) = 0 THEN%@NL@%
            GloTitle(menu).rColItem = 0%@NL@%
            GloTitle(menu).lColItem = 0%@NL@%
            GloTitle(menu).rColTitle = 0%@NL@%
            GloTitle(menu).lColTitle = 0%@NL@%
            GloTitle(menu).itemLength = 0%@NL@%
            GloTitle(menu).state = -1%@NL@%
       ELSE%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' else, assign data about the column location to the global storage%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            GloTitle(menu).lColTitle = currCol%@NL@%
            GloTitle(menu).rColTitle = currCol + LEN(RTRIM$(GloTitle(menu).text)) + 1%@NL@%
            GloTitle(menu).lColItem = currCol - 1%@NL@%
%@NL@%
            IF GloTitle(menu).rColTitle > MAXCOL THEN%@NL@%
                BEEP: CLS : PRINT "Menu bar longer than screen!  Cannot function!"%@NL@%
                END%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Update the index about where the menu is located, increment%@AE@%%@NL@%
%@AB@%            ' currCol%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            FOR index = currCol TO currCol + LEN(RTRIM$(GloTitle(menu).text)) + 1%@NL@%
                MID$(GloMenu.menuIndex, index * 2 - 1, 2) = MKI$(menu)%@NL@%
            NEXT index%@NL@%
%@NL@%
            currCol = currCol + LEN(RTRIM$(GloTitle(menu).text)) + 2%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Process the items in the menu, computing the%@AE@%%@NL@%
%@AB@%            ' longest item, and preparing the row index%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            GloTitle(menu).itemLength = 0%@NL@%
            currRow = 3%@NL@%
            iFlag = FALSE%@NL@%
%@NL@%
            FOR item = 1 TO MAXITEM%@NL@%
                GloItem(menu, currRow - 2).index = 0%@NL@%
                IF GloItem(menu, item).state >= 0 THEN%@NL@%
                    GloItem(menu, currRow - 2).index = item%@NL@%
                    GloItem(menu, item).row = currRow%@NL@%
                    currRow = currRow + 1%@NL@%
                    IF LEN(RTRIM$(GloItem(menu, item).text)) > GloTitle(menu).itemLength THEN%@NL@%
                        GloTitle(menu).itemLength = LEN(RTRIM$(GloItem(menu, item).text))%@NL@%
                    END IF%@NL@%
                    iFlag = TRUE%@NL@%
                END IF%@NL@%
            NEXT item%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' If all items were empty, disable the menu itself%@AE@%%@NL@%
%@AB@%            ' else, assign the longest length to the proper variable%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            IF NOT iFlag THEN%@NL@%
                GloTitle(menu).state = 0%@NL@%
            ELSE%@NL@%
                GloTitle(menu).rColItem = GloTitle(menu).lColItem + GloTitle(menu).itemLength + 3%@NL@%
                IF GloTitle(menu).rColItem > MAXCOL - 2 THEN%@NL@%
                   diff = GloTitle(menu).rColItem - (MAXCOL - 2)%@NL@%
                   GloTitle(menu).rColItem = GloTitle(menu).rColItem - diff%@NL@%
                   GloTitle(menu).lColItem = GloTitle(menu).lColItem - diff%@NL@%
                END IF%@NL@%
            END IF%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
        GloTitle(menu).lowestRow = currRow + 1%@NL@%
    NEXT menu%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB MenuSet (menu, item, state, text$, accessKey) STATIC%@NL@%
%@NL@%
    IF accessKey > LEN(text$) THEN accessKey = LEN(text$)%@NL@%
%@NL@%
    IF item >= 0 AND menu >= 1 AND item <= MAXITEM AND menu <= MAXMENU THEN%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Assign parameters to proper global menu variables%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF item = 0 THEN%@NL@%
            IF state < -1 OR state > 1 THEN%@NL@%
                SOUND 3000, 40%@NL@%
            ELSE%@NL@%
                GloTitle(menu).text = text$%@NL@%
                GloTitle(menu).state = state%@NL@%
                GloTitle(menu).accessKey = accessKey%@NL@%
            END IF%@NL@%
        ELSE%@NL@%
            IF state < -1 OR state > 2 THEN%@NL@%
                SOUND 4000, 40%@NL@%
            ELSE%@NL@%
                GloItem(menu, item).text = text$%@NL@%
                GloItem(menu, item).state = state%@NL@%
                GloItem(menu, item).accessKey = accessKey%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB MenuSetState (menu, item, state) STATIC%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Assign parameters to proper global menu variables%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF item = 0 THEN%@NL@%
        IF state < 0 OR state > 1 OR GloTitle(menu).state < 0 THEN%@NL@%
            SOUND 5000, 40%@NL@%
        ELSE%@NL@%
            GloTitle(menu).state = state%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
        IF state < 0 OR state > 2 OR GloItem(menu, item).state < 0 THEN%@NL@%
            SOUND 6000, 40%@NL@%
        ELSE%@NL@%
            GloItem(menu, item).state = state%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
DEFSNG A-Z%@NL@%
SUB MenuShow%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' This section actually prints the menu on the screen%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    COLOR GloMenu.fore, GloMenu.back%@NL@%
    LOCATE 1, 1%@NL@%
    PRINT SPACE$(MAXCOL);%@NL@%
%@NL@%
    FOR menu = 1 TO MAXMENU%@NL@%
        SELECT CASE GloTitle(menu).state%@NL@%
            CASE 0:%@NL@%
                COLOR GloMenu.disabled, GloMenu.back%@NL@%
                LOCATE 1, GloTitle(menu).lColTitle + 1%@NL@%
                PRINT RTRIM$(GloTitle(menu).text$);%@NL@%
            CASE 1:%@NL@%
                COLOR GloMenu.fore, GloMenu.back%@NL@%
                LOCATE 1, GloTitle(menu).lColTitle + 1%@NL@%
                PRINT RTRIM$(GloTitle(menu).text$);%@NL@%
            CASE ELSE%@NL@%
        END SELECT%@NL@%
%@NL@%
    NEXT menu%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
SUB ShortCutKeyDelete (menu, item) STATIC%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' Search through shortcut key index until the menu,item pair is found%@AE@%%@NL@%
%@AB@%    ' or the end of the list is reached.%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    ptr = -1%@NL@%
    DO%@NL@%
        ptr = ptr + 1%@NL@%
        temp = CVI(MID$(GloMenu.shortcutKeyIndex, ptr * 4 + 1, 2))%@NL@%
        testMenu = INT(temp / 256)%@NL@%
        testItem = INT(temp MOD 256)%@NL@%
    LOOP UNTIL (menu = testMenu AND item = testItem) OR testMenu = 0 AND testItem = 0 OR ptr = 25%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' If a match is found, delete the shortcut key by squeezing out the four%@AE@%%@NL@%
%@AB@%    ' bytes that represents the shortcut key, and adding four chr$(0) at the%@AE@%%@NL@%
%@AB@%    ' end.%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    IF menu = testMenu AND item = testItem THEN%@NL@%
        GloMenu.shortcutKeyIndex = LEFT$(GloMenu.shortcutKeyIndex, ptr * 4) + RIGHT$(GloMenu.shortcutKeyIndex, 96 - ptr * 4) + STRING$(4, 0)%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB ShortCutKeyEvent (theKey$)%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' If menu event trapping turned off, return immediately%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    IF NOT GloMenu.MenuOn THEN%@NL@%
        EXIT SUB%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' Make sure the length of theKey$ is two bytes by adding a chr$(0) if%@AE@%%@NL@%
%@AB@%    ' necessary.  If the length is > 2, make it null.%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    SELECT CASE LEN(theKey$)%@NL@%
        CASE 1%@NL@%
            theKey$ = theKey$ + CHR$(0)%@NL@%
        CASE 2%@NL@%
        CASE ELSE%@NL@%
            theKey$ = ""%@NL@%
    END SELECT%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' Search the shortcut key list for a match -- only if theKey$ is valid.%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    IF theKey$ <> "" THEN%@NL@%
%@NL@%
        ptr = -1%@NL@%
        DO%@NL@%
            ptr = ptr + 1%@NL@%
            testKey$ = MID$(GloMenu.shortcutKeyIndex, ptr * 4 + 3, 2)%@NL@%
%@NL@%
        LOOP UNTIL theKey$ = testKey$ OR testKey$ = STRING$(2, 0) OR ptr = 25%@NL@%
%@NL@%
%@AB@%        '===================================================================%@AE@%%@NL@%
%@AB@%        ' If match is found, make sure menu choice is valid (state > 0)%@AE@%%@NL@%
%@AB@%        ' If so, assign the proper global variables.%@AE@%%@NL@%
%@AB@%        '===================================================================%@AE@%%@NL@%
%@NL@%
    IF theKey$ = testKey$ THEN%@NL@%
            temp = CVI(MID$(GloMenu.shortcutKeyIndex, ptr * 4 + 1, 2))%@NL@%
            tempMenu = INT(temp / 256)%@NL@%
            tempItem = INT(temp MOD 256)%@NL@%
%@NL@%
            IF GloItem(tempMenu, tempItem).state > 0 THEN%@NL@%
                GloMenu.currMenu = tempMenu%@NL@%
                GloMenu.currItem = tempItem%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB ShortCutKeySet (menu, item, shortcutKey$)%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' Make sure the length of theKey$ is two bytes by adding a chr$(0) if%@AE@%%@NL@%
%@AB@%    ' necessary.  If the length is >2, make it null.%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    SELECT CASE LEN(shortcutKey$)%@NL@%
        CASE 1%@NL@%
            shortcutKey$ = shortcutKey$ + CHR$(0)%@NL@%
        CASE 2%@NL@%
        CASE ELSE%@NL@%
            shortcutKey$ = ""%@NL@%
    END SELECT%@NL@%
%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@AB@%    ' First delete the shortcut key, just in case it already exists, and then%@AE@%%@NL@%
%@AB@%    ' and the shortcut key to the front of the shortcut key index string.%@AE@%%@NL@%
%@AB@%    '=======================================================================%@AE@%%@NL@%
%@NL@%
    ShortCutKeyDelete menu, item%@NL@%
    IF shortcutKey$ <> "" THEN%@NL@%
        newKey$ = MKI$(menu * 256 + item) + shortcutKey$%@NL@%
        GloMenu.shortcutKeyIndex = newKey$ + LEFT$(GloMenu.shortcutKeyIndex, 396)%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MOUSE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MOUSE.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'============================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'    MOUSE.BAS - Mouse Support Routines for the User Interface Toolbox in%@AE@%%@NL@%
%@AB@%'           Microsoft BASIC 7.0, Professional Development System%@AE@%%@NL@%
%@AB@%'              Copyright (C) 1987-1989, Microsoft Corporation%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' NOTE:     This sample source code toolbox is intended to demonstrate some%@AE@%%@NL@%
%@AB@%'           of the extended capabilities of Microsoft BASIC 7.0 Professional%@AE@%%@NL@%
%@AB@%'           Development system that can help to leverage the professional%@AE@%%@NL@%
%@AB@%'           developer's time more effectively.  While you are free to use,%@AE@%%@NL@%
%@AB@%'           modify, or distribute the routines in this module in any way you%@AE@%%@NL@%
%@AB@%'           find useful, it should be noted that these are examples only and%@AE@%%@NL@%
%@AB@%'           should not be relied upon as a fully-tested "add-on" library.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  PURPOSE: These routines are required for mouse support in the user%@AE@%%@NL@%
%@AB@%'           interface toolbox, but they may be used independently as well.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  For information on creating a library and QuickLib from the routines%@AE@%%@NL@%
%@AB@%'  contained in this file, read the comment header of GENERAL.BAS.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'============================================================================%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
%@AB@%'$INCLUDE: 'general.bi'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'mouse.bi'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'menu.bi'%@AE@%%@NL@%
%@NL@%
COMMON SHARED /uitools/ GloMenu      AS MenuMiscType%@NL@%
COMMON SHARED /uitools/ GloTitle()   AS MenuTitleType%@NL@%
COMMON SHARED /uitools/ GloItem()    AS MenuItemType%@NL@%
%@NL@%
SUB MouseBorder (row1, col1, row2, col2) STATIC%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Sets max and min bounds on mouse movement both vertically, and%@AE@%%@NL@%
%@AB@%    ' horizontally%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    MouseDriver 7, 0, (col1 - 1) * 8, (col2 - 1) * 8%@NL@%
    MouseDriver 8, 0, (row1 - 1) * 8, (row2 - 1) * 8%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB MouseDriver (m0, m1, m2, m3) STATIC%@NL@%
%@NL@%
    DIM regs AS RegType%@NL@%
%@NL@%
    IF MouseChecked = FALSE THEN%@NL@%
        DEF SEG = 0%@NL@%
%@NL@%
        MouseSegment& = 256& * PEEK(207) + PEEK(206)%@NL@%
        MouseOffset& = 256& * PEEK(205) + PEEK(204)%@NL@%
%@NL@%
        DEF SEG = MouseSegment&%@NL@%
%@NL@%
        IF (MouseSegment& = 0 AND MouseOffset& = 0) OR PEEK(MouseOffset&) = 207 THEN%@NL@%
            MousePresent = FALSE%@NL@%
            MouseChecked = TRUE%@NL@%
            DEF SEG%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
    IF MousePresent = FALSE AND MouseChecked = TRUE THEN%@NL@%
        EXIT SUB%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Calls interrupt 51 to invoke mouse functions in the MS Mouse Driver.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    regs.ax = m0%@NL@%
    regs.bx = m1%@NL@%
    regs.cx = m2%@NL@%
    regs.dx = m3%@NL@%
%@NL@%
    Interrupt 51, regs, regs%@NL@%
%@NL@%
    m0 = regs.ax%@NL@%
    m1 = regs.bx%@NL@%
    m2 = regs.cx%@NL@%
    m3 = regs.dx%@NL@%
%@NL@%
    IF MouseChecked THEN EXIT SUB%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Check for successful mouse initialization%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF m0 AND NOT MouseChecked THEN%@NL@%
        MousePresent = TRUE%@NL@%
    END IF%@NL@%
%@NL@%
    MouseChecked = TRUE%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB MouseHide%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Decrements internal cursor flag%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
   MouseDriver 2, 0, 0, 0%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB MouseInit%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Mouse driver's initialization routine%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    MouseDriver 0, 0, 0, 0%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB MousePoll (row, col, lButton, rButton) STATIC%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Polls mouse driver, then sets parms correctly%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    MouseDriver 3, button, col, row%@NL@%
    row = row / 8 + 1%@NL@%
    col = col / 8 + 1%@NL@%
%@NL@%
    IF button AND 1 THEN%@NL@%
        lButton = TRUE%@NL@%
    ELSE%@NL@%
        lButton = FALSE%@NL@%
    END IF%@NL@%
%@NL@%
    IF button AND 2 THEN%@NL@%
        rButton = TRUE%@NL@%
    ELSE%@NL@%
        rButton = FALSE%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB MouseShow%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Increments mouse's internal cursor flag%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    MouseDriver 1, 0, 0, 0%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MUSIC.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MUSIC.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' Turn on trapping of background music events:%@AE@%%@NL@%
PLAY ON%@NL@%
%@NL@%
%@AB@%' Branch to the Refresh subroutine when there are fewer than%@AE@%%@NL@%
%@AB@%' two notes in the background music buffer:%@AE@%%@NL@%
ON PLAY(2) GOSUB Refresh%@NL@%
%@NL@%
PRINT "Press any key to start, q to end."%@NL@%
Pause$ = INPUT$(1)%@NL@%
%@NL@%
%@AB@%' Select the background music option for PLAY:%@AE@%%@NL@%
PLAY "MB"%@NL@%
%@NL@%
%@AB@%' Start playing the music, so notes will be put in the%@AE@%%@NL@%
%@AB@%' background music buffer:%@AE@%%@NL@%
GOSUB Refresh%@NL@%
%@NL@%
I = 0%@NL@%
%@NL@%
DO%@NL@%
%@NL@%
%@AB@%        ' Print the numbers from 0 to 10,000 over and over until%@AE@%%@NL@%
%@AB@%        ' the user presses the "q" key. While this is happening,%@AE@%%@NL@%
%@AB@%        ' the music will repeat in the background:%@AE@%%@NL@%
        PRINT I%@NL@%
        I = (I + 1) MOD 10001%@NL@%
LOOP UNTIL INKEY$ = "q"%@NL@%
%@NL@%
END%@NL@%
%@NL@%
Refresh:%@NL@%
%@NL@%
%@AB@%        ' Plays the opening motive of%@AE@%%@NL@%
%@AB@%        ' Beethoven's Fifth Symphony:%@AE@%%@NL@%
        Listen$ = "t180 o2 p2 p8 L8 GGG L2 E-"%@NL@%
        Fate$   = "p24 p8 L8 FFF L2 D"%@NL@%
        PLAY Listen$ + Fate$%@NL@%
        RETURN%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MXADSTA.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MXADSTA.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%;***************************** ADDSTRING ********************************%@AE@%%@NL@%
%@AB@%; This procedure accepts two far strings, concatenates them, and%@AE@%%@NL@%
%@AB@%; returns the result in the form of a far string.%@AE@%%@NL@%
%@NL@%
        .model  medium,basic        %@AB@%;Define memory model to match BASIC.%@AE@%%@NL@%
        .stack%@NL@%
        .data?%@NL@%
        maxst = 50                  %@AB@%;Maximum bytes reserved for strings%@AE@%%@NL@%
inbuffer1       db  maxst dup(0)    %@AB@%;Room for first fixed-length string%@AE@%%@NL@%
inbuffer2       db  maxst dup(0)    %@AB@%;and second one%@AE@%%@NL@%
outbuffer       db  2*maxst dup(0)  %@AB@%;Work area for string processing%@AE@%%@NL@%
        .data%@NL@%
sh              dd  0               %@AB@%;Output string descriptor%@AE@%%@NL@%
        .code%@NL@%
addstring   proc    uses si di ds, s1:far ptr, s1len, s2:far ptr, s2len%@NL@%
%@NL@%
%@AB@%;First get BASIC to convert BASIC strings into standard form.%@AE@%%@NL@%
        les     ax,s1               %@AB@%;Push far pointer to%@AE@%%@NL@%
        push    es                  %@AB@%;input string descriptor.%@AE@%%@NL@%
        push    ax%@NL@%
        xor     ax,ax               %@AB@%;Push a zero to indicate%@AE@%%@NL@%
        push    ax                  %@AB@%;it is variable length.%@AE@%%@NL@%
        push    ds                  %@AB@%;Push far pointer to%@AE@%%@NL@%
        lea     ax, inbuffer1       %@AB@%;destination string.%@AE@%%@NL@%
        push    ax%@NL@%
        mov     ax,maxst            %@AB@%;Push length of destination%@AE@%%@NL@%
        push    ax                  %@AB@%;fixed-length string.%@AE@%%@NL@%
        extrn   stringassign:proc%@NL@%
        call    stringassign        %@AB@%;Call BASIC to assign variable-length%@AE@%%@NL@%
                                    %@AB@%;string to fixed-length string.%@AE@%%@NL@%
        les     ax,s2               %@AB@%;Push far pointer to second%@AE@%%@NL@%
        push    es                  %@AB@%;input string descriptor.%@AE@%%@NL@%
        push    ax%@NL@%
        xor     ax,ax               %@AB@%;Push a zero to indicate%@AE@%%@NL@%
        push    ax                  %@AB@%;it is variable length.%@AE@%%@NL@%
        push    ds                  %@AB@%;Push far pointer to%@AE@%%@NL@%
        lea     ax,inbuffer2        %@AB@%;second destination string.%@AE@%%@NL@%
        push    ax%@NL@%
        mov     ax,maxst            %@AB@%;Push length of destination%@AE@%%@NL@%
        push    ax                  %@AB@%;fixed-length string.%@AE@%%@NL@%
        extrn   stringassign:proc%@NL@%
        call    stringassign        %@AB@%;Call BASIC to assign variable-length%@AE@%%@NL@%
                                    %@AB@%;string to fixed-length string.%@AE@%%@NL@%
%@AB@%;Concatenate strings.%@AE@%%@NL@%
        lea     si,inbuffer1        %@AB@%;Copy first string to buffer.%@AE@%%@NL@%
        lea     di,outbuffer%@NL@%
        mov     ax,ds%@NL@%
        mov     es,ax%@NL@%
        mov     cx,s1len%@NL@%
        rep     movsb%@NL@%
        lea     si,inbuffer2        %@AB@%;Concatenate second string to%@AE@%%@NL@%
        mov     cx,s2len            %@AB@%;end of first.%@AE@%%@NL@%
        rep     movsb%@NL@%
%@NL@%
%@AB@%;Get BASIC to convert result back into a BASIC string.%@AE@%%@NL@%
        push    ds                  %@AB@%;Push far pointer to fixed-length%@AE@%%@NL@%
        lea     ax,outbuffer        %@AB@%;result string.%@AE@%%@NL@%
        push    ax%@NL@%
        mov     ax,s1len            %@AB@%;Compute total length of%@AE@%%@NL@%
        mov     bx,s2len            %@AB@%;fixed-length result string.%@AE@%%@NL@%
        add     ax,bx%@NL@%
        push    ax                  %@AB@%;Push length.%@AE@%%@NL@%
        push    ds                  %@AB@%;Push far pointer to sh (BASIC%@AE@%%@NL@%
        lea     ax,sh               %@AB@%;will use this in StringAssign).%@AE@%%@NL@%
        push    ax%@NL@%
        xor     ax,ax               %@AB@%;Push a zero for length%@AE@%%@NL@%
        push    ax                  %@AB@%;indicating variable-length.%@AE@%%@NL@%
        call    stringassign        %@AB@%;Call BASIC to assign the%@AE@%%@NL@%
                                    %@AB@%;result to sh.%@AE@%%@NL@%
        lea     ax,sh               %@AB@%;Return output string pointer%@AE@%%@NL@%
                                    %@AB@%;in ax and go back to BASIC.%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
addstring       endp%@NL@%
                end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MXADSTB.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MXADSTB.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
%@AB@%'Start program in BASIC for proper initialization.%@AE@%%@NL@%
%@AB@%' Define external and internal procedures.%@AE@%%@NL@%
DECLARE SUB shakespeare ()%@NL@%
DECLARE SUB StringAssign (BYVAL srcsegment, BYVAL srcoffset, BYVAL srclen, BYVAL destsegment, BYVAL destoffset, BYVAL destlen)%@NL@%
DECLARE SUB addstring (instrg1off, instrg1len, instrg2off, instrg2len, outstrgoff, outstrglen)%@NL@%
DECLARE SUB StringRelease (s$)%@NL@%
%@NL@%
%@AB@%'Go to main routine in second language%@AE@%%@NL@%
CALL shakespeare%@NL@%
%@NL@%
%@AB@%'The non-BASIC program calls this SUB to add the two strings together%@AE@%%@NL@%
SUB addstring (instrg1off, instrg1len, instrg2off, instrg2len, outstrgoff, outstrglen)%@NL@%
%@NL@%
%@AB@%'Create variable-length strings and transfer non-BASIC fixed strings to them.%@AE@%%@NL@%
%@AB@%'Use VARSEG() to compute the segement of the strings returned from the other%@AE@%%@NL@%
%@AB@%'language--this is the DGROUP segment, and all string descriptors are found%@AE@%%@NL@%
%@AB@%'in this segment (even though the far string itself is elsewhere).%@AE@%%@NL@%
%@NL@%
CALL StringAssign(VARSEG(a$), instrg1off, instrg1len, VARSEG(a$), VARPTR(a$), 0)%@NL@%
CALL StringAssign(VARSEG(b$), instrg2off, instrg2len, VARSEG(b$), VARPTR(b$), 0)%@NL@%
%@NL@%
%@AB@%' Process the strings--in this case, add them.%@AE@%%@NL@%
c$ = a$ + b$%@NL@%
%@NL@%
%@AB@%' Calculate the new output length.%@AE@%%@NL@%
outstrglen = LEN(c$)%@NL@%
%@NL@%
%@AB@%' Transfer string output to a non-BASIC fixed-length string.%@AE@%%@NL@%
CALL StringAssign(VARSEG(c$), VARPTR(c$), 0, VARSEG(c$), outstrgoff, outstrglen)%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MXADSTC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MXADSTC.C%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AB@%/* Function Prototypes force either correct data typing or compiler warnings.%@NL@%
%@AB@% * Note all functions exported to BASIC and all BASIC callback (extern)%@NL@%
%@AB@% * functions are declared with the far pascal calling convention.%@NL@%
%@AB@% * WARNING: This must be compiled with the Medium memory model (/AM)%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
char * pascal addstring( char far *s1, int s1len,%@NL@%
              char far *s2, int s2len );%@NL@%
extern void far pascal StringAssign( char far *source, int slen,%@NL@%
                       char far *dest, int dlen );%@NL@%
%@NL@%
%@AB@%/* Declare global char array to contain new BASIC string descriptor.%@NL@%
%@AB@% */%@AE@%%@NL@%
char BASICDesc[4];%@NL@%
%@NL@%
char * pascal addstring( char far *s1, int s1len,%@NL@%
              char far *s2, int s2len )%@NL@%
{%@NL@%
    char TS1[50];%@NL@%
    char TS2[50];%@NL@%
    char TSBig[100];%@NL@%
%@NL@%
    %@AB@%/* Use the BASIC callback StringAssign to retrieve information%@NL@%
%@AB@%     * from the descriptors, s1 and s2, and place them in the temporary%@NL@%
%@AB@%     * arrays TS1 and TS2.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    StringAssign( s1, 0, TS1, 49 );        %@AB@%/* Get S1 as array of char */%@AE@%%@NL@%
    StringAssign( s2, 0, TS2, 49 );        %@AB@%/* Get S2 as array of char */%@AE@%%@NL@%
%@NL@%
    %@AB@%/* Copy the data from TS1 into TSBig, then append the data from%@NL@%
%@AB@%     * TS2.%@NL@%
%@AB@%     */%@AE@%%@NL@%
    memcpy( TSBig, TS1, s1len );%@NL@%
    memcpy( &TSBig[s1len], TS2, s2len );%@NL@%
%@NL@%
    StringAssign( TSBig, s1len + s2len, BASICDesc, 0 );%@NL@%
%@NL@%
    return BASICDesc;%@NL@%
}%@NL@%
%@NL@%
%@AB@%/*%@NL@%
%@AB@% * If, for example, we wanted to return not just one variable length string,%@NL@%
%@AB@% * but rather the variable length string and the reverse of that:%@NL@%
%@AB@% *%@NL@%
%@AB@% * call addstring( "foo ", 4, "bar", 3, a$, r$ )%@NL@%
%@AB@% *%@NL@%
%@AB@% * you get "foo bar" in a$ and "rab oof" in r$.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Say you give me s1, and s2 (and their respective lengths) on input; for%@NL@%
%@AB@% * output, I want s3 and s4.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Change the StringAssign for TSBig to assign to s3 instead of BASICDesc.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Add the following lines of code:%@NL@%
%@AB@% *%@NL@%
%@AB@% *     TSBig[s1len + s2len] = '\0';%@NL@%
%@AB@% *     strrev( TSBig );%@NL@%
%@AB@% *     StringAssign( TSBig, s1len + s2len, s4, 0 );%@NL@%
%@AB@% *%@NL@%
%@AB@% * Delete the return statement.%@NL@%
%@AB@% *%@NL@%
%@AB@% * Change the prototype and function header to say:%@NL@%
%@AB@% *%@NL@%
%@AB@% * void far pascal addstring%@NL@%
%@AB@% *%@NL@%
%@AB@% * instead of%@NL@%
%@AB@% *%@NL@%
%@AB@% * char far * pascal addstring%@NL@%
%@AB@% */%@AE@%%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MXADSTF.FOR%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MXADSTF.FOR%@AE@%%@NL@%
%@NL@%
%@AB@%C ******************** ADDSTRING  *********************%@AE@%%@NL@%
%@AB@%C This program is in file MXADSTF.FOR%@AE@%%@NL@%
%@AB@%C Declare interface to Stringassign subprogram. The pointer fields are%@AE@%%@NL@%
%@AB@%C declared INTEGER*4, so that different types of far pointers can be%@AE@%%@NL@%
%@AB@%C passed without conflict. The INTEGER*4 fields are essentially generic%@AE@%%@NL@%
%@AB@%C pointers. [VALUE] must be specified, or FORTRAN will pass pointers to%@AE@%%@NL@%
%@AB@%C pointers. INTEGER*2 also passed by [VALUE], to be consistent with%@AE@%%@NL@%
%@AB@%C declaration of Stringassign.%@AE@%%@NL@%
%@AB@%C%@AE@%%@NL@%
       INTERFACE TO SUBROUTINE STRASG [ALIAS:'STRINGASSIGN'] (S,SL,D,DL)%@NL@%
       INTEGER*4 S [VALUE]%@NL@%
       INTEGER*2 SL [VALUE]%@NL@%
       INTEGER*4 D [VALUE]%@NL@%
       INTEGER*2 DL [VALUE]%@NL@%
       END%@NL@%
%@AB@%C%@AE@%%@NL@%
%@AB@%C Declare heading of Addstring function in the same way as above: the%@AE@%%@NL@%
%@AB@%C pointer fields are INTEGER*4%@AE@%%@NL@%
%@AB@%C%@AE@%%@NL@%
       INTEGER*2 FUNCTION ADDSTR [ALIAS:'ADDSTRING'] (S1,S1LEN,S2,S2LEN)%@NL@%
       INTEGER*4 S1 [VALUE]%@NL@%
       INTEGER*2 S1LEN [VALUE]%@NL@%
       INTEGER*4 S2 [VALUE]%@NL@%
       INTEGER*2 S2LEN [VALUE]%@NL@%
%@AB@%C%@AE@%%@NL@%
%@AB@%C Local parameters TS1, TS2, and BIGSTR are temporary strings. STRDES is%@AE@%%@NL@%
%@AB@%C a four-byte object into which Stringassign will put BASIC string%@AE@%%@NL@%
%@AB@%C descriptor.%@AE@%%@NL@%
%@AB@%C%@AE@%%@NL@%
%@AB@%       CHARACTER*50 TS1, TS2%@AE@%%@NL@%
%@AB@%       CHARACTER*100 BIGSTR%@AE@%%@NL@%
       INTEGER*4 STRDES%@NL@%
%@NL@%
        TS1 = " "%@NL@%
        TS2 = " "%@NL@%
        STRDES = 0%@NL@%
%@NL@%
%@AB@%C%@AE@%%@NL@%
%@AB@%C Use the LOCFAR function to take the far address of data. LOCFAR returns%@AE@%%@NL@%
%@AB@%C a value of type INTEGER*4.%@AE@%%@NL@%
%@AB@%C%@AE@%%@NL@%
%@AB@%       CALL STRASG (S1, 0, LOCFAR(TS1), S1LEN)%@AE@%%@NL@%
%@AB@%       CALL STRASG (S2, 0, LOCFAR(TS2), S2LEN)%@AE@%%@NL@%
       BIGSTR = TS1(1:S1LEN) // TS2(1:S2LEN)%@NL@%
%@AB@%       CALL STRASG (LOCFAR(BIGSTR), S1LEN+S2LEN, LOCFAR(STRDES), 0)%@AE@%%@NL@%
       ADDSTR = LOC(STRDES)%@NL@%
       RETURN%@NL@%
       END%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MXSHKA.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MXSHKA.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%;*************************** SHAKESPEARE ******************************%@AE@%%@NL@%
%@AB@%; This program creates two strings and passes them to a BASIC procedure%@AE@%%@NL@%
%@AB@%; called addstring (in file MXADSTB.BAS).  This procedure concatenates%@AE@%%@NL@%
%@AB@%; the strings and passes the result to MASM which prints it.%@AE@%%@NL@%
%@NL@%
        .model  medium,basic        %@AB@%;Use same memory model as BASIC.%@AE@%%@NL@%
        .stack%@NL@%
        .data                       %@AB@%;Create the data.%@AE@%%@NL@%
phrase1         db      "To be or not to be%@AB@%;"%@AE@%%@NL@%
phrase1len      dw      $-phrase1%@NL@%
phrase1off      dw      phrase1%@NL@%
phrase2         db      " that is the question."%@NL@%
phrase2len      dw      $-phrase2%@NL@%
phrase2off      dw      phrase2%@NL@%
sentence        db      100 dup(0)  %@AB@%;Make room for return data%@AE@%%@NL@%
sentencelen     dw      0           %@AB@%;and a length indicator.%@AE@%%@NL@%
sentenceoff     dw      sentence%@NL@%
%@NL@%
        .code%@NL@%
shakespeare proc    uses si%@NL@%
%@NL@%
%@AB@%;First call BASIC to concatenate strings.%@AE@%%@NL@%
        lea     ax,phrase1off       %@AB@%;Push far address of%@AE@%%@NL@%
        push    ax                  %@AB@%;fixed-length string #1,%@AE@%%@NL@%
        lea     ax,phrase1len       %@AB@%;and its length.%@AE@%%@NL@%
        push    ax%@NL@%
        lea     ax,phrase2off       %@AB@%;Do the same for the%@AE@%%@NL@%
        push    ax                  %@AB@%;address of string #2,%@AE@%%@NL@%
        lea     ax,phrase2len       %@AB@%;and its length.%@AE@%%@NL@%
        push    ax%@NL@%
        lea     ax,sentenceoff      %@AB@%;Push far address of%@AE@%%@NL@%
        push    ax                  %@AB@%;the return string,%@AE@%%@NL@%
        lea     ax,sentencelen      %@AB@%;and its length.%@AE@%%@NL@%
        push    ax%@NL@%
        extrn   addstring:proc      %@AB@%;Call BASIC function to%@AE@%%@NL@%
        call    addstring           %@AB@%;concatenate the strings and%@AE@%%@NL@%
                                    %@AB@%;put the result in the%@AE@%%@NL@%
                                    %@AB@%;fixed-length return string.%@AE@%%@NL@%
%@NL@%
%@AB@%;Call DOS to print string. The DOS string output routine (09H)%@AE@%%@NL@%
%@AB@%;requires that strings end with a "$" character.%@AE@%%@NL@%
        mov     bx,sentencelen      %@AB@%;Go to end of the result string%@AE@%%@NL@%
        lea     si,sentence         %@AB@%;and add a "$" (24h) character.%@AE@%%@NL@%
        mov     byte ptr [bx + si],24h%@NL@%
%@NL@%
        lea     dx,sentence         %@AB@%;Set up registers%@AE@%%@NL@%
        mov     ah,9                %@AB@%;and call DOS to%@AE@%%@NL@%
        int     21h                 %@AB@%;print result string.%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
shakespeare endp%@NL@%
%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MXSHKB.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MXSHKB.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@AB@%'Define non-basic procedures%@AE@%%@NL@%
DECLARE FUNCTION addstring$(SEG s1$, BYVAL s1length, SEG s2$, BYVAL s2length)%@NL@%
%@NL@%
%@NL@%
%@AB@%'Create the data%@AE@%%@NL@%
a$ = "To be or not to be;"%@NL@%
b$ = " that is the question."%@NL@%
%@NL@%
%@AB@%'Use non-BASIC function to add two BASIC far strings%@AE@%%@NL@%
c$ = addstring(a$, LEN(a$), b$, LEN(b$))%@NL@%
%@NL@%
%@AB@%'print the result on the screen%@AE@%%@NL@%
%@NL@%
PRINT c$%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MXSHKC.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MXSHKC.C%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<stdio.h> %@NL@%
%@AI@%#include %@AE@%<string.h> %@NL@%
%@NL@%
%@AB@%/* Function Prototypes force either correct data typing or compiler warnings.%@NL@%
%@AB@% * Note all functions exported to BASIC and all BASIC callback (extern)%@NL@%
%@AB@% * functions are declared with the far pascal calling convention.%@NL@%
%@AB@% * IMPORTANT: This must be compiled with the Medium memory model (/AM)%@NL@%
%@AB@% */%@AE@%%@NL@%
void far pascal shakespeare( void );%@NL@%
extern void far pascal addstring( char  ** s1, int * s1len,%@NL@%
                                    char ** s2, int * s2len,%@NL@%
                                    char ** s3, int * s3len );%@NL@%
%@NL@%
void far pascal shakespeare( void )%@NL@%
{%@NL@%
    char * s1 = "To be or not to be;";%@NL@%
    int  s1len;%@NL@%
    char * s2 = " that is the question.";%@NL@%
    int  s2len;%@NL@%
    char s3[100];%@NL@%
    int  s3len;%@NL@%
    char * s3add = s3;%@NL@%
%@NL@%
    s1len = strlen( s1 );%@NL@%
    s2len = strlen( s2 );%@NL@%
    addstring( &s1, &s1len, &s2, &s2len, &s3add, &s3len );%@NL@%
%@NL@%
    s3[s3len] = '\0';%@NL@%
    printf("\n%s", s3 );%@NL@%
}%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MXSHKF.FOR%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\MXSHKF.FOR%@AE@%%@NL@%
%@NL@%
%@AB@%C *********************** SHAKESPEARE ****************%@AE@%%@NL@%
%@AB@%C This program is in file MXSHKF.FOR%@AE@%%@NL@%
%@AB@%C Declare interface to BASIC routine ADDSTRING.%@AE@%%@NL@%
%@AB@%C All parameters must be passed NEAR, for compatibility with BASIC's%@AE@%%@NL@%
%@AB@%C conventions.%@AE@%%@NL@%
%@AB@%C%@AE@%%@NL@%
%@NL@%
%@NL@%
       INTERFACE TO SUBROUTINE ADDSTR[ALIAS:'ADDSTRING']%@NL@%
     * (S1,L1,S2,L2,S3,L3)%@NL@%
       INTEGER*2 S1 [NEAR]%@NL@%
       INTEGER*2 L1 [NEAR]%@NL@%
       INTEGER*2 S2 [NEAR]%@NL@%
       INTEGER*2 L2 [NEAR]%@NL@%
       INTEGER*2 S3 [NEAR]%@NL@%
       INTEGER*2 L3 [NEAR]%@NL@%
       END%@NL@%
%@AB@%C%@AE@%%@NL@%
%@AB@%C Declare subroutine SHAKESPEARE, which declares two strings, calls BASIC%@AE@%%@NL@%
%@AB@%C subroutine ADDSTRING, and prints the result.%@AE@%%@NL@%
%@AB@%C%@AE@%%@NL@%
       SUBROUTINE SHAKES [ALIAS:'SHAKESPEARE']%@NL@%
%@AB@%       CHARACTER*50 STR1, STR2%@AE@%%@NL@%
%@AB@%       CHARACTER*100 STR3%@AE@%%@NL@%
       INTEGER*2 STRLEN1, STRLEN2, STRLEN3%@NL@%
       INTEGER*2 TMP1, TMP2, TMP3%@NL@%
%@AB@%C%@AE@%%@NL@%
%@AB@%C The subroutine uses FORTRAN LEN_TRIM function, which returns the length%@AE@%%@NL@%
%@AB@%C of string, excluding trailing blanks. (All FORTRAN strings are initialized%@AE@%%@NL@%
%@AB@%C to blanks.)%@AE@%%@NL@%
%@AB@%C%@AE@%%@NL@%
       STR1 = 'To be or not to be;'%@NL@%
       STRLEN1 = LEN_TRIM(STR1)%@NL@%
       STR2 = ' that is the question.'%@NL@%
       STRLEN2 = LEN_TRIM(STR2)%@NL@%
       TMP1 = LOC(STR1)%@NL@%
       TMP2 = LOC(STR2)%@NL@%
       TMP3 = LOC(STR3)%@NL@%
%@AB@%       CALL ADDSTR (TMP1, STRLEN1, TMP2, STRLEN2, TMP3, STRLEN3)%@AE@%%@NL@%
       WRITE (*,*) STR3%@NL@%
       END%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PALETTE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\PALETTE.BAS%@AE@%%@NL@%
%@NL@%
DECLARE SUB InitPalette ()%@NL@%
DECLARE        SUB ChangePalette ()%@NL@%
DECLARE        SUB DrawEllipses ()%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
DIM SHARED PaletteArray(15)%@NL@%
%@NL@%
SCREEN 8                 ' 640 x 200 resolution; 16 colors%@NL@%
%@NL@%
InitPalette                 ' Initialize PaletteArray.%@NL@%
DrawEllipses                 ' Draw and paint concentric ellipses.%@NL@%
%@NL@%
DO                         ' Shift the palette until a key%@NL@%
   ChangePalette         ' is pressed.%@NL@%
LOOP WHILE INKEY$ = ""%@NL@%
%@NL@%
END%@NL@%
%@NL@%
%@NL@%
%@AB@%' ====================== InitPalette ======================%@AE@%%@NL@%
%@AB@%'    This procedure initializes the integer array used to%@AE@%%@NL@%
%@AB@%'    change the palette.%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
SUB InitPalette        STATIC%@NL@%
   FOR I = 0 TO        15%@NL@%
      PaletteArray(I) =        I%@NL@%
   NEXT        I%@NL@%
END SUB%@NL@%
%@AB@%' ===================== DrawEllipses ======================%@AE@%%@NL@%
%@AB@%'    This procedure draws 15 concentric ellipses and%@AE@%%@NL@%
%@AB@%'    paints the interior of each with a different color.%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
SUB DrawEllipses STATIC%@NL@%
   CONST ASPECT        = 1 / 3%@NL@%
   FOR ColorVal        = 15 TO        1 STEP -1%@NL@%
      Radius = 20 * ColorVal%@NL@%
      CIRCLE (320, 100), Radius, ColorVal, , , ASPECT%@NL@%
      PAINT (320, 100),        ColorVal%@NL@%
   NEXT%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@AB@%' ===================== ChangePalette =====================%@AE@%%@NL@%
%@AB@%'  This procedure rotates the palette by one each time it%@AE@%%@NL@%
%@AB@%'  is called. For example, after the first call to%@AE@%%@NL@%
%@AB@%'  ChangePalette, PaletteArray(1) = 2, PaletteArray(2) = 3,%@AE@%%@NL@%
%@AB@%'  . . . , PaletteArray(14) = 15, and PaletteArray(15) = 1%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
SUB ChangePalette STATIC%@NL@%
   FOR I = 1 TO        15%@NL@%
      PaletteArray(I) =        (PaletteArray(I) MOD 15) + 1%@NL@%
   NEXT        I%@NL@%
   PALETTE USING PaletteArray(0) ' Shift the color displayed%@NL@%
%@AB@%                                 ' by each of the attributes.%@AE@%%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PASSWRD.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\PASSWRD.BAS%@AE@%%@NL@%
%@NL@%
DECLARE FUNCTION CertifiedOperator% ()%@NL@%
CONST FALSE = 0, True = NOT FALSE%@NL@%
%@NL@%
IF CertifiedOperator = FALSE THEN%@NL@%
        PRINT "Connection Refused."%@NL@%
        END%@NL@%
END IF%@NL@%
%@NL@%
PRINT "Connected to Network."%@NL@%
%@AB@%'Main program continues here.%@AE@%%@NL@%
%@AB@%'  .%@AE@%%@NL@%
%@AB@%'  .%@AE@%%@NL@%
%@AB@%'  .%@AE@%%@NL@%
END%@NL@%
%@NL@%
FUNCTION CertifiedOperator%%@NL@%
ON LOCAL ERROR GOTO Handler%@NL@%
%@AB@%'Count the number of times the operator tries to sign on.%@AE@%%@NL@%
Attempts% = 0%@NL@%
%@NL@%
TryAgain:%@NL@%
%@AB@%'Assume the operator has valid credentials.%@AE@%%@NL@%
CertifiedOperator = True%@NL@%
%@AB@%'Keep track of bad entries.%@AE@%%@NL@%
Attempts% = Attempts% + 1%@NL@%
IF Attempts% > 3 THEN ERROR 255%@NL@%
%@AB@%'Check out the operator's credentials.%@AE@%%@NL@%
INPUT "Enter Account Number"; Account$%@NL@%
IF LEFT$(Account$, 4) <> "1234" THEN ERROR 200%@NL@%
INPUT "Enter Password"; Password$%@NL@%
IF Password$ <> "Swordfish" THEN ERROR 201%@NL@%
EXIT FUNCTION%@NL@%
%@NL@%
Handler:%@NL@%
SELECT CASE ERR%@NL@%
%@AB@%    'Start over if account number doesn't have "1234" in it.%@AE@%%@NL@%
        CASE 200%@NL@%
                PRINT "Illegal account number. Please re-enter."%@NL@%
                RESUME TryAgain%@NL@%
%@AB@%    'Start over if the password is wrong.%@AE@%%@NL@%
        CASE 201%@NL@%
                PRINT "Wrong password. Please re-enter both items."%@NL@%
                RESUME TryAgain%@NL@%
%@AB@%    'Return false if operator makes too many mistakes.%@AE@%%@NL@%
        CASE 255%@NL@%
                CertifiedOperator% = FALSE%@NL@%
                EXIT FUNCTION%@NL@%
END SELECT%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PGBAR.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\PGBAR.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' PGBAR.BAS:  Create sample bar chart%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@AB@%' $INCLUDE: 'CHRTB.BI'%@AE@%%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE, MONTHS = 12%@NL@%
CONST HIGHESTMODE = 13, TEXTONLY = 0%@NL@%
%@NL@%
DIM Env AS ChartEnvironment                 ' See CHRTB.BI for declaration of                     ' the ChartEnvironment type%@NL@%
DIM MonthCategories(1 TO MONTHS) AS STRING  ' Array for categories (used for%@NL@%
%@AB@%                                                                                                                                                                                ' Pie, Column and Bar Charts)%@AE@%%@NL@%
DIM OJvalues(1 TO MONTHS) AS SINGLE         ' Array for 1st data series%@NL@%
%@NL@%
DECLARE FUNCTION BestMode ()%@NL@%
%@NL@%
%@AB@%' Initialize the data arrays%@AE@%%@NL@%
FOR index = 1 TO MONTHS: READ OJvalues(index): NEXT index%@NL@%
FOR index = 1 TO MONTHS: READ MonthCategories$(index): NEXT index%@NL@%
%@NL@%
%@AB@%' Pass the value returned by the BestMode function to the Presentation%@AE@%%@NL@%
%@AB@%' Graphics routine ChartScreen to set the graphics mode for charting%@AE@%%@NL@%
%@NL@%
ChartScreen (BestMode)      ' Even if SCREEN is already set to an acceptable%@NL@%
%@AB@%                                                                                                                ' mode, you still have to set it with ChartScreen%@AE@%%@NL@%
IF ChartErr = cBadScreen THEN   ' Check to make sure ChartScreen succeeded%@NL@%
        PRINT "Sorry --- There is a screen-mode problem in the Charting library"%@NL@%
        END%@NL@%
END IF%@NL@%
%@AB@%' Initialize a default pie chart%@AE@%%@NL@%
%@AB@%                                                                                                                                                ' Pass Env (the environment variable),%@AE@%%@NL@%
DefaultChart Env, cBar, cPlain      ' the constant cBar (for Bar Chart) and%@NL@%
%@AB@%                                                                                                                                                ' cPlain%@AE@%%@NL@%
%@NL@%
%@AB@%' Add Titles and some chart options. These assignments modify some default%@AE@%%@NL@%
%@AB@%' values set in the variable Env (of type ChartEnvironment) by DefaultChart%@AE@%%@NL@%
%@NL@%
Env.MainTitle.Title = "Good Neighbor Grocery" ' Specifies text of chart title%@NL@%
Env.MainTitle.TitleColor = 15                 ' Specifies color of title text%@NL@%
Env.MainTitle.Justify = cRight                ' How to align of title text%@NL@%
Env.SubTitle.Title = "Orange Juice Sales"     ' Text of chart subtitle%@NL@%
Env.SubTitle.TitleColor = 15                  ' Color of subtitle text%@NL@%
Env.SubTitle.Justify = cRight                 ' How to align of subtitle text%@NL@%
Env.ChartWindow.Border = cNo                  ' Specifies chart has no border%@NL@%
%@NL@%
%@AB@%' The next 2 assignments label the x-axis and y-axis%@AE@%%@NL@%
Env.XAxis.AxisTitle.Title = "Quantity (cases)"%@NL@%
Env.YAxis.AxisTitle.Title = "Months"%@NL@%
%@NL@%
%@AB@%' Call the bar-charting routine --- Arguments for call to Chart are:%@AE@%%@NL@%
%@AB@%' Env                 - Environment variable%@AE@%%@NL@%
%@AB@%' MonthCategories()   - Array containing Category labels%@AE@%%@NL@%
%@AB@%' OJvalues()          - Array containing Data values to chart%@AE@%%@NL@%
%@AB@%' MONTHS              - Tells number of data values to chart%@AE@%%@NL@%
%@NL@%
        Chart Env, MonthCategories(), OJvalues(), MONTHS%@NL@%
        SLEEP%@NL@%
%@AB@%        '  If the rest of your program isn't graphic, reset original mode here%@AE@%%@NL@%
END%@NL@%
%@NL@%
%@AB@%' Simulate data generation for chart values and category labels%@AE@%%@NL@%
DATA 33,27,42,64,106,157,182,217,128,62,43,36%@NL@%
DATA "Jan","Feb","Mar","Apr","May","Jun","Jly","Aug","Sep","Oct","Nov","Dec",%@NL@%
%@NL@%
%@AB@%'============= Function to determine and set highest resolution ========%@AE@%%@NL@%
%@AB@%' The BestMode function uses a local error trap to check available modes,%@AE@%%@NL@%
%@AB@%' then assigns the integer representing the best mode for charting to its%@AE@%%@NL@%
%@AB@%' name so it is returned to the caller. The function terminate execution if%@AE@%%@NL@%
%@AB@%' the hardware doesn't support a mode appropriate for Presentation Graphics%@AE@%%@NL@%
%@AB@%'========================================================================%@AE@%%@NL@%
FUNCTION BestMode%@NL@%
%@NL@%
%@AB@%' Set a trap for an expected local error --- handled within the function%@AE@%%@NL@%
ON LOCAL ERROR GOTO ScreenError%@NL@%
%@NL@%
FOR TestValue = HIGHESTMODE TO 0 STEP -1%@NL@%
        DisplayError = FALSE%@NL@%
        SCREEN TestValue%@NL@%
        IF DisplayError = FALSE THEN%@NL@%
                SELECT CASE TestValue%@NL@%
                        CASE 12, 13%@NL@%
                                BestMode = 12%@NL@%
                        CASE 9, 10, 11%@NL@%
                                BestMode = 9%@NL@%
                        CASE 8, 4, 3%@NL@%
                                BestMode = TestValue%@NL@%
                        CASE 2, 7%@NL@%
                                BestMode = 2%@NL@%
                        CASE 1%@NL@%
                                BestMode = 1%@NL@%
                        CASE ELSE%@NL@%
                                PRINT "Sorry, you need graphics to display charts"%@NL@%
                                END%@NL@%
                END SELECT%@NL@%
                EXIT FUNCTION%@NL@%
        END IF%@NL@%
NEXT TestValue%@NL@%
%@AB@%' Note there is no need to turn off the local error handler. It is turned off%@AE@%%@NL@%
%@AB@%' automatically when control passes out of the function%@AE@%%@NL@%
%@NL@%
EXIT FUNCTION%@NL@%
%@AB@%'==================== | Local error handler code |=======================%@AE@%%@NL@%
%@AB@%' The ScreenError label identifies a local error handler relied in the%@AE@%%@NL@%
%@AB@%' BestMode function. Invalid SCREEN values generate Error # 5 (Illegal%@AE@%%@NL@%
%@AB@%' function call) --- so if that is not the error reset ERROR to the ERR%@AE@%%@NL@%
%@AB@%' value that was generated so the error can be passed to other, possibly%@AE@%%@NL@%
%@AB@%' more appropriate errors.%@AE@%%@NL@%
ScreenError:%@NL@%
        IF ERR = 5 THEN%@NL@%
                DisplayError = TRUE%@NL@%
                RESUME NEXT%@NL@%
        ELSE%@NL@%
                ERROR ERR%@NL@%
        END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PGLINEMS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\PGLINEMS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' PGLINEMS.BAS - Program to generate a simple multi-data series line chart%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@AB@%'$INCLUDE: 'CHRTB.BI'                 ' Declarations and Definitions%@AE@%%@NL@%
DIM Env AS ChartEnvironment           ' Variable to hold environment structure%@NL@%
DIM AxisLabels(1 TO 4) AS STRING      ' Array of categories%@NL@%
DIM LegendLabels(1 TO 2) AS STRING    ' Array of series labels%@NL@%
DIM Values(1 TO 4, 1 TO 3) AS SINGLE  ' 2-dimentsion array of values to plot%@NL@%
%@NL@%
DIM Col%(0 TO cPalLen)          ' Define arrays to hold values retrieved with%@NL@%
DIM Lines%(0 TO cPalLen)        ' call to GetPaletteDef. By modifying these%@NL@%
DIM Fill$(0 TO cPalLen)         ' values, then calling ResetPaletteDef, you%@NL@%
DIM Char%(0 TO cPalLen)         ' can change colors, plot characters, borders,%@NL@%
DIM Bord%(0 TO cPalLen)         ' and even the line styles and fill patterns%@NL@%
%@NL@%
%@AB@%' Read the data to display into the arrays%@AE@%%@NL@%
%@NL@%
FOR index = 1 TO 2: READ LegendLabels(index): NEXT index%@NL@%
FOR index = 1 TO 4: READ AxisLabels(index): NEXT index%@NL@%
%@NL@%
FOR columnindex = 1 TO 2                ' The array has 2 columns, each of%@NL@%
  FOR rowindex = 1 TO 4                 ' which has 4 rows. Each column rep-%@NL@%
    READ Values(rowindex, columnindex)  ' resents 1 full data series. First,%@NL@%
  NEXT rowindex                         ' fill column 1, then fill column 2%@NL@%
NEXT columnindex                        ' with values from the last DATA%@NL@%
%@AB@%                                        ' statement (below).%@AE@%%@NL@%
CLS%@NL@%
%@NL@%
ChartScreen 2                           ' Set a common graphics mode%@NL@%
%@NL@%
%@AB@%' Retrieve current palette settings, then assign some new values%@AE@%%@NL@%
%@NL@%
GetPaletteDef Col%(), Lines%(), Fill$(), Char%(), Bord%()%@NL@%
%@NL@%
 Col%(2) = (15)          '  Assign white as color for second-series plot line%@NL@%
 Char%(1) = (4)          '  Assign  "" as plot character for 1st plot line%@NL@%
 Char%(2) = (18)         '  Assign  "" as plot character for 2nd plot line%@NL@%
%@NL@%
%@AB@%' Reset the palettes with modified arrays%@AE@%%@NL@%
%@NL@%
SetPaletteDef Col%(), Lines%(), Fill$(), Char%(), Bord%()   ' Enter the changes%@NL@%
%@NL@%
DefaultChart Env, cLine, cLines         ' Set up multi-series line chart%@NL@%
%@NL@%
%@AB@%' Display the chart%@AE@%%@NL@%
%@NL@%
ChartMS Env, AxisLabels(), Values(), 4, 1, 2, LegendLabels()%@NL@%
%@NL@%
SLEEP                                   ' Keep it onscreen until user presses%@NL@%
%@AB@%                                        ' a key%@AE@%%@NL@%
END%@NL@%
%@NL@%
%@AB@%' Simulated data to be shown on chart%@AE@%%@NL@%
DATA "Qtr 1","Qtr 2"%@NL@%
DATA "Admn","Markg","Prodn","Devel"%@NL@%
DATA 38,30,40,32,18,40,20,12%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PGPIE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\PGPIE.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' PGPIE.BAS:  Create sample pie chart%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@AB@%' $INCLUDE: 'fontb.BI'%@AE@%%@NL@%
%@AB@%' $INCLUDE: 'CHRTB.BI'%@AE@%%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE, MONTHS = 12%@NL@%
CONST HIGHESTMODE = 13, TEXTONLY = 0%@NL@%
%@NL@%
DIM Env AS ChartEnvironment                 ' See CHRTB.BI for declaration of                     ' the ChartEnvironment type%@NL@%
DIM MonthCategories(1 TO MONTHS) AS STRING  ' Array for categories%@NL@%
DIM OJvalues(1 TO MONTHS) AS SINGLE         ' Array for 1st data series%@NL@%
DIM Exploded(1 TO MONTHS) AS INTEGER        ' "Explode" flags array (specifies%@NL@%
%@AB@%                                                                                                                                                                                '  which pie slices are separated)%@AE@%%@NL@%
DECLARE FUNCTION BestMode ()%@NL@%
%@NL@%
%@AB@%' Initialize the data arrays%@AE@%%@NL@%
FOR index = 1 TO MONTHS: READ OJvalues(index): NEXT index%@NL@%
FOR index = 1 TO MONTHS: READ MonthCategories$(index): NEXT index%@NL@%
%@NL@%
%@AB@%' Set the elements of the array that determines separation of the pie slices%@AE@%%@NL@%
FOR Flags = 1 TO MONTHS                       ' If value of OJvalues(Flags)%@NL@%
        Exploded(Flags) = (OJvalues(Flags) >= 100)  ' >= 100 the corresponding flag%@NL@%
NEXT Flags                                    ' is set true, separating slices%@NL@%
%@NL@%
%@AB@%' Pass the value returned by the BestMode function to the Presentation%@AE@%%@NL@%
%@AB@%' Graphics routine ChartScreen to set the graphics mode for charting%@AE@%%@NL@%
%@NL@%
ChartScreen (BestMode)      ' Even if SCREEN is already set to an acceptable%@NL@%
%@AB@%                                                                                                                ' mode, you still have to set it with ChartScreen%@AE@%%@NL@%
%@NL@%
IF ChartErr = cBadScreen THEN   ' Check to make sure ChartScreen succeeded%@NL@%
        PRINT "Sorry --- There is a screen-mode problem in the Charting library"%@NL@%
        END%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Initialize a default pie chart%@AE@%%@NL@%
%@AB@%                                                                                                                                                ' Pass Env (the environment variable),%@AE@%%@NL@%
DefaultChart Env, cPie, cPercent    ' the constant cPie (for Pie Chart) and%@NL@%
%@AB@%                                                                                                                                                ' cPercent (label slices with percentage)%@AE@%%@NL@%
%@NL@%
%@AB@%' Add Titles and some chart options. These assignments modify some default%@AE@%%@NL@%
%@AB@%' values set in the variable Env (of type ChartEnvironment) by DefaultChart%@AE@%%@NL@%
%@NL@%
%@NL@%
Env.MainTitle.Title = "Good Neighbor Grocery" ' Specifies text of chart title%@NL@%
Env.MainTitle.TitleColor = 15                 ' Specifies color of title text%@NL@%
Env.MainTitle.Justify = cCenter               ' How to align of title text%@NL@%
Env.SubTitle.Title = "Orange Juice Sales"     ' Text of chart subtitle%@NL@%
Env.SubTitle.TitleColor = 11                  ' Color of subtitle text%@NL@%
Env.SubTitle.Justify = cCenter                ' How to align of subtitle text%@NL@%
Env.ChartWindow.Border = cYes                 ' Specifies chart has no border%@NL@%
%@NL@%
%@AB@%' Call the pie-charting routine --- Arguments for call to ChartPie are:%@AE@%%@NL@%
%@AB@%' Env                 - Environment variable%@AE@%%@NL@%
%@AB@%' MonthCategories()   - Array containing Category labels%@AE@%%@NL@%
%@AB@%' OJvalues()          - Array containing Data values to chart%@AE@%%@NL@%
%@AB@%' Exploded()          - Integer array tells which pieces of the pie should%@AE@%%@NL@%
%@AB@%'                         be separated (non-zero=exploded, 0=not exploded)%@AE@%%@NL@%
%@AB@%' MONTHS              - Tells number of data values to chart%@AE@%%@NL@%
%@NL@%
        ChartPie Env, MonthCategories(), OJvalues(), Exploded(), MONTHS%@NL@%
        SLEEP%@NL@%
%@AB@%        '  If the rest of your program isn't graphic, reset original mode here%@AE@%%@NL@%
END%@NL@%
%@NL@%
%@AB@%' Simulate data generation for chart values and category labels%@AE@%%@NL@%
DATA 33,27,42,64,106,157,182,217,128,62,43,36%@NL@%
DATA "Jan","Feb","Mar","Apr","May","Jun","Jly","Aug","Sep","Oct","Nov","Dec"%@NL@%
%@NL@%
%@AB@%'============= Function to determine and set highest resolution ========%@AE@%%@NL@%
%@AB@%' The BestMode function uses a local error trap to check available modes,%@AE@%%@NL@%
%@AB@%' then assigns the integer representing the best mode for charting to its%@AE@%%@NL@%
%@AB@%' name so it is returned to the caller. The function terminate execution if%@AE@%%@NL@%
%@AB@%' the hardware doesn't support a mode appropriate for Presentation Graphics%@AE@%%@NL@%
%@AB@%'========================================================================%@AE@%%@NL@%
FUNCTION BestMode%@NL@%
%@NL@%
%@AB@%' Set a trap for an expected local error --- handled within the function%@AE@%%@NL@%
ON LOCAL ERROR GOTO ScreenError%@NL@%
%@NL@%
FOR TestValue = HIGHESTMODE TO 0 STEP -1%@NL@%
        DisplayError = FALSE%@NL@%
        SCREEN TestValue%@NL@%
        IF DisplayError = FALSE THEN%@NL@%
                SELECT CASE TestValue%@NL@%
                        CASE 12, 13%@NL@%
                                BestMode = 12%@NL@%
                        CASE 9, 10, 11%@NL@%
                                BestMode = 9%@NL@%
                        CASE 8, 4, 3%@NL@%
                                BestMode = TestValue%@NL@%
                        CASE 2, 7%@NL@%
                                BestMode = 2%@NL@%
                        CASE 1%@NL@%
                                BestMode = 1%@NL@%
                        CASE ELSE%@NL@%
                                PRINT "Sorry, you need graphics to display charts"%@NL@%
                                END%@NL@%
                END SELECT%@NL@%
                EXIT FUNCTION%@NL@%
        END IF%@NL@%
NEXT TestValue%@NL@%
%@AB@%' Note there is no need to turn off the local error handler. It is turned off%@AE@%%@NL@%
%@AB@%' automatically when control passes out of the function%@AE@%%@NL@%
%@NL@%
EXIT FUNCTION%@NL@%
%@AB@%'==================== | Local error handler code |=======================%@AE@%%@NL@%
%@AB@%' The ScreenError label identifies a local error handler relied in the%@AE@%%@NL@%
%@AB@%' BestMode function. Invalid SCREEN values generate Error # 5 (Illegal%@AE@%%@NL@%
%@AB@%' function call) --- so if that is not the error reset ERROR to the ERR%@AE@%%@NL@%
%@AB@%' value that was generated so the error can be passed to other, possibly%@AE@%%@NL@%
%@AB@%' more appropriate errors.%@AE@%%@NL@%
ScreenError:%@NL@%
        IF ERR = 5 THEN%@NL@%
                DisplayError = TRUE%@NL@%
                RESUME NEXT%@NL@%
        ELSE%@NL@%
                ERROR ERR%@NL@%
        END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PGSCAT.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\PGSCAT.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' PGSCAT.BAS:  Create sample scatter diagram%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@AB@%' $INCLUDE: 'CHRTB.BI'%@AE@%%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE, MONTHS = 12%@NL@%
CONST HIGHESTMODE = 13, TEXTONLY = 0%@NL@%
%@NL@%
DIM Env AS ChartEnvironment                 ' See CHRTB.BI for declaration of                     ' the%@NL@%
%@AB@%                                                                                                                                                                                ' ChartEnvironment type%@AE@%%@NL@%
DIM OJvalues(1 TO MONTHS) AS SINGLE         ' Array for 1st data series%@NL@%
DIM HCvalues(1 TO MONTHS) AS SINGLE         ' Array for 2nd data series%@NL@%
DECLARE FUNCTION BestMode ()%@NL@%
%@NL@%
%@AB@%' Initialize the data arrays%@AE@%%@NL@%
FOR index = 1 TO MONTHS: READ OJvalues(index): NEXT index%@NL@%
FOR index = 1 TO MONTHS: READ HCvalues(index): NEXT index%@NL@%
%@NL@%
%@AB@%' Pass the value returned by the BestMode function to the Presentation%@AE@%%@NL@%
%@AB@%' Graphics routine ChartScreen to set the graphics mode for charting%@AE@%%@NL@%
%@NL@%
ChartScreen (BestMode)      ' Even if SCREEN is already set to an acceptable%@NL@%
%@AB@%                                                                                                                ' mode, you still have to set it with ChartScreen%@AE@%%@NL@%
IF ChartErr = cBadScreen THEN   ' Check to make sure ChartScreen succeeded%@NL@%
        PRINT "Sorry --- There is a screen-mode problem in the Charting library"%@NL@%
        END%@NL@%
END IF%@NL@%
%@NL@%
%@AB@%' Initialize a default pie chart%@AE@%%@NL@%
%@AB@%                                                                                                                                                        ' Pass Env (the environment variable);%@AE@%%@NL@%
DefaultChart Env, cScatter, cNoLines  ' constant cScatter (for Scatter Chart);%@NL@%
%@AB@%                                                                                                                                                        ' cNoLines (unjoined points)%@AE@%%@NL@%
%@NL@%
%@AB@%' Add Titles and some chart options. These assignments modify some default%@AE@%%@NL@%
%@AB@%' values set in the variable Env (of type ChartEnvironment) by DefaultChart%@AE@%%@NL@%
%@NL@%
Env.MainTitle.Title = "Good Neighbor Grocery" ' Specifies text of chart title%@NL@%
Env.MainTitle.TitleColor = 11                 ' Specifies color of title text%@NL@%
Env.MainTitle.Justify = cRight                ' How to align of title text%@NL@%
Env.SubTitle.Title = "OJ vs. Hot Chocolate"   ' Text of chart subtitle%@NL@%
Env.SubTitle.TitleColor = 15                  ' Color of subtitle text%@NL@%
Env.SubTitle.Justify = cRight                 ' How to align of subtitle text%@NL@%
Env.ChartWindow.Border = cNo                  ' Specifies chart has no border%@NL@%
%@NL@%
%@AB@%' The next two assignments label the x and y axes of the chart%@AE@%%@NL@%
Env.XAxis.AxisTitle.Title = "Orange Juice Sales"%@NL@%
Env.YAxis.AxisTitle.Title = "Hot Chocolate Sales"%@NL@%
%@NL@%
%@AB@%' Call the pie-charting routine --- Arguments for call to ChartPie are:%@AE@%%@NL@%
%@AB@%' Env                 - Environment variable%@AE@%%@NL@%
%@AB@%' OJvalues            - Array containing orange-juice sales values to chart%@AE@%%@NL@%
%@AB@%' HCvalues            - Array containing hot-chocolate sales values to chart%@AE@%%@NL@%
%@AB@%' MONTHS              - Tells number of data values to chart%@AE@%%@NL@%
%@NL@%
        ChartScatter Env, OJvalues(), HCvalues(), MONTHS%@NL@%
        SLEEP%@NL@%
%@AB@%        '  If the rest of your program isn't graphic, reset original mode here%@AE@%%@NL@%
END%@NL@%
%@NL@%
%@AB@%' Simulate data generation for chart values and category labels%@AE@%%@NL@%
DATA 33,27,42,64,106,157,182,217,128,62,43,36%@NL@%
DATA 37,37,30,19,10,5,2,1,7,15,28,39%@NL@%
%@NL@%
%@AB@%'============= Function to determine and set highest resolution ========%@AE@%%@NL@%
%@AB@%' The BestMode function uses a local error trap to check available modes,%@AE@%%@NL@%
%@AB@%' then assigns the integer representing the best mode for charting to its%@AE@%%@NL@%
%@AB@%' name so it is returned to the caller. The function terminate execution if%@AE@%%@NL@%
%@AB@%' the hardware doesn't support a mode appropriate for Presentation Graphics%@AE@%%@NL@%
%@AB@%'========================================================================%@AE@%%@NL@%
FUNCTION BestMode%@NL@%
%@NL@%
%@AB@%' Set a trap for an expected local error --- handled within the function%@AE@%%@NL@%
ON LOCAL ERROR GOTO ScreenError%@NL@%
%@NL@%
FOR TestValue = HIGHESTMODE TO 0 STEP -1%@NL@%
        DisplayError = FALSE%@NL@%
        SCREEN TestValue%@NL@%
        IF DisplayError = FALSE THEN%@NL@%
                SELECT CASE TestValue%@NL@%
                        CASE 12, 13%@NL@%
                                BestMode = 12%@NL@%
                        CASE 9, 10, 11%@NL@%
                                BestMode = 9%@NL@%
                        CASE 8, 4, 3%@NL@%
                                BestMode = TestValue%@NL@%
                        CASE 2, 7%@NL@%
                                BestMode = 2%@NL@%
                        CASE 1%@NL@%
                                BestMode = 1%@NL@%
                        CASE ELSE%@NL@%
                                PRINT "Sorry, you need graphics to display charts"%@NL@%
                                END%@NL@%
                END SELECT%@NL@%
                EXIT FUNCTION%@NL@%
        END IF%@NL@%
NEXT TestValue%@NL@%
%@AB@%' Note there is no need to turn off the local error handler. It is turned off%@AE@%%@NL@%
%@AB@%' automatically when control passes out of the function%@AE@%%@NL@%
%@NL@%
EXIT FUNCTION%@NL@%
%@AB@%'==================== | Local error handler code |=======================%@AE@%%@NL@%
%@AB@%' The ScreenError label identifies a local error handler relied in the%@AE@%%@NL@%
%@AB@%' BestMode function. Invalid SCREEN values generate Error # 5 (Illegal%@AE@%%@NL@%
%@AB@%' function call) --- so if that is not the error reset ERROR to the ERR%@AE@%%@NL@%
%@AB@%' value that was generated so the error can be passed to other, possibly%@AE@%%@NL@%
%@AB@%' more appropriate errors.%@AE@%%@NL@%
ScreenError:%@NL@%
        IF ERR = 5 THEN%@NL@%
                DisplayError = TRUE%@NL@%
                RESUME NEXT%@NL@%
        ELSE%@NL@%
                ERROR ERR%@NL@%
        END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PLOTTER.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\PLOTTER.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' Values for keys on the numeric keypad and the spacebar:%@AE@%%@NL@%
CONST UP = 72, DOWN = 80, LFT = 75, RGHT = 77%@NL@%
CONST UPLFT = 71, UPRGHT = 73, DOWNLFT = 79, DOWNRGHT = 81%@NL@%
CONST SPACEBAR = " "%@NL@%
%@NL@%
%@AB@%' Null$ is the first character of the two-character INKEY$%@AE@%%@NL@%
%@AB@%' value returned for direction keys such as UP and DOWN:%@AE@%%@NL@%
Null$ = CHR$(0)%@NL@%
%@AB@%' Plot$ = "" means draw lines; Plot$ = "B" means%@AE@%%@NL@%
%@AB@%' move graphics cursor, but don't draw lines:%@AE@%%@NL@%
Plot$ = ""%@NL@%
%@NL@%
PRINT "Use the cursor movement keys to draw lines."%@NL@%
PRINT "Press spacebar to toggle line drawing on and off."%@NL@%
PRINT "Press <ENTER> to begin. Press q to end the program."%@NL@%
DO : LOOP WHILE INKEY$ = ""%@NL@%
%@NL@%
SCREEN 1%@NL@%
%@NL@%
DO%@NL@%
   SELECT CASE KeyVal$%@NL@%
      CASE Null$ + CHR$(UP)%@NL@%
         DRAW Plot$ + "C1 U2"%@NL@%
      CASE Null$ + CHR$(DOWN)%@NL@%
         DRAW Plot$ + "C1 D2"%@NL@%
      CASE Null$ + CHR$(LFT)%@NL@%
         DRAW Plot$ + "C2 L2"%@NL@%
      CASE Null$ + CHR$(RGHT)%@NL@%
         DRAW Plot$ + "C2 R2"%@NL@%
      CASE Null$ + CHR$(UPLFT)%@NL@%
         DRAW Plot$ + "C3 H2"%@NL@%
      CASE Null$ + CHR$(UPRGHT)%@NL@%
         DRAW Plot$ + "C3 E2"%@NL@%
      CASE Null$ + CHR$(DOWNLFT)%@NL@%
         DRAW Plot$ + "C3 G2"%@NL@%
      CASE Null$ + CHR$(DOWNRGHT)%@NL@%
         DRAW Plot$ + "C3 F2"%@NL@%
      CASE SPACEBAR%@NL@%
         IF Plot$ = "" THEN Plot$ = "B " ELSE Plot$ = ""%@NL@%
      CASE ELSE%@NL@%
%@AB@%         ' The user pressed some key other than one of the%@AE@%%@NL@%
%@AB@%         ' direction keys, the spacebar, or "q," so%@AE@%%@NL@%
%@AB@%         ' don't do anything.%@AE@%%@NL@%
   END SELECT%@NL@%
%@NL@%
   KeyVal$ = INKEY$%@NL@%
%@NL@%
LOOP UNTIL KeyVal$ = "q"%@NL@%
%@NL@%
SCREEN 0, 0                ' Restore the screen to 80-column%@NL@%
WIDTH 80                ' text mode and end.%@NL@%
END%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%QLBDUMP.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\QLBDUMP.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'This program prints the names of Quick library procedures.%@AE@%%@NL@%
%@NL@%
DECLARE SUB DumpSym (SymStart AS INTEGER, QHdrPos AS LONG)%@NL@%
%@NL@%
TYPE ExeHdr                   'Part of DOS .EXE header.%@NL@%
     other1    AS STRING * 8  'Other header information.%@NL@%
     CParHdr   AS INTEGER     'Size of header in paragraphs.%@NL@%
     other2    AS STRING * 10 'Other header information.%@NL@%
     IP         AS INTEGER    'Initial IP value.%@NL@%
     CS         AS INTEGER    'Initial (relative) CS value.%@NL@%
END TYPE%@NL@%
TYPE QBHdr                    'QLB header.%@NL@%
     QBHead    AS STRING * 6  'QBX specific heading.%@NL@%
     Magic     AS INTEGER     'Magic word: identifies file as a Quick library.%@NL@%
     SymStart  AS INTEGER     'Offset from header to first code symbol.%@NL@%
     DatStart  AS INTEGER     'Offset from header to first data symbol.%@NL@%
END TYPE%@NL@%
%@NL@%
TYPE QbSym                    'QuickLib symbol entry.%@NL@%
     Flags     AS INTEGER     'Symbol flags.%@NL@%
     NameStart AS INTEGER     'Offset into name table.%@NL@%
     other     AS STRING * 4  'Other header information.%@NL@%
END TYPE%@NL@%
%@NL@%
DIM EHdr AS ExeHdr, Qhdr AS QBHdr, QHdrPos AS LONG%@NL@%
%@NL@%
INPUT "Enter Quick library file name: ", FileName$%@NL@%
FileName$ = UCASE$(FileName$)%@NL@%
IF INSTR(FileName$, ".QLB") = 0 THEN FileName$ = FileName$ + ".QLB"%@NL@%
INPUT "Enter output file name or press ENTER for screen: ", OutFile$%@NL@%
OutFile$ = UCASE$(OutFile$)%@NL@%
IF OutFile$ = "" THEN OutFile$ = "CON"%@NL@%
%@NL@%
IF DIR$(FileName$) = "" THEN PRINT "File "; FileName$; " not found.": END%@NL@%
%@NL@%
OPEN FileName$ FOR BINARY AS #1%@NL@%
OPEN OutFile$ FOR OUTPUT AS #2%@NL@%
%@NL@%
GET #1, , EHdr                     'Read the EXE format header.%@NL@%
TEMP1& = EHdr.CParHdr + EHdr.CS    'Use a LONG temp to prevent overflow.%@NL@%
QHdrPos = TEMP1& * 16 + EHdr.IP + 1%@NL@%
%@NL@%
GET #1, QHdrPos, Qhdr              'Read the QuickLib format header.%@NL@%
IF Qhdr.Magic <> &H6C75 THEN PRINT "Not a valid QBX Quick-Library": END%@NL@%
%@NL@%
PRINT #2, "Code Symbols:": PRINT #2,%@NL@%
DumpSym Qhdr.SymStart, QHdrPos     'Dump code symbols.%@NL@%
PRINT #2,%@NL@%
PRINT #2, "Data Symbols:": PRINT #2, ""%@NL@%
DumpSym Qhdr.DatStart, QHdrPos     'Dump data symbols.%@NL@%
PRINT #2,%@NL@%
%@NL@%
END%@NL@%
%@NL@%
SUB DumpSym (SymStart AS INTEGER, QHdrPos AS LONG)%@NL@%
        DIM QlbSym AS QbSym%@NL@%
        DIM NextSym AS LONG, CurrentSym AS LONG%@NL@%
%@NL@%
%@AB@%    'Calculate the location of the first symbol entry, then read that entry.%@AE@%%@NL@%
        NextSym = QHdrPos + SymStart%@NL@%
        GET #1, NextSym, QlbSym%@NL@%
DO%@NL@%
        NextSym = SEEK(1)         'Save the location of the next symbol.%@NL@%
                CurrentSym = QHdrPos + QlbSym.NameStart%@NL@%
        SEEK #1, CurrentSym       'Use SEEK to move to the name%@NL@%
%@AB@%                                  'for the current symbol entry.%@AE@%%@NL@%
        Prospect$ = INPUT$(40, 1) 'Read the longest legal string,%@NL@%
%@AB@%                                  'plus one additional byte for%@AE@%%@NL@%
%@AB@%                                  'the final null character (CHR$(0)).%@AE@%%@NL@%
%@NL@%
%@AB@%        'Extract the null-terminated name.%@AE@%%@NL@%
                SName$ = LEFT$(Prospect$, INSTR(Prospect$, CHR$(0)))%@NL@%
%@NL@%
%@AB@%        'Print only those names that do not begin with "__", "$", or "b$"%@AE@%%@NL@%
%@AB@%        'as these names are usually considered reserved.%@AE@%%@NL@%
                T$ = LEFT$(SName$, 2)%@NL@%
                IF T$ <> "__" AND LEFT$(SName$, 1) <> "$" AND UCASE$(T$) <> "B$" THEN%@NL@%
                        PRINT #2, "  " + SName$%@NL@%
                END IF%@NL@%
%@NL@%
        GET #1, NextSym, QlbSym    'Read a symbol entry.%@NL@%
    LOOP WHILE QlbSym.Flags        'Flags=0 (false) means end of table.%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%REMLINE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\REMLINE.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   Microsoft RemLine - Line Number Removal Utility%@AE@%%@NL@%
%@AB@%'   Copyright (C) Microsoft Corporation   - 1985, 1986, 1987%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   REMLINE.BAS is a program to remove line numbers from Microsoft BASIC%@AE@%%@NL@%
%@AB@%'   Programs. It removes only those line numbers that are not the object%@AE@%%@NL@%
%@AB@%'   of one of the following statements: GOSUB, RETURN, GOTO, THEN, ELSE,%@AE@%%@NL@%
%@AB@%'   RESUME, RESTORE, or RUN.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   REMLINE is run by typing%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'      REMLINE [<input> [, <output>]]%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   where <input> is the name of the file to be processed and <output>%@AE@%%@NL@%
%@AB@%'   is the name of the file or device to receive the reformatted output.%@AE@%%@NL@%
%@AB@%'   If no extension is given, .BAS is assumed (except for output devices).%@AE@%%@NL@%
%@AB@%'   If file names are not given, REMLINE prompts for file names. If both%@AE@%%@NL@%
%@AB@%'   file names are the same, REMLINE saves the original file with the%@AE@%%@NL@%
%@AB@%'   extension .BAK.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   REMLINE makes several assumptions about the program:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     1. It must be correct syntactically, and must run in BASICA or%@AE@%%@NL@%
%@AB@%'        GWBASIC interpreter.%@AE@%%@NL@%
%@AB@%'     2. There is a 400 line limit. To process larger files, change%@AE@%%@NL@%
%@AB@%'        MaxLines constant.%@AE@%%@NL@%
%@AB@%'     3. The first number encountered on a line is considered a line%@AE@%%@NL@%
%@AB@%'        number; thus some continuation lines (in a compiler specific%@AE@%%@NL@%
%@AB@%'        constructiion) may not be handled correctly.%@AE@%%@NL@%
%@AB@%'     4. REMLINE can handle simple statements that test the ERL function%@AE@%%@NL@%
%@AB@%'        using  relational operators such as =, <, and >. For example,%@AE@%%@NL@%
%@AB@%'        the following statement is handled correctly:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'             IF ERL = 100 THEN END%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'        Line 100 is not removed from the source code. However, more%@AE@%%@NL@%
%@AB@%'        complex expressions that contain the +, -, AND, OR, XOR, EQV,%@AE@%%@NL@%
%@AB@%'        MOD, or IMP operators may not be handled correctly. For example,%@AE@%%@NL@%
%@AB@%'        in the following statement REMLINE does not recognize line 105%@AE@%%@NL@%
%@AB@%'        as a referenced line number and removes it from the source code:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'             IF ERL + 5 = 105 THEN END%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   If you do not like the way REMLINE formats its output, you can modify%@AE@%%@NL@%
%@AB@%'   the output lines in SUB GenOutFile. An example is shown in comments.%@AE@%%@NL@%
%@NL@%
%@AB@%' Function and Subprogram declarations%@AE@%%@NL@%
%@NL@%
DECLARE FUNCTION GetToken$ (Search$, Delim$)%@NL@%
DECLARE FUNCTION StrSpn% (InString$, Separator$)%@NL@%
DECLARE FUNCTION StrBrk% (InString$, Separator$)%@NL@%
DECLARE FUNCTION IsDigit% (Char$)%@NL@%
DECLARE SUB GetFileNames ()%@NL@%
DECLARE SUB BuildTable ()%@NL@%
DECLARE SUB GenOutFile ()%@NL@%
DECLARE SUB InitKeyTable ()%@NL@%
%@NL@%
%@AB@%' Global and constant data%@AE@%%@NL@%
%@NL@%
CONST TRUE = -1%@NL@%
CONST false = 0%@NL@%
CONST MaxLines = 400%@NL@%
%@NL@%
DIM SHARED LineTable!(MaxLines)%@NL@%
DIM SHARED LineCount%@NL@%
DIM SHARED Seps$, InputFile$, OutputFile$, TmpFile$%@NL@%
%@NL@%
%@AB@%' Keyword search data%@AE@%%@NL@%
%@NL@%
CONST KeyWordCount = 9%@NL@%
DIM SHARED KeyWordTable$(KeyWordCount)%@NL@%
%@NL@%
KeyData:%@NL@%
   DATA THEN, ELSE, GOSUB, GOTO, RESUME, RETURN, RESTORE, RUN, ERL, ""%@NL@%
%@NL@%
%@AB@%' Start of module-level program code%@AE@%%@NL@%
%@NL@%
   Seps$ = " ,:=<>()" + CHR$(9)%@NL@%
   InitKeyTable%@NL@%
   GetFileNames%@NL@%
   ON ERROR GOTO FileErr1%@NL@%
   OPEN InputFile$ FOR INPUT AS 1%@NL@%
   ON ERROR GOTO 0%@NL@%
   COLOR 7: PRINT "Working"; : COLOR 23: PRINT " . . .": COLOR 7: PRINT%@NL@%
   BuildTable%@NL@%
   CLOSE #1%@NL@%
   OPEN InputFile$ FOR INPUT AS 1%@NL@%
   ON ERROR GOTO FileErr2%@NL@%
   OPEN OutputFile$ FOR OUTPUT AS 2%@NL@%
   ON ERROR GOTO 0%@NL@%
   GenOutFile%@NL@%
   CLOSE #1, #2%@NL@%
   IF OutputFile$ <> "CON" THEN CLS%@NL@%
%@NL@%
END%@NL@%
%@NL@%
FileErr1:%@NL@%
   CLS%@NL@%
   PRINT "      Invalid file name": PRINT%@NL@%
   INPUT "      New input file name (ENTER to terminate): ", InputFile$%@NL@%
   IF InputFile$ = "" THEN END%@NL@%
FileErr2:%@NL@%
   INPUT "      Output file name (ENTER to print to screen) :", OutputFile$%@NL@%
   PRINT%@NL@%
   IF (OutputFile$ = "") THEN OutputFile$ = "CON"%@NL@%
   IF TmpFile$ = "" THEN%@NL@%
      RESUME%@NL@%
   ELSE%@NL@%
      TmpFile$ = ""%@NL@%
      RESUME NEXT%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' BuildTable:%@AE@%%@NL@%
%@AB@%'   Examines the entire text file looking for line numbers that are%@AE@%%@NL@%
%@AB@%'   the object of GOTO, GOSUB, etc. As each is found, it is entered%@AE@%%@NL@%
%@AB@%'   into a table of line numbers. The table is used during a second%@AE@%%@NL@%
%@AB@%'   pass (see GenOutFile), when all line numbers not in the list%@AE@%%@NL@%
%@AB@%'   are removed.%@AE@%%@NL@%
%@AB@%' Input:%@AE@%%@NL@%
%@AB@%'   Uses globals KeyWordTable$, KeyWordCount, and Seps$%@AE@%%@NL@%
%@AB@%' Output:%@AE@%%@NL@%
%@AB@%'   Modefies LineTable! and LineCount%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB BuildTable STATIC%@NL@%
%@NL@%
   DO WHILE NOT EOF(1)%@NL@%
%@AB@%      ' Get line and first token%@AE@%%@NL@%
      LINE INPUT #1, InLin$%@NL@%
      token$ = GetToken$(InLin$, Seps$)%@NL@%
      DO WHILE (token$ <> "")%@NL@%
         FOR KeyIndex = 1 TO KeyWordCount%@NL@%
%@AB@%            ' See if token is keyword%@AE@%%@NL@%
            IF (KeyWordTable$(KeyIndex) = UCASE$(token$)) THEN%@NL@%
%@AB@%               ' Get possible line number after keyword%@AE@%%@NL@%
               token$ = GetToken$("", Seps$)%@NL@%
%@AB@%               ' Check each token to see if it is a line number%@AE@%%@NL@%
%@AB@%               ' (the LOOP is necessary for the multiple numbers%@AE@%%@NL@%
%@AB@%               ' of ON GOSUB or ON GOTO). A non-numeric token will%@AE@%%@NL@%
%@AB@%               ' terminate search.%@AE@%%@NL@%
               DO WHILE (IsDigit(LEFT$(token$, 1)))%@NL@%
                  LineCount = LineCount + 1%@NL@%
                  LineTable!(LineCount) = VAL(token$)%@NL@%
                  token$ = GetToken$("", Seps$)%@NL@%
                  IF token$ <> "" THEN KeyIndex = 0%@NL@%
               LOOP%@NL@%
            END IF%@NL@%
         NEXT KeyIndex%@NL@%
%@AB@%         ' Get next token%@AE@%%@NL@%
         token$ = GetToken$("", Seps$)%@NL@%
      LOOP%@NL@%
   LOOP%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' GenOutFile:%@AE@%%@NL@%
%@AB@%'  Generates an output file with unreferenced line numbers removed.%@AE@%%@NL@%
%@AB@%' Input:%@AE@%%@NL@%
%@AB@%'  Uses globals LineTable!, LineCount, and Seps$%@AE@%%@NL@%
%@AB@%' Output:%@AE@%%@NL@%
%@AB@%'  Processed file%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB GenOutFile STATIC%@NL@%
%@NL@%
%@AB@%   ' Speed up by eliminating comma and colon (can't separate first token)%@AE@%%@NL@%
   Sep$ = " " + CHR$(9)%@NL@%
   DO WHILE NOT EOF(1)%@NL@%
      LINE INPUT #1, InLin$%@NL@%
      IF (InLin$ <> "") THEN%@NL@%
%@AB@%         ' Get first token and process if it is a line number%@AE@%%@NL@%
         token$ = GetToken$(InLin$, Sep$)%@NL@%
         IF IsDigit(LEFT$(token$, 1)) THEN%@NL@%
            LineNumber! = VAL(token$)%@NL@%
            FoundNumber = false%@NL@%
%@AB@%            ' See if line number is in table of referenced line numbers%@AE@%%@NL@%
            FOR index = 1 TO LineCount%@NL@%
               IF (LineNumber! = LineTable!(index)) THEN%@NL@%
                  FoundNumber = TRUE%@NL@%
               END IF%@NL@%
            NEXT index%@NL@%
%@AB@%            ' Modify line strings%@AE@%%@NL@%
            IF (NOT FoundNumber) THEN%@NL@%
               token$ = SPACE$(LEN(token$))%@NL@%
               MID$(InLin$, StrSpn(InLin$, Sep$), LEN(token$)) = token$%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%            ' You can replace the previous lines with your own%@AE@%%@NL@%
%@AB@%            ' code to reformat output. For example, try these lines:%@AE@%%@NL@%
%@NL@%
%@AB@%            'TmpPos1 = StrSpn(InLin$, Sep$) + LEN(Token$)%@AE@%%@NL@%
%@AB@%            'TmpPos2 = TmpPos1 + StrSpn(MID$(InLin$, TmpPos1), Sep$)%@AE@%%@NL@%
%@AB@%            '%@AE@%%@NL@%
%@AB@%            'IF FoundNumber THEN%@AE@%%@NL@%
%@AB@%            '   InLin$ = LEFT$(InLin$, TmpPos1 - 1) + CHR$(9) + MID$(InLin$, TmpPos2)%@AE@%%@NL@%
%@AB@%            'ELSE%@AE@%%@NL@%
%@AB@%            '   InLin$ = CHR$(9) + MID$(InLin$, TmpPos2)%@AE@%%@NL@%
%@AB@%            'END IF%@AE@%%@NL@%
%@NL@%
         END IF%@NL@%
      END IF%@NL@%
%@AB@%      ' Print line to file or console (PRINT is faster than console device)%@AE@%%@NL@%
      IF OutputFile$ = "CON" THEN%@NL@%
         PRINT InLin$%@NL@%
      ELSE%@NL@%
         PRINT #2, InLin$%@NL@%
      END IF%@NL@%
   LOOP%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' GetFileNames:%@AE@%%@NL@%
%@AB@%'  Gets a file name from COMMAND$ or by prompting the user.%@AE@%%@NL@%
%@AB@%' Input:%@AE@%%@NL@%
%@AB@%'  Used Command$ or user input%@AE@%%@NL@%
%@AB@%' Output:%@AE@%%@NL@%
%@AB@%'  Defines InputFiles$ and OutputFiles$%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB GetFileNames STATIC%@NL@%
%@NL@%
   IF (COMMAND$ = "") THEN%@NL@%
      CLS%@NL@%
      PRINT " Microsoft RemLine: Line Number Removal Utility"%@NL@%
      PRINT "       (.BAS assumed if no extension given)"%@NL@%
      PRINT%@NL@%
      INPUT "      Input file name (ENTER to terminate): ", InputFile$%@NL@%
      IF InputFile$ = "" THEN END%@NL@%
      INPUT "      Output file name (ENTER to print to screen): ", OutputFile$%@NL@%
      PRINT%@NL@%
      IF (OutputFile$ = "") THEN OutputFile$ = "CON"%@NL@%
   ELSE%@NL@%
      InputFile$ = UCASE$(GetToken$(COMMAND$, Seps$))%@NL@%
      OutputFile$ = UCASE$(GetToken$("", Seps$))%@NL@%
      IF (OutputFile$ = "") THEN%@NL@%
         INPUT "      Output file name (ENTER to print to screen): ", OutputFile$%@NL@%
         PRINT%@NL@%
         IF (OutputFile$ = "") THEN OutputFile$ = "CON"%@NL@%
      END IF%@NL@%
   END IF%@NL@%
   IF INSTR(InputFile$, ".") = 0 THEN%@NL@%
      InputFile$ = InputFile$ + ".BAS"%@NL@%
   END IF%@NL@%
   IF INSTR(OutputFile$, ".") = 0 THEN%@NL@%
      SELECT CASE OutputFile$%@NL@%
         CASE "CON", "SCRN", "PRN", "COM1", "COM2", "LPT1", "LPT2", "LPT3"%@NL@%
            EXIT SUB%@NL@%
         CASE ELSE%@NL@%
            OutputFile$ = OutputFile$ + ".BAS"%@NL@%
      END SELECT%@NL@%
   END IF%@NL@%
   DO WHILE InputFile$ = OutputFile$%@NL@%
      TmpFile$ = LEFT$(InputFile$, INSTR(InputFile$, ".")) + "BAK"%@NL@%
      ON ERROR GOTO FileErr1%@NL@%
      NAME InputFile$ AS TmpFile$%@NL@%
      ON ERROR GOTO 0%@NL@%
      IF TmpFile$ <> "" THEN InputFile$ = TmpFile$%@NL@%
   LOOP%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' GetToken$:%@AE@%%@NL@%
%@AB@%'  Extracts tokens from a string. A token is a word that is surrounded%@AE@%%@NL@%
%@AB@%'  by separators, such as spaces or commas. Tokens are extracted and%@AE@%%@NL@%
%@AB@%'  analyzed when parsing sentences or commands. To use the GetToken$%@AE@%%@NL@%
%@AB@%'  function, pass the string to be parsed on the first call, then pass%@AE@%%@NL@%
%@AB@%'  a null string on subsequent calls until the function returns a null%@AE@%%@NL@%
%@AB@%'  to indicate that the entire string has been parsed.%@AE@%%@NL@%
%@AB@%' Input:%@AE@%%@NL@%
%@AB@%'  Search$ = string to search%@AE@%%@NL@%
%@AB@%'  Delim$  = String of separators%@AE@%%@NL@%
%@AB@%' Output:%@AE@%%@NL@%
%@AB@%'  GetToken$ = next token%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION GetToken$ (Search$, Delim$) STATIC%@NL@%
%@NL@%
%@AB@%   ' Note that SaveStr$ and BegPos must be static from call to call%@AE@%%@NL@%
%@AB@%   ' (other variables are only static for efficiency).%@AE@%%@NL@%
%@AB@%   ' If first call, make a copy of the string%@AE@%%@NL@%
   IF (Search$ <> "") THEN%@NL@%
      BegPos = 1%@NL@%
      SaveStr$ = Search$%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' Find the start of the next token%@AE@%%@NL@%
   NewPos = StrSpn(MID$(SaveStr$, BegPos, LEN(SaveStr$)), Delim$)%@NL@%
   IF NewPos THEN%@NL@%
%@AB@%      ' Set position to start of token%@AE@%%@NL@%
      BegPos = NewPos + BegPos - 1%@NL@%
   ELSE%@NL@%
%@AB@%      ' If no new token, quit and return null%@AE@%%@NL@%
      GetToken$ = ""%@NL@%
      EXIT FUNCTION%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' Find end of token%@AE@%%@NL@%
   NewPos = StrBrk(MID$(SaveStr$, BegPos, LEN(SaveStr$)), Delim$)%@NL@%
   IF NewPos THEN%@NL@%
%@AB@%      ' Set position to end of token%@AE@%%@NL@%
      NewPos = BegPos + NewPos - 1%@NL@%
   ELSE%@NL@%
%@AB@%      ' If no end of token, return set to end a value%@AE@%%@NL@%
      NewPos = LEN(SaveStr$) + 1%@NL@%
   END IF%@NL@%
%@AB@%   ' Cut token out of search string%@AE@%%@NL@%
   GetToken$ = MID$(SaveStr$, BegPos, NewPos - BegPos)%@NL@%
%@AB@%   ' Set new starting position%@AE@%%@NL@%
   BegPos = NewPos%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' InitKeyTable:%@AE@%%@NL@%
%@AB@%'  Initializes a keyword table. Keywords must be recognized so that%@AE@%%@NL@%
%@AB@%'  line numbers can be distinguished from numeric constants.%@AE@%%@NL@%
%@AB@%' Input:%@AE@%%@NL@%
%@AB@%'  Uses KeyData%@AE@%%@NL@%
%@AB@%' Output:%@AE@%%@NL@%
%@AB@%'  Modifies global array KeyWordTable$%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB InitKeyTable STATIC%@NL@%
%@NL@%
   RESTORE KeyData%@NL@%
   FOR Count = 1 TO KeyWordCount%@NL@%
      READ KeyWord$%@NL@%
      KeyWordTable$(Count) = KeyWord$%@NL@%
   NEXT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' IsDigit:%@AE@%%@NL@%
%@AB@%'  Returns true if character passed is a decimal digit. Since any%@AE@%%@NL@%
%@AB@%'  BASIC token starting with a digit is a number, the function only%@AE@%%@NL@%
%@AB@%'  needs to check the first digit. Doesn't check for negative numbers,%@AE@%%@NL@%
%@AB@%'  but that's not needed here.%@AE@%%@NL@%
%@AB@%' Input:%@AE@%%@NL@%
%@AB@%'  Char$ - initial character of string to check%@AE@%%@NL@%
%@AB@%' Output:%@AE@%%@NL@%
%@AB@%'  IsDigit - true if within 0 - 9%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION IsDigit (Char$) STATIC%@NL@%
%@NL@%
   IF (Char$ = "") THEN%@NL@%
      IsDigit = false%@NL@%
   ELSE%@NL@%
      CharAsc = ASC(Char$)%@NL@%
      IsDigit = (CharAsc >= ASC("0")) AND (CharAsc <= ASC("9"))%@NL@%
   END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' StrBrk:%@AE@%%@NL@%
%@AB@%'  Searches InString$ to find the first character from among those in%@AE@%%@NL@%
%@AB@%'  Separator$. Returns the index of that character. This function can%@AE@%%@NL@%
%@AB@%'  be used to find the end of a token.%@AE@%%@NL@%
%@AB@%' Input:%@AE@%%@NL@%
%@AB@%'  InString$ = string to search%@AE@%%@NL@%
%@AB@%'  Separator$ = characters to search for%@AE@%%@NL@%
%@AB@%' Output:%@AE@%%@NL@%
%@AB@%'  StrBrk = index to first match in InString$ or 0 if none match%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION StrBrk (InString$, Separator$) STATIC%@NL@%
%@NL@%
   Ln = LEN(InString$)%@NL@%
   BegPos = 1%@NL@%
%@AB@%   ' Look for end of token (first character that is a delimiter).%@AE@%%@NL@%
   DO WHILE INSTR(Separator$, MID$(InString$, BegPos, 1)) = 0%@NL@%
      IF BegPos > Ln THEN%@NL@%
         StrBrk = 0%@NL@%
         EXIT FUNCTION%@NL@%
      ELSE%@NL@%
         BegPos = BegPos + 1%@NL@%
      END IF%@NL@%
   LOOP%@NL@%
   StrBrk = BegPos%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' StrSpn:%@AE@%%@NL@%
%@AB@%'  Searches InString$ to find the first character that is not one of%@AE@%%@NL@%
%@AB@%'  those in Separator$. Returns the index of that character. This%@AE@%%@NL@%
%@AB@%'  function can be used to find the start of a token.%@AE@%%@NL@%
%@AB@%' Input:%@AE@%%@NL@%
%@AB@%'  InString$ = string to search%@AE@%%@NL@%
%@AB@%'  Separator$ = characters to search for%@AE@%%@NL@%
%@AB@%' Output:%@AE@%%@NL@%
%@AB@%'  StrSpn = index to first nonmatch in InString$ or 0 if all match%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION StrSpn% (InString$, Separator$) STATIC%@NL@%
%@NL@%
   Ln = LEN(InString$)%@NL@%
   BegPos = 1%@NL@%
%@AB@%   ' Look for start of a token (character that isn't a delimiter).%@AE@%%@NL@%
   DO WHILE INSTR(Separator$, MID$(InString$, BegPos, 1))%@NL@%
      IF BegPos > Ln THEN%@NL@%
         StrSpn = 0%@NL@%
         EXIT FUNCTION%@NL@%
      ELSE%@NL@%
         BegPos = BegPos + 1%@NL@%
      END IF%@NL@%
   LOOP%@NL@%
   StrSpn = BegPos%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SINEWAVE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\SINEWAVE.BAS%@AE@%%@NL@%
%@NL@%
SCREEN 2%@NL@%
%@NL@%
%@AB@%' Viewport sized to proper scale for graph:%@AE@%%@NL@%
VIEW (20, 2)-(620, 172), , 1%@NL@%
CONST PI = 3.141592653589#%@NL@%
%@NL@%
%@AB@%' Make window large enough to graph sine wave from%@AE@%%@NL@%
%@AB@%' 0 radians to pi radians:%@AE@%%@NL@%
WINDOW (0, -1.1)-(2 * PI, 1.1)%@NL@%
Style% = &HFF00         ' Use to make dashed line.%@NL@%
VIEW PRINT 23 TO 24  ' Scroll printed output in rows 23, 24.%@NL@%
DO%@NL@%
        PRINT TAB(20);%@NL@%
        INPUT "Number of cycles (0 to end): ", Cycles%@NL@%
        CLS%@NL@%
        LINE (2 * PI, 0)-(0, 0), , , Style%  ' Draw the x axis.%@NL@%
        IF Cycles > 0 THEN%@NL@%
%@NL@%
%@AB@%                '  Start at (0,0) and plot the graph:%@AE@%%@NL@%
                FOR X = 0 TO 2 * PI STEP .01%@NL@%
         Y = SIN(Cycles * X) ' Calculate the y coordinate.%@NL@%
         LINE -(X, Y)     ' Draw a line to new point.%@NL@%
                NEXT X%@NL@%
        END IF%@NL@%
LOOP WHILE Cycles > 0%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%STRTONUM.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\STRTONUM.BAS%@AE@%%@NL@%
%@NL@%
DECLARE FUNCTION Filter$ (Txt$, FilterString$)%@NL@%
%@NL@%
%@AB@%' Input a line:%@AE@%%@NL@%
LINE INPUT "Enter a number with commas: "; A$%@NL@%
%@NL@%
%@AB@%' Look only for valid numeric characters (0123456789.-)%@AE@%%@NL@%
%@AB@%' in the input string:%@AE@%%@NL@%
CleanNum$ = Filter$(A$, "0123456789.-")%@NL@%
%@NL@%
%@AB@%' Convert the string to a number:%@AE@%%@NL@%
PRINT "The number's value = "; VAL(CleanNum$)%@NL@%
END%@NL@%
%@NL@%
%@AB@%' ========================== FILTER =======================%@AE@%%@NL@%
%@AB@%'         Takes unwanted characters out of a string by%@AE@%%@NL@%
%@AB@%'         comparing them with a filter string containing%@AE@%%@NL@%
%@AB@%'         only acceptable numeric characters%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
FUNCTION Filter$ (Txt$, FilterString$) STATIC%@NL@%
   Temp$ = ""%@NL@%
   TxtLength = LEN(Txt$)%@NL@%
%@NL@%
   FOR I = 1 TO TxtLength     ' Isolate each character in%@NL@%
      C$ = MID$(Txt$, I, 1)   ' the string.%@NL@%
%@NL@%
%@AB@%      ' If the character is in the filter string, save it:%@AE@%%@NL@%
      IF INSTR(FilterString$, C$) <> 0 THEN%@NL@%
         Temp$ = Temp$ + C$%@NL@%
      END IF%@NL@%
   NEXT I%@NL@%
%@NL@%
   Filter$ = Temp$%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TERMINAL.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\TERMINAL.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
DECLARE        SUB Filter (InString$)%@NL@%
%@NL@%
COLOR 7, 1                        ' Set screen color.%@NL@%
CLS%@NL@%
%@NL@%
Quit$ = CHR$(0) + CHR$(16)        ' Value returned by INKEY$%@NL@%
%@AB@%                                ' when ALT+q is pressed.%@AE@%%@NL@%
%@NL@%
%@AB@%' Set up prompt on bottom line of screen and turn cursor on:%@AE@%%@NL@%
LOCATE 24, 1, 1%@NL@%
PRINT STRING$(80, "_");%@NL@%
LOCATE 25, 1%@NL@%
PRINT TAB(30); "Press ALT+q to quit";%@NL@%
%@NL@%
VIEW PRINT 1 TO        23                ' Print between lines 1 & 23.%@NL@%
%@NL@%
%@AB@%' Open communications (1200 baud, no parity, 8-bit data,%@AE@%%@NL@%
%@AB@%' 1 stop bit, 256-byte input buffer):%@AE@%%@NL@%
OPEN "COM1:1200,N,8,1" FOR RANDOM AS #1        LEN = 256%@NL@%
%@NL@%
DO                                ' Main communications loop.%@NL@%
%@NL@%
   KeyInput$ = INKEY$                ' Check the keyboard.%@NL@%
%@NL@%
   IF KeyInput$        = Quit$        THEN        ' Exit the loop if the user%@NL@%
      EXIT DO                        ' pressed ALT+q.%@NL@%
%@NL@%
   ELSEIF KeyInput$ <> "" THEN        ' Otherwise, if the user has%@NL@%
      PRINT #1,        KeyInput$;        ' pressed a key, send the%@NL@%
   END IF                        ' character typed to modem.%@NL@%
%@AB@% ' Check the modem. If characters are waiting (EOF(1) is%@AE@%%@NL@%
%@AB@% ' true), get them and print them to the screen:%@AE@%%@NL@%
 IF NOT EOF(1) THEN%@NL@%
%@NL@%
%@AB@%      ' LOC(1) gives the number of characters waiting:%@AE@%%@NL@%
      ModemInput$ = INPUT$(LOC(1), #1)%@NL@%
%@NL@%
      Filter ModemInput$        ' Filter out line feeds and%@NL@%
      PRINT ModemInput$;        ' backspaces, then print.%@NL@%
   END IF%@NL@%
LOOP%@NL@%
%@NL@%
CLOSE                                ' End communications.%@NL@%
CLS%@NL@%
END%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ========================= FILTER ========================%@AE@%%@NL@%
%@AB@%'               Filters characters in an input string%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB Filter (InString$) STATIC%@NL@%
%@NL@%
%@AB@%   ' Look for backspace characters and recode%@AE@%%@NL@%
%@AB@%   ' them to CHR$(29) (the LEFT cursor key):%@AE@%%@NL@%
   DO%@NL@%
      BackSpace = INSTR(InString$, CHR$(8))%@NL@%
      IF BackSpace THEN%@NL@%
      MID$(InString$, BackSpace) = CHR$(29)%@NL@%
      END IF%@NL@%
   LOOP WHILE BackSpace%@NL@%
%@NL@%
%@AB@%   ' Look for line-feed characters and%@AE@%%@NL@%
%@AB@%   ' remove any found:%@AE@%%@NL@%
   DO%@NL@%
      LnFd = INSTR(InString$, CHR$(10))%@NL@%
      IF LnFd THEN%@NL@%
   InString$=LEFT$(InString$,LnFd-1)+MID$(InString$,LnFd+1)%@NL@%
      END IF%@NL@%
   LOOP WHILE LnFd%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TIMER.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\TIMER.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' Declare external MASM procedures.%@AE@%%@NL@%
DECLARE SUB SetInt%@NL@%
DECLARE SUB RestInt%@NL@%
%@NL@%
%@AB@%' Install new interrupt service routine.%@AE@%%@NL@%
CALL SetInt%@NL@%
%@NL@%
%@AB@%' Set up the BASIC event handler.%@AE@%%@NL@%
ON UEVENT GOSUB SpecialTask%@NL@%
UEVENT ON%@NL@%
%@NL@%
DO%@NL@%
%@AB@%' Normal program operation occurs here.%@AE@%%@NL@%
%@AB@%' Program ends when any key is pressed.%@AE@%%@NL@%
LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%' Restore old interrupt service routine before quitting.%@AE@%%@NL@%
CALL RestInt%@NL@%
%@NL@%
END%@NL@%
%@NL@%
%@AB@%' Program branches here every 4.5 seconds.%@AE@%%@NL@%
SpecialTask:%@NL@%
%@AB@%' Code for performing the special task goes here, for example:%@AE@%%@NL@%
PRINT "Arrived here after 4.5 seconds."%@NL@%
RETURN%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TIMERA.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\TIMERA.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%;*************************  TIMERA.ASM  ******************************%@AE@%%@NL@%
%@AB@%; This program, along with TIMER.BAS, makes use of the BASIC SetUEvent%@AE@%%@NL@%
%@AB@%; routine to print a message on the screen every 4.5 seconds.%@AE@%%@NL@%
%@AB@%; This file has three procedures.  SetInt sets up the new DOS interrupt%@AE@%%@NL@%
%@AB@%; vector.  EventHandler increments a counter 18 times a second and%@AE@%%@NL@%
%@AB@%; notifies BASIC when 4.5 seconds have elapsed.  RestInt restores the%@AE@%%@NL@%
%@AB@%; old interrupt vector.%@AE@%%@NL@%
%@NL@%
            .model  medium, basic           %@AB@%;Stay compatible with BASIC.%@AE@%%@NL@%
            .code%@NL@%
SetInt      proc    uses ds                 %@AB@%;Get old interrupt vector%@AE@%%@NL@%
            mov     ax, 351CH               %@AB@%;and save it.%@AE@%%@NL@%
                        int        21h%@NL@%
            mov     word ptr cs:OldVector, bx%@NL@%
            mov     word ptr cs:OldVector + 2, es%@NL@%
%@NL@%
            push    cs                      %@AB@%;Set the new%@AE@%%@NL@%
            pop ds                          %@AB@%;interrupt vector%@AE@%%@NL@%
            lea dx, EventHandler            %@AB@%;to the address%@AE@%%@NL@%
            mov ax, 251CH                   %@AB@%;of our service%@AE@%%@NL@%
            int 21H                         %@AB@%;routine.%@AE@%%@NL@%
                        ret%@NL@%
SetInt      endp%@NL@%
%@NL@%
public  EventHandler                        %@AB@%;Make this routine%@AE@%%@NL@%
                                            %@AB@%;public for debugging--%@AE@%%@NL@%
EventHandler    proc                        %@AB@%;it will check to see if%@AE@%%@NL@%
                extrn   SetUEvent: proc     %@AB@%;4.5 seconds have passed.%@AE@%%@NL@%
%@NL@%
            push    bx%@NL@%
            lea     bx, TimerTicks%@NL@%
            inc     byte ptr cs:[bx]        %@AB@%;Have 4.5 seconds elapsed?%@AE@%%@NL@%
            cmp     byte ptr cs:[bx], 82%@NL@%
            jnz     Continue%@NL@%
            mov     byte ptr cs:[bx], 0     %@AB@%;If true, reset counter,%@AE@%%@NL@%
            push    ax                      %@AB@%;save registers, and%@AE@%%@NL@%
            push    cx                      %@AB@%;have BASIC set the%@AE@%%@NL@%
            push    dx                      %@AB@%;user event flag.%@AE@%%@NL@%
            push    es%@NL@%
            call    SetUevent%@NL@%
            pop     es%@NL@%
            pop     dx                      %@AB@%;Restore registers.%@AE@%%@NL@%
            pop     cx%@NL@%
            pop     ax%@NL@%
Continue:%@NL@%
            pop     bx%@NL@%
            jmp     cs:OldVector            %@AB@%;Continue on with the%@AE@%%@NL@%
                                            %@AB@%;old service routine.%@AE@%%@NL@%
%@NL@%
TimerTicks  db      0                       %@AB@%;Keep data in code segment%@AE@%%@NL@%
OldVector   dd      0                       %@AB@%;where it can be found no%@AE@%%@NL@%
                                            %@AB@%;matter where in memory the%@AE@%%@NL@%
EventHandler    endp                        %@AB@%;interrupt occurs.%@AE@%%@NL@%
%@NL@%
RestInt     proc    uses ds                 %@AB@%;Restore the old%@AE@%%@NL@%
            lds     dx, cs:OldVector        %@AB@%;interrupt vector%@AE@%%@NL@%
            mov     ax, 251CH               %@AB@%;so things will%@AE@%%@NL@%
            int     21h                     %@AB@%;keep working when%@AE@%%@NL@%
            ret                             %@AB@%;this BASIC program is%@AE@%%@NL@%
RestInt     endp                            %@AB@%;finished.%@AE@%%@NL@%
                        end%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TOKEN.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\TOKEN.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' TOKEN.BAS%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Demonstrates a BASIC version of the strtok C function.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
DECLARE FUNCTION StrTok$(Source$,Delimiters$)%@NL@%
%@NL@%
LINE INPUT "Enter string: ",P$%@NL@%
%@AB@%' Set up the characters that separate tokens.%@AE@%%@NL@%
Delimiters$=" ,;:().?"+CHR$(9)+CHR$(34)%@NL@%
%@AB@%' Invoke StrTok$ with the string to tokenize.%@AE@%%@NL@%
Token$=StrTok$(P$,Delimiters$)%@NL@%
WHILE Token$<>""%@NL@%
   PRINT Token$%@NL@%
%@AB@%   ' Call StrTok$ with a null string so it knows this%@AE@%%@NL@%
%@AB@%   ' isn't the first call.%@AE@%%@NL@%
   Token$=StrTok$("",Delimiters$)%@NL@%
WEND%@NL@%
%@NL@%
FUNCTION StrTok$(Srce$,Delim$)%@NL@%
STATIC Start%, SaveStr$%@NL@%
%@NL@%
%@AB@%   ' If first call, make a copy of the string.%@AE@%%@NL@%
   IF Srce$<>"" THEN%@NL@%
      Start%=1 : SaveStr$=Srce$%@NL@%
   END IF%@NL@%
%@NL@%
   BegPos%=Start% : Ln%=LEN(SaveStr$)%@NL@%
%@AB@%   ' Look for start of a token (character that isn't delimiter).%@AE@%%@NL@%
   WHILE BegPos%<=Ln% AND INSTR(Delim$,MID$(SaveStr$,BegPos%,1))<>0%@NL@%
      BegPos%=BegPos%+1%@NL@%
   WEND%@NL@%
%@AB@%   ' Test for token start found.%@AE@%%@NL@%
   IF BegPos% > Ln% THEN%@NL@%
      StrTok$="" : EXIT FUNCTION%@NL@%
   END IF%@NL@%
%@AB@%   ' Find the end of the token.%@AE@%%@NL@%
   EndPos%=BegPos%%@NL@%
   WHILE EndPos% <= Ln% AND INSTR(Delim$,MID$(SaveStr$,EndPos%,1))=0%@NL@%
      EndPos%=EndPos%+1%@NL@%
   WEND%@NL@%
   StrTok$=MID$(SaveStr$,BegPos%,EndPos%-BegPos%)%@NL@%
%@AB@%   ' Set starting point for search for next token.%@AE@%%@NL@%
   Start%=EndPos%%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TORUS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\TORUS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'                                TORUS%@AE@%%@NL@%
%@AB@%'   This program draws a Torus figure. The program accepts user input%@AE@%%@NL@%
%@AB@%'   to specify various TORUS parameters. It checks the current system%@AE@%%@NL@%
%@AB@%'   configuration and takes appropriate action to set the best possible%@AE@%%@NL@%
%@AB@%'   initial mode.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
DECLARE SUB GetConfig ()%@NL@%
DECLARE SUB SetPalette ()%@NL@%
DECLARE SUB TorusDefine ()%@NL@%
DECLARE SUB TorusCalc (T() AS ANY)%@NL@%
DECLARE SUB TorusColor (T() AS ANY)%@NL@%
DECLARE SUB TorusSort (Low, High)%@NL@%
DECLARE SUB TorusDraw (T() AS ANY, Index())%@NL@%
DECLARE SUB TileDraw (T AS ANY)%@NL@%
DECLARE SUB TorusRotate (First)%@NL@%
DECLARE SUB Delay (Seconds!)%@NL@%
DECLARE SUB CountTiles (T1, T2)%@NL@%
DECLARE SUB Message (Text$)%@NL@%
DECLARE SUB SetConfig (mode)%@NL@%
DECLARE FUNCTION Inside (T AS ANY)%@NL@%
DECLARE FUNCTION DegToRad! (Degrees)%@NL@%
DECLARE FUNCTION Rotated (Lower, Upper, Current, Inc)%@NL@%
%@NL@%
%@AB@%' General purpose constants%@AE@%%@NL@%
CONST PI = 3.14159%@NL@%
CONST TRUE = -1, FALSE = 0%@NL@%
CONST BACK = 0%@NL@%
CONST TROW = 24, TCOL = 60%@NL@%
%@NL@%
%@AB@%' Rotation flags%@AE@%%@NL@%
CONST RNDM = -1%@NL@%
CONST START = 0%@NL@%
CONST CONTINUE = 1%@NL@%
%@NL@%
%@AB@%' Constants for best available screen mode%@AE@%%@NL@%
CONST VGA = 12%@NL@%
CONST MCGA = 13%@NL@%
CONST EGA256 = 9%@NL@%
CONST EGA64 = 8%@NL@%
CONST MONO = 10%@NL@%
CONST HERC = 3%@NL@%
CONST CGA = 1%@NL@%
%@NL@%
%@AB@%' User-defined type for tiles - an array of these make a torus%@AE@%%@NL@%
TYPE Tile%@NL@%
   x1    AS SINGLE%@NL@%
   x2    AS SINGLE%@NL@%
   x3    AS SINGLE%@NL@%
   x4    AS SINGLE%@NL@%
   y1    AS SINGLE%@NL@%
   y2    AS SINGLE%@NL@%
   y3    AS SINGLE%@NL@%
   y4    AS SINGLE%@NL@%
   z1    AS SINGLE%@NL@%
   xc    AS SINGLE%@NL@%
   yc    AS SINGLE%@NL@%
   TColor AS INTEGER%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' User-defined type to hold information about the mode%@AE@%%@NL@%
TYPE Config%@NL@%
   Scrn     AS INTEGER%@NL@%
   Colors   AS INTEGER%@NL@%
   Atribs   AS INTEGER%@NL@%
   XPix     AS INTEGER%@NL@%
   YPix     AS INTEGER%@NL@%
   TCOL     AS INTEGER%@NL@%
   TROW     AS INTEGER%@NL@%
END TYPE%@NL@%
%@NL@%
DIM VC AS Config%@NL@%
%@NL@%
%@AB@%' User-defined type to hold information about current Torus%@AE@%%@NL@%
TYPE TORUS%@NL@%
   Panel    AS INTEGER%@NL@%
   Sect     AS INTEGER%@NL@%
   Thick    AS SINGLE%@NL@%
   XDegree  AS INTEGER%@NL@%
   YDegree  AS INTEGER%@NL@%
   Bord     AS STRING * 3%@NL@%
   Delay    AS SINGLE%@NL@%
END TYPE%@NL@%
%@NL@%
DIM TOR AS TORUS, Max AS INTEGER%@NL@%
%@NL@%
%@AB@%' A palette of colors to paint with%@AE@%%@NL@%
DIM Pal(0 TO 300) AS LONG%@NL@%
%@NL@%
%@AB@%' Error variables to check screen type%@AE@%%@NL@%
DIM InitRows AS INTEGER, BestMode AS INTEGER, Available AS STRING%@NL@%
%@NL@%
%@AB@%' The code of the module-level program begins here%@AE@%%@NL@%
%@NL@%
%@AB@%   ' Initialize defaults%@AE@%%@NL@%
   TOR.Thick = 3: TOR.Bord = "YES"%@NL@%
   TOR.Panel = 8: TOR.Sect = 14%@NL@%
   TOR.XDegree = 60: TOR.YDegree = 165%@NL@%
%@NL@%
%@AB@%   ' Get best configuration and set initial graphics mode to it%@AE@%%@NL@%
   GetConfig%@NL@%
   VC.Scrn = BestMode%@NL@%
%@NL@%
   DO WHILE TRUE           ' Loop forever (exit is from within a SUB)%@NL@%
%@NL@%
%@AB@%      ' Get Torus definition from user%@AE@%%@NL@%
      TorusDefine%@NL@%
%@NL@%
%@AB@%      ' Dynamically dimension arrays%@AE@%%@NL@%
      DO%@NL@%
         Tmp = TOR.Panel%@NL@%
         Max = TOR.Panel * TOR.Sect%@NL@%
%@NL@%
%@AB@%         ' Array for indexes%@AE@%%@NL@%
         REDIM Index(0 TO Max - 1) AS INTEGER%@NL@%
%@AB@%         ' Turn on error trap for insufficient memory%@AE@%%@NL@%
         ON ERROR GOTO MemErr%@NL@%
%@AB@%         ' Array for tiles%@AE@%%@NL@%
         REDIM T(0 TO Max - 1) AS Tile%@NL@%
         ON ERROR GOTO 0%@NL@%
      LOOP UNTIL Tmp = TOR.Panel%@NL@%
%@NL@%
%@AB@%      ' Initialize array of indexes%@AE@%%@NL@%
      FOR Til = 0 TO Max - 1%@NL@%
         Index(Til) = Til%@NL@%
      NEXT%@NL@%
%@NL@%
%@AB@%      ' Calculate the points of each tile on the torus%@AE@%%@NL@%
      Message "Calculating"%@NL@%
      TorusCalc T()%@NL@%
%@NL@%
%@AB@%      ' Color each tile in the torus.%@AE@%%@NL@%
      TorusColor T()%@NL@%
%@NL@%
%@AB@%      ' Sort the tiles by their "distance" from the screen%@AE@%%@NL@%
      Message "Sorting"%@NL@%
      TorusSort 0, Max - 1%@NL@%
%@NL@%
%@AB@%      ' Set the screen mode%@AE@%%@NL@%
      SCREEN VC.Scrn%@NL@%
%@NL@%
%@AB@%      ' Mix a palette of colors%@AE@%%@NL@%
      SetPalette%@NL@%
%@NL@%
%@AB@%      ' Set logical window with variable thickness%@AE@%%@NL@%
%@AB@%      ' Center is 0, up and right are positive, down and left are negative%@AE@%%@NL@%
      WINDOW (-(TOR.Thick + 1), -(TOR.Thick + 1))-(TOR.Thick + 1, TOR.Thick + 1)%@NL@%
%@NL@%
%@AB@%      ' Draw and paint the tiles, the farthest first and nearest last%@AE@%%@NL@%
      TorusDraw T(), Index()%@NL@%
%@NL@%
%@AB@%      ' Rotate the torus by rotating the color palette%@AE@%%@NL@%
      DO WHILE INKEY$ = ""%@NL@%
         Delay (TOR.Delay)%@NL@%
         TorusRotate CONTINUE%@NL@%
      LOOP%@NL@%
      SCREEN 0%@NL@%
      WIDTH 80%@NL@%
   LOOP%@NL@%
%@NL@%
%@AB@%   ' Restore original rows%@AE@%%@NL@%
   WIDTH 80, InitRows%@NL@%
%@NL@%
END%@NL@%
%@NL@%
%@AB@%' Error trap to make torus screen independent%@AE@%%@NL@%
VideoErr:%@NL@%
   SELECT CASE BestMode    ' Fall through until something works%@NL@%
      CASE VGA%@NL@%
         BestMode = MCGA%@NL@%
         Available = "12BD"%@NL@%
      CASE MCGA%@NL@%
         BestMode = EGA256%@NL@%
         Available = "12789"%@NL@%
      CASE EGA256%@NL@%
         BestMode = CGA%@NL@%
         Available = "12"%@NL@%
      CASE CGA%@NL@%
         BestMode = MONO%@NL@%
         Available = "A"%@NL@%
      CASE MONO%@NL@%
         BestMode = HERC%@NL@%
         Available = "3"%@NL@%
      CASE ELSE%@NL@%
         PRINT "Sorry. Graphics not available. Can't run Torus."%@NL@%
         END%@NL@%
   END SELECT%@NL@%
   RESUME%@NL@%
%@NL@%
%@AB@%' Trap to detect 64K EGA%@AE@%%@NL@%
EGAErr:%@NL@%
   BestMode = EGA64%@NL@%
   Available = "12789"%@NL@%
   RESUME NEXT%@NL@%
%@NL@%
%@AB@%' Trap to detect insufficient memory for large Torus%@AE@%%@NL@%
MemErr:%@NL@%
   LOCATE 22, 1%@NL@%
   PRINT "Out of memory"%@NL@%
   PRINT "Reducing panels from"; TOR.Panel; "to"; TOR.Panel - 1%@NL@%
   PRINT "Reducing sections from"; TOR.Sect; "to"; TOR.Sect - 1;%@NL@%
   DO WHILE INKEY$ = "": LOOP%@NL@%
   TOR.Panel = TOR.Panel - 1%@NL@%
   TOR.Sect = TOR.Sect - 1%@NL@%
   RESUME NEXT%@NL@%
%@NL@%
%@AB@%' Trap to determine initial number of rows so they can be restored%@AE@%%@NL@%
RowErr:%@NL@%
   IF InitRows = 50 THEN%@NL@%
      InitRows = 43%@NL@%
      RESUME%@NL@%
   ELSE%@NL@%
      InitRows = 25%@NL@%
      RESUME NEXT%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%' ============================ CountTiles ==============================%@AE@%%@NL@%
%@AB@%'   Displays number of the tiles currently being calculated or sorted.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB CountTiles (T1, T2) STATIC%@NL@%
%@NL@%
%@AB@%   ' Erase previous%@AE@%%@NL@%
   LOCATE TROW - 1, TCOL: PRINT SPACE$(19);%@NL@%
%@AB@%   ' If positive, display - give negative values to erase%@AE@%%@NL@%
   IF T1 > 0 AND T2 > 0 THEN%@NL@%
      LOCATE TROW - 1, TCOL%@NL@%
      PRINT "Tile ";%@NL@%
      PRINT USING " ###"; T1;%@NL@%
      PRINT USING " ###"; T2;%@NL@%
   END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%' ============================ DegToRad ================================%@AE@%%@NL@%
%@AB@%'   Convert degrees to radians, since BASIC trigonometric functions%@AE@%%@NL@%
%@AB@%'   require radians.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION DegToRad! (Degrees) STATIC%@NL@%
%@NL@%
   DegToRad! = (Degrees * 2 * PI) / 360%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%' =============================== Delay ================================%@AE@%%@NL@%
%@AB@%'   Delay based on time so that wait will be the same on any processor.%@AE@%%@NL@%
%@AB@%'   Notice the check for negative numbers so that the delay won't%@AE@%%@NL@%
%@AB@%'   freeze at midnight when the delay could become negative.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB Delay (Seconds!) STATIC%@NL@%
%@NL@%
   Begin! = TIMER%@NL@%
   DO UNTIL (TIMER - Begin! > Seconds!) OR (TIMER - Begin! < 0)%@NL@%
   LOOP%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%' ============================ GetConfig ===============================%@AE@%%@NL@%
%@AB@%'   Get the starting number of lines and the video adapter.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB GetConfig STATIC%@NL@%
SHARED InitRows AS INTEGER, BestMode AS INTEGER, Available AS STRING%@NL@%
%@NL@%
%@AB@%   ' Assume 50 line display and fall through error%@AE@%%@NL@%
%@AB@%   ' until we get the actual number%@AE@%%@NL@%
   InitRows = 50%@NL@%
   ON ERROR GOTO RowErr%@NL@%
   LOCATE InitRows, 1%@NL@%
%@NL@%
%@AB@%   ' Assume best possible screen mode%@AE@%%@NL@%
   BestMode = VGA%@NL@%
   Available = "12789BCD"%@NL@%
%@NL@%
   ON ERROR GOTO VideoErr%@NL@%
%@AB@%   ' Fall through error trap until a mode works%@AE@%%@NL@%
   SCREEN BestMode%@NL@%
%@AB@%   ' If EGA, then check pages to see whether more than 64K%@AE@%%@NL@%
   ON ERROR GOTO EGAErr%@NL@%
   IF BestMode = EGA256 THEN SCREEN 8, , 1%@NL@%
%@NL@%
   ON ERROR GOTO 0%@NL@%
%@NL@%
%@AB@%   ' Reset text mode%@AE@%%@NL@%
   SCREEN 0, , 0%@NL@%
   WIDTH 80, 25%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%' ============================== Inside ================================%@AE@%%@NL@%
%@AB@%'   Finds a point, T.xc and T.yc, that is mathematically within a tile.%@AE@%%@NL@%
%@AB@%'   Then check to see if the point is actually inside. Because of the%@AE@%%@NL@%
%@AB@%'   jagged edges of tiles, the center point is often actually inside%@AE@%%@NL@%
%@AB@%'   very thin tiles. Such tiles will not be painted, This causes%@AE@%%@NL@%
%@AB@%'   imperfections that are often visible at the edge of the Torus.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   Return FALSE if a center point is not found inside a tile.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION Inside (T AS Tile) STATIC%@NL@%
SHARED VC AS Config%@NL@%
DIM Highest AS SINGLE, Lowest AS SINGLE%@NL@%
%@NL@%
   Border = VC.Atribs - 1%@NL@%
%@NL@%
%@AB@%   ' Find an inside point. Since some tiles are triangles, the%@AE@%%@NL@%
%@AB@%   ' diagonal center isn't good enough. Instead find the center%@AE@%%@NL@%
%@AB@%   ' by drawing a diagonal from the center of the outside to%@AE@%%@NL@%
%@AB@%   ' a bottom corner.%@AE@%%@NL@%
   T.xc = T.x2 + ((T.x3 + (T.x4 - T.x3) / 2 - T.x2) / 2)%@NL@%
   T.yc = T.y2 + ((T.y3 + (T.y4 - T.y3) / 2 - T.y2) / 2)%@NL@%
%@NL@%
%@AB@%   ' If we're on a border, no need to fill%@AE@%%@NL@%
   IF POINT(T.xc, T.yc) = Border THEN%@NL@%
      Inside = FALSE%@NL@%
      EXIT FUNCTION%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' Find highest and lowest Y on the tile%@AE@%%@NL@%
   Highest = T.y1%@NL@%
   Lowest = T.y1%@NL@%
   IF T.y2 > Highest THEN Highest = T.y2%@NL@%
   IF T.y2 < Lowest THEN Lowest = T.y2%@NL@%
   IF T.y3 > Highest THEN Highest = T.y3%@NL@%
   IF T.y3 < Lowest THEN Lowest = T.y3%@NL@%
   IF T.y4 > Highest THEN Highest = T.y4%@NL@%
   IF T.y4 < Lowest THEN Lowest = T.y4%@NL@%
%@NL@%
%@AB@%   ' Convert coordinates to pixels%@AE@%%@NL@%
   X = PMAP(T.xc, 0)%@NL@%
   YU = PMAP(T.yc, 1)%@NL@%
   YD = YU%@NL@%
   H = PMAP(Highest, 1)%@NL@%
   L = PMAP(Lowest, 1)%@NL@%
%@NL@%
%@AB@%   ' Search for top and bottom tile borders until we either find them%@AE@%%@NL@%
%@AB@%   ' both, or check beyond the highest and lowest points.%@AE@%%@NL@%
%@NL@%
   IsUp = FALSE%@NL@%
   IsDown = FALSE%@NL@%
%@NL@%
   DO%@NL@%
      YU = YU - 1%@NL@%
      YD = YD + 1%@NL@%
%@NL@%
%@AB@%      ' Search up%@AE@%%@NL@%
      IF NOT IsUp THEN%@NL@%
         IF POINT(T.xc, PMAP(YU, 3)) = Border THEN IsUp = TRUE%@NL@%
      END IF%@NL@%
%@NL@%
%@AB@%      ' Search down%@AE@%%@NL@%
      IF NOT IsDown THEN%@NL@%
         IF POINT(T.xc, PMAP(YD, 3)) = Border THEN IsDown = TRUE%@NL@%
      END IF%@NL@%
%@NL@%
%@AB@%      ' If top and bottom are found, we're inside%@AE@%%@NL@%
      IF IsUp AND IsDown THEN%@NL@%
         Inside = TRUE%@NL@%
         EXIT FUNCTION%@NL@%
      END IF%@NL@%
%@NL@%
   LOOP UNTIL (YD > L) AND (YU < H)%@NL@%
   Inside = FALSE%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%' ============================= Message ================================%@AE@%%@NL@%
%@AB@%'   Displays a status message followed by blinking dots.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB Message (Text$) STATIC%@NL@%
SHARED VC AS Config%@NL@%
%@NL@%
   LOCATE TROW, TCOL: PRINT SPACE$(19);%@NL@%
   LOCATE TROW, TCOL%@NL@%
   COLOR 7       ' White%@NL@%
   PRINT Text$;%@NL@%
   COLOR 23      ' Blink%@NL@%
   PRINT " . . .";%@NL@%
   COLOR 7       ' White%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%' ============================ Rotated =================================%@AE@%%@NL@%
%@AB@%'   Returns the Current value adjusted by Inc and rotated if necessary%@AE@%%@NL@%
%@AB@%'   so that it falls within the range of Lower and Upper.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION Rotated (Lower, Upper, Current, Inc)%@NL@%
%@NL@%
%@AB@%   ' Calculate the next value%@AE@%%@NL@%
   Current = Current + Inc%@NL@%
%@NL@%
%@AB@%   ' Handle special cases of rotating off top or bottom%@AE@%%@NL@%
   IF Current > Upper THEN Current = Lower%@NL@%
   IF Current < Lower THEN Current = Upper%@NL@%
   Rotated = Current%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%' ============================ SetConfig ===============================%@AE@%%@NL@%
%@AB@%'   Sets the correct values for each field of the VC variable. They%@AE@%%@NL@%
%@AB@%'   vary depending on Mode and on the current configuration.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB SetConfig (mode AS INTEGER) STATIC%@NL@%
SHARED VC AS Config, BestMode AS INTEGER%@NL@%
%@NL@%
   SELECT CASE mode%@NL@%
      CASE 1   ' Four-color graphics for CGA, EGA, VGA, and MCGA%@NL@%
         IF BestMode = CGA OR BestMode = MCGA THEN%@NL@%
            VC.Colors = 0%@NL@%
         ELSE%@NL@%
            VC.Colors = 16%@NL@%
         END IF%@NL@%
         VC.Atribs = 4%@NL@%
         VC.XPix = 319%@NL@%
         VC.YPix = 199%@NL@%
         VC.TCOL = 40%@NL@%
         VC.TROW = 25%@NL@%
      CASE 2   ' Two-color medium-res graphics for CGA, EGA, VGA, and MCGA%@NL@%
         IF BestMode = CGA OR BestMode = MCGA THEN%@NL@%
            VC.Colors = 0%@NL@%
         ELSE%@NL@%
            VC.Colors = 16%@NL@%
         END IF%@NL@%
         VC.Atribs = 2%@NL@%
         VC.XPix = 639%@NL@%
         VC.YPix = 199%@NL@%
         VC.TCOL = 80%@NL@%
         VC.TROW = 25%@NL@%
      CASE 3   ' Two-color high-res graphics for Hercules%@NL@%
         VC.Colors = 0%@NL@%
         VC.Atribs = 2%@NL@%
         VC.XPix = 720%@NL@%
         VC.YPix = 348%@NL@%
         VC.TCOL = 80%@NL@%
         VC.TROW = 25%@NL@%
      CASE 7   ' 16-color medium-res graphics for EGA and VGA%@NL@%
         VC.Colors = 16%@NL@%
         VC.Atribs = 16%@NL@%
         VC.XPix = 319%@NL@%
         VC.YPix = 199%@NL@%
         VC.TCOL = 40%@NL@%
         VC.TROW = 25%@NL@%
      CASE 8   ' 16-color high-res graphics for EGA and VGA%@NL@%
         VC.Colors = 16%@NL@%
         VC.Atribs = 16%@NL@%
         VC.XPix = 639%@NL@%
         VC.YPix = 199%@NL@%
         VC.TCOL = 80%@NL@%
         VC.TROW = 25%@NL@%
      CASE 9   ' 16- or 4-color very high-res graphics for EGA and VGA%@NL@%
         VC.Colors = 64%@NL@%
         IF BestMode = EGA64 THEN VC.Atribs = 4 ELSE VC.Atribs = 16%@NL@%
         VC.XPix = 639%@NL@%
         VC.YPix = 349%@NL@%
         VC.TCOL = 80%@NL@%
         VC.TROW = 25%@NL@%
      CASE 10  ' Two-color high-res graphics for EGA or VGA monochrome%@NL@%
         VC.Colors = 0%@NL@%
         VC.Atribs = 2%@NL@%
         VC.XPix = 319%@NL@%
         VC.YPix = 199%@NL@%
         VC.TCOL = 80%@NL@%
         VC.TROW = 25%@NL@%
      CASE 11  ' Two-color very high-res graphics for VGA and MCGA%@NL@%
%@AB@%         ' Note that for VGA screens 11, 12, and 13, more colors are%@AE@%%@NL@%
%@AB@%         ' available, depending on how the colors are mixed.%@AE@%%@NL@%
         VC.Colors = 216%@NL@%
         VC.Atribs = 2%@NL@%
         VC.XPix = 639%@NL@%
         VC.YPix = 479%@NL@%
         VC.TCOL = 80%@NL@%
         VC.TROW = 30%@NL@%
      CASE 12  ' 16-color very high-res graphics for VGA%@NL@%
         VC.Colors = 216%@NL@%
         VC.Atribs = 16%@NL@%
         VC.XPix = 639%@NL@%
         VC.YPix = 479%@NL@%
         VC.TCOL = 80%@NL@%
         VC.TROW = 30%@NL@%
      CASE 13  ' 256-color medium-res graphics for VGA and MCGA%@NL@%
         VC.Colors = 216%@NL@%
         VC.Atribs = 256%@NL@%
         VC.XPix = 639%@NL@%
         VC.YPix = 479%@NL@%
         VC.TCOL = 40%@NL@%
         VC.TROW = 25%@NL@%
      CASE ELSE%@NL@%
         VC.Colors = 16%@NL@%
         VC.Atribs = 16%@NL@%
         VC.XPix = 0%@NL@%
         VC.YPix = 0%@NL@%
         VC.TCOL = 80%@NL@%
         VC.TROW = 25%@NL@%
         VC.Scrn = 0%@NL@%
         EXIT SUB%@NL@%
   END SELECT%@NL@%
   VC.Scrn = mode%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%' ============================ SetPalette ==============================%@AE@%%@NL@%
%@AB@%'   Mixes palette colors in an array.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB SetPalette STATIC%@NL@%
SHARED VC AS Config, Pal() AS LONG%@NL@%
%@NL@%
%@AB@%   ' Mix only if the adapter supports color attributes%@AE@%%@NL@%
   IF VC.Colors THEN%@NL@%
      SELECT CASE VC.Scrn%@NL@%
         CASE 1, 2, 7, 8%@NL@%
%@AB@%            ' Red, green, blue, and intense in four bits of a byte%@AE@%%@NL@%
%@AB@%            ' Bits: 0000irgb%@AE@%%@NL@%
%@AB@%            ' Change the order of FOR loops to change color mix%@AE@%%@NL@%
            Index = 0%@NL@%
            FOR Bs = 0 TO 1%@NL@%
               FOR Gs = 0 TO 1%@NL@%
                  FOR Rs = 0 TO 1%@NL@%
                     FOR Hs = 0 TO 1%@NL@%
                        Pal(Index) = Hs * 8 + Rs * 4 + Gs * 2 + Bs%@NL@%
                        Index = Index + 1%@NL@%
                     NEXT%@NL@%
                  NEXT%@NL@%
               NEXT%@NL@%
            NEXT%@NL@%
         CASE 9%@NL@%
%@AB@%            ' EGA red, green, and blue colors in 6 bits of a byte%@AE@%%@NL@%
%@AB@%            ' Capital letters repesent intense, lowercase normal%@AE@%%@NL@%
%@AB@%            ' Bits:  00rgbRGB%@AE@%%@NL@%
%@AB@%            ' Change the order of FOR loops to change color mix%@AE@%%@NL@%
            Index = 0%@NL@%
            FOR Bs = 0 TO 1%@NL@%
               FOR Gs = 0 TO 1%@NL@%
                  FOR Rs = 0 TO 1%@NL@%
                     FOR HRs = 0 TO 1%@NL@%
                        FOR HGs = 0 TO 1%@NL@%
                           FOR HBs = 0 TO 1%@NL@%
                              Pal(Index) = Rs * 32 + Gs * 16 + Bs * 8 + HRs * 4 + HGs * 2 + HBs%@NL@%
                              Index = Index + 1%@NL@%
                           NEXT%@NL@%
                        NEXT%@NL@%
                     NEXT%@NL@%
                  NEXT%@NL@%
               NEXT%@NL@%
            NEXT%@NL@%
         CASE 11, 12, 13%@NL@%
%@AB@%            ' VGA colors in 6 bits of 3 bytes of a long integer%@AE@%%@NL@%
%@AB@%            ' Bits:  000000000 00bbbbbb 00gggggg 00rrrrrr%@AE@%%@NL@%
%@AB@%            ' Change the order of FOR loops to change color mix%@AE@%%@NL@%
%@AB@%            ' Decrease the STEP and increase VC.Colors to get more colors%@AE@%%@NL@%
            Index = 0%@NL@%
            FOR Rs = 0 TO 63 STEP 11%@NL@%
               FOR Bs = 0 TO 63 STEP 11%@NL@%
                  FOR Gs = 0 TO 63 STEP 11%@NL@%
                     Pal(Index) = (65536 * Bs) + (256 * Gs) + Rs%@NL@%
                     Index = Index + 1%@NL@%
                  NEXT%@NL@%
               NEXT%@NL@%
            NEXT%@NL@%
         CASE ELSE%@NL@%
      END SELECT%@NL@%
%@AB@%      ' Assign colors%@AE@%%@NL@%
      IF VC.Atribs > 2 THEN TorusRotate RNDM%@NL@%
   END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%' ============================ TileDraw ================================%@AE@%%@NL@%
%@AB@%'   Draw and optionally paint a tile. Tiles are painted if there are%@AE@%%@NL@%
%@AB@%'   more than two atributes and if the inside of the tile can be found.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB TileDraw (T AS Tile) STATIC%@NL@%
SHARED VC AS Config, TOR AS TORUS%@NL@%
%@NL@%
%@AB@%   'Set border%@AE@%%@NL@%
   Border = VC.Atribs - 1%@NL@%
%@NL@%
   IF VC.Atribs = 2 THEN%@NL@%
%@AB@%      ' Draw and quit for two-color modes%@AE@%%@NL@%
      LINE (T.x1, T.y1)-(T.x2, T.y2), T.TColor%@NL@%
      LINE -(T.x3, T.y3), T.TColor%@NL@%
      LINE -(T.x4, T.y4), T.TColor%@NL@%
      LINE -(T.x1, T.y1), T.TColor%@NL@%
      EXIT SUB%@NL@%
   ELSE%@NL@%
%@AB@%      ' For other modes, draw in the border color%@AE@%%@NL@%
%@AB@%      ' (which must be different than any tile color)%@AE@%%@NL@%
      LINE (T.x1, T.y1)-(T.x2, T.y2), Border%@NL@%
      LINE -(T.x3, T.y3), Border%@NL@%
      LINE -(T.x4, T.y4), Border%@NL@%
      LINE -(T.x1, T.y1), Border%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' See if tile is large enough to be painted%@AE@%%@NL@%
   IF Inside(T) THEN%@NL@%
%@AB@%      'Black out the center to make sure it isn't paint color%@AE@%%@NL@%
      PRESET (T.xc, T.yc)%@NL@%
%@AB@%      ' Paint tile black so colors of underlying tiles can't interfere%@AE@%%@NL@%
      PAINT STEP(0, 0), BACK, Border%@NL@%
%@AB@%      ' Fill with the final tile color.%@AE@%%@NL@%
      PAINT STEP(0, 0), T.TColor, Border%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' A border drawn with the background color looks like a border.%@AE@%%@NL@%
%@AB@%   ' One drawn with the tile color doesn't look like a border.%@AE@%%@NL@%
   IF TOR.Bord = "YES" THEN%@NL@%
      Border = BACK%@NL@%
   ELSE%@NL@%
      Border = T.TColor%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' Redraw with the final border%@AE@%%@NL@%
   LINE (T.x1, T.y1)-(T.x2, T.y2), Border%@NL@%
   LINE -(T.x3, T.y3), Border%@NL@%
   LINE -(T.x4, T.y4), Border%@NL@%
   LINE -(T.x1, T.y1), Border%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
DEFSNG A-Z%@NL@%
%@AB@%' =========================== TorusCalc ================================%@AE@%%@NL@%
%@AB@%'   Calculates the x and y coordinates for each tile.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB TorusCalc (T() AS Tile) STATIC%@NL@%
SHARED TOR AS TORUS, Max AS INTEGER%@NL@%
DIM XSect AS INTEGER, YPanel AS INTEGER%@NL@%
%@NL@%
%@AB@%   ' Calculate sine and cosine of the angles of rotation%@AE@%%@NL@%
   XRot = DegToRad(TOR.XDegree)%@NL@%
   YRot = DegToRad(TOR.YDegree)%@NL@%
   CXRot = COS(XRot)%@NL@%
   SXRot = SIN(XRot)%@NL@%
   CYRot = COS(YRot)%@NL@%
   SYRot = SIN(YRot)%@NL@%
%@NL@%
%@AB@%   ' Calculate the angle to increment between one tile and the next.%@AE@%%@NL@%
   XInc = 2 * PI / TOR.Sect%@NL@%
   YInc = 2 * PI / TOR.Panel%@NL@%
%@NL@%
%@AB@%   ' First calculate the first point, which will be used as a reference%@AE@%%@NL@%
%@AB@%   ' for future points. This point must be calculated separately because%@AE@%%@NL@%
%@AB@%   ' it is both the beginning and the end of the center seam.%@AE@%%@NL@%
   FirstY = (TOR.Thick + 1) * CYRot%@NL@%
%@NL@%
%@AB@%   ' Starting point is x1 of 0 section, 0 panel     last     0%@AE@%%@NL@%
   T(0).x1 = FirstY                             ' +------+------+%@NL@%
%@AB@%   ' Also x2 of tile on last section, 0 panel   ' |      |      | last%@AE@%%@NL@%
   T(TOR.Sect - 1).x2 = FirstY                  ' |    x3|x4    |%@NL@%
%@AB@%   ' Also x3 of last section, last panel        ' +------+------+%@AE@%%@NL@%
   T(Max - 1).x3 = FirstY                       ' |    x2|x1    |  0%@NL@%
%@AB@%   ' Also x4 of 0 section, last panel           ' |      |      |%@AE@%%@NL@%
   T(Max - TOR.Sect).x4 = FirstY                ' +------+------+%@NL@%
%@AB@%   ' A similar pattern is used for assigning all points of Torus%@AE@%%@NL@%
%@NL@%
%@AB@%   ' Starting Y point is 0 (center)%@AE@%%@NL@%
   T(0).y1 = 0%@NL@%
   T(TOR.Sect - 1).y2 = 0%@NL@%
   T(Max - 1).y3 = 0%@NL@%
   T(Max - TOR.Sect).y4 = 0%@NL@%
%@NL@%
%@AB@%   ' Only one z coordinate is used in sort, so other three can be ignored%@AE@%%@NL@%
   T(0).z1 = -(TOR.Thick + 1) * SYRot%@NL@%
%@NL@%
%@AB@%   ' Starting at first point, work around the center seam of the Torus.%@AE@%%@NL@%
%@AB@%   ' Assign points for each section. The seam must be calculated separately%@AE@%%@NL@%
%@AB@%   ' because it is both beginning and of each section.%@AE@%%@NL@%
   FOR XSect = 1 TO TOR.Sect - 1%@NL@%
%@NL@%
%@AB@%      ' X, Y, and Z elements of equation%@AE@%%@NL@%
      sx = (TOR.Thick + 1) * COS(XSect * XInc)%@NL@%
      sy = (TOR.Thick + 1) * SIN(XSect * XInc) * CXRot%@NL@%
      sz = (TOR.Thick + 1) * SIN(XSect * XInc) * SXRot%@NL@%
      ssx = (sz * SYRot) + (sx * CYRot)%@NL@%
%@NL@%
      T(XSect).x1 = ssx%@NL@%
      T(XSect - 1).x2 = ssx%@NL@%
      T(Max - TOR.Sect + XSect - 1).x3 = ssx%@NL@%
      T(Max - TOR.Sect + XSect).x4 = ssx%@NL@%
%@NL@%
      T(XSect).y1 = sy%@NL@%
      T(XSect - 1).y2 = sy%@NL@%
      T(Max - TOR.Sect + XSect - 1).y3 = sy%@NL@%
      T(Max - TOR.Sect + XSect).y4 = sy%@NL@%
%@NL@%
      T(XSect).z1 = (sz * CYRot) - (sx * SYRot)%@NL@%
   NEXT%@NL@%
%@NL@%
%@AB@%   ' Now start at the first seam between panel and assign points for%@AE@%%@NL@%
%@AB@%   ' each section of each panel. The outer loop assigns the initial%@AE@%%@NL@%
%@AB@%   ' point for the panel. This point must be calculated separately%@AE@%%@NL@%
%@AB@%   ' since it is both the beginning and the end of the seam of panels.%@AE@%%@NL@%
   FOR YPanel = 1 TO TOR.Panel - 1%@NL@%
%@NL@%
%@AB@%      ' X, Y, and Z elements of equation%@AE@%%@NL@%
      sx = TOR.Thick + COS(YPanel * YInc)%@NL@%
      sy = -SIN(YPanel * YInc) * SXRot%@NL@%
      sz = SIN(YPanel * YInc) * CXRot%@NL@%
      ssx = (sz * SYRot) + (sx * CYRot)%@NL@%
%@NL@%
%@AB@%      ' Assign X points for each panel%@AE@%%@NL@%
%@AB@%      ' Current ring, current side%@AE@%%@NL@%
      T(TOR.Sect * YPanel).x1 = ssx%@NL@%
%@AB@%      ' Current ring minus 1, next side%@AE@%%@NL@%
      T(TOR.Sect * (YPanel + 1) - 1).x2 = ssx%@NL@%
%@AB@%      ' Current ring minus 1, previous side%@AE@%%@NL@%
      T(TOR.Sect * YPanel - 1).x3 = ssx%@NL@%
%@AB@%      ' Current ring, previous side%@AE@%%@NL@%
      T(TOR.Sect * (YPanel - 1)).x4 = ssx%@NL@%
%@NL@%
%@AB@%      ' Assign Y points for each panel%@AE@%%@NL@%
      T(TOR.Sect * YPanel).y1 = sy%@NL@%
      T(TOR.Sect * (YPanel + 1) - 1).y2 = sy%@NL@%
      T(TOR.Sect * YPanel - 1).y3 = sy%@NL@%
      T(TOR.Sect * (YPanel - 1)).y4 = sy%@NL@%
%@NL@%
%@AB@%      ' Z point for each panel%@AE@%%@NL@%
      T(TOR.Sect * YPanel).z1 = (sz * CYRot) - (sx * SYRot)%@NL@%
%@NL@%
%@AB@%      ' The inner loop assigns points for each ring (except the first)%@AE@%%@NL@%
%@AB@%      ' on the current side.%@AE@%%@NL@%
      FOR XSect = 1 TO TOR.Sect - 1%@NL@%
%@NL@%
%@AB@%         ' Display section and panel%@AE@%%@NL@%
         CountTiles XSect, YPanel%@NL@%
%@NL@%
         ty = (TOR.Thick + COS(YPanel * YInc)) * SIN(XSect * XInc)%@NL@%
         tz = SIN(YPanel * YInc)%@NL@%
         sx = (TOR.Thick + COS(YPanel * YInc)) * COS(XSect * XInc)%@NL@%
         sy = ty * CXRot - tz * SXRot%@NL@%
         sz = ty * SXRot + tz * CXRot%@NL@%
         ssx = (sz * SYRot) + (sx * CYRot)%@NL@%
%@NL@%
         T(TOR.Sect * YPanel + XSect).x1 = ssx%@NL@%
         T(TOR.Sect * YPanel + XSect - 1).x2 = ssx%@NL@%
         T(TOR.Sect * (YPanel - 1) + XSect - 1).x3 = ssx%@NL@%
         T(TOR.Sect * (YPanel - 1) + XSect).x4 = ssx%@NL@%
%@NL@%
         T(TOR.Sect * YPanel + XSect).y1 = sy%@NL@%
         T(TOR.Sect * YPanel + XSect - 1).y2 = sy%@NL@%
         T(TOR.Sect * (YPanel - 1) + XSect - 1).y3 = sy%@NL@%
         T(TOR.Sect * (YPanel - 1) + XSect).y4 = sy%@NL@%
%@NL@%
         T(TOR.Sect * YPanel + XSect).z1 = (sz * CYRot) - (sx * SYRot)%@NL@%
      NEXT%@NL@%
   NEXT%@NL@%
%@AB@%   ' Erase message%@AE@%%@NL@%
   CountTiles -1, -1%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@AB@%' =========================== TorusColor ===============================%@AE@%%@NL@%
%@AB@%'   Assigns color atributes to each tile.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB TorusColor (T() AS Tile) STATIC%@NL@%
SHARED VC AS Config, Max AS INTEGER%@NL@%
%@NL@%
%@AB@%   ' Skip first and last atributes%@AE@%%@NL@%
   LastAtr = VC.Atribs - 2%@NL@%
   Atr = 1%@NL@%
%@NL@%
%@AB@%   ' Cycle through each attribute until all tiles are done%@AE@%%@NL@%
   FOR Til = 0 TO Max - 1%@NL@%
      IF (Atr >= LastAtr) THEN%@NL@%
         Atr = 1%@NL@%
      ELSE%@NL@%
         Atr = Atr + 1%@NL@%
      END IF%@NL@%
      T(Til).TColor = Atr%@NL@%
   NEXT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%' ============================ TorusDefine =============================%@AE@%%@NL@%
%@AB@%'   Define the attributes of a Torus based on information from the%@AE@%%@NL@%
%@AB@%'   user, the video configuration, and the current screen mode.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB TorusDefine STATIC%@NL@%
SHARED VC AS Config, TOR AS TORUS, Available AS STRING%@NL@%
%@NL@%
%@AB@%' Constants for key codes and column positions%@AE@%%@NL@%
CONST ENTER = 13, ESCAPE = 27%@NL@%
CONST DOWNARROW = 80, UPARROW = 72, LEFTARROW = 75, RIGHTARROW = 77%@NL@%
CONST COL1 = 20, COL2 = 50, ROW = 9%@NL@%
%@NL@%
%@AB@%   ' Display key instructions%@AE@%%@NL@%
   LOCATE 1, COL1%@NL@%
   PRINT "UP .............. Move to next field"%@NL@%
   LOCATE 2, COL1%@NL@%
   PRINT "DOWN ........ Move to previous field"%@NL@%
   LOCATE 3, COL1%@NL@%
   PRINT "LEFT ......... Rotate field value up"%@NL@%
   LOCATE 4, COL1%@NL@%
   PRINT "RIGHT ...... Rotate field value down"%@NL@%
   LOCATE 5, COL1%@NL@%
   PRINT "ENTER .... Start with current values"%@NL@%
   LOCATE 6, COL1%@NL@%
   PRINT "ESCAPE .................. Quit Torus"%@NL@%
%@NL@%
%@AB@%   ' Block cursor%@AE@%%@NL@%
   LOCATE ROW, COL1, 1, 1, 12%@NL@%
%@AB@%   ' Display fields%@AE@%%@NL@%
   LOCATE ROW, COL1: PRINT "Thickness";%@NL@%
   LOCATE ROW, COL2: PRINT USING "[ # ]"; TOR.Thick;%@NL@%
%@NL@%
   LOCATE ROW + 2, COL1: PRINT "Panels per Section";%@NL@%
   LOCATE ROW + 2, COL2: PRINT USING "[ ## ]"; TOR.Panel;%@NL@%
%@NL@%
   LOCATE ROW + 4, COL1: PRINT "Sections per Torus";%@NL@%
   LOCATE ROW + 4, COL2: PRINT USING "[ ## ]"; TOR.Sect;%@NL@%
%@NL@%
   LOCATE ROW + 6, COL1: PRINT "Tilt around Horizontal Axis";%@NL@%
   LOCATE ROW + 6, COL2: PRINT USING "[ ### ]"; TOR.XDegree;%@NL@%
%@NL@%
   LOCATE ROW + 8, COL1: PRINT "Tilt around Vertical Axis";%@NL@%
   LOCATE ROW + 8, COL2: PRINT USING "[ ### ]"; TOR.YDegree;%@NL@%
%@NL@%
   LOCATE ROW + 10, COL1: PRINT "Tile Border";%@NL@%
   LOCATE ROW + 10, COL2: PRINT USING "[ & ] "; TOR.Bord;%@NL@%
%@NL@%
   LOCATE ROW + 12, COL1: PRINT "Screen Mode";%@NL@%
   LOCATE ROW + 12, COL2: PRINT USING "[ ## ]"; VC.Scrn%@NL@%
%@NL@%
%@AB@%   ' Skip field 10 if there's only one value%@AE@%%@NL@%
   IF LEN(Available$) = 1 THEN Fields = 10 ELSE Fields = 12%@NL@%
%@NL@%
%@AB@%   ' Update field values and position based on keystrokes%@AE@%%@NL@%
   DO%@NL@%
%@AB@%      ' Put cursor on field%@AE@%%@NL@%
      LOCATE ROW + Fld, COL2 + 2%@NL@%
%@AB@%      ' Get a key and strip null off if it's an extended code%@AE@%%@NL@%
      DO%@NL@%
         K$ = INKEY$%@NL@%
      LOOP WHILE K$ = ""%@NL@%
      Ky = ASC(RIGHT$(K$, 1))%@NL@%
%@NL@%
      SELECT CASE Ky%@NL@%
         CASE ESCAPE%@NL@%
%@AB@%            ' End program%@AE@%%@NL@%
            CLS : END%@NL@%
         CASE UPARROW, DOWNARROW%@NL@%
%@AB@%            ' Adjust field location%@AE@%%@NL@%
            IF Ky = DOWNARROW THEN Inc = 2 ELSE Inc = -2%@NL@%
            Fld = Rotated(0, Fields, Fld, Inc)%@NL@%
         CASE RIGHTARROW, LEFTARROW%@NL@%
%@AB@%            ' Adjust field%@AE@%%@NL@%
            IF Ky = RIGHTARROW THEN Inc = 1 ELSE Inc = -1%@NL@%
            SELECT CASE Fld%@NL@%
               CASE 0%@NL@%
%@AB@%                  ' Thickness%@AE@%%@NL@%
                  TOR.Thick = Rotated(1, 9, INT(TOR.Thick), Inc)%@NL@%
                  PRINT USING "#"; TOR.Thick%@NL@%
               CASE 2%@NL@%
%@AB@%                  ' Panels%@AE@%%@NL@%
                  TOR.Panel = Rotated(6, 20, TOR.Panel, Inc)%@NL@%
                  PRINT USING "##"; TOR.Panel%@NL@%
               CASE 4%@NL@%
%@AB@%                  ' Sections%@AE@%%@NL@%
                  TOR.Sect = Rotated(6, 20, TOR.Sect, Inc)%@NL@%
                  PRINT USING "##"; TOR.Sect%@NL@%
               CASE 6%@NL@%
%@AB@%                  ' Horizontal tilt%@AE@%%@NL@%
                  TOR.XDegree = Rotated(0, 345, TOR.XDegree, (15 * Inc))%@NL@%
                  PRINT USING "###"; TOR.XDegree%@NL@%
               CASE 8%@NL@%
%@AB@%                  ' Vertical tilt%@AE@%%@NL@%
                  TOR.YDegree = Rotated(0, 345, TOR.YDegree, (15 * Inc))%@NL@%
                  PRINT USING "###"; TOR.YDegree%@NL@%
               CASE 10%@NL@%
%@AB@%                  ' Border%@AE@%%@NL@%
                  IF VC.Atribs > 2 THEN%@NL@%
                     IF TOR.Bord = "YES" THEN%@NL@%
                        TOR.Bord = "NO"%@NL@%
                     ELSE%@NL@%
                        TOR.Bord = "YES"%@NL@%
                     END IF%@NL@%
                  END IF%@NL@%
                  PRINT TOR.Bord%@NL@%
               CASE 12%@NL@%
%@AB@%                  ' Available screen modes%@AE@%%@NL@%
                  I = INSTR(Available$, HEX$(VC.Scrn))%@NL@%
                  I = Rotated(1, LEN(Available$), I, Inc)%@NL@%
                  VC.Scrn = VAL("&h" + MID$(Available$, I, 1))%@NL@%
                  PRINT USING "##"; VC.Scrn%@NL@%
               CASE ELSE%@NL@%
            END SELECT%@NL@%
         CASE ELSE%@NL@%
      END SELECT%@NL@%
%@AB@%   ' Set configuration data for graphics mode%@AE@%%@NL@%
   SetConfig VC.Scrn%@NL@%
%@AB@%   ' Draw Torus if ENTER%@AE@%%@NL@%
   LOOP UNTIL Ky = ENTER%@NL@%
%@NL@%
%@AB@%   ' Remove cursor%@AE@%%@NL@%
   LOCATE 1, 1, 0%@NL@%
%@NL@%
%@AB@%   ' Set different delays depending on mode%@AE@%%@NL@%
   SELECT CASE VC.Scrn%@NL@%
      CASE 1%@NL@%
         TOR.Delay = .3%@NL@%
      CASE 2, 3, 10, 11, 13%@NL@%
         TOR.Delay = 0%@NL@%
      CASE ELSE%@NL@%
         TOR.Delay = .05%@NL@%
   END SELECT%@NL@%
%@NL@%
%@AB@%   ' Get new random seed for this torus%@AE@%%@NL@%
   RANDOMIZE TIMER%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%' =========================== TorusDraw ================================%@AE@%%@NL@%
%@AB@%'   Draws each tile of the torus starting with the farthest and working%@AE@%%@NL@%
%@AB@%'   to the closest. Thus nearer tiles overwrite farther tiles to give%@AE@%%@NL@%
%@AB@%'   a three-dimensional effect. Notice that the index of the tile being%@AE@%%@NL@%
%@AB@%'   drawn is actually the index of an array of indexes. This is because%@AE@%%@NL@%
%@AB@%'   the array of tiles is not sorted, but the parallel array of indexes%@AE@%%@NL@%
%@AB@%'   is. See TorusSort for an explanation of how indexes are sorted.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB TorusDraw (T() AS Tile, Index() AS INTEGER)%@NL@%
SHARED Max AS INTEGER%@NL@%
%@NL@%
   FOR Til = 0 TO Max - 1%@NL@%
      TileDraw T(Index(Til))%@NL@%
   NEXT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%' =========================== TorusRotate ==============================%@AE@%%@NL@%
%@AB@%'   Rotates the Torus. This can be done more successfully in some modes%@AE@%%@NL@%
%@AB@%'   than in others. There are three methods:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'     1. Rotate the palette colors assigned to each attribute%@AE@%%@NL@%
%@AB@%'     2. Draw, erase, and redraw the torus (two-color modes)%@AE@%%@NL@%
%@AB@%'     3. Rotate between two palettes (CGA and MCGA screen 1)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   Note that for EGA and VGA screen 2, methods 1 and 2 are both used.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB TorusRotate (First) STATIC%@NL@%
SHARED VC AS Config, TOR AS TORUS, Pal() AS LONG, Max AS INTEGER%@NL@%
SHARED T() AS Tile, Index() AS INTEGER, BestMode AS INTEGER%@NL@%
DIM Temp AS LONG%@NL@%
%@NL@%
%@AB@%   ' For EGA and higher rotate colors through palette%@AE@%%@NL@%
   IF VC.Colors THEN%@NL@%
%@NL@%
%@AB@%      ' Argument determines whether to start at next color, first color,%@AE@%%@NL@%
%@AB@%      ' or random color%@AE@%%@NL@%
      SELECT CASE First%@NL@%
         CASE RNDM%@NL@%
            FirstClr = INT(RND * VC.Colors)%@NL@%
         CASE START%@NL@%
            FirstClr = 0%@NL@%
         CASE ELSE%@NL@%
            FirstClr = FirstClr - 1%@NL@%
      END SELECT%@NL@%
%@NL@%
%@AB@%      ' Set last color to smaller of last possible color or last tile%@AE@%%@NL@%
      IF VC.Colors > Max - 1 THEN%@NL@%
         LastClr = Max - 1%@NL@%
      ELSE%@NL@%
         LastClr = VC.Colors - 1%@NL@%
      END IF%@NL@%
%@NL@%
%@AB@%      ' If color is too low, rotate to end%@AE@%%@NL@%
      IF FirstClr < 0 OR FirstClr >= LastClr THEN FirstClr = LastClr%@NL@%
%@NL@%
%@AB@%      ' Set last attribute%@AE@%%@NL@%
      IF VC.Atribs = 2 THEN%@NL@%
%@AB@%         ' Last for two-color modes%@AE@%%@NL@%
         LastAtr = VC.Atribs - 1%@NL@%
      ELSE%@NL@%
%@AB@%         ' Smaller of last color or next-to-last attribute%@AE@%%@NL@%
         IF LastClr < VC.Atribs - 2 THEN%@NL@%
            LastAtr = LastClr%@NL@%
         ELSE%@NL@%
            LastAtr = VC.Atribs - 2%@NL@%
         END IF%@NL@%
      END IF%@NL@%
%@NL@%
%@AB@%      ' Cycle through attributes, assigning colors%@AE@%%@NL@%
      Work = FirstClr%@NL@%
      FOR Atr = LastAtr TO 1 STEP -1%@NL@%
         PALETTE Atr, Pal(Work)%@NL@%
         Work = Work - 1%@NL@%
         IF Work < 0 THEN Work = LastClr%@NL@%
      NEXT%@NL@%
%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' For two-color screens, the best we can do is erase and redraw the torus%@AE@%%@NL@%
   IF VC.Atribs = 2 THEN%@NL@%
%@NL@%
%@AB@%      ' Set all tiles to color%@AE@%%@NL@%
      FOR I = 0 TO Max - 1%@NL@%
         T(I).TColor = Toggle%@NL@%
      NEXT%@NL@%
%@AB@%      ' Draw Torus%@AE@%%@NL@%
      TorusDraw T(), Index()%@NL@%
%@AB@%      ' Toggle between color and background%@AE@%%@NL@%
      Toggle = (Toggle + 1) MOD 2%@NL@%
%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' For CGA or MCGA screen 1, toggle palettes using the COLOR statement%@AE@%%@NL@%
%@AB@%   ' (these modes do not allow the PALETTE statement)%@AE@%%@NL@%
   IF VC.Scrn = 1 AND (BestMode = CGA OR BestMode = MCGA) THEN%@NL@%
      COLOR , Toggle%@NL@%
      Toggle = (Toggle + 1) MOD 2%@NL@%
      EXIT SUB%@NL@%
   END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%' ============================ TorusSort ===============================%@AE@%%@NL@%
%@AB@%'   Sorts the tiles of the Torus according to their Z axis (distance%@AE@%%@NL@%
%@AB@%'   from the "front" of the screen). When the tiles are drawn, the%@AE@%%@NL@%
%@AB@%'   farthest will be drawn first, and nearer tiles will overwrite them%@AE@%%@NL@%
%@AB@%'   to give a three-dimensional effect.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   To make sorting as fast as possible, the Quick Sort algorithm is%@AE@%%@NL@%
%@AB@%'   used. Also, the array of tiles is not actually sorted. Instead a%@AE@%%@NL@%
%@AB@%'   parallel array of tile indexes is sorted. This complicates things,%@AE@%%@NL@%
%@AB@%'   but makes the sort much faster, since two-byte integers are swapped%@AE@%%@NL@%
%@AB@%'   instead of 46-byte Tile variables.%@AE@%%@NL@%
%@AB@%' ======================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB TorusSort (Low, High)%@NL@%
SHARED T() AS Tile, Index() AS INTEGER%@NL@%
DIM Partition AS SINGLE%@NL@%
%@NL@%
   IF Low < High THEN%@NL@%
%@AB@%      ' If only one, compare and swap if necessary%@AE@%%@NL@%
%@AB@%      ' The SUB procedure only stops recursing when it reaches this point%@AE@%%@NL@%
      IF High - Low = 1 THEN%@NL@%
         IF T(Index(Low)).z1 > T(Index(High)).z1 THEN%@NL@%
            CountTiles High, Low%@NL@%
            SWAP Index(Low), Index(High)%@NL@%
         END IF%@NL@%
      ELSE%@NL@%
%@AB@%      ' If more than one, separate into two random groups%@AE@%%@NL@%
         RandIndex = INT(RND * (High - Low + 1)) + Low%@NL@%
         CountTiles High, Low%@NL@%
         SWAP Index(High), Index(RandIndex%)%@NL@%
         Partition = T(Index(High)).z1%@NL@%
%@AB@%         ' Sort one group%@AE@%%@NL@%
         DO%@NL@%
            I = Low: J = High%@NL@%
%@AB@%            ' Find the largest%@AE@%%@NL@%
            DO WHILE (I < J) AND (T(Index(I)).z1 <= Partition)%@NL@%
               I = I + 1%@NL@%
            LOOP%@NL@%
%@AB@%            ' Find the smallest%@AE@%%@NL@%
            DO WHILE (J > I) AND (T(Index(J)).z1 >= Partition)%@NL@%
               J = J - 1%@NL@%
            LOOP%@NL@%
%@AB@%            ' Swap them if necessary%@AE@%%@NL@%
            IF I < J THEN%@NL@%
               CountTiles High, Low%@NL@%
               SWAP Index(I), Index(J)%@NL@%
            END IF%@NL@%
         LOOP WHILE I < J%@NL@%
%@NL@%
%@AB@%         ' Now get the other group and recursively sort it%@AE@%%@NL@%
         CountTiles High, Low%@NL@%
         SWAP Index(I), Index(High)%@NL@%
         IF (I - Low) < (High - I) THEN%@NL@%
            TorusSort Low, I - 1%@NL@%
            TorusSort I + 1, High%@NL@%
         ELSE%@NL@%
            TorusSort I + 1, High%@NL@%
            TorusSort Low, I - 1%@NL@%
         END IF%@NL@%
      END IF%@NL@%
   END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%UIASM.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\UIASM.ASM%@AE@%%@NL@%
%@NL@%
%@AB@%;-----------------------------------------------------------------------------%@AE@%%@NL@%
%@AB@%;-----------------------------------------------------------------------------%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;  UIASM.ASM%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;  Copyright (C) 1989 Microsoft Corporation, All Rights Reserved%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;  GetCopyBox : Gets screen box info and places into string variable%@AE@%%@NL@%
%@AB@%;  PutCopyBox : Puts screen box info from string variable onto screen%@AE@%%@NL@%
%@AB@%;  AttrBox    : Changes the color attributes of all characters within a box%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;-----------------------------------------------------------------------------%@AE@%%@NL@%
%@AB@%;-----------------------------------------------------------------------------%@AE@%%@NL@%
%@NL@%
%@AB@%;NOTE: For optimum speed, these routines write directly to screen memory%@AE@%%@NL@%
%@AB@%;      without waiting for re-trace.  If "snow" is a problem, these routines%@AE@%%@NL@%
%@AB@%;      will need modification.%@AE@%%@NL@%
%@NL@%
.model medium%@NL@%
%@NL@%
        extrn   STRINGADDRESS:far       %@AB@%;BASIC RTL entry point for string info%@AE@%%@NL@%
%@NL@%
.data%@NL@%
%@NL@%
attr    db      ?                       %@AB@%;destination attribute (AttrBox)%@AE@%%@NL@%
x0      db      ?                       %@AB@%;x coord of upper-left%@AE@%%@NL@%
y0      db      ?                       %@AB@%;y coord of upper-left%@AE@%%@NL@%
x1      db      ?                       %@AB@%;x coord of lower-right%@AE@%%@NL@%
y1      db      ?                       %@AB@%;y coord of lower-right%@AE@%%@NL@%
bwidth  db      ?                       %@AB@%;box width%@AE@%%@NL@%
height  db      ?                       %@AB@%;box height%@AE@%%@NL@%
strdoff dw      ?                       %@AB@%;string pointer offset%@AE@%%@NL@%
strdseg dw      ?                       %@AB@%;string pointer segment%@AE@%%@NL@%
scrseg  dw      ?                       %@AB@%;screen segment%@AE@%%@NL@%
movword dw      ?                       %@AB@%;word count to move/change%@AE@%%@NL@%
%@NL@%
.code%@NL@%
%@NL@%
%@AB@%;---------------------------------------place segment of screen memory%@AE@%%@NL@%
%@AB@%;---------------------------------------in SCRSEG%@AE@%%@NL@%
get_scrseg      proc%@NL@%
%@NL@%
        push    ax                      %@AB@%;save value of AX%@AE@%%@NL@%
        mov     ah,0Fh%@NL@%
        int     10h                     %@AB@%;INT 10H fn. 0Fh - Get Video Mode%@AE@%%@NL@%
        mov     dgroup:scrseg,0B800h    %@AB@%;assume COLOR screen for now%@AE@%%@NL@%
        cmp     al,07h                  %@AB@%;is it MONOCHROME mode?%@AE@%%@NL@%
        jne     arnd1%@NL@%
        mov     dgroup:scrseg,0B000h    %@AB@%;yes, set for mono screen seg%@AE@%%@NL@%
arnd1:  pop     ax                      %@AB@%;restore AX%@AE@%%@NL@%
        ret                             %@AB@%;and exit%@AE@%%@NL@%
%@NL@%
get_scrseg      endp%@NL@%
%@NL@%
%@NL@%
%@AB@%;----------------------------------------Given X and Y in AH and AL, find%@AE@%%@NL@%
%@AB@%;----------------------------------------the offset into screen memory and%@AE@%%@NL@%
%@AB@%;----------------------------------------return in AX%@AE@%%@NL@%
get_memxy       proc%@NL@%
%@NL@%
        push    dx                      %@AB@%;save DX%@AE@%%@NL@%
        push    ax                      %@AB@%;save coords%@AE@%%@NL@%
        mov     dl,160%@NL@%
        mul     dl                      %@AB@%;multiply Y by 160%@AE@%%@NL@%
        pop     dx                      %@AB@%;put coords in DX%@AE@%%@NL@%
        mov     dl,dh%@NL@%
        mov     dh,0%@NL@%
        add     dl,dl                   %@AB@%;double X%@AE@%%@NL@%
        add     ax,dx                   %@AB@%;and add to mult. result for final!%@AE@%%@NL@%
        pop     dx                      %@AB@%;restore DX%@AE@%%@NL@%
        ret%@NL@%
%@NL@%
get_memxy       endp%@NL@%
%@NL@%
%@NL@%
%@AB@%;-----------------------------------------------------------------------------%@AE@%%@NL@%
%@AB@%;----------------------------------------This is the routine that copies%@AE@%%@NL@%
%@AB@%;----------------------------------------screen info to the string variable%@AE@%%@NL@%
%@AB@%;-----------------------------------------------------------------------------%@AE@%%@NL@%
        public  getcopybox%@NL@%
getcopybox      proc    far%@NL@%
%@NL@%
        push    bp%@NL@%
        mov     bp,sp%@NL@%
        push    ds%@NL@%
        push    es%@NL@%
        push    si%@NL@%
        push    di                      %@AB@%;preserve registers%@AE@%%@NL@%
%@NL@%
get_start:%@NL@%
        mov     bx,[bp + 14]            %@AB@%;get y0%@AE@%%@NL@%
        mov     ax,[bx]%@NL@%
        mov     y0,al%@NL@%
        mov     bx,[bp + 12]            %@AB@%;...x0%@AE@%%@NL@%
        mov     ax,[bx]%@NL@%
        mov     x0,al%@NL@%
        mov     bx,[bp + 10]            %@AB@%;...y1%@AE@%%@NL@%
        mov     ax,[bx]%@NL@%
        mov     y1,al%@NL@%
        mov     bx,[bp + 8]             %@AB@%;...x1%@AE@%%@NL@%
        mov     ax,[bx]%@NL@%
        mov     x1,al%@NL@%
        mov     bx,[bp + 6]             %@AB@%;...and the destination str desc.%@AE@%%@NL@%
%@NL@%
        push    bx%@NL@%
        call    STRINGADDRESS           %@AB@%;for both near and far string support%@AE@%%@NL@%
        mov     strdoff, ax%@NL@%
        mov     strdseg, dx%@NL@%
%@NL@%
        dec     x0                      %@AB@%;subtract 1 from%@AE@%%@NL@%
        dec     y0                      %@AB@%;all coordinates%@AE@%%@NL@%
        dec     x1                      %@AB@%;to reflect BASIC's%@AE@%%@NL@%
        dec     y1                      %@AB@%;screen base of 1 (not 0)%@AE@%%@NL@%
%@NL@%
get_chkscr:%@NL@%
        call    get_scrseg              %@AB@%;set up screen segment%@AE@%%@NL@%
%@NL@%
get_setstr:%@NL@%
        mov     al,x1%@NL@%
        sub     al,x0                   %@AB@%;find width of box%@AE@%%@NL@%
        mov     bwidth,al               %@AB@%;and save%@AE@%%@NL@%
        add     al,1                    %@AB@%;add one to width%@AE@%%@NL@%
        mov     ah,0                    %@AB@%;to find # words to move%@AE@%%@NL@%
        mov     movword,ax              %@AB@%;MovWord = (width+1)%@AE@%%@NL@%
        mov     al,y1%@NL@%
        sub     al,y0                   %@AB@%;find height of box%@AE@%%@NL@%
        mov     height,al               %@AB@%;and save%@AE@%%@NL@%
        mov     es,strdseg%@NL@%
        mov     di,strdoff              %@AB@%;string is the destination%@AE@%%@NL@%
        mov     si,offset bwidth        %@AB@%;point to width%@AE@%%@NL@%
        movsb                           %@AB@%;put width in string%@AE@%%@NL@%
        mov     si,offset height%@NL@%
        movsb                           %@AB@%;and the height, too%@AE@%%@NL@%
%@NL@%
get_movstr:%@NL@%
        mov     al,y0%@NL@%
        mov     ah,x0                   %@AB@%;put coords in AH and AL%@AE@%%@NL@%
        call    get_memxy               %@AB@%;and find offset into screen mem%@AE@%%@NL@%
        mov     si,ax                   %@AB@%;this will be the source%@AE@%%@NL@%
%@NL@%
get_domove:%@NL@%
        mov     cx,movword%@NL@%
        push    ds%@NL@%
        mov     ds,scrseg%@NL@%
        rep     movsw                   %@AB@%;move a row into the string%@AE@%%@NL@%
        pop     ds%@NL@%
        add     si,160%@NL@%
        sub     si,movword              %@AB@%;Add 160-(movword*2) to si%@AE@%%@NL@%
        sub     si,movword              %@AB@%;to point to next row%@AE@%%@NL@%
        cmp     height,0                %@AB@%;was that the last row?%@AE@%%@NL@%
        je      get_done                %@AB@%;yes, we're done%@AE@%%@NL@%
        dec     height                  %@AB@%;decrement height%@AE@%%@NL@%
        jmp     get_domove              %@AB@%;and do another row%@AE@%%@NL@%
%@NL@%
get_done:%@NL@%
        pop     di%@NL@%
        pop     si%@NL@%
        pop     es%@NL@%
        pop     ds                      %@AB@%;restore registers%@AE@%%@NL@%
        pop     bp%@NL@%
        ret     10                      %@AB@%;there were 5 parameters%@AE@%%@NL@%
%@NL@%
getcopybox      endp%@NL@%
%@NL@%
%@NL@%
%@AB@%;-----------------------------------------------------------------------------%@AE@%%@NL@%
%@AB@%;----------------------------------------This is the routine that copies the%@AE@%%@NL@%
%@AB@%;----------------------------------------information stored in the string to%@AE@%%@NL@%
%@AB@%;----------------------------------------the screen in the specified location%@AE@%%@NL@%
%@AB@%;-----------------------------------------------------------------------------%@AE@%%@NL@%
        public  putcopybox%@NL@%
putcopybox      proc    far%@NL@%
%@NL@%
        push    bp%@NL@%
        mov     bp,sp%@NL@%
        push    ds%@NL@%
        push    es%@NL@%
        push    si%@NL@%
        push    di                      %@AB@%;preserve registers%@AE@%%@NL@%
%@NL@%
%@NL@%
put_start:%@NL@%
        mov     bx,[bp + 10]            %@AB@%;get y0%@AE@%%@NL@%
        mov     ax,[bx]%@NL@%
        mov     y0,al%@NL@%
        mov     bx,[bp + 8]             %@AB@%;...x0%@AE@%%@NL@%
        mov     ax,[bx]%@NL@%
        mov     x0,al%@NL@%
        mov     bx,[bp + 6]             %@AB@%;...and the destination string%@AE@%%@NL@%
%@NL@%
        push    bx%@NL@%
        call    STRINGADDRESS           %@AB@%;for both near and far string support%@AE@%%@NL@%
        mov     strdoff, ax%@NL@%
        mov     strdseg, dx%@NL@%
%@NL@%
        dec     x0                      %@AB@%;subtract 1 from%@AE@%%@NL@%
        dec     y0                      %@AB@%;all coordinates%@AE@%%@NL@%
%@NL@%
put_chkscr:%@NL@%
        call    get_scrseg              %@AB@%;set up scrseg%@AE@%%@NL@%
%@NL@%
put_setstr:%@NL@%
        push    ds%@NL@%
        pop     es                      %@AB@%;equate ES to DS%@AE@%%@NL@%
%@NL@%
        mov     si,strdoff              %@AB@%;point DS:SI to string mem%@AE@%%@NL@%
        push    ds%@NL@%
        mov     ds,strdseg%@NL@%
        mov     di,offset bwidth%@NL@%
        movsb                           %@AB@%;get width%@AE@%%@NL@%
        mov     di,offset height%@NL@%
        movsb                           %@AB@%;and height out of string%@AE@%%@NL@%
        pop     ds%@NL@%
%@NL@%
        mov     al,bwidth%@NL@%
        add     al,1%@NL@%
        mov     ah,0%@NL@%
        mov     movword,ax              %@AB@%;set movword to (bwidth+1)%@AE@%%@NL@%
%@NL@%
        mov     ah,x0%@NL@%
        mov     al,y0                   %@AB@%;get coords%@AE@%%@NL@%
        call    get_memxy               %@AB@%;and find offset into screen mem%@AE@%%@NL@%
        mov     di,ax%@NL@%
        mov     es,scrseg               %@AB@%;ES:DI -> screen mem (UL corner)%@AE@%%@NL@%
%@NL@%
put_domove:%@NL@%
        mov     cx,movword%@NL@%
        push    ds%@NL@%
        mov     ds,strdseg%@NL@%
        rep     movsw                   %@AB@%;move a row onto the screen%@AE@%%@NL@%
        pop     ds%@NL@%
        add     di,160%@NL@%
        sub     di,movword              %@AB@%;add 160-(movword*2) to DI%@AE@%%@NL@%
        sub     di,movword              %@AB@%;to point to next row on screen%@AE@%%@NL@%
        cmp     height,0                %@AB@%;was that the last row?%@AE@%%@NL@%
        je      put_done                %@AB@%;yes, we're finished%@AE@%%@NL@%
        dec     height%@NL@%
        jmp     put_domove              %@AB@%;no, decrement and do again%@AE@%%@NL@%
%@NL@%
put_done:%@NL@%
        pop     di%@NL@%
        pop     si%@NL@%
        pop     es%@NL@%
        pop     ds                      %@AB@%;restore registers%@AE@%%@NL@%
        pop     bp%@NL@%
        ret     6                       %@AB@%;pop off 3 parameters%@AE@%%@NL@%
%@NL@%
putcopybox      endp%@NL@%
%@NL@%
%@AB@%;-----------------------------------------------------------------------------%@AE@%%@NL@%
%@AB@%;----------------------------------------This is the routine that changes%@AE@%%@NL@%
%@AB@%;----------------------------------------the colors of the box's characters%@AE@%%@NL@%
%@AB@%;-----------------------------------------------------------------------------%@AE@%%@NL@%
        public  attrbox%@NL@%
attrbox         proc    far%@NL@%
%@NL@%
        push    bp%@NL@%
        mov     bp, sp%@NL@%
        push    ds%@NL@%
        push    es%@NL@%
        push    si%@NL@%
        push    di                      %@AB@%;preserve registers%@AE@%%@NL@%
%@NL@%
atr_start:%@NL@%
        mov     bx, [bp+14]             %@AB@%;get y0%@AE@%%@NL@%
        mov     ax, [bx]%@NL@%
        mov     y0, al%@NL@%
        mov     bx, [bp+12]             %@AB@%;...x0%@AE@%%@NL@%
        mov     ax, [bx]%@NL@%
        mov     x0, al%@NL@%
        mov     bx, [bp+10]             %@AB@%;...y1%@AE@%%@NL@%
        mov     ax, [bx]%@NL@%
        mov     y1, al%@NL@%
        mov     bx, [bp+8]              %@AB@%;...x1%@AE@%%@NL@%
        mov     ax, [bx]%@NL@%
        mov     x1, al%@NL@%
        mov     bx, [bp+6]              %@AB@%;...and finally the new color value%@AE@%%@NL@%
        mov     ax, [bx]%@NL@%
        mov     attr, al%@NL@%
%@NL@%
        dec     y0                      %@AB@%;subtract 1 from%@AE@%%@NL@%
        dec     x0                      %@AB@%;all coordinates%@AE@%%@NL@%
        dec     y1                      %@AB@%;to reflect BASIC's%@AE@%%@NL@%
        dec     x1                      %@AB@%;screen base of 1 (not 0)%@AE@%%@NL@%
%@NL@%
atr_chkscr:%@NL@%
        call    get_scrseg              %@AB@%;set up screen segment%@AE@%%@NL@%
%@NL@%
atr_setup:%@NL@%
        mov     al, x1%@NL@%
        sub     al, x0                  %@AB@%;find width of box%@AE@%%@NL@%
        inc     al%@NL@%
        xor     ah, ah%@NL@%
        mov     movword, ax             %@AB@%;(width + 1 = movword)%@AE@%%@NL@%
        mov     al, y1%@NL@%
        sub     al, y0                  %@AB@%;find height of box%@AE@%%@NL@%
        mov     height, al              %@AB@%;and save%@AE@%%@NL@%
%@NL@%
atr_chgclr:%@NL@%
        mov     al, y0%@NL@%
        mov     ah, x0                  %@AB@%;put coords in AH and AL%@AE@%%@NL@%
        call    get_memxy               %@AB@%;find offset into screen memory%@AE@%%@NL@%
        mov     di, ax                  %@AB@%;(which is our destination)%@AE@%%@NL@%
        mov     es, scrseg%@NL@%
        mov     al, attr                %@AB@%;get the color value to store%@AE@%%@NL@%
%@NL@%
atr_doit:%@NL@%
        mov     cx, movword%@NL@%
atr_loop:%@NL@%
        inc     di                      %@AB@%;skip the character value%@AE@%%@NL@%
        stosb                           %@AB@%;write new color value%@AE@%%@NL@%
        loop    atr_loop                %@AB@%;cx times%@AE@%%@NL@%
        add     di, 160                 %@AB@%;add 160-(movword*2) to di%@AE@%%@NL@%
        sub     di, movword%@NL@%
        sub     di, movword%@NL@%
        cmp     height, 0               %@AB@%;was that the last row?%@AE@%%@NL@%
        je      atr_done                %@AB@%;yes, we be finished%@AE@%%@NL@%
        dec     height                  %@AB@%;no, decrement height%@AE@%%@NL@%
        jmp     atr_doit%@NL@%
%@NL@%
atr_done:%@NL@%
        pop     di%@NL@%
        pop     si%@NL@%
        pop     es%@NL@%
        pop     ds%@NL@%
        pop     bp                      %@AB@%;restore registers%@AE@%%@NL@%
        ret     10                      %@AB@%;pull off 5 paramters and return%@AE@%%@NL@%
%@NL@%
attrbox         endp%@NL@%
%@NL@%
        END%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%UIDEMO.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\UIDEMO.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' UIDEMO.BAS Copyright (c) 1989 Microsoft Corporation%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Decls, includes, and dimensions%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
DEFINT A-Z%@NL@%
DECLARE SUB AboutDemo ()%@NL@%
DECLARE SUB AboutUIP ()%@NL@%
DECLARE SUB AboutMouse ()%@NL@%
DECLARE SUB AboutAccess ()%@NL@%
DECLARE SUB AboutQuick ()%@NL@%
DECLARE SUB AboutWindows ()%@NL@%
DECLARE SUB ColorDisplay ()%@NL@%
DECLARE SUB DemoAlert ()%@NL@%
DECLARE SUB DemoDialog ()%@NL@%
DECLARE SUB DemoDialogEZ ()%@NL@%
DECLARE SUB DemoFileNameListBox ()%@NL@%
DECLARE SUB DemoListBox ()%@NL@%
DECLARE SUB DemoWindow ()%@NL@%
DECLARE SUB DemoScrollBar ()%@NL@%
DECLARE SUB DemoResize ()%@NL@%
DECLARE SUB MonoDisplay ()%@NL@%
DECLARE SUB SetupDesktop ()%@NL@%
DECLARE SUB SetupMenu ()%@NL@%
DECLARE FUNCTION GetFileCount% (FileSpec$)%@NL@%
%@NL@%
%@AB@%'$INCLUDE: 'general.bi'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'mouse.bi'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'menu.bi'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'window.bi'%@AE@%%@NL@%
%@NL@%
COMMON SHARED /uitools/ GloMenu           AS MenuMiscType%@NL@%
COMMON SHARED /uitools/ GloTitle()        AS MenuTitleType%@NL@%
COMMON SHARED /uitools/ GloItem()         AS MenuItemType%@NL@%
COMMON SHARED /uitools/ GloWindow()       AS windowType%@NL@%
COMMON SHARED /uitools/ GloButton()       AS buttonType%@NL@%
COMMON SHARED /uitools/ GloEdit()         AS EditFieldType%@NL@%
COMMON SHARED /uitools/ GloStorage        AS WindowStorageType%@NL@%
COMMON SHARED /uitools/ GloWindowStack()  AS INTEGER%@NL@%
COMMON SHARED /uitools/ GloBuffer$()%@NL@%
%@NL@%
DIM GloTitle(MAXMENU)           AS MenuTitleType%@NL@%
DIM GloItem(MAXMENU, MAXITEM)   AS MenuItemType%@NL@%
DIM GloWindow(MAXWINDOW)        AS windowType%@NL@%
DIM GloButton(MAXBUTTON)        AS buttonType%@NL@%
DIM GloEdit(MAXEDITFIELD)       AS EditFieldType%@NL@%
DIM GloWindowStack(MAXWINDOW)   AS INTEGER%@NL@%
DIM GloBuffer$(MAXWINDOW + 1, 2)%@NL@%
%@NL@%
DIM SHARED DisplayType          AS INTEGER%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Initialize Demo%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    MenuInit%@NL@%
    WindowInit%@NL@%
    MouseShow%@NL@%
    MonoDisplay%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Show Opening alert window%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
%@NL@%
         a$ = "User Interface Toolbox Demo|"%@NL@%
    a$ = a$ + "for|"%@NL@%
    a$ = a$ + "Microsoft BASIC 7.0 Professional Development System|"%@NL@%
    a$ = a$ + "Copyright (c) 1989 Microsoft Corporation|"%@NL@%
%@NL@%
    x = Alert(4, a$, 9, 10, 14, 70, "Color", "Monochrome", "")%@NL@%
%@NL@%
    IF x = 1 THEN%@NL@%
        DisplayType = TRUE%@NL@%
        ColorDisplay%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Main Loop : Stay in loop until DemoFinished set to TRUE%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    DemoFinished = FALSE%@NL@%
%@NL@%
    WHILE NOT DemoFinished%@NL@%
        kbd$ = MenuInkey$%@NL@%
        WHILE MenuCheck(2)%@NL@%
            GOSUB MenuTrap%@NL@%
        WEND%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' End Program%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    MouseHide%@NL@%
    COLOR 15, 0%@NL@%
    CLS%@NL@%
    END%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' If a menu event occured, call the proper demo, or if Exit, set demoFinished%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
MenuTrap:%@NL@%
    menu = MenuCheck(0)%@NL@%
    item = MenuCheck(1)%@NL@%
%@NL@%
    SELECT CASE menu%@NL@%
        CASE 1%@NL@%
            SELECT CASE item%@NL@%
                CASE 1:  DemoAlert%@NL@%
                CASE 2:  DemoDialogEZ%@NL@%
                CASE 3:  DemoDialog%@NL@%
                CASE 4:  DemoListBox%@NL@%
                CASE 5:  DemoFileNameListBox%@NL@%
                CASE 6:  DemoScrollBar%@NL@%
                CASE 7:  DemoWindow%@NL@%
                CASE 8:  DemoResize%@NL@%
                CASE 10: DemoFinished = TRUE%@NL@%
            END SELECT%@NL@%
        CASE 2%@NL@%
            SELECT CASE item%@NL@%
                CASE 1: ColorDisplay%@NL@%
                CASE 2: MonoDisplay%@NL@%
%@NL@%
            END SELECT%@NL@%
        CASE 3%@NL@%
            SELECT CASE item%@NL@%
                CASE 1: AboutDemo%@NL@%
                CASE 2: AboutUIP%@NL@%
                CASE 3: AboutWindows%@NL@%
                CASE 4: AboutMouse%@NL@%
                CASE 5: AboutAccess%@NL@%
                CASE 6: AboutQuick%@NL@%
            END SELECT%@NL@%
        CASE ELSE%@NL@%
    END SELECT%@NL@%
RETURN%@NL@%
%@NL@%
SUB AboutAccess%@NL@%
         a$ = "                      Access Keys||"%@NL@%
    a$ = a$ + "Access keys are the keys on the menu bar that are highlighted|"%@NL@%
    a$ = a$ + "when you press the Alt key. If you press a letter that is|"%@NL@%
    a$ = a$ + "highlighted in a menu title, that menu will be selected.||"%@NL@%
    a$ = a$ + "Once a pull-down menu is displayed, each menu item also has a|"%@NL@%
    a$ = a$ + "highlighted letter associated with each choice. Press the|"%@NL@%
    a$ = a$ + "letter that corresponds to the menu item you want to select.||"%@NL@%
    a$ = a$ + "If, after you press Alt, you change your mind, press the Alt|"%@NL@%
    a$ = a$ + "key again to cancel."%@NL@%
%@NL@%
    junk = Alert(1, a$, 7, 9, 20, 69, "", "", "")%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB AboutDemo%@NL@%
         a$ = "                      About This Demo||"%@NL@%
    a$ = a$ + "Running this program provides a visual demonstration of most|"%@NL@%
    a$ = a$ + "of the features implemented in the new User Interface Toolbox|"%@NL@%
    a$ = a$ + "for the BASIC Compiler 7.0.||"%@NL@%
    a$ = a$ + "In addition to serving as a demo of toolbox features, the|"%@NL@%
    a$ = a$ + "source code that makes up this program can also serve as a|"%@NL@%
    a$ = a$ + "programming example of how to implement these features in|"%@NL@%
    a$ = a$ + "your programs. While the demo is relatively simple, it does|"%@NL@%
    a$ = a$ + "illustrate almost all the features available."%@NL@%
%@NL@%
    junk = Alert(1, a$, 7, 9, 19, 69, "", "", "")%@NL@%
END SUB%@NL@%
%@NL@%
SUB AboutMouse%@NL@%
         a$ = "                      Using the Mouse||"%@NL@%
    a$ = a$ + "Virtually all operations in the User Interface Toolbox can|"%@NL@%
    a$ = a$ + "be accomplished using the mouse. Move the mouse cursor to|"%@NL@%
    a$ = a$ + "whatever you want to select and press the left button.||"%@NL@%
    a$ = a$ + "In addition to being able to make a choice with a mouse,|"%@NL@%
    a$ = a$ + "you can also perform a number of operations on windows.|"%@NL@%
    a$ = a$ + "Using the mouse you can close, move, or resize windows|"%@NL@%
    a$ = a$ + "depending on the particular features of the window that is|"%@NL@%
    a$ = a$ + "active."%@NL@%
%@NL@%
    junk = Alert(1, a$, 7, 9, 19, 69, "", "", "")%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB AboutQuick%@NL@%
         a$ = "                      Quick Keys||"%@NL@%
    a$ = a$ + "Quick keys are optional keys that you can define in addition|"%@NL@%
    a$ = a$ + "to the normal access keys that must be specified when you|"%@NL@%
    a$ = a$ + "set up the individual menu items.||"%@NL@%
    a$ = a$ + "Quick keys normally reduce selection of a menu item to one|"%@NL@%
    a$ = a$ + "keystroke. For example, this demo uses function keys F1 thru|"%@NL@%
    a$ = a$ + "F8 to select menu choices that demonstrate different features|"%@NL@%
    a$ = a$ + "of the User Interface Toolbox.  Additionally, Ctrl-X is the|"%@NL@%
    a$ = a$ + "Quick key that exits this demonstration program."%@NL@%
%@NL@%
    junk = Alert(1, a$, 7, 9, 19, 69, "", "", "")%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB AboutUIP%@NL@%
         a$ = "                 About the User Interface||"%@NL@%
    a$ = a$ + "The user interface provided with this toolbox is designed to|"%@NL@%
    a$ = a$ + "provide much the same functionality as that found in the QBX|"%@NL@%
    a$ = a$ + "programming environment. The menus, check boxes, option|"%@NL@%
    a$ = a$ + "buttons, and other interface features operate similarly to|"%@NL@%
    a$ = a$ + "their QBX counterparts. ||"%@NL@%
    a$ = a$ + "If you know how to navigate QBX, you know how to navigate|"%@NL@%
    a$ = a$ + "the interface provided by the User Interface Toolbox."%@NL@%
%@NL@%
    junk = Alert(1, a$, 7, 9, 18, 69, "", "", "")%@NL@%
END SUB%@NL@%
%@NL@%
SUB AboutWindows%@NL@%
         a$ = "                     About the Windows||"%@NL@%
    a$ = a$ + "Several border characters used by the windows in the User|"%@NL@%
    a$ = a$ + "Interface Toolbox have special significance.  Any window that|"%@NL@%
    a$ = a$ + "has a '=' in the upper-left corner can be closed by selecting|"%@NL@%
    a$ = a$ + "that character with the mouse. Windows with the '' character|"%@NL@%
    a$ = a$ + "across the window's top row can be moved around the screen by|"%@NL@%
    a$ = a$ + "selecting that area with the mouse.  The '+' character in the|"%@NL@%
    a$ = a$ + "lower-right corner means that the window can be resized by|"%@NL@%
    a$ = a$ + "selecting the '+' character with the mouse.||"%@NL@%
    a$ = a$ + "Note that none of these features can be accessed without a|"%@NL@%
    a$ = a$ + "mouse. "%@NL@%
%@NL@%
    junk = Alert(1, a$, 7, 9, 21, 69, "", "", "")%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB ColorDisplay%@NL@%
    DisplayType = TRUE%@NL@%
    MouseHide%@NL@%
    SetupMenu%@NL@%
    MenuSetState 2, 1, 2%@NL@%
    MenuSetState 2, 2, 1%@NL@%
    SetupDesktop%@NL@%
    MenuShow%@NL@%
    MouseShow%@NL@%
END SUB%@NL@%
%@NL@%
SUB DemoAlert%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Simple little demo of how easy alerts are to use.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
         a$ = "|"%@NL@%
    a$ = a$ + "This is an Alert Box.| |"%@NL@%
    a$ = a$ + "It was created using a simple one|"%@NL@%
    a$ = a$ + "line command.  Notice the buttons|"%@NL@%
    a$ = a$ + "below.  They are user definable|"%@NL@%
    a$ = a$ + "yet their spacing is automatic."%@NL@%
%@NL@%
    B$ = "You Selected OK"%@NL@%
%@NL@%
    C$ = "You Selected Cancel"%@NL@%
%@NL@%
    SELECT CASE Alert(4, a$, 6, 20, 15, 60, "OK", "Cancel", "")%@NL@%
        CASE 1%@NL@%
            x = Alert(4, B$, 10, 25, 12, 55, "OK", "", "")%@NL@%
        CASE 2%@NL@%
            x = Alert(4, C$, 10, 25, 12, 55, "OK", "", "")%@NL@%
    END SELECT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB DemoDialog%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' This is about as complex as they get.  As you can see it is still very%@AE@%%@NL@%
%@AB@%    ' simple - just a lot bigger.  This sub exactly duplicates the%@AE@%%@NL@%
%@AB@%    ' functionality of the QuickBASIC Search-Change dialog box.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Open Window, place a horizontal line on row 13%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    WindowOpen 1, 6, 11, 19, 67, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 1, ""%@NL@%
%@NL@%
    WindowLine 13%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Print the text, and boxes for the edit fields%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    WindowLocate 2, 2%@NL@%
    WindowPrint 2, "Find What:"%@NL@%
    WindowBox 1, 14, 3, 56%@NL@%
%@NL@%
    WindowLocate 5, 2%@NL@%
    WindowPrint 2, "Change To:"%@NL@%
    WindowBox 4, 14, 6, 56%@NL@%
%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Print the title of the window -- This overides the string in WindowOpen%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    WindowLocate 0, 26%@NL@%
    WindowPrint 1, " Change "%@NL@%
%@NL@%
    WindowBox 8, 32, 12, 56%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Open Edit fields%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    search$ = ""%@NL@%
    replace$ = ""%@NL@%
    EditFieldOpen 1, search$, 2, 15, 0, 0, 40, 39%@NL@%
%@NL@%
    EditFieldOpen 2, replace$, 5, 15, 0, 0, 40, 39%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Open all buttons%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    ButtonOpen 1, 1, "Match Upper/Lowercase", 9, 2, 0, 0, 2%@NL@%
    ButtonOpen 2, 1, "Whole Word", 10, 2, 0, 0, 2%@NL@%
    ButtonOpen 3, 1, "1. Active Window", 9, 34, 0, 0, 3%@NL@%
    ButtonOpen 4, 2, "2. Current Module", 10, 34, 0, 0, 3%@NL@%
    ButtonOpen 5, 1, "3. All Modules", 11, 34, 0, 0, 3%@NL@%
    ButtonOpen 6, 2, "Find and Verify", 14, 2, 0, 0, 1%@NL@%
    ButtonOpen 7, 1, "Change All", 14, 22, 0, 0, 1%@NL@%
    ButtonOpen 8, 1, "Cancel", 14, 38, 0, 0, 1%@NL@%
    ButtonOpen 9, 1, "Help", 14, 49, 0, 0, 1%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Set initial states to match initial button settings%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    MatchState = FALSE%@NL@%
    WordState = FALSE%@NL@%
    searchState = 2%@NL@%
    pushButton = 1%@NL@%
    currButton = 0%@NL@%
    currEditField = 1%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Do until exitFlag is set%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    ExitFlag = FALSE%@NL@%
    WHILE NOT ExitFlag%@NL@%
        WindowDo currButton, currEditField%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 0, 3, 4, 5, 20%@NL@%
%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@AB@%            ' If edit field clicked, assign currEditField to Dialog(2)%@AE@%%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@NL@%
            CASE 2%@NL@%
                currButton = 0%@NL@%
                currEditField = Dialog(2)%@NL@%
%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@AB@%            ' If escape is hit,  set pushbutton = 0 and exit flag%@AE@%%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@NL@%
            CASE 9  '(Escape)%@NL@%
                pushButton = 3%@NL@%
                ExitFlag = TRUE%@NL@%
%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@AB@%            ' If return is hit, perform action based on the current button%@AE@%%@NL@%
%@AB@%            ' Button 9 is the help button.  In that case, show help, else just%@AE@%%@NL@%
%@AB@%            ' exit%@AE@%%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@NL@%
            CASE 6%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 9%@NL@%
                        a$ = "Sample Help Window"%@NL@%
                        ButtonSetState pushButton + 5, 1%@NL@%
                        pushButton = 4%@NL@%
                        ButtonSetState pushButton + 5, 2%@NL@%
                        junk = Alert(4, a$, 7, 9, 19, 69, "", "", "")%@NL@%
                    CASE ELSE%@NL@%
                        ExitFlag = TRUE%@NL@%
                END SELECT%@NL@%
%@NL@%
%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@AB@%            ' A Button was pushed with mouse. Perform the desired action%@AE@%%@NL@%
%@AB@%            ' based on Button%@AE@%%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@NL@%
            CASE 1%@NL@%
                currButton = Dialog(1)%@NL@%
                currEditField = 0%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1%@NL@%
                        MatchState = NOT MatchState%@NL@%
                        ButtonToggle 1%@NL@%
                    CASE 2%@NL@%
                        WordState = NOT WordState%@NL@%
                        ButtonToggle 2%@NL@%
                    CASE 3, 4, 5%@NL@%
                        ButtonSetState searchState + 2, 1%@NL@%
                        searchState = Dialog(1) - 2%@NL@%
                        ButtonSetState searchState + 2, 2%@NL@%
                    CASE 6, 7, 8%@NL@%
                        pushButton = Dialog(1) - 5%@NL@%
                        ExitFlag = TRUE%@NL@%
                    CASE 9%@NL@%
                        a$ = "Sample Help Window"%@NL@%
                        ButtonSetState pushButton + 5, 1%@NL@%
                        pushButton = Dialog(1) - 5%@NL@%
                        ButtonSetState pushButton + 5, 2%@NL@%
                        junk = Alert(4, a$, 7, 9, 19, 69, "", "", "")%@NL@%
                    CASE ELSE%@NL@%
                END SELECT%@NL@%
%@NL@%
%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@AB@%            ' Tab was hit.  Depending upon the current button, or current edit field,%@AE@%%@NL@%
%@AB@%            ' assign the new values to currButton, and currEditField%@AE@%%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@NL@%
            CASE 7  'tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0%@NL@%
                        SELECT CASE currEditField%@NL@%
                            CASE 1%@NL@%
                                currEditField = 2%@NL@%
%@NL@%
                            CASE ELSE%@NL@%
                                currButton = 1%@NL@%
                                currEditField = 0%@NL@%
                        END SELECT%@NL@%
                    CASE 1%@NL@%
                        currButton = 2%@NL@%
                    CASE 6, 7, 8%@NL@%
                        currButton = currButton + 1%@NL@%
                        ButtonSetState pushButton + 5, 1%@NL@%
                        pushButton = currButton - 5%@NL@%
                        ButtonSetState pushButton + 5, 2%@NL@%
                    CASE 3, 4, 5%@NL@%
                        currButton = 6%@NL@%
                    CASE 2%@NL@%
                        currButton = 2 + searchState%@NL@%
                    CASE 9%@NL@%
                        currButton = 0%@NL@%
                        ButtonSetState pushButton + 5, 1%@NL@%
                        pushButton = 1%@NL@%
                        ButtonSetState pushButton + 5, 2%@NL@%
                        currEditField = 1%@NL@%
                END SELECT%@NL@%
%@NL@%
%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@AB@%            ' Same for Back Tab, only reverse.%@AE@%%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@NL@%
            CASE 8 'back tab%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0%@NL@%
                        SELECT CASE currEditField%@NL@%
                            CASE 1%@NL@%
                                currButton = 9%@NL@%
                                ButtonSetState pushButton + 5, 1%@NL@%
                                pushButton = currButton - 5%@NL@%
                                ButtonSetState pushButton + 5, 2%@NL@%
                                currEditField = 0%@NL@%
                            CASE 2%@NL@%
                                currEditField = 1%@NL@%
                        END SELECT%@NL@%
                    CASE 1%@NL@%
                        currButton = 0%@NL@%
                        currEditField = 2%@NL@%
                    CASE 7, 8, 9%@NL@%
                        currButton = currButton - 1%@NL@%
                        ButtonSetState pushButton + 5, 1%@NL@%
                        pushButton = currButton - 5%@NL@%
                        ButtonSetState pushButton + 5, 2%@NL@%
                    CASE 3, 4, 5%@NL@%
                        currButton = 2%@NL@%
                    CASE 6%@NL@%
                        currButton = 2 + searchState%@NL@%
                    CASE 2%@NL@%
                        currButton = 1%@NL@%
                END SELECT%@NL@%
%@NL@%
%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@AB@%            ' Up arrow only affects buttons 1,2,3,4,5  (the radial and check%@AE@%%@NL@%
%@AB@%            ' buttons)%@AE@%%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@NL@%
            CASE 10 'up arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1%@NL@%
                        IF NOT MatchState THEN%@NL@%
                            MatchState = TRUE%@NL@%
                            ButtonToggle 1%@NL@%
                        END IF%@NL@%
                    CASE 2%@NL@%
                        IF NOT WordState THEN%@NL@%
                            WordState = TRUE%@NL@%
                            ButtonToggle 2%@NL@%
                        END IF%@NL@%
                    CASE 3%@NL@%
                        ButtonSetState searchState + 2, 1%@NL@%
                        searchState = 3%@NL@%
                        currButton = 5%@NL@%
                        ButtonSetState searchState + 2, 2%@NL@%
                    CASE 4, 5%@NL@%
                        ButtonSetState searchState + 2, 1%@NL@%
                        searchState = searchState - 1%@NL@%
                        currButton = currButton - 1%@NL@%
                        ButtonSetState searchState + 2, 2%@NL@%
                END SELECT%@NL@%
%@NL@%
%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@AB@%            ' Same with down arrow, only reverse%@AE@%%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@NL@%
            CASE 11 'down%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1%@NL@%
                        IF MatchState THEN%@NL@%
                            MatchState = NOT MatchState%@NL@%
                            ButtonToggle 1%@NL@%
                        END IF%@NL@%
                    CASE 2%@NL@%
                        IF WordState THEN%@NL@%
                            WordState = NOT WordState%@NL@%
                            ButtonToggle 2%@NL@%
                        END IF%@NL@%
                    CASE 3, 4%@NL@%
                        ButtonSetState searchState + 2, 1%@NL@%
                        searchState = searchState + 1%@NL@%
                        currButton = currButton + 1%@NL@%
                        ButtonSetState searchState + 2, 2%@NL@%
                    CASE 5%@NL@%
                        ButtonSetState searchState + 2, 1%@NL@%
                        searchState = 1%@NL@%
                        currButton = 3%@NL@%
                        ButtonSetState searchState + 2, 2%@NL@%
                END SELECT%@NL@%
%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@AB@%            ' Left arrow only affects button 1 and 2  (the check buttons)%@AE@%%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@NL@%
            CASE 12 'Left Arrow%@NL@%
               SELECT CASE currButton%@NL@%
                    CASE 1%@NL@%
                        IF NOT MatchState THEN%@NL@%
                            MatchState = TRUE%@NL@%
                            ButtonToggle 1%@NL@%
                        END IF%@NL@%
                    CASE 2%@NL@%
                        IF NOT WordState THEN%@NL@%
                            WordState = TRUE%@NL@%
                            ButtonToggle 2%@NL@%
                        END IF%@NL@%
                    CASE 3%@NL@%
                        ButtonSetState searchState + 2, 1%@NL@%
                        searchState = 3%@NL@%
                        currButton = 5%@NL@%
                        ButtonSetState searchState + 2, 2%@NL@%
%@NL@%
                    CASE 4, 5%@NL@%
                        ButtonSetState searchState + 2, 1%@NL@%
                        searchState = searchState - 1%@NL@%
                        currButton = currButton - 1%@NL@%
                        ButtonSetState searchState + 2, 2%@NL@%
%@NL@%
               END SELECT%@NL@%
%@NL@%
%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@AB@%            ' Right arrow only affects button 1 and 2  (the check buttons)%@AE@%%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@NL@%
            CASE 13 'Right Arrow%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1%@NL@%
                        IF MatchState THEN%@NL@%
                            MatchState = NOT MatchState%@NL@%
                            ButtonToggle 1%@NL@%
                        END IF%@NL@%
                    CASE 2%@NL@%
                        IF WordState THEN%@NL@%
                            WordState = NOT WordState%@NL@%
                            ButtonToggle 2%@NL@%
                        END IF%@NL@%
                    CASE 3, 4%@NL@%
                        ButtonSetState searchState + 2, 1%@NL@%
                        searchState = searchState + 1%@NL@%
                        currButton = currButton + 1%@NL@%
                        ButtonSetState searchState + 2, 2%@NL@%
                    CASE 5%@NL@%
                        ButtonSetState searchState + 2, 1%@NL@%
                        searchState = 1%@NL@%
                        currButton = 3%@NL@%
                        ButtonSetState searchState + 2, 2%@NL@%
%@NL@%
                END SELECT%@NL@%
%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@AB@%            ' Space will toggle a check button, or select a push button (including help)%@AE@%%@NL@%
%@AB@%            ' ==============================================================%@AE@%%@NL@%
%@NL@%
            CASE 14 'space%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 1%@NL@%
                        MatchState = NOT MatchState%@NL@%
                        ButtonToggle 1%@NL@%
                    CASE 2%@NL@%
                        WordState = NOT WordState%@NL@%
                        ButtonToggle 2%@NL@%
                    CASE 6, 7, 8%@NL@%
                        pushButton = currButton - 5%@NL@%
                        ExitFlag = TRUE%@NL@%
                    CASE 9%@NL@%
                        a$ = "Sample Help Window"%@NL@%
                        ButtonSetState pushButton + 5, 1%@NL@%
                        pushButton = 4%@NL@%
                        ButtonSetState pushButton + 5, 2%@NL@%
                        junk = Alert(4, a$, 7, 9, 19, 69, "", "", "")%@NL@%
                    CASE ELSE%@NL@%
                END SELECT%@NL@%
            CASE ELSE%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Prepare data for final alert box that says what the final state was.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    search$ = EditFieldInquire(1)%@NL@%
    replace$ = EditFieldInquire(2)%@NL@%
%@NL@%
%@NL@%
    WindowClose 1%@NL@%
    IF pushButton = 3 THEN%@NL@%
        a$ = "You Selected CANCEL"%@NL@%
        x = Alert(4, a$, 10, 25, 12, 55, "OK", "", "")%@NL@%
    ELSE%@NL@%
        IF pushButton = 1 THEN%@NL@%
            a$ = "You selected VERIFY.  Here are your other selections:| |"%@NL@%
        ELSE%@NL@%
            a$ = "You selected CHANGE ALL.  Here are your other selections:| |"%@NL@%
        END IF%@NL@%
%@NL@%
        IF MatchState THEN%@NL@%
            a$ = a$ + "   Match Upper/Lowercase = Yes|"%@NL@%
        ELSE%@NL@%
            a$ = a$ + "   Match Upper/Lowercase = No|"%@NL@%
        END IF%@NL@%
%@NL@%
        IF WordState THEN%@NL@%
            a$ = a$ + "   Whole Word            = Yes|"%@NL@%
        ELSE%@NL@%
            a$ = a$ + "   Whole Word            = No|"%@NL@%
        END IF%@NL@%
%@NL@%
        SELECT CASE searchState%@NL@%
            CASE 1: a$ = a$ + "   Search space          = Active Window|"%@NL@%
            CASE 2: a$ = a$ + "   Search space          = Current Module|"%@NL@%
            CASE 3: a$ = a$ + "   Search space          = All Modules|"%@NL@%
        END SELECT%@NL@%
%@NL@%
        a$ = a$ + "   Search string : " + search$ + "|"%@NL@%
        a$ = a$ + "   Replace string: " + replace$ + "|"%@NL@%
%@NL@%
        x = Alert(2, a$, 7, 11, 15, 69, "OK", "", "")%@NL@%
    END IF%@NL@%
END SUB%@NL@%
%@NL@%
SUB DemoDialogEZ%@NL@%
%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Open Window, write text, and open button and edit field%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    WindowOpen 1, 8, 20, 13, 60, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 1, ""%@NL@%
%@NL@%
    WindowLocate 2, 2%@NL@%
    WindowPrint 2, "Your Name:"%@NL@%
    WindowBox 1, 14, 3, 38%@NL@%
%@NL@%
    EditFieldOpen 1, "", 2, 15, 0, 0, 23, 22%@NL@%
    WindowLine 5%@NL@%
    ButtonOpen 1, 2, "OK", 6, 17, 0, 0, 1%@NL@%
%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Set initial state + go into main loop%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    currButton = 0%@NL@%
    currEditField = 1%@NL@%
%@NL@%
    ExitFlag = FALSE%@NL@%
%@NL@%
    WHILE NOT ExitFlag%@NL@%
        WindowDo currButton, currEditField%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1, 6                       'Button, or Enter, exit loop%@NL@%
                ExitFlag = TRUE%@NL@%
            CASE 2                          'EditField, switch to edit field%@NL@%
                currButton = 0%@NL@%
                currEditField = 1%@NL@%
            CASE 7, 8                       'tab and backTab, flip/flop state%@NL@%
                IF currButton = 1 THEN%@NL@%
                    currButton = 0%@NL@%
                    currEditField = 1%@NL@%
                ELSE%@NL@%
                    currButton = 1%@NL@%
                    currEditField = 0%@NL@%
                END IF%@NL@%
            CASE 14                         'space - if on button then exit%@NL@%
                IF currButton = 1 THEN%@NL@%
                    ExitFlag = TRUE%@NL@%
                END IF%@NL@%
            CASE 9                          'escape%@NL@%
                WindowClose 1%@NL@%
                EXIT SUB%@NL@%
            CASE ELSE%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Assign the variable before closing the window, and close the window%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    yourName$ = EditFieldInquire$(1)%@NL@%
%@NL@%
    WindowClose 1%@NL@%
%@NL@%
    IF LEN(yourName$) <> 0 THEN%@NL@%
        junk = Alert(4, "Hello " + yourName$ + ".", 10, 20, 12, 60, "OK", "", "")%@NL@%
    ELSE%@NL@%
        junk = Alert(4, "I understand. You wish to remain anonymous!", 10, 15, 12, 65, "OK", "", "")%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB DemoFileNameListBox%@NL@%
%@NL@%
    WindowOpen 1, 8, 20, 15, 60, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, TRUE, 1, ""%@NL@%
%@NL@%
    WindowLocate 2, 4%@NL@%
    WindowPrint 4, "Enter a file specification:"%@NL@%
    WindowBox 3, 4, 5, 38%@NL@%
%@NL@%
    EditFieldOpen 1, "*.*", 4, 5, 0, 0, 23, 22%@NL@%
    WindowLine 7%@NL@%
    ButtonOpen 1, 2, "OK", 8, 17, 0, 0, 1%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Set initial state + go into main loop%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    currButton = 0%@NL@%
    currEditField = 1%@NL@%
%@NL@%
    ExitFlag = FALSE%@NL@%
    WHILE NOT ExitFlag%@NL@%
        WindowDo currButton, currEditField%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 1, 6                       'Button, or Enter, exit loop%@NL@%
                ExitFlag = TRUE%@NL@%
            CASE 2                          'EditField, switch to edit field%@NL@%
                currButton = 0%@NL@%
                currEditField = 1%@NL@%
            CASE 7, 8                       'tab and backTab, flip/flop state%@NL@%
                IF currButton = 1 THEN%@NL@%
                    currButton = 0%@NL@%
                    currEditField = 1%@NL@%
                ELSE%@NL@%
                    currButton = 1%@NL@%
                    currEditField = 0%@NL@%
                END IF%@NL@%
            CASE 9                          'escape%@NL@%
                WindowClose 1%@NL@%
                EXIT SUB%@NL@%
            CASE 14                         'space - if on button then exit%@NL@%
                IF currButton = 1 THEN%@NL@%
                    ExitFlag = TRUE%@NL@%
                END IF%@NL@%
            CASE ELSE%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Assign the variable before closing the window, and close the window%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    FileSpec$ = EditFieldInquire$(1)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Make sure its a valid file name%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    delimit = INSTR(FileSpec$, ".")%@NL@%
%@NL@%
    IF delimit THEN%@NL@%
        fileName$ = LEFT$(FileSpec$, delimit - 1)%@NL@%
        fileExt$ = RIGHT$(FileSpec$, LEN(FileSpec$) - (delimit))%@NL@%
    ELSE%@NL@%
        fileName$ = FileSpec$%@NL@%
        fileExt$ = ""%@NL@%
    END IF%@NL@%
%@NL@%
    IF LEN(FileSpec$) = 0 OR LEN(fileName$) > 8 OR LEN(fileExt$) > 3 THEN%@NL@%
        WindowClose 1%@NL@%
        junk = Alert(4, "You didn't enter a valid file specification.", 10, 15, 12, 62, "OK", "", "")%@NL@%
        EXIT SUB%@NL@%
    END IF%@NL@%
%@NL@%
    FileCount = GetFileCount(FileSpec$)%@NL@%
%@NL@%
    IF FileCount THEN%@NL@%
%@NL@%
        REDIM FileList$(FileCount)%@NL@%
%@NL@%
    ELSE%@NL@%
%@NL@%
        WindowClose 1%@NL@%
        junk = Alert(4, "No match to your file specification could be found.", 10, 10, 12, 70, "OK", "", "")%@NL@%
        EXIT SUB%@NL@%
    END IF%@NL@%
%@NL@%
    FileList$(1) = DIR$(FileSpec$)%@NL@%
%@NL@%
    FOR Indx = 2 TO FileCount%@NL@%
        FileList$(Indx) = DIR$%@NL@%
    NEXT Indx%@NL@%
%@NL@%
    x = ListBox(FileList$(), UBOUND(FileList$))%@NL@%
%@NL@%
    SELECT CASE x%@NL@%
        CASE 0%@NL@%
            junk = Alert(4, "You selected CANCEL", 10, 25, 12, 55, "OK", "", "")%@NL@%
        CASE ELSE%@NL@%
            junk = Alert(4, "You selected " + FileList$(x), 10, 25, 12, 55, "OK", "", "")%@NL@%
    END SELECT%@NL@%
%@NL@%
    WindowClose 1%@NL@%
END SUB%@NL@%
%@NL@%
SUB DemoListBox%@NL@%
%@NL@%
    REDIM x$(30), y$(30)%@NL@%
%@NL@%
    x$(1) = "Orange":                 y$(1) = "Orange you glad I didn't say Banana?"%@NL@%
    x$(2) = "Butter":                 y$(2) = "Try margarine! less cholesterol"%@NL@%
    x$(3) = "Corn":                   y$(3) = "Some people call it maize."%@NL@%
    x$(4) = "Potato":                 y$(4) = "Wouldn't you prefer stuffing?"%@NL@%
    x$(5) = "Grape":                  y$(5) = "Grape balls of fire!"%@NL@%
    x$(6) = "Cherry":                 y$(6) = "Don't chop down the tree!"%@NL@%
    x$(7) = "Lettuce":                y$(7) = "Two heads are better than one."%@NL@%
    x$(8) = "Lima bean":              y$(8) = "Who's Lima? and why do I have her beans?"%@NL@%
    x$(9) = "Carrot":                 y$(9) = "What's up Doc?"%@NL@%
    x$(10) = "Rice":                  y$(10) = "Yes, but can you use chopsticks?"%@NL@%
    x$(11) = "Steak":                 y$(11) = "Ooo.. Big spender."%@NL@%
    x$(12) = "Meatloaf":              y$(12) = "It must be Thursday."%@NL@%
    x$(13) = "Stuffing":              y$(13) = "Wouldn't you prefer potatoes?"%@NL@%
    x$(14) = "Wine":                  y$(14) = "Remember: 'Party Responsibly.'"%@NL@%
    x$(15) = "Pea":                   y$(15) = "Comes with the princess."%@NL@%
    x$(16) = "Gravy":                 y$(16) = "like home made! (Only no lumps)"%@NL@%
    x$(17) = "Pancake":               y$(17) = "Three for a dollar!"%@NL@%
    x$(18) = "Waffle":                y$(18) = "Syrup on your waffle sir?"%@NL@%
    x$(19) = "Broccoli":              y$(19) = "Little trees..."%@NL@%
    x$(20) = "Oatmeal":               y$(20) = "Yuck.."%@NL@%
%@NL@%
    x = ListBox(x$(), 20)%@NL@%
%@NL@%
    SELECT CASE x%@NL@%
        CASE 0%@NL@%
            y = Alert(4, "You Selected Cancel", 10, 25, 12, 55, "OK", "", "")%@NL@%
        CASE ELSE%@NL@%
            y = Alert(4, y$(x), 10, 38 - LEN(y$(x)) \ 2, 12, 43 + LEN(y$(x)) \ 2, "OK", "", "")%@NL@%
    END SELECT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB DemoResize%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Define Window's text string%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    REDIM x$(19)%@NL@%
    x$(1) = "Resize Me!  Hello there!  Welcome to the wonderful world"%@NL@%
    x$(2) = "of Windows.  This demo shows how BASIC programmers can"%@NL@%
    x$(3) = "use a re-sizable window in their own applications."%@NL@%
    x$(4) = ""%@NL@%
    x$(5) = "This demo consists of a single window (this window) which"%@NL@%
    x$(6) = "can be moved, closed, or re-sized.  When the user resizes"%@NL@%
    x$(7) = "a window, an event code of 5 is returned.  Upon receiving"%@NL@%
    x$(8) = "the event code, the programmer can then do whatever is"%@NL@%
    x$(9) = "needed to refresh the window. "%@NL@%
    x$(10) = ""%@NL@%
    x$(11) = "The text in this window simply truncates when the window"%@NL@%
    x$(12) = "is made smaller, but text can be made to wrap either by"%@NL@%
    x$(13) = "character, or at the spaces between words. The choice is"%@NL@%
    x$(14) = "the programmer's."%@NL@%
    x$(15) = ""%@NL@%
    x$(16) = "The programmer has many tools available to make the"%@NL@%
    x$(17) = "job very easy such as functions that return the window"%@NL@%
    x$(18) = "size, and simple one-line calls to perform actions like"%@NL@%
    x$(19) = "opening or closing a window. "%@NL@%
%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Open up a resizeable window%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    WindowOpen 1, 4, 5, 4, 16, 0, 7, 0, 7, 8, TRUE, TRUE, TRUE, FALSE, 1, "-Window 1-"%@NL@%
%@NL@%
    GOSUB DemoResizeDrawText%@NL@%
%@NL@%
    ExitFlag = FALSE%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Process window events...%@AE@%%@NL@%
%@AB@%    '  IMPORTANT:  Window moving, and re-sizing is handled automatically%@AE@%%@NL@%
%@AB@%    '  The window type dictates when this is allowed to happen.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    WHILE NOT ExitFlag%@NL@%
        WindowDo 0, 0%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 4, 9%@NL@%
                WindowClose WindowCurrent         'Close current window%@NL@%
                ExitFlag = TRUE%@NL@%
            CASE 5%@NL@%
                GOSUB DemoResizeDrawText%@NL@%
            CASE 20%@NL@%
                ExitFlag = TRUE                   'Exit if menu action%@NL@%
            CASE ELSE%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
    WindowClose 0%@NL@%
%@NL@%
EXIT SUB%@NL@%
%@NL@%
DemoResizeDrawText:%@NL@%
    WindowCls%@NL@%
%@NL@%
    FOR a = 1 TO 19%@NL@%
        IF a <= WindowRows(1) THEN%@NL@%
            WindowLocate a, 1%@NL@%
            WindowPrint -1, x$(a)%@NL@%
       END IF%@NL@%
    NEXT a%@NL@%
RETURN%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB DemoScrollBar%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Open up a closeable window%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF NOT DisplayType THEN%@NL@%
        WindowOpen 1, 4, 10, 20, 70, 0, 7, 0, 7, 15, FALSE, TRUE, FALSE, FALSE, 1, "Scroll Bar Demo"%@NL@%
    ELSE%@NL@%
        WindowOpen 1, 4, 10, 20, 70, 15, 5, 15, 5, 14, FALSE, TRUE, FALSE, FALSE, 1, "Scroll Bar Demo"%@NL@%
    END IF%@NL@%
%@NL@%
    ButtonOpen 1, 3, "", 4, 4, 14, 4, 6%@NL@%
    ButtonOpen 2, 4, "", 4, 6, 14, 6, 6%@NL@%
    ButtonOpen 3, 5, "", 4, 8, 14, 8, 6%@NL@%
    ButtonOpen 4, 4, "", 4, 10, 14, 10, 6%@NL@%
    ButtonOpen 5, 4, "", 4, 12, 14, 12, 6%@NL@%
    ButtonOpen 6, 9, "", 4, 16, 4, 50, 7%@NL@%
    ButtonOpen 7, 9, "", 6, 16, 6, 50, 7%@NL@%
    ButtonOpen 8, 8, "", 8, 16, 8, 50, 7%@NL@%
    ButtonOpen 9, 10, "", 10, 16, 10, 50, 7%@NL@%
    ButtonOpen 10, 12, "", 12, 16, 12, 50, 7%@NL@%
    ButtonOpen 11, 11, "", 14, 16, 14, 50, 7%@NL@%
%@NL@%
    ExitFlag = FALSE%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Process window events...%@AE@%%@NL@%
%@AB@%    '   IMPORTANT:  Window moving, and re-sizing is handled automatically%@AE@%%@NL@%
%@AB@%    '   The window type dictates when this is allowed to happen.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    WHILE NOT ExitFlag%@NL@%
        WindowDo 0, 0%@NL@%
        x = Dialog(0)%@NL@%
%@NL@%
        SELECT CASE x%@NL@%
            CASE 1%@NL@%
                button = Dialog(1)%@NL@%
%@NL@%
                scrollCode = Dialog(19)%@NL@%
                currState = ButtonInquire(button)%@NL@%
%@NL@%
                SELECT CASE scrollCode%@NL@%
                    CASE -1%@NL@%
                        IF currState > 1 THEN%@NL@%
                            newState = currState - 1%@NL@%
                        END IF%@NL@%
                    CASE -2%@NL@%
                        IF currState < MaxScrollLength(button) THEN%@NL@%
                            newState = currState + 1%@NL@%
                        END IF%@NL@%
                    CASE ELSE%@NL@%
                        newState = scrollCode%@NL@%
                END SELECT%@NL@%
%@NL@%
                ButtonSetState button, newState%@NL@%
%@NL@%
            CASE 4, 9%@NL@%
                WindowClose WindowCurrent         'Close current window%@NL@%
                ExitFlag = TRUE%@NL@%
            CASE 20%@NL@%
                ExitFlag = TRUE                   'Exit if menu action%@NL@%
            CASE ELSE%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
    WindowClose 0%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB DemoWindow%@NL@%
%@NL@%
    REDIM z$(4 TO 6, 6)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Open up 6 windows, showcase the features, and make each a different color%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
    IF NOT DisplayType THEN%@NL@%
        WindowOpen 1, 6, 5, 12, 25, 0, 7, 0, 7, 15, FALSE, FALSE, FALSE, FALSE, 0, ""%@NL@%
    ELSE%@NL@%
        WindowOpen 1, 6, 5, 12, 25, 0, 4, 0, 4, 15, FALSE, FALSE, FALSE, FALSE, 0, ""%@NL@%
    END IF%@NL@%
    WindowPrint 1, "Features:"%@NL@%
    WindowPrint 1, "No Title bar"%@NL@%
    WindowPrint 1, "No border"%@NL@%
%@NL@%
    IF NOT DisplayType THEN%@NL@%
        WindowOpen 2, 8, 15, 14, 35, 0, 7, 0, 7, 15, TRUE, FALSE, FALSE, FALSE, 1, "-Window 2-"%@NL@%
    ELSE%@NL@%
        WindowOpen 2, 8, 15, 14, 35, 0, 2, 0, 2, 15, TRUE, FALSE, FALSE, FALSE, 1, "-Window 2-"%@NL@%
    END IF%@NL@%
    WindowPrint 1, "Features:"%@NL@%
    WindowPrint 1, "Title bar"%@NL@%
    WindowPrint 1, "Moveable window"%@NL@%
    WindowPrint 1, "Single-line border"%@NL@%
%@NL@%
    IF NOT DisplayType THEN%@NL@%
        WindowOpen 3, 10, 25, 16, 45, 0, 7, 0, 7, 15, FALSE, TRUE, FALSE, FALSE, 1, "-Window 3-"%@NL@%
    ELSE%@NL@%
        WindowOpen 3, 10, 25, 16, 45, 0, 3, 0, 3, 15, FALSE, TRUE, FALSE, FALSE, 1, "-Window 3-"%@NL@%
    END IF%@NL@%
    WindowPrint 1, "Features:"%@NL@%
    WindowPrint 1, "Title bar"%@NL@%
    WindowPrint 1, "Closeable window"%@NL@%
    WindowPrint 1, "Single-line border"%@NL@%
%@NL@%
    WindowOpen 4, 12, 35, 18, 55, 0, 7, 0, 7, 15, FALSE, FALSE, TRUE, FALSE, 1, "-Window 4-"%@NL@%
    z$(4, 1) = "Features:"%@NL@%
    z$(4, 2) = "Title bar"%@NL@%
    z$(4, 3) = "Resizeable window"%@NL@%
    z$(4, 4) = "Single-line border"%@NL@%
    ValidLines = 4%@NL@%
    GOSUB DemoReDrawText%@NL@%
%@NL@%
    IF NOT DisplayType THEN%@NL@%
        WindowOpen 5, 14, 45, 20, 65, 0, 7, 0, 7, 15, TRUE, TRUE, TRUE, FALSE, 1, "-Window 5-"%@NL@%
    ELSE%@NL@%
        WindowOpen 5, 14, 45, 20, 65, 0, 5, 0, 5, 15, TRUE, TRUE, TRUE, FALSE, 1, "-Window 5-"%@NL@%
    END IF%@NL@%
    z$(5, 1) = "Features:"%@NL@%
    z$(5, 2) = "Title bar"%@NL@%
    z$(5, 3) = "Moveable window"%@NL@%
    z$(5, 4) = "Closeable window"%@NL@%
    z$(5, 5) = "Resizeable window"%@NL@%
    z$(5, 6) = "Single-line border"%@NL@%
    ValidLines = 6%@NL@%
    GOSUB DemoReDrawText%@NL@%
%@NL@%
    IF NOT DisplayType THEN%@NL@%
        WindowOpen 6, 16, 55, 22, 75, 0, 7, 0, 7, 15, TRUE, TRUE, TRUE, FALSE, 2, "-Window 6-"%@NL@%
    ELSE%@NL@%
        WindowOpen 6, 16, 55, 22, 75, 0, 6, 0, 6, 15, TRUE, TRUE, TRUE, FALSE, 2, "-Window 6-"%@NL@%
    END IF%@NL@%
    z$(6, 1) = "Features:"%@NL@%
    z$(6, 2) = "Title bar"%@NL@%
    z$(6, 3) = "Moveable window"%@NL@%
    z$(6, 4) = "Closeable window"%@NL@%
    z$(6, 5) = "Resizeable window"%@NL@%
    z$(6, 6) = "Double-line border"%@NL@%
    ValidLines = 6%@NL@%
    GOSUB DemoReDrawText%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Show alert box describing what is going on%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
         a$ = "WINDOWS:  This demo displays six windows, each representing one "%@NL@%
    a$ = a$ + "or more of the features that are available.  You may use the "%@NL@%
    a$ = a$ + "mouse to select windows, move windows, resize windows, or close "%@NL@%
    a$ = a$ + "windows. You can also select border characters and define your "%@NL@%
    a$ = a$ + "window title.| |You should know that this demo "%@NL@%
    a$ = a$ + "consists of only six window open commands, and a 12 line "%@NL@%
    a$ = a$ + "Select Case statement to handle the actual processing."%@NL@%
%@NL@%
    choice = Alert(3, a$, 7, 15, 18, 65, "OK", "Cancel", "")%@NL@%
%@NL@%
    IF choice = 1 THEN%@NL@%
        ExitFlag = FALSE%@NL@%
    ELSE%@NL@%
        ExitFlag = TRUE%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Process window events...%@AE@%%@NL@%
%@AB@%    '  IMPORTANT:  Window moving, and re-sizing is handled automatically%@AE@%%@NL@%
%@AB@%    '  The windowtype dictates when this is allowed to happen.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    WHILE NOT ExitFlag%@NL@%
        WindowDo 0, 0%@NL@%
        SELECT CASE Dialog(0)%@NL@%
            CASE 3%@NL@%
                WindowSetCurrent Dialog(3)        'Change current window%@NL@%
            CASE 4%@NL@%
                WindowClose WindowCurrent         'Close current window%@NL@%
            CASE 5%@NL@%
                GOSUB DemoReDrawText              'Redraw text when resizing%@NL@%
            CASE 9%@NL@%
                ExitFlag = TRUE                   'Exit if escape key pressed%@NL@%
            CASE 20%@NL@%
                ExitFlag = TRUE                   'Exit if menu action%@NL@%
            CASE ELSE%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
    WindowClose 0%@NL@%
%@NL@%
EXIT SUB%@NL@%
%@NL@%
DemoReDrawText:%@NL@%
    WindowCls%@NL@%
%@NL@%
    FOR a = 1 TO ValidLines%@NL@%
        IF a <= WindowRows(WindowCurrent) THEN%@NL@%
            WindowLocate a, 1%@NL@%
            WindowPrint -1, z$(WindowCurrent, a)%@NL@%
        END IF%@NL@%
    NEXT a%@NL@%
RETURN%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
FUNCTION GetFileCount (FileSpec$)%@NL@%
    count = 0%@NL@%
    fileName$ = DIR$(FileSpec$)%@NL@%
    DO WHILE fileName$ <> ""%@NL@%
        count = count + 1%@NL@%
        fileName$ = DIR$%@NL@%
    LOOP%@NL@%
    GetFileCount = count%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB MonoDisplay%@NL@%
    DisplayType = FALSE%@NL@%
    MouseHide%@NL@%
    SetupMenu%@NL@%
    MenuSetState 2, 1, 1%@NL@%
    MenuSetState 2, 2, 2%@NL@%
    SetupDesktop%@NL@%
    MenuShow%@NL@%
    MouseShow%@NL@%
END SUB%@NL@%
%@NL@%
DEFSNG A-Z%@NL@%
SUB SetupDesktop STATIC%@NL@%
%@NL@%
    MouseHide%@NL@%
%@NL@%
    WIDTH , 25%@NL@%
%@NL@%
    IF DisplayType THEN%@NL@%
        COLOR 15, 1      'Color%@NL@%
    ELSE%@NL@%
        COLOR 15, 0      'Monochrome%@NL@%
    END IF%@NL@%
    CLS%@NL@%
%@NL@%
    FOR a = 2 TO 80 STEP 4%@NL@%
        FOR B = 2 TO 25 STEP 2%@NL@%
            LOCATE B, a%@NL@%
            PRINT CHR$(250);%@NL@%
        NEXT B%@NL@%
    NEXT a%@NL@%
%@NL@%
    MouseShow%@NL@%
END SUB%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
SUB SetupMenu%@NL@%
%@NL@%
    MenuSet 1, 0, 1, "Demos", 1%@NL@%
    MenuSet 1, 1, 1, "Alert Window         F1", 1%@NL@%
    MenuSet 1, 2, 1, "Dialog Box (Simple)  F2", 13%@NL@%
    MenuSet 1, 3, 1, "Dialog Box (Complex) F3", 13%@NL@%
    MenuSet 1, 4, 1, "List Boxes           F4", 1%@NL@%
    MenuSet 1, 5, 1, "List Box w/File List F5", 12%@NL@%
    MenuSet 1, 6, 1, "Scroll Bars          F6", 8%@NL@%
    MenuSet 1, 7, 1, "Windows - Multiple   F7", 11%@NL@%
    MenuSet 1, 8, 1, "Window - Resizable   F8", 10%@NL@%
    MenuSet 1, 9, 1, "-", 1%@NL@%
    MenuSet 1, 10, 1, "Exit             Ctrl-X", 2%@NL@%
%@NL@%
    MenuSet 2, 0, 1, "Options", 1%@NL@%
    MenuSet 2, 1, 1, "Color", 1%@NL@%
    MenuSet 2, 2, 1, "Monochrome", 1%@NL@%
%@NL@%
%@NL@%
    MenuSet 3, 0, 1, "Help", 1%@NL@%
    MenuSet 3, 1, 1, "About This Demo", 12%@NL@%
    MenuSet 3, 2, 1, "About The User Interface", 11%@NL@%
    MenuSet 3, 3, 1, "About the Windows", 11%@NL@%
    MenuSet 3, 4, 1, "Using the Mouse", 11%@NL@%
    MenuSet 3, 5, 1, "Using Access Keys", 7%@NL@%
    MenuSet 3, 6, 1, "Using Quick Keys", 7%@NL@%
%@NL@%
    ShortCutKeySet 1, 1, CHR$(0) + CHR$(59) ' F1%@NL@%
    ShortCutKeySet 1, 2, CHR$(0) + CHR$(60) ' F2%@NL@%
    ShortCutKeySet 1, 3, CHR$(0) + CHR$(61) ' F3%@NL@%
    ShortCutKeySet 1, 4, CHR$(0) + CHR$(62) ' F4%@NL@%
    ShortCutKeySet 1, 5, CHR$(0) + CHR$(63) ' F5%@NL@%
    ShortCutKeySet 1, 6, CHR$(0) + CHR$(64) ' F6%@NL@%
    ShortCutKeySet 1, 7, CHR$(0) + CHR$(65) ' F7%@NL@%
    ShortCutKeySet 1, 8, CHR$(0) + CHR$(66) ' F8%@NL@%
%@NL@%
    ShortCutKeySet 1, 10, CHR$(24)          ' Ctrl-X%@NL@%
%@NL@%
    IF NOT DisplayType THEN%@NL@%
        MenuColor 0, 7, 15, 8, 7, 0, 15   'Best for monochrome and colors%@NL@%
    ELSE%@NL@%
        MenuColor 0, 7, 4, 8, 15, 0, 12   'Best for color%@NL@%
    END IF%@NL@%
%@NL@%
    MenuPreProcess%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WHEREIS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\WHEREIS.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
%@AB@%' Declare symbolic constants used in program:%@AE@%%@NL@%
CONST EOFTYPE = 0, FILETYPE = 1, DIRTYPE = 2, ROOT = "TWH"%@NL@%
%@NL@%
DECLARE SUB ScanDir (PathSpec$, Level, FileSpec$, Row)%@NL@%
%@NL@%
DECLARE FUNCTION MakeFileName$ (Num)%@NL@%
DECLARE FUNCTION GetEntry$ (FileNum, EntryType)%@NL@%
CLS%@NL@%
INPUT "File to look for"; FileSpec$%@NL@%
PRINT%@NL@%
PRINT "Enter the directory where the search should start"%@NL@%
PRINT "(optional drive + directories). Press <ENTER> to "%@NL@%
PRINT "begin search in root directory of current drive."%@NL@%
PRINT%@NL@%
INPUT "Starting directory"; PathSpec$%@NL@%
CLS%@NL@%
%@NL@%
RightCh$ = RIGHT$(PathSpec$, 1)%@NL@%
%@NL@%
IF PathSpec$ = "" OR RightCh$ = ":" OR RightCh$ <> "\" THEN%@NL@%
        PathSpec$ = PathSpec$ + "\"%@NL@%
END IF%@NL@%
%@NL@%
FileSpec$ = UCASE$(FileSpec$)%@NL@%
PathSpec$ = UCASE$(PathSpec$)%@NL@%
Level = 1%@NL@%
Row = 3%@NL@%
%@NL@%
%@AB@%' Make the top level call (level 1) to begin the search:%@AE@%%@NL@%
ScanDir PathSpec$, Level, FileSpec$, Row%@NL@%
%@NL@%
KILL ROOT + ".*"        ' Delete all temporary files created%@NL@%
%@AB@%                        ' by the program.%@AE@%%@NL@%
%@NL@%
LOCATE Row + 1, 1: PRINT "Search complete."%@NL@%
END%@NL@%
%@AB@%' ======================= GETENTRY ========================%@AE@%%@NL@%
%@AB@%'    This procedure processes entry lines in a DIR listing%@AE@%%@NL@%
%@AB@%'    saved to a file.%@AE@%%@NL@%
%@NL@%
%@AB@%'    This procedure returns the following values:%@AE@%%@NL@%
%@AB@%' ===================== MAKEFILENAME$ =====================%@AE@%%@NL@%
%@AB@%'    This procedure makes a file name from a root string%@AE@%%@NL@%
%@AB@%'    ("TWH," defined as a symbolic constant at the module%@AE@%%@NL@%
%@AB@%'    level) and a number passed to it as an argument (Num).%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
%@AB@%' ======================= SCANDIR =========================%@AE@%%@NL@%
%@AB@%'   This procedure recursively scans a directory for the%@AE@%%@NL@%
%@AB@%'   file name entered by the user.%@AE@%%@NL@%
%@NL@%
%@AB@%'   NOTE: The SUB header doesn't use the STATIC keyword%@AE@%%@NL@%
%@AB@%'         since this procedure needs a new set of variables%@AE@%%@NL@%
%@AB@%'         each time it is invoked.%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
%@NL@%
%@AB@%'  GetEntry$   A valid file or directory name%@AE@%%@NL@%
%@AB@%'  EntryType   If equal to 1, then GetEntry$%@AE@%%@NL@%
%@AB@%'        is a file.%@AE@%%@NL@%
%@AB@%'        If equal to 2, then GetEntry$%@AE@%%@NL@%
%@AB@%'        is a directory.%@AE@%%@NL@%
%@AB@%' =========================================================%@AE@%%@NL@%
FUNCTION GetEntry$ (FileNum, EntryType) STATIC%@NL@%
%@NL@%
%@AB@%        ' Loop until a valid entry or end-of-file (EOF) is read:%@AE@%%@NL@%
        DO UNTIL EOF(FileNum)%@NL@%
                LINE INPUT #FileNum, EntryLine$%@NL@%
                IF EntryLine$ <> "" THEN%@NL@%
%@NL@%
%@AB@%                        ' Get first character from the line for test:%@AE@%%@NL@%
         TestCh$ = LEFT$(EntryLine$, 1)%@NL@%
         IF TestCh$ <> " " AND TestCh$ <> "." THEN EXIT DO%@NL@%
                END IF%@NL@%
        LOOP%@NL@%
%@NL@%
%@AB@%        ' Entry or EOF found, decide which:%@AE@%%@NL@%
        IF EOF(FileNum) THEN    ' EOF, so return EOFTYPE%@NL@%
                EntryType = EOFTYPE  ' in EntryType.%@NL@%
                GetEntry$ = ""%@NL@%
%@NL@%
        ELSE                 ' Not EOF, so it must be a%@NL@%
%@AB@%                                        ' file or a directory.%@AE@%%@NL@%
%@NL@%
%@AB@%                ' Build and return the entry name:%@AE@%%@NL@%
                EntryName$ = RTRIM$(LEFT$(EntryLine$, 8))%@NL@%
%@NL@%
%@AB@%                ' Test for extension and add to name if there is one:%@AE@%%@NL@%
                EntryExt$ = RTRIM$(MID$(EntryLine$, 10, 3))%@NL@%
                IF EntryExt$ <> "" THEN%@NL@%
                        GetEntry$ = EntryName$ + "." + EntryExt$%@NL@%
                ELSE%@NL@%
         GetEntry$ = EntryName$%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' Determine the entry type, and return that value%@AE@%%@NL@%
%@AB@%                ' to the point where GetEntry$ was called:%@AE@%%@NL@%
                IF MID$(EntryLine$, 15, 3) = "DIR" THEN%@NL@%
         EntryType = DIRTYPE            ' Directory%@NL@%
                ELSE%@NL@%
         EntryType = FILETYPE           ' File%@NL@%
                END IF%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
FUNCTION MakeFileName$ (Num) STATIC%@NL@%
%@NL@%
        MakeFileName$ = ROOT + "." + LTRIM$(STR$(Num))%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB ScanDir (PathSpec$, Level, FileSpec$, Row)%@NL@%
%@NL@%
        LOCATE 1, 1: PRINT "Now searching"; SPACE$(50);%@NL@%
        LOCATE 1, 15: PRINT PathSpec$;%@NL@%
%@NL@%
%@AB@%        ' Make a file specification for the temporary file:%@AE@%%@NL@%
        TempSpec$ = MakeFileName$(Level)%@NL@%
%@NL@%
%@AB@%        ' Get a directory listing of the current directory,%@AE@%%@NL@%
%@AB@%        ' and save it in the temporary file:%@AE@%%@NL@%
        SHELL "DIR " + PathSpec$ + " > " + TempSpec$%@NL@%
%@NL@%
%@AB@%        ' Get the next available file number:%@AE@%%@NL@%
        FileNum = FREEFILE%@NL@%
%@NL@%
%@AB@%        ' Open the DIR listing file and scan it:%@AE@%%@NL@%
        OPEN TempSpec$ FOR INPUT AS #FileNum%@NL@%
%@AB@%' Process the file, one line at a time:%@AE@%%@NL@%
        DO%@NL@%
%@NL@%
%@AB@%                ' Input an entry from the DIR listing file:%@AE@%%@NL@%
                DirEntry$ = GetEntry$(FileNum, EntryType)%@NL@%
%@NL@%
%@AB@%                ' If entry is a file:%@AE@%%@NL@%
                IF EntryType = FILETYPE THEN%@NL@%
%@NL@%
%@AB@%         ' If the FileSpec$ string matches,%@AE@%%@NL@%
%@AB@%         ' print entry and exit this loop:%@AE@%%@NL@%
         IF DirEntry$ = FileSpec$ THEN%@NL@%
                 LOCATE Row, 1: PRINT PathSpec$; DirEntry$;%@NL@%
                 Row = Row + 1%@NL@%
                 EntryType = EOFTYPE%@NL@%
         END IF%@NL@%
%@NL@%
%@AB@%                ' If the entry is a directory, then make a recursive%@AE@%%@NL@%
%@AB@%                ' call to ScanDir with the new directory:%@AE@%%@NL@%
                ELSEIF EntryType = DIRTYPE THEN%@NL@%
         NewPath$ = PathSpec$ + DirEntry$ + "\"%@NL@%
         ScanDir NewPath$, Level + 1, FileSpec$, Row%@NL@%
         LOCATE 1, 1: PRINT "Now searching"; SPACE$(50);%@NL@%
         LOCATE 1, 15: PRINT PathSpec$;%@NL@%
                END IF%@NL@%
%@NL@%
        LOOP UNTIL EntryType = EOFTYPE%@NL@%
%@NL@%
%@AB@%        ' Scan on this DIR listing file is finished, so close it:%@AE@%%@NL@%
        CLOSE FileNum%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WINDOW.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\BASIC\WINDOW.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'============================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'    WINDOW.BAS - Window Routines for the User Interface Toolbox in%@AE@%%@NL@%
%@AB@%'           Microsoft BASIC 7.0, Professional Development System%@AE@%%@NL@%
%@AB@%'              Copyright (C) 1987-1989, Microsoft Corporation%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  NOTE:%@AE@%%@NL@%
%@AB@%'           This sample source code toolbox is intended to demonstrate some%@AE@%%@NL@%
%@AB@%'           of the extended capabilities of Microsoft BASIC 7.0 Professional%@AE@%%@NL@%
%@AB@%'           Development system that can help to leverage the professional%@AE@%%@NL@%
%@AB@%'           developer's time more effectively.  While you are free to use,%@AE@%%@NL@%
%@AB@%'           modify, or distribute the routines in this module in any way you%@AE@%%@NL@%
%@AB@%'           find useful, it should be noted that these are examples only and%@AE@%%@NL@%
%@AB@%'           should not be relied upon as a fully-tested "add-on" library.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  PURPOSE: These routines provide dialog box and window support to the%@AE@%%@NL@%
%@AB@%'           user interface toolbox.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'  For information on creating a library and QuickLib from the routines%@AE@%%@NL@%
%@AB@%'  contained in this file, read the comment header of GENERAL.BAS.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'==========================================================================%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
%@AB@%'$INCLUDE: 'general.bi'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'mouse.bi'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'menu.bi'%@AE@%%@NL@%
%@AB@%'$INCLUDE: 'window.bi'%@AE@%%@NL@%
%@NL@%
%@NL@%
COMMON SHARED /uitools/ GloMenu           AS MenuMiscType%@NL@%
COMMON SHARED /uitools/ GloTitle()        AS MenuTitleType%@NL@%
COMMON SHARED /uitools/ GloItem()         AS MenuItemType%@NL@%
COMMON SHARED /uitools/ GloWindow()       AS windowType%@NL@%
COMMON SHARED /uitools/ GloButton()       AS buttonType%@NL@%
COMMON SHARED /uitools/ GloEdit()         AS EditFieldType%@NL@%
COMMON SHARED /uitools/ GloStorage        AS WindowStorageType%@NL@%
COMMON SHARED /uitools/ GloWindowStack()  AS INTEGER%@NL@%
COMMON SHARED /uitools/ GloBuffer$()%@NL@%
%@NL@%
FUNCTION Alert (style, text$, row1, col1, row2, col2, b1$, b2$, b3$)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Open an alert window, then return the button that was pushed%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    Alert = 0%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Make sure coordinates and butttons are valid%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF row1 >= MINROW AND row2 <= MAXROW AND col1 >= MINCOL AND col2 <= MAXCOL THEN%@NL@%
%@NL@%
        IF b1$ = "" THEN%@NL@%
            b1$ = "OK"%@NL@%
            b2$ = ""%@NL@%
            b3$ = ""%@NL@%
        END IF%@NL@%
%@NL@%
        IF b2$ = "" THEN%@NL@%
            b3$ = ""%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If a window is available, compute button locations%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        alertWindow = WindowNext%@NL@%
%@NL@%
        IF alertWindow <> 0 THEN%@NL@%
%@NL@%
            minWidth = 3%@NL@%
            buttonTotal = 0%@NL@%
%@NL@%
            IF b1$ <> "" THEN%@NL@%
                minWidth = minWidth + 7 + LEN(b1$):%@NL@%
                buttonTotal = buttonTotal + 1%@NL@%
            END IF%@NL@%
%@NL@%
            IF b2$ <> "" THEN%@NL@%
                minWidth = minWidth + 7 + LEN(b2$)%@NL@%
                buttonTotal = buttonTotal + 1%@NL@%
            END IF%@NL@%
%@NL@%
            IF b3$ <> "" THEN%@NL@%
                minWidth = minWidth + 7 + LEN(b3$)%@NL@%
                buttonTotal = buttonTotal + 1%@NL@%
            END IF%@NL@%
%@NL@%
            actualWidth = col2 - col1 + 1%@NL@%
            actualHeight = row2 - row1 + 1%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' If size is valid, open window, print text, open buttons%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            IF actualWidth >= minWidth AND actualHeight >= 3 THEN%@NL@%
%@NL@%
                WindowOpen alertWindow, row1, col1, row2, col2, 0, 7, 0, 7, 15, 0, 0, 0, 1, 1, ""%@NL@%
                WindowLine actualHeight - 1%@NL@%
%@NL@%
                text$ = text$ + "|"%@NL@%
                WHILE text$ <> ""%@NL@%
                    x$ = LEFT$(text$, INSTR(text$, "|") - 1)%@NL@%
                    text$ = RIGHT$(text$, LEN(text$) - LEN(x$) - 1)%@NL@%
                    WindowPrint style, x$%@NL@%
                WEND%@NL@%
%@NL@%
                charTotal = LEN(b1$) + LEN(b2$) + LEN(b3$) + 4 * buttonTotal%@NL@%
                avgSpace = INT((actualWidth - charTotal) / (buttonTotal + 1))%@NL@%
%@NL@%
                IF LEN(b1$) > 0 THEN%@NL@%
                    ButtonOpen 1, 2, b1$, actualHeight, avgSpace + 1, 0, 0, 1%@NL@%
                END IF%@NL@%
%@NL@%
                IF LEN(b2$) > 0 THEN%@NL@%
                    ButtonOpen 2, 1, b2$, actualHeight, avgSpace * 2 + LEN(b1$) + 5, 0, 0, 1%@NL@%
                END IF%@NL@%
%@NL@%
                IF LEN(b3$) > 0 THEN%@NL@%
                    ButtonOpen 3, 1, b3$, actualHeight, avgSpace * 3 + LEN(b1$) + LEN(b2$) + 9, 0, 0, 1%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
%@AB@%                ' Main window processing loop%@AE@%%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
%@NL@%
                currButton = 1%@NL@%
%@NL@%
                ExitFlag = FALSE%@NL@%
                WHILE NOT ExitFlag%@NL@%
                    WindowDo currButton, 0%@NL@%
                    SELECT CASE Dialog(0)%@NL@%
                        CASE 1                      'Button Pressed%@NL@%
                            Alert = Dialog(1)%@NL@%
                            ExitFlag = TRUE%@NL@%
                        CASE 6, 14                  'Enter or Space%@NL@%
                            Alert = currButton%@NL@%
                            ExitFlag = TRUE%@NL@%
                        CASE 7                      'Tab%@NL@%
                            ButtonSetState currButton, 1%@NL@%
                            currButton = (currButton) MOD buttonTotal + 1%@NL@%
                            ButtonSetState currButton, 2%@NL@%
                        CASE 8                      'BackTab%@NL@%
                            ButtonSetState currButton, 1%@NL@%
                            currButton = (currButton + buttonTotal - 2) MOD buttonTotal + 1%@NL@%
                            ButtonSetState currButton, 2%@NL@%
                        CASE 9%@NL@%
                            IF UCASE$(b1$) = "CANCEL" THEN%@NL@%
                                Alert = 1%@NL@%
                            END IF%@NL@%
                            IF UCASE$(b2$) = "CANCEL" THEN%@NL@%
                                Alert = 2%@NL@%
                            END IF%@NL@%
                            IF UCASE$(b3$) = "CANCEL" THEN%@NL@%
                                Alert = 3%@NL@%
                            END IF%@NL@%
                            ExitFlag = TRUE%@NL@%
                        CASE ELSE%@NL@%
                    END SELECT%@NL@%
                WEND%@NL@%
%@NL@%
                WindowClose alertWindow%@NL@%
%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB BackgroundRefresh (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Refresh the background behind a window%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GloWindow(handle).handle > 0 THEN%@NL@%
        MouseHide%@NL@%
        PutBackground GloWindow(handle).row1 - 1, GloWindow(handle).col1 - 1, GloBuffer$(handle, 1)%@NL@%
        MouseShow%@NL@%
    END IF%@NL@%
END SUB%@NL@%
%@NL@%
SUB BackgroundSave (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Save the background before a window opens, or is moved... etc%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GloWindow(handle).handle > 0 THEN%@NL@%
        MouseHide%@NL@%
        GetBackground GloWindow(handle).row1 - 1, GloWindow(handle).col1 - 1, GloWindow(handle).row2 + 1, GloWindow(handle).col2 + 1, GloBuffer$(handle, 1)%@NL@%
        MouseShow%@NL@%
    END IF%@NL@%
END SUB%@NL@%
%@NL@%
SUB ButtonClose (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Make sure a window is actually opened%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
%@NL@%
    IF windo > 0 THEN%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If handle=0, recursively close all buttons in the CURRENT WINDOW only%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF handle = 0 THEN%@NL@%
            IF GloStorage.numButtonsOpen > 0 THEN%@NL@%
                FOR A = GloStorage.numButtonsOpen TO 1 STEP -1%@NL@%
                    IF GloButton(A).windowHandle = windo THEN%@NL@%
                        ButtonClose GloButton(A).handle%@NL@%
                    END IF%@NL@%
                NEXT A%@NL@%
            END IF%@NL@%
        ELSE%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Get the index into the global array based on handle, and%@AE@%%@NL@%
%@AB@%            ' currWindow%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            button = FindButton(handle)%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' If valid, hide button, then squeeze array, decrement totals%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            IF button > 0 THEN%@NL@%
%@NL@%
                COLOR GloWindow(windo).fore, GloWindow(windo).back%@NL@%
                SELECT CASE GloButton(button).buttonType%@NL@%
                    CASE 1, 2, 3%@NL@%
                        LOCATE GloWindow(windo).row1 + GloButton(button).row1 - 1, GloWindow(windo).col1 + GloButton(button).col1 - 1%@NL@%
                        MouseHide%@NL@%
                        PRINT SPACE$(4 + LEN(RTRIM$(GloButton(button).text$)));%@NL@%
                        MouseShow%@NL@%
                    CASE 6%@NL@%
                        MouseHide%@NL@%
                        FOR A = 1 TO GloButton(button).row2 - GloButton(button).row1 + 1%@NL@%
                            LOCATE GloWindow(windo).row1 + GloButton(button).row1 + A - 2, GloWindow(windo).col1 + GloButton(button).col1 - 1%@NL@%
                            PRINT " ";%@NL@%
                        NEXT A%@NL@%
                        MouseShow%@NL@%
                    CASE 7%@NL@%
                        LOCATE GloWindow(windo).row1 + GloButton(button).row1 - 1, GloWindow(windo).col1 + GloButton(button).col1 - 1%@NL@%
                        MouseHide%@NL@%
                        PRINT SPACE$(GloButton(button).col2 - GloButton(button).col1 + 1);%@NL@%
                        MouseShow%@NL@%
                    CASE ELSE%@NL@%
                END SELECT%@NL@%
%@NL@%
%@NL@%
                GloStorage.numButtonsOpen = GloStorage.numButtonsOpen - 1%@NL@%
                WHILE button <= GloStorage.numButtonsOpen%@NL@%
                    GloButton(button).row1 = GloButton(button + 1).row1%@NL@%
                    GloButton(button).col1 = GloButton(button + 1).col1%@NL@%
                    GloButton(button).row2 = GloButton(button + 1).row2%@NL@%
                    GloButton(button).col2 = GloButton(button + 1).col2%@NL@%
                    GloButton(button).text = GloButton(button + 1).text%@NL@%
                    GloButton(button).handle = GloButton(button + 1).handle%@NL@%
                    GloButton(button).state = GloButton(button + 1).state%@NL@%
                    GloButton(button).buttonType = GloButton(button + 1).buttonType%@NL@%
                    GloButton(button).windowHandle = GloButton(button + 1).windowHandle%@NL@%
                    button = button + 1%@NL@%
                WEND%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
FUNCTION ButtonInquire (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If valid, return then state of the button%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    button = FindButton(handle)%@NL@%
%@NL@%
    IF button > 0 THEN%@NL@%
        ButtonInquire = GloButton(button).state%@NL@%
    ELSE%@NL@%
        ButtonInquire = 0%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB ButtonOpen (handle, state, title$, row1, col1, row2, col2, buttonType)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Open a button - first check if window can be resized - If so, do not%@AE@%%@NL@%
%@AB@%    ' open!%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF MID$(WindowBorder$(GloWindow(WindowCurrent).windowType), 9, 1) = "+" THEN%@NL@%
        resize = TRUE%@NL@%
    END IF%@NL@%
%@NL@%
    IF (resize AND buttonType >= 6) OR NOT resize THEN%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If scroll bar, then make sure "state" is valid, given bar length%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF buttonType = 6 THEN%@NL@%
            length = (row2 - row1) - 1%@NL@%
            IF state < 1 THEN state = 1%@NL@%
            IF state > length THEN state = length%@NL@%
        END IF%@NL@%
%@NL@%
        IF buttonType = 7 THEN%@NL@%
            length = (col2 - col1) - 1%@NL@%
            IF state < 1 THEN state = 1%@NL@%
            IF state > length THEN state = length%@NL@%
        END IF%@NL@%
%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If valid state and type, increment totals, and store button info%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF (buttonType = 1 AND state >= 1 AND state <= 3) OR (buttonType >= 2 AND buttonType <= 3 AND state >= 1 AND state <= 2) OR (buttonType >= 4 AND buttonType <= 7) THEN%@NL@%
            ButtonClose handle%@NL@%
%@NL@%
            GloStorage.numButtonsOpen = GloStorage.numButtonsOpen + 1%@NL@%
            GloButton(GloStorage.numButtonsOpen).row1 = row1%@NL@%
            GloButton(GloStorage.numButtonsOpen).col1 = col1%@NL@%
            GloButton(GloStorage.numButtonsOpen).row2 = row2%@NL@%
            GloButton(GloStorage.numButtonsOpen).col2 = col2%@NL@%
            GloButton(GloStorage.numButtonsOpen).text = title$%@NL@%
            GloButton(GloStorage.numButtonsOpen).state = state%@NL@%
            GloButton(GloStorage.numButtonsOpen).handle = handle%@NL@%
            GloButton(GloStorage.numButtonsOpen).buttonType = buttonType%@NL@%
            GloButton(GloStorage.numButtonsOpen).windowHandle = WindowCurrent%@NL@%
            ButtonShow handle%@NL@%
        ELSE%@NL@%
            PRINT "Cannot open button on window that can be re-sized!"%@NL@%
            END%@NL@%
        END IF%@NL@%
    END IF%@NL@%
END SUB%@NL@%
%@NL@%
SUB ButtonSetState (handle, state)%@NL@%
%@NL@%
    button = FindButton(handle)%@NL@%
    windo = WindowCurrent%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If valid state for the type of button, assign the new state, and re-show%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF button > 0 AND windo > 0 THEN%@NL@%
        SELECT CASE GloButton(button).buttonType%@NL@%
            CASE 1%@NL@%
                IF state >= 1 AND state <= 3 THEN%@NL@%
                    GloButton(button).state = state%@NL@%
                END IF%@NL@%
            CASE 2, 3%@NL@%
                IF state = 1 OR state = 2 THEN%@NL@%
                    GloButton(button).state = state%@NL@%
                END IF%@NL@%
            CASE 4, 5%@NL@%
            CASE 6%@NL@%
                IF state <> GloButton(button).state THEN%@NL@%
                    MouseHide%@NL@%
                    COLOR 0, 7%@NL@%
                    LOCATE GloWindow(windo).row1 + GloButton(button).row1 - 1 + GloButton(button).state, GloWindow(windo).col1 + GloButton(button).col1 - 1%@NL@%
                    PRINT CHR$(176);%@NL@%
                    GloButton(button).state = state%@NL@%
                    LOCATE GloWindow(windo).row1 + GloButton(button).row1 - 1 + GloButton(button).state, GloWindow(windo).col1 + GloButton(button).col1 - 1%@NL@%
                    PRINT CHR$(219);%@NL@%
                    MouseShow%@NL@%
                END IF%@NL@%
            CASE 7%@NL@%
                IF state <> GloButton(button).state THEN%@NL@%
                    MouseHide%@NL@%
                    COLOR 0, 7%@NL@%
                    LOCATE GloWindow(windo).row1 + GloButton(button).row1 - 1, GloWindow(windo).col1 + GloButton(button).col1 - 1 + GloButton(button).state%@NL@%
                    PRINT CHR$(176);%@NL@%
                    GloButton(button).state = state%@NL@%
                    LOCATE GloWindow(windo).row1 + GloButton(button).row1 - 1, GloWindow(windo).col1 + GloButton(button).col1 - 1 + GloButton(button).state%@NL@%
                    PRINT CHR$(219);%@NL@%
                    MouseShow%@NL@%
                END IF%@NL@%
            CASE ELSE%@NL@%
        END SELECT%@NL@%
    END IF%@NL@%
%@NL@%
    ButtonShow handle%@NL@%
END SUB%@NL@%
%@NL@%
SUB ButtonShow (handle)%@NL@%
%@NL@%
    button = FindButton(handle)%@NL@%
    windo = WindowCurrent%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If valid, show the button based on button type and button state%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF button > 0 THEN%@NL@%
        LOCATE GloWindow(windo).row1 + GloButton(button).row1 - 1, GloWindow(windo).col1 + GloButton(button).col1 - 1%@NL@%
%@NL@%
        MouseHide%@NL@%
        SELECT CASE GloButton(button).buttonType%@NL@%
            CASE 1%@NL@%
                SELECT CASE GloButton(button).state%@NL@%
                    CASE 1%@NL@%
                        COLOR GloWindow(windo).textFore, GloWindow(windo).textBack%@NL@%
                        PRINT "< " + RTRIM$(GloButton(button).text$) + " >";%@NL@%
                    CASE 2%@NL@%
                        COLOR GloWindow(windo).highlight, GloWindow(windo).textBack%@NL@%
                        PRINT "<";%@NL@%
                        COLOR GloWindow(windo).textFore, GloWindow(windo).textBack%@NL@%
                        PRINT " "; RTRIM$(GloButton(button).text$); " ";%@NL@%
                        COLOR GloWindow(windo).highlight, GloWindow(windo).textBack%@NL@%
                        PRINT ">";%@NL@%
                    CASE 3%@NL@%
                        COLOR GloWindow(windo).textBack, GloWindow(windo).textFore%@NL@%
                        PRINT "< " + RTRIM$(GloButton(button).text$) + " >";%@NL@%
                END SELECT%@NL@%
            CASE 2%@NL@%
                SELECT CASE GloButton(button).state%@NL@%
                    CASE 1%@NL@%
                        COLOR GloWindow(windo).textFore, GloWindow(windo).textBack%@NL@%
                        PRINT "[ ] " + RTRIM$(GloButton(button).text$);%@NL@%
                    CASE 2%@NL@%
                        COLOR GloWindow(windo).textFore, GloWindow(windo).textBack%@NL@%
                        PRINT "[X] " + RTRIM$(GloButton(button).text$);%@NL@%
                END SELECT%@NL@%
            CASE 3%@NL@%
                SELECT CASE GloButton(button).state%@NL@%
                    CASE 1%@NL@%
                        COLOR GloWindow(windo).textFore, GloWindow(windo).textBack%@NL@%
                        PRINT "( ) " + RTRIM$(GloButton(button).text$);%@NL@%
                    CASE 2%@NL@%
                        COLOR GloWindow(windo).textFore, GloWindow(windo).textBack%@NL@%
                        PRINT "() " + RTRIM$(GloButton(button).text$);%@NL@%
                END SELECT%@NL@%
            CASE 4, 5%@NL@%
            CASE 6%@NL@%
                COLOR 0, 7%@NL@%
                PRINT CHR$(24);%@NL@%
                FOR A = 1 TO GloButton(button).row2 - GloButton(button).row1 - 1%@NL@%
                    LOCATE GloWindow(windo).row1 + GloButton(button).row1 - 1 + A, GloWindow(windo).col1 + GloButton(button).col1 - 1%@NL@%
                    IF A = GloButton(button).state THEN%@NL@%
                        PRINT CHR$(219);%@NL@%
                    ELSE%@NL@%
                        PRINT CHR$(176);%@NL@%
                    END IF%@NL@%
                NEXT A%@NL@%
                LOCATE GloWindow(windo).row1 + GloButton(button).row1 - 1 + A, GloWindow(windo).col1 + GloButton(button).col1 - 1%@NL@%
                PRINT CHR$(25);%@NL@%
            CASE 7%@NL@%
                COLOR 0, 7%@NL@%
                PRINT CHR$(27); STRING$(GloButton(button).col2 - GloButton(button).col1 - 1, 176); CHR$(26);%@NL@%
                LOCATE GloWindow(windo).row1 + GloButton(button).row1 - 1, GloWindow(windo).col1 + GloButton(button).col1 - 1 + GloButton(button).state%@NL@%
                PRINT CHR$(219);%@NL@%
            CASE ELSE%@NL@%
                PRINT "Error in Button Parameter";%@NL@%
        END SELECT%@NL@%
        MouseShow%@NL@%
    END IF%@NL@%
END SUB%@NL@%
%@NL@%
SUB ButtonToggle (handle)%@NL@%
%@NL@%
    button = FindButton(handle)%@NL@%
    windo = WindowCurrent%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If valid button, and state is 1 or 2, toggle button%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF button > 0 THEN%@NL@%
        IF GloButton(button).state = 1 OR GloButton(button).state = 2 THEN%@NL@%
           GloButton(button).state = 3 - GloButton(button).state%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
    ButtonShow handle%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
FUNCTION Dialog (op)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Based on global variables set in WindowDo, return proper event ID/Info%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    SELECT CASE op%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Return event ID, and reset all variables.%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        CASE 0%@NL@%
            GloStorage.DialogButton = GloStorage.oldDialogButton%@NL@%
            GloStorage.DialogEdit = GloStorage.oldDialogEdit%@NL@%
            GloStorage.DialogWindow = GloStorage.oldDialogWindow%@NL@%
            GloStorage.DialogClose = GloStorage.oldDialogClose%@NL@%
            GloStorage.DialogScroll = GloStorage.oldDialogScroll%@NL@%
            GloStorage.DialogRow = GloStorage.oldDialogRow%@NL@%
            GloStorage.DialogCol = GloStorage.oldDialogCol%@NL@%
            Dialog = GloStorage.oldDialogEvent%@NL@%
%@NL@%
            GloStorage.oldDialogButton = 0%@NL@%
            GloStorage.oldDialogEdit = 0%@NL@%
            GloStorage.oldDialogWindow = 0%@NL@%
            GloStorage.oldDialogClose = 0%@NL@%
            GloStorage.oldDialogScroll = 0%@NL@%
            GloStorage.oldDialogRow = 0%@NL@%
            GloStorage.oldDialogCol = 0%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If button is pressed, dialog(0) is 1, and dialog(1) is the button%@AE@%%@NL@%
%@AB@%        ' number%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        CASE 1%@NL@%
            Dialog = GloStorage.DialogButton%@NL@%
%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If edit field is clicked, dialog(0) is 2, and dialog(2) is the edit%@AE@%%@NL@%
%@AB@%        ' field number%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        CASE 2%@NL@%
            Dialog = GloStorage.DialogEdit%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If another window is clicked, dialog(0)=3, and dialog(3)=window%@AE@%%@NL@%
%@AB@%        ' number%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        CASE 3%@NL@%
            Dialog = GloStorage.DialogWindow%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If a field button was pressed This returns the row (relative to%@AE@%%@NL@%
%@AB@%        ' window position) of the click%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        CASE 17%@NL@%
            Dialog = GloStorage.DialogRow%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If a field button was pressed This returns the column (relative to%@AE@%%@NL@%
%@AB@%        ' window position) of the click%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        CASE 18%@NL@%
            Dialog = GloStorage.DialogCol%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If a scroll bar was clicked, return new position of marker%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        CASE 19%@NL@%
            Dialog = GloStorage.DialogScroll%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Bad call, so return 0%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        CASE ELSE%@NL@%
            Dialog = 0%@NL@%
    END SELECT%@NL@%
%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB EditFieldClose (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Close an edit field%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
%@NL@%
    IF windo > 0 THEN%@NL@%
        IF handle = 0 THEN%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' If handle = 0, then recursivily close all edit fields%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            IF GloStorage.numEditFieldsOpen > 0 THEN%@NL@%
                FOR A = GloStorage.numEditFieldsOpen TO 1 STEP -1%@NL@%
                    IF GloEdit(A).windowHandle = windo THEN%@NL@%
                        EditFieldClose GloEdit(A).handle%@NL@%
                    END IF%@NL@%
                NEXT A%@NL@%
            END IF%@NL@%
        ELSE%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' else, erase edit field, then squeeze array, decrement total%@AE@%%@NL@%
%@AB@%            ' variables%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            editField = FindEditField(handle)%@NL@%
%@NL@%
            IF editField > 0 THEN%@NL@%
                LOCATE GloWindow(windo).row1 + GloEdit(editField).row - 1, GloWindow(windo).col1 + GloEdit(editField).col - 1%@NL@%
                COLOR GloWindow(windo).fore, GloWindow(windo).back%@NL@%
                MouseHide%@NL@%
                PRINT SPACE$(GloEdit(editField).visLength);%@NL@%
                MouseShow%@NL@%
%@NL@%
                GloStorage.numEditFieldsOpen = GloStorage.numEditFieldsOpen - 1%@NL@%
                WHILE editField <= GloStorage.numEditFieldsOpen%@NL@%
                    GloEdit(editField).row = GloEdit(editField + 1).row%@NL@%
                    GloEdit(editField).col = GloEdit(editField + 1).col%@NL@%
                    GloEdit(editField).text = GloEdit(editField + 1).text%@NL@%
                    GloEdit(editField).handle = GloEdit(editField + 1).handle%@NL@%
                    GloEdit(editField).visLength = GloEdit(editField + 1).visLength%@NL@%
                    GloEdit(editField).maxLength = GloEdit(editField + 1).maxLength%@NL@%
                    GloEdit(editField).windowHandle = GloEdit(editField + 1).windowHandle%@NL@%
                    editField = editField + 1%@NL@%
                WEND%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    END IF%@NL@%
END SUB%@NL@%
%@NL@%
FUNCTION EditFieldInquire$ (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If valid edit field, return the value.  Note edit$ is terminated%@AE@%%@NL@%
%@AB@%    ' by a CHR$(0), or maxLength, or 255 chars.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    editField = FindEditField(handle)%@NL@%
    windo = WindowCurrent%@NL@%
    EditFieldInquire$ = ""%@NL@%
%@NL@%
    IF editField > 0 THEN%@NL@%
        x$ = GloEdit(editField).text$%@NL@%
        x = INSTR(x$, CHR$(0)) - 1%@NL@%
        IF x >= 0 THEN%@NL@%
            EditFieldInquire$ = LEFT$(x$, x)%@NL@%
        ELSE%@NL@%
            EditFieldInquire$ = x$%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB EditFieldOpen (handle, text$, row, col, fore, back, visLength, maxLength)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If window can be re-sized, do not open edit field%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF MID$(WindowBorder$(GloWindow(WindowCurrent).windowType), 9, 1) <> "+" THEN%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Close edit field by the same handle if it exists%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        EditFieldClose handle%@NL@%
%@NL@%
        windo = WindowCurrent%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If no colors given, use default window colors%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF fore = 0 AND back = 0 THEN%@NL@%
            fore = GloWindow(windo).fore%@NL@%
            back = GloWindow(windo).back%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Increment totals, and store edit field info%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        GloStorage.numEditFieldsOpen = GloStorage.numEditFieldsOpen + 1%@NL@%
        GloEdit(GloStorage.numEditFieldsOpen).row = row%@NL@%
        GloEdit(GloStorage.numEditFieldsOpen).col = col%@NL@%
        GloEdit(GloStorage.numEditFieldsOpen).fore = fore%@NL@%
        GloEdit(GloStorage.numEditFieldsOpen).back = back%@NL@%
        GloEdit(GloStorage.numEditFieldsOpen).text = text$ + CHR$(0)%@NL@%
        GloEdit(GloStorage.numEditFieldsOpen).visLength = visLength%@NL@%
        GloEdit(GloStorage.numEditFieldsOpen).maxLength = maxLength%@NL@%
        GloEdit(GloStorage.numEditFieldsOpen).windowHandle = windo%@NL@%
        GloEdit(GloStorage.numEditFieldsOpen).handle = handle%@NL@%
%@NL@%
        LOCATE GloWindow(windo).row1 + row - 1, GloWindow(windo).col1 + col - 1%@NL@%
        COLOR fore, back%@NL@%
%@NL@%
%@AB@%        'Create temp$ so that padding with spaces doesn't alter the original text$%@AE@%%@NL@%
        IF LEN(text$) < visLength THEN%@NL@%
            temp$ = text$ + SPACE$(visLength - LEN(text$))%@NL@%
        ELSE%@NL@%
            temp$ = LEFT$(text$, visLength)%@NL@%
        END IF%@NL@%
        PRINT temp$;%@NL@%
%@NL@%
    ELSE%@NL@%
        PRINT "EditField cannot be opened on a window that can be re-sized!"%@NL@%
    END IF%@NL@%
END SUB%@NL@%
%@NL@%
FUNCTION FindButton (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Given a handle, return the index into the global array that stores%@AE@%%@NL@%
%@AB@%    ' buttons.  Each button is uniquely described by a handle, and a window#%@AE@%%@NL@%
%@AB@%    ' This SUB program assumes that you want the current window.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    FindButton = 0%@NL@%
%@NL@%
    IF GloStorage.numButtonsOpen > 0 THEN%@NL@%
        A = 0%@NL@%
        curr = WindowCurrent%@NL@%
        DO%@NL@%
            A = A + 1%@NL@%
        LOOP UNTIL (GloButton(A).handle = handle AND GloButton(A).windowHandle = curr) OR A = GloStorage.numButtonsOpen%@NL@%
%@NL@%
        IF GloButton(A).handle = handle AND GloButton(A).windowHandle = curr THEN%@NL@%
            FindButton = A%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
FUNCTION FindEditField (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Given a handle, return the index into the global array that stores%@AE@%%@NL@%
%@AB@%    ' edit fields.  Each button is uniquely described by a handle, and a%@AE@%%@NL@%
%@AB@%    ' window number. This SUB program assumes the you want the current window.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    FindEditField = 0%@NL@%
%@NL@%
    IF GloStorage.numEditFieldsOpen > 0 THEN%@NL@%
        A = 0%@NL@%
        curr = WindowCurrent%@NL@%
        DO%@NL@%
            A = A + 1%@NL@%
        LOOP UNTIL (GloEdit(A).handle = handle AND GloEdit(A).windowHandle = curr) OR A = GloStorage.numEditFieldsOpen%@NL@%
%@NL@%
        IF GloEdit(A).handle = handle AND GloEdit(A).windowHandle = curr THEN%@NL@%
            FindEditField = A%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@AB@%' ==========================================================================%@AE@%%@NL@%
%@AB@%' The ListBox FUNCTION can be modified to accept a box width parameter. This%@AE@%%@NL@%
%@AB@%' will enable you to specify the width of a listbox when you call the ListBox%@AE@%%@NL@%
%@AB@%' FUNCTION. Below you will find two FUNCTION statements. The first is the%@AE@%%@NL@%
%@AB@%' default ListBox FUNCTION that takes only two arguments.  The second allows%@AE@%%@NL@%
%@AB@%' you to specify a box width parameter. As configured, the listbox width is%@AE@%%@NL@%
%@AB@%' assumed to be 14. This default is idal for listboxes that contain file%@AE@%%@NL@%
%@AB@%' names. To use the second form of the ListBox FUNCTION, that%@AE@%%@NL@%
%@AB@%' lets you specify the listbox width, comment out the first FUNCTION%@AE@%%@NL@%
%@AB@%' statement and remove the ' from the beginning of the second FUNCTION%@AE@%%@NL@%
%@AB@%' statement. Change the WINDOW.BI file so that the DECLARE statement matches%@AE@%%@NL@%
%@AB@%' the actual FUNCTION as follows:%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' DECLARE FUNCTION ListBox (Text$(), MaxRec%, BoxWidth%)%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' You also need to comment out the "BoxWidth = 14" statement that occurs just the%@AE@%%@NL@%
%@AB@%' after second FUNCTION statement.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' When you use the ListBox FUNCTION be sure to include a box width parameter%@AE@%%@NL@%
%@AB@%' as the third argument.  All calculations will be automatically performed%@AE@%%@NL@%
%@AB@%' to properly display the listbox.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION ListBox (text$(), MaxRec)%@NL@%
%@AB@%'FUNCTION ListBox (text$(), MaxRec, BoxWidth)%@AE@%%@NL@%
%@NL@%
%@AB@%    ' Comment out the following line if you modify this function to allow%@AE@%%@NL@%
%@AB@%    ' specification of a ListBox width parameter in the function call.%@AE@%%@NL@%
%@NL@%
    BoxWidth = 14%@NL@%
%@NL@%
    GOSUB ListBoxWidthCalc%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Open up a modal window and put the right buttons in it%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    WindowOpen 1, 4, StartRowPos, 20, StopRowPos, 0, 7, 0, 7, 15, 0, 0, 0, 1, 1, ""%@NL@%
%@NL@%
    WindowBox 1, 6, 14, BoxEndPos%@NL@%
    ButtonOpen 1, 1, "", 2, BoxEndPos, 13, BoxEndPos, 6     'Scroll Bar%@NL@%
    ButtonOpen 2, 2, "OK", 16, 6, 0, 0, 1                   'OK button%@NL@%
    ButtonOpen 3, 1, "Cancel", 16, BoxEndPos - 9, 0, 0, 1   'Cancel button%@NL@%
    ButtonOpen 4, 1, "", 1, 8, 1, AreaEndPos, 4             'Area above box%@NL@%
    ButtonOpen 5, 1, "", 2, 7, 13, AreaEndPos + 1, 4        'Area of box%@NL@%
    ButtonOpen 6, 1, "", 14, 8, 14, AreaEndPos, 4           'Area below box%@NL@%
%@NL@%
    currTop = 1%@NL@%
    currPos = 1%@NL@%
    currButton = 2%@NL@%
%@NL@%
    GOSUB ListBoxDrawText%@NL@%
%@NL@%
    ExitFlag = FALSE%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Process window events...%@AE@%%@NL@%
%@AB@%    '  IMPORTANT:  Window moving, and re-sizing is handled automatically%@AE@%%@NL@%
%@AB@%    '  The window type dictates when this is allowed to happen.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    WHILE NOT ExitFlag%@NL@%
        WindowDo currButton, 0%@NL@%
        x = Dialog(0)%@NL@%
%@NL@%
        SELECT CASE x%@NL@%
            CASE 1%@NL@%
                button = Dialog(1)%@NL@%
                SELECT CASE button%@NL@%
                    CASE 1%@NL@%
                        scrollCode = Dialog(19)%@NL@%
                        SELECT CASE scrollCode%@NL@%
                            CASE -1:   GOSUB ListBoxUp%@NL@%
                            CASE -2:   GOSUB ListBoxDown%@NL@%
                            CASE ELSE: GOSUB ListBoxMove%@NL@%
                        END SELECT%@NL@%
                    CASE 2%@NL@%
                        ListBox = currTop + currPos - 1%@NL@%
                        ExitFlag = TRUE%@NL@%
                    CASE 3%@NL@%
                        ListBox = 0%@NL@%
                        ExitFlag = TRUE%@NL@%
                    CASE 4%@NL@%
                        GOSUB ListBoxUp%@NL@%
                    CASE 5%@NL@%
                        GOSUB ListBoxAssign%@NL@%
                    CASE 6%@NL@%
                        GOSUB ListBoxDown%@NL@%
                END SELECT%@NL@%
            CASE 6, 14%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0, 2%@NL@%
                        ListBox = currTop + currPos - 1%@NL@%
                        ExitFlag = TRUE%@NL@%
                    CASE 3%@NL@%
                        ListBox = 0%@NL@%
                        ExitFlag = TRUE%@NL@%
                    CASE ELSE%@NL@%
                END SELECT%@NL@%
            CASE 7%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0%@NL@%
                        currButton = 2%@NL@%
                    CASE 2%@NL@%
                        ButtonToggle 2%@NL@%
                        ButtonToggle 3%@NL@%
                        currButton = 3%@NL@%
                    CASE 3%@NL@%
                        ButtonToggle 2%@NL@%
                        ButtonToggle 3%@NL@%
                        currButton = 0%@NL@%
                END SELECT%@NL@%
            CASE 8%@NL@%
                SELECT CASE currButton%@NL@%
                    CASE 0%@NL@%
                        ButtonToggle 2%@NL@%
                        ButtonToggle 3%@NL@%
                        currButton = 3%@NL@%
                    CASE 2%@NL@%
                        currButton = 0%@NL@%
                    CASE 3%@NL@%
                        ButtonToggle 2%@NL@%
                        ButtonToggle 3%@NL@%
                        currButton = 2%@NL@%
                END SELECT%@NL@%
            CASE 9%@NL@%
                ListBox = 0%@NL@%
                ExitFlag = TRUE%@NL@%
            CASE 10, 12%@NL@%
                IF currButton = 0 THEN%@NL@%
                    GOSUB ListBoxUp%@NL@%
                END IF%@NL@%
            CASE 11, 13%@NL@%
                IF currButton = 0 THEN%@NL@%
                    GOSUB ListBoxDown%@NL@%
                END IF%@NL@%
            CASE 16%@NL@%
                scrollCode = 1%@NL@%
                GOSUB ListBoxMove%@NL@%
            CASE 17%@NL@%
                scrollCode = 10%@NL@%
                GOSUB ListBoxMove%@NL@%
            CASE 18%@NL@%
                GOSUB ListBoxPgUp%@NL@%
            CASE 19%@NL@%
                GOSUB ListBoxPgDn%@NL@%
            CASE ELSE%@NL@%
        END SELECT%@NL@%
    WEND%@NL@%
%@NL@%
    WindowClose 0%@NL@%
    EXIT FUNCTION%@NL@%
%@NL@%
ListBoxUp:%@NL@%
    oldRec = currTop + currPos - 1%@NL@%
    currPos = currPos - 1%@NL@%
    IF currPos < 1 THEN%@NL@%
        currPos = 1%@NL@%
        currTop = currTop - 1%@NL@%
        IF currTop < 1 THEN%@NL@%
            currTop = 1%@NL@%
        END IF%@NL@%
    END IF%@NL@%
    newRec = currTop + currPos - 1%@NL@%
    IF oldRec <> newRec THEN%@NL@%
        GOSUB ListBoxDrawText%@NL@%
        GOSUB ListBoxNewBarPos%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
ListBoxDown:%@NL@%
    oldRec = currTop + currPos - 1%@NL@%
    IF MaxRec > 12 THEN%@NL@%
        currPos = currPos + 1%@NL@%
        IF currPos > 12 THEN%@NL@%
            currPos = 12%@NL@%
            currTop = currTop + 1%@NL@%
            IF currTop + currPos - 1 > MaxRec THEN%@NL@%
                currTop = currTop - 1%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
        IF currPos + 1 <= MaxRec THEN%@NL@%
            currPos = currPos + 1%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
    newRec = currTop + currPos - 1%@NL@%
    IF oldRec <> newRec THEN%@NL@%
        GOSUB ListBoxDrawText%@NL@%
        GOSUB ListBoxNewBarPos%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
ListBoxPgUp:%@NL@%
    oldRec = currTop + currPos - 1%@NL@%
    currTop = currTop - 12%@NL@%
    IF currTop < 1 THEN%@NL@%
        currTop = 1%@NL@%
        currPos = 1%@NL@%
    END IF%@NL@%
    newRec = currTop + currPos - 1%@NL@%
    IF oldRec <> newRec THEN%@NL@%
        GOSUB ListBoxDrawText%@NL@%
        GOSUB ListBoxNewBarPos%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
ListBoxPgDn:%@NL@%
    oldRec = currTop + currPos - 1%@NL@%
    IF MaxRec > 12 THEN%@NL@%
        currTop = currTop + 12%@NL@%
            IF currTop + 12 > MaxRec THEN%@NL@%
                currTop = MaxRec - 11%@NL@%
                currPos = 12%@NL@%
            END IF%@NL@%
    ELSE%@NL@%
        currPos = MaxRec%@NL@%
    END IF%@NL@%
%@NL@%
    newRec = currTop + currPos - 1%@NL@%
    IF oldRec <> newRec THEN%@NL@%
        GOSUB ListBoxDrawText%@NL@%
        GOSUB ListBoxNewBarPos%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
ListBoxAssign:%@NL@%
    currPos = Dialog(17)%@NL@%
    IF currPos > MaxRec THEN currPos = MaxRec%@NL@%
    GOSUB ListBoxDrawText%@NL@%
    GOSUB ListBoxNewBarPos%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
ListBoxMove:%@NL@%
    SELECT CASE scrollCode%@NL@%
        CASE 1:      newPos = 1%@NL@%
        CASE 2 TO 9: newPos = scrollCode * MaxRec / 10%@NL@%
        CASE 10:     newPos = MaxRec%@NL@%
    END SELECT%@NL@%
%@NL@%
    IF newPos < 1 THEN newPos = 1%@NL@%
    IF newPos > MaxRec THEN newPos = MaxRec%@NL@%
%@NL@%
    currPos = newPos - currTop + 1%@NL@%
    IF currPos <= 0 THEN%@NL@%
        currTop = newPos%@NL@%
        currPos = 1%@NL@%
    ELSEIF currPos > 12 THEN%@NL@%
        currPos = 12%@NL@%
        currTop = newPos - 11%@NL@%
    END IF%@NL@%
    GOSUB ListBoxDrawText%@NL@%
    GOSUB ListBoxNewBarPos%@NL@%
RETURN%@NL@%
%@NL@%
ListBoxDrawText:%@NL@%
    FOR A = currTop TO currTop + 11%@NL@%
        IF A <= MaxRec THEN%@NL@%
            IF currTop + currPos - 1 = A THEN%@NL@%
                WindowColor 7, 0%@NL@%
            ELSE%@NL@%
                WindowColor 0, 7%@NL@%
            END IF%@NL@%
%@NL@%
            WindowLocate A - currTop + 2, 8%@NL@%
            WindowPrint -1, LEFT$(text$(A) + STRING$(BoxWidth + 1, " "), BoxWidth + 1)%@NL@%
        END IF%@NL@%
    NEXT A%@NL@%
    WindowColor 0, 7%@NL@%
    RETURN%@NL@%
%@NL@%
ListBoxNewBarPos:%@NL@%
    IF currPos = 1 AND currTop = 1 THEN%@NL@%
        newState = 1%@NL@%
    ELSE%@NL@%
        newState = (currTop + currPos - 1) * 10 / MaxRec%@NL@%
        IF newState < 1 THEN newState = 1%@NL@%
        IF newState > 10 THEN newState = 10%@NL@%
    END IF%@NL@%
    ButtonSetState 1, newState%@NL@%
RETURN%@NL@%
%@NL@%
ListBoxWidthCalc:%@NL@%
    IF BoxWidth < 14 THEN BoxWidth = 14%@NL@%
    IF BoxWidth > 55 THEN BoxWidth = 55%@NL@%
    StartRowPos = 40 - ((BoxWidth + 14) / 2)%@NL@%
    StopRowPos = StartRowPos + BoxWidth + 14%@NL@%
    BoxEndPos = BoxWidth + 10%@NL@%
    AreaEndPos = BoxWidth + 8%@NL@%
RETURN%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
FUNCTION MaxScrollLength (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If valid, return then maximum length of scroll bar%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    button = FindButton(handle)%@NL@%
%@NL@%
    IF button > 0 THEN%@NL@%
        SELECT CASE GloButton(button).buttonType%@NL@%
            CASE 6%@NL@%
                MaxScrollLength = GloButton(button).row2 - GloButton(button).row1 - 1%@NL@%
            CASE 7%@NL@%
                MaxScrollLength = GloButton(button).col2 - GloButton(button).col1 - 1%@NL@%
            CASE ELSE%@NL@%
                MaxScrollLength = 0%@NL@%
        END SELECT%@NL@%
    ELSE%@NL@%
        MaxScrollLength = 0%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
FUNCTION WhichWindow (row, col)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Returns the window number where the row,col points to.  Takes into%@AE@%%@NL@%
%@AB@%    ' account which windows overlap which other windows by going down%@AE@%%@NL@%
%@AB@%    ' the GloWindowStack from the top.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    x = GloStorage.numWindowsOpen%@NL@%
    Found = FALSE%@NL@%
    WhichWindow = 0%@NL@%
%@NL@%
    WHILE x > 0 AND NOT Found%@NL@%
        handle = GloWindowStack(x)%@NL@%
        row1 = GloWindow(handle).row1 - 1%@NL@%
        col1 = GloWindow(handle).col1 - 1%@NL@%
        row2 = GloWindow(handle).row2 + 1%@NL@%
        col2 = GloWindow(handle).col2 + 1%@NL@%
%@NL@%
        IF row >= row1 AND row <= row2 AND col >= col1 AND col <= col2 THEN%@NL@%
            WhichWindow = handle%@NL@%
            Found = TRUE%@NL@%
        ELSE%@NL@%
            x = x - 1%@NL@%
        END IF%@NL@%
    WEND%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
FUNCTION WindowBorder$ (windowType)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Returns a window border for the given window type.%@AE@%%@NL@%
%@AB@%    ' You may customize this to create custom windows.  See external%@AE@%%@NL@%
%@AB@%    ' documentation for a discussion of window borders%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    SELECT CASE ABS(windowType)%@NL@%
        CASE 1%@NL@%
            WindowBorder$ = "           ST"%@NL@%
        CASE 2%@NL@%
            WindowBorder$ = "=           ST"%@NL@%
        CASE 3%@NL@%
            WindowBorder$ = "=          ST"%@NL@%
        CASE 4%@NL@%
            WindowBorder$ = "        +   ST"%@NL@%
        CASE 5%@NL@%
            WindowBorder$ = "       +   ST"%@NL@%
        CASE 6%@NL@%
            WindowBorder$ = "=       +   ST"%@NL@%
        CASE 7%@NL@%
            WindowBorder$ = "=      +   ST"%@NL@%
        CASE 8%@NL@%
            WindowBorder$ = " ST"%@NL@%
        CASE 9%@NL@%
            WindowBorder$ = " ST"%@NL@%
        CASE 10%@NL@%
            WindowBorder$ = "= ST"%@NL@%
        CASE 11%@NL@%
            WindowBorder$ = "= ST"%@NL@%
        CASE 12%@NL@%
            WindowBorder$ = " +ST"%@NL@%
        CASE 13%@NL@%
            WindowBorder$ = " +ST"%@NL@%
        CASE 14%@NL@%
            WindowBorder$ = "= +ST"%@NL@%
        CASE 15%@NL@%
            WindowBorder$ = "= +ST"%@NL@%
        CASE 16%@NL@%
            WindowBorder$ = " ST"%@NL@%
        CASE 17%@NL@%
            WindowBorder$ = " ST"%@NL@%
        CASE 18%@NL@%
            WindowBorder$ = "= ST"%@NL@%
        CASE 19%@NL@%
            WindowBorder$ = "= ST"%@NL@%
        CASE 20%@NL@%
            WindowBorder$ = " +ST"%@NL@%
        CASE 21%@NL@%
            WindowBorder$ = " +ST"%@NL@%
        CASE 22%@NL@%
            WindowBorder$ = "= +ST"%@NL@%
        CASE 23%@NL@%
            WindowBorder$ = "= +ST"%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Put any custom-designed border styles after this point and before%@AE@%%@NL@%
%@AB@%        ' the CASE ELSE statement.%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        CASE ELSE%@NL@%
            WindowBorder$ = "            ST"%@NL@%
%@NL@%
    END SELECT%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB WindowBox (boxRow1, boxCol1, boxRow2, boxCol2)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Draw a box, given coordinates based on the current window%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
    IF windo > 0 THEN%@NL@%
        row1 = GloWindow(windo).row1 + boxRow1 - 1%@NL@%
        row2 = GloWindow(windo).row1 + boxRow2 - 1%@NL@%
        col1 = GloWindow(windo).col1 + boxCol1 - 1%@NL@%
        col2 = GloWindow(windo).col1 + boxCol2 - 1%@NL@%
        fore = GloWindow(windo).fore%@NL@%
        back = GloWindow(windo).back%@NL@%
        border$ = " "%@NL@%
%@NL@%
        Box row1, col1, row2, col2, fore, back, border$, 0%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowClose (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Close window # handle.  If handle is 0, recursively close all windows%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF handle = 0 THEN%@NL@%
        IF GloStorage.numWindowsOpen > 0 THEN%@NL@%
            FOR x = GloStorage.numWindowsOpen TO 1 STEP -1%@NL@%
                WindowClose GloWindowStack(x)%@NL@%
            NEXT x%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If valid window,%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF GloWindow(handle).handle <> -1 THEN%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Make the window you want to close the top window%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            WindowSetCurrent handle%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' If top window has shadow, hide shadow%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            IF INSTR(WindowBorder$(GloWindow(GloStorage.currWindow).windowType), "S") THEN%@NL@%
                WindowShadowRefresh%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Close all edit fields, and button on top window%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            EditFieldClose 0%@NL@%
            ButtonClose 0%@NL@%
            MouseHide%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Restore the background of the window + clear data%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            BackgroundRefresh handle%@NL@%
%@NL@%
            GloBuffer$(handle, 1) = ""%@NL@%
            GloBuffer$(handle, 2) = ""%@NL@%
%@NL@%
            GloWindow(handle).handle = -1%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Decrement total number of windows%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            GloStorage.numWindowsOpen = GloStorage.numWindowsOpen - 1%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' If some windows still open, assign curr Window to top window,%@AE@%%@NL@%
%@AB@%            ' show shadow is the currWindow has a shadow%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            IF GloStorage.numWindowsOpen > 0 THEN%@NL@%
                GloStorage.currWindow = GloWindowStack(GloStorage.numWindowsOpen)%@NL@%
%@NL@%
                IF INSTR(WindowBorder$(GloWindow(GloStorage.currWindow).windowType), "S") THEN%@NL@%
                    WindowShadowSave%@NL@%
                END IF%@NL@%
            ELSE%@NL@%
%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
%@AB@%                ' If no more windows open, assign 0 to the currWindow variable%@AE@%%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
%@NL@%
                GloStorage.currWindow = 0%@NL@%
            END IF%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowCls%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If curr window is valid, clear the window%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
    IF windo > 0 THEN%@NL@%
        WindowScroll 0%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowColor (fore, back)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If curr window is valid, assign the colors to the variables%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
    IF windo > 0 THEN%@NL@%
        GloWindow(windo).textFore = fore%@NL@%
        GloWindow(windo).textBack = back%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
FUNCTION WindowCols (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If window Handle is valid, return number of columns in that window%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GloWindow(handle).handle > 0 THEN%@NL@%
        WindowCols = GloWindow(handle).col2 - GloWindow(handle).col1 + 1%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
FUNCTION WindowCurrent%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Simply return the current window, as stored in the global array%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    WindowCurrent = GloStorage.currWindow%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB WindowDo (startButton, startEdit)%@NL@%
%@NL@%
  DIM RB$(1 TO 4)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Main Processing loop.  Init, go to proper mode, exit%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    GOSUB WindowDoInit%@NL@%
    GOSUB WindowDoComputeHotSpots%@NL@%
%@NL@%
    IF WindowDoMode = 1 THEN%@NL@%
        GOSUB WindowDoEditMode%@NL@%
    ELSE%@NL@%
        GOSUB WindowDoButtonMode%@NL@%
    END IF%@NL@%
    LOCATE , , 0%@NL@%
    EXIT SUB%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' If startEdit is=0 then do button mode.  In button mode, we wait%@AE@%%@NL@%
%@AB@%' for any keyboard event or mouse event that flips the ExitFlag.%@AE@%%@NL@%
%@AB@%' Then we exit.  It's very simple really, don't try to make it complicated.%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoButtonMode:%@NL@%
    GOSUB WindowDoShowTextCursor%@NL@%
    WHILE NOT ExitFlag%@NL@%
        GOSUB WindowDoMouse%@NL@%
        GOSUB WindowDoButtonKbd%@NL@%
    WEND%@NL@%
    GOSUB WindowDoHideTextCursor%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' If startEdit>0 then go to edit mode.  Here we also wait for a mouse event%@AE@%%@NL@%
%@AB@%' or kbd event to flip the ExitFlag, but in the mean time, we trap the%@AE@%%@NL@%
%@AB@%' alphanumberic keys, and arrow keys, and use them to edit the current%@AE@%%@NL@%
%@AB@%' edit field.  (StartEdit is the current edit field.)  Again, there's no magic.%@AE@%%@NL@%
%@AB@%' (well maybe just a little...)%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoEditMode:%@NL@%
    GOSUB WindowDoEditInit%@NL@%
    WHILE NOT ExitFlag%@NL@%
        GOSUB WindowDoMouse%@NL@%
        GOSUB WindowDoEditKbd%@NL@%
    WEND%@NL@%
    GOSUB WindowDoEditExit%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Set initial flags, determine where cursor should be located, and figure%@AE@%%@NL@%
%@AB@%' out which mode we should be in (edit mode or button mode)%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoInit:%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Simply abort if there is no window open.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
    IF windo = 0 THEN EXIT SUB%@NL@%
%@NL@%
    REDIM HSClick(MAXHOTSPOT) AS hotSpotType%@NL@%
    REDIM HSRel(MAXHOTSPOT) AS hotSpotType%@NL@%
%@NL@%
    ExitFlag = FALSE%@NL@%
    ButtonHighLight = FALSE%@NL@%
%@NL@%
    border$ = WindowBorder$(GloWindow(windo).windowType)%@NL@%
    WindowDoMode = 2%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If startEdit>0, assign the index value to currEditField, and set%@AE@%%@NL@%
%@AB@%    ' WindowDoMode to 1%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF startEdit > 0 THEN%@NL@%
        index = FindEditField(startEdit)%@NL@%
        IF index > 0 THEN%@NL@%
            currEditField = index%@NL@%
            WindowDoMode = 1%@NL@%
            origCursorRow = GloWindow(windo).row1 + GloEdit(index).row - 1%@NL@%
            origCursorCol = GloWindow(windo).col1 + GloEdit(index).col - 1%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If start button>0, then set current cursor location properly%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF startButton > 0 THEN%@NL@%
        index = FindButton(startButton)%@NL@%
        IF index > 0 THEN%@NL@%
            currButton = index%@NL@%
            origCursorRow = GloWindow(windo).row1 + GloButton(index).row1 - 1%@NL@%
            origCursorCol = GloWindow(windo).col1 + GloButton(index).col1%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' For area buttons decrement the cursor position%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            SELECT CASE GloButton(index).buttonType%@NL@%
                CASE 4%@NL@%
                    origCursorCol = origCursorCol - 1%@NL@%
                CASE ELSE%@NL@%
            END SELECT%@NL@%
%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
    currCursorRow = origCursorRow%@NL@%
    currCursorCol = origCursorCol%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Checks buttons, editfields, etc. and stores where the hot spots are%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoComputeHotSpots:%@NL@%
    numHSClick = 0%@NL@%
    numHSRel = 0%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If upper left corder of border is "=", then that's a close box%@AE@%%@NL@%
%@AB@%    ' Furthermore, a close box is a release type event so store in HSRel%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF MID$(border$, 1, 1) = "=" THEN%@NL@%
        numHSRel = numHSRel + 1%@NL@%
        HSRel(numHSRel).row1 = GloWindow(windo).row1 - 1%@NL@%
        HSRel(numHSRel).row2 = GloWindow(windo).row1 - 1%@NL@%
        HSRel(numHSRel).col1 = GloWindow(windo).col1 - 1%@NL@%
        HSRel(numHSRel).col2 = GloWindow(windo).col1 - 1%@NL@%
        HSRel(numHSRel).action = 4%@NL@%
        HSRel(numHSRel).misc = windo%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If lower right corner is "+", then that's a re-size box%@AE@%%@NL@%
%@AB@%    ' Further more, a re-size box is a click event, so store in HSClick%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF MID$(border$, 9, 1) = "+" THEN%@NL@%
        numHSClick = numHSClick + 1%@NL@%
        HSClick(numHSClick).row1 = GloWindow(windo).row2 + 1%@NL@%
        HSClick(numHSClick).row2 = GloWindow(windo).row2 + 1%@NL@%
        HSClick(numHSClick).col1 = GloWindow(windo).col2 + 1%@NL@%
        HSClick(numHSClick).col2 = GloWindow(windo).col2 + 1%@NL@%
        HSClick(numHSClick).action = 5%@NL@%
        HSClick(numHSClick).misc = 0%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Likewise, a "" chr$(176) is a move bar.  That's also a click event%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF MID$(border$, 2, 1) = "" THEN%@NL@%
        numHSClick = numHSClick + 1%@NL@%
        HSClick(numHSClick).row1 = GloWindow(windo).row1 - 1%@NL@%
        HSClick(numHSClick).row2 = GloWindow(windo).row1 - 1%@NL@%
        HSClick(numHSClick).col1 = GloWindow(windo).col1%@NL@%
        HSClick(numHSClick).col2 = GloWindow(windo).col2%@NL@%
        HSClick(numHSClick).action = 15%@NL@%
        HSClick(numHSClick).misc = 0%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Buttons are click, and release events.%@AE@%%@NL@%
%@AB@%    ' Click, and the cursor goes there, and the button is highlighted.%@AE@%%@NL@%
%@AB@%    ' Release, and the selection is made%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GloStorage.numButtonsOpen > 0 THEN%@NL@%
        button = 0%@NL@%
        WHILE button < GloStorage.numButtonsOpen%@NL@%
            button = button + 1%@NL@%
            IF GloButton(button).windowHandle = windo THEN%@NL@%
                numHSClick = numHSClick + 1%@NL@%
                HSClick(numHSClick).row1 = GloWindow(windo).row1 + GloButton(button).row1 - 1%@NL@%
                HSClick(numHSClick).row2 = GloWindow(windo).row1 + GloButton(button).row1 - 1%@NL@%
                HSClick(numHSClick).col1 = GloWindow(windo).col1 + GloButton(button).col1 - 1%@NL@%
                HSClick(numHSClick).col2 = GloWindow(windo).col1 + GloButton(button).col1 + 2 + LEN(RTRIM$(GloButton(button).text$))%@NL@%
                HSClick(numHSClick).action = 1%@NL@%
                HSClick(numHSClick).misc = GloButton(button).handle%@NL@%
                HSClick(numHSClick).misc2 = GloButton(button).buttonType%@NL@%
%@NL@%
                numHSRel = numHSRel + 1%@NL@%
                HSRel(numHSRel).row1 = GloWindow(windo).row1 + GloButton(button).row1 - 1%@NL@%
                HSRel(numHSRel).row2 = GloWindow(windo).row1 + GloButton(button).row1 - 1%@NL@%
                HSRel(numHSRel).col1 = GloWindow(windo).col1 + GloButton(button).col1 - 1%@NL@%
                HSRel(numHSRel).col2 = GloWindow(windo).col1 + GloButton(button).col1 + 2 + LEN(RTRIM$(GloButton(button).text$))%@NL@%
                HSRel(numHSRel).action = 1%@NL@%
                HSRel(numHSRel).misc = GloButton(button).handle%@NL@%
                HSRel(numHSRel).misc2 = GloButton(button).buttonType%@NL@%
%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
%@AB@%                ' Adjust previous info to handle special cases for%@AE@%%@NL@%
%@AB@%                ' "field" buttons, and "scroll bar" buttons.%@AE@%%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
%@NL@%
                SELECT CASE GloButton(button).buttonType%@NL@%
                    CASE 4%@NL@%
                        numHSRel = numHSRel - 1%@NL@%
                        HSClick(numHSClick).row2 = GloWindow(windo).row1 + GloButton(button).row2 - 1%@NL@%
                        HSClick(numHSClick).col2 = GloWindow(windo).col1 + GloButton(button).col2 - 1%@NL@%
                    CASE 5%@NL@%
                        numHSClick = numHSClick - 1%@NL@%
                        HSRel(numHSRel).row2 = GloWindow(windo).row1 + GloButton(button).row2 - 1%@NL@%
                        HSRel(numHSRel).col2 = GloWindow(windo).col1 + GloButton(button).col2 - 1%@NL@%
                    CASE 6%@NL@%
                        numHSRel = numHSRel - 1%@NL@%
                        HSClick(numHSClick).row2 = GloWindow(windo).row1 + GloButton(button).row2 - 1%@NL@%
                        HSClick(numHSClick).col2 = GloWindow(windo).col1 + GloButton(button).col1 - 1%@NL@%
                    CASE 7%@NL@%
                        numHSRel = numHSRel - 1%@NL@%
                        HSClick(numHSClick).row2 = GloWindow(windo).row1 + GloButton(button).row1 - 1%@NL@%
                        HSClick(numHSClick).col2 = GloWindow(windo).col1 + GloButton(button).col2 - 1%@NL@%
                    CASE ELSE%@NL@%
                END SELECT%@NL@%
            END IF%@NL@%
        WEND%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' EditFields are Click events%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GloStorage.numEditFieldsOpen > 0 THEN%@NL@%
        editField = 0%@NL@%
        WHILE editField < GloStorage.numEditFieldsOpen%@NL@%
            editField = editField + 1%@NL@%
            IF GloEdit(editField).windowHandle = windo THEN%@NL@%
                numHSClick = numHSClick + 1%@NL@%
                HSClick(numHSClick).row1 = GloWindow(windo).row1 + GloEdit(editField).row - 1%@NL@%
                HSClick(numHSClick).row2 = GloWindow(windo).row1 + GloEdit(editField).row - 1%@NL@%
                HSClick(numHSClick).col1 = GloWindow(windo).col1 + GloEdit(editField).col - 1%@NL@%
                HSClick(numHSClick).col2 = GloWindow(windo).col1 + GloEdit(editField).col + GloEdit(editField).visLength - 1%@NL@%
                HSClick(numHSClick).action = 2%@NL@%
                HSClick(numHSClick).misc = GloEdit(editField).handle%@NL@%
            END IF%@NL@%
        WEND%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Feel free to add your own hot spots!  One good idea is if the%@AE@%%@NL@%
%@AB@%    ' right hand side of the border is , make that a scroll bar!  Adding%@AE@%%@NL@%
%@AB@%    ' that would be good practice -- and fun too!%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Polls the mouse%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoMouse:%@NL@%
%@NL@%
    MousePoll MouseRow, MouseCol, lButton, rButton%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If lButton is down, then keep checking for click events until it's released%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF lButton THEN%@NL@%
        WHILE lButton AND MouseRow <> 1 AND NOT ExitFlag%@NL@%
            GOSUB WindowDoCheckClickEvent%@NL@%
            IF Found THEN%@NL@%
                GOSUB WindowDoClickEvent%@NL@%
            END IF%@NL@%
%@NL@%
            MousePoll MouseRow, MouseCol, lButton, rButton%@NL@%
        WEND%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If the button was released (and no click event occured) then check%@AE@%%@NL@%
%@AB@%        ' for a release event!%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF NOT lButton AND MouseRow <> 1 AND NOT ExitFlag THEN%@NL@%
            GOSUB WindowDoCheckReleaseEvent%@NL@%
            IF Found THEN%@NL@%
                GOSUB WindowDoReleaseEvent%@NL@%
            ELSE%@NL@%
%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
%@AB@%                ' If no release event, then see if mouse was released in another%@AE@%%@NL@%
%@AB@%                ' window.  This is a special case release event%@AE@%%@NL@%
%@AB@%                ' ===========================================================%@AE@%%@NL@%
%@NL@%
                GOSUB WindowDoCheckOtherWindow%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Un highlight the button if the mouse was released for any reason%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            GOSUB WindowDoUnHighlightButton%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If in button mode, return cursor to original spot.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF WindowDoMode = 2 THEN%@NL@%
        currCursorRow = origCursorRow%@NL@%
        currCursorCol = origCursorCol%@NL@%
        GOSUB WindowDoShowTextCursor%@NL@%
    END IF%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Used only in Button mode.  Checks for menu event with MenuInkey$,%@AE@%%@NL@%
%@AB@%' then checks for all the misc events.  See below%@AE@%%@NL@%
%@AB@%' If an event is found, the proper event ID is stored, and ExifFlag is set%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoButtonKbd:%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Only check menu if window type > 0.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GloWindow(windo).windowType < 0 THEN%@NL@%
        kbd$ = INKEY$%@NL@%
    ELSE%@NL@%
        kbd$ = MenuInkey$%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' The following is a list of key strokes that can be detected. You can%@AE@%%@NL@%
%@AB@%    ' add more as needed, but you will need to change any programs that use%@AE@%%@NL@%
%@AB@%    ' the existing configuration.  The numbers associated with each key are%@AE@%%@NL@%
%@AB@%    ' the numbers that are returned by Dialog(0).%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    SELECT CASE kbd$%@NL@%
        CASE CHR$(13)%@NL@%
            GloStorage.oldDialogEvent = 6          'Return%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(9)%@NL@%
            GloStorage.oldDialogEvent = 7          'Tab%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + CHR$(15)%@NL@%
            GloStorage.oldDialogEvent = 8          'Back Tab%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(27)%@NL@%
            GloStorage.oldDialogEvent = 9          'Escape%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + "H"%@NL@%
            GloStorage.oldDialogEvent = 10         'Up%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + "P"%@NL@%
            GloStorage.oldDialogEvent = 11         'Down%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + "K"%@NL@%
            GloStorage.oldDialogEvent = 12         'Left%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + "M"%@NL@%
            GloStorage.oldDialogEvent = 13         'Right%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE " "%@NL@%
            GloStorage.oldDialogEvent = 14         'Space%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + "G"%@NL@%
            GloStorage.oldDialogEvent = 16         'Home%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + "O"%@NL@%
            GloStorage.oldDialogEvent = 17         'End%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + "I"%@NL@%
            GloStorage.oldDialogEvent = 18         'PgUp%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + "Q"%@NL@%
            GloStorage.oldDialogEvent = 19         'PgDn%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE "menu"%@NL@%
            GloStorage.oldDialogEvent = 20         'Menu%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE ELSE%@NL@%
    END SELECT%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Checks mouseRow, mouseCol against all the click events stored in HSClick%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoCheckClickEvent:%@NL@%
    currEvent = 1%@NL@%
    Found = FALSE%@NL@%
%@NL@%
    WHILE NOT Found AND currEvent <= numHSClick%@NL@%
        IF MouseRow >= HSClick(currEvent).row1 AND MouseRow <= HSClick(currEvent).row2 AND MouseCol >= HSClick(currEvent).col1 AND MouseCol <= HSClick(currEvent).col2 THEN%@NL@%
            Found = TRUE%@NL@%
        ELSE%@NL@%
            currEvent = currEvent + 1%@NL@%
        END IF%@NL@%
    WEND%@NL@%
%@NL@%
    IF NOT Found THEN%@NL@%
        GOSUB WindowDoUnHighlightButton%@NL@%
    END IF%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Checks mouseRow,mouseCol against all the release events in HSRel%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoCheckReleaseEvent:%@NL@%
    currEvent = 1%@NL@%
    Found = FALSE%@NL@%
%@NL@%
    WHILE NOT Found AND currEvent <= numHSRel%@NL@%
        IF MouseRow >= HSRel(currEvent).row1 AND MouseRow <= HSRel(currEvent).row2 AND MouseCol >= HSRel(currEvent).col1 AND MouseCol <= HSRel(currEvent).col2 THEN%@NL@%
            Found = TRUE%@NL@%
        ELSE%@NL@%
            currEvent = currEvent + 1%@NL@%
        END IF%@NL@%
    WEND%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Calls WhichWindow to see if mouseRow, mouseCol is in another window%@AE@%%@NL@%
%@AB@%' If it is, that's event ID #3, so set it, and set ExitFlag to TRUE%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoCheckOtherWindow:%@NL@%
    IF GloWindow(windo).windowType > 0 THEN%@NL@%
        otherWindow = WhichWindow(MouseRow, MouseCol)%@NL@%
        IF otherWindow AND (otherWindow <> windo) THEN%@NL@%
            GloStorage.oldDialogEvent = 3%@NL@%
            GloStorage.oldDialogWindow = otherWindow%@NL@%
            ExitFlag = TRUE%@NL@%
        END IF%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' If there was a release event, this routine handles it%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoReleaseEvent:%@NL@%
%@NL@%
    SELECT CASE HSRel(currEvent).action%@NL@%
        CASE 1                                      'Released on Button%@NL@%
            GloStorage.oldDialogEvent = 1%@NL@%
            GloStorage.oldDialogButton = HSRel(currEvent).misc%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE 4                                      'Released on Close Box%@NL@%
            GloStorage.oldDialogEvent = 4%@NL@%
            GloStorage.oldDialogClose = HSRel(currEvent).misc%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE ELSE%@NL@%
    END SELECT%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' If there was a click event, this routine handles it%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoClickEvent:%@NL@%
%@NL@%
    SELECT CASE HSClick(currEvent).action%@NL@%
        CASE 1                                          'ButtonClick%@NL@%
            SELECT CASE HSClick(currEvent).misc2%@NL@%
                CASE 1%@NL@%
                    IF ButtonHighLight THEN%@NL@%
                        IF currButton <> HSClick(currEvent).misc THEN%@NL@%
                            ButtonSetState currButton, origState%@NL@%
                            currButton = HSClick(currEvent).misc%@NL@%
                            ButtonSetState currButton, 3%@NL@%
                        END IF%@NL@%
                    ELSE%@NL@%
                        currButton = HSClick(currEvent).misc%@NL@%
                        origState = ButtonInquire(currButton)%@NL@%
                        ButtonHighLight = TRUE%@NL@%
                        ButtonSetState currButton, 3%@NL@%
                    END IF%@NL@%
%@NL@%
                    currCursorRow = HSClick(currEvent).row1%@NL@%
                    currCursorCol = HSClick(currEvent).col1 + 1%@NL@%
                    GOSUB WindowDoShowTextCursor%@NL@%
                CASE 2, 3%@NL@%
                    currCursorRow = HSClick(currEvent).row1%@NL@%
                    currCursorCol = HSClick(currEvent).col1 + 1%@NL@%
                    GOSUB WindowDoShowTextCursor%@NL@%
                CASE 4%@NL@%
                    IF ButtonHighLight THEN%@NL@%
                        ButtonSetState currButton, origState%@NL@%
                    END IF%@NL@%
%@NL@%
                    GloStorage.oldDialogEvent = 1%@NL@%
                    GloStorage.oldDialogButton = HSClick(currEvent).misc%@NL@%
                    GloStorage.oldDialogRow = MouseRow - HSClick(currEvent).row1 + 1%@NL@%
                    GloStorage.oldDialogCol = MouseCol - HSClick(currEvent).col1 + 1%@NL@%
                    ExitFlag = TRUE%@NL@%
                CASE 6%@NL@%
                    GloStorage.oldDialogEvent = 1%@NL@%
                    GloStorage.oldDialogButton = HSClick(currEvent).misc%@NL@%
%@NL@%
                    IF MouseRow = HSClick(currEvent).row1 THEN%@NL@%
                        GloStorage.oldDialogScroll = -1%@NL@%
                    ELSEIF MouseRow = HSClick(currEvent).row2 THEN%@NL@%
                        GloStorage.oldDialogScroll = -2%@NL@%
                    ELSE%@NL@%
                        GloStorage.oldDialogScroll = MouseRow - HSClick(currEvent).row1%@NL@%
                    END IF%@NL@%
%@NL@%
                    ExitFlag = TRUE%@NL@%
                CASE 7%@NL@%
                    GloStorage.oldDialogEvent = 1%@NL@%
                    GloStorage.oldDialogButton = HSClick(currEvent).misc%@NL@%
%@NL@%
                    IF MouseCol = HSClick(currEvent).col1 THEN%@NL@%
                        GloStorage.oldDialogScroll = -1%@NL@%
                    ELSEIF MouseCol = HSClick(currEvent).col2 THEN%@NL@%
                        GloStorage.oldDialogScroll = -2%@NL@%
                    ELSE%@NL@%
                        GloStorage.oldDialogScroll = MouseCol - HSClick(currEvent).col1%@NL@%
                    END IF%@NL@%
%@NL@%
                    ExitFlag = TRUE%@NL@%
                CASE ELSE%@NL@%
            END SELECT%@NL@%
        CASE 2                                      'Edit Field Click%@NL@%
            GloStorage.oldDialogEvent = 2           'Event ID #2%@NL@%
            GloStorage.oldDialogEdit = HSClick(currEvent).misc%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE 5%@NL@%
            GOSUB WindowDoSize                      'Internally handle Re-Size%@NL@%
            ExitFlag = TRUE%@NL@%
            GloStorage.oldDialogEvent = 5%@NL@%
        CASE 15%@NL@%
            GOSUB WindowDoHideTextCursor%@NL@%
            GOSUB WindowDoMove                      'Internally handle Move%@NL@%
            ExitFlag = TRUE%@NL@%
            GloStorage.oldDialogEvent = 15%@NL@%
        CASE ELSE%@NL@%
%@NL@%
    END SELECT%@NL@%
%@NL@%
    IF HSClick(currEvent).action <> 1 THEN%@NL@%
        GOSUB WindowDoUnHighlightButton%@NL@%
    END IF%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Un-highlight a button%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoUnHighlightButton:%@NL@%
    IF ButtonHighLight THEN%@NL@%
        ButtonSetState currButton, origState%@NL@%
        ButtonHighLight = FALSE%@NL@%
        GOSUB WindowDoShowTextCursor%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Handle the move window click -- drag the window around until button released%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoMove:%@NL@%
    MouseHide%@NL@%
    WindowSave windo%@NL@%
    BackgroundRefresh windo%@NL@%
    IF INSTR(WindowBorder$(GloWindow(windo).windowType), "S") THEN%@NL@%
      WindowShadowRefresh%@NL@%
    END IF%@NL@%
%@NL@%
    oldWinrow1 = GloWindow(windo).row1%@NL@%
    oldWincol1 = GloWindow(windo).col1%@NL@%
    oldWinrow2 = GloWindow(windo).row2%@NL@%
    oldWincol2 = GloWindow(windo).col2%@NL@%
%@NL@%
    GOSUB DrawRubberBand%@NL@%
%@NL@%
    WindowPrintTitle%@NL@%
    MouseShow%@NL@%
%@NL@%
    MouseBorder MINROW, (MouseCol - GloWindow(windo).col1 + 1 + MINCOL), (MAXROW - WindowRows(windo) - 1), (MAXCOL - (GloWindow(windo).col2 - MouseCol) - 1)%@NL@%
%@NL@%
    oldMouseRow = MouseRow%@NL@%
    oldMouseCol = MouseCol%@NL@%
%@NL@%
    DO%@NL@%
        MousePoll MouseRow, MouseCol, lButton, rButton%@NL@%
        IF MouseRow <> oldMouseRow OR MouseCol <> oldMouseCol THEN%@NL@%
            MouseHide%@NL@%
%@NL@%
            GOSUB EraseRubberBand%@NL@%
%@NL@%
            oldWinrow1 = oldWinrow1 - oldMouseRow + MouseRow%@NL@%
            oldWinrow2 = oldWinrow2 - oldMouseRow + MouseRow%@NL@%
            oldWincol1 = oldWincol1 - oldMouseCol + MouseCol%@NL@%
            oldWincol2 = oldWincol2 - oldMouseCol + MouseCol%@NL@%
%@NL@%
            oldMouseRow = MouseRow%@NL@%
            oldMouseCol = MouseCol%@NL@%
%@NL@%
            GOSUB DrawRubberBand%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
%@NL@%
    LOOP UNTIL NOT lButton%@NL@%
%@NL@%
    MouseHide%@NL@%
    GOSUB EraseRubberBand%@NL@%
    GloWindow(windo).row1 = oldWinrow1%@NL@%
    GloWindow(windo).row2 = oldWinrow2%@NL@%
    GloWindow(windo).col1 = oldWincol1%@NL@%
    GloWindow(windo).col2 = oldWincol2%@NL@%
    BackgroundSave windo%@NL@%
    WindowRefresh windo%@NL@%
    IF INSTR(WindowBorder$(GloWindow(windo).windowType), "S") THEN%@NL@%
        WindowShadowSave%@NL@%
    END IF%@NL@%
    GloBuffer$(windo, 2) = ""%@NL@%
    MouseShow%@NL@%
    MouseBorder 1, 1, MAXROW, MAXCOL%@NL@%
    GOSUB WindowDoComputeHotSpots%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Re-Size window -- Drag box around until button released, then exit%@AE@%%@NL@%
%@AB@%' with eventID #5  -- Window need refreshing%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoSize:%@NL@%
    ButtonClose 0%@NL@%
    MouseHide%@NL@%
    WindowSave windo%@NL@%
%@NL@%
%@AB@%    ' ======================================================================%@AE@%%@NL@%
%@AB@%    ' Comment out the next line if you want to retain the window contents%@AE@%%@NL@%
%@AB@%    ' while resizing the window.%@AE@%%@NL@%
%@AB@%    ' ======================================================================%@AE@%%@NL@%
%@NL@%
    BackgroundRefresh windo%@NL@%
%@NL@%
    IF INSTR(WindowBorder$(GloWindow(windo).windowType), "S") THEN%@NL@%
      WindowShadowRefresh%@NL@%
    END IF%@NL@%
%@NL@%
    oldWinrow1 = GloWindow(windo).row1%@NL@%
    oldWincol1 = GloWindow(windo).col1%@NL@%
    oldWinrow2 = GloWindow(windo).row2%@NL@%
    oldWincol2 = GloWindow(windo).col2%@NL@%
%@NL@%
    GOSUB DrawRubberBand%@NL@%
%@NL@%
    MouseShow%@NL@%
    MouseBorder GloWindow(windo).row1 + 3, GloWindow(windo).col1 + 6, MAXROW, MAXCOL%@NL@%
%@NL@%
    oldMouseRow = MouseRow%@NL@%
    oldMouseCol = MouseCol%@NL@%
%@NL@%
    DO%@NL@%
        MousePoll MouseRow, MouseCol, lButton, rButton%@NL@%
        IF MouseRow <> oldMouseRow OR MouseCol <> oldMouseCol THEN%@NL@%
            MouseHide%@NL@%
%@NL@%
            GOSUB EraseRubberBand%@NL@%
%@NL@%
            oldWinrow2 = oldWinrow2 - oldMouseRow + MouseRow%@NL@%
            oldWincol2 = oldWincol2 - oldMouseCol + MouseCol%@NL@%
%@NL@%
            oldMouseRow = MouseRow%@NL@%
            oldMouseCol = MouseCol%@NL@%
%@NL@%
            GOSUB DrawRubberBand%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    LOOP UNTIL NOT lButton%@NL@%
%@NL@%
    MouseHide%@NL@%
    GOSUB EraseRubberBand%@NL@%
    WindowShadowRefresh%@NL@%
    BackgroundRefresh windo%@NL@%
    GloWindow(windo).row2 = oldWinrow2%@NL@%
    GloWindow(windo).col2 = oldWincol2%@NL@%
    BackgroundSave windo%@NL@%
    Box GloWindow(windo).row1 - 1, GloWindow(windo).col1 - 1, GloWindow(windo).row2 + 1, GloWindow(windo).col2 + 1, GloWindow(windo).fore, GloWindow(windo).back, WindowBorder$(GloWindow(windo).windowType), 0%@NL@%
    GloBuffer$(windo, 2) = ""%@NL@%
    WindowPrintTitle%@NL@%
%@NL@%
    IF INSTR(WindowBorder$(GloWindow(windo).windowType), "S") THEN%@NL@%
        WindowShadowSave%@NL@%
    END IF%@NL@%
    MouseShow%@NL@%
%@NL@%
    MouseBorder 1, 1, MAXROW, MAXCOL%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Draw rubber band of current window%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
DrawRubberBand:%@NL@%
  GetBackground oldWinrow1 - 1, oldWincol1 - 1, oldWinrow1 - 1, oldWincol2 + 1, RB$(1)%@NL@%
  GetBackground oldWinrow2 + 1, oldWincol1 - 1, oldWinrow2 + 1, oldWincol2 + 1, RB$(2)%@NL@%
  GetBackground oldWinrow1 - 1, oldWincol1 - 1, oldWinrow2 + 1, oldWincol1 - 1, RB$(3)%@NL@%
  GetBackground oldWinrow1 - 1, oldWincol2 + 1, oldWinrow2 + 1, oldWincol2 + 1, RB$(4)%@NL@%
  Box oldWinrow1 - 1, oldWincol1 - 1, oldWinrow2 + 1, oldWincol2 + 1, GloWindow(windo).highlight, GloWindow(windo).back, WindowBorder$(GloWindow(windo).windowType), 0%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Erase rubber band of current window%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
EraseRubberBand:%@NL@%
  PutBackground oldWinrow1 - 1, oldWincol1 - 1, RB$(1)%@NL@%
  PutBackground oldWinrow2 + 1, oldWincol1 - 1, RB$(2)%@NL@%
  PutBackground oldWinrow1 - 1, oldWincol1 - 1, RB$(3)%@NL@%
  PutBackground oldWinrow1 - 1, oldWincol2 + 1, RB$(4)%@NL@%
  RETURN%@NL@%
%@NL@%
WindowDoHideTextCursor:%@NL@%
    LOCATE , , 0%@NL@%
RETURN%@NL@%
%@NL@%
%@NL@%
WindowDoShowTextCursor:%@NL@%
    IF currCursorRow <> 0 AND currCursorCol <> 0 THEN%@NL@%
        LOCATE currCursorRow, currCursorCol, 1%@NL@%
    ELSE%@NL@%
        LOCATE , , 0%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' If in edit mode, this routine gets info from the global arrays%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoEditInit:%@NL@%
    row = GloWindow(windo).row1 + GloEdit(currEditField).row - 1%@NL@%
    col = GloWindow(windo).col1 + GloEdit(currEditField).col - 1%@NL@%
    fore = GloEdit(currEditField).fore%@NL@%
    back = GloEdit(currEditField).back%@NL@%
    visLength = GloEdit(currEditField).visLength%@NL@%
    maxLength = GloEdit(currEditField).maxLength%@NL@%
    editField$ = LEFT$(GloEdit(currEditField).text$, maxLength)%@NL@%
    insertMode = TRUE%@NL@%
    InsertKey = GetShiftState(7)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Make sure everything's the right length%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    x = INSTR(editField$, CHR$(0)) - 1%@NL@%
    IF x >= 0 THEN%@NL@%
        editField$ = LEFT$(editField$, x)%@NL@%
    END IF%@NL@%
%@NL@%
    IF LEN(editField$) >= visLength THEN%@NL@%
        firstchar = LEN(editField$) - visLength + 2%@NL@%
        cursor = visLength - 1%@NL@%
    ELSE%@NL@%
        firstchar = 1%@NL@%
        cursor = LEN(editField$)%@NL@%
    END IF%@NL@%
%@NL@%
    GOSUB WindowDoEditPrint%@NL@%
%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Handles the edit kbd event trapping.  Some keys trigger events%@AE@%%@NL@%
%@AB@%' (e.g. TAB is event ID #7)  Others affect the current edit field string (DEL)%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoEditKbd:%@NL@%
    IF GetShiftState(7) = InsertKey THEN%@NL@%
        insertMode = TRUE%@NL@%
        LOCATE , , , 6, 7%@NL@%
    ELSE%@NL@%
        insertMode = FALSE%@NL@%
        LOCATE , , , 0, 7%@NL@%
    END IF%@NL@%
%@NL@%
    LOCATE row, col + cursor, 1%@NL@%
%@NL@%
    GOSUB WindowDoMouse%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Only call MenuInkey$ if menuType > 0%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GloWindow(windo).windowType < 0 THEN%@NL@%
        kbd$ = INKEY$%@NL@%
    ELSE%@NL@%
        kbd$ = MenuInkey$%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Either key is an event, and the exitFlag is set, or something happens%@AE@%%@NL@%
%@AB@%    ' to the current edit string.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    SELECT CASE kbd$%@NL@%
        CASE CHR$(13)%@NL@%
            GloStorage.oldDialogEvent = 6          'Return%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(9)%@NL@%
            GloStorage.oldDialogEvent = 7          'Tab%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + CHR$(15)%@NL@%
            GloStorage.oldDialogEvent = 8          'Back Tab%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(27)%@NL@%
            GloStorage.oldDialogEvent = 9          'Escape%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + "H"%@NL@%
            GloStorage.oldDialogEvent = 10         'Up%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + "P"%@NL@%
            GloStorage.oldDialogEvent = 11         'Down%@NL@%
            ExitFlag = TRUE%@NL@%
        CASE CHR$(0) + "M"                         'Right%@NL@%
            GOSUB WindowDoEditRight%@NL@%
        CASE CHR$(0) + "K"%@NL@%
            cursor = cursor - 1%@NL@%
            IF cursor < 0 THEN%@NL@%
                cursor = cursor + 1%@NL@%
                IF firstchar > 1 THEN%@NL@%
                    firstchar = firstchar - 1%@NL@%
                    GOSUB WindowDoEditPrint%@NL@%
                END IF%@NL@%
            END IF%@NL@%
%@NL@%
        CASE CHR$(0) + "S"%@NL@%
            IF cursor + firstchar <= LEN(editField$) THEN%@NL@%
                editField$ = LEFT$(editField$, cursor + firstchar - 1) + RIGHT$(editField$, LEN(editField$) - (cursor + firstchar))%@NL@%
                GOSUB WindowDoEditPrint%@NL@%
            END IF%@NL@%
        CASE CHR$(8)%@NL@%
            IF firstchar + cursor > 1 THEN%@NL@%
                editField$ = LEFT$(editField$, cursor + firstchar - 2) + RIGHT$(editField$, LEN(editField$) - (cursor + firstchar) + 1)%@NL@%
                GOSUB WindowDoEditPrint%@NL@%
                SELECT CASE cursor%@NL@%
                    CASE 0%@NL@%
                        firstchar = firstchar - 1%@NL@%
                        GOSUB WindowDoEditPrint%@NL@%
                    CASE 1%@NL@%
                        IF firstchar > 1 THEN%@NL@%
                            firstchar = firstchar - 1%@NL@%
                            GOSUB WindowDoEditPrint%@NL@%
                        ELSE%@NL@%
                            cursor = cursor - 1%@NL@%
                        END IF%@NL@%
                    CASE ELSE%@NL@%
                        cursor = cursor - 1%@NL@%
                END SELECT%@NL@%
            END IF%@NL@%
        CASE CHR$(0) + "G"                         'Home%@NL@%
            firstchar = 1%@NL@%
            cursor = 0%@NL@%
            GOSUB WindowDoEditPrint%@NL@%
        CASE CHR$(0) + "O"                         'End%@NL@%
            IF LEN(editField$) >= visLength THEN%@NL@%
                cursor = visLength - 1%@NL@%
                firstchar = LEN(editField$) - visLength + 2%@NL@%
                GOSUB WindowDoEditPrint%@NL@%
            ELSE%@NL@%
                firstchar = 1%@NL@%
                cursor = LEN(editField$)%@NL@%
            END IF%@NL@%
        CASE CHR$(0) + "u"                         'Ctrl+end%@NL@%
            editField$ = LEFT$(editField$, firstchar + cursor - 1)%@NL@%
            GOSUB WindowDoEditPrint%@NL@%
        CASE "menu"%@NL@%
            GloStorage.oldDialogEvent = 20         'Menu%@NL@%
            ExitFlag = TRUE%@NL@%
%@NL@%
        CASE CHR$(32) TO CHR$(255)                 'Alphanumeric%@NL@%
            IF insertMode THEN%@NL@%
                IF LEN(editField$) < maxLength THEN%@NL@%
                    editField$ = LEFT$(editField$, cursor + firstchar - 1) + kbd$ + RIGHT$(editField$, LEN(editField$) - (cursor + firstchar) + 1)%@NL@%
                    GOSUB WindowDoEditPrint%@NL@%
                    GOSUB WindowDoEditRight%@NL@%
                ELSE%@NL@%
                    BEEP%@NL@%
                END IF%@NL@%
            ELSE%@NL@%
                IF cursor + firstchar > LEN(editField$) THEN%@NL@%
                    IF LEN(editField$) < maxLength THEN%@NL@%
                        editField$ = editField$ + kbd$%@NL@%
                        MouseHide%@NL@%
                        PRINT kbd$;%@NL@%
                        MouseShow%@NL@%
                    END IF%@NL@%
                ELSE%@NL@%
                    MID$(editField$, cursor + firstchar, 1) = kbd$%@NL@%
                    MouseHide%@NL@%
                    PRINT kbd$;%@NL@%
                    MouseShow%@NL@%
                END IF%@NL@%
%@NL@%
                GOSUB WindowDoEditRight%@NL@%
            END IF%@NL@%
%@NL@%
    END SELECT%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Moves the cursor right 1 space.  This is used twice, so it is its own%@AE@%%@NL@%
%@AB@%' routine%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoEditRight:%@NL@%
    cursor = cursor + 1%@NL@%
    IF cursor + firstchar - 1 > LEN(editField$) THEN%@NL@%
        cursor = cursor - 1%@NL@%
    ELSEIF cursor + firstchar - 1 > maxLength THEN%@NL@%
        cursor = cursor - 1%@NL@%
    ELSEIF cursor = visLength THEN%@NL@%
        firstchar = firstchar + 1%@NL@%
        cursor = cursor - 1%@NL@%
        GOSUB WindowDoEditPrint%@NL@%
    END IF%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Upon exit, store the current edit field string back into the global array%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoEditExit:%@NL@%
    GloEdit(currEditField).text$ = editField$ + CHR$(0)%@NL@%
    LOCATE , , 0, 6, 7%@NL@%
RETURN%@NL@%
%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@AB@%' Prints the edit field in the proper color, at the proper location%@AE@%%@NL@%
%@AB@%' ===========================================================================%@AE@%%@NL@%
%@NL@%
WindowDoEditPrint:%@NL@%
    MouseHide%@NL@%
    COLOR fore, back%@NL@%
    LOCATE row, col%@NL@%
    PRINT MID$(editField$ + SPACE$(visLength), firstchar, visLength);%@NL@%
    MouseShow%@NL@%
RETURN%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowInit%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Initialize totals%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    GloStorage.currWindow = -1%@NL@%
    GloStorage.numWindowsOpen = 0%@NL@%
    GloStorage.numButtonsOpen = 0%@NL@%
    GloStorage.numEditFieldsOpen = 0%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Clear all windows%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    FOR A = 1 TO MAXWINDOW%@NL@%
        GloWindow(A).handle = -1%@NL@%
        GloWindow(A).row1 = 0%@NL@%
        GloWindow(A).col1 = 0%@NL@%
        GloWindow(A).row2 = 0%@NL@%
        GloWindow(A).col2 = 0%@NL@%
        GloWindow(A).fore = 0%@NL@%
        GloWindow(A).back = 0%@NL@%
        GloWindow(A).windowType = 0%@NL@%
        GloWindow(A).title = ""%@NL@%
        GloWindowStack(A) = -1%@NL@%
    NEXT A%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Clear all buttons%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    FOR A = 1 TO MAXBUTTON%@NL@%
        GloButton(A).handle = -1%@NL@%
        GloButton(A).windowHandle = -1%@NL@%
        GloButton(A).text = ""%@NL@%
        GloButton(A).state = 0%@NL@%
        GloButton(A).buttonOn = FALSE%@NL@%
        GloButton(A).row1 = 0%@NL@%
        GloButton(A).col1 = 0%@NL@%
        GloButton(A).row2 = 0%@NL@%
        GloButton(A).col2 = 0%@NL@%
        GloButton(A).buttonType = 0%@NL@%
    NEXT A%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Clear all edit fields%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    FOR A = 1 TO MAXEDITFIELD%@NL@%
        GloEdit(A).handle = 0%@NL@%
        GloEdit(A).windowHandle = 0%@NL@%
        GloEdit(A).text = ""%@NL@%
        GloEdit(A).row = 0%@NL@%
        GloEdit(A).col = 0%@NL@%
        GloEdit(A).visLength = 0%@NL@%
        GloEdit(A).maxLength = 0%@NL@%
        GloEdit(A).fore = 0%@NL@%
        GloEdit(A).back = 0%@NL@%
    NEXT A%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowLine (row)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If window is valid, draw a horizontal line at the row which is passed%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
%@NL@%
    IF windo > 0 THEN%@NL@%
        IF row >= 1 OR row <= WindowRows(windo) THEN%@NL@%
%@NL@%
            topRow = GloWindow(windo).row1%@NL@%
            leftCol = GloWindow(windo).col1 - 1%@NL@%
            rightCol = GloWindow(windo).col2 + 1%@NL@%
            border$ = WindowBorder$(GloWindow(windo).windowType)%@NL@%
%@NL@%
            LOCATE topRow + row - 1, leftCol%@NL@%
            MouseHide%@NL@%
            COLOR GloWindow(windo).fore, GloWindow(windo).back%@NL@%
%@NL@%
            IF MID$(border$, 11, 1) = " " THEN%@NL@%
                PRINT STRING$(rightCol - leftCol + 1, CHR$(196))%@NL@%
            ELSE%@NL@%
                PRINT MID$(border$, 10, 1); STRING$(rightCol - leftCol - 1, MID$(border$, 11, 1)); MID$(border$, 12, 1)%@NL@%
            END IF%@NL@%
%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowLocate (row, col)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If window is valid, assign the passed row and col to the global variables%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
    IF windo > 0 THEN%@NL@%
        GloWindow(windo).cursorRow = row%@NL@%
        GloWindow(windo).cursorCol = col%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
FUNCTION WindowNext%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Loop through window array, and find first unused window, return handle%@AE@%%@NL@%
%@AB@%    ' If no window found, return 0%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    Found = FALSE%@NL@%
    A = 1%@NL@%
    WHILE A <= MAXWINDOW AND NOT Found%@NL@%
        IF GloWindow(A).handle = -1 THEN%@NL@%
            Found = TRUE%@NL@%
        ELSE%@NL@%
            A = A + 1%@NL@%
        END IF%@NL@%
    WEND%@NL@%
%@NL@%
    IF Found THEN%@NL@%
        WindowNext = A%@NL@%
    ELSE%@NL@%
        WindowNext = 0%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB WindowOpen (handle, row1, col1, row2, col2, textFore, textBack, fore, back, highlight, movewin, closewin, sizewin, modalwin, borderchar, title$)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Open Window!   First make sure coordinates are valid%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
    IF row1 > row2 THEN SWAP row1, row2%@NL@%
    IF col1 > col2 THEN SWAP col1, col2%@NL@%
%@NL@%
    IF col1 >= MINCOL + 1 AND row1 >= MINROW + 1 AND col2 <= MAXCOL - 1 AND row2 <= MAXROW - 1 THEN%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Close window by save number if it already exists%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        WindowClose handle%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Evaluate argument list to determine windowType%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF movewin THEN windowType = 1%@NL@%
        IF closewin THEN windowType = windowType + 2%@NL@%
        IF sizewin THEN windowType = windowType + 4%@NL@%
        IF borderchar = 1 THEN windowType = windowType + 8%@NL@%
        IF borderchar = 2 THEN windowType = windowType + 16%@NL@%
        IF windowType = 0 THEN windowType = 99%@NL@%
        IF modalwin THEN windowType = -windowType%@NL@%
%@NL@%
        border$ = WindowBorder(windowType)%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' hide current window's shadow if it has one%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        MouseHide%@NL@%
        IF GloStorage.numWindowsOpen > 0 THEN%@NL@%
            IF INSTR(WindowBorder$(GloWindow(GloWindowStack(GloStorage.numWindowsOpen)).windowType), "S") THEN%@NL@%
                WindowShadowRefresh%@NL@%
            END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Assign new values to window array%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        GloWindow(handle).handle = handle%@NL@%
        GloWindow(handle).row1 = row1%@NL@%
        GloWindow(handle).col1 = col1%@NL@%
        GloWindow(handle).row2 = row2%@NL@%
        GloWindow(handle).col2 = col2%@NL@%
        GloWindow(handle).cursorRow = 1%@NL@%
        GloWindow(handle).cursorCol = 1%@NL@%
        GloWindow(handle).fore = fore%@NL@%
        GloWindow(handle).back = back%@NL@%
        GloWindow(handle).textFore = textFore%@NL@%
        GloWindow(handle).textBack = textBack%@NL@%
        GloWindow(handle).highlight = highlight%@NL@%
        GloWindow(handle).windowType = windowType%@NL@%
        GloWindow(handle).title = title$%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Save background, then draw window%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        BackgroundSave handle%@NL@%
        Box row1 - 1, col1 - 1, row2 + 1, col2 + 1, fore, back, border$, 1%@NL@%
        MouseShow%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Assign handle to currWindow, incr total windows, push handle on stack%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        GloStorage.currWindow = handle%@NL@%
        GloStorage.numWindowsOpen = GloStorage.numWindowsOpen + 1%@NL@%
        GloWindowStack(GloStorage.numWindowsOpen) = handle%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Print window title, and shadow%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        WindowPrintTitle%@NL@%
        IF INSTR(border$, "S") THEN%@NL@%
            WindowShadowSave%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowPrint (printMode, text$)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If window is valid, print text$ using mode printMode%.  See%@AE@%%@NL@%
%@AB@%    ' External documentation for details on printMode%%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
%@NL@%
    IF windo > 0 THEN%@NL@%
        SELECT CASE printMode%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Truncate printing%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            CASE 1, -1%@NL@%
                length = WindowCols(windo) - GloWindow(windo).cursorCol + 1%@NL@%
                LOCATE GloWindow(windo).row1 + GloWindow(windo).cursorRow - 1, GloWindow(windo).col1 + GloWindow(windo).cursorCol - 1%@NL@%
                COLOR GloWindow(windo).textFore, GloWindow(windo).textBack%@NL@%
                MouseHide%@NL@%
                PRINT LEFT$(text$, length);%@NL@%
                MouseShow%@NL@%
                IF printMode < 0 THEN%@NL@%
                    GloWindow(windo).cursorCol = GloWindow(windo).cursorCol + LEN(text$)%@NL@%
                    IF GloWindow(windo).cursorCol > WindowCols(windo) THEN%@NL@%
                        GloWindow(windo).cursorCol = WindowCols(windo) + 1%@NL@%
                    END IF%@NL@%
                ELSE%@NL@%
                    GloWindow(windo).cursorRow = GloWindow(windo).cursorRow + 1%@NL@%
                    GloWindow(windo).cursorCol = 1%@NL@%
                    IF GloWindow(windo).cursorRow > WindowRows(windo) THEN%@NL@%
                        WindowScroll 1%@NL@%
                        GloWindow(windo).cursorRow = WindowRows(windo)%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Character wrapping%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            CASE 2, -2%@NL@%
                COLOR GloWindow(windo).textFore, GloWindow(windo).textBack%@NL@%
                A$ = text$%@NL@%
                WHILE LEN(A$) > 0%@NL@%
                    length = WindowCols(windo) - GloWindow(windo).cursorCol + 1%@NL@%
                    LOCATE GloWindow(windo).row1 + GloWindow(windo).cursorRow - 1, GloWindow(windo).col1 + GloWindow(windo).cursorCol - 1%@NL@%
%@NL@%
                    MouseHide%@NL@%
                    PRINT LEFT$(A$, length);%@NL@%
                    MouseShow%@NL@%
%@NL@%
                    IF length < LEN(A$) THEN%@NL@%
                        A$ = RIGHT$(A$, LEN(A$) - length)%@NL@%
                        GloWindow(windo).cursorRow = GloWindow(windo).cursorRow + 1%@NL@%
                        GloWindow(windo).cursorCol = 1%@NL@%
                        IF GloWindow(windo).cursorRow > WindowRows(windo) THEN%@NL@%
                            WindowScroll 1%@NL@%
                            GloWindow(windo).cursorRow = WindowRows(windo)%@NL@%
                        END IF%@NL@%
                    ELSE%@NL@%
                        IF printMode < 0 THEN%@NL@%
                            GloWindow(windo).cursorCol = GloWindow(windo).cursorCol + LEN(A$)%@NL@%
                            IF GloWindow(windo).cursorCol > WindowCols(windo) THEN%@NL@%
                                GloWindow(windo).cursorCol = WindowCols(windo) + 1%@NL@%
                            END IF%@NL@%
                        ELSE%@NL@%
                            GloWindow(windo).cursorRow = GloWindow(windo).cursorRow + 1%@NL@%
                            GloWindow(windo).cursorCol = GloWindow(windo).cursorCol%@NL@%
                            IF GloWindow(windo).cursorRow > WindowRows(windo) THEN%@NL@%
                                WindowScroll 1%@NL@%
                                GloWindow(windo).cursorRow = WindowRows(windo)%@NL@%
                            END IF%@NL@%
                        END IF%@NL@%
                        A$ = ""%@NL@%
                    END IF%@NL@%
                WEND%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Word wrapping%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            CASE 3, -3%@NL@%
                COLOR GloWindow(windo).textFore, GloWindow(windo).textBack%@NL@%
                A$ = text$%@NL@%
                WHILE LEN(A$) > 0%@NL@%
                    length = WindowCols(windo) - GloWindow(windo).cursorCol + 1%@NL@%
                    LOCATE GloWindow(windo).row1 + GloWindow(windo).cursorRow - 1, GloWindow(windo).col1 + GloWindow(windo).cursorCol - 1%@NL@%
%@NL@%
                    IF length < LEN(A$) THEN%@NL@%
                        x = length + 1%@NL@%
                        b$ = " " + A$%@NL@%
                        WHILE MID$(b$, x, 1) <> " "%@NL@%
                            x = x - 1%@NL@%
                        WEND%@NL@%
                        x = x - 1%@NL@%
%@NL@%
                        MouseHide%@NL@%
                        IF x = 0 THEN%@NL@%
                            PRINT LEFT$(A$, length);%@NL@%
                            A$ = RIGHT$(A$, LEN(A$) - length)%@NL@%
                        ELSE%@NL@%
                            PRINT LEFT$(A$, x);%@NL@%
                            A$ = RIGHT$(A$, LEN(A$) - x)%@NL@%
                        END IF%@NL@%
                        MouseShow%@NL@%
%@NL@%
                        x = 1%@NL@%
                        b$ = A$ + " "%@NL@%
                        WHILE MID$(b$, x, 1) = " "%@NL@%
                            x = x + 1%@NL@%
                        WEND%@NL@%
%@NL@%
                        IF x = LEN(b$) THEN%@NL@%
                            A$ = ""%@NL@%
                        ELSEIF x > 1 THEN%@NL@%
                            A$ = RIGHT$(A$, LEN(A$) - x + 1)%@NL@%
                        END IF%@NL@%
%@NL@%
                        GloWindow(windo).cursorRow = GloWindow(windo).cursorRow + 1%@NL@%
                        GloWindow(windo).cursorCol = 1%@NL@%
                        IF GloWindow(windo).cursorRow > WindowRows(windo) THEN%@NL@%
                            WindowScroll 1%@NL@%
                            GloWindow(windo).cursorRow = WindowRows(windo)%@NL@%
                        END IF%@NL@%
                    ELSE%@NL@%
%@NL@%
                    MouseHide%@NL@%
                    PRINT LEFT$(A$, length);%@NL@%
                    MouseShow%@NL@%
                        IF printMode < 0 THEN%@NL@%
                            GloWindow(windo).cursorCol = GloWindow(windo).cursorCol + LEN(A$)%@NL@%
                            IF GloWindow(windo).cursorCol > WindowCols(windo) THEN%@NL@%
                                GloWindow(windo).cursorCol = WindowCols(windo) + 1%@NL@%
                            END IF%@NL@%
                        ELSE%@NL@%
                            GloWindow(windo).cursorRow = GloWindow(windo).cursorRow + 1%@NL@%
                            GloWindow(windo).cursorCol = GloWindow(windo).cursorCol%@NL@%
                            IF GloWindow(windo).cursorRow > WindowRows(windo) THEN%@NL@%
                                WindowScroll 1%@NL@%
                                GloWindow(windo).cursorRow = WindowRows(windo)%@NL@%
                            END IF%@NL@%
                        END IF%@NL@%
                        A$ = ""%@NL@%
                    END IF%@NL@%
                WEND%@NL@%
%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@AB@%            ' Centered text printing%@AE@%%@NL@%
%@AB@%            ' ===============================================================%@AE@%%@NL@%
%@NL@%
            CASE 4%@NL@%
                COLOR GloWindow(windo).textFore, GloWindow(windo).textBack%@NL@%
                IF LEN(text$) >= WindowCols(windo) THEN%@NL@%
                    LOCATE GloWindow(windo).row1 + GloWindow(windo).cursorRow - 1, GloWindow(windo).col1%@NL@%
                    MouseHide%@NL@%
                    PRINT LEFT$(text$, length);%@NL@%
                    MouseShow%@NL@%
                ELSE%@NL@%
                    LOCATE GloWindow(windo).row1 + GloWindow(windo).cursorRow - 1, GloWindow(windo).col1 - 1 + INT((WindowCols(windo) / 2) + .9) - LEN(text$) / 2%@NL@%
                    MouseHide%@NL@%
                    PRINT text$%@NL@%
                    MouseShow%@NL@%
                END IF%@NL@%
%@NL@%
                GloWindow(windo).cursorRow = GloWindow(windo).cursorRow + 1%@NL@%
                GloWindow(windo).cursorCol = 1%@NL@%
                IF GloWindow(windo).cursorRow > WindowRows(windo) THEN%@NL@%
                    WindowScroll 1%@NL@%
                    GloWindow(windo).cursorRow = WindowRows(windo)%@NL@%
                END IF%@NL@%
        END SELECT%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowPrintTitle%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Print title of current window if the border$ says it's valid%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
    IF windo > 0 THEN%@NL@%
%@NL@%
        title$ = GloWindow(windo).title%@NL@%
        border$ = WindowBorder$(GloWindow(windo).windowType)%@NL@%
%@NL@%
%@NL@%
        IF INSTR(border$, "T") THEN%@NL@%
            tx$ = RTRIM$(title$)%@NL@%
            IF LEN(tx$) > 0 THEN%@NL@%
                COLOR GloWindow(windo).highlight, GloWindow(windo).back%@NL@%
                MouseHide%@NL@%
                length = WindowCols(windo)%@NL@%
                IF (LEN(tx$) + 2) < length THEN%@NL@%
                    LOCATE GloWindow(windo).row1 - 1, GloWindow(windo).col1 + INT(length / 2 - LEN(tx$) / 2) - 1%@NL@%
                    PRINT " "; tx$; " ";%@NL@%
                ELSE%@NL@%
                    LOCATE GloWindow(windo).row1 - 1, GloWindow(windo).col1%@NL@%
                    PRINT LEFT$(" " + tx$ + " ", (GloWindow(windo).col2 - GloWindow(windo).col1 + 1))%@NL@%
                END IF%@NL@%
                MouseShow%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowRefresh (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Refresh the window -- used for window move, window resize, and%@AE@%%@NL@%
%@AB@%    ' WindowSetCurrent%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GloWindow(handle).handle > 0 THEN%@NL@%
        MouseHide%@NL@%
        PutBackground GloWindow(handle).row1 - 1, GloWindow(handle).col1 - 1, GloBuffer$(handle, 2)%@NL@%
        MouseShow%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
FUNCTION WindowRows (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Returns number of rows if handle is a valid window%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GloWindow(handle).handle > 0 THEN%@NL@%
        WindowRows = GloWindow(handle).row2 - GloWindow(handle).row1 + 1%@NL@%
    END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
SUB WindowSave (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Saves the window handle%%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GloWindow(handle).handle > 0 THEN%@NL@%
        MouseHide%@NL@%
        GetBackground GloWindow(handle).row1 - 1, GloWindow(handle).col1 - 1, GloWindow(handle).row2 + 1, GloWindow(handle).col2 + 1, GloBuffer$(handle, 2)%@NL@%
        MouseShow%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowScroll (lines)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' Scroll just the window area.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
    IF windo > 0 THEN%@NL@%
        MouseHide%@NL@%
        CALL Scroll(GloWindow(windo).row1, GloWindow(windo).col1, GloWindow(windo).row2, GloWindow(windo).col2, lines, GloWindow(windo).back)%@NL@%
        MouseShow%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowSetCurrent (handle)%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If window is valid, and not already the current window%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    IF GloWindow(handle).handle <> -1 AND handle <> WindowCurrent THEN%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If current window has a shadow, hide the shadow%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        MouseHide%@NL@%
        IF INSTR(WindowBorder$(GloWindow(GloStorage.currWindow).windowType), "S") THEN%@NL@%
            WindowShadowRefresh%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Save all windows on top of the one to be current, and refresh the%@AE@%%@NL@%
%@AB@%        ' background of each%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        x = GloStorage.numWindowsOpen%@NL@%
        WHILE GloWindowStack(x) <> handle%@NL@%
            WindowSave GloWindowStack(x)%@NL@%
            BackgroundRefresh GloWindowStack(x)%@NL@%
            x = x - 1%@NL@%
        WEND%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Save the window to be made the current window%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        WindowSave handle%@NL@%
        BackgroundRefresh handle%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Replace each window that was on top of handle, and squeeze stack%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF handle <> GloWindowStack(GloStorage.numWindowsOpen) THEN%@NL@%
            FOR A = x + 1 TO GloStorage.numWindowsOpen%@NL@%
                BackgroundSave GloWindowStack(A)%@NL@%
                WindowRefresh GloWindowStack(A)%@NL@%
                GloBuffer$(GloWindowStack(A), 2) = ""%@NL@%
                GloWindowStack(A - 1) = GloWindowStack(A)%@NL@%
            NEXT A%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Save new background of new current window.%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        BackgroundSave handle%@NL@%
        WindowRefresh handle%@NL@%
        GloBuffer$(handle, 2) = ""%@NL@%
        MouseShow%@NL@%
%@NL@%
        GloStorage.currWindow = handle%@NL@%
        GloWindowStack(GloStorage.numWindowsOpen) = handle%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Show shadow if current window has one%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF INSTR(WindowBorder$(GloWindow(handle).windowType), "S") THEN%@NL@%
            WindowShadowSave%@NL@%
        END IF%@NL@%
%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowShadowRefresh%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If window is current, replace what was under the shadow%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
    IF windo > 0 THEN%@NL@%
        row1 = GloWindow(windo).row1%@NL@%
        row2 = GloWindow(windo).row2%@NL@%
        col1 = GloWindow(windo).col1%@NL@%
        col2 = GloWindow(windo).col2%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If shadow partially (or fully) off screen, adjust coordinates%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        MouseHide%@NL@%
        IF col1 <= MAXCOL - 2 THEN%@NL@%
            PutBackground row1, col2 + 2, GloBuffer$(MAXWINDOW + 1, 1)%@NL@%
        END IF%@NL@%
        IF row2 <= MAXROW - 2 THEN%@NL@%
            PutBackground row2 + 2, col1 + 1, GloBuffer$(MAXWINDOW + 1, 2)%@NL@%
        END IF%@NL@%
        MouseShow%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
SUB WindowShadowSave%@NL@%
%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@AB@%    ' If current window valid, draw the shadow, storing what is underneath%@AE@%%@NL@%
%@AB@%    ' it first.%@AE@%%@NL@%
%@AB@%    ' =======================================================================%@AE@%%@NL@%
%@NL@%
    windo = WindowCurrent%@NL@%
%@NL@%
    IF windo > 0 THEN%@NL@%
        row1 = GloWindow(windo).row1%@NL@%
        row2 = GloWindow(windo).row2%@NL@%
        col1 = GloWindow(windo).col1%@NL@%
        col2 = GloWindow(windo).col2%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' If shadow is partially, or fully off screen, adjust coordinates%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF col2 > MAXCOL - 2 THEN%@NL@%
            shadowWidth = -1%@NL@%
        ELSEIF col2 = MAXCOL - 2 THEN%@NL@%
            shadowWidth = 0%@NL@%
        ELSE%@NL@%
            shadowWidth = 1%@NL@%
        END IF%@NL@%
%@NL@%
        MouseHide%@NL@%
%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@AB@%        ' Save background, the draw shadow%@AE@%%@NL@%
%@AB@%        ' ===================================================================%@AE@%%@NL@%
%@NL@%
        IF col2 <= MAXCOL - 2 THEN%@NL@%
            GetBackground row1, col2 + 2, row2 + 1, col2 + 2 + shadowWidth, GloBuffer$(MAXWINDOW + 1, 1)%@NL@%
            AttrBox row1, col2 + 2, row2 + 1, col2 + 2 + shadowWidth, 8%@NL@%
        END IF%@NL@%
%@NL@%
        IF row2 <= MAXROW - 2 THEN%@NL@%
            GetBackground row2 + 2, col1 + 1, row2 + 2, col2 + 2 + shadowWidth, GloBuffer$(MAXWINDOW + 1, 2)%@NL@%
            AttrBox row2 + 2, col1 + 1, row2 + 2, col2 + 2 + shadowWidth, 8%@NL@%
        END IF%@NL@%
        MouseShow%@NL@%
    END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@1@%%@AH@%Microsoft Quick-BASIC Sample Code%@EH@%%@AE@%
%@NL@%
%@NL@%
%@2@%%@AH@%ABSOLUTE.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\ABSOLUTE.ASM%@AE@%%@NL@%
%@NL@%
        TITLE   ABSOLUTE - helper for assembly routines%@NL@%
%@AB@%;***%@AE@%%@NL@%
%@AB@%; ABSOLUTE - Helper for calling BASIC interpreter assembly routines%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       Copyright <C> 1986, Microsoft Corporation%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;Purpose:%@AE@%%@NL@%
%@AB@%; Allow a BASIC program to call a routine which is located at an%@AE@%%@NL@%
%@AB@%; absolute memory address in the DEF SEG.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; The form of the call is:%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       CALL ABSOLUTE(<param>,...,<loc>)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; where%@AE@%%@NL@%
%@AB@%;       <param>,...   -  zero or more parameters for the assembly routine%@AE@%%@NL@%
%@AB@%;       <loc>         -  an Integer variable that contains the%@AE@%%@NL@%
%@AB@%;                        location in the DEF SEG of the start of%@AE@%%@NL@%
%@AB@%;                        the assembly routine%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; The location parameter will be removed, and the routine at DEF SEG:<loc>%@AE@%%@NL@%
%@AB@%; will be called with the remaining parameters.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Notes:%@AE@%%@NL@%
%@AB@%;       - The parameters are not checked or verified before being passed%@AE@%%@NL@%
%@AB@%;         to the assembly routine.%@AE@%%@NL@%
%@AB@%;       - CALL must be used.  CALLS will cause execution to jump to a%@AE@%%@NL@%
%@AB@%;         random location.%@AE@%%@NL@%
%@AB@%;       - The DOSSEG, .MODEL, .CODE, and .DATA? directives are part of%@AE@%%@NL@%
%@AB@%;         the simplified segment system of MASM 5.0. If you have an%@AE@%%@NL@%
%@AB@%;         earlier version of MASM, you must modify the source to define%@AE@%%@NL@%
%@AB@%;         the segments required by Microsoft high-level languages. These%@AE@%%@NL@%
%@AB@%;         segments are discussed in Appendix C of "Learning and Using%@AE@%%@NL@%
%@AB@%;         QuickBASIC."%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;******************************************************************************%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
        DOSSEG                %@AB@%;requires MASM 5.0 or higher%@AE@%%@NL@%
        .MODEL  medium%@NL@%
%@NL@%
%@AB@%;       Define the routine as public.%@AE@%%@NL@%
%@NL@%
        PUBLIC  ABSOLUTE%@NL@%
%@NL@%
%@AB@%;       Define the seg segment%@AE@%%@NL@%
%@NL@%
        .DATA?%@NL@%
%@NL@%
        EXTRN  b$seg:WORD     %@AB@%;seg segment%@AE@%%@NL@%
%@NL@%
%@AB@%;***%@AE@%%@NL@%
%@AB@%; ABSOLUTE - Call absolute address%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;Purpose:%@AE@%%@NL@%
%@AB@%; Routine which can be directly called from the basic level which in turn%@AE@%%@NL@%
%@AB@%; calls an absolute address.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;Entry:%@AE@%%@NL@%
%@AB@%; The actual number of parameters is variable, and depends on the routine%@AE@%%@NL@%
%@AB@%; that ABSOLUTE will in turn call. The LAST parameter pushed MUST be the DS%@AE@%%@NL@%
%@AB@%; offset of an integer variable containing the offset of the routine to be%@AE@%%@NL@%
%@AB@%; called. The current DEF SEG is used as the segment for the call.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;Exit:%@AE@%%@NL@%
%@AB@%; Whatever the called routine elects. We do NOT return here.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;Uses:%@AE@%%@NL@%
%@AB@%; This routine follows convention, but does no saving or checking of the code%@AE@%%@NL@%
%@AB@%; actually called.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;Notes:%@AE@%%@NL@%
%@AB@%; The called routine receives control with all parameters passed to ABSOLUTE,%@AE@%%@NL@%
%@AB@%; except the offset integer, on the stack in Pascal convention. The return%@AE@%%@NL@%
%@AB@%; address present is back to the BASIC level code which CALLed ABSOLUTE.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Stack on call to ABSOLUTE:%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;               \       Variable number of parameters           \%@AE@%%@NL@%
%@AB@%;               |          to routine to be CALLed              |%@AE@%%@NL@%
%@AB@%;               +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+%@AE@%%@NL@%
%@AB@%;               |       Near pointer to I2 var containing       |%@AE@%%@NL@%
%@AB@%;               |       the offset of the routine to CALL       |%@AE@%%@NL@%
%@AB@%;               +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+%@AE@%%@NL@%
%@AB@%;               |CS                                             |%@AE@%%@NL@%
%@AB@%;               +    Far return address to caller of ABSOLUTE   +%@AE@%%@NL@%
%@AB@%;       [SP] -> |IP                                             |%@AE@%%@NL@%
%@AB@%;               +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Stack on transfer to called routine:%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;               \       Variable number of parameters           \%@AE@%%@NL@%
%@AB@%;               |          to routine to be CALLed              |%@AE@%%@NL@%
%@AB@%;               +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+%@AE@%%@NL@%
%@AB@%;               |CS                                             |%@AE@%%@NL@%
%@AB@%;               +    Far return address to caller of ABSOLUTE   +%@AE@%%@NL@%
%@AB@%;       [SP] -> |IP                                             |%@AE@%%@NL@%
%@AB@%;               +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;******************************************************************************%@AE@%%@NL@%
%@NL@%
        .CODE%@NL@%
%@NL@%
ABSOLUTE PROC FAR%@NL@%
%@NL@%
        POP     AX              %@AB@%;return offset%@AE@%%@NL@%
        POP     DX              %@AB@%;return segment%@AE@%%@NL@%
        POP     BX              %@AB@%;get pointer to routine address%@AE@%%@NL@%
        PUSH    DX              %@AB@%;restore return address%@AE@%%@NL@%
        PUSH    AX%@NL@%
        PUSH    [b$seg]         %@AB@%;stack DEF SEG segment%@AE@%%@NL@%
        PUSH    [BX]            %@AB@%;stack routine offset%@AE@%%@NL@%
%@NL@%
        RET                     %@AB@%;jump to ABSOLUTE routine%@AE@%%@NL@%
%@NL@%
ABSOLUTE ENDP%@NL@%
%@NL@%
        END%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ATTRIB.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\ATTRIB.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ATTRIB                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        ATTRIB.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Displays all combinations of text mode character%@AE@%%@NL@%
%@AB@%  ' attributes on the screen for review.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:    CGA%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' FUNCTIONS:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@NL@%
    DECLARE SUB Attrib ()%@NL@%
%@NL@%
%@AB@%  ' Call the subprogram%@AE@%%@NL@%
    Attrib%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    END%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Attrib                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        ATTRIB.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Displays table of color attributes for text mode.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Attrib%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       bgd%        Background number for COLOR statement%@AE@%%@NL@%
%@AB@%  '                  fgd%        Foreground number for COLOR statement%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:              DECLARE SUB Attrib ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Attrib STATIC%@NL@%
        SCREEN 0%@NL@%
        CLS%@NL@%
        PRINT "Attributes for the COLOR statement in text mode (SCREEN 0)."%@NL@%
        PRINT "Add 16 to the foreground to cause the character to blink."%@NL@%
        FOR bgd% = 0 TO 7%@NL@%
            COLOR bgd% XOR 7, bgd%%@NL@%
            PRINT%@NL@%
            PRINT "Background%"; STR$(bgd%),%@NL@%
            PRINT "Foreground% ..."; SPACE$(41)%@NL@%
            FOR fgd% = 0 TO 15%@NL@%
                COLOR fgd%, bgd%%@NL@%
                PRINT STR$(fgd%); "  ";%@NL@%
            NEXT fgd%%@NL@%
        NEXT bgd%%@NL@%
        COLOR 7, 0%@NL@%
        PRINT%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BALLPSET.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\BALLPSET.BAS%@AE@%%@NL@%
%@NL@%
DECLARE FUNCTION GetArraySize (WLeft, WRight, WTop, WBottom)%@NL@%
%@NL@%
SCREEN 2%@NL@%
CLS%@NL@%
%@NL@%
%@AB@%' Define a viewport and draw a border around it:%@AE@%%@NL@%
VIEW (20, 10)-(620, 190), , 1%@NL@%
%@NL@%
CONST PI = 3.141592653589#%@NL@%
%@NL@%
%@AB@%' Redefine the coordinates of the viewport with logical%@AE@%%@NL@%
%@AB@%' coordinates:%@AE@%%@NL@%
WINDOW (-3.15, -.14)-(3.56, 1.01)%@NL@%
%@NL@%
%@AB@%' Arrays in program are now dynamic:%@AE@%%@NL@%
%@AB@%' $DYNAMIC%@AE@%%@NL@%
%@NL@%
%@AB@%' Calculate the logical coordinates for the top and bottom of a%@AE@%%@NL@%
%@AB@%' rectangle large enough to hold the image that will be drawn%@AE@%%@NL@%
%@AB@%' with CIRCLE and PAINT:%@AE@%%@NL@%
WLeft = -.21%@NL@%
WRight = .21%@NL@%
WTop = .07%@NL@%
WBottom = -.07%@NL@%
%@NL@%
%@AB@%' Call the GetArraySize function, passing it the rectangle's%@AE@%%@NL@%
%@AB@%' logical coordinates:%@AE@%%@NL@%
ArraySize% = GetArraySize(WLeft, WRight, WTop, WBottom)%@NL@%
%@NL@%
DIM Array(1 TO ArraySize%) AS INTEGER%@NL@%
%@NL@%
%@AB@%' Draw and paint the circle:%@AE@%%@NL@%
CIRCLE (0, 0), .18%@NL@%
PAINT (0, 0)%@NL@%
%@NL@%
%@AB@%' Store the rectangle in Array:%@AE@%%@NL@%
GET (WLeft, WTop)-(WRight, WBottom), Array%@NL@%
CLS%@NL@%
%@NL@%
%@AB@%' Draw a box and fill it with a pattern:%@AE@%%@NL@%
LINE (-3, .8)-(3.4, .2), , B%@NL@%
Pattern$ = CHR$(126) + CHR$(0) + CHR$(126) + CHR$(126)%@NL@%
PAINT (0, .5), Pattern$%@NL@%
%@NL@%
LOCATE 21, 29%@NL@%
PRINT "Press any key to end"%@NL@%
%@NL@%
%@AB@%' Initialize loop variables:%@AE@%%@NL@%
StepSize = .02%@NL@%
StartLoop = -PI%@NL@%
Decay = 1%@NL@%
%@NL@%
DO%@NL@%
   EndLoop = -StartLoop%@NL@%
   FOR X = StartLoop TO EndLoop STEP StepSize%@NL@%
%@NL@%
%@AB@%      ' Each time the ball "bounces" (hits the bottom of the%@AE@%%@NL@%
%@AB@%      ' viewport), the Decay variable gets smaller, making the%@AE@%%@NL@%
%@AB@%      ' height of the next bounce smaller:%@AE@%%@NL@%
      Y = ABS(COS(X)) * Decay - .14%@NL@%
      IF Y < -.13 THEN Decay = Decay * .9%@NL@%
%@NL@%
%@AB@%      ' Stop if a key pressed or if Decay is less than .01:%@AE@%%@NL@%
      Esc$ = INKEY$%@NL@%
      IF Esc$ <> "" OR Decay < .01 THEN EXIT FOR%@NL@%
%@NL@%
%@AB@%      ' Put the image on the screen.  The StepSize offset is%@AE@%%@NL@%
%@AB@%      ' smaller than the border around the circle, so each time%@AE@%%@NL@%
%@AB@%      ' the image moves, it erases any traces left from the%@AE@%%@NL@%
%@AB@%      ' previous PUT (it also erases anything else on the%@AE@%%@NL@%
%@AB@%      ' screen):%@AE@%%@NL@%
      PUT (X, Y), Array, PSET%@NL@%
   NEXT X%@NL@%
%@NL@%
%@AB@%   ' Reverse direction:%@AE@%%@NL@%
   StepSize = -StepSize%@NL@%
   StartLoop = -StartLoop%@NL@%
LOOP UNTIL Esc$ <> "" OR Decay < .01%@NL@%
%@NL@%
Pause$ = INPUT$(1)%@NL@%
END%@NL@%
REM $STATIC%@NL@%
REM $DYNAMIC%@NL@%
FUNCTION GetArraySize (WLeft, WRight, WTop, WBottom) STATIC%@NL@%
%@NL@%
%@AB@%   ' Map the logical coordinates passed to this function to%@AE@%%@NL@%
%@AB@%   ' their physical-coordinate equivalents:%@AE@%%@NL@%
   VLeft = PMAP(WLeft, 0)%@NL@%
   VRight = PMAP(WRight, 0)%@NL@%
   VTop = PMAP(WTop, 1)%@NL@%
   VBottom = PMAP(WBottom, 1)%@NL@%
%@NL@%
%@AB@%   ' Calculate the height and width in pixels of the%@AE@%%@NL@%
%@AB@%   ' enclosing rectangle:%@AE@%%@NL@%
   RectHeight = ABS(VBottom - VTop) + 1%@NL@%
   RectWidth = ABS(VRight - VLeft) + 1%@NL@%
%@NL@%
%@AB@%   ' Calculate size in bytes of array:%@AE@%%@NL@%
   ByteSize = 4 + RectHeight * INT((RectWidth + 7) / 8)%@NL@%
%@NL@%
%@AB@%   ' Array is integer, so divide bytes by two:%@AE@%%@NL@%
   GetArraySize = ByteSize \ 2 + 1%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BALLXOR.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\BALLXOR.BAS%@AE@%%@NL@%
%@NL@%
DECLARE FUNCTION GetArraySize (WLeft, WRight, WTop, WBottom)%@NL@%
%@NL@%
SCREEN 2%@NL@%
CLS%@NL@%
VIEW (20, 10)-(620, 190), , 1%@NL@%
%@NL@%
CONST PI = 3.141592653589#%@NL@%
%@NL@%
WINDOW (-3.15, -.14)-(3.56, 1.01)%@NL@%
%@NL@%
%@AB@%' $DYNAMIC%@AE@%%@NL@%
%@AB@%' The rectangle is smaller than the one in the previous%@AE@%%@NL@%
%@AB@%' program, which means Array is also smaller:%@AE@%%@NL@%
WLeft = -.18%@NL@%
WRight = .18%@NL@%
WTop = .05%@NL@%
WBottom = -.05%@NL@%
%@NL@%
ArraySize% = GetArraySize(WLeft, WRight, WTop, WBottom)%@NL@%
%@NL@%
DIM Array(1 TO ArraySize%) AS INTEGER%@NL@%
%@NL@%
CIRCLE (0, 0), .18%@NL@%
PAINT (0, 0)%@NL@%
%@NL@%
GET (WLeft, WTop)-(WRight, WBottom), Array%@NL@%
CLS%@NL@%
%@NL@%
LINE (-3, .8)-(3.4, .2), , B%@NL@%
Pattern$ = CHR$(126) + CHR$(0) + CHR$(126) + CHR$(126)%@NL@%
PAINT (0, .5), Pattern$%@NL@%
%@NL@%
LOCATE 21, 29%@NL@%
PRINT "Press any key to end"%@NL@%
%@NL@%
StepSize = .02%@NL@%
StartLoop = -PI%@NL@%
Decay = 1%@NL@%
%@NL@%
DO%@NL@%
   EndLoop = -StartLoop%@NL@%
   FOR X = StartLoop TO EndLoop STEP StepSize%@NL@%
      Y = ABS(COS(X)) * Decay - .14%@NL@%
%@NL@%
%@AB@%      ' The first PUT statement places the image on%@AE@%%@NL@%
%@AB@%      ' the screen:%@AE@%%@NL@%
      PUT (X, Y), Array, XOR%@NL@%
%@NL@%
%@AB@%      ' An empty FOR...NEXT loop to delay the program and%@AE@%%@NL@%
%@AB@%      ' reduce image flicker:%@AE@%%@NL@%
      FOR I = 1 TO 5: NEXT I%@NL@%
%@NL@%
      IF Y < -.13 THEN Decay = Decay * .9%@NL@%
      Esc$ = INKEY$%@NL@%
      IF Esc$ <> "" OR Decay < .01 THEN EXIT FOR%@NL@%
%@NL@%
%@AB@%      ' The second PUT statement erases the image and%@AE@%%@NL@%
%@AB@%      ' restores the background:%@AE@%%@NL@%
      PUT (X, Y), Array, XOR%@NL@%
   NEXT X%@NL@%
%@NL@%
   StepSize = -StepSize%@NL@%
   StartLoop = -StartLoop%@NL@%
LOOP UNTIL Esc$ <> "" OR Decay < .01%@NL@%
%@NL@%
Pause$ = INPUT$(1)%@NL@%
END%@NL@%
REM $STATIC%@NL@%
REM $DYNAMIC%@NL@%
FUNCTION GetArraySize (WLeft, WRight, WTop, WBottom) STATIC%@NL@%
   VLeft = PMAP(WLeft, 0)%@NL@%
   VRight = PMAP(WRight, 0)%@NL@%
   VTop = PMAP(WTop, 1)%@NL@%
   VBottom = PMAP(WBottom, 1)%@NL@%
%@NL@%
   RectHeight = ABS(VBottom - VTop) + 1%@NL@%
   RectWidth = ABS(VRight - VLeft) + 1%@NL@%
%@NL@%
   ByteSize = 4 + RectHeight * INT((RectWidth + 7) / 8)%@NL@%
   GetArraySize = ByteSize \ 2 + 1%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BAR.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\BAR.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' Define type for the titles:%@AE@%%@NL@%
TYPE TitleType%@NL@%
   MainTitle AS STRING * 40%@NL@%
   XTitle AS STRING * 40%@NL@%
   YTitle AS STRING * 18%@NL@%
END TYPE%@NL@%
%@NL@%
DECLARE SUB InputTitles (T AS TitleType)%@NL@%
DECLARE FUNCTION DrawGraph$ (T AS TitleType, Label$(), Value!(), N%)%@NL@%
DECLARE FUNCTION InputData% (Label$(), Value!())%@NL@%
%@NL@%
%@AB@%' Variable declarations for titles and bar data:%@AE@%%@NL@%
DIM Titles AS TitleType, Label$(1 TO 5), Value(1 TO 5)%@NL@%
%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE%@NL@%
%@NL@%
DO%@NL@%
   InputTitles Titles%@NL@%
   N% = InputData%(Label$(), Value())%@NL@%
   IF N% <> FALSE THEN%@NL@%
      NewGraph$ = DrawGraph$(Titles, Label$(), Value(), N%)%@NL@%
   END IF%@NL@%
LOOP WHILE NewGraph$ = "Y"%@NL@%
%@NL@%
END%@NL@%
REM $STATIC%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ========================== DRAWGRAPH =========================%@AE@%%@NL@%
%@AB@%'   Draws a bar graph from the data entered in the INPUTTITLES%@AE@%%@NL@%
%@AB@%'   and INPUTDATA procedures.%@AE@%%@NL@%
%@AB@%' ==============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION DrawGraph$ (T AS TitleType, Label$(), Value(), N%) STATIC%@NL@%
%@NL@%
%@AB@%   ' Set size of graph:%@AE@%%@NL@%
   CONST GRAPHTOP = 24, GRAPHBOTTOM = 171%@NL@%
   CONST GRAPHLEFT = 48, GRAPHRIGHT = 624%@NL@%
   CONST YLENGTH = GRAPHBOTTOM - GRAPHTOP%@NL@%
%@NL@%
%@AB@%   ' Calculate max/min values:%@AE@%%@NL@%
   YMax = 0%@NL@%
   YMin = 0%@NL@%
   FOR I% = 1 TO N%%@NL@%
      IF Value(I%) < YMin THEN YMin = Value(I%)%@NL@%
      IF Value(I%) > YMax THEN YMax = Value(I%)%@NL@%
   NEXT I%%@NL@%
%@NL@%
%@AB@%   ' Calculate width of bars and space between them:%@AE@%%@NL@%
   BarWidth = (GRAPHRIGHT - GRAPHLEFT) / N%%@NL@%
   BarSpace = .2 * BarWidth%@NL@%
   BarWidth = BarWidth - BarSpace%@NL@%
%@NL@%
   SCREEN 2%@NL@%
   CLS%@NL@%
%@NL@%
%@AB@%   ' Draw y axis:%@AE@%%@NL@%
   LINE (GRAPHLEFT, GRAPHTOP)-(GRAPHLEFT, GRAPHBOTTOM), 1%@NL@%
%@NL@%
%@AB@%   ' Draw main graph title:%@AE@%%@NL@%
   Start% = 44 - (LEN(RTRIM$(T.MainTitle)) / 2)%@NL@%
   LOCATE 2, Start%%@NL@%
   PRINT RTRIM$(T.MainTitle);%@NL@%
%@NL@%
%@AB@%   ' Annotate Y axis:%@AE@%%@NL@%
   Start% = CINT(13 - LEN(RTRIM$(T.YTitle)) / 2)%@NL@%
   FOR I% = 1 TO LEN(RTRIM$(T.YTitle))%@NL@%
      LOCATE Start% + I% - 1, 1%@NL@%
      PRINT MID$(T.YTitle, I%, 1);%@NL@%
   NEXT I%%@NL@%
%@NL@%
%@AB@%   ' Calculate scale factor so labels aren't bigger than 4 digits:%@AE@%%@NL@%
   IF ABS(YMax) > ABS(YMin) THEN%@NL@%
      Power = YMax%@NL@%
   ELSE%@NL@%
      Power = YMin%@NL@%
   END IF%@NL@%
   Power = CINT(LOG(ABS(Power) / 100) / LOG(10))%@NL@%
   IF Power < 0 THEN Power = 0%@NL@%
%@NL@%
%@AB@%   ' Scale min and max down:%@AE@%%@NL@%
   ScaleFactor = 10 ^ Power%@NL@%
   YMax = CINT(YMax / ScaleFactor)%@NL@%
   YMin = CINT(YMin / ScaleFactor)%@NL@%
%@NL@%
%@AB@%   ' If power isn't zero then put scale factor on chart:%@AE@%%@NL@%
   IF Power <> 0 THEN%@NL@%
      LOCATE 3, 2%@NL@%
      PRINT "x 10^"; LTRIM$(STR$(Power))%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' Put tic mark and number for Max point on Y axis:%@AE@%%@NL@%
   LINE (GRAPHLEFT - 3, GRAPHTOP)-STEP(3, 0)%@NL@%
   LOCATE 4, 2%@NL@%
   PRINT USING "####"; YMax%@NL@%
%@NL@%
%@AB@%   ' Put tic mark and number for Min point on Y axis:%@AE@%%@NL@%
   LINE (GRAPHLEFT - 3, GRAPHBOTTOM)-STEP(3, 0)%@NL@%
   LOCATE 22, 2%@NL@%
   PRINT USING "####"; YMin%@NL@%
%@NL@%
%@AB@%   ' Scale min and max back up for charting calculations:%@AE@%%@NL@%
   YMax = YMax * ScaleFactor%@NL@%
   YMin = YMin * ScaleFactor%@NL@%
%@NL@%
%@AB@%   ' Annotate X axis:%@AE@%%@NL@%
   Start% = 44 - (LEN(RTRIM$(T.XTitle)) / 2)%@NL@%
   LOCATE 25, Start%%@NL@%
   PRINT RTRIM$(T.XTitle);%@NL@%
%@NL@%
%@AB@%   ' Calculate the pixel range for the Y axis:%@AE@%%@NL@%
   YRange = YMax - YMin%@NL@%
%@NL@%
%@AB@%   ' Define a diagonally striped pattern:%@AE@%%@NL@%
   Tile$ = CHR$(1) + CHR$(2) + CHR$(4) + CHR$(8) + CHR$(16) + CHR$(32) + CHR$(64) + CHR$(128)%@NL@%
%@NL@%
%@AB@%   ' Draw a zero line if appropriate:%@AE@%%@NL@%
   IF YMin < 0 THEN%@NL@%
      Bottom = GRAPHBOTTOM - ((-YMin) / YRange * YLENGTH)%@NL@%
      LOCATE INT((Bottom - 1) / 8) + 1, 5%@NL@%
      PRINT "0";%@NL@%
   ELSE%@NL@%
      Bottom = GRAPHBOTTOM%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' Draw x axis:%@AE@%%@NL@%
   LINE (GRAPHLEFT - 3, Bottom)-(GRAPHRIGHT, Bottom)%@NL@%
%@NL@%
%@AB@%   ' Draw bars and labels:%@AE@%%@NL@%
   Start% = GRAPHLEFT + (BarSpace / 2)%@NL@%
   FOR I% = 1 TO N%%@NL@%
%@NL@%
%@AB@%      ' Draw a bar label:%@AE@%%@NL@%
      BarMid = Start% + (BarWidth / 2)%@NL@%
      CharMid = INT((BarMid - 1) / 8) + 1%@NL@%
      LOCATE 23, CharMid - INT(LEN(RTRIM$(Label$(I%))) / 2)%@NL@%
      PRINT Label$(I%);%@NL@%
%@NL@%
%@AB@%      ' Draw the bar and fill it with the striped pattern:%@AE@%%@NL@%
      BarHeight = (Value(I%) / YRange) * YLENGTH%@NL@%
      LINE (Start%, Bottom)-STEP(BarWidth, -BarHeight), , B%@NL@%
      PAINT (BarMid, Bottom - (BarHeight / 2)), Tile$, 1%@NL@%
%@NL@%
      Start% = Start% + BarWidth + BarSpace%@NL@%
   NEXT I%%@NL@%
%@NL@%
   LOCATE 1, 1, 1%@NL@%
   PRINT "New graph? ";%@NL@%
   DrawGraph$ = UCASE$(INPUT$(1))%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ========================= INPUTDATA ========================%@AE@%%@NL@%
%@AB@%'         Gets input for the bar labels and their values%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION InputData% (Label$(), Value()) STATIC%@NL@%
%@NL@%
%@AB@%   ' Initialize the number of data values:%@AE@%%@NL@%
   NumData% = 0%@NL@%
%@NL@%
%@AB@%   ' Print data-entry instructions:%@AE@%%@NL@%
   CLS%@NL@%
   PRINT "Enter data for up to 5 bars:"%@NL@%
   PRINT "   * Enter the label and value for each bar."%@NL@%
   PRINT "   * Values can be negative."%@NL@%
   PRINT "   * Enter a blank label to stop."%@NL@%
   PRINT%@NL@%
   PRINT "After viewing the graph, press any key ";%@NL@%
   PRINT "to end the program."%@NL@%
%@NL@%
%@AB@%   ' Accept data until blank label or 5 entries:%@AE@%%@NL@%
   Done% = FALSE%@NL@%
   DO%@NL@%
      NumData% = NumData% + 1%@NL@%
      PRINT%@NL@%
      PRINT "Bar("; LTRIM$(STR$(NumData%)); "):"%@NL@%
      INPUT ; "        Label? ", Label$(NumData%)%@NL@%
%@NL@%
%@AB@%      ' Only input value if label isn't blank:%@AE@%%@NL@%
      IF Label$(NumData%) <> "" THEN%@NL@%
         LOCATE , 35%@NL@%
         INPUT "Value? ", Value(NumData%)%@NL@%
%@NL@%
%@AB@%      ' If label was blank, decrement data counter and%@AE@%%@NL@%
%@AB@%      ' set Done flag equal to TRUE:%@AE@%%@NL@%
      ELSE%@NL@%
         NumData% = NumData% - 1%@NL@%
         Done% = TRUE%@NL@%
      END IF%@NL@%
   LOOP UNTIL (NumData% = 5) OR Done%%@NL@%
%@NL@%
%@AB@%   ' Return the number of data values input:%@AE@%%@NL@%
   InputData% = NumData%%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================= INPUTTITLES ========================%@AE@%%@NL@%
%@AB@%'       Accepts input for the three different graph titles%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB InputTitles (T AS TitleType) STATIC%@NL@%
%@NL@%
%@AB@%   ' Set text screen:%@AE@%%@NL@%
   SCREEN 0, 0%@NL@%
%@NL@%
%@AB@%   ' Input Titles%@AE@%%@NL@%
   DO%@NL@%
      CLS%@NL@%
      INPUT "Enter main graph title: ", T.MainTitle%@NL@%
      INPUT "Enter X-Axis title    : ", T.XTitle%@NL@%
      INPUT "Enter Y-Axis title    : ", T.YTitle%@NL@%
%@NL@%
%@AB@%      ' Check to see if titles are OK:%@AE@%%@NL@%
      LOCATE 7, 1%@NL@%
      PRINT "OK (Y to continue, N to change)? ";%@NL@%
      LOCATE , , 1%@NL@%
      OK$ = UCASE$(INPUT$(1))%@NL@%
   LOOP UNTIL OK$ = "Y"%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIN2HEX.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\BIN2HEX.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          BIN2HEX                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BIN2HEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Reads in any file and writes out a hexadecimal format file%@AE@%%@NL@%
%@AB@%  ' suitable for rebuilding the original file using the HEX2BIN%@AE@%%@NL@%
%@AB@%  ' program.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:          BIN2HEX inFileName.ext outFileName.ext%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:      BIN2HEX.BAS%@AE@%%@NL@%
%@AB@%  '                 PARSE.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:     inFileName    Name of file to be duplicated in hexadecimal%@AE@%%@NL@%
%@AB@%  '                               format%@AE@%%@NL@%
%@AB@%  '                 outFileName   Name of hexadecimal format file to be created%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      cmd$          Working copy of the command line%@AE@%%@NL@%
%@AB@%  '                 inFile$       Name of input file%@AE@%%@NL@%
%@AB@%  '                 outFile$      Name of output file%@AE@%%@NL@%
%@AB@%  '                 byte$         Buffer for binary file access%@AE@%%@NL@%
%@AB@%  '                 i&            Index to each byte of input file%@AE@%%@NL@%
%@AB@%  '                 h$            Pair of hexadecimal characters representing%@AE@%%@NL@%
%@AB@%  '                               each byte%@AE@%%@NL@%
%@NL@%
%@NL@%
    DECLARE SUB ParseWord (a$, sep$, word$)%@NL@%
%@NL@%
%@AB@%  ' Initialization%@AE@%%@NL@%
    CLS%@NL@%
    PRINT "BIN2HEX "; COMMAND$%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Get the input and output filenames from the command line%@AE@%%@NL@%
    cmd$ = COMMAND$%@NL@%
    ParseWord cmd$, " ,", inFile$%@NL@%
    ParseWord cmd$, " ,", outFile$%@NL@%
%@NL@%
%@AB@%  ' Verify that both filenames were given%@AE@%%@NL@%
    IF outFile$ = "" THEN%@NL@%
        PRINT%@NL@%
        PRINT "Usage: BIN2HEX inFileName outFileName"%@NL@%
        SYSTEM%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Open the input file%@AE@%%@NL@%
    OPEN inFile$ FOR BINARY AS #1 LEN = 1%@NL@%
    IF LOF(1) = 0 THEN%@NL@%
        CLOSE #1%@NL@%
        KILL inFile$%@NL@%
        PRINT%@NL@%
        PRINT "File not found - "; inFile$%@NL@%
        SYSTEM%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Open the output file%@AE@%%@NL@%
    OPEN outFile$ FOR OUTPUT AS #2%@NL@%
%@NL@%
%@AB@%  ' Process each byte of the file%@AE@%%@NL@%
    byte$ = SPACE$(1)%@NL@%
    FOR i& = 1 TO LOF(1)%@NL@%
        GET #1, , byte$%@NL@%
        h$ = RIGHT$("0" + HEX$(ASC(byte$)), 2)%@NL@%
        PRINT #2, h$; SPACE$(1);%@NL@%
        IF i& = LOF(1) THEN%@NL@%
            PRINT #2, ""%@NL@%
        ELSEIF i& MOD 16 = 0 THEN%@NL@%
            PRINT #2, ""%@NL@%
        ELSEIF i& MOD 8 = 0 THEN%@NL@%
            PRINT #2, "- ";%@NL@%
        END IF%@NL@%
    NEXT i&%@NL@%
%@NL@%
%@AB@%  ' Clean up and quit%@AE@%%@NL@%
    CLOSE%@NL@%
    END%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BIOSCALL.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\BIOSCALL.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          BIOSCALL                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BIOSCALL.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Demonstrates several interrupt calls to the ROM BIOS.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE: No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:    MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%         Loop index for creating lines to scroll%@AE@%%@NL@%
%@AB@%  '                  equip      Structure of type EquipmentType%@AE@%%@NL@%
%@AB@%  '                  mode%      Video mode returned by VideoState%@AE@%%@NL@%
%@AB@%  '                  columns%   Video columns returned by VideoState%@AE@%%@NL@%
%@AB@%  '                  page%      Video page returned by VideoState%@AE@%%@NL@%
%@AB@%  '                  shift      Structure of type ShiftType%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Constants%@AE@%%@NL@%
    CONST FALSE = 0%@NL@%
    CONST TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%  ' Declare the Type structures%@AE@%%@NL@%
    TYPE RegType%@NL@%
        ax    AS INTEGER%@NL@%
        bx    AS INTEGER%@NL@%
        cx    AS INTEGER%@NL@%
        dx    AS INTEGER%@NL@%
        Bp    AS INTEGER%@NL@%
        si    AS INTEGER%@NL@%
        di    AS INTEGER%@NL@%
        flags AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE RegTypeX%@NL@%
        ax    AS INTEGER%@NL@%
        bx    AS INTEGER%@NL@%
        cx    AS INTEGER%@NL@%
        dx    AS INTEGER%@NL@%
        Bp    AS INTEGER%@NL@%
        si    AS INTEGER%@NL@%
        di    AS INTEGER%@NL@%
        flags AS INTEGER%@NL@%
        ds    AS INTEGER%@NL@%
        es    AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE EquipmentType%@NL@%
        printers     AS INTEGER%@NL@%
        gameAdapter  AS INTEGER%@NL@%
        serial       AS INTEGER%@NL@%
        floppies     AS INTEGER%@NL@%
        initialVideo AS INTEGER%@NL@%
        coprocessor  AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE ShiftType%@NL@%
        right           AS INTEGER%@NL@%
        left            AS INTEGER%@NL@%
        ctrl            AS INTEGER%@NL@%
        alt             AS INTEGER%@NL@%
        scrollLockState AS INTEGER%@NL@%
        numLockState    AS INTEGER%@NL@%
        capsLockState   AS INTEGER%@NL@%
        insertState     AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@NL@%
    DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@NL@%
    DECLARE SUB PrintScreen ()%@NL@%
    DECLARE SUB Scroll (row1%, col1%, row2%, col2%, lines%, attribute%)%@NL@%
    DECLARE SUB Equipment (equip AS EquipmentType)%@NL@%
    DECLARE SUB VideoState (mode%, columns%, page%)%@NL@%
    DECLARE SUB GetShiftStates (shift AS ShiftType)%@NL@%
    DECLARE SUB ReBoot ()%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the Scroll subprogram%@AE@%%@NL@%
    CLS%@NL@%
    FOR i% = 1 TO 15%@NL@%
        COLOR i%, i% - 1%@NL@%
        PRINT STRING$(25, i% + 64)%@NL@%
    NEXT i%%@NL@%
    COLOR 7, 0%@NL@%
    PRINT%@NL@%
    PRINT "Press <Enter> to scroll part of the screen"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ = CHR$(13)%@NL@%
    Scroll 2, 3, 6, 16, 3, SCREEN(2, 3, 1)%@NL@%
%@NL@%
%@AB@%  ' Wait for user before continuing%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
    CLS%@NL@%
%@NL@%
%@AB@%  ' Determine the equipment information%@AE@%%@NL@%
    DIM equip AS EquipmentType%@NL@%
    Equipment equip%@NL@%
    PRINT "Printers:", equip.printers%@NL@%
    PRINT "Game adapter:", equip.gameAdapter%@NL@%
    PRINT "Serial IO:", equip.serial%@NL@%
    PRINT "Floppies:", equip.floppies%@NL@%
    PRINT "Video:", equip.initialVideo%@NL@%
    PRINT "Coprocessor:", equip.coprocessor%@NL@%
%@NL@%
%@AB@%  ' Determine the current video state%@AE@%%@NL@%
    PRINT%@NL@%
    VideoState mode%, columns%, page%%@NL@%
    PRINT "Video mode:", mode%%@NL@%
    PRINT "Text columns:", columns%%@NL@%
    PRINT "Video page:", page%%@NL@%
%@NL@%
%@AB@%  ' Wait for user before continuing%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the shift key states%@AE@%%@NL@%
    CLS%@NL@%
    PRINT "(Press shift keys, then <Enter> to continue...)"%@NL@%
    DIM shift AS ShiftType%@NL@%
    DO%@NL@%
        LOCATE 4, 1%@NL@%
        PRINT "Shift states:"%@NL@%
        GetShiftStates shift%@NL@%
        PRINT%@NL@%
        PRINT "Left shift:", shift.left%@NL@%
        PRINT "Right shift:", shift.right%@NL@%
        PRINT "Ctrl:", shift.ctrl%@NL@%
        PRINT "Alt:", shift.alt%@NL@%
        PRINT "Scroll Lock:", shift.scrollLockState%@NL@%
        PRINT "Num Lock:", shift.numLockState%@NL@%
        PRINT "Caps Lock:", shift.capsLockState%@NL@%
        PRINT "Insert:", shift.insertState%@NL@%
    LOOP UNTIL INKEY$ = CHR$(13)%@NL@%
%@NL@%
%@AB@%  ' Uncomment the following line to cause a screen dump to printer....%@AE@%%@NL@%
%@AB@%  ' PrintScreen%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Uncomment the following line only if you want to reboot....%@AE@%%@NL@%
%@AB@%  ' ReBoot%@AE@%%@NL@%
%@NL@%
    END%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Equipment                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BIOSCALL.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns equipment configuration information from BIOS.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Equipment equip%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      equip      Structure of type EquipmentType%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegType%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegType%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     Bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  TYPE EquipmentType%@AE@%%@NL@%
%@AB@%  '                     printers     AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     gameAdapter  AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     serial       AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     floppies     AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     initialVideo AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     coprocessor  AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '     DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '     DECLARE SUB Equipment (equip AS EquipmentType)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Equipment (equip AS EquipmentType) STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        Interrupt &H11, reg, reg%@NL@%
        equip.printers = (reg.ax AND &HC000&) \ 16384%@NL@%
        equip.gameAdapter = (reg.ax AND &H1000) \ 4096%@NL@%
        equip.serial = (reg.ax AND &HE00) \ 512%@NL@%
        equip.floppies = (reg.ax AND &HC0) \ 64 + 1%@NL@%
        equip.initialVideo = (reg.ax AND &H30) \ 16%@NL@%
        equip.coprocessor = (reg.ax AND 2) \ 2%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetShiftStates             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BIOSCALL.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Return state of the various shift keys.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  GetShiftStates shift%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      shift      Structure of type ShiftType%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegType%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegType%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     Bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  TYPE ShiftType%@AE@%%@NL@%
%@AB@%  '                     right           AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     left            AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     ctrl            AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     alt             AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     scrollLockState AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     numLockState    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     capsLockState   AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     insertState     AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB GetShiftStates (shift AS ShiftType)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB GetShiftStates (shift AS ShiftType) STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        reg.ax = &H200%@NL@%
        Interrupt &H16, reg, reg%@NL@%
        shift.right = reg.ax AND 1%@NL@%
        shift.left = (reg.ax AND 2) \ 2%@NL@%
        shift.ctrl = (reg.ax AND 4) \ 4%@NL@%
        shift.alt = (reg.ax AND 8) \ 8%@NL@%
        shift.scrollLockState = (reg.ax AND 16) \ 16%@NL@%
        shift.numLockState = (reg.ax AND 32) \ 32%@NL@%
        shift.capsLockState = (reg.ax AND 64) \ 64%@NL@%
        shift.insertState = (reg.ax AND 128) \ 128%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          PrintScreen                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BIOSCALL.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Activates interrupt 5 to cause a dump of the%@AE@%%@NL@%
%@AB@%  ' screen's contents to the printer.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  PrintScreen%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegType%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegType%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     Bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB PrintScreen ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB PrintScreen STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        Interrupt 5, reg, reg%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ReBoot                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BIOSCALL.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Causes the computer to reboot.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ReBoot%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegType%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegType%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     Bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB ReBoot ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ReBoot STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        Interrupt &H19, reg, reg%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Scroll                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BIOSCALL.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Scrolls the screen in the rectangular area defined%@AE@%%@NL@%
%@AB@%  ' by the row and col parameters.  Positive line count%@AE@%%@NL@%
%@AB@%  ' moves the lines up, leaving blank lines at bottom;%@AE@%%@NL@%
%@AB@%  ' negative line count moves the lines down.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Scroll row1%, col1%, row2%, col2%, lines%, attr%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      row1%    Upper left character row defining rectangular%@AE@%%@NL@%
%@AB@%  '                           scroll area%@AE@%%@NL@%
%@AB@%  '                  col1     Upper left character column defining rectangular%@AE@%%@NL@%
%@AB@%  '                           scroll area%@AE@%%@NL@%
%@AB@%  '                  row2%    Lower right character row defining rectangular%@AE@%%@NL@%
%@AB@%  '                           scroll area%@AE@%%@NL@%
%@AB@%  '                  col2%    Lower right character column defining%@AE@%%@NL@%
%@AB@%  '                           rectangular scroll area%@AE@%%@NL@%
%@AB@%  '                  lines%   Number of character lines to scroll%@AE@%%@NL@%
%@AB@%  '                  attr%    Color attribute byte to be used in new text%@AE@%%@NL@%
%@AB@%  '                           lines scrolled onto the screen%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg      Structure of type RegType%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegType%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     Bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Scroll (row1%, col1%, row2%, col2%, lines%, attribute%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Scroll (row1%, col1%, row2%, col2%, lines%, attribute%) STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        IF lines% > 0 THEN%@NL@%
            reg.ax = &H600 + lines% MOD 256%@NL@%
        ELSE%@NL@%
            reg.ax = &H700 + ABS(lines%) MOD 256%@NL@%
        END IF%@NL@%
        reg.bx = (attribute% * 256&) AND &HFF00%@NL@%
        reg.cx = (row1% - 1) * 256 + col1% - 1%@NL@%
        reg.dx = (row2% - 1) * 256 + col2% - 1%@NL@%
        Interrupt &H10, reg, reg%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          VideoState                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BIOSCALL.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Determines the current video mode parameters.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  VideoState mode%, columns%, page%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mode%      Current video mode%@AE@%%@NL@%
%@AB@%  '                  columns%   Current number of text columns%@AE@%%@NL@%
%@AB@%  '                  page%      Current active display page%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegType%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegType%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     Bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB VideoState (mode%, columns%, page%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB VideoState (mode%, columns%, page%) STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        reg.ax = &HF00%@NL@%
        Interrupt &H10, reg, reg%@NL@%
        mode% = reg.ax AND &HFF%@NL@%
        columns% = (CLNG(reg.ax) AND &HFF00) \ 256%@NL@%
        page% = (CLNG(reg.bx) AND &HFF00) \ 256%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%BITS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\BITS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          BITS                       **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BITS.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Demonstrates the bit manipulation functions%@AE@%%@NL@%
%@AB@%  ' and subprograms.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE: No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       max%       Upper limit for the prime number generator%@AE@%%@NL@%
%@AB@%  '                  b$         Bit string for finding prime numbers%@AE@%%@NL@%
%@AB@%  '                  n%         Loop index for sieve of Eratosthenes%@AE@%%@NL@%
%@AB@%  '                  bit%       Bit retrieved from b$%@AE@%%@NL@%
%@AB@%  '                  i%         Bit loop index%@AE@%%@NL@%
%@AB@%  '                  q$         The double quote character%@AE@%%@NL@%
%@NL@%
%@NL@%
    DECLARE FUNCTION BinStr2Bin% (b$)%@NL@%
    DECLARE FUNCTION Bin2BinStr$ (b%)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB BitGet (a$, bitIndex%, bit%)%@NL@%
    DECLARE SUB BitPut (b$, bitIndex%, bit%)%@NL@%
%@NL@%
%@AB@%  ' Prime numbers less than max%, using bit fields in B$%@AE@%%@NL@%
    CLS%@NL@%
    max% = 1000%@NL@%
    PRINT "Primes up to"; max%; "using BitGet and BitPut for sieve..."%@NL@%
    PRINT%@NL@%
    PRINT 1; 2;%@NL@%
    b$ = STRING$(max% \ 8 + 1, 0)%@NL@%
    FOR n% = 3 TO max% STEP 2%@NL@%
        BitGet b$, n%, bit%%@NL@%
        IF bit% = 0 THEN%@NL@%
            PRINT n%;%@NL@%
            FOR i% = 3 * n% TO max% STEP n% + n%%@NL@%
                BitPut b$, i%, 1%@NL@%
            NEXT i%%@NL@%
        END IF%@NL@%
    NEXT n%%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Demonstration of the Bin2BinStr$ function%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "Bin2BinStr$(12345) = "; Bin2BinStr$(12345)%@NL@%
%@NL@%
%@AB@%  ' Demonstration of the BinStr2Bin% function%@AE@%%@NL@%
    PRINT%@NL@%
    q$ = CHR$(34)%@NL@%
    PRINT "BinStr2Bin%("; q$; "1001011"; q$; ") = ";%@NL@%
    PRINT BinStr2Bin%("1001011")%@NL@%
%@NL@%
%@AB@%  ' That's all%@AE@%%@NL@%
    END%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Bin2BinStr$                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BITS.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a string of sixteen "0" and "1" characters%@AE@%%@NL@%
%@AB@%  ' that represent the binary value of b%.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  PRINT Bin2BinStr$(b%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      b%         Integer number%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       t$         Working string space for forming binary string%@AE@%%@NL@%
%@AB@%  '                  b%         Integer number%@AE@%%@NL@%
%@AB@%  '                  mask%      Bit isolation mask%@AE@%%@NL@%
%@AB@%  '                  i%         Looping index%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Bin2BinStr$ (b%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Bin2BinStr$ (b%) STATIC%@NL@%
        t$ = STRING$(16, "0")%@NL@%
        IF b% THEN%@NL@%
            IF b% < 0 THEN%@NL@%
                MID$(t$, 1, 1) = "1"%@NL@%
            END IF%@NL@%
            mask% = &H4000%@NL@%
            FOR i% = 2 TO 16%@NL@%
                IF b% AND mask% THEN%@NL@%
                    MID$(t$, i%, 1) = "1"%@NL@%
                END IF%@NL@%
                mask% = mask% \ 2%@NL@%
            NEXT i%%@NL@%
        END IF%@NL@%
        Bin2BinStr$ = t$%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          BinStr2Bin%                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BITS.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the integer represented by a string of up%@AE@%%@NL@%
%@AB@%  ' to 16 "0" and "1" characters.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  PRINT BinStr2Bin%(b$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      b$         Binary representation string%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       bin%       Working variable for finding value%@AE@%%@NL@%
%@AB@%  '                  t$         Working copy of b$%@AE@%%@NL@%
%@AB@%  '                  mask%      Bit mask for forming value%@AE@%%@NL@%
%@AB@%  '                  i%         Looping index%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION BinStr2Bin% (b$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION BinStr2Bin% (b$) STATIC%@NL@%
        bin% = 0%@NL@%
        t$ = RIGHT$(STRING$(16, "0") + b$, 16)%@NL@%
        IF LEFT$(t$, 1) = "1" THEN%@NL@%
            bin% = &H8000%@NL@%
        END IF%@NL@%
        mask% = &H4000%@NL@%
        FOR i% = 2 TO 16%@NL@%
            IF MID$(t$, i%, 1) = "1" THEN%@NL@%
                bin% = bin% OR mask%%@NL@%
            END IF%@NL@%
            mask% = mask% \ 2%@NL@%
        NEXT i%%@NL@%
        BinStr2Bin% = bin%%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          BitGet                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BITS.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Extracts the bit at bitIndex% into a$ and returns%@AE@%%@NL@%
%@AB@%  ' either 0 or 1 in bit%.  The value of bitIndex%%@AE@%%@NL@%
%@AB@%  ' can range from 1 to 8 * LEN(a$).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  BitGet a$, bitIndex%, bit%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String where bit is stored%@AE@%%@NL@%
%@AB@%  '                  bitIndex%  Bit position in string%@AE@%%@NL@%
%@AB@%  '                  bit%       Extracted bit value, 0 or 1%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       byte%      Byte location in string of the bit%@AE@%%@NL@%
%@AB@%  '                  mask%      Bit isolation mask for given bit%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB BitGet (a$, bitIndex%, bit%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB BitGet (a$, bitIndex%, bit%) STATIC%@NL@%
        byte% = (bitIndex% - 1) \ 8 + 1%@NL@%
        SELECT CASE bitIndex% MOD 8%@NL@%
        CASE 1%@NL@%
            mask% = 128%@NL@%
        CASE 2%@NL@%
            mask% = 64%@NL@%
        CASE 3%@NL@%
            mask% = 32%@NL@%
        CASE 4%@NL@%
            mask% = 16%@NL@%
        CASE 5%@NL@%
            mask% = 8%@NL@%
        CASE 6%@NL@%
            mask% = 4%@NL@%
        CASE 7%@NL@%
            mask% = 2%@NL@%
        CASE 0%@NL@%
            mask% = 1%@NL@%
        END SELECT%@NL@%
        IF ASC(MID$(a$, byte%, 1)) AND mask% THEN%@NL@%
            bit% = 1%@NL@%
        ELSE%@NL@%
            bit% = 0%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          BitPut                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BITS.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' If bit% is non-zero, then the bit at bitIndex% into%@AE@%%@NL@%
%@AB@%  ' a$ is set to 1; otherwise, it's set to 0. The value%@AE@%%@NL@%
%@AB@%  ' of bitIndex% can range from 1 to 8 * LEN(a$).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  BitPut a$, bitIndex%, bit%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String containing the bits%@AE@%%@NL@%
%@AB@%  '                  bitIndex%  Index to the bit of concern%@AE@%%@NL@%
%@AB@%  '                  bit%       Value of bit (1 to set, 0 to clear)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       bytePtr%   Pointer to the byte position in the string%@AE@%%@NL@%
%@AB@%  '                  mask%      Bit isolation mask%@AE@%%@NL@%
%@AB@%  '                  byteNow%   Current numeric value of string byte%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB BitPut (b$, bitIndex%, bit%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB BitPut (a$, bitIndex%, bit%) STATIC%@NL@%
        bytePtr% = bitIndex% \ 8 + 1%@NL@%
        SELECT CASE bitIndex% MOD 8%@NL@%
        CASE 1%@NL@%
            mask% = 128%@NL@%
        CASE 2%@NL@%
            mask% = 64%@NL@%
        CASE 3%@NL@%
            mask% = 32%@NL@%
        CASE 4%@NL@%
            mask% = 16%@NL@%
        CASE 5%@NL@%
            mask% = 8%@NL@%
        CASE 6%@NL@%
            mask% = 4%@NL@%
        CASE 7%@NL@%
            mask% = 2%@NL@%
        CASE 0%@NL@%
            mask% = 1%@NL@%
            bytePtr% = bytePtr% - 1%@NL@%
        END SELECT%@NL@%
        byteNow% = ASC(MID$(a$, bytePtr%, 1))%@NL@%
        IF byteNow% AND mask% THEN%@NL@%
            IF bit% = 0 THEN%@NL@%
                MID$(a$, bytePtr%, 1) = CHR$(byteNow% XOR mask%)%@NL@%
            END IF%@NL@%
        ELSE%@NL@%
            IF bit% THEN%@NL@%
                MID$(a$, bytePtr%, 1) = CHR$(byteNow% XOR mask%)%@NL@%
            END IF%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CAL.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\CAL.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z               ' Default variable type is integer%@NL@%
%@NL@%
%@AB@%' Define a data type for the names of the months and the%@AE@%%@NL@%
%@AB@%' number of days in each:%@AE@%%@NL@%
TYPE MonthType%@NL@%
   Number AS INTEGER     ' Number of days in the month%@NL@%
   MName AS STRING * 9   ' Name of the month%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' Declare procedures used:%@AE@%%@NL@%
DECLARE FUNCTION IsLeapYear% (N%)%@NL@%
DECLARE FUNCTION GetInput% (Prompt$, Row%, LowVal%, HighVal%)%@NL@%
%@NL@%
DECLARE SUB PrintCalendar (Year%, Month%)%@NL@%
DECLARE SUB ComputeMonth (Year%, Month%, StartDay%, TotalDays%)%@NL@%
%@NL@%
DIM MonthData(1 TO 12) AS MonthType%@NL@%
%@NL@%
%@AB@%' Initialize month definitions from DATA statements below:%@AE@%%@NL@%
FOR I = 1 TO 12%@NL@%
   READ MonthData(I).MName, MonthData(I).Number%@NL@%
NEXT%@NL@%
%@NL@%
%@AB@%' Main loop, repeat for as many months as desired:%@AE@%%@NL@%
DO%@NL@%
%@NL@%
   CLS%@NL@%
%@NL@%
%@AB@%   ' Get year and month as input:%@AE@%%@NL@%
   Year = GetInput("Year (1899 to 2099): ", 1, 1899, 2099)%@NL@%
   Month = GetInput("Month (1 to 12): ", 2, 1, 12)%@NL@%
%@NL@%
%@AB@%   ' Print the calendar:%@AE@%%@NL@%
   PrintCalendar Year, Month%@NL@%
%@NL@%
%@AB@%   ' Another Date?%@AE@%%@NL@%
   LOCATE 13, 1         ' Locate in 13th row, 1st column%@NL@%
   PRINT "New Date? ";  ' Keep cursor on same line%@NL@%
   LOCATE , , 1, 0, 13  ' Turn cursor on and make it one%@NL@%
%@AB@%                        ' character high%@AE@%%@NL@%
   Resp$ = INPUT$(1)    ' Wait for a key press%@NL@%
   PRINT Resp$          ' Print the key pressed%@NL@%
%@NL@%
LOOP WHILE UCASE$(Resp$) = "Y"%@NL@%
END%@NL@%
%@NL@%
%@AB@%' Data for the months of a year:%@AE@%%@NL@%
DATA January, 31, February, 28, March, 31%@NL@%
DATA April, 30, May, 31, June, 30, July, 31, August, 31%@NL@%
DATA September, 30, October, 31, November, 30, December, 31%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ====================== COMPUTEMONTH ========================%@AE@%%@NL@%
%@AB@%'     Computes the first day and the total days in a month.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ComputeMonth (Year, Month, StartDay, TotalDays) STATIC%@NL@%
   SHARED MonthData() AS MonthType%@NL@%
   CONST LEAP = 366 MOD 7%@NL@%
   CONST NORMAL = 365 MOD 7%@NL@%
%@NL@%
%@AB@%   ' Calculate total number of days (NumDays) since 1/1/1899.%@AE@%%@NL@%
%@NL@%
%@AB@%   ' Start with whole years:%@AE@%%@NL@%
   NumDays = 0%@NL@%
   FOR I = 1899 TO Year - 1%@NL@%
      IF IsLeapYear(I) THEN         ' If year is leap, add%@NL@%
         NumDays = NumDays + LEAP   ' 366 MOD 7.%@NL@%
      ELSE                          ' If normal year, add%@NL@%
         NumDays = NumDays + NORMAL ' 365 MOD 7.%@NL@%
      END IF%@NL@%
   NEXT%@NL@%
%@NL@%
%@AB@%   ' Next, add in days from whole months:%@AE@%%@NL@%
   FOR I = 1 TO Month - 1%@NL@%
      NumDays = NumDays + MonthData(I).Number%@NL@%
   NEXT%@NL@%
%@NL@%
%@AB@%   ' Set the number of days in the requested month:%@AE@%%@NL@%
   TotalDays = MonthData(Month).Number%@NL@%
%@NL@%
%@AB@%   ' Compensate if requested year is a leap year:%@AE@%%@NL@%
   IF IsLeapYear(Year) THEN%@NL@%
%@NL@%
%@AB@%      ' If after February, add one to total days:%@AE@%%@NL@%
      IF Month > 2 THEN%@NL@%
         NumDays = NumDays + 1%@NL@%
%@NL@%
%@AB@%      ' If February, add one to the month's days:%@AE@%%@NL@%
      ELSEIF Month = 2 THEN%@NL@%
         TotalDays = TotalDays + 1%@NL@%
%@NL@%
      END IF%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' 1/1/1899 was a Sunday, so calculating "NumDays MOD 7"%@AE@%%@NL@%
%@AB@%   ' gives the day of week (Sunday = 0, Monday = 1, Tuesday = 2,%@AE@%%@NL@%
%@AB@%   ' and so on) for the first day of the input month:%@AE@%%@NL@%
   StartDay = NumDays MOD 7%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================== GETINPUT ==========================%@AE@%%@NL@%
%@AB@%'       Prompts for input, then tests for a valid range.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION GetInput (Prompt$, Row, LowVal, HighVal) STATIC%@NL@%
%@NL@%
%@AB@%   ' Locate prompt at specified row, turn cursor on and%@AE@%%@NL@%
%@AB@%   ' make it one character high:%@AE@%%@NL@%
   LOCATE Row, 1, 1, 0, 13%@NL@%
   PRINT Prompt$;%@NL@%
%@NL@%
%@AB@%   ' Save column position:%@AE@%%@NL@%
   Column = POS(0)%@NL@%
%@NL@%
%@AB@%   ' Input value until it's within range:%@AE@%%@NL@%
   DO%@NL@%
      LOCATE Row, Column   ' Locate cursor at end of prompt%@NL@%
      PRINT SPACE$(10)     ' Erase anything already there%@NL@%
      LOCATE Row, Column   ' Relocate cursor at end of prompt%@NL@%
      INPUT "", Value      ' Input value with no prompt%@NL@%
   LOOP WHILE (Value < LowVal OR Value > HighVal)%@NL@%
%@NL@%
%@AB@%   ' Return valid input as value of function:%@AE@%%@NL@%
   GetInput = Value%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ====================== ISLEAPYEAR ==========================%@AE@%%@NL@%
%@AB@%'         Determines if a year is a leap year or not.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION IsLeapYear (N) STATIC%@NL@%
%@NL@%
%@AB@%   ' If the year is evenly divisible by 4 and not divisible%@AE@%%@NL@%
%@AB@%   ' by 100, or if the year is evenly divisible by 400, then%@AE@%%@NL@%
%@AB@%   ' it's a leap year:%@AE@%%@NL@%
   IsLeapYear = (N MOD 4 = 0 AND N MOD 100 <> 0) OR (N MOD 400 = 0)%@NL@%
END FUNCTION%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ===================== PRINTCALENDAR ========================%@AE@%%@NL@%
%@AB@%'     Prints a formatted calendar given the year and month.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB PrintCalendar (Year, Month) STATIC%@NL@%
SHARED MonthData() AS MonthType%@NL@%
%@NL@%
%@AB@%   ' Compute starting day (Su M Tu ...) and total days%@AE@%%@NL@%
%@AB@%   ' for the month:%@AE@%%@NL@%
   ComputeMonth Year, Month, StartDay, TotalDays%@NL@%
   CLS%@NL@%
   Header$ = RTRIM$(MonthData(Month).MName) + "," + STR$(Year)%@NL@%
%@NL@%
%@AB@%   ' Calculates location for centering month and year:%@AE@%%@NL@%
   LeftMargin = (35 - LEN(Header$)) \ 2%@NL@%
%@NL@%
%@AB@%   ' Print header:%@AE@%%@NL@%
   PRINT TAB(LeftMargin); Header$%@NL@%
   PRINT%@NL@%
   PRINT "Su    M   Tu    W   Th    F   Sa"%@NL@%
   PRINT%@NL@%
%@NL@%
%@AB@%   ' Recalculate and print tab to the first day%@AE@%%@NL@%
%@AB@%   ' of the month (Su M Tu ...):%@AE@%%@NL@%
   LeftMargin = 5 * StartDay + 1%@NL@%
   PRINT TAB(LeftMargin);%@NL@%
%@NL@%
%@AB@%   ' Print out the days of the month:%@AE@%%@NL@%
   FOR I = 1 TO TotalDays%@NL@%
      PRINT USING "##   "; I;%@NL@%
%@NL@%
%@AB@%      ' Advance to the next line when the cursor%@AE@%%@NL@%
%@AB@%      ' is past column 32:%@AE@%%@NL@%
      IF POS(0) > 32 THEN PRINT%@NL@%
   NEXT%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CALENDAR.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\CALENDAR.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CALENDAR                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE: No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       month%     Month for demonstration%@AE@%%@NL@%
%@AB@%  '                  day%       Day for demonstration%@AE@%%@NL@%
%@AB@%  '                  year%      Year for demonstration%@AE@%%@NL@%
%@AB@%  '                  dat$       Date for demonstration%@AE@%%@NL@%
%@AB@%  '                  j&         Julian day number%@AE@%%@NL@%
%@AB@%  '                  tim$       System time right now%@AE@%%@NL@%
%@AB@%  '                  hour%      Hour right now%@AE@%%@NL@%
%@AB@%  '                  minute%    Minute right now%@AE@%%@NL@%
%@AB@%  '                  second%    Second right now%@AE@%%@NL@%
%@AB@%  '                  sec&       Seconds since last second of 1979%@AE@%%@NL@%
%@NL@%
%@NL@%
    CONST FALSE = 0%@NL@%
    CONST TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION CheckDate% (dat$)%@NL@%
    DECLARE FUNCTION Date2Day% (dat$)%@NL@%
    DECLARE FUNCTION Date2Julian& (dat$)%@NL@%
    DECLARE FUNCTION Date2Month% (dat$)%@NL@%
    DECLARE FUNCTION Date2Year% (dat$)%@NL@%
    DECLARE FUNCTION DayOfTheCentury& (dat$)%@NL@%
    DECLARE FUNCTION DayOfTheWeek$ (dat$)%@NL@%
    DECLARE FUNCTION DayOfTheYear% (dat$)%@NL@%
    DECLARE FUNCTION DaysBetweenDates& (dat1$, dat2$)%@NL@%
    DECLARE FUNCTION HMS2Time$ (hour%, minute%, second%)%@NL@%
    DECLARE FUNCTION Julian2Date$ (julian&)%@NL@%
    DECLARE FUNCTION MDY2Date$ (month%, day%, year%)%@NL@%
    DECLARE FUNCTION MonthName$ (dat$)%@NL@%
    DECLARE FUNCTION Second2Date$ (second&)%@NL@%
    DECLARE FUNCTION Second2Time$ (second&)%@NL@%
    DECLARE FUNCTION Time2Hour% (tim$)%@NL@%
    DECLARE FUNCTION Time2Minute% (tim$)%@NL@%
    DECLARE FUNCTION Time2Second% (tim$)%@NL@%
    DECLARE FUNCTION TimeDate2Second& (tim$, dat$)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB OneMonthCalendar (dat$, row%, col%)%@NL@%
%@NL@%
%@AB@%  ' Let's choose the fourth of July for the demonstration%@AE@%%@NL@%
    CLS%@NL@%
    PRINT "All about the fourth of July for this year..."%@NL@%
    month% = 7%@NL@%
    day% = 4%@NL@%
    year% = Date2Year%(DATE$)%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the conversion to dat$%@AE@%%@NL@%
    PRINT%@NL@%
    dat$ = MDY2Date$(month%, day%, year%)%@NL@%
    PRINT "QuickBASIC string format for this date is "; dat$%@NL@%
%@NL@%
%@AB@%  ' Check the validity of this date%@AE@%%@NL@%
    IF CheckDate%(dat$) = FALSE THEN%@NL@%
        PRINT "The date you entered is faulty... " + dat$%@NL@%
        SYSTEM%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Day of the week and name of the month%@AE@%%@NL@%
    PRINT "The day of the week is "; DayOfTheWeek$(dat$); "."%@NL@%
%@NL@%
%@AB@%  ' Astronomical Julian day number%@AE@%%@NL@%
    j& = Date2Julian&(dat$)%@NL@%
    PRINT "The Julian day number is"; j&%@NL@%
%@NL@%
%@AB@%  ' Conversion of Julian number to date%@AE@%%@NL@%
    PRINT "Date for the given Julian number is "; Julian2Date$(j&); "."%@NL@%
%@NL@%
%@AB@%  ' Convert the date string to numbers%@AE@%%@NL@%
    PRINT "The month, day, and year numbers are ";%@NL@%
    PRINT Date2Month%(dat$); ","; Date2Day%(dat$); ","; Date2Year%(dat$)%@NL@%
%@NL@%
%@AB@%  ' The month name%@AE@%%@NL@%
    PRINT "The month name is "; MonthName$(dat$)%@NL@%
%@NL@%
%@AB@%  ' Day of the year%@AE@%%@NL@%
    PRINT "The day of the year is"; DayOfTheYear%(dat$)%@NL@%
%@NL@%
%@AB@%  ' Day of the century%@AE@%%@NL@%
    PRINT "The day of the century is"; DayOfTheCentury&(dat$)%@NL@%
%@NL@%
%@AB@%  ' Days from right now%@AE@%%@NL@%
    IF Date2Julian&(dat$) < Date2Julian&(DATE$) THEN%@NL@%
        PRINT "That was"; DaysBetweenDates&(dat$, DATE$); "days ago."%@NL@%
    ELSEIF Date2Julian&(dat$) > Date2Julian&(DATE$) THEN%@NL@%
        PRINT "That is"; DaysBetweenDates&(dat$, DATE$); "days from now."%@NL@%
    ELSE%@NL@%
        PRINT "The date you entered is today's date."%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Print a one-month calendar%@AE@%%@NL@%
    OneMonthCalendar dat$, 14, 25%@NL@%
%@NL@%
%@AB@%  ' Wait for user%@AE@%%@NL@%
    LOCATE 23, 1%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
    CLS%@NL@%
%@NL@%
%@AB@%  ' Demonstrate extracting hour, minute, and second from tim$%@AE@%%@NL@%
    dat$ = DATE$%@NL@%
    tim$ = TIME$%@NL@%
    hour% = Time2Hour%(tim$)%@NL@%
    minute% = Time2Minute%(tim$)%@NL@%
    second% = Time2Second%(tim$)%@NL@%
    PRINT "The date today... "; dat$%@NL@%
    PRINT "The time now  ... "; tim$%@NL@%
    PRINT "The hour, minute, and second numbers are ";%@NL@%
    PRINT hour%; ","; minute%; ","; second%%@NL@%
%@NL@%
%@AB@%  ' Now put it all back together again%@AE@%%@NL@%
    PRINT "Time string created from hour, minute, and second is ";%@NL@%
    PRINT HMS2Time$(hour%, minute%, second%)%@NL@%
%@NL@%
%@AB@%  ' Seconds since end of 1979%@AE@%%@NL@%
    dat$ = DATE$%@NL@%
    PRINT "The number of seconds since the last second of 1979 is";%@NL@%
    sec& = TimeDate2Second&(tim$, dat$)%@NL@%
    PRINT sec&%@NL@%
    PRINT "From this number we can extract the date and time..."%@NL@%
    PRINT Second2Date$(sec&); " and "; Second2Time$(sec&); "."%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CheckDate%                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns TRUE if the given date represents a real%@AE@%%@NL@%
%@AB@%  ' date or FALSE if the date is in error.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  test% = CheckDate%(dat$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dat$       Date to be checked%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       julian&    Julian day number for the date%@AE@%%@NL@%
%@AB@%  '                  test$      Date string for given Julian day number%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  CONST FALSE = 0%@AE@%%@NL@%
%@AB@%  '                  CONST TRUE = NOT FALSE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  DECLARE FUNCTION CheckDate% (dat$)%@AE@%%@NL@%
%@AB@%  '                  DECLARE FUNCTION Date2Julian& (dat$)%@AE@%%@NL@%
%@AB@%  '                  DECLARE FUNCTION Julian2Date$ (julian&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION CheckDate% (dat$) STATIC%@NL@%
        julian& = Date2Julian&(dat$)%@NL@%
        test$ = Julian2Date$(julian&)%@NL@%
        IF dat$ = test$ THEN%@NL@%
            CheckDate% = TRUE%@NL@%
        ELSE%@NL@%
            CheckDate% = FALSE%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Date2Day%                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the day number given a date in the%@AE@%%@NL@%
%@AB@%  ' QuickBASIC string format MM-DD-YYYY.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  day% = Date2Day%(dat$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dat$       Date of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Date2Day% (dat$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Date2Day% (dat$) STATIC%@NL@%
        Date2Day% = VAL(MID$(dat$, 4, 2))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Date2Julian&               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the astronomical Julian day number given a%@AE@%%@NL@%
%@AB@%  ' date in the QuickBASIC string format MM-DD-YYYY.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  j& = Date2Julian&(dat$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dat$       Date of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       month%     Month number for given date%@AE@%%@NL@%
%@AB@%  '                  day%       Day number for given date%@AE@%%@NL@%
%@AB@%  '                  year%      Year number for given date%@AE@%%@NL@%
%@AB@%  '                  ta&        First term of the Julian day number calculation%@AE@%%@NL@%
%@AB@%  '                  tb&        Second term of the Julian day number calculation%@AE@%%@NL@%
%@AB@%  '                  tc&        Third term of the Julian day number calculation%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Date2Day% (dat$)%@AE@%%@NL@%
%@AB@%  '                  DECLARE FUNCTION Date2Julian& (dat$)%@AE@%%@NL@%
%@AB@%  '                  DECLARE FUNCTION Date2Month% (dat$)%@AE@%%@NL@%
%@AB@%  '                  DECLARE FUNCTION Date2Year% (dat$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Date2Julian& (dat$) STATIC%@NL@%
        month% = Date2Month%(dat$)%@NL@%
        day% = Date2Day%(dat$)%@NL@%
        year% = Date2Year%(dat$)%@NL@%
        IF year% < 1583 THEN%@NL@%
            PRINT "Date2Julian: Year is less than 1583"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
        IF month% > 2 THEN%@NL@%
            month% = month% - 3%@NL@%
        ELSE%@NL@%
            month% = month% + 9%@NL@%
            year% = year% - 1%@NL@%
        END IF%@NL@%
        ta& = 146097 * (year% \ 100) \ 4%@NL@%
        tb& = 1461& * (year% MOD 100) \ 4%@NL@%
        tc& = (153 * month% + 2) \ 5 + day% + 1721119%@NL@%
        Date2Julian& = ta& + tb& + tc&%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Date2Month%                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the month number given a date in the%@AE@%%@NL@%
%@AB@%  ' QuickBASIC string format MM-DD-YYYY.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  month% = Date2Month%(dat$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dat$       Date of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Date2Month% (dat$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Date2Month% (dat$) STATIC%@NL@%
        Date2Month% = VAL(MID$(dat$, 1, 2))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Date2Year%                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the year number given a date in the%@AE@%%@NL@%
%@AB@%  ' QuickBASIC string format MM-DD-YYYY.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  year% = Date2Year%(dat$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dat$       Date of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Date2Year% (dat$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Date2Year% (dat$) STATIC%@NL@%
        Date2Year% = VAL(MID$(dat$, 7))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DayOfTheCentury%           **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the number of the day of the century.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  cDay& = DayOfTheCentury&(dat$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dat$       Date of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       year%      Year for given date%@AE@%%@NL@%
%@AB@%  '                  dat1$      Date for last day of previous century%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION DayOfTheCentury& (dat$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION DayOfTheCentury& (dat$)%@NL@%
        year% = Date2Year%(dat$)%@NL@%
        dat1$ = MDY2Date$(12, 31, year% - (year% MOD 100) - 1)%@NL@%
        DayOfTheCentury& = DaysBetweenDates&(dat1$, dat$)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DayOfTheWeek$              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a string stating the day of the week.%@AE@%%@NL@%
%@AB@%  ' Input is a date expressed in the QuickBASIC string%@AE@%%@NL@%
%@AB@%  ' format MM-DD-YYYY.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  PRINT "The day of the week is "; DayOfTheWeek$(dat$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dat$       Date of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION DayOfTheWeek$ (dat$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION DayOfTheWeek$ (dat$) STATIC%@NL@%
        SELECT CASE Date2Julian&(dat$) MOD 7%@NL@%
        CASE 0%@NL@%
            DayOfTheWeek$ = "Monday"%@NL@%
        CASE 1%@NL@%
            DayOfTheWeek$ = "Tuesday"%@NL@%
        CASE 2%@NL@%
            DayOfTheWeek$ = "Wednesday"%@NL@%
        CASE 3%@NL@%
            DayOfTheWeek$ = "Thursday"%@NL@%
        CASE 4%@NL@%
            DayOfTheWeek$ = "Friday"%@NL@%
        CASE 5%@NL@%
            DayOfTheWeek$ = "Saturday"%@NL@%
        CASE 6%@NL@%
            DayOfTheWeek$ = "Sunday"%@NL@%
        END SELECT%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DayOfTheYear%              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the number of the day of the year (1-366).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  PRINT "The day of the year is"; DayOfTheYear%(dat$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dat$       Date of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       dat1$      Date of last day of previous year%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION DayOfTheYear% (dat$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION DayOfTheYear% (dat$) STATIC%@NL@%
        dat1$ = MDY2Date$(12, 31, Date2Year%(dat$) - 1)%@NL@%
        DayOfTheYear% = DaysBetweenDates&(dat1$, dat$)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DaysBetweenDates&          **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the number of days between any two dates.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  days& = DaysBetweenDates&(dat1$, dat2$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dat1$      First date%@AE@%%@NL@%
%@AB@%  '                  dat2$      Second date%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION DaysBetweenDates& (dat1$, dat2$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION DaysBetweenDates& (dat1$, dat2$) STATIC%@NL@%
        DaysBetweenDates& = ABS(Date2Julian&(dat1$) - Date2Julian&(dat2$))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          HMS2Time$                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the time in the QuickBASIC string format%@AE@%%@NL@%
%@AB@%  ' HH:MM:SS given hour%, minute%, and second%.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  PRINT HMS2Time$(hour%, minute%, second%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      hour%      Hour number%@AE@%%@NL@%
%@AB@%  '                  minute%    Minutes number%@AE@%%@NL@%
%@AB@%  '                  second%    Seconds number%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       t$         Workspace for building the time string%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION HMS2Time$ (hour%, minute%, second%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION HMS2Time$ (hour%, minute%, second%) STATIC%@NL@%
        t$ = RIGHT$("0" + MID$(STR$(hour%), 2), 2) + ":"%@NL@%
        t$ = t$ + RIGHT$("0" + MID$(STR$(minute%), 2), 2) + ":"%@NL@%
        HMS2Time$ = t$ + RIGHT$("0" + MID$(STR$(second%), 2), 2)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Julian2Date$               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a date in the QuickBASIC string format%@AE@%%@NL@%
%@AB@%  ' MM-DD-YYYY as calculated from a Julian day number.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:%@AE@%%@NL@%
%@AB@%  '        PRINT "Date for the given Julian number is ";Julian2Date$(j&)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      j&         Julian day number%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       x&         Temporary calculation variable%@AE@%%@NL@%
%@AB@%  '                  y&         Temporary calculation variable%@AE@%%@NL@%
%@AB@%  '                  d&         Day number in long integer form%@AE@%%@NL@%
%@AB@%  '                  m&         Month number before adjustment%@AE@%%@NL@%
%@AB@%  '                  month%     Month number%@AE@%%@NL@%
%@AB@%  '                  year%      Year number%@AE@%%@NL@%
%@AB@%  '                  day%       Day number%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Julian2Date$ (julian&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Julian2Date$ (julian&) STATIC%@NL@%
%@NL@%
        x& = 4 * julian& - 6884477%@NL@%
        y& = (x& \ 146097) * 100%@NL@%
        d& = (x& MOD 146097) \ 4%@NL@%
%@NL@%
        x& = 4 * d& + 3%@NL@%
        y& = (x& \ 1461) + y&%@NL@%
        d& = (x& MOD 1461) \ 4 + 1%@NL@%
%@NL@%
        x& = 5 * d& - 3%@NL@%
        m& = x& \ 153 + 1%@NL@%
        d& = (x& MOD 153) \ 5 + 1%@NL@%
%@NL@%
        IF m& < 11 THEN%@NL@%
            month% = m& + 2%@NL@%
        ELSE%@NL@%
            month% = m& - 10%@NL@%
        END IF%@NL@%
        day% = d&%@NL@%
        year% = y& + m& \ 11%@NL@%
%@NL@%
        dat$ = MDY2Date$(month%, day%, year%)%@NL@%
        Julian2Date$ = dat$%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MDY2Date$                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Converts month%, day%, and year% to a date string%@AE@%%@NL@%
%@AB@%  ' in the QuickBASIC string format MM-DD-YYYY.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  dat$ = MDY2Date$(month%, day%, year%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      month%     Month for the date%@AE@%%@NL@%
%@AB@%  '                  day%       Day of the month%@AE@%%@NL@%
%@AB@%  '                  year%      Year number%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       y$         Temporary year string%@AE@%%@NL@%
%@AB@%  '                  m$         Temporary month string%@AE@%%@NL@%
%@AB@%  '                  d$         Temporary day string%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION MDY2Date$ (month%, day%, year%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION MDY2Date$ (month%, day%, year%) STATIC%@NL@%
        y$ = RIGHT$("000" + MID$(STR$(year%), 2), 4)%@NL@%
        m$ = RIGHT$("0" + MID$(STR$(month%), 2), 2)%@NL@%
        d$ = RIGHT$("0" + MID$(STR$(day%), 2), 2)%@NL@%
        MDY2Date$ = m$ + "-" + d$ + "-" + y$%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MonthName$                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a string stating the month as indicated%@AE@%%@NL@%
%@AB@%  ' in dat$ (QuickBASIC string format MM-DD-YYYY).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  PRINT MonthName$(dat$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dat$       Date of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION MonthName$ (dat$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION MonthName$ (dat$) STATIC%@NL@%
%@NL@%
        IF LEN(dat$) <> 10 THEN%@NL@%
            dat$ = "MM-DD-YYYY"%@NL@%
        END IF%@NL@%
%@NL@%
        SELECT CASE LEFT$(dat$, 2)%@NL@%
        CASE "01"%@NL@%
            MonthName$ = "January"%@NL@%
        CASE "02"%@NL@%
            MonthName$ = "February"%@NL@%
        CASE "03"%@NL@%
            MonthName$ = "March"%@NL@%
        CASE "04"%@NL@%
            MonthName$ = "April"%@NL@%
        CASE "05"%@NL@%
            MonthName$ = "May"%@NL@%
        CASE "06"%@NL@%
            MonthName$ = "June"%@NL@%
        CASE "07"%@NL@%
            MonthName$ = "July"%@NL@%
        CASE "08"%@NL@%
            MonthName$ = "August"%@NL@%
        CASE "09"%@NL@%
            MonthName$ = "September"%@NL@%
        CASE "10"%@NL@%
            MonthName$ = "October"%@NL@%
        CASE "11"%@NL@%
            MonthName$ = "November"%@NL@%
        CASE "12"%@NL@%
            MonthName$ = "December"%@NL@%
        CASE ELSE%@NL@%
            MonthName$ = "?MonthName?"%@NL@%
        END SELECT%@NL@%
%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          OneMonthCalendar           **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Prints a small, one-month calendar at the row%%@AE@%%@NL@%
%@AB@%  ' and col% indicated.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  OneMonthCalendar dat$, row%, col%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dat$       Date of concern%@AE@%%@NL@%
%@AB@%  '                  row%       Screen row for upper left corner of calendar%@AE@%%@NL@%
%@AB@%  '                  col%       Screen column for upper left corner of calendar%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       mname$     Name of given month%@AE@%%@NL@%
%@AB@%  '                  month%     Month number%@AE@%%@NL@%
%@AB@%  '                  day%       Day number%@AE@%%@NL@%
%@AB@%  '                  year%      Year number%@AE@%%@NL@%
%@AB@%  '                  dat1$      Date for first of the given month%@AE@%%@NL@%
%@AB@%  '                  j&         Julian day number for each day of the month%@AE@%%@NL@%
%@AB@%  '                  heading$   Title line for calendar%@AE@%%@NL@%
%@AB@%  '                  wa%        Day of the week for each day of the month%@AE@%%@NL@%
%@AB@%  '                  rowloc%    Row for printing each day number%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB OneMonthCalendar (dat$, row%, col%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB OneMonthCalendar (dat$, row%, col%) STATIC%@NL@%
        mname$ = MonthName$(dat$)%@NL@%
        LOCATE row%, col% + 12 - LEN(mname$) \ 2%@NL@%
        PRINT mname$; ","; Date2Year%(dat$)%@NL@%
        month% = Date2Month%(dat$)%@NL@%
        day% = 1%@NL@%
        year% = Date2Year%(dat$)%@NL@%
        dat1$ = MDY2Date$(month%, day%, year%)%@NL@%
        j& = Date2Julian&(dat1$)%@NL@%
        heading$ = " Sun Mon Tue Wed Thu Fri Sat"%@NL@%
        wa% = INSTR(heading$, LEFT$(DayOfTheWeek$(dat1$), 3)) \ 4%@NL@%
        LOCATE row% + 1, col%%@NL@%
        PRINT heading$%@NL@%
        rowloc% = row% + 2%@NL@%
        LOCATE rowloc%, col% + 4 * wa%%@NL@%
        DO%@NL@%
            PRINT USING "####"; day%;%@NL@%
            IF wa% = 6 THEN%@NL@%
                rowloc% = rowloc% + 1%@NL@%
                LOCATE rowloc%, col%%@NL@%
            END IF%@NL@%
            wa% = (wa% + 1) MOD 7%@NL@%
            j& = j& + 1%@NL@%
            day% = Date2Day%(Julian2Date$(j&))%@NL@%
        LOOP UNTIL day% = 1%@NL@%
        PRINT%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Second2Date$               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the date in the QuickBASIC string format%@AE@%%@NL@%
%@AB@%  ' MM-DD-YYYY given a number of seconds since the%@AE@%%@NL@%
%@AB@%  ' last second of 1979.  Use Second2Time$ to find%@AE@%%@NL@%
%@AB@%  ' the time of day at the indicated second.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  dat$ = Second2Date$(second&)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      second&    Number of seconds since the last second of 1979%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       days&      Julian day number of the date%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Second2Date$ (second&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Second2Date$ (second&) STATIC%@NL@%
        days& = second& \ 86400 + 2444240%@NL@%
        Second2Date$ = Julian2Date$(days&)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Second2Time$               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the time in the QuickBASIC string format%@AE@%%@NL@%
%@AB@%  ' HH:MM:SS given the number of seconds since the%@AE@%%@NL@%
%@AB@%  ' last second of 1979.  Use Second2Date$ to find%@AE@%%@NL@%
%@AB@%  ' the date at the indicated second.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  tim$ = Second2Time$(second&)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      second&    Number of seconds since the last second of 1979%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       time&      Number of seconds in current day%@AE@%%@NL@%
%@AB@%  '                  second%    Current second of the minute%@AE@%%@NL@%
%@AB@%  '                  minute%    Current minute of the hour%@AE@%%@NL@%
%@AB@%  '                  hour%      Current hour of the day%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Second2Time$ (second&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Second2Time$ (second&) STATIC%@NL@%
        IF second& > 0 THEN%@NL@%
            time& = second& MOD 86400%@NL@%
            second% = time& MOD 60%@NL@%
            time& = time& \ 60%@NL@%
            minute% = time& MOD 60%@NL@%
            hour% = time& \ 60%@NL@%
            Second2Time$ = HMS2Time$(hour%, minute%, second%)%@NL@%
        ELSE%@NL@%
            Second2Time$ = "HH:MM:SS"%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Time2Hour%                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the hour number as indicated in a time%@AE@%%@NL@%
%@AB@%  ' string in the format HH:MM:SS.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  hour% = Time2Hour%(tim$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      tim$       Time of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Time2Hour% (tim$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Time2Hour% (tim$) STATIC%@NL@%
        Time2Hour% = VAL(LEFT$(tim$, 2))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Time2Minute%               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the minute number as indicated in a time%@AE@%%@NL@%
%@AB@%  ' string in the format HH:MM:SS.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  minute% = Time2Minute%(tim$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      tim$       Time of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Time2Minute% (tim$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Time2Minute% (tim$) STATIC%@NL@%
        Time2Minute% = VAL(MID$(tim$, 4, 2))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Time2Second%               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the second number as indicated in a time%@AE@%%@NL@%
%@AB@%  ' string in the format HH:MM:SS.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  second% = Time2Second%(tim$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      tim$       Time of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Time2Second% (tim$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Time2Second% (tim$) STATIC%@NL@%
        Time2Second% = VAL(MID$(tim$, 7))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          TimeDate2Second&           **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the number of seconds since the last%@AE@%%@NL@%
%@AB@%  ' second of 1979.  If the date is not in the years%@AE@%%@NL@%
%@AB@%  ' 1980 to 2047, an error message is output.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  sec& = TimeDate2Second&(tim$, dat$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      tim$       Time of concern%@AE@%%@NL@%
%@AB@%  '                  dat$       Date of concern%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       days&      Days since 12-31-1979%@AE@%%@NL@%
%@AB@%  '                  hour%      Hour of the day%@AE@%%@NL@%
%@AB@%  '                  minute%    Minute of the hour%@AE@%%@NL@%
%@AB@%  '                  second%    Second of the minute%@AE@%%@NL@%
%@AB@%  '                  secs&      Working number of total seconds%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION TimeDate2Second& (tim$, dat$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION TimeDate2Second& (tim$, dat$) STATIC%@NL@%
        days& = Date2Julian&(dat$) - 2444240%@NL@%
        hour% = VAL(LEFT$(tim$, 2))%@NL@%
        minute% = VAL(MID$(tim$, 4, 2))%@NL@%
        second% = VAL(RIGHT$(tim$, 2))%@NL@%
        secs& = CLNG(hour%) * 3600 + minute% * 60 + second%%@NL@%
        IF days& >= 0 AND days& < 24857 THEN%@NL@%
            TimeDate2Second& = days& * 86400 + secs&%@NL@%
        ELSE%@NL@%
            PRINT "TimeDate2Second: Not in range 1980 to 2047"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CARTESIA.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\CARTESIA.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CARTESIA                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CARTESIA.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Demonstrates a set of functions and subprograms%@AE@%%@NL@%
%@AB@%  ' dealing with Cartesian coordinates.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       x!     X value of Cartesian coordinate%@AE@%%@NL@%
%@AB@%  '                  y!     Y value of Cartesian coordinate%@AE@%%@NL@%
%@AB@%  '                  r!     Polar notation distance from origin%@AE@%%@NL@%
%@AB@%  '                  theta! Polar notation angle from X axis%@AE@%%@NL@%
%@NL@%
    DECLARE FUNCTION Angle! (x!, y!)%@NL@%
    DECLARE FUNCTION Magnitude! (x!, y!)%@NL@%
%@NL@%
    DECLARE SUB Pol2Rec (r!, theta!, x!, y!)%@NL@%
    DECLARE SUB Rec2Pol (x!, y!, r!, theta!)%@NL@%
%@NL@%
    CLS%@NL@%
    INPUT "Enter X  ", x!%@NL@%
    INPUT "Enter Y  ", y!%@NL@%
    PRINT%@NL@%
    PRINT "Magnitude!(x!, y!)", Magnitude!(x!, y!)%@NL@%
    PRINT "Angle!(x!, y!)", Angle!(x!, y!)%@NL@%
    PRINT%@NL@%
    Rec2Pol x!, y!, r!, theta!%@NL@%
    PRINT "Rec2Pol", , r!; theta!%@NL@%
    Pol2Rec r!, theta!, x!, y!%@NL@%
    PRINT "Pol2Rec", , x!; y!%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Angle!                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CARTESIA.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the angle (in radians) between the X axis%@AE@%%@NL@%
%@AB@%  ' and the line from the origin to the point x!,y!%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  a! = Angle!(x!, y!)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x!         X part of the Cartesian coordinate%@AE@%%@NL@%
%@AB@%  '                  y!         Y part of the Cartesian coordinate%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Angle! (x!, y!)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Angle! (x!, y!) STATIC%@NL@%
%@NL@%
        CONST PI = 3.141593%@NL@%
        CONST HALFPI = PI / 2%@NL@%
%@NL@%
        IF x! = 0! THEN%@NL@%
            IF y! > 0! THEN%@NL@%
                Angle! = HALFPI%@NL@%
            ELSEIF y! < 0! THEN%@NL@%
                Angle! = -HALFPI%@NL@%
            ELSE%@NL@%
                Angle! = 0!%@NL@%
            END IF%@NL@%
        ELSEIF y! = 0! THEN%@NL@%
            IF x! < 0! THEN%@NL@%
                Angle! = PI%@NL@%
            ELSE%@NL@%
                Angle! = 0!%@NL@%
            END IF%@NL@%
        ELSE%@NL@%
            IF x! < 0! THEN%@NL@%
                IF y! > 0! THEN%@NL@%
                    Angle! = ATN(y! / x!) + PI%@NL@%
                ELSE%@NL@%
                    Angle! = ATN(y! / x!) - PI%@NL@%
                END IF%@NL@%
            ELSE%@NL@%
                Angle! = ATN(y! / x!)%@NL@%
            END IF%@NL@%
        END IF%@NL@%
%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Magnitude!                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CARTESIA.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the distance from the origin to the%@AE@%%@NL@%
%@AB@%  ' point x!,y!%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  r! =  Magnitude!(x!, y!)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x!         X part of the Cartesian coordinate%@AE@%%@NL@%
%@AB@%  '                  y!         Y part of the Cartesian coordinate%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Magnitude! (x!, y!)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Magnitude! (x!, y!) STATIC%@NL@%
        Magnitude! = SQR(x! * x! + y! * y!)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Pol2rec                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CARTESIA.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Converts polar coordinates to Cartesian notation.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Pol2Rec r!, theta!, x!, y!%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      r!         Distance of point from the origin%@AE@%%@NL@%
%@AB@%  '                  theta!     Angle of point from the X axis%@AE@%%@NL@%
%@AB@%  '                  x!         X coordinate of the point%@AE@%%@NL@%
%@AB@%  '                  y!         Y coordinate of the point%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Pol2Rec (r!, theta!, x!, y!)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Pol2Rec (r!, theta!, x!, y!) STATIC%@NL@%
        x! = r! * COS(theta!)%@NL@%
        y! = r! * SIN(theta!)%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Rec2pol                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CARTESIA.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Converts Cartesian coordinates to polar notation.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Rec2Pol x!, y!, r!, theta!%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x!         X coordinate of the point%@AE@%%@NL@%
%@AB@%  '                  y!         Y coordinate of the point%@AE@%%@NL@%
%@AB@%  '                  r!         Distance of point from the origin%@AE@%%@NL@%
%@AB@%  '                  theta!     Angle of point from the X axis%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Angle! (x!, y!)%@AE@%%@NL@%
%@AB@%  '                  DECLARE FUNCTION Magnitude! (x!, y!)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB Rec2Pol (x!, y!, r!, theta!)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Rec2Pol (x!, y!, r!, theta!) STATIC%@NL@%
        r! = Magnitude!(x!, y!)%@NL@%
        theta! = Angle!(x!, y!)%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CASEMAP.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\CASEMAP.ASM%@AE@%%@NL@%
%@NL@%
 %@AB@%; **********************************************%@AE@%%@NL@%
 %@AB@%; **  CASEMAP.ASM                   MASM 5.0  **%@AE@%%@NL@%
 %@AB@%; **                                          **%@AE@%%@NL@%
 %@AB@%; **  Assembly subprogram for translating     **%@AE@%%@NL@%
 %@AB@%; **  some characters according to the        **%@AE@%%@NL@%
 %@AB@%; **  currently loaded MS-DOS country-        **%@AE@%%@NL@%
 %@AB@%; **  dependent information.                  **%@AE@%%@NL@%
 %@AB@%; **                                          **%@AE@%%@NL@%
 %@AB@%; **  Use:  CALL CASEMAP (CHAR%, SEG%, OFS%)  **%@AE@%%@NL@%
 %@AB@%; **  Note: CHAR% is passed by reference      **%@AE@%%@NL@%
 %@AB@%; **        SEG% and OFS% are passed by value **%@AE@%%@NL@%
 %@AB@%; **********************************************%@AE@%%@NL@%
 %@AB@%;%@AE@%%@NL@%
 %@AB@%; EXAMPLE OF USE:  CALL CaseMap (char%, seg%, ofs%)%@AE@%%@NL@%
 %@AB@%; PARAMETERS:      char%      Character byte to be translated%@AE@%%@NL@%
 %@AB@%;                  seg%       Segment of address of MS-DOS translate routine%@AE@%%@NL@%
 %@AB@%;                  ofs%       Offset of address of MS-DOS translate routine%@AE@%%@NL@%
 %@AB@%; VARIABLES:       (none)%@AE@%%@NL@%
 %@AB@%; MODULE LEVEL%@AE@%%@NL@%
 %@AB@%;   DECLARATIONS:  DECLARE SUB GetCountry (country AS CountryType)%@AE@%%@NL@%
 %@AB@%;                  DECLARE SUB CaseMap (character%, BYVAL Segment%,%@AE@%%@NL@%
 %@AB@%;                                       BYVAL Offset%)%@AE@%%@NL@%
 %@AB@%;              DECLARE FUNCTION TranslateCountry$ (a$, country AS CountryType)%@AE@%%@NL@%
%@NL@%
%@NL@%
.MODEL  MEDIUM%@NL@%
.CODE%@NL@%
        public casemap%@NL@%
%@NL@%
casemap proc%@NL@%
%@NL@%
%@AB@%; Standard entry%@AE@%%@NL@%
        push bp%@NL@%
        mov bp, sp%@NL@%
%@NL@%
%@AB@%; Get CHAR% into AX register%@AE@%%@NL@%
        mov bx, (bp+10)%@NL@%
        mov ax, (bx)%@NL@%
%@NL@%
%@AB@%; Call the translate function in MS-DOS%@AE@%%@NL@%
        call    dword ptr [bp+6]%@NL@%
%@NL@%
%@AB@%; Return translated character to CHAR%%@AE@%%@NL@%
        mov bx, (bp+10)%@NL@%
        mov (bx), ax%@NL@%
%@NL@%
%@AB@%; Standard exit, assumes three variables passed%@AE@%%@NL@%
        pop bp%@NL@%
        ret 6%@NL@%
%@NL@%
%@AB@%; End of the procedure%@AE@%%@NL@%
casemap endp%@NL@%
        END%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CDEMO1.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\CDEMO1.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CDEMO1                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CDEMO1.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Demonstrates the QuickC routines presented in%@AE@%%@NL@%
%@AB@%  ' the file CTOOLS1.C.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:    CGA%@AE@%%@NL@%
%@AB@%  '                  MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       a%(0 TO 1999) Storage space for first text screen%@AE@%%@NL@%
%@AB@%  '                  b%(0 TO 1999) Storage space for second text screen%@AE@%%@NL@%
%@AB@%  '                  i%            Looping index%@AE@%%@NL@%
%@AB@%  '                  sseg%         Word and byte move source segment%@AE@%%@NL@%
%@AB@%  '                                part of address%@AE@%%@NL@%
%@AB@%  '                  soff%         Word and byte move source offset%@AE@%%@NL@%
%@AB@%  '                                part of address%@AE@%%@NL@%
%@AB@%  '                  dseg%         Word and byte move destination segment%@AE@%%@NL@%
%@AB@%  '                                part of address%@AE@%%@NL@%
%@AB@%  '                  doff%         Word and byte move destination offset%@AE@%%@NL@%
%@AB@%  '                                part of address%@AE@%%@NL@%
%@AB@%  '                  nwords%       Number of words to move%@AE@%%@NL@%
%@AB@%  '                  nbytes%       Number of bytes to move%@AE@%%@NL@%
%@AB@%  '                  t$            Copy of TIME$%@AE@%%@NL@%
%@AB@%  '                  quitflag%     Signal to end first demonstration%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION IsItAlnum% CDECL (BYVAL c AS INTEGER)%@NL@%
    DECLARE FUNCTION IsItAlpha% CDECL (BYVAL c AS INTEGER)%@NL@%
    DECLARE FUNCTION IsItAscii% CDECL (BYVAL c AS INTEGER)%@NL@%
    DECLARE FUNCTION IsItCntrl% CDECL (BYVAL c AS INTEGER)%@NL@%
    DECLARE FUNCTION IsItDigit% CDECL (BYVAL c AS INTEGER)%@NL@%
    DECLARE FUNCTION IsItGraph% CDECL (BYVAL c AS INTEGER)%@NL@%
    DECLARE FUNCTION IsItLower% CDECL (BYVAL c AS INTEGER)%@NL@%
    DECLARE FUNCTION IsItPrint% CDECL (BYVAL c AS INTEGER)%@NL@%
    DECLARE FUNCTION IsItPunct% CDECL (BYVAL c AS INTEGER)%@NL@%
    DECLARE FUNCTION IsItSpace% CDECL (BYVAL c AS INTEGER)%@NL@%
    DECLARE FUNCTION IsItUpper% CDECL (BYVAL c AS INTEGER)%@NL@%
    DECLARE FUNCTION IsItXDigit% CDECL (BYVAL c AS INTEGER)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB MovBytes CDECL (sseg%, soff%, dseg%, doff%, nbytes%)%@NL@%
    DECLARE SUB MovWords CDECL (sseg%, soff%, dseg%, doff%, nwords%)%@NL@%
%@NL@%
%@AB@%  ' Make two buffers for the first page of video memory%@AE@%%@NL@%
    DIM a%(0 TO 1999), b%(0 TO 1999)%@NL@%
%@NL@%
%@AB@%  ' Prevent scrolling when printing in row 25, column 80%@AE@%%@NL@%
    VIEW PRINT 1 TO 25%@NL@%
%@NL@%
%@AB@%  ' Create the first page of text%@AE@%%@NL@%
    CLS%@NL@%
    COLOR 14, 4%@NL@%
    FOR i% = 1 TO 25%@NL@%
        PRINT STRING$(80, 179);%@NL@%
    NEXT i%%@NL@%
    COLOR 15, 1%@NL@%
    LOCATE 11, 25%@NL@%
    PRINT STRING$(30, 32);%@NL@%
    LOCATE 12, 25%@NL@%
    PRINT "    -  Calling MovWords  -    "%@NL@%
    LOCATE 13, 25%@NL@%
    PRINT STRING$(30, 32);%@NL@%
%@NL@%
%@AB@%  ' Move the screen memory into the first array%@AE@%%@NL@%
    sseg% = &HB800%@NL@%
    soff% = 0%@NL@%
    dseg% = VARSEG(a%(0))%@NL@%
    doff% = VARPTR(a%(0))%@NL@%
    nwords% = 2000%@NL@%
    MovWords sseg%, soff%, dseg%, doff%, nwords%%@NL@%
%@NL@%
%@AB@%  ' Create the second page of text%@AE@%%@NL@%
    CLS%@NL@%
    COLOR 14, 4%@NL@%
    FOR i% = 1 TO 25%@NL@%
        PRINT STRING$(80, 196);%@NL@%
    NEXT i%%@NL@%
    COLOR 15, 1%@NL@%
    LOCATE 11, 25%@NL@%
    PRINT STRING$(30, 32);%@NL@%
    LOCATE 12, 25%@NL@%
    PRINT "    -  Calling MovBytes  -    "%@NL@%
    LOCATE 13, 25%@NL@%
    PRINT STRING$(30, 32);%@NL@%
%@NL@%
%@AB@%  ' Move the screen memory into the second array%@AE@%%@NL@%
    sseg% = &HB800%@NL@%
    soff% = 0%@NL@%
    dseg% = VARSEG(b%(0))%@NL@%
    doff% = VARPTR(b%(0))%@NL@%
    nwords% = 2000%@NL@%
    MovWords sseg%, soff%, dseg%, doff%, nwords%%@NL@%
%@NL@%
%@AB@%  ' Set destination to the video screen memory%@AE@%%@NL@%
    dseg% = &HB800%@NL@%
    doff% = 0%@NL@%
%@NL@%
%@AB@%  ' Do the following until a key is pressed%@AE@%%@NL@%
    DO%@NL@%
%@NL@%
%@AB@%      ' Move 2000 words from first array to screen memory%@AE@%%@NL@%
        sseg% = VARSEG(a%(0))%@NL@%
        soff% = VARPTR(a%(0))%@NL@%
        nwords% = 2000%@NL@%
        MovWords sseg%, soff%, dseg%, doff%, nwords%%@NL@%
%@NL@%
%@AB@%      ' Wait one second%@AE@%%@NL@%
        t$ = TIME$%@NL@%
        DO%@NL@%
            IF INKEY$ <> "" THEN%@NL@%
                t$ = ""%@NL@%
                quitFlag% = 1%@NL@%
            END IF%@NL@%
        LOOP UNTIL TIME$ <> t$%@NL@%
%@NL@%
%@AB@%      ' Move 4000 bytes from second array to screen memory%@AE@%%@NL@%
        sseg% = VARSEG(b%(0))%@NL@%
        soff% = VARPTR(b%(0))%@NL@%
        nbytes% = 4000%@NL@%
        MovBytes sseg%, soff%, dseg%, doff%, nbytes%%@NL@%
%@NL@%
%@AB@%      ' Wait one second%@AE@%%@NL@%
        t$ = TIME$%@NL@%
        DO%@NL@%
            IF INKEY$ <> "" THEN%@NL@%
                t$ = ""%@NL@%
                quitFlag% = 1%@NL@%
            END IF%@NL@%
        LOOP UNTIL TIME$ <> t$%@NL@%
%@NL@%
    LOOP UNTIL quitFlag%%@NL@%
%@NL@%
%@AB@%  ' Create a table of all 256 characters and their type designations%@AE@%%@NL@%
    FOR i% = 0 TO 255%@NL@%
%@NL@%
%@AB@%      ' After each screenful display a heading%@AE@%%@NL@%
        IF i% MOD 19 = 0 THEN%@NL@%
%@NL@%
%@AB@%          ' If not the first heading, prompt user before continuing%@AE@%%@NL@%
            IF i% THEN%@NL@%
                PRINT%@NL@%
                PRINT "Press any key to continue"%@NL@%
                DO WHILE INKEY$ = ""%@NL@%
                LOOP%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Print the heading%@AE@%%@NL@%
            CLS%@NL@%
            PRINT "Char   Alnum Alpha Ascii Cntrl Digit Graph ";%@NL@%
            PRINT "Lower Print Punct Space Upper XDigit"%@NL@%
            PRINT%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Some characters we don't want to display%@AE@%%@NL@%
        SELECT CASE i%%@NL@%
        CASE 7, 8, 9, 10, 11, 12, 13, 29, 30, 31%@NL@%
            PRINT USING "###    "; i%;%@NL@%
        CASE ELSE%@NL@%
            PRINT USING "### \ \"; i%, CHR$(i%);%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%      ' Display "1" if test is true, "0" otherwise%@AE@%%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItAlnum%(i%));%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItAlpha%(i%));%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItAscii%(i%));%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItCntrl%(i%));%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItDigit%(i%));%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItGraph%(i%));%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItLower%(i%));%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItPrint%(i%));%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItPunct%(i%));%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItSpace%(i%));%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItUpper%(i%));%@NL@%
        PRINT USING "  #   "; 1 + (0 = IsItXDigit%(i%))%@NL@%
%@NL@%
    NEXT i%%@NL@%
    END%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CDEMO2.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\CDEMO2.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CDEMO2                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CDEMO2.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:    CGA%@AE@%%@NL@%
%@AB@%  '                  MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       m$            Menu string%@AE@%%@NL@%
%@AB@%  '                  word%         Integer to be packed with two bytes%@AE@%%@NL@%
%@AB@%  '                  hi%           Most significant byte unpacked from an%@AE@%%@NL@%
%@AB@%  '                                integer%@AE@%%@NL@%
%@AB@%  '                  lo%           Least significant byte unpacked from an%@AE@%%@NL@%
%@AB@%  '                                integer%@AE@%%@NL@%
%@AB@%  '                  a$            Workspace for TextGet and TextPut%@AE@%%@NL@%
%@AB@%  '                  b$            Workspace for TextGet and TextPut%@AE@%%@NL@%
%@AB@%  '                  n%            Timing constant for TextPut demonstration%@AE@%%@NL@%
%@AB@%  '                  row%          Row location to put small "window" using%@AE@%%@NL@%
%@AB@%  '                                TextPut%@AE@%%@NL@%
%@AB@%  '                  col%          Column location to put small "window" using%@AE@%%@NL@%
%@AB@%  '                                TextPut%@AE@%%@NL@%
%@AB@%  '                  t0            Timer variable%@AE@%%@NL@%
%@AB@%  '                  x$            String variable for bit shifting%@AE@%%@NL@%
%@AB@%  '                  i%            Looping index%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION MenuString% CDECL (row%, col%, a$)%@NL@%
    DECLARE FUNCTION BitShiftleft% CDECL (a$)%@NL@%
    DECLARE FUNCTION BitShiftRight% CDECL (a$)%@NL@%
    DECLARE FUNCTION NumberOfBits& CDECL (a$)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB PackWord CDECL (word%, hi%, lo%)%@NL@%
    DECLARE SUB UnPackWord CDECL (word%, hi%, lo%)%@NL@%
    DECLARE SUB TextGet CDECL (r1%, c1%, r2%, c2%, a$)%@NL@%
    DECLARE SUB TextPut CDECL (r1%, c1%, r2%, c2%, a$)%@NL@%
%@NL@%
%@AB@%  ' Build menu string%@AE@%%@NL@%
    m$ = "Packword Unpackword Textget Textput "%@NL@%
    m$ = m$ + "Bitshiftleft Bitshiftright Numberofbits Quit"%@NL@%
%@NL@%
%@AB@%  ' Let user repeatedly select the demonstrations%@AE@%%@NL@%
    DO%@NL@%
        COLOR 15, 1%@NL@%
        CLS%@NL@%
        PRINT%@NL@%
        PRINT%@NL@%
        PRINT "MenuString function..."%@NL@%
        PRINT%@NL@%
        PRINT "Select one of the CTOOLS2 demonstrations by ";%@NL@%
        PRINT "pressing the Left arrow,"%@NL@%
        PRINT "Right arrow, first letter of the choice, or Enter keys."%@NL@%
%@NL@%
%@AB@%      ' Use MenuString to choose demonstrations%@AE@%%@NL@%
        SELECT CASE MenuString%(1, 1, m$)%@NL@%
%@NL@%
%@AB@%      ' PackWord demonstration%@AE@%%@NL@%
        CASE 1%@NL@%
%@NL@%
            CLS%@NL@%
            PRINT "PackWord word%, 255, 255  ...  word% = ";%@NL@%
            PackWord word%, 255, 255%@NL@%
            PRINT word%%@NL@%
            PRINT "PackWord word%,   0,   1  ...  word% = ";%@NL@%
            PackWord word%, 0, 1%@NL@%
            PRINT word%%@NL@%
            PRINT "PackWord word%,   1,   0  ...  word% = ";%@NL@%
            PackWord word%, 1, 0%@NL@%
            PRINT word%%@NL@%
%@NL@%
            PRINT%@NL@%
            PRINT "Press any key to continue..."%@NL@%
%@NL@%
            DO%@NL@%
            LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%      ' UnPackWord demonstration%@AE@%%@NL@%
        CASE 2%@NL@%
%@NL@%
            CLS%@NL@%
            PRINT "UnPackWord  -1, hi%, lo%  ...  hi%, lo% =";%@NL@%
            UnPackWord -1, hi%, lo%%@NL@%
            PRINT hi%; lo%%@NL@%
            PRINT "UnPackWord   1, hi%, lo%  ...  hi%, lo% =";%@NL@%
            UnPackWord 1, hi%, lo%%@NL@%
            PRINT hi%; lo%%@NL@%
            PRINT "UnPackWord 256, hi%, lo%  ...  hi%, lo% =";%@NL@%
            UnPackWord 256, hi%, lo%%@NL@%
            PRINT hi%; lo%%@NL@%
%@NL@%
            PRINT%@NL@%
            PRINT "Press any key to continue..."%@NL@%
%@NL@%
            DO%@NL@%
            LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%      ' TextGet and TextPut demonstration%@AE@%%@NL@%
        CASE 3, 4%@NL@%
%@NL@%
%@AB@%          ' TextGet a line of text%@AE@%%@NL@%
            CLS%@NL@%
            PRINT "A Vertical Message"%@NL@%
            a$ = SPACE$(36)%@NL@%
            TextGet 1, 1, 1, 18, a$%@NL@%
%@NL@%
%@AB@%          ' TextPut it back, but stretch it vertically%@AE@%%@NL@%
            TextPut 6, 1, 23, 1, a$%@NL@%
%@NL@%
%@AB@%          ' Now just a normal line of text at top%@AE@%%@NL@%
            LOCATE 1, 1%@NL@%
            PRINT "TextGet and TextPut - Press any key to stop"%@NL@%
%@NL@%
%@AB@%          ' Create first of two colorful text patterns%@AE@%%@NL@%
            COLOR 14, 4%@NL@%
            LOCATE 13, 13, 0%@NL@%
            PRINT CHR$(201); CHR$(205); CHR$(209); CHR$(205); CHR$(187)%@NL@%
            LOCATE 14, 13, 0%@NL@%
            PRINT CHR$(199); CHR$(196); CHR$(197); CHR$(196); CHR$(182)%@NL@%
            LOCATE 15, 13, 0%@NL@%
            PRINT CHR$(200); CHR$(205); CHR$(207); CHR$(205); CHR$(188)%@NL@%
            a$ = SPACE$(30)%@NL@%
            TextGet 13, 13, 15, 17, a$%@NL@%
%@NL@%
%@AB@%          ' Create second of two colorful text patterns%@AE@%%@NL@%
            COLOR 10, 1%@NL@%
            LOCATE 13, 13, 0%@NL@%
            PRINT CHR$(218); CHR$(196); CHR$(210); CHR$(196); CHR$(191)%@NL@%
            LOCATE 14, 13, 0%@NL@%
            PRINT CHR$(198); CHR$(205); CHR$(206); CHR$(205); CHR$(181)%@NL@%
            LOCATE 15, 13, 0%@NL@%
            PRINT CHR$(192); CHR$(196); CHR$(208); CHR$(196); CHR$(217)%@NL@%
            b$ = SPACE$(30)%@NL@%
            TextGet 13, 13, 15, 17, b$%@NL@%
%@NL@%
%@AB@%          ' Randomly pop up little "windows"%@AE@%%@NL@%
            n% = 0%@NL@%
            DO%@NL@%
                row% = INT(RND * 21 + 3)%@NL@%
                col% = INT(RND * 73 + 4)%@NL@%
                TextPut row%, col%, row% + 2, col% + 4, a$%@NL@%
                row% = INT(RND * 21 + 3)%@NL@%
                col% = INT(RND * 73 + 4)%@NL@%
                TextPut row%, col%, row% + 2, col% + 4, b$%@NL@%
                IF n% < 10 THEN%@NL@%
                    n% = n% + 1%@NL@%
                    t0 = TIMER%@NL@%
                    DO%@NL@%
                    LOOP UNTIL TIMER > t0 + (10 - n%) / 10%@NL@%
                END IF%@NL@%
            LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%      ' BitShiftLeft demonstration%@AE@%%@NL@%
        CASE 5%@NL@%
%@NL@%
            CLS%@NL@%
            x$ = "This string will be shifted left 8 bits"%@NL@%
            PRINT x$%@NL@%
            FOR i% = 1 TO 8%@NL@%
                PRINT "bit ="; BitShiftleft%(x$)%@NL@%
            NEXT i%%@NL@%
            PRINT x$%@NL@%
%@NL@%
            PRINT%@NL@%
            PRINT "Press any key to continue..."%@NL@%
%@NL@%
            DO%@NL@%
            LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%      ' BitShiftRight demonstration%@AE@%%@NL@%
        CASE 6%@NL@%
%@NL@%
            CLS%@NL@%
            x$ = "This string will be shifted right 8 bits"%@NL@%
            PRINT x$%@NL@%
            FOR i% = 1 TO 8%@NL@%
                PRINT "bit ="; BitShiftRight%(x$)%@NL@%
            NEXT i%%@NL@%
            PRINT x$%@NL@%
%@NL@%
            PRINT%@NL@%
            PRINT "Press any key to continue..."%@NL@%
%@NL@%
            DO%@NL@%
            LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%      ' BitShiftRight demonstration%@AE@%%@NL@%
        CASE 7%@NL@%
%@NL@%
            CLS%@NL@%
            x$ = "The number of bits in this string is ..."%@NL@%
            PRINT x$%@NL@%
            PRINT NumberOfBits&(x$)%@NL@%
%@NL@%
            PRINT%@NL@%
            PRINT "Press any key to continue..."%@NL@%
%@NL@%
            DO%@NL@%
            LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%      ' Must be time to quit%@AE@%%@NL@%
        CASE ELSE%@NL@%
            COLOR 7, 0%@NL@%
            CLS%@NL@%
            END%@NL@%
        END SELECT%@NL@%
    LOOP%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CHECK.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\CHECK.BAS%@AE@%%@NL@%
%@NL@%
DIM Amount(1 TO 100)%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%' Get account's starting balance:%@AE@%%@NL@%
CLS%@NL@%
INPUT "Type starting balance, then press <ENTER>: ", Balance%@NL@%
%@NL@%
%@AB@%' Get transactions. Continue accepting input until the%@AE@%%@NL@%
%@AB@%' input is zero for a transaction, or until 100%@AE@%%@NL@%
%@AB@%' transactions have been entered:%@AE@%%@NL@%
FOR TransacNum% = 1 TO 100%@NL@%
   PRINT TransacNum%;%@NL@%
   PRINT ") Enter transaction amount (0 to end): ";%@NL@%
   INPUT "", Amount(TransacNum%)%@NL@%
   IF Amount(TransacNum%) = 0 THEN%@NL@%
      TransacNum% = TransacNum% - 1%@NL@%
      EXIT FOR%@NL@%
   END IF%@NL@%
NEXT%@NL@%
%@NL@%
%@AB@%' Sort transactions in ascending order,%@AE@%%@NL@%
%@AB@%' using a "bubble sort":%@AE@%%@NL@%
Limit% = TransacNum%%@NL@%
DO%@NL@%
   Swaps% = FALSE%@NL@%
   FOR I% = 1 TO (Limit% - 1)%@NL@%
%@NL@%
%@AB@%      ' If two adjacent elements are out of order, switch%@AE@%%@NL@%
%@AB@%      ' those elements:%@AE@%%@NL@%
      IF Amount(I%) < Amount(I% + 1) THEN%@NL@%
         SWAP Amount(I%), Amount(I% + 1)%@NL@%
         Swaps% = I%%@NL@%
      END IF%@NL@%
   NEXT I%%@NL@%
%@NL@%
%@AB@%   ' Sort on next pass only to where the last switch was made:%@AE@%%@NL@%
   IF Swaps% THEN Limit% = Swaps%%@NL@%
%@NL@%
%@AB@%' Sort until no elements are exchanged:%@AE@%%@NL@%
LOOP WHILE Swaps%%@NL@%
%@NL@%
%@AB@%' Print the sorted transaction array. If a transaction%@AE@%%@NL@%
%@AB@%' is greater than zero, print it as a "CREDIT"; if a%@AE@%%@NL@%
%@AB@%' transaction is less than zero, print it as a "DEBIT":%@AE@%%@NL@%
FOR I% = 1 TO TransacNum%%@NL@%
   IF Amount(I%) > 0 THEN%@NL@%
      PRINT USING "CREDIT: $$#####.##"; Amount(I%)%@NL@%
   ELSEIF Amount(I%) < 0 THEN%@NL@%
      PRINT USING "DEBIT:  $$#####.##"; Amount(I%)%@NL@%
   END IF%@NL@%
%@NL@%
%@AB@%   ' Update balance:%@AE@%%@NL@%
   Balance = Balance + Amount(I%)%@NL@%
NEXT I%%@NL@%
%@NL@%
%@AB@%' Print the final balance:%@AE@%%@NL@%
PRINT%@NL@%
PRINT "--------------------------"%@NL@%
PRINT USING "Final Total: $$######.##"; Balance%@NL@%
END%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CIPHER.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\CIPHER.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CIPHER                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CIPHER.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:   CIPHER  filename.ext key    or    CIPHER /NEWKEY%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       CIPHER.BAS%@AE@%%@NL@%
%@AB@%  '                  RANDOMS.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      filename      Name of file to be ciphered or deciphered%@AE@%%@NL@%
%@AB@%  '                  key           String of one or more words used as the%@AE@%%@NL@%
%@AB@%  '                                cipher key%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       cmd$          Working copy of COMMAND$%@AE@%%@NL@%
%@AB@%  '                  i%            Loop index%@AE@%%@NL@%
%@AB@%  '                  firstSpace%   Location in command line of first character%@AE@%%@NL@%
%@AB@%  '                  fileName$     Name of file to be processed%@AE@%%@NL@%
%@AB@%  '                  key$          String to be used as cipher key%@AE@%%@NL@%
%@AB@%  '                  fileLength&   Length of file to be processed%@AE@%%@NL@%
%@AB@%  '                  a$            Workspace for groups of bytes from the file%@AE@%%@NL@%
%@AB@%  '                  count%        Number of groups of bytes to be processed%@AE@%%@NL@%
%@AB@%  '                  j&            Location in file of each group of bytes%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Constants%@AE@%%@NL@%
    CONST BYTES = 1000&%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION NewWord$ ()%@NL@%
    DECLARE FUNCTION Rand& ()%@NL@%
    DECLARE FUNCTION RandInteger% (a%, b%)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB RandShuffle (key$)%@NL@%
    DECLARE SUB ProcesX (a$)%@NL@%
%@NL@%
%@AB@%  ' Initialization%@AE@%%@NL@%
    CLS%@NL@%
    PRINT "CIPHER "; COMMAND$%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Grab the command line parameters%@AE@%%@NL@%
    cmd$ = COMMAND$%@NL@%
%@NL@%
%@AB@%  ' If no command line parameters, then tell user what's needed%@AE@%%@NL@%
    IF cmd$ = "" THEN%@NL@%
        PRINT%@NL@%
        PRINT "Usage:  CIPHER /NEWKEY"%@NL@%
        PRINT "(or)    CIPHER filename key-string"%@NL@%
        PRINT%@NL@%
        SYSTEM%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' If /NEWKEY option, generate a few new words, and then quit%@AE@%%@NL@%
    IF INSTR(cmd$, "/NEWKEY") THEN%@NL@%
%@NL@%
%@AB@%      ' Clear the screen and describe the output%@AE@%%@NL@%
        CLS%@NL@%
        PRINT "Randomly created words that can be used as cipher keys..."%@NL@%
        PRINT%@NL@%
        RandShuffle DATE$ + TIME$ + STR$(TIMER)%@NL@%
        FOR i% = 1 TO 9%@NL@%
            PRINT NewWord$; " ";%@NL@%
        NEXT i%%@NL@%
        PRINT%@NL@%
        SYSTEM%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Get the filename from the command line%@AE@%%@NL@%
    cmd$ = cmd$ + " "%@NL@%
    firstSpace% = INSTR(cmd$, " ")%@NL@%
    fileName$ = LEFT$(cmd$, firstSpace% - 1)%@NL@%
%@NL@%
%@AB@%  ' Grab the rest of the command line as the cipher key%@AE@%%@NL@%
    key$ = LTRIM$(MID$(cmd$, firstSpace% + 1))%@NL@%
%@NL@%
%@AB@%  ' Prepare the pseudorandom numbers using the key for shuffling%@AE@%%@NL@%
    RandShuffle key$%@NL@%
%@NL@%
%@AB@%  ' Open up the file%@AE@%%@NL@%
    OPEN fileName$ FOR BINARY AS #1%@NL@%
    fileLength& = LOF(1)%@NL@%
%@NL@%
%@AB@%  ' Process the file in manageable pieces%@AE@%%@NL@%
    a$ = SPACE$(BYTES)%@NL@%
    count% = fileLength& \ BYTES%@NL@%
%@NL@%
%@AB@%  ' Loop through the file%@AE@%%@NL@%
    FOR i% = 0 TO count%%@NL@%
        j& = i% * BYTES + 1%@NL@%
        IF i% = count% THEN%@NL@%
            a$ = SPACE$(fileLength& - BYTES * count%)%@NL@%
        END IF%@NL@%
        GET #1, j&, a$%@NL@%
        ProcesX a$%@NL@%
        PUT #1, j&, a$%@NL@%
    NEXT i%%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    SYSTEM%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          NewWord$                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CIPHER.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a pseudorandom word of a possibly%@AE@%%@NL@%
%@AB@%  ' speakable form.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE: PRINT NewWord$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:     (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      vowel$     String constant listing the set of vowels%@AE@%%@NL@%
%@AB@%  '                 consonant$ String constant listing the set of consonants%@AE@%%@NL@%
%@AB@%  '                 syllables% Random number of syllables for the new word%@AE@%%@NL@%
%@AB@%  '                 i%         Loop index for creating each syllable%@AE@%%@NL@%
%@AB@%  '                 t$         Temporary work string for forming the new word%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS: DECLARE FUNCTION NewWord$ ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION NewWord$ STATIC%@NL@%
        CONST vowel$ = "aeiou"%@NL@%
        CONST consonant$ = "bcdfghjklmnpqrstvwxyz"%@NL@%
        syllables% = Rand& MOD 3 + 1%@NL@%
        FOR i% = 1 TO syllables%%@NL@%
            t$ = t$ + MID$(consonant$, RandInteger%(1, 21), 1)%@NL@%
            IF i% = 1 THEN%@NL@%
                t$ = UCASE$(t$)%@NL@%
            END IF%@NL@%
            t$ = t$ + MID$(vowel$, RandInteger%(1, 5), 1)%@NL@%
        NEXT i%%@NL@%
        IF Rand& MOD 2 THEN%@NL@%
            t$ = t$ + MID$(consonant$, RandInteger%(1, 21), 1)%@NL@%
        END IF%@NL@%
        NewWord$ = t$%@NL@%
        t$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ProcesX                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CIPHER.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Enciphers a string by XORing with pseudorandom bytes.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ProcesX a$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String to be ciphered%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%         Index into the string%@AE@%%@NL@%
%@AB@%  '                  byte%      Numeric value of each string character%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB ProcesX (a$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ProcesX (a$) STATIC%@NL@%
        FOR i% = 1 TO LEN(a$)%@NL@%
            byte% = ASC(MID$(a$, i%, 1)) XOR RandInteger%(0, 255)%@NL@%
            MID$(a$, i%, 1) = CHR$(byte%)%@NL@%
        NEXT i%%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%COLORS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\COLORS.BAS%@AE@%%@NL@%
%@NL@%
SCREEN 1%@NL@%
%@NL@%
Esc$ = CHR$(27)%@NL@%
%@NL@%
%@AB@%' Draw three boxes and paint the interior of each%@AE@%%@NL@%
%@AB@%' box with a different color:%@AE@%%@NL@%
FOR ColorVal = 1 TO 3%@NL@%
   LINE (X, Y)-STEP(60, 50), ColorVal, BF%@NL@%
   X = X + 61%@NL@%
   Y = Y + 51%@NL@%
NEXT ColorVal%@NL@%
%@NL@%
LOCATE 21, 1%@NL@%
PRINT "Press ESC to end."%@NL@%
PRINT "Press any other key to continue."%@NL@%
%@NL@%
%@AB@%' Restrict additional printed output to the twenty-third line:%@AE@%%@NL@%
VIEW PRINT 23 TO 23%@NL@%
%@NL@%
DO%@NL@%
   PaletteVal = 1%@NL@%
   DO%@NL@%
%@NL@%
%@AB@%      ' PaletteVal is either one or zero:%@AE@%%@NL@%
      PaletteVal = 1 - PaletteVal%@NL@%
%@NL@%
%@AB@%      ' Set the background color and choose the palette:%@AE@%%@NL@%
      COLOR BackGroundVal, PaletteVal%@NL@%
      PRINT "Background ="; BackGroundVal; "Palette ="; PaletteVal;%@NL@%
%@NL@%
      Pause$ = INPUT$(1)        ' Wait for a keystroke.%@NL@%
      PRINT%@NL@%
%@NL@%
%@AB@%   ' Exit the loop if both palettes have been shown,%@AE@%%@NL@%
%@AB@%   ' or if the user pressed the ESC key:%@AE@%%@NL@%
   LOOP UNTIL PaletteVal = 1 OR Pause$ = Esc$%@NL@%
%@NL@%
   BackGroundVal = BackGroundVal + 1%@NL@%
%@NL@%
%@AB@%' Exit this loop if all sixteen background colors have been%@AE@%%@NL@%
%@AB@%' shown, or if the user pressed the ESC key:%@AE@%%@NL@%
LOOP UNTIL BackGroundVal > 15 OR Pause$ = Esc$%@NL@%
%@NL@%
SCREEN 0                        ' Restore text mode and%@NL@%
WIDTH 80                        ' eighty-column screen width.%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%COLORS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\COLORS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          COLORS                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COLORS.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Provides interactive selection of a color shade.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:    VGA or MCGA%@AE@%%@NL@%
%@AB@%  '                  MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  '                  Mouse%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       COLORS.BAS%@AE@%%@NL@%
%@AB@%  '                  BITS.BAS%@AE@%%@NL@%
%@AB@%  '                  MOUSSUBS.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       red!            Intensity of red, from 0 to 1%@AE@%%@NL@%
%@AB@%  '                  green!          Intensity of green, from 0 to 1%@AE@%%@NL@%
%@AB@%  '                  blue!           Intensity of blue, from 0 to 1%@AE@%%@NL@%
%@AB@%  '                  mask$           Mouse graphics cursor definition string%@AE@%%@NL@%
%@AB@%  '                  xHot%           Mouse cursor hot spot X location%@AE@%%@NL@%
%@AB@%  '                  yHot%           Mouse cursor hot spot Y location%@AE@%%@NL@%
%@AB@%  '                  cursor$         Mouse cursor binary definition string%@AE@%%@NL@%
%@AB@%  '                  fill%           Color bar height calculation%@AE@%%@NL@%
%@AB@%  '                  x%              Color bar horizontal left edge%@AE@%%@NL@%
%@AB@%  '                  x2%             Color bar horizontal right edge%@AE@%%@NL@%
%@AB@%  '                  y%              Color bar vertical top edge%@AE@%%@NL@%
%@AB@%  '                  y2%             Color bar vertical bottom edge%@AE@%%@NL@%
%@AB@%  '                  leftButton%     State of left mouse button%@AE@%%@NL@%
%@AB@%  '                  rightButton%    State of right mouse button%@AE@%%@NL@%
%@AB@%  '                  xMouse%         Horizontal mouse location%@AE@%%@NL@%
%@AB@%  '                  yMouse%         Vertical mouse location%@AE@%%@NL@%
%@AB@%  '                  clickFlag%      Toggle for left mouse button state%@AE@%%@NL@%
%@AB@%  '                  xM%             Modified mouse horizontal location%@AE@%%@NL@%
%@AB@%  '                  quitFlag%       Signal to end program%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Logical constants%@AE@%%@NL@%
    CONST FALSE = 0%@NL@%
    CONST TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%  ' Constants%@AE@%%@NL@%
    CONST REDPAL = 1%@NL@%
    CONST BLUEPAL = 2%@NL@%
    CONST GREENPAL = 3%@NL@%
    CONST TESTPAL = 4%@NL@%
    CONST WHITEPAL = 5%@NL@%
    CONST BARPAL = 6%@NL@%
    CONST DX = 15%@NL@%
    CONST DY = 150%@NL@%
    CONST RX = 180%@NL@%
    CONST RY = 30%@NL@%
    CONST GX = RX + DX + DX%@NL@%
    CONST GY = RY%@NL@%
    CONST BX = GX + DX + DX%@NL@%
    CONST BY = RY%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION Shade& (red!, green!, blue!)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB MouseHide ()%@NL@%
    DECLARE SUB MouseMaskTranslate (mask$, xHot%, yHot%, cursor$)%@NL@%
    DECLARE SUB MouseSetGcursor (cursor$)%@NL@%
    DECLARE SUB MouseShow ()%@NL@%
    DECLARE SUB Cursleft (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB MouseNow (leftButton%, rightButton%, xMouse%, yMouse%)%@NL@%
%@NL@%
%@AB@%  ' Set 256 color mode%@AE@%%@NL@%
    SCREEN 13%@NL@%
%@NL@%
%@AB@%  ' Set first three colors as pure red, green, blue%@AE@%%@NL@%
    PALETTE REDPAL, Shade&(1!, 0!, 0!)%@NL@%
    PALETTE GREENPAL, Shade&(0!, 1!, 0!)%@NL@%
    PALETTE BLUEPAL, Shade&(0!, 0!, 1!)%@NL@%
%@NL@%
%@AB@%  ' Set a pure white color choice%@AE@%%@NL@%
    PALETTE WHITEPAL, Shade&(1!, 1!, 1!)%@NL@%
%@NL@%
%@AB@%  ' Set bar background color%@AE@%%@NL@%
    PALETTE BARPAL, Shade&(0!, 0!, 0!)%@NL@%
%@NL@%
%@AB@%  ' Set background to light gray%@AE@%%@NL@%
    PALETTE 0, Shade&(.4, .4, .4)%@NL@%
%@NL@%
%@AB@%  ' Start each intensity at midscale%@AE@%%@NL@%
    red! = .5%@NL@%
    green! = .5%@NL@%
    blue! = .5%@NL@%
%@NL@%
%@AB@%  ' Set starting shade%@AE@%%@NL@%
    PALETTE TESTPAL, Shade&(red!, green!, blue!)%@NL@%
%@NL@%
%@AB@%  ' Create ellipse of circle to show current shade selected%@AE@%%@NL@%
    CIRCLE (70, 100), 80, TESTPAL, , , 1.4%@NL@%
    PAINT (70, 100), TESTPAL%@NL@%
%@NL@%
%@AB@%  ' Create the three color bars%@AE@%%@NL@%
    LINE (RX, RY)-(RX + DX, RY + DY), WHITEPAL, B%@NL@%
    LINE (GX, GY)-(GX + DX, GY + DY), WHITEPAL, B%@NL@%
    LINE (BX, BY)-(BX + DX, BY + DY), WHITEPAL, B%@NL@%
%@NL@%
%@AB@%  ' Mark place to quit by clicking%@AE@%%@NL@%
    LOCATE 25, 1%@NL@%
    PRINT "(X) "; CHR$(27); " Quit";%@NL@%
%@NL@%
%@AB@%  ' Make the left arrow mouse cursor%@AE@%%@NL@%
    Cursleft mask$, xHot%, yHot%%@NL@%
    MouseMaskTranslate mask$, xHot%, yHot%, cursor$%@NL@%
    MouseSetGcursor cursor$%@NL@%
%@NL@%
%@AB@%  ' Main loop%@AE@%%@NL@%
    DO%@NL@%
%@NL@%
%@AB@%      ' Put title and current shade number at top%@AE@%%@NL@%
        LOCATE 1, 1%@NL@%
        PRINT "COLOR CHOOSER"; TAB(22);%@NL@%
        PRINT USING "##########"; Shade&(red!, green!, blue!)%@NL@%
%@NL@%
%@AB@%      ' Fill in the red color bar%@AE@%%@NL@%
        fill% = red! * (DY - 3) + 1%@NL@%
        x% = RX + 1%@NL@%
        x2% = RX + DX%@NL@%
        y% = RY + 1%@NL@%
        y2% = RY + DY%@NL@%
        LINE (x%, y%)-(x2% - 1, y2% - fill% - 1), BARPAL, BF%@NL@%
        LINE (x%, y2% - fill%)-(x2% - 1, y2% - 1), REDPAL, BF%@NL@%
%@NL@%
%@AB@%      ' Fill in the green color bar%@AE@%%@NL@%
        fill% = green! * (DY - 3) + 1%@NL@%
        x% = GX + 1%@NL@%
        x2% = GX + DX%@NL@%
        y% = GY + 1%@NL@%
        y2% = GY + DY%@NL@%
        LINE (x%, y%)-(x2% - 1, y2% - fill% - 1), BARPAL, BF%@NL@%
        LINE (x%, y2% - fill%)-(x2% - 1, y2% - 1), GREENPAL, BF%@NL@%
%@NL@%
%@AB@%      ' Fill in the blue color bar%@AE@%%@NL@%
        fill% = blue! * (DY - 3) + 1%@NL@%
        x% = BX + 1%@NL@%
        x2% = BX + DX%@NL@%
        y% = BY + 1%@NL@%
        y2% = BY + DY%@NL@%
        LINE (x%, y%)-(x2% - 1, y2% - fill% - 1), BARPAL, BF%@NL@%
        LINE (x%, y2% - fill%)-(x2% - 1, y2% - 1), BLUEPAL, BF%@NL@%
%@NL@%
%@AB@%      ' Change the shade of the ellipse%@AE@%%@NL@%
        PALETTE TESTPAL, Shade&(red!, green!, blue!)%@NL@%
%@NL@%
%@AB@%      ' Refresh mouse cursor%@AE@%%@NL@%
        MouseShow%@NL@%
%@NL@%
%@AB@%      ' Wait for fresh mouse left button click%@AE@%%@NL@%
        DO%@NL@%
            MouseNow leftButton%, rightButton%, xMouse%, yMouse%%@NL@%
            IF leftButton% = FALSE THEN%@NL@%
                clickFlag% = FALSE%@NL@%
            END IF%@NL@%
            IF clickFlag% THEN%@NL@%
                leftButton% = 0%@NL@%
            END IF%@NL@%
        LOOP UNTIL leftButton%%@NL@%
%@NL@%
%@AB@%      ' Hide mouse and set parameters%@AE@%%@NL@%
        MouseHide%@NL@%
        clickFlag% = TRUE%@NL@%
        xM% = xMouse% \ 2%@NL@%
%@NL@%
%@AB@%      ' Is mouse in the "Quit" area?%@AE@%%@NL@%
        IF xMouse% < 45 AND yMouse% > 190 THEN%@NL@%
            quitFlag% = TRUE%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Is mouse at the right height to be in a bar?%@AE@%%@NL@%
        IF yMouse% > RY - 2 AND yMouse% < RY + DY + 2 THEN%@NL@%
%@NL@%
%@AB@%          ' Is mouse in the red bar?%@AE@%%@NL@%
            IF xM% > RX AND xM% < RX + DX THEN%@NL@%
                red! = 1! - (yMouse% - RY) / DY%@NL@%
                IF red! < 0 THEN%@NL@%
                    red! = 0%@NL@%
                ELSEIF red! > 1 THEN%@NL@%
                    red! = 1%@NL@%
                END IF%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Is mouse in the green bar?%@AE@%%@NL@%
            IF xM% > GX AND xM% < GX + DX THEN%@NL@%
                green! = 1! - (yMouse% - RY) / DY%@NL@%
                IF green! < 0 THEN%@NL@%
                    green! = 0%@NL@%
                ELSEIF green! > 1 THEN%@NL@%
                    green! = 1%@NL@%
                END IF%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Is mouse in the blue bar?%@AE@%%@NL@%
            IF xM% > BX AND xM% < BX + DX THEN%@NL@%
                blue! = 1! - (yMouse% - RY) / DY%@NL@%
                IF blue! < 0 THEN%@NL@%
                    blue! = 0%@NL@%
                ELSEIF blue! > 1 THEN%@NL@%
                    blue! = 1%@NL@%
                END IF%@NL@%
            END IF%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
    LOOP UNTIL quitFlag%%@NL@%
%@NL@%
    SCREEN 0%@NL@%
    WIDTH 80%@NL@%
    CLS%@NL@%
    END%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Shade&                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COLORS.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the long integer color number given red,%@AE@%%@NL@%
%@AB@%  ' green, and blue intensity numbers in the range%@AE@%%@NL@%
%@AB@%  ' 0 to 1.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  PALETTE 1, Shade&(red!, green!, blue!)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      red!       Intensity of red, from 0 through 1%@AE@%%@NL@%
%@AB@%  '                  green!     Intensity of green, from 0 through 1%@AE@%%@NL@%
%@AB@%  '                  blue!      Intensity of blue, from 0 through 1%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       r&         Red amount%@AE@%%@NL@%
%@AB@%  '                  g&         Green amount%@AE@%%@NL@%
%@AB@%  '                  b&         Blue amount%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Shade& (red!, green!, blue!)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Shade& (red!, green!, blue!) STATIC%@NL@%
        r& = red! * 63!%@NL@%
        g& = green! * 63!%@NL@%
        b& = blue! * 63!%@NL@%
        Shade& = r& + g& * 256& + b& * 65536%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%COMPLEX.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\COMPLEX.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          COMPLEX                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Demonstrates a set of complex number functions and%@AE@%%@NL@%
%@AB@%  ' subprograms.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:         No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:     COMPLEX.BAS%@AE@%%@NL@%
%@AB@%  '                CARTESIA.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:    (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:     a          Variable of type Complex%@AE@%%@NL@%
%@AB@%  '                b          Variable of type Complex%@AE@%%@NL@%
%@AB@%  '                c          Variable of type Complex%@AE@%%@NL@%
%@AB@%  '                x$         String representation of a complex number%@AE@%%@NL@%
%@AB@%  '                y$         String representation of a complex number%@AE@%%@NL@%
%@AB@%  '                z$         String representation of a complex number%@AE@%%@NL@%
%@NL@%
    TYPE Complex%@NL@%
        r AS SINGLE%@NL@%
        i AS SINGLE%@NL@%
    END TYPE%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB ComplexSub (a AS Complex, b AS Complex, c AS Complex)%@NL@%
    DECLARE SUB ComplexSqr (a AS Complex, c AS Complex)%@NL@%
    DECLARE SUB ComplexRoot (a AS Complex, b AS Complex, c AS Complex)%@NL@%
    DECLARE SUB ComplexReciprocal (a AS Complex, c AS Complex)%@NL@%
    DECLARE SUB ComplexAdd (a AS Complex, b AS Complex, c AS Complex)%@NL@%
    DECLARE SUB ComplexLog (a AS Complex, c AS Complex)%@NL@%
    DECLARE SUB ComplexPower (a AS Complex, b AS Complex, c AS Complex)%@NL@%
    DECLARE SUB Complex2String (a AS Complex, x$)%@NL@%
    DECLARE SUB String2Complex (x$, a AS Complex)%@NL@%
    DECLARE SUB ComplexDiv (a AS Complex, b AS Complex, c AS Complex)%@NL@%
    DECLARE SUB ComplexExp (a AS Complex, c AS Complex)%@NL@%
    DECLARE SUB ComplexMul (a AS Complex, b AS Complex, c AS Complex)%@NL@%
    DECLARE SUB Rec2pol (x!, y!, r!, theta!)%@NL@%
%@NL@%
    DIM a AS Complex, b AS Complex, c AS Complex%@NL@%
%@NL@%
    CLS%@NL@%
    INPUT "Enter first complex number  "; x$%@NL@%
    String2Complex x$, a%@NL@%
    Complex2String a, x$%@NL@%
    PRINT x$%@NL@%
    PRINT%@NL@%
%@NL@%
    ComplexExp a, c%@NL@%
    Complex2String c, z$%@NL@%
    PRINT "ComplexExp", , z$%@NL@%
%@NL@%
    ComplexLog a, c%@NL@%
    Complex2String c, z$%@NL@%
    PRINT "ComplexLog", , z$%@NL@%
%@NL@%
    ComplexReciprocal a, c%@NL@%
    Complex2String c, z$%@NL@%
    PRINT "ComplexReciprocal", z$%@NL@%
%@NL@%
    ComplexSqr a, c%@NL@%
    Complex2String c, z$%@NL@%
    PRINT "ComplexSqr", , z$%@NL@%
%@NL@%
    PRINT%@NL@%
    INPUT "Enter second complex number "; y$%@NL@%
    String2Complex y$, b%@NL@%
    Complex2String b, y$%@NL@%
    PRINT y$%@NL@%
    PRINT%@NL@%
%@NL@%
    ComplexAdd a, b, c%@NL@%
    Complex2String c, z$%@NL@%
    PRINT "ComplexAdd", , z$%@NL@%
%@NL@%
    ComplexSub a, b, c%@NL@%
    Complex2String c, z$%@NL@%
    PRINT "ComplexSub", , z$%@NL@%
%@NL@%
    ComplexMul a, b, c%@NL@%
    Complex2String c, z$%@NL@%
    PRINT "ComplexMul", , z$%@NL@%
%@NL@%
    ComplexDiv a, b, c%@NL@%
    Complex2String c, z$%@NL@%
    PRINT "ComplexDiv", , z$%@NL@%
%@NL@%
    ComplexPower a, b, c%@NL@%
    Complex2String c, z$%@NL@%
    PRINT "ComplexPower", , z$%@NL@%
%@NL@%
    ComplexRoot a, b, c%@NL@%
    Complex2String c, z$%@NL@%
    PRINT "ComplexRoot", , z$%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Complex2String             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Makes a string representation of a complex number.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Complex2String a, x$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          Complex number variable (type Complex)%@AE@%%@NL@%
%@AB@%  '                  x$         String representation of the complex number%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       r$         Working string, real part%@AE@%%@NL@%
%@AB@%  '                  i$         Working string, imaginary part%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB Complex2String (a AS Complex, x$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Complex2String (a AS Complex, x$) STATIC%@NL@%
%@NL@%
%@AB@%      ' Form the left part of the string%@AE@%%@NL@%
        IF a.r < 0 THEN%@NL@%
            r$ = "(" + STR$(a.r)%@NL@%
        ELSE%@NL@%
            r$ = "(" + MID$(STR$(a.r), 2)%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Form the right part of the string%@AE@%%@NL@%
        IF a.i < 0 THEN%@NL@%
            i$ = STR$(a.i)%@NL@%
        ELSE%@NL@%
            i$ = "+" + MID$(STR$(a.i), 2)%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' The whole is more complex than the sum of the parts%@AE@%%@NL@%
        x$ = r$ + i$ + "i)"%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ComplexAdd                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Adds two complex numbers.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ComplexAdd a, b, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          First complex number for the addition%@AE@%%@NL@%
%@AB@%  '                  b          Second complex number for the addition%@AE@%%@NL@%
%@AB@%  '                  c          Result of the complex number addition%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '         DECLARE SUB ComplexAdd (a AS Complex, b AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ComplexAdd (a AS Complex, b AS Complex, c AS Complex) STATIC%@NL@%
        c.r = a.r + b.r%@NL@%
        c.i = a.i + b.i%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ComplexDiv                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Divides two complex numbers.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ComplexDiv a, b, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          First complex number for the division%@AE@%%@NL@%
%@AB@%  '                  b          Second complex number for the division%@AE@%%@NL@%
%@AB@%  '                  c          Result of the complex number division a/b%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '        DECLARE SUB ComplexDiv (a AS Complex, b AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ComplexDiv (a AS Complex, b AS Complex, c AS Complex) STATIC%@NL@%
        t! = b.r * b.r + b.i * b.i%@NL@%
        c.r = (a.r * b.r + a.i * b.i) / t!%@NL@%
        c.i = (a.i * b.r - a.r * b.i) / t!%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ComplexExp                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Calculates the exponential function of a complex number.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ComplexExp a, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          Complex number argument%@AE@%%@NL@%
%@AB@%  '                  c          Complex result of the calculations%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       t!         Temporary working value%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB ComplexExp (a AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ComplexExp (a AS Complex, c AS Complex) STATIC%@NL@%
        t! = EXP(a.r)%@NL@%
        c.r = t! * COS(a.i)%@NL@%
        c.i = t! * SIN(a.i)%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ComplexLog                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Calculates the log of a complex number.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ComplexLog a, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          Complex number argument%@AE@%%@NL@%
%@AB@%  '                  c          Complex result of the calculations%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       r!         Magnitude of complex number a%@AE@%%@NL@%
%@AB@%  '                  theta!     Angle of complex number a%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB ComplexLog (a AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB Rec2pol (x!, y!, r!, theta!)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ComplexLog (a AS Complex, c AS Complex) STATIC%@NL@%
        CALL Rec2pol(a.r, a.i, r!, theta!)%@NL@%
        IF r! <> 0! THEN%@NL@%
            c.r = LOG(r!)%@NL@%
            c.i = theta!%@NL@%
        ELSE%@NL@%
            ERROR 5%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ComplexMul                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Multiplies two complex numbers.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ComplexMul a, b, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          First complex number for the multiplication%@AE@%%@NL@%
%@AB@%  '                  b          Second complex number for the multiplication%@AE@%%@NL@%
%@AB@%  '                  c          Result of the complex number multiplication%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '         DECLARE SUB ComplexMul (a AS Complex, b AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ComplexMul (a AS Complex, b AS Complex, c AS Complex) STATIC%@NL@%
        c.r = a.r * b.r - a.i * b.i%@NL@%
        c.i = a.r * b.i + a.i * b.r%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ComplexPower               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Calculates a complex number raised to a complex number.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ComplexPower a, b, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          Complex number to be raised to a power%@AE@%%@NL@%
%@AB@%  '                  b          Complex number to raise a to%@AE@%%@NL@%
%@AB@%  '                  c          Result of a raised to the power of b%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       t1         Structure of type Complex%@AE@%%@NL@%
%@AB@%  '                  t2         Structure of type Complex%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB ComplexPower (a AS Complex, b AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB ComplexExp (a AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB ComplexLog (a AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB ComplexMul (a AS Complex, b AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ComplexPower (a AS Complex, b AS Complex, c AS Complex) STATIC%@NL@%
        DIM t1 AS Complex, t2 AS Complex%@NL@%
        IF a.r <> 0! OR a.i <> 0! THEN%@NL@%
            CALL ComplexLog(a, t1)%@NL@%
            CALL ComplexMul(t1, b, t2)%@NL@%
            CALL ComplexExp(t2, c)%@NL@%
        ELSE%@NL@%
            ERROR 5%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ComplexReciprocal          **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Calculates the reciprocal of a complex number.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ComplexReciprocal a, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          Complex number to be processed%@AE@%%@NL@%
%@AB@%  '                  c          Result of calculating 1/a%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       t          Structure of type Complex%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '         DECLARE SUB ComplexReciprocal (a AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '         DECLARE SUB ComplexDiv (a AS Complex, b AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ComplexReciprocal (a AS Complex, c AS Complex) STATIC%@NL@%
        DIM t AS Complex%@NL@%
        t.r = 1!%@NL@%
        t.i = 0%@NL@%
        ComplexDiv t, a, c%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ComplexRoot                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Calculates the complex root of a complex number.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ComplexRoot a, b, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          First complex number%@AE@%%@NL@%
%@AB@%  '                  b          Complex number root%@AE@%%@NL@%
%@AB@%  '                  c          Result of finding the bth root of a%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       t          Structure of type Complex%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '       DECLARE SUB ComplexRoot (a AS Complex, b AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '       DECLARE SUB ComplexReciprocal (a AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '       DECLARE SUB ComplexPower (a AS Complex, b AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ComplexRoot (a AS Complex, b AS Complex, c AS Complex) STATIC%@NL@%
        DIM t AS Complex%@NL@%
        IF b.r <> 0! OR b.i <> 0! THEN%@NL@%
            CALL ComplexReciprocal(b, t)%@NL@%
            CALL ComplexPower(a, t, c)%@NL@%
        ELSE%@NL@%
            ERROR 5%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ComplexSqr                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Calculates the square root of a complex number.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  'EXAMPLE OF USE:   ComplexSqr a, c%@AE@%%@NL@%
%@AB@%  'PARAMETERS:       a          Complex number argument%@AE@%%@NL@%
%@AB@%  '                  c          Result of finding the square root of a%@AE@%%@NL@%
%@AB@%  'VARIABLES:        r!         Magnitude of complex number a%@AE@%%@NL@%
%@AB@%  '                  theta!     Angle of complex number a%@AE@%%@NL@%
%@AB@%  '                  rs!        Square root of r!%@AE@%%@NL@%
%@AB@%  '                  h!         One half of theta!%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  'MODULE LEVEL%@AE@%%@NL@%
%@AB@%  ' DECLARATIONS:    TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB ComplexSqr (a AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ComplexSqr (a AS Complex, c AS Complex) STATIC%@NL@%
        CALL Rec2pol(a.r, a.i, r!, theta!)%@NL@%
        rs! = SQR(r!)%@NL@%
        h! = theta! / 2!%@NL@%
        c.r = rs! * COS(h!)%@NL@%
        c.i = rs! * SIN(h!)%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ComplexSub                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Subtracts two complex numbers.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ComplexSub a, b, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          First complex number%@AE@%%@NL@%
%@AB@%  '                  b          Second Complex number%@AE@%%@NL@%
%@AB@%  '                  c          Result of subtracting b from a%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '         DECLARE SUB ComplexSub (a AS Complex, b AS Complex, c AS Complex)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ComplexSub (a AS Complex, b AS Complex, c AS Complex) STATIC%@NL@%
        c.r = a.r - b.r%@NL@%
        c.i = a.i - b.i%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          String2Complex             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        COMPLEX.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Converts a string representation of a complex%@AE@%%@NL@%
%@AB@%  ' number to a type Complex variable.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  String2Complex x$, a%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x$         String representation of a complex number%@AE@%%@NL@%
%@AB@%  '                  a          Complex number structure of type Complex%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       j%         Index to first numerical character%@AE@%%@NL@%
%@AB@%  '                  i%         Pointer to the "i" or "j" character%@AE@%%@NL@%
%@AB@%  '                  k%         Pointer to start of imaginary part%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Complex%@AE@%%@NL@%
%@AB@%  '                     r AS SINGLE%@AE@%%@NL@%
%@AB@%  '                     i AS SINGLE%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB Complex2String (a AS Complex, x$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB String2Complex (x$, a AS Complex) STATIC%@NL@%
%@NL@%
%@AB@%      ' Real part starts just after left parenthesis%@AE@%%@NL@%
        j% = INSTR(x$, "(") + 1%@NL@%
%@NL@%
%@AB@%      ' Step forward to find start of number%@AE@%%@NL@%
        DO UNTIL INSTR("+-0123456789", MID$(x$, j%, 1)) OR j% > LEN(x$)%@NL@%
            j% = j% + 1%@NL@%
        LOOP%@NL@%
%@NL@%
%@AB@%      ' Imaginary part ends at the "i" or "j"%@AE@%%@NL@%
        i% = INSTR(LCASE$(x$), "i")%@NL@%
        IF INSTR(LCASE$(x$), "j") > i% THEN%@NL@%
            i% = INSTR(LCASE$(x$), "j")%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Step back to find start of imaginary part%@AE@%%@NL@%
        FOR k% = i% TO 1 STEP -1%@NL@%
            IF INSTR("+-", MID$(x$, k%, 1)) THEN%@NL@%
                EXIT FOR%@NL@%
            END IF%@NL@%
        NEXT k%%@NL@%
%@NL@%
%@AB@%      ' Error if pointers don't make sense%@AE@%%@NL@%
        IF j% = 0 OR j% > LEN(x$) THEN%@NL@%
            PRINT "Error: String2Complex - unrecognizable string format"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Grab the real part%@AE@%%@NL@%
        a.r = VAL(MID$(x$, j%))%@NL@%
%@NL@%
%@AB@%      ' Grab the imaginary part%@AE@%%@NL@%
        IF k% > j% THEN%@NL@%
            a.i = VAL(MID$(x$, k%))%@NL@%
        ELSEIF k% = j% THEN%@NL@%
            a.r = 0%@NL@%
            a.i = VAL(MID$(x$, j%))%@NL@%
        ELSE%@NL@%
            a.i = 0%@NL@%
        END IF%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CRLF.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\CRLF.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z              ' Default variable type is integer%@NL@%
%@NL@%
%@AB@%' The Backup$ FUNCTION makes a backup file with%@AE@%%@NL@%
%@AB@%' the same base as FileName$, plus a .BAK extension:%@AE@%%@NL@%
DECLARE FUNCTION Backup$ (FileName$)%@NL@%
%@NL@%
%@AB@%' Initialize symbolic constants and variables:%@AE@%%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE%@NL@%
%@NL@%
CarReturn$ = CHR$(13)%@NL@%
LineFeed$ = CHR$(10)%@NL@%
%@NL@%
DO%@NL@%
   CLS%@NL@%
%@NL@%
%@AB@%   ' Get the name of the file to change:%@AE@%%@NL@%
   INPUT "Which file do you want to convert"; OutFile$%@NL@%
%@NL@%
   InFile$ = Backup$(OutFile$)  ' Get the backup file's name.%@NL@%
%@NL@%
   ON ERROR GOTO ErrorHandler   ' Turn on error trapping.%@NL@%
%@NL@%
   NAME OutFile$ AS InFile$     ' Copy the input file to the%@NL@%
%@AB@%                                ' backup file.%@AE@%%@NL@%
%@NL@%
   ON ERROR GOTO 0              ' Turn off error trapping.%@NL@%
%@NL@%
%@AB@%   ' Open the backup file for input and the old file%@AE@%%@NL@%
%@AB@%   ' for output:%@AE@%%@NL@%
   OPEN InFile$ FOR INPUT AS #1%@NL@%
   OPEN OutFile$ FOR OUTPUT AS #2%@NL@%
%@NL@%
%@AB@%   ' The PrevCarReturn variable is a flag that is set to TRUE%@AE@%%@NL@%
%@AB@%   ' whenever the program reads a carriage-return character:%@AE@%%@NL@%
   PrevCarReturn = FALSE%@NL@%
%@NL@%
%@AB@%   ' Read from the input file until reaching%@AE@%%@NL@%
%@AB@%   ' the end of the file:%@AE@%%@NL@%
   DO UNTIL EOF(1)%@NL@%
%@NL@%
%@AB@%      ' Not the end of the file, so read a character:%@AE@%%@NL@%
      FileChar$ = INPUT$(1, #1)%@NL@%
%@NL@%
      SELECT CASE FileChar$%@NL@%
%@NL@%
         CASE CarReturn$        ' The character is a CR.%@NL@%
%@NL@%
%@AB@%            ' If the previous character was also a%@AE@%%@NL@%
%@AB@%            ' CR, put a LF before the character:%@AE@%%@NL@%
            IF PrevCarReturn THEN%@NL@%
                FileChar$ = LineFeed$ + FileChar$%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%            ' In any case, set the PrevCarReturn%@AE@%%@NL@%
%@AB@%            ' variable to TRUE:%@AE@%%@NL@%
            PrevCarReturn = TRUE%@NL@%
%@NL@%
         CASE LineFeed$         ' The character is a LF.%@NL@%
%@NL@%
%@AB@%            ' If the previous character was not a%@AE@%%@NL@%
%@AB@%            ' CR, put a CR before the character:%@AE@%%@NL@%
            IF NOT PrevCarReturn THEN%@NL@%
                FileChar$ = CarReturn$ + FileChar$%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%            ' In any case, set the PrevCarReturn%@AE@%%@NL@%
%@AB@%            ' variable to FALSE:%@AE@%%@NL@%
            PrevCarReturn = FALSE%@NL@%
%@NL@%
         CASE ELSE              ' Neither a CR nor a LF.%@NL@%
%@NL@%
%@AB@%            ' If the previous character was a CR,%@AE@%%@NL@%
%@AB@%            ' set the PrevCarReturn variable to FALSE%@AE@%%@NL@%
%@AB@%            ' and put a LF before the current character:%@AE@%%@NL@%
            IF PrevCarReturn THEN%@NL@%
                PrevCarReturn = FALSE%@NL@%
                FileChar$ = LineFeed$ + FileChar$%@NL@%
            END IF%@NL@%
%@NL@%
      END SELECT%@NL@%
%@NL@%
%@AB@%      ' Write the character(s) to the new file:%@AE@%%@NL@%
      PRINT #2, FileChar$;%@NL@%
   LOOP%@NL@%
%@NL@%
%@AB@%   ' Write a LF if the last character in the file was a CR:%@AE@%%@NL@%
   IF PrevCarReturn THEN PRINT #2, LineFeed$;%@NL@%
%@NL@%
   CLOSE                        ' Close both files.%@NL@%
   PRINT "Another file (Y/N)?"  ' Prompt to continue.%@NL@%
%@NL@%
%@AB@%   ' Change the input to uppercase (capital letter):%@AE@%%@NL@%
   More$ = UCASE$(INPUT$(1))%@NL@%
%@NL@%
%@AB@%' Continue the program if the user entered a "y" or a "Y":%@AE@%%@NL@%
LOOP WHILE More$ = "Y"%@NL@%
END%@NL@%
%@NL@%
ErrorHandler:           ' Error-handling routine%@NL@%
   CONST NOFILE = 53, FILEEXISTS = 58%@NL@%
%@NL@%
%@AB@%   ' The ERR function returns the error code for last error:%@AE@%%@NL@%
   SELECT CASE ERR%@NL@%
      CASE NOFILE       ' Program couldn't find file with%@NL@%
%@AB@%                        ' input name.%@AE@%%@NL@%
         PRINT "No such file in current directory."%@NL@%
         INPUT "Enter new name: ", OutFile$%@NL@%
         InFile$ = Backup$(OutFile$)%@NL@%
         RESUME%@NL@%
      CASE FILEEXISTS   ' There is already a file named%@NL@%
%@AB@%                        ' <filename>.BAK in this directory:%@AE@%%@NL@%
%@AB@%                        ' remove it, then continue.%@AE@%%@NL@%
         KILL InFile$%@NL@%
         RESUME%@NL@%
      CASE ELSE         ' An unanticipated error occurred:%@NL@%
%@AB@%                        ' stop the program.%@AE@%%@NL@%
         ON ERROR GOTO 0%@NL@%
   END SELECT%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ========================= BACKUP$ ==========================%@AE@%%@NL@%
%@AB@%'   This procedure returns a file name that consists of the%@AE@%%@NL@%
%@AB@%'   base name of the input file (everything before the ".")%@AE@%%@NL@%
%@AB@%'   plus the extension ".BAK"%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION Backup$ (FileName$) STATIC%@NL@%
%@NL@%
%@AB@%   ' Look for a period:%@AE@%%@NL@%
   Extension = INSTR(FileName$, ".")%@NL@%
%@NL@%
%@AB@%   ' If there is a period, add .BAK to the base:%@AE@%%@NL@%
   IF Extension > 0 THEN%@NL@%
      Backup$ = LEFT$(FileName$, Extension - 1) + ".BAK"%@NL@%
%@NL@%
%@AB@%   ' Otherwise, add .BAK to the whole name:%@AE@%%@NL@%
   ELSE%@NL@%
      Backup$ = FileName$ + ".BAK"%@NL@%
   END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CTOOLS1.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\CTOOLS1.C%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<ctype.h> %@NL@%
%@AI@%#include %@AE@%<memory.h> %@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItAlnum%                  **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:   result% = IsItAlnum%(c%)                        %@NL@%
%@AB@%* PARAMETERS:       c%         ASCII character code                 %@NL@%
%@AB@%* VARIABLES:        (none)                                          %@NL@%
%@AB@%* MODULE LEVEL                                                      %@NL@%
%@AB@%*   DECLARATIONS:   #include <ctype.h>        */%@AE@%%@NL@%
 %@NL@%
%@NL@%
int isitalnum (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (isalnum(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItAlpha%                  **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:   result% = IsItAlpha%(c%)                        %@NL@%
%@AB@%* PARAMETERS:       c%         ASCII character code                 %@NL@%
%@AB@%* VARIABLES:        (none)                                      %@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:   #include <ctype.h>        */%@AE@%%@NL@%
 %@NL@%
%@NL@%
int isitalpha (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (isalpha(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItAscii%                  **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  result% = IsItAscii%(c%)%@NL@%
%@AB@%* PARAMETERS:      c%         ASCII character code%@NL@%
%@AB@%* VARIABLES:       (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:  #include <ctype.h>         */%@AE@%%@NL@%
 %@NL@%
%@NL@%
int isitascii (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (isascii(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItCntrl%                  **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:   result% = IsItCntrl%(c%)%@NL@%
%@AB@%* PARAMETERS:       c%         ASCII character code%@NL@%
%@AB@%* VARIABLES:        (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:   #include <ctype.h>        */%@AE@%%@NL@%
 %@NL@%
%@NL@%
int isitcntrl (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (iscntrl(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItDigit%                  **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  result% = IsItDigit%(c%)%@NL@%
%@AB@%* PARAMETERS:      c%         ASCII character code%@NL@%
%@AB@%* VARIABLES:       (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:  #include <ctype.h>         */%@AE@%%@NL@%
 %@NL@%
%@NL@%
int isitdigit (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (isdigit(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItGraph%                  **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  result% = IsItGraph%(c%)%@NL@%
%@AB@%* PARAMETERS:      c%         ASCII character code%@NL@%
%@AB@%* VARIABLES:       (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:  #include <ctype.h>         */%@AE@%%@NL@%
 %@NL@%
%@NL@%
int isitgraph (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (isgraph(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItLower%                  **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  result% = IsItLower%(c%)%@NL@%
%@AB@%* PARAMETERS:      c%         ASCII character code%@NL@%
%@AB@%* VARIABLES:       (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:  #include <ctype.h>         */%@AE@%%@NL@%
%@NL@%
%@NL@%
int isitlower (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (islower(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItPrint%                  **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  result% = IsItPrint%(c%)%@NL@%
%@AB@%* PARAMETERS:      c%         ASCII character code%@NL@%
%@AB@%* VARIABLES:       (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:  #include <ctype.h>         */%@AE@%%@NL@%
 %@NL@%
%@NL@%
int isitprint (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (isprint(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItPunct%                  **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  result% = IsItPunct%(c%)%@NL@%
%@AB@%* PARAMETERS:      c%         ASCII character code%@NL@%
%@AB@%* VARIABLES:       (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:  #include <ctype.h>         */%@AE@%%@NL@%
 %@NL@%
%@NL@%
int isitpunct (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (ispunct(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItSpace%                  **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  result% = IsItSpace%(c%)%@NL@%
%@AB@%* PARAMETERS:      c%         ASCII character code%@NL@%
%@AB@%* VARIABLES:       (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:  #include <ctype.h>         */%@AE@%%@NL@%
 %@NL@%
%@NL@%
int isitspace (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (isspace(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItUpper%                  **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:   result% = IsItUpper%(c%)%@NL@%
%@AB@%* PARAMETERS:       c%         ASCII character code%@NL@%
%@AB@%* VARIABLES:        (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:   #include <ctype.h>         */%@AE@%%@NL@%
 %@NL@%
int isitupper (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (isupper(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         IsItXDigit%                 **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  result% = IsItXDigit%(c%)%@NL@%
%@AB@%* PARAMETERS:      c%         ASCII character code%@NL@%
%@AB@%* VARIABLES:       (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:  #include <ctype.h>         */%@AE@%%@NL@%
 %@NL@%
%@NL@%
int isitxdigit (c)%@NL@%
int c;%@NL@%
    {%@NL@%
    return (isxdigit(c));%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         MovBytes                    **%@NL@%
%@AB@%**  Type:         Subprogram                  **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Moves bytes from a source segment and offset%@NL@%
%@AB@%*  location in memory to a destination segment and%@NL@%
%@AB@%*  offset location.%@NL@%
%@AB@%*%@NL@%
%@AB@%*  EXAMPLE OF USE:  MovBytes sseg%, soff%, dseg%, doff%, nbytes%%@NL@%
%@AB@%*  PARAMETERS:      sseg%      Source segment address of bytes to be moved%@NL@%
%@AB@%*                   soff%      Source offset address of bytes to be moved%@NL@%
%@AB@%*                   dseg%      Destination segment address of bytes to be moved%@NL@%
%@AB@%*                   doff%      Destination offset address of bytes to be moved%@NL@%
%@AB@%*                   nbytes%    Number of bytes to be moved%@NL@%
%@AB@%* VARIABLES:        (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:   #include <memory.h>     */%@AE@%%@NL@%
 %@NL@%
%@NL@%
void movbytes(srcseg, srcoff, destseg, destoff, nbytes)%@NL@%
unsigned int *srcseg, *srcoff, *destseg, *destoff, *nbytes;%@NL@%
    {%@NL@%
    movedata(*srcseg, *srcoff, *destseg, *destoff, *nbytes);%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         MovWords                    **%@NL@%
%@AB@%**  Type:         Subprogram                  **%@NL@%
%@AB@%**  Module:       CTOOLS1.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Moves words from a source segment and offset%@NL@%
%@AB@%*  location in memory to a destination segment and%@NL@%
%@AB@%*  offset location.%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  MovWords sseg%, soff%, dseg%, doff%, nbytes%%@NL@%
%@AB@%* PARAMETERS:      sseg%      Source segment address of words to be moved%@NL@%
%@AB@%*                  soff%      Source offset address of words to be moved%@NL@%
%@AB@%*                  dseg%      Destination segment address of words to be moved%@NL@%
%@AB@%*                  doff%      Destination offset address of words to be moved%@NL@%
%@AB@%*                  nwords%    Number of words to be moved%@NL@%
%@AB@%* VARIABLES:       (none)%@NL@%
%@AB@%* MODULE LEVEL%@NL@%
%@AB@%*   DECLARATIONS:  #include <memory.h>        */%@AE@%%@NL@%
 %@NL@%
%@NL@%
void movwords(srcseg, srcoff, destseg, destoff, nwords)%@NL@%
unsigned int *srcseg, *srcoff, *destseg, *destoff, *nwords;%@NL@%
    {%@NL@%
    unsigned int nbytes;%@NL@%
    %@NL@%
    nbytes = *nwords + *nwords;%@NL@%
    movedata(*srcseg, *srcoff, *destseg, *destoff, nbytes);%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CTOOLS2.C%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\CTOOLS2.C%@AE@%%@NL@%
%@NL@%
%@AI@%#include %@AE@%<ctype.h> %@NL@%
%@AI@%#include %@AE@%<conio.h> %@NL@%
%@NL@%
%@AI@%#define %@AE@%VIDEO_START         0xb8000000 %@NL@%
%@NL@%
%@AI@%#define %@AE@%BLACK_ON_CYAN       48 %@NL@%
%@AI@%#define %@AE@%RED_ON_CYAN         52 %@NL@%
%@AI@%#define %@AE@%BRIGHT_WHITE_ON_RED 79 %@NL@%
%@NL@%
%@AI@%#define %@AE@%ENTER               13 %@NL@%
%@AI@%#define %@AE@%RIGHT_ARROW         77 %@NL@%
%@AI@%#define %@AE@%LEFT_ARROW          75 %@NL@%
%@NL@%
%@AB@%/* Definition of the QuickBASIC string descriptor structure */%@AE@%%@NL@%
struct bas_str%@NL@%
    {%@NL@%
    int  sd_len;%@NL@%
    char *sd_addr;%@NL@%
    };%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         BitShiftLeft%               **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS2.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* Shifts all bits in a QuickBASIC string one bit%@NL@%
%@AB@%* to the left.  The leftmost bit is returned, and%@NL@%
%@AB@%* the rightmost bit is set to zero.%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  bit% = BitShiftLeft%(bit$)%@NL@%
%@AB@%* PARAMETERS:      bit$       String containing a bit pattern%@NL@%
%@AB@%* VARIABLES:       len        Length of the string (number of bytes)%@NL@%
%@AB@%*                  str        Pointer to string contents%@NL@%
%@AB@%*                  i          Looping index to each byte of the string%@NL@%
%@AB@%*                  carry      Bit carried over from byte to byte%@NL@%
%@AB@%*                  the_byte   Working copy of each byte of the string%@NL@%
%@AB@%*%@NL@%
%@AB@%* Definition of the QuickBASIC string descriptor structure%@NL@%
%@AB@%*    struct bas_str%@NL@%
%@AB@%*        {%@NL@%
%@AB@%*        int  sd_len;%@NL@%
%@AB@%*        char *sd_addr;%@NL@%
%@AB@%*        };                                    */%@AE@%%@NL@%
%@NL@%
%@NL@%
int bitshiftleft (basic_string)%@NL@%
struct bas_str *basic_string;%@NL@%
    {%@NL@%
    int len = basic_string->sd_len;%@NL@%
    unsigned char *str = basic_string->sd_addr;%@NL@%
    int i, carry;%@NL@%
    unsigned int the_byte;%@NL@%
   %@NL@%
    for (i=len-1, carry=0; i>=0; i--)%@NL@%
        {%@NL@%
        the_byte = *(str + i);%@NL@%
        *(str + i) = (the_byte << 1) + carry;%@NL@%
        carry = the_byte >> 7;%@NL@%
        }%@NL@%
   %@NL@%
    return (carry);%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         BitShiftRight%              **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS2.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* Shifts all bits in a QuickBASIC string one bit to%@NL@%
%@AB@%* the right.  The rightmost bit is returned, and the%@NL@%
%@AB@%* leftmost bit is set to zero.%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  bit% = BitShiftRight%(bit$)%@NL@%
%@AB@%* PARAMETERS:      bit$       String containing a bit pattern%@NL@%
%@AB@%* VARIABLES:       len        Length of the string (number of bytes)%@NL@%
%@AB@%*                  str        Pointer to string contents%@NL@%
%@AB@%*                  i          Looping index to each byte of the string%@NL@%
%@AB@%*                  carry      Bit carried over from byte to byte%@NL@%
%@AB@%*                  the_byte   Working copy of each byte of the string%@NL@%
%@AB@%*%@NL@%
%@AB@%* Definition of the QuickBASIC string descriptor structure%@NL@%
%@AB@%*    struct bas_str%@NL@%
%@AB@%*        {%@NL@%
%@AB@%*        int  sd_len;%@NL@%
%@AB@%*        char *sd_addr;%@NL@%
%@AB@%*        };                                             */%@AE@%%@NL@%
%@NL@%
%@NL@%
int bitshiftright (basic_string)%@NL@%
struct bas_str *basic_string;%@NL@%
    {%@NL@%
    int len = basic_string->sd_len;%@NL@%
    unsigned char *str = basic_string->sd_addr;%@NL@%
    int i, carry;%@NL@%
    unsigned int the_byte;%@NL@%
   %@NL@%
    for (i=0, carry=0; i<len; i++)%@NL@%
        {%@NL@%
        the_byte = *(str + i);%@NL@%
        *(str + i) = (the_byte >> 1) + carry;%@NL@%
        carry = (the_byte & 1) << 7;%@NL@%
        }%@NL@%
   %@NL@%
    if (carry)%@NL@%
        return(1);%@NL@%
    else%@NL@%
        return(0);%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         MenuString%                 **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS2.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Displays a horizontal bar menu and waits for a%@NL@%
%@AB@%*  response from the user.  Returns the number of%@NL@%
%@AB@%*  the word selected from the string. %@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  choice% = MenuString%(row%, col%, menu$)%@NL@%
%@AB@%* PARAMETERS:      row%       Row location to display the menu string%@NL@%
%@AB@%*                  col%       Column location to display the menu string%@NL@%
%@AB@%*                  menu$      String containing list of words representing%@NL@%
%@AB@%*                             choices%@NL@%
%@AB@%* VARIABLES:       len        Length of the menu string%@NL@%
%@AB@%*                  str        Pointer to string contents%@NL@%
%@AB@%*                  vidptr     Pointer to video memory%@NL@%
%@AB@%*                  attribute  Index into string%@NL@%
%@AB@%*                  character  Character from keyboard press%@NL@%
%@AB@%*                  both       Combination of a character and its attribute%@NL@%
%@AB@%*                  i          Looping index%@NL@%
%@AB@%*                  j          Looping index%@NL@%
%@AB@%*                  k          Looping index%@NL@%
%@AB@%*                  c          Looping index%@NL@%
%@AB@%*                  choice     Menu selection number%@NL@%
%@AB@%*                  wordnum    Sequential count of each word in the menu string%@NL@%
%@AB@%*                  refresh    Signals to redraw the menu string%@NL@%
%@AB@%* #include <ctype.h>%@NL@%
%@AB@%* #include <conio.h>%@NL@%
%@AB@%* #define VIDEO_START         0xb8000000%@NL@%
%@AB@%* #define BLACK_ON_CYAN       48%@NL@%
%@AB@%* #define RED_ON_CYAN         52%@NL@%
%@AB@%* #define BRIGHT_WHITE_ON_RED 79%@NL@%
%@AB@%* #define ENTER               13%@NL@%
%@AB@%* #define RIGHT_ARROW         77%@NL@%
%@AB@%* #define LEFT_ARROW          75%@NL@%
%@AB@%*%@NL@%
%@AB@%* Definition of the QuickBASIC string descriptor structure%@NL@%
%@AB@%*    struct bas_str%@NL@%
%@AB@%*        {%@NL@%
%@AB@%*        int  sd_len;%@NL@%
%@AB@%*        char *sd_addr;%@NL@%
%@AB@%*        };                                        */%@AE@%%@NL@%
%@NL@%
%@NL@%
int menustring (row, col, basic_string)%@NL@%
int *row, *col;%@NL@%
struct bas_str *basic_string;%@NL@%
    {%@NL@%
    int len;%@NL@%
    char * str;%@NL@%
    int far * vidptr;%@NL@%
    int attribute, character, both;%@NL@%
    int i, j, k, c;%@NL@%
    int choice, wordnum;%@NL@%
    int refresh;%@NL@%
    void packword();%@NL@%
%@NL@%
    %@AB@%/* Initialize variables */%@AE@%%@NL@%
    len = basic_string->sd_len;%@NL@%
    str = basic_string->sd_addr;%@NL@%
    vidptr = (int far *) VIDEO_START + (*row - 1) * 80 + (*col - 1);%@NL@%
    choice = 1;%@NL@%
    refresh = 1;%@NL@%
   %@NL@%
    %@AB@%/* Loop until return() statement */%@AE@%%@NL@%
    while (1)%@NL@%
        {%@NL@%
       %@NL@%
        %@AB@%/* Display the string only if refresh is non-zero */%@AE@%%@NL@%
        if (refresh)%@NL@%
            {%@NL@%
            refresh = 0;%@NL@%
           %@NL@%
            %@AB@%/* Loop through each character of the string */%@AE@%%@NL@%
            for (wordnum = 0, i=0; i<len; i++)%@NL@%
                {%@NL@%
               %@NL@%
                %@AB@%/* Set the character and default attribute */%@AE@%%@NL@%
                character = str[i];%@NL@%
                attribute = BLACK_ON_CYAN;%@NL@%
               %@NL@%
                %@AB@%/* Uppercase? */%@AE@%%@NL@%
                if (isupper(character))%@NL@%
                    {%@NL@%
                    wordnum++;%@NL@%
                    attribute = RED_ON_CYAN;%@NL@%
                    }%@NL@%
               %@NL@%
                %@AB@%/* In the middle of the current selection? */%@AE@%%@NL@%
                if (wordnum == choice && character != ' ')%@NL@%
                    attribute = BRIGHT_WHITE_ON_RED;%@NL@%
               %@NL@%
                %@AB@%/* Move data to video */%@AE@%%@NL@%
                packword(&both, &attribute, &character);%@NL@%
                vidptr[i] = both;%@NL@%
                }%@NL@%
            }%@NL@%
       %@NL@%
        %@AB@%/* Check for any key presses */%@AE@%%@NL@%
        if (kbhit())%@NL@%
            {%@NL@%
           %@NL@%
            %@AB@%/* Get the key code and process it */%@AE@%%@NL@%
            switch (c = getch())%@NL@%
                {%@NL@%
               %@NL@%
                %@AB@%/* Return the choice when Enter is pressed */%@AE@%%@NL@%
                case ENTER:%@NL@%
                    return (choice);%@NL@%
               %@NL@%
                %@AB@%/* Highlight next choice if Right arrow is pressed */%@AE@%%@NL@%
                case RIGHT_ARROW:%@NL@%
                    if (choice < wordnum)%@NL@%
                        {%@NL@%
                        choice++;%@NL@%
                        refresh = 1;%@NL@%
                        }%@NL@%
                    break;%@NL@%
               %@NL@%
                %@AB@%/* Highlight previous choice if Left arrow is pressed */%@AE@%%@NL@%
                case LEFT_ARROW:%@NL@%
                    if (choice > 1)%@NL@%
                        {%@NL@%
                        choice--;%@NL@%
                        refresh = 1;%@NL@%
                        }%@NL@%
                    break;%@NL@%
               %@NL@%
                %@AB@%/* Check for match on first character of each word */%@AE@%%@NL@%
                default:%@NL@%
                    c = _toupper(c);%@NL@%
                    for (k=0, j=0; j<len; j++)%@NL@%
                        {%@NL@%
                       %@NL@%
                        %@AB@%/* Each choice starts at an uppercase char */%@AE@%%@NL@%
                        if (isupper(str[j]))%@NL@%
                            k++;%@NL@%
                   %@NL@%
                        %@AB@%/* Match if same char and not current choice */%@AE@%%@NL@%
                        if (str[j] == c && k != choice)%@NL@%
                            {%@NL@%
                            choice = k;%@NL@%
                            refresh = 1;%@NL@%
                            break;%@NL@%
                            }%@NL@%
                        }%@NL@%
                    break;%@NL@%
                }%@NL@%
            }%@NL@%
        }%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         NumberOfBits&               **%@NL@%
%@AB@%**  Type:         Function                    **%@NL@%
%@AB@%**  Module:       CTOOLS2.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* Counts the 1 bits in a QuickBASIC string.%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  count& = NumberOfBits&(a$)%@NL@%
%@AB@%* PARAMETERS:      a$         String containing bits to be counted%@NL@%
%@AB@%* VARIABLES:       len        Length of the string%@NL@%
%@AB@%*                  str        Pointer to string contents%@NL@%
%@AB@%*                  i          Looping index to each byte%@NL@%
%@AB@%*                  the_byte   Working copy of each byte of the string%@NL@%
%@AB@%*                  count      Count of the bits%@NL@%
%@AB@%*%@NL@%
%@AB@%* Definition of the QuickBASIC string descriptor structure%@NL@%
%@AB@%*    struct bas_str%@NL@%
%@AB@%*        {%@NL@%
%@AB@%*        int  sd_len;%@NL@%
%@AB@%*        char *sd_addr;%@NL@%
%@AB@%*        };                                           */%@AE@%%@NL@%
%@NL@%
%@NL@%
long numberofbits (basic_string)%@NL@%
struct bas_str *basic_string;%@NL@%
    {%@NL@%
    int len = basic_string->sd_len;%@NL@%
    unsigned char *str = basic_string->sd_addr;%@NL@%
    int i,the_byte;%@NL@%
    long count = 0;%@NL@%
%@NL@%
    for (i=0; i<len; i++)%@NL@%
        {%@NL@%
        the_byte = *(str+i);%@NL@%
        while (the_byte)%@NL@%
            {%@NL@%
            count += (the_byte & 1);%@NL@%
            the_byte >>= 1;%@NL@%
            }%@NL@%
        }%@NL@%
    return (count);%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         PackWord                    **%@NL@%
%@AB@%**  Type:         Subprogram                  **%@NL@%
%@AB@%**  Module:       CTOOLS2.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Packs two byte values into the high and low%@NL@%
%@AB@%*  bytes of an integer (word).%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  PackWord hiloword%, hibyte%, lobyte%%@NL@%
%@AB@%* PARAMETERS:      hiloword%  Integer word to pack the two bytes into%@NL@%
%@AB@%*                  hibyte%    Integer value of the most significant byte%@NL@%
%@AB@%*                  lobyte%    Integer value of the least significant byte%@NL@%
%@AB@%* VARIABLES:       both       A union of a two-byte structure and an integer *  %@NL@%
%@AB@%*                             variable                                */%@AE@%%@NL@%
%@NL@%
%@NL@%
void packword (hiloword, hibyte, lobyte)%@NL@%
int *hiloword, *hibyte, *lobyte;%@NL@%
    {%@NL@%
    union%@NL@%
        {%@NL@%
        struct%@NL@%
            {%@NL@%
            unsigned char lo;%@NL@%
            unsigned char hi;%@NL@%
            } bytes;%@NL@%
        int hilo;%@NL@%
        } both;%@NL@%
   %@NL@%
    both.bytes.hi = *hibyte;%@NL@%
    both.bytes.lo = *lobyte;%@NL@%
    *hiloword = both.hilo;%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         TextGet                     **%@NL@%
%@AB@%**  Type:         Subprogram                  **%@NL@%
%@AB@%**  Module:       CTOOLS2.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* Saves characters and attributes from a rectangular%@NL@%
%@AB@%* area of the screen.%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  TextGet r1%, c1%, r2%, c2%, a$%@NL@%
%@AB@%* PARAMETERS:      r1%        Pointer to row at upper left corner%@NL@%
%@AB@%*                  c1%        Pointer to column at upper left corner%@NL@%
%@AB@%*                  r2%        Pointer to row at lower right corner%@NL@%
%@AB@%*                  c2%        Pointer to column at lower right corner%@NL@%
%@AB@%*                  a$         String descriptor, where screen contents%@NL@%
%@AB@%*                             will be stored%@NL@%
%@AB@%* VARIABLES:       len        Length of string%@NL@%
%@AB@%*                  str        Pointer to string contents%@NL@%
%@AB@%*                  video      Pointer to video memory%@NL@%
%@AB@%*                  i          Index into string%@NL@%
%@AB@%*                  row        Looping index%@NL@%
%@AB@%*                  col        Looping index%@NL@%
%@AB@%* #define VIDEO_START         0xb8000000%@NL@%
%@AB@%*%@NL@%
%@AB@%* Definition of the QuickBASIC string descriptor structure%@NL@%
%@AB@%*%@NL@%
%@AB@%*  struct bas_str%@NL@%
%@AB@%*      {%@NL@%
%@AB@%*      int  sd_len;%@NL@%
%@AB@%*      char *sd_addr;%@NL@%
%@AB@%*      };                                           */%@AE@%%@NL@%
%@NL@%
%@NL@%
void textget (r1,c1,r2,c2,basic_string)%@NL@%
int *r1,*c1,*r2,*c2;%@NL@%
struct bas_str *basic_string;%@NL@%
    {%@NL@%
    int len;%@NL@%
    int * str;%@NL@%
    int far * video;%@NL@%
    int i,row,col;%@NL@%
   %@NL@%
    len = basic_string->sd_len;%@NL@%
    str = (int *) basic_string->sd_addr;%@NL@%
    video = (int far *) VIDEO_START;%@NL@%
   %@NL@%
    if (len == (*r2 - *r1 + 1) * (*c2 - *c1 + 1) * 2)%@NL@%
        for (row = *r1 - 1, i = 0; row < *r2; row++)%@NL@%
            for (col = *c1 - 1; col < *c2; col++)%@NL@%
                str[i++] = video[row * 80 + col];%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         TextPut                     **%@NL@%
%@AB@%**  Type:         Subprogram                  **%@NL@%
%@AB@%**  Module:       CTOOLS2.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%* Restores characters and attributes to a rectangular%@NL@%
%@AB@%* area of the screen.%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  TextPut r1%, c1%, r2%, c2%, a$%@NL@%
%@AB@%* PARAMETERS:      r1%        Pointer to row at upper left corner%@NL@%
%@AB@%*                  c1%        Pointer to column at upper left corner%@NL@%
%@AB@%*                  r2%        Pointer to row at lower right corner%@NL@%
%@AB@%*                  c2%        Pointer to column at lower right corner%@NL@%
%@AB@%*                  a$         String descriptor where screen contents are stored%@NL@%
%@AB@%* VARIABLES:       len        Length of string%@NL@%
%@AB@%*                  str        Pointer to string contents%@NL@%
%@AB@%*                  video      Pointer to video memory%@NL@%
%@AB@%*                  i          Index into string%@NL@%
%@AB@%*                  row        Looping index%@NL@%
%@AB@%*                  col        Looping index%@NL@%
%@AB@%* #define VIDEO_START         0xb8000000%@NL@%
%@AB@%*%@NL@%
%@AB@%* Definition of the QuickBASIC string descriptor structure%@NL@%
%@AB@%*    struct bas_str%@NL@%
%@AB@%*        {%@NL@%
%@AB@%*        int  sd_len;%@NL@%
%@AB@%*        char *sd_addr;%@NL@%
%@AB@%*        };                                        */%@AE@%%@NL@%
%@NL@%
%@NL@%
void textput (r1,c1,r2,c2,basic_string)%@NL@%
int *r1,*c1,*r2,*c2;%@NL@%
struct bas_str *basic_string;%@NL@%
    {%@NL@%
    int len;%@NL@%
    int * str;%@NL@%
    int far * video;%@NL@%
    int i,row,col;%@NL@%
   %@NL@%
    len = basic_string->sd_len;%@NL@%
    str = (int *) basic_string->sd_addr;%@NL@%
    video = (int far *) VIDEO_START;%@NL@%
   %@NL@%
    if (len == (*r2 - *r1 + 1) * (*c2 - *c1 + 1) * 2)%@NL@%
        for (row = *r1 - 1, i = 0; row < *r2; row++)%@NL@%
            for (col = *c1 - 1; col < *c2; col++)%@NL@%
                video[row * 80 + col] = str[i++];%@NL@%
    }%@NL@%
%@NL@%
%@AB@%/***********************************************%@NL@%
%@AB@%**  Name:         UnPackWord                  **%@NL@%
%@AB@%**  Type:         Subprogram                  **%@NL@%
%@AB@%**  Module:       CTOOLS2.C                   **%@NL@%
%@AB@%**  Language:     Microsoft QuickC/QuickBASIC **%@NL@%
%@AB@%************************************************%@NL@%
%@AB@%*%@NL@%
%@AB@%*  Unpacks two byte values from the high and low%@NL@%
%@AB@%*  bytes of an integer (word).%@NL@%
%@AB@%*%@NL@%
%@AB@%* EXAMPLE OF USE:  UnPackWord hiloword%, hibyte%, lobyte%%@NL@%
%@AB@%* PARAMETERS:      hiloword%  Integer word containing the two bytes%@NL@%
%@AB@%*                  hibyte%    Integer value of the most significant byte%@NL@%
%@AB@%*                  lobyte%    Integer value of the least significant byte%@NL@%
%@AB@%* VARIABLES:       both       A union of a two-byte structure and an integer%@NL@%
%@AB@%*                             variable                               */%@AE@%%@NL@%
%@NL@%
%@NL@%
void unpackword (hiloword, hibyte, lobyte)%@NL@%
int *hiloword, *hibyte, *lobyte;%@NL@%
    {%@NL@%
    union%@NL@%
        {%@NL@%
        struct%@NL@%
            {%@NL@%
            unsigned char lo;%@NL@%
            unsigned char hi;%@NL@%
            } bytes;%@NL@%
        int hilo;%@NL@%
        } both;%@NL@%
   %@NL@%
    both.hilo = *hiloword;%@NL@%
    *hibyte = both.bytes.hi;%@NL@%
    *lobyte = both.bytes.lo;%@NL@%
    }%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%CUBE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\CUBE.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' The macro string to draw the cube and paint its sides:%@AE@%%@NL@%
Plot$ = "BR30 BU25 C1 R54 U45 L54 D45 BE20 P1,1 G20 C2 G20" + "R54 E20 L54 BD5 P2,2 U5 C4 G20 U45 E20 D45 BL5 P4,4"%@NL@%
%@NL@%
APage% = 1      ' Initialize values for the active and visual%@NL@%
VPage% = 0      ' pages, as well as the angle of rotation.%@NL@%
Angle% = 0%@NL@%
%@NL@%
DO%@NL@%
%@NL@%
%@AB@%   ' Draw to the active page while showing%@AE@%%@NL@%
%@AB@%   ' the visual page:%@AE@%%@NL@%
   SCREEN 7, , APage%, VPage%%@NL@%
   CLS 1%@NL@%
%@NL@%
%@AB@%   ' Rotate the cube "Angle%" degrees:%@AE@%%@NL@%
   DRAW "TA" + STR$(Angle%) + Plot$%@NL@%
%@NL@%
%@AB@%   ' Angle% is some multiple of 15 degrees:%@AE@%%@NL@%
   Angle% = (Angle% + 15) MOD 360%@NL@%
%@NL@%
%@AB@%   ' Switch the active and visual pages:%@AE@%%@NL@%
   SWAP APage%, VPage%%@NL@%
%@NL@%
LOOP WHILE INKEY$ = ""     ' A key press ends the program.%@NL@%
%@NL@%
END%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DOLLARS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\DOLLARS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DOLLARS                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOLLARS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:         No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:     (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:    (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:     n#         Number for demonstration of the functions%@AE@%%@NL@%
%@NL@%
    DECLARE FUNCTION Comma$ (n#)%@NL@%
    DECLARE FUNCTION DollarString$ (amount#, length%)%@NL@%
    DECLARE FUNCTION Round# (n#, place%)%@NL@%
%@NL@%
    CLS%@NL@%
    n# = 1234567.76543#%@NL@%
    PRINT "Number n#:", , n#%@NL@%
    PRINT "Comma$(n#)", , Comma$(n#)%@NL@%
    PRINT "Comma$(Round#(n#, -2))", Comma$(Round#(n#, -2))%@NL@%
    PRINT%@NL@%
    PRINT "DollarString$(n#, 20)", ":"; DollarString$(n#, 20); ":"%@NL@%
    PRINT , , " 12345678901234567890"%@NL@%
    PRINT%@NL@%
%@NL@%
    PRINT "Round#(n#, -3)", Round#(n#, -3)%@NL@%
    PRINT "Round#(n#, -2)", Round#(n#, -2)%@NL@%
    PRINT "Round#(n#, -1)", Round#(n#, -1)%@NL@%
    PRINT "Round#(n#, 0)", , Round#(n#, 0)%@NL@%
    PRINT "Round#(n#, 1)", , Round#(n#, 1)%@NL@%
    PRINT "Round#(n#, 2)", , Round#(n#, 2)%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Comma$                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOLLARS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Creates a string representing a double-precision%@AE@%%@NL@%
%@AB@%  ' number, with commas inserted every three digits.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:    n$  =  Comma$(n#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:        n#     Number to be formatted%@AE@%%@NL@%
%@AB@%  ' VARIABLES:         tn$    Temporary string of the number%@AE@%%@NL@%
%@AB@%  '                    dp%    Position of the decimal point%@AE@%%@NL@%
%@AB@%  '                    i%     Index into tn$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:           DECLARE FUNCTION Comma$ (n#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Comma$ (n#) STATIC%@NL@%
        tn$ = STR$(n#)%@NL@%
        dp% = INSTR(tn$, ".")%@NL@%
        IF dp% = 0 THEN%@NL@%
            dp% = LEN(tn$) + 1%@NL@%
        END IF%@NL@%
        IF dp% > 4 THEN%@NL@%
            FOR i% = dp% - 3 TO 3 STEP -3%@NL@%
                tn$ = LEFT$(tn$, i% - 1) + "," + MID$(tn$, i%)%@NL@%
            NEXT i%%@NL@%
        END IF%@NL@%
        Comma$ = LTRIM$(tn$)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DollarString$              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOLLARS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a string representation of a dollar amount,%@AE@%%@NL@%
%@AB@%  ' rounded to the nearest cent, with commas separating%@AE@%%@NL@%
%@AB@%  ' groups of three digits, and with a preceding dollar sign.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:    d$ = DollarString$(dollars#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:        dollars#   Amount of money%@AE@%%@NL@%
%@AB@%  ' VARIABLES:         tmp$       Temporary working string%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:    DECLARE FUNCTION Comma$ (n#)%@AE@%%@NL@%
%@AB@%  '                    DECLARE FUNCTION DollarString$ (amount#, length%)%@AE@%%@NL@%
%@AB@%  '                    DECLARE FUNCTION Round# (n#, place%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION DollarString$ (amount#, length%) STATIC%@NL@%
        tmp$ = SPACE$(length%) + "$" + Comma$(Round#(amount#, -2))%@NL@%
        DollarString$ = RIGHT$(tmp$, length%)%@NL@%
        tmp$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Round#                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOLLARS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Rounds a number at the power of 10 decimal place.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  x# = Round#(n#, place%)%@AE@%%@NL@%
%@AB@%  ' EXAMPLES:        Round#(12.3456#, -2) = 12.35#%@AE@%%@NL@%
%@AB@%  '                  Round#(12.3456#, -1) = 12.3#%@AE@%%@NL@%
%@AB@%  '                  Round#(12.3456#, 0)  = 12#%@AE@%%@NL@%
%@AB@%  '                  Round#(12.3456#, 1)  = 10#%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      n#         Number to be rounded%@AE@%%@NL@%
%@AB@%  '                  place%     Power of 10 for rounding the number%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       pTen#      10 raised to the indicated power of 10%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:             DECLARE FUNCTION Round# (n#, place%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Round# (n#, powerOfTen%) STATIC%@NL@%
        pTen# = 10# ^ powerOfTen%%@NL@%
        Round# = INT(n# / pTen# + .5#) * pTen#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%DOSCALLS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\DOSCALLS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DOSCALLS                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Demonstrates several interrupt calls to MS-DOS.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:          No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:   MS-DOS 3.0 or later%@AE@%%@NL@%
%@AB@%  '                 MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  '.MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:     (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      buffer$    String for buffered input demonstration%@AE@%%@NL@%
%@AB@%  '                 x$         Buffered input string%@AE@%%@NL@%
%@AB@%  '                 drive$     Current disk drive name%@AE@%%@NL@%
%@AB@%  '                 desc       Structure of type MediaDescriptorType%@AE@%%@NL@%
%@AB@%  '                 state%     Current status of the Verify state%@AE@%%@NL@%
%@AB@%  '                 oppositeState%   Opposite state for Verify%@AE@%%@NL@%
%@AB@%  '                 disk       Structure of type DiskFreeSpaceType%@AE@%%@NL@%
%@AB@%  '                 country    Structure of type CountryType%@AE@%%@NL@%
%@AB@%  '                 i%         Loop index for creating translation characters%@AE@%%@NL@%
%@AB@%  '                 a$         Characters to be translated%@AE@%%@NL@%
%@AB@%  '                 path$      Current directory%@AE@%%@NL@%
%@AB@%  '                 result%    Result code from call to SetDirectory%@AE@%%@NL@%
%@AB@%  '                 t$         Temporary copy of TIME$%@AE@%%@NL@%
%@AB@%  '                 attr       Structure of type FileAttributesType%@AE@%%@NL@%
%@AB@%  '                 fileName$  Name of file for determining file attributes%@AE@%%@NL@%
%@NL@%
%@NL@%
    TYPE RegType%@NL@%
        ax    AS INTEGER%@NL@%
        bx    AS INTEGER%@NL@%
        cx    AS INTEGER%@NL@%
        dx    AS INTEGER%@NL@%
        bp    AS INTEGER%@NL@%
        si    AS INTEGER%@NL@%
        di    AS INTEGER%@NL@%
        flags AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE RegTypeX%@NL@%
        ax    AS INTEGER%@NL@%
        bx    AS INTEGER%@NL@%
        cx    AS INTEGER%@NL@%
        dx    AS INTEGER%@NL@%
        bp    AS INTEGER%@NL@%
        si    AS INTEGER%@NL@%
        di    AS INTEGER%@NL@%
        flags AS INTEGER%@NL@%
        ds    AS INTEGER%@NL@%
        es    AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE MediaDescriptorType%@NL@%
        sectorsPerAllocationUnit AS INTEGER%@NL@%
        bytesPerSector AS INTEGER%@NL@%
        FATIdentificationByte AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE DiskFreeSpaceType%@NL@%
        sectorsPerCluster AS INTEGER%@NL@%
        bytesPerSector AS INTEGER%@NL@%
        clustersPerDrive AS LONG%@NL@%
        availableClusters AS LONG%@NL@%
        availableBytes AS LONG%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE CountryType%@NL@%
        dateTimeFormat AS STRING * 11%@NL@%
        currencySymbol AS STRING * 4%@NL@%
        thousandsSeparator AS STRING * 1%@NL@%
        decimalSeparator AS STRING * 1%@NL@%
        dateSeparator AS STRING * 1%@NL@%
        timeSeparator AS STRING * 1%@NL@%
        currencyThenSymbol AS INTEGER%@NL@%
        currencySymbolSpace AS INTEGER%@NL@%
        currencyPlaces AS INTEGER%@NL@%
        hours24 AS INTEGER%@NL@%
        caseMapSegment AS INTEGER%@NL@%
        caseMapOffset AS INTEGER%@NL@%
        dataListSeparator AS STRING * 1%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE FileAttributesType%@NL@%
        readOnly AS INTEGER%@NL@%
        hidden AS INTEGER%@NL@%
        systemFile AS INTEGER%@NL@%
        archive AS INTEGER%@NL@%
        result AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@NL@%
    DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@NL@%
    DECLARE SUB SetDrive (drive$)%@NL@%
    DECLARE SUB GetMediaDescriptor (drive$, desc AS MediaDescriptorType)%@NL@%
    DECLARE SUB SetVerifyState (state%)%@NL@%
    DECLARE SUB GetDiskFreeSpace (drive$, disk AS DiskFreeSpaceType)%@NL@%
    DECLARE SUB GetCountry (country AS CountryType)%@NL@%
    DECLARE SUB CaseMap (character%, BYVAL Segment%, BYVAL Offset%)%@NL@%
    DECLARE SUB SetDirectory (path$, result%)%@NL@%
    DECLARE SUB WriteToDevice (handle%, a$, result%)%@NL@%
    DECLARE SUB GetFileAttributes (fileName$, attr AS FileAttributesType)%@NL@%
    DECLARE SUB SetFileAttributes (fileName$, attr AS FileAttributesType)%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION DOSVersion! ()%@NL@%
    DECLARE FUNCTION BufferedKeyInput$ (n%)%@NL@%
    DECLARE FUNCTION GetDrive$ ()%@NL@%
    DECLARE FUNCTION GetVerifyState% ()%@NL@%
    DECLARE FUNCTION TranslateCountry$ (a$, country AS CountryType)%@NL@%
    DECLARE FUNCTION GetDirectory$ (drive$)%@NL@%
%@NL@%
%@AB@%  ' Try the Buffered Keyboard Input call%@AE@%%@NL@%
    CLS%@NL@%
    PRINT "BufferedKeyInput$:"%@NL@%
    PRINT "Enter a string of up to nine characters...  ";%@NL@%
    x$ = BufferedKeyInput$(9)%@NL@%
    PRINT%@NL@%
    PRINT "Here's the nine-character string result... ";%@NL@%
    PRINT CHR$(34); x$; CHR$(34)%@NL@%
%@NL@%
%@AB@%  ' Get the MS-DOS version number%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "DosVersion!:"%@NL@%
    PRINT "DOS Version number is "; DOSVersion!%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the GetDrive and SetDrive routines%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "GetDrive$ and SetDrive:"%@NL@%
    drive$ = GetDrive$%@NL@%
    PRINT "The current drive is "; drive$%@NL@%
    PRINT "Setting the current drive to A:"%@NL@%
    SetDrive "A:"%@NL@%
    PRINT "Now the current drive is "; GetDrive$%@NL@%
    PRINT "Setting the current drive back to "; drive$%@NL@%
    SetDrive drive$%@NL@%
    PRINT "Now the current drive is "; GetDrive$%@NL@%
%@NL@%
%@AB@%  ' Call the MS-DOS "Media Descriptor" function for the current drive%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "GetMediaDescriptor"%@NL@%
    DIM desc AS MediaDescriptorType%@NL@%
    GetMediaDescriptor drive$, desc%@NL@%
    PRINT "Drive                        "; drive$%@NL@%
    PRINT "Sectors per allocation unit "; desc.sectorsPerAllocationUnit%@NL@%
    PRINT "Bytes per sector            "; desc.bytesPerSector%@NL@%
    PRINT "FAT identification byte      &H"; HEX$(desc.FATIdentificationByte)%@NL@%
%@NL@%
%@AB@%  ' Wait for user%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
    CLS%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the GetVerifyState and SetVerifyState routines%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "GetVerifyState% and SetVerifyState:"%@NL@%
    state% = GetVerifyState%%@NL@%
    PRINT "Current verify state is"; state%%@NL@%
    oppositeState% = 1 AND NOT state%%@NL@%
    SetVerifyState oppositeState%%@NL@%
    PRINT "Now the verify state is"; GetVerifyState%%@NL@%
    SetVerifyState state%%@NL@%
    PRINT "Now the verify state is"; GetVerifyState%%@NL@%
%@NL@%
%@AB@%  ' Determine free space on the current drive%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "GetDiskFreeSpace:"%@NL@%
    DIM disk AS DiskFreeSpaceType%@NL@%
    GetDiskFreeSpace drive$, disk%@NL@%
    PRINT "Sectors per cluster     "; disk.sectorsPerCluster%@NL@%
    PRINT "Bytes per sector        "; disk.bytesPerSector%@NL@%
    PRINT "Total clusters on drive "; disk.clustersPerDrive%@NL@%
    PRINT "Available clusters      "; disk.availableClusters%@NL@%
    PRINT "Available bytes         "; disk.availableBytes%@NL@%
%@NL@%
%@AB@%  ' Wait for user%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
    CLS%@NL@%
%@NL@%
%@AB@%  ' Get country-dependent information%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "GetCountry:"%@NL@%
    DIM country AS CountryType%@NL@%
    GetCountry country%@NL@%
    PRINT "Date and time format    "; country.dateTimeFormat%@NL@%
    PRINT "Currency symbol         "; country.currencySymbol%@NL@%
    PRINT "Thousands separator     "; country.thousandsSeparator%@NL@%
    PRINT "Decimal separator       "; country.decimalSeparator%@NL@%
    PRINT "Date separator          "; country.dateSeparator%@NL@%
    PRINT "Time separator          "; country.timeSeparator%@NL@%
    PRINT "Currency before symbol "; country.currencyThenSymbol%@NL@%
    PRINT "Currency symbol space  "; country.currencySymbolSpace%@NL@%
    PRINT "Currency decimal places"; country.currencyPlaces%@NL@%
    PRINT "24-hour time           "; country.hours24%@NL@%
    PRINT "Case map segment       "; country.caseMapSegment%@NL@%
    PRINT "Case map offset        "; country.caseMapOffset%@NL@%
    PRINT "Data list separator     "; country.dataListSeparator%@NL@%
%@NL@%
%@AB@%  ' Let's translate lowercase characters for the current country%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "TranslateCountry$:"%@NL@%
    FOR i% = 128 TO 175%@NL@%
        a$ = a$ + CHR$(i%)%@NL@%
    NEXT i%%@NL@%
    PRINT "Character codes 128 to 175, before and after translation... "%@NL@%
    PRINT a$%@NL@%
    PRINT TranslateCountry$(a$, country)%@NL@%
%@NL@%
%@AB@%  ' Wait for user%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
    CLS%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the SetDirectory and GetDirectory routines%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "GetDirectory$ and SetDirectory:"%@NL@%
    path$ = GetDirectory$(drive$)%@NL@%
    PRINT "Current directory is "; path$%@NL@%
    SetDirectory GetDrive$ + "\", result%%@NL@%
    PRINT "Now the directory is "; GetDirectory$(drive$)%@NL@%
    SetDirectory path$, result%%@NL@%
    PRINT "Now the directory is "; GetDirectory$(drive$)%@NL@%
%@NL@%
%@AB@%  ' Write to a file or device%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "WriteToDevice:"%@NL@%
    PRINT "Writing a 'bell' character to the CRT"%@NL@%
    WriteToDevice 1, CHR$(7), result%%@NL@%
    t$ = TIME$%@NL@%
    DO%@NL@%
    LOOP UNTIL t$ <> TIME$%@NL@%
    PRINT "Writing a 'bell' character to the printer"%@NL@%
    WriteToDevice 4, CHR$(7), result%%@NL@%
%@NL@%
%@AB@%  ' Wait for user%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
    CLS%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the GetFileAttributes and SetFileAttributes routines%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "GetFileAttributes and SetFileAttributes:"%@NL@%
    DIM attr AS FileAttributesType%@NL@%
    fileName$ = "C:\IBMDOS.COM"%@NL@%
    GetFileAttributes fileName$, attr%@NL@%
    PRINT "File attributes for "; fileName$%@NL@%
    PRINT "Result of call "; attr.result%@NL@%
    PRINT "Read only      "; attr.readOnly%@NL@%
    PRINT "Hidden         "; attr.hidden%@NL@%
    PRINT "System         "; attr.systemFile%@NL@%
    PRINT "Archive        "; attr.archive%@NL@%
    PRINT%@NL@%
    attr.hidden = 0%@NL@%
    SetFileAttributes fileName$, attr%@NL@%
    GetFileAttributes fileName$, attr%@NL@%
    PRINT "File attributes for "; fileName$%@NL@%
    PRINT "Result of call "; attr.result%@NL@%
    PRINT "Read only      "; attr.readOnly%@NL@%
    PRINT "Hidden         "; attr.hidden%@NL@%
    PRINT "System         "; attr.systemFile%@NL@%
    PRINT "Archive        "; attr.archive%@NL@%
    PRINT%@NL@%
    attr.hidden = 1%@NL@%
    SetFileAttributes fileName$, attr%@NL@%
    GetFileAttributes fileName$, attr%@NL@%
    PRINT "File attributes for "; fileName$%@NL@%
    PRINT "Result of call "; attr.result%@NL@%
    PRINT "Read only      "; attr.readOnly%@NL@%
    PRINT "Hidden         "; attr.hidden%@NL@%
    PRINT "System         "; attr.systemFile%@NL@%
    PRINT "Archive        "; attr.archive%@NL@%
    PRINT%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          BufferedKeyInput$          **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Calls the "Buffered Keyboard Input" MS-DOS function%@AE@%%@NL@%
%@AB@%  ' and returns the entered string of characters.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  x$ = BufferedKeyInput$(n%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      buffer$    Buffer for keyboard input%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       regX       Structure of type RegTypeX%@AE@%%@NL@%
%@AB@%  '                  bufSize%   Length of buffer$%@AE@%%@NL@%
%@AB@%  '                  b$         Working copy of buffer$%@AE@%%@NL@%
%@AB@%  '                  count%     Count of characters entered%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     ds    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     es    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@AE@%%@NL@%
%@AB@%  '   DECLARE FUNCTION BufferedKeyInput$ (n%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION BufferedKeyInput$ (n%) STATIC%@NL@%
        DIM regX AS RegTypeX%@NL@%
        b$ = CHR$(n% + 1) + SPACE$(n% + 1)%@NL@%
        regX.ax = &HA00%@NL@%
        regX.ds = VARSEG(b$)%@NL@%
        regX.dx = SADD(b$)%@NL@%
        InterruptX &H21, regX, regX%@NL@%
        count% = ASC(MID$(b$, 2, 1))%@NL@%
        BufferedKeyInput$ = MID$(b$, 3, count%) + SPACE$(n% - count%)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DOSVersion!                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the version number of MS-DOS.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  PRINT "MS-DOS Version number is "; DOSVersion!%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegType%@AE@%%@NL@%
%@AB@%  '                  major%     Integer part of the MS-DOS version number%@AE@%%@NL@%
%@AB@%  '                  minor%     Fractional part of the MS-DOS version number%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegType%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '      DECLARE FUNCTION DOSVersion! ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION DOSVersion! STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        reg.ax = &H3000%@NL@%
        Interrupt &H21, reg, reg%@NL@%
        major% = reg.ax MOD 256%@NL@%
        minor% = reg.ax \ 256%@NL@%
        DOSVersion! = major% + minor% / 100!%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetCountry                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns country-dependent information as defined%@AE@%%@NL@%
%@AB@%  ' by MS-DOS.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  GetCountry country%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      country    Structure of type CountryType%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       regX       Structure of type RegTypeX%@AE@%%@NL@%
%@AB@%  '                  c$         Buffer for data returned from interrupt%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     ds    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     es    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  TYPE CountryType%@AE@%%@NL@%
%@AB@%  '                     DateTimeFormat AS STRING * 11%@AE@%%@NL@%
%@AB@%  '                     CurrencySymbol AS STRING * 4%@AE@%%@NL@%
%@AB@%  '                     ThousandsSeparator AS STRING * 1%@AE@%%@NL@%
%@AB@%  '                     DecimalSeparator AS STRING * 1%@AE@%%@NL@%
%@AB@%  '                     DateSeparator AS STRING * 1%@AE@%%@NL@%
%@AB@%  '                     TimeSeparator AS STRING * 1%@AE@%%@NL@%
%@AB@%  '                     CurrencyThenSymbol AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     CurrencySymbolSpace AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     CurrencyPlaces AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     Hours24 AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     caseMapSegment AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     caseMapOffset AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     DataListSeparator AS STRING * 1%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB GetCountry (country AS CountryType)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB GetCountry (country AS CountryType)%@NL@%
        DIM regX AS RegTypeX%@NL@%
        regX.ax = &H3800%@NL@%
        c$ = SPACE$(32)%@NL@%
        regX.ds = VARSEG(c$)%@NL@%
        regX.dx = SADD(c$)%@NL@%
        InterruptX &H21, regX, regX%@NL@%
        SELECT CASE CVI(LEFT$(c$, 2))%@NL@%
        CASE 0%@NL@%
            country.dateTimeFormat = "h:m:s m/d/y"%@NL@%
        CASE 1%@NL@%
            country.dateTimeFormat = "h:m:s d/m/y"%@NL@%
        CASE 2%@NL@%
            country.dateTimeFormat = "y/m/d h:m:s"%@NL@%
        CASE ELSE%@NL@%
            country.dateTimeFormat = "h:m:s m/d/y"%@NL@%
        END SELECT%@NL@%
        country.currencySymbol = MID$(c$, 3, 4)%@NL@%
        country.thousandsSeparator = MID$(c$, 8, 1)%@NL@%
        country.decimalSeparator = MID$(c$, 10, 1)%@NL@%
        country.dateSeparator = MID$(c$, 12, 1)%@NL@%
        country.timeSeparator = MID$(c$, 14, 1)%@NL@%
        country.currencyThenSymbol = ASC(MID$(c$, 16)) AND 1%@NL@%
        country.currencySymbolSpace = (ASC(MID$(c$, 16)) AND 2) \ 2%@NL@%
        country.currencyPlaces = ASC(MID$(c$, 17))%@NL@%
        country.hours24 = ASC(MID$(c$, 18))%@NL@%
        country.caseMapSegment = CVI(MID$(c$, 21, 2))%@NL@%
        country.caseMapOffset = CVI(MID$(c$, 19, 2))%@NL@%
        country.dataListSeparator = MID$(c$, 23, 1)%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetDirectory$              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the name of the current directory for any drive.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  path$ = GetDirectory$(drive$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      drive$     Drive of concern, or null string for default%@AE@%%@NL@%
%@AB@%  '                             drive%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       regX       Structure of type RegTypeX%@AE@%%@NL@%
%@AB@%  '                  d$         Working copy of drive$%@AE@%%@NL@%
%@AB@%  '                  p$         Buffer space for returned path%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     ds    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     es    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@AE@%%@NL@%
%@AB@%  '   DECLARE FUNCTION GetDirectory$ (drive$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION GetDirectory$ (drive$) STATIC%@NL@%
        DIM regX AS RegTypeX%@NL@%
        IF drive$ = "" THEN%@NL@%
            d$ = GetDrive$%@NL@%
        ELSE%@NL@%
            d$ = UCASE$(drive$)%@NL@%
        END IF%@NL@%
        drive% = ASC(d$) - 64%@NL@%
        regX.dx = drive%%@NL@%
        regX.ax = &H4700%@NL@%
        p$ = SPACE$(64)%@NL@%
        regX.ds = VARSEG(p$)%@NL@%
        regX.si = SADD(p$)%@NL@%
        InterruptX &H21, regX, regX%@NL@%
        p$ = LEFT$(p$, INSTR(p$, CHR$(0)) - 1)%@NL@%
        GetDirectory$ = LEFT$(d$, 1) + ":\" + p$%@NL@%
        IF regX.flags AND 1 THEN%@NL@%
            GetDirectory$ = ""%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetDiskFreeSpace           **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Get information about a drive's organization, including%@AE@%%@NL@%
%@AB@%  ' total number of bytes available.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  GetDiskFreeSpace drive$, disk%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      drive$     Disk drive designation%@AE@%%@NL@%
%@AB@%  '                  disk       Structure of type DiskFreeSpaceType%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegType%@AE@%%@NL@%
%@AB@%  '                  drive%     Numeric drive designation%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegType%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  TYPE DiskFreeSpaceType%@AE@%%@NL@%
%@AB@%  '                     sectorsPerCluster AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bytesPerSector AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     clustersPerDrive AS LONG%@AE@%%@NL@%
%@AB@%  '                     availableClusters AS LONG%@AE@%%@NL@%
%@AB@%  '                     availableBytes AS LONG%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB GetDiskFreeSpace (drive$, disk AS DiskFreeSpaceType)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB GetDiskFreeSpace (drive$, disk AS DiskFreeSpaceType)%@NL@%
        DIM reg AS RegType%@NL@%
        IF drive$ <> "" THEN%@NL@%
            drive% = ASC(UCASE$(drive$)) - 64%@NL@%
        ELSE%@NL@%
            drive% = 0%@NL@%
        END IF%@NL@%
        IF drive% >= 0 THEN%@NL@%
            reg.dx = drive%%@NL@%
        ELSE%@NL@%
            reg.dx = 0%@NL@%
        END IF%@NL@%
        reg.ax = &H3600%@NL@%
        Interrupt &H21, reg, reg%@NL@%
        disk.sectorsPerCluster = reg.ax%@NL@%
        disk.bytesPerSector = reg.cx%@NL@%
        IF reg.dx >= 0 THEN%@NL@%
            disk.clustersPerDrive = reg.dx%@NL@%
        ELSE%@NL@%
            disk.clustersPerDrive = reg.dx + 65536%@NL@%
        END IF%@NL@%
        IF reg.bx >= 0 THEN%@NL@%
            disk.availableClusters = reg.bx%@NL@%
        ELSE%@NL@%
            disk.availableClusters = reg.bx + 65536%@NL@%
        END IF%@NL@%
        disk.availableBytes = disk.availableClusters * reg.ax * reg.cx%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetDrive$                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the current disk drive name, such as "A:".%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  drive$ = GetDrive$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegType%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegType%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '      DECLARE FUNCTION GetDrive$ ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION GetDrive$ STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        reg.ax = &H1900%@NL@%
        Interrupt &H21, reg, reg%@NL@%
        GetDrive$ = CHR$((reg.ax AND &HFF) + 65) + ":"%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetFileAttributes          **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the file attribute settings for a file.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  GetFileAttributes fileName$, attr%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      fileName$  Name of file%@AE@%%@NL@%
%@AB@%  '                  attr       Structure of type FileAttributesType%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       regX       Structure of type RegTypeX%@AE@%%@NL@%
%@AB@%  '                  f$         Null terminated copy of fileName$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     ds    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     es    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  TYPE FileAttributesType%@AE@%%@NL@%
%@AB@%  '                     readOnly AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     hidden AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     systemFile AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     archive AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     result AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB GetFileAttributes (fileName$, attr AS FileAttributesType)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB GetFileAttributes (fileName$, attr AS FileAttributesType) STATIC%@NL@%
        DIM regX AS RegTypeX%@NL@%
        regX.ax = &H4300%@NL@%
        f$ = fileName$ + CHR$(0)%@NL@%
        regX.ds = VARSEG(f$)%@NL@%
        regX.dx = SADD(f$)%@NL@%
        InterruptX &H21, regX, regX%@NL@%
        IF regX.flags AND 1 THEN%@NL@%
            attr.result = regX.ax%@NL@%
        ELSE%@NL@%
            attr.result = 0%@NL@%
        END IF%@NL@%
        attr.readOnly = regX.cx AND 1%@NL@%
        attr.hidden = (regX.cx \ 2) AND 1%@NL@%
        attr.systemFile = (regX.cx \ 4) AND 1%@NL@%
        attr.archive = (regX.cx \ 32) AND 1%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetMediaDescriptor         **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Calls the MS-DOS "Get Media Descriptor" function for%@AE@%%@NL@%
%@AB@%  ' the indicated drive.  Results are returned in a%@AE@%%@NL@%
%@AB@%  ' structure of type MediaDescriptorType.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  GetMediaDescriptor drive$, desc%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      drive$     Drive designation, such as "A:"%@AE@%%@NL@%
%@AB@%  '                  desc       Structure of type MediaDescriptorType%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       regX       Structure of type RegTypeX%@AE@%%@NL@%
%@AB@%  '                  drive%     Numeric drive designation%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     ds    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     es    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  TYPE MediaDescriptorType%@AE@%%@NL@%
%@AB@%  '                     sectorsPerAllocationUnit AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bytesPerSector AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     FATIdentificationByte AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB GetMediaDescriptor (drive$, desc AS MediaDescriptorType)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB GetMediaDescriptor (drive$, desc AS MediaDescriptorType) STATIC%@NL@%
        DIM regX AS RegTypeX%@NL@%
        IF drive$ <> "" THEN%@NL@%
            drive% = ASC(UCASE$(drive$)) - 64%@NL@%
        ELSE%@NL@%
            drive% = 0%@NL@%
        END IF%@NL@%
        IF drive% >= 0 THEN%@NL@%
            regX.dx = drive%%@NL@%
        ELSE%@NL@%
            regX.dx = 0%@NL@%
        END IF%@NL@%
        regX.ax = &H1C00%@NL@%
        InterruptX &H21, regX, regX%@NL@%
        desc.sectorsPerAllocationUnit = regX.ax AND &HFF%@NL@%
        desc.bytesPerSector = regX.cx%@NL@%
        DEF SEG = regX.ds%@NL@%
        desc.FATIdentificationByte = PEEK(regX.bx)%@NL@%
        DEF SEG%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetVerifyState%            **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the current state of the MS-DOS "Verify After%@AE@%%@NL@%
%@AB@%  ' Write" flag.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  state% = GetVerifyState%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegType%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '      DECLARE FUNCTION GetVerifyState% ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION GetVerifyState% STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        reg.ax = &H5400%@NL@%
        Interrupt &H21, reg, reg%@NL@%
        GetVerifyState% = reg.ax AND &HFF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          SetDirectory               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Sets the current directory.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  SetDirectory path$, result%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      path$      The path to the directory%@AE@%%@NL@%
%@AB@%  '                  result%    Returned error code, zero if successful%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       regX       Structure of type RegTypeX%@AE@%%@NL@%
%@AB@%  '                  p$         Null terminated copy of path$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     ds    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     es    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB SetDirectory (path$, result%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB SetDirectory (path$, result%) STATIC%@NL@%
        DIM regX AS RegTypeX%@NL@%
        regX.ax = &H3B00%@NL@%
        p$ = path$ + CHR$(0)%@NL@%
        regX.ds = VARSEG(p$)%@NL@%
        regX.dx = SADD(p$)%@NL@%
        InterruptX &H21, regX, regX%@NL@%
        IF regX.flags AND 1 THEN%@NL@%
            result% = regX.ax%@NL@%
        ELSE%@NL@%
            result% = 0%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          SetDrive                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Calls MS-DOS to set the current drive.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  SetDrive d$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      d$         Drive designation, such as "A:"%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegType%@AE@%%@NL@%
%@AB@%  '                  drive%     Numeric value of drive%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB SetDrive (drive$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB SetDrive (drive$) STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        IF drive$ <> "" THEN%@NL@%
            drive% = ASC(UCASE$(drive$)) - 65%@NL@%
        ELSE%@NL@%
            drive% = 0%@NL@%
        END IF%@NL@%
        IF drive% >= 0 THEN%@NL@%
            reg.dx = drive%%@NL@%
        ELSE%@NL@%
            reg.dx = 0%@NL@%
        END IF%@NL@%
        reg.ax = &HE00%@NL@%
        Interrupt &H21, reg, reg%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          SetFileAttributes          **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Sets attribute bits for a file.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  SetFileAttributes fileName$, attr%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      fileName$  Name of file%@AE@%%@NL@%
%@AB@%  '                  attr       Structure of type FileAttributesType%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       regX       Structure of type RegTypeX%@AE@%%@NL@%
%@AB@%  '                  f$         Null terminated copy of fileName$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     ds    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     es    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                 TYPE FileAttributesType%@AE@%%@NL@%
%@AB@%  '                    readOnly AS INTEGER%@AE@%%@NL@%
%@AB@%  '                    hidden AS INTEGER%@AE@%%@NL@%
%@AB@%  '                    systemFile AS INTEGER%@AE@%%@NL@%
%@AB@%  '                    archive AS INTEGER%@AE@%%@NL@%
%@AB@%  '                    result AS INTEGER%@AE@%%@NL@%
%@AB@%  '                 END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB SetFileAttributes (fileName$, attr AS FileAttributesType)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB SetFileAttributes (fileName$, attr AS FileAttributesType)%@NL@%
        DIM regX AS RegTypeX%@NL@%
        regX.ax = &H4301%@NL@%
        IF attr.readOnly THEN%@NL@%
            regX.cx = 1%@NL@%
        ELSE%@NL@%
            regX.cx = 0%@NL@%
        END IF%@NL@%
        IF attr.hidden THEN%@NL@%
            regX.cx = regX.cx + 2%@NL@%
        END IF%@NL@%
        IF attr.systemFile THEN%@NL@%
            regX.cx = regX.cx + 4%@NL@%
        END IF%@NL@%
        IF attr.archive THEN%@NL@%
            regX.cx = regX.cx + 32%@NL@%
        END IF%@NL@%
        f$ = fileName$ + CHR$(0)%@NL@%
        regX.ds = VARSEG(f$)%@NL@%
        regX.dx = SADD(f$)%@NL@%
        InterruptX &H21, regX, regX%@NL@%
        IF regX.flags AND 1 THEN%@NL@%
            attr.result = regX.ax%@NL@%
        ELSE%@NL@%
            attr.result = 0%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          SetVerifyState             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Sets or clears the "Verify After Write" MS-DOS flag.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  SetVerifyState state%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      state%     If 0, resets Verify;  If non-zero,%@AE@%%@NL@%
%@AB@%  '                             then sets Verify on%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegType%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@AE@%%@NL@%
%@AB@%  '      DECLARE SUB SetVerifyState (state%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB SetVerifyState (state%) STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        IF state% THEN%@NL@%
            reg.ax = &H2E01%@NL@%
        ELSE%@NL@%
            reg.ax = &H2E00%@NL@%
        END IF%@NL@%
        Interrupt &H21, reg, reg%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          TranslateCountry$          **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a string of characters translated according to%@AE@%%@NL@%
%@AB@%  ' the current country setting of MS-DOS.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = TranslateCountry$(a$, country)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String to be translated%@AE@%%@NL@%
%@AB@%  '                  country    Structure of type CountryType%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%         Index to each character of a$%@AE@%%@NL@%
%@AB@%  '                  c%         Byte value of each character in a$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE CountryType%@AE@%%@NL@%
%@AB@%  '                     DateTimeFormat AS STRING * 11%@AE@%%@NL@%
%@AB@%  '                     CurrencySymbol AS STRING * 4%@AE@%%@NL@%
%@AB@%  '                     ThousandsSeparator AS STRING * 1%@AE@%%@NL@%
%@AB@%  '                     DecimalSeparator AS STRING * 1%@AE@%%@NL@%
%@AB@%  '                     DateSeparator AS STRING * 1%@AE@%%@NL@%
%@AB@%  '                     TimeSeparator AS STRING * 1%@AE@%%@NL@%
%@AB@%  '                     CurrencyThenSymbol AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     CurrencySymbolSpace AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     CurrencyPlaces AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     Hours24 AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     caseMapSegment AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     caseMapOffset AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     DataListSeparator AS STRING * 1%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '           DECLARE SUB CaseMap (character%, BYVAL Segment%, BYVAL Offset%)%@AE@%%@NL@%
%@AB@%  '           DECLARE FUNCTION TranslateCountry$ (a$, country AS CountryType)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION TranslateCountry$ (a$, country AS CountryType) STATIC%@NL@%
        FOR i% = 1 TO LEN(a$)%@NL@%
            c% = ASC(MID$(a$, i%))%@NL@%
            CaseMap c%, country.caseMapSegment, country.caseMapOffset%@NL@%
            MID$(a$, i%, 1) = CHR$(c%)%@NL@%
        NEXT i%%@NL@%
        TranslateCountry$ = a$%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          WriteToDevice              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Writes bytes to a file or device.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  WriteToDevice handle%, a$, result%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      handle%    File or device handle%@AE@%%@NL@%
%@AB@%  '                  a$         String to be output%@AE@%%@NL@%
%@AB@%  '                  result%    Error code returned from MS-DOS%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       regX       Structure of type RegTypeX%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     ds    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     es    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB WriteToDevice (handle%, a$, result%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB WriteToDevice (handle%, a$, result%) STATIC%@NL@%
        DIM regX AS RegTypeX%@NL@%
        regX.ax = &H4000%@NL@%
        regX.cx = LEN(a$)%@NL@%
        regX.bx = handle%%@NL@%
        regX.ds = VARSEG(a$)%@NL@%
        regX.dx = SADD(a$)%@NL@%
        InterruptX &H21, regX, regX%@NL@%
        IF regX.flags AND 1 THEN%@NL@%
            result% = regX.ax%@NL@%
        ELSEIF regX.ax <> LEN(a$) THEN%@NL@%
            result% = -1%@NL@%
        ELSE%@NL@%
            result% = 0%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EDIT.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\EDIT.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          EDIT                       **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        EDIT.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       EDIT.BAS%@AE@%%@NL@%
%@AB@%  '                  KEYS.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       a$         String to be edited by the user%@AE@%%@NL@%
%@NL@%
    CONST FALSE = 0%@NL@%
    CONST TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%  ' Key code numbers%@AE@%%@NL@%
    CONST BACKSPACE = 8%@NL@%
    CONST CTRLLEFTARROW = 29440%@NL@%
    CONST CTRLRIGHTARROW = 29696%@NL@%
    CONST CTRLY = 25%@NL@%
    CONST CTRLQ = 17%@NL@%
    CONST DELETE = 21248%@NL@%
    CONST DOWNARROW = 20480%@NL@%
    CONST ENDKEY = 20224%@NL@%
    CONST ENTER = 13%@NL@%
    CONST ESCAPE = 27%@NL@%
    CONST HOME = 18176%@NL@%
    CONST INSERTKEY = 20992%@NL@%
    CONST LEFTARROW = 19200%@NL@%
    CONST RIGHTARROW = 19712%@NL@%
    CONST TABKEY = 9%@NL@%
    CONST UPARROW = 18432%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION KeyCode% ()%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB EditLine (a$, exitCode%)%@NL@%
    DECLARE SUB DrawBox (row1%, col1%, row2%, col2%)%@NL@%
    DECLARE SUB EditBox (a$, row1%, col1%, row2%, col2%)%@NL@%
    DECLARE SUB FormatTwo (a$, b$, col%)%@NL@%
    DECLARE SUB InsertCharacter (x$(), kee$, cp%, rp%, wide%, high%)%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the EditLine subprogram%@AE@%%@NL@%
    a$ = " Edit this line, and then press Up arrow, Down arrow, or Enter "%@NL@%
    CLS%@NL@%
    COLOR 14, 1%@NL@%
    EditLine a$, exitCode%%@NL@%
    COLOR 7, 0%@NL@%
    PRINT%@NL@%
    PRINT%@NL@%
    PRINT "Result of edit ..."%@NL@%
    COLOR 14, 0%@NL@%
    PRINT a$%@NL@%
    COLOR 7, 0%@NL@%
    PRINT%@NL@%
    SELECT CASE exitCode%%@NL@%
    CASE 0%@NL@%
        PRINT "Enter";%@NL@%
    CASE -1%@NL@%
        PRINT "Down arrow";%@NL@%
    CASE 1%@NL@%
        PRINT "Up arrow";%@NL@%
    CASE ELSE%@NL@%
    END SELECT%@NL@%
    PRINT " key pressed."%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the EditBox subprogram%@AE@%%@NL@%
    a$ = "Now, edit text inside this box.  Press "%@NL@%
    a$ = a$ + "Esc to end the editing..."%@NL@%
    COLOR 12, 1%@NL@%
    DrawBox 8, 17, 19, 57%@NL@%
    COLOR 11, 1%@NL@%
    EditBox a$, 8, 17, 19, 57%@NL@%
    LOCATE 21, 1%@NL@%
    COLOR 7, 0%@NL@%
    PRINT "Result..."%@NL@%
    COLOR 14, 0%@NL@%
    PRINT a$%@NL@%
    COLOR 7, 0%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DrawBox                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        EDIT.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Draws a double-lined box.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  DrawBox row1%, col1%, row2%, col2%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      row1%    Screen text row at upper left corner of the box%@AE@%%@NL@%
%@AB@%  '                  col1%    Screen text column at upper left corner of the box%@AE@%%@NL@%
%@AB@%  '                  row2%    Screen text row at lower right corner of the box%@AE@%%@NL@%
%@AB@%  '                  col2%    Screen text column at lower right corner of the%@AE@%%@NL@%
%@AB@%  '                           box%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       wide%    Inside width of box%@AE@%%@NL@%
%@AB@%  '                  row3%    Loop row number for creating sides of box%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB DrawBox (row1%, col1%, row2%, col2%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB DrawBox (row1%, col1%, row2%, col2%) STATIC%@NL@%
%@NL@%
%@AB@%      ' Determine inside width of box%@AE@%%@NL@%
        wide% = col2% - col1% - 1%@NL@%
%@NL@%
%@AB@%      ' Across the top%@AE@%%@NL@%
        LOCATE row1%, col1%, 0%@NL@%
        PRINT CHR$(201);%@NL@%
        PRINT STRING$(wide%, 205);%@NL@%
        PRINT CHR$(187);%@NL@%
%@NL@%
%@AB@%      ' Down the sides%@AE@%%@NL@%
        FOR row3% = row1% + 1 TO row2% - 1%@NL@%
            LOCATE row3%, col1%, 0%@NL@%
            PRINT CHR$(186);%@NL@%
            PRINT SPACE$(wide%);%@NL@%
            PRINT CHR$(186);%@NL@%
        NEXT row3%%@NL@%
%@NL@%
%@AB@%      ' Across the bottom%@AE@%%@NL@%
        LOCATE row2%, col1%, 0%@NL@%
        PRINT CHR$(200);%@NL@%
        PRINT STRING$(wide%, 205);%@NL@%
        PRINT CHR$(188);%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          EditBox                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        EDIT.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Allows the user to edit text inside a rectangular area.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  EditBox a$, row1%, col1%, row2%, col2%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$     String to be edited%@AE@%%@NL@%
%@AB@%  '                  row1%  Screen text row at upper left corner of the area%@AE@%%@NL@%
%@AB@%  '                  col1%  Screen text column at upper left corner of the area%@AE@%%@NL@%
%@AB@%  '                  row2%  Screen text row at lower right corner of the area%@AE@%%@NL@%
%@AB@%  '                  col2%  Screen text column at lower right corner of the area%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       r1%    Upper inside row of rectangular area%@AE@%%@NL@%
%@AB@%  '                  r2%    Lower inside row of rectangular area%@AE@%%@NL@%
%@AB@%  '                  c1%    Left inside column of rectangular area%@AE@%%@NL@%
%@AB@%  '                  c2%    Right inside column of rectangular area%@AE@%%@NL@%
%@AB@%  '                  wide%  Width of area%@AE@%%@NL@%
%@AB@%  '                  high%  Height of area%@AE@%%@NL@%
%@AB@%  '                  rp%    Index to current working row%@AE@%%@NL@%
%@AB@%  '                  cp%    Index to current working column%@AE@%%@NL@%
%@AB@%  '                  insert%  Flag for insert/replace mode%@AE@%%@NL@%
%@AB@%  '                  quit%  Flag for quitting the subprogram%@AE@%%@NL@%
%@AB@%  '                  across%  Saved current cursor column%@AE@%%@NL@%
%@AB@%  '                  down%  Saved current cursor row%@AE@%%@NL@%
%@AB@%  '                  x$()  Workspace string array%@AE@%%@NL@%
%@AB@%  '                  i%  Looping index%@AE@%%@NL@%
%@AB@%  '                  b$  Works with a$ to format a$ into x$()%@AE@%%@NL@%
%@AB@%  '                  keyNumber%  Integer code for any key press%@AE@%%@NL@%
%@AB@%  '                  c$  Temporary string workspace%@AE@%%@NL@%
%@AB@%  '                  ds%  Index to double-space groupings%@AE@%%@NL@%
%@AB@%  '                  sp%  Index to character where split of string is to occur%@AE@%%@NL@%
%@AB@%  '                  ctrlQflag%  Indicates Ctrl-Q has been pressed%@AE@%%@NL@%
%@AB@%  '                  kee$  Character entered from keyboard%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION KeyCode% ()%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB EditBox ($, row1%, col1%, row2%, col2%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB FormatTwo (a$, b$, col%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB InsertCharacter (x$(), kee$, cp%, rp%,%@AE@%%@NL@%
%@AB@%  '                                               wide%, high%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB EditBox (a$, row1%, col1%, row2%, col2%) STATIC%@NL@%
%@NL@%
%@AB@%      ' Set up some working variables%@AE@%%@NL@%
        r1% = row1% + 1%@NL@%
        r2% = row2% - 1%@NL@%
        c1% = col1% + 2%@NL@%
        c2% = col2% - 2%@NL@%
        wide% = c2% - c1% + 1%@NL@%
        high% = r2% - r1% + 1%@NL@%
        rp% = 1%@NL@%
        cp% = 1%@NL@%
        insert% = TRUE%@NL@%
        quit% = FALSE%@NL@%
%@NL@%
%@AB@%      ' Record the current cursor location%@AE@%%@NL@%
        across% = POS(0)%@NL@%
        down% = CSRLIN%@NL@%
%@NL@%
%@AB@%      ' Dimension a workspace array%@AE@%%@NL@%
        REDIM x$(1 TO high%)%@NL@%
%@NL@%
%@AB@%      ' Format a$ into array space%@AE@%%@NL@%
        FOR i% = 1 TO high%%@NL@%
            FormatTwo a$, b$, wide%%@NL@%
            x$(i%) = a$%@NL@%
            a$ = b$%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' Display the strings%@AE@%%@NL@%
        FOR i% = 1 TO high%%@NL@%
            LOCATE r1% + i% - 1, c1%, 0%@NL@%
            PRINT x$(i%);%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' Process each keystroke%@AE@%%@NL@%
        DO%@NL@%
%@NL@%
%@AB@%          ' Update the current line%@AE@%%@NL@%
            LOCATE r1% + rp% - 1, c1%, 0%@NL@%
            PRINT x$(rp%);%@NL@%
%@NL@%
%@AB@%          ' Place the cursor%@AE@%%@NL@%
            IF insert% THEN%@NL@%
                LOCATE r1% + rp% - 1, c1% + cp% - 1, 1, 6, 7%@NL@%
            ELSE%@NL@%
                LOCATE r1% + rp% - 1, c1% + cp% - 1, 1, 1, 7%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Grab next keystroke%@AE@%%@NL@%
            keyNumber% = KeyCode%%@NL@%
%@NL@%
%@AB@%          ' Process the key%@AE@%%@NL@%
            SELECT CASE keyNumber%%@NL@%
%@NL@%
            CASE INSERTKEY%@NL@%
                IF insert% THEN%@NL@%
                    insert% = FALSE%@NL@%
                ELSE%@NL@%
                    insert% = TRUE%@NL@%
                END IF%@NL@%
%@NL@%
            CASE BACKSPACE%@NL@%
%@NL@%
%@AB@%              ' Rub out character to the left%@AE@%%@NL@%
                IF cp% > 1 THEN%@NL@%
                    x$(rp%) = x$(rp%) + " "%@NL@%
                    b$ = LEFT$(x$(rp%), cp% - 2)%@NL@%
                    c$ = MID$(x$(rp%), cp%)%@NL@%
                    x$(rp%) = b$ + c$%@NL@%
                    cp% = cp% - 1%@NL@%
%@NL@%
%@AB@%              ' Upper left corner, so reformat the whole box%@AE@%%@NL@%
                ELSEIF rp% = 1 THEN%@NL@%
%@NL@%
%@AB@%                  ' Pull all the strings together%@AE@%%@NL@%
                    a$ = ""%@NL@%
                    FOR i% = 1 TO high%%@NL@%
                        a$ = a$ + LTRIM$(RTRIM$(x$(i%))) + " "%@NL@%
                    NEXT i%%@NL@%
%@NL@%
%@AB@%                  ' Remove double spaces%@AE@%%@NL@%
                    ds% = INSTR(a$, "  ")%@NL@%
                    DO WHILE ds%%@NL@%
                        a$ = LEFT$(a$, ds% - 1) + MID$(a$, ds% + 1)%@NL@%
                        ds% = INSTR(a$, "  ")%@NL@%
                    LOOP%@NL@%
%@NL@%
%@AB@%                  ' Format into the array and display lines%@AE@%%@NL@%
                    FOR i% = 1 TO high%%@NL@%
                        FormatTwo a$, b$, wide%%@NL@%
                        x$(i%) = a$%@NL@%
                        a$ = b$%@NL@%
                        LOCATE r1% + i% - 1, c1%, 0%@NL@%
                        PRINT x$(i%);%@NL@%
                    NEXT i%%@NL@%
%@NL@%
%@AB@%              ' Concatenate to the preceding line%@AE@%%@NL@%
                ELSE%@NL@%
%@NL@%
%@AB@%                  ' Use the InsertCharacter sub to insert a space%@AE@%%@NL@%
                    rp% = rp% - 1%@NL@%
                    cp% = wide% + 1%@NL@%
                    InsertCharacter x$(), " ", rp%, cp%, wide%, high%%@NL@%
%@NL@%
%@AB@%                  ' Remove the extra spaces introduced%@AE@%%@NL@%
                    IF cp% > 2 THEN%@NL@%
                        b$ = LEFT$(x$(rp%), cp% - 3)%@NL@%
                        c$ = MID$(x$(rp%), cp%)%@NL@%
                    ELSE%@NL@%
                        b$ = ""%@NL@%
                        c$ = MID$(x$(rp%), cp% + 1)%@NL@%
                    END IF%@NL@%
%@NL@%
%@AB@%                  ' Pull the line pieces together%@AE@%%@NL@%
                    x$(rp%) = LEFT$(b$ + c$ + SPACE$(3), wide%)%@NL@%
%@NL@%
%@AB@%                  ' Adjust the cursor position%@AE@%%@NL@%
                    cp% = cp% - 1%@NL@%
%@NL@%
%@AB@%                  ' Display the lines%@AE@%%@NL@%
                    FOR i% = 1 TO high%%@NL@%
                        LOCATE r1% + i% - 1, c1%, 0%@NL@%
                        PRINT x$(i%);%@NL@%
                    NEXT i%%@NL@%
                END IF%@NL@%
%@NL@%
            CASE DELETE%@NL@%
                x$(rp%) = x$(rp%) + " "%@NL@%
                b$ = LEFT$(x$(rp%), cp% - 1)%@NL@%
                c$ = MID$(x$(rp%), cp% + 1)%@NL@%
                x$(rp%) = b$ + c$%@NL@%
%@NL@%
            CASE UPARROW%@NL@%
                IF rp% > 1 THEN%@NL@%
                    rp% = rp% - 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE DOWNARROW%@NL@%
                IF rp% < high% THEN%@NL@%
                    rp% = rp% + 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE LEFTARROW%@NL@%
                IF cp% > 1 THEN%@NL@%
                    cp% = cp% - 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE RIGHTARROW%@NL@%
                IF cp% < wide% THEN%@NL@%
                    cp% = cp% + 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE ENTER%@NL@%
                IF rp% < high% AND x$(high%) = SPACE$(wide%) THEN%@NL@%
%@NL@%
%@AB@%                  ' Shuffle lines down%@AE@%%@NL@%
                    FOR i% = high% TO rp% + 1 STEP -1%@NL@%
                        x$(i%) = x$(i% - 1)%@NL@%
                    NEXT i%%@NL@%
%@NL@%
%@AB@%                  ' Split current line at cursor%@AE@%%@NL@%
                    sp% = wide% - cp% + 1%@NL@%
                    IF sp% THEN%@NL@%
                        MID$(x$(rp%), cp%, sp%) = SPACE$(sp%)%@NL@%
                    END IF%@NL@%
%@NL@%
%@AB@%                  ' Move to next line%@AE@%%@NL@%
                    rp% = rp% + 1%@NL@%
                    x$(rp%) = MID$(x$(rp%), cp%) + SPACE$(cp% - 1)%@NL@%
                    cp% = 1%@NL@%
%@NL@%
%@AB@%                  ' Display the modified lines%@AE@%%@NL@%
                    FOR i% = rp% - 1 TO high%%@NL@%
                        LOCATE r1% + i% - 1, c1%, 0%@NL@%
                        PRINT x$(i%);%@NL@%
                    NEXT i%%@NL@%
%@NL@%
                ELSE%@NL@%
%@NL@%
%@AB@%                  ' Nowhere to push things down%@AE@%%@NL@%
                    BEEP%@NL@%
%@NL@%
                END IF%@NL@%
%@NL@%
            CASE HOME%@NL@%
                cp% = 1%@NL@%
%@NL@%
            CASE ENDKEY%@NL@%
                cp% = wide% + 1%@NL@%
%@NL@%
%@AB@%              ' Move back to just after last character%@AE@%%@NL@%
                IF x$(rp%) <> SPACE$(wide%) THEN%@NL@%
                    DO UNTIL MID$(x$(rp%), cp% - 1, 1) <> " "%@NL@%
                        cp% = cp% - 1%@NL@%
                    LOOP%@NL@%
                ELSE%@NL@%
                    cp% = 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE CTRLRIGHTARROW%@NL@%
%@NL@%
%@AB@%              ' Find next space%@AE@%%@NL@%
                DO UNTIL MID$(x$(rp%), cp%, 1) = " " OR cp% = wide%%@NL@%
                    cp% = cp% + 1%@NL@%
                LOOP%@NL@%
%@NL@%
%@AB@%              ' Find first non-space character%@AE@%%@NL@%
                DO UNTIL MID$(x$(rp%), cp%, 1) <> " " OR cp% = wide%%@NL@%
                    cp% = cp% + 1%@NL@%
                LOOP%@NL@%
%@NL@%
            CASE CTRLLEFTARROW%@NL@%
%@NL@%
%@AB@%              ' Find first space to the left%@AE@%%@NL@%
                DO UNTIL MID$(x$(rp%), cp%, 1) = " " OR cp% = 1%@NL@%
                    cp% = cp% - 1%@NL@%
                LOOP%@NL@%
%@NL@%
%@AB@%              ' Find first non-space character to the left%@AE@%%@NL@%
                DO UNTIL MID$(x$(rp%), cp%, 1) <> " " OR cp% = 1%@NL@%
                    cp% = cp% - 1%@NL@%
                LOOP%@NL@%
%@NL@%
%@AB@%              ' Find next space to the left%@AE@%%@NL@%
                DO UNTIL MID$(x$(rp%), cp%, 1) = " " OR cp% = 1%@NL@%
                    cp% = cp% - 1%@NL@%
                LOOP%@NL@%
%@NL@%
%@AB@%              ' Adjust cursor position to first non-space character%@AE@%%@NL@%
                IF cp% > 1 THEN%@NL@%
                    cp% = cp% + 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE CTRLY%@NL@%
                IF rp% < high% THEN%@NL@%
%@AB@%                  ' Shuffle lines up, spacing out the last%@AE@%%@NL@%
                    FOR i% = rp% TO high%%@NL@%
                        IF i% < high% THEN%@NL@%
                            x$(i%) = x$(i% + 1)%@NL@%
                        ELSE%@NL@%
                            x$(i%) = SPACE$(wide%)%@NL@%
                        END IF%@NL@%
                        LOCATE r1% + i% - 1, c1%, 0%@NL@%
                        PRINT x$(i%);%@NL@%
                    NEXT i%%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Move cursor to far left%@AE@%%@NL@%
                cp% = 1%@NL@%
%@NL@%
            CASE CTRLQ%@NL@%
                ctrlQflag% = TRUE%@NL@%
%@NL@%
            CASE ESCAPE%@NL@%
                quit% = TRUE%@NL@%
%@NL@%
            CASE IS > 255%@NL@%
                SOUND 999, 1%@NL@%
%@NL@%
            CASE IS < 32%@NL@%
                SOUND 999, 1%@NL@%
%@NL@%
            CASE ELSE%@NL@%
                kee$ = CHR$(keyNumber%)%@NL@%
%@NL@%
%@AB@%              ' Insert mode%@AE@%%@NL@%
                IF insert% THEN%@NL@%
                    InsertCharacter x$(), kee$, rp%, cp%, wide%, high%%@NL@%
                    FOR i% = 1 TO high%%@NL@%
                        LOCATE r1% + i% - 1, c1%, 0%@NL@%
                        PRINT x$(i%);%@NL@%
                    NEXT i%%@NL@%
%@NL@%
%@AB@%              ' Must be overstrike mode%@AE@%%@NL@%
                ELSE%@NL@%
                    MID$(x$(rp%), cp%, 1) = kee$%@NL@%
                    IF cp% < wide% + 1 THEN%@NL@%
                        cp% = cp% + 1%@NL@%
                    ELSE%@NL@%
                        IF rp% < high% THEN%@NL@%
                            LOCATE r1% + rp% - 1, c1%, 0%@NL@%
                            PRINT x$(rp%);%@NL@%
                            rp% = rp% + 1%@NL@%
                            cp% = 1%@NL@%
                        END IF%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Correct for bottom right corner problem%@AE@%%@NL@%
                IF rp% > high% THEN%@NL@%
                    cp% = wide%%@NL@%
                    rp% = high%%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Check for Ctrl-Q-Y combination (del to end of line)%@AE@%%@NL@%
                IF kee$ = "y" AND ctrlQflag% THEN%@NL@%
                    cp% = cp% - 1%@NL@%
                    IF cp% = 0 THEN%@NL@%
                        cp% = wide%%@NL@%
                        rp% = rp% - 1%@NL@%
                    END IF%@NL@%
                    sp% = wide% - cp% + 1%@NL@%
                    MID$(x$(rp%), cp%, sp%) = SPACE$(sp%)%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Clear out the possible Ctrl-Q signal%@AE@%%@NL@%
                ctrlQflag% = FALSE%@NL@%
%@NL@%
            END SELECT%@NL@%
%@NL@%
        LOOP UNTIL quit%%@NL@%
%@NL@%
%@AB@%      ' Concatenate the array strings to form the result%@AE@%%@NL@%
        a$ = ""%@NL@%
        FOR i% = 1 TO high%%@NL@%
            a$ = a$ + " " + LTRIM$(RTRIM$(x$(i%)))%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' Remove double spaces%@AE@%%@NL@%
        ds% = INSTR(a$, "  ")%@NL@%
        DO WHILE ds%%@NL@%
            a$ = LEFT$(a$, ds% - 1) + MID$(a$, ds% + 1)%@NL@%
            ds% = INSTR(a$, "  ")%@NL@%
        LOOP%@NL@%
%@NL@%
%@AB@%      ' Trim both ends of spaces%@AE@%%@NL@%
        a$ = LTRIM$(RTRIM$(a$))%@NL@%
%@NL@%
%@AB@%      ' Restore original cursor position%@AE@%%@NL@%
        LOCATE down%, across%, 1%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          EditLine                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        EDIT.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Allows the user to edit a string at the current cursor position%@AE@%%@NL@%
%@AB@%  ' on the screen.  Keys acted upon are Ctrl-Y, Ctrl-Q-Y, Right%@AE@%%@NL@%
%@AB@%  ' arrow, Left arrow, Ctrl-Left arrow, Ctrl-Right arrow, Home, End,%@AE@%%@NL@%
%@AB@%  ' Insert, Escape, Backspace, and Delete.%@AE@%%@NL@%
%@AB@%  ' Pressing Enter, Up arrow, or Down arrow terminates%@AE@%%@NL@%
%@AB@%  ' the subprogram and returns exitCode% of 0, +1, or -1.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  EditLine a$, exitCode%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String to be edited%@AE@%%@NL@%
%@AB@%  '                  exitCode%  Returned code indicating the terminating%@AE@%%@NL@%
%@AB@%  '                             key press%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       row%       Saved current cursor row%@AE@%%@NL@%
%@AB@%  '                  col%       Saved current cursor column%@AE@%%@NL@%
%@AB@%  '                  length%    Length of a$%@AE@%%@NL@%
%@AB@%  '                  ptr%       Location of cursor during the editing%@AE@%%@NL@%
%@AB@%  '                  insert%    Insert mode toggle%@AE@%%@NL@%
%@AB@%  '                  quit%      Flag for quitting the editing%@AE@%%@NL@%
%@AB@%  '                  original$  Saved copy of starting a$%@AE@%%@NL@%
%@AB@%  '                  keyNumber% Integer code for any key press%@AE@%%@NL@%
%@AB@%  '                  ctrlQflag% Indicates Ctrl-Q key press%@AE@%%@NL@%
%@AB@%  '                  kee$       Character of key just pressed%@AE@%%@NL@%
%@AB@%  '                  sp%        Length of space string%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION KeyCode% ()%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB EditLine (a$, exitCode%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB EditLine (a$, exitCode%) STATIC%@NL@%
%@NL@%
%@AB@%      ' Set up some variables%@AE@%%@NL@%
        row% = CSRLIN%@NL@%
        col% = POS(0)%@NL@%
        length% = LEN(a$)%@NL@%
        ptr% = 0%@NL@%
        insert% = TRUE%@NL@%
        quit% = FALSE%@NL@%
        original$ = a$%@NL@%
%@NL@%
%@AB@%      ' Main processing loop%@AE@%%@NL@%
        DO%@NL@%
%@NL@%
%@AB@%          ' Display the line%@AE@%%@NL@%
            LOCATE row%, col%, 0%@NL@%
            PRINT a$;%@NL@%
%@NL@%
%@AB@%          ' Show appropriate cursor type%@AE@%%@NL@%
            IF insert% THEN%@NL@%
                LOCATE row%, col% + ptr%, 1, 6, 7%@NL@%
            ELSE%@NL@%
                LOCATE row%, col% + ptr%, 1, 1, 7%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Get next keystroke%@AE@%%@NL@%
            keyNumber% = KeyCode%%@NL@%
%@NL@%
%@AB@%          ' Process the key%@AE@%%@NL@%
            SELECT CASE keyNumber%%@NL@%
%@NL@%
            CASE INSERTKEY%@NL@%
                IF insert% THEN%@NL@%
                    insert% = FALSE%@NL@%
                ELSE%@NL@%
                    insert% = TRUE%@NL@%
                END IF%@NL@%
%@NL@%
            CASE BACKSPACE%@NL@%
                IF ptr% THEN%@NL@%
                    a$ = a$ + " "%@NL@%
                    a$ = LEFT$(a$, ptr% - 1) + MID$(a$, ptr% + 1)%@NL@%
                    ptr% = ptr% - 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE DELETE%@NL@%
                a$ = a$ + " "%@NL@%
                a$ = LEFT$(a$, ptr%) + MID$(a$, ptr% + 2)%@NL@%
%@NL@%
            CASE UPARROW%@NL@%
                exitCode% = 1%@NL@%
                quit% = TRUE%@NL@%
%@NL@%
            CASE DOWNARROW%@NL@%
                exitCode% = -1%@NL@%
                quit% = TRUE%@NL@%
%@NL@%
            CASE LEFTARROW%@NL@%
                IF ptr% THEN%@NL@%
                    ptr% = ptr% - 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE RIGHTARROW%@NL@%
                IF ptr% < length% - 1 THEN%@NL@%
                    ptr% = ptr% + 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE ENTER%@NL@%
                exitCode% = 0%@NL@%
                quit% = TRUE%@NL@%
%@NL@%
            CASE HOME%@NL@%
                ptr% = 0%@NL@%
%@NL@%
            CASE ENDKEY%@NL@%
                ptr% = length% - 1%@NL@%
%@NL@%
            CASE CTRLRIGHTARROW%@NL@%
                DO UNTIL MID$(a$, ptr% + 1, 1) = " " OR ptr% = length% - 1%@NL@%
                    ptr% = ptr% + 1%@NL@%
                LOOP%@NL@%
                DO UNTIL MID$(a$, ptr% + 1, 1) <> " " OR ptr% = length% - 1%@NL@%
                    ptr% = ptr% + 1%@NL@%
                LOOP%@NL@%
%@NL@%
            CASE CTRLLEFTARROW%@NL@%
                DO UNTIL MID$(a$, ptr% + 1, 1) = " " OR ptr% = 0%@NL@%
                    ptr% = ptr% - 1%@NL@%
                LOOP%@NL@%
                DO UNTIL MID$(a$, ptr% + 1, 1) <> " " OR ptr% = 0%@NL@%
                    ptr% = ptr% - 1%@NL@%
                LOOP%@NL@%
                DO UNTIL MID$(a$, ptr% + 1, 1) = " " OR ptr% = 0%@NL@%
                    ptr% = ptr% - 1%@NL@%
                LOOP%@NL@%
                IF ptr% THEN%@NL@%
                    ptr% = ptr% + 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE CTRLY%@NL@%
                a$ = SPACE$(length%)%@NL@%
                ptr% = 0%@NL@%
%@NL@%
            CASE CTRLQ%@NL@%
                ctrlQflag% = TRUE%@NL@%
%@NL@%
            CASE ESCAPE%@NL@%
                a$ = original$%@NL@%
                ptr% = 0%@NL@%
                insert% = TRUE%@NL@%
%@NL@%
            CASE IS > 255%@NL@%
                SOUND 999, 1%@NL@%
%@NL@%
            CASE IS < 32%@NL@%
                SOUND 999, 1%@NL@%
%@NL@%
            CASE ELSE%@NL@%
%@NL@%
%@AB@%              ' Convert key code to character string%@AE@%%@NL@%
                kee$ = CHR$(keyNumber%)%@NL@%
%@NL@%
%@AB@%              ' Insert or overstrike%@AE@%%@NL@%
                IF insert% THEN%@NL@%
                    a$ = LEFT$(a$, ptr%) + kee$ + MID$(a$, ptr% + 1)%@NL@%
                    a$ = LEFT$(a$, length%)%@NL@%
                ELSE%@NL@%
                    IF ptr% < length% THEN%@NL@%
                        MID$(a$, ptr% + 1, 1) = kee$%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Are we up against the wall?%@AE@%%@NL@%
                IF ptr% < length% THEN%@NL@%
                    ptr% = ptr% + 1%@NL@%
                ELSE%@NL@%
                    SOUND 999, 1%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Special check for Ctrl-Q-Y (del to end of line)%@AE@%%@NL@%
                IF kee$ = "y" AND ctrlQflag% THEN%@NL@%
                    IF ptr% <= length% THEN%@NL@%
                        sp% = length% - ptr% + 1%@NL@%
                        MID$(a$, ptr%, sp%) = SPACE$(sp%)%@NL@%
                        ptr% = ptr% - 1%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Clear out the Ctrl-Q signal%@AE@%%@NL@%
                ctrlQflag% = FALSE%@NL@%
%@NL@%
            END SELECT%@NL@%
%@NL@%
        LOOP UNTIL quit%%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FormatTwo                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        EDIT.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Splits a string into two strings between words,%@AE@%%@NL@%
%@AB@%  ' and with spaces padded to the first string to bring it to%@AE@%%@NL@%
%@AB@%  ' length, col%.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  FormatTwo a$, b$, col%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String to be split%@AE@%%@NL@%
%@AB@%  '                  b$         Returns the tail of the string%@AE@%%@NL@%
%@AB@%  '                  col%       Maximum length of a$ after being split%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       ptr%       Pointer to split point in a$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB FormatTwo (a$, b$, col%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FormatTwo (a$, b$, col%) STATIC%@NL@%
%@NL@%
%@AB@%      ' Be sure string is long enough%@AE@%%@NL@%
        a$ = a$ + SPACE$(col%)%@NL@%
%@NL@%
%@AB@%      ' Look for rightmost space%@AE@%%@NL@%
        ptr% = col% + 1%@NL@%
        DO WHILE MID$(a$, ptr%, 1) <> " " AND ptr% > 1%@NL@%
            ptr% = ptr% - 1%@NL@%
        LOOP%@NL@%
%@NL@%
%@AB@%      ' Do the split%@AE@%%@NL@%
        IF ptr% = 1 THEN%@NL@%
            b$ = MID$(a$, col% + 1)%@NL@%
            a$ = LEFT$(a$, col%)%@NL@%
        ELSE%@NL@%
            b$ = MID$(a$, ptr% + 1)%@NL@%
            a$ = LEFT$(a$, ptr% - 1)%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Pad the first string with spaces to length col%%@AE@%%@NL@%
        a$ = LEFT$(a$ + SPACE$(col%), col%)%@NL@%
%@NL@%
%@AB@%      ' Trim extra spaces from end of second string%@AE@%%@NL@%
        b$ = RTRIM$(b$)%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          InsertCharacter            **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        EDIT.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Handles the task of inserting a character%@AE@%%@NL@%
%@AB@%  ' for the EditBox subprogram.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  InsertCharacter x$(), kee$, rp%, cp%, wide%, high%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x$()       Array in EditBox where character is to be%@AE@%%@NL@%
%@AB@%  '                             inserted%@AE@%%@NL@%
%@AB@%  '                  kee$       Character to be inserted%@AE@%%@NL@%
%@AB@%  '                  rp%        Row location of insert%@AE@%%@NL@%
%@AB@%  '                  cp%        Column location of insert%@AE@%%@NL@%
%@AB@%  '                  wide%      Width of rectangular area being edited%@AE@%%@NL@%
%@AB@%  '                  high%      Height of rectangular area being edited%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       dum$       Marker character%@AE@%%@NL@%
%@AB@%  '                  b$         String from array at insertion point%@AE@%%@NL@%
%@AB@%  '                  c$         Right part of string at insertion point%@AE@%%@NL@%
%@AB@%  '                  i%         Looping index%@AE@%%@NL@%
%@AB@%  '                  ds%        Position in string of double spaces%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB InsertCharacter (x$(), kee$, cp%, rp%,%@AE@%%@NL@%
%@AB@%  '                                               wide%, high%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB InsertCharacter (x$(), kee$, rp%, cp%, wide%, high%) STATIC%@NL@%
%@NL@%
%@AB@%      ' First, insert a dummy character as a marker%@AE@%%@NL@%
        dum$ = CHR$(255)%@NL@%
        b$ = LEFT$(x$(rp%), cp% - 1)%@NL@%
        c$ = MID$(x$(rp%), cp%)%@NL@%
        b$ = b$ + dum$ + c$%@NL@%
%@NL@%
%@AB@%      ' If end of string is a space, then drop it%@AE@%%@NL@%
        IF RIGHT$(b$, 1) = " " THEN%@NL@%
            x$(rp%) = LEFT$(b$, wide%)%@NL@%
%@NL@%
%@AB@%      ' Otherwise, need to adjust the lines%@AE@%%@NL@%
        ELSE%@NL@%
%@NL@%
%@AB@%          ' If not in the last line, then tack them all together%@AE@%%@NL@%
            IF rp% < high% THEN%@NL@%
                FOR i% = rp% + 1 TO high%%@NL@%
                    b$ = b$ + " " + x$(i%)%@NL@%
                NEXT i%%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Trim both ends%@AE@%%@NL@%
            b$ = LTRIM$(RTRIM$(b$))%@NL@%
%@NL@%
%@AB@%          ' Remove all double spaces%@AE@%%@NL@%
            ds% = INSTR(b$, "  ")%@NL@%
            DO WHILE ds%%@NL@%
                b$ = LEFT$(b$, ds% - 1) + MID$(b$, ds% + 1)%@NL@%
                ds% = INSTR(b$, "  ")%@NL@%
            LOOP%@NL@%
%@NL@%
%@AB@%          ' Reformat the lines%@AE@%%@NL@%
            FOR i% = rp% TO high%%@NL@%
                FormatTwo b$, c$, wide%%@NL@%
                x$(i%) = b$%@NL@%
                b$ = c$%@NL@%
            NEXT i%%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Find out where that dummy character is now%@AE@%%@NL@%
        FOR rp% = 1 TO high%%@NL@%
            cp% = INSTR(x$(rp%), dum$)%@NL@%
            IF cp% THEN%@NL@%
                EXIT FOR%@NL@%
            END IF%@NL@%
        NEXT rp%%@NL@%
%@NL@%
%@AB@%      ' Replace the dummy character with the keystroke character%@AE@%%@NL@%
        IF cp% THEN%@NL@%
            MID$(x$(rp%), cp%, 1) = kee$%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Increment the cursor location%@AE@%%@NL@%
        IF cp% < wide% + 1 THEN%@NL@%
            cp% = cp% + 1%@NL@%
        ELSE%@NL@%
            IF rp% < high% THEN%@NL@%
                cp% = 1%@NL@%
                rp% = rp% + 1%@NL@%
            END IF%@NL@%
        END IF%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%EDPAT.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\EDPAT.BAS%@AE@%%@NL@%
%@NL@%
DECLARE SUB DrawPattern ()%@NL@%
DECLARE SUB EditPattern ()%@NL@%
DECLARE SUB Initialize ()%@NL@%
DECLARE SUB ShowPattern (OK$)%@NL@%
%@NL@%
DIM Bit%(0 TO 7), Pattern$, Esc$, PatternSize%%@NL@%
%@NL@%
DO%@NL@%
   Initialize%@NL@%
   EditPattern%@NL@%
   ShowPattern OK$%@NL@%
LOOP WHILE OK$ = "Y"%@NL@%
%@NL@%
END%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================== DRAWPATTERN =======================%@AE@%%@NL@%
%@AB@%'    Draws a patterned rectangle on the right side of screen%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB DrawPattern STATIC%@NL@%
SHARED Pattern$%@NL@%
%@NL@%
   VIEW (320, 24)-(622, 160), 0, 1  ' Set view to rectangle%@NL@%
   PAINT (1, 1), Pattern$           ' Use PAINT to fill it%@NL@%
   VIEW                             ' Set view to full screen%@NL@%
%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================== EDITPATTERN =======================%@AE@%%@NL@%
%@AB@%'                  Edits a tile-byte pattern%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB EditPattern STATIC%@NL@%
SHARED Pattern$, Esc$, Bit%(), PatternSize%%@NL@%
%@NL@%
   ByteNum% = 1         ' Starting position.%@NL@%
   BitNum% = 7%@NL@%
   Null$ = CHR$(0)      ' CHR$(0) is the first byte of the%@NL@%
%@AB@%                        ' two-byte string returned when a%@AE@%%@NL@%
%@AB@%                        ' direction key such as UP or DOWN is%@AE@%%@NL@%
%@AB@%                        ' pressed.%@AE@%%@NL@%
   DO%@NL@%
%@NL@%
%@AB@%      ' Calculate starting location on screen of this bit:%@AE@%%@NL@%
      X% = ((7 - BitNum%) * 16) + 80%@NL@%
      Y% = (ByteNum% + 2) * 8%@NL@%
%@NL@%
%@AB@%      ' Wait for a key press (and flash cursor each 3/10 second):%@AE@%%@NL@%
      State% = 0%@NL@%
      RefTime = 0%@NL@%
      DO%@NL@%
%@NL@%
%@AB@%         ' Check timer and switch cursor state if 3/10 second:%@AE@%%@NL@%
         IF ABS(TIMER - RefTime) > .3 THEN%@NL@%
            RefTime = TIMER%@NL@%
            State% = 1 - State%%@NL@%
%@NL@%
%@AB@%            ' Turn the  border of bit on and off:%@AE@%%@NL@%
            LINE (X% - 1, Y% - 1)-STEP(15, 8), State%, B%@NL@%
         END IF%@NL@%
%@NL@%
         Check$ = INKEY$        ' Check for key press.%@NL@%
%@NL@%
      LOOP WHILE Check$ = ""    ' Loop until a key is pressed.%@NL@%
%@NL@%
%@AB@%      ' Erase cursor:%@AE@%%@NL@%
      LINE (X% - 1, Y% - 1)-STEP(15, 8), 0, B%@NL@%
%@NL@%
      SELECT CASE Check$        ' Respond to key press.%@NL@%
%@NL@%
         CASE CHR$(27)          ' ESC key pressed:%@NL@%
            EXIT SUB            ' exit this subprogram%@NL@%
%@NL@%
         CASE CHR$(32)          ' SPACEBAR pressed:%@NL@%
%@AB@%                                ' reset state of bit%@AE@%%@NL@%
%@NL@%
%@AB@%            ' Invert bit in pattern string:%@AE@%%@NL@%
            CurrentByte% = ASC(MID$(Pattern$, ByteNum%, 1))%@NL@%
            CurrentByte% = CurrentByte% XOR Bit%(BitNum%)%@NL@%
            MID$ (Pattern$, ByteNum%) = CHR$(CurrentByte%)%@NL@%
%@NL@%
%@AB@%            ' Redraw bit on screen:%@AE@%%@NL@%
            IF (CurrentByte% AND Bit%(BitNum%)) <> 0 THEN%@NL@%
                CurrentColor% = 1%@NL@%
            ELSE%@NL@%
                CurrentColor% = 0%@NL@%
            END IF%@NL@%
            LINE (X% + 1, Y% + 1)-STEP(11, 4), CurrentColor%, BF%@NL@%
%@NL@%
         CASE CHR$(13)           ' ENTER key pressed:%@NL@%
            DrawPattern          ' draw pattern in box on right.%@NL@%
%@NL@%
         CASE Null$ + CHR$(75)   ' LEFT key: move cursor left%@NL@%
%@NL@%
            BitNum% = BitNum% + 1%@NL@%
            IF BitNum% > 7 THEN BitNum% = 0%@NL@%
%@NL@%
         CASE Null$ + CHR$(77)   ' RIGHT key: move cursor right%@NL@%
%@NL@%
            BitNum% = BitNum% - 1%@NL@%
            IF BitNum% < 0 THEN BitNum% = 7%@NL@%
%@NL@%
         CASE Null$ + CHR$(72)   ' UP key: move cursor up%@NL@%
%@NL@%
            ByteNum% = ByteNum% - 1%@NL@%
            IF ByteNum% < 1 THEN ByteNum% = PatternSize%%@NL@%
%@NL@%
         CASE Null$ + CHR$(80)   ' DOWN key: move cursor down%@NL@%
%@NL@%
            ByteNum% = ByteNum% + 1%@NL@%
            IF ByteNum% > PatternSize% THEN ByteNum% = 1%@NL@%
%@NL@%
         CASE ELSE%@NL@%
%@AB@%            ' User pressed a key other than ESC, SPACEBAR,%@AE@%%@NL@%
%@AB@%            ' ENTER, UP, DOWN, LEFT, or RIGHT, so don't%@AE@%%@NL@%
%@AB@%            ' do anything.%@AE@%%@NL@%
      END SELECT%@NL@%
   LOOP%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================== INITIALIZE ========================%@AE@%%@NL@%
%@AB@%'               Sets up starting pattern and screen%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB Initialize STATIC%@NL@%
SHARED Pattern$, Esc$, Bit%(), PatternSize%%@NL@%
%@NL@%
   Esc$ = CHR$(27)              ' ESC character is ASCII 27.%@NL@%
%@NL@%
%@AB@%   ' Set up an array holding bits in positions 0 to 7:%@AE@%%@NL@%
   FOR I% = 0 TO 7%@NL@%
      Bit%(I%) = 2 ^ I%%@NL@%
   NEXT I%%@NL@%
%@NL@%
   CLS%@NL@%
%@NL@%
%@AB@%   ' Input the pattern size (in number of bytes):%@AE@%%@NL@%
   LOCATE 5, 5%@NL@%
   PRINT "Enter pattern size (1-16 rows):";%@NL@%
   DO%@NL@%
      LOCATE 5, 38%@NL@%
      PRINT "    ";%@NL@%
      LOCATE 5, 38%@NL@%
      INPUT "", PatternSize%%@NL@%
   LOOP WHILE PatternSize% < 1 OR PatternSize% > 16%@NL@%
%@NL@%
%@AB@%   ' Set initial pattern to all bits set:%@AE@%%@NL@%
   Pattern$ = STRING$(PatternSize%, 255)%@NL@%
%@NL@%
   SCREEN 2                ' 640 x 200 monochrome graphics mode.%@NL@%
%@NL@%
%@AB@%   ' Draw dividing lines:%@AE@%%@NL@%
   LINE (0, 10)-(635, 10), 1%@NL@%
   LINE (300, 0)-(300, 199)%@NL@%
   LINE (302, 0)-(302, 199)%@NL@%
%@NL@%
%@AB@%   ' Print titles:%@AE@%%@NL@%
   LOCATE 1, 13: PRINT "Pattern Bytes"%@NL@%
   LOCATE 1, 53: PRINT "Pattern View"%@NL@%
%@NL@%
%@AB@%   ' Draw editing screen for pattern:%@AE@%%@NL@%
   FOR I% = 1 TO PatternSize%%@NL@%
%@NL@%
%@AB@%      ' Print label on left of each line:%@AE@%%@NL@%
      LOCATE I% + 3, 8%@NL@%
      PRINT USING "##:"; I%%@NL@%
%@NL@%
%@AB@%      ' Draw "bit" boxes:%@AE@%%@NL@%
      X% = 80%@NL@%
      Y% = (I% + 2) * 8%@NL@%
      FOR J% = 1 TO 8%@NL@%
         LINE (X%, Y%)-STEP(13, 6), 1, BF%@NL@%
         X% = X% + 16%@NL@%
      NEXT J%%@NL@%
   NEXT I%%@NL@%
%@NL@%
   DrawPattern                  ' Draw  "Pattern View" box.%@NL@%
%@NL@%
   LOCATE 21, 1%@NL@%
   PRINT "DIRECTION keys........Move cursor"%@NL@%
   PRINT "SPACEBAR............Changes point"%@NL@%
   PRINT "ENTER............Displays pattern"%@NL@%
   PRINT "ESC.........................Quits";%@NL@%
%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================== SHOWPATTERN =======================%@AE@%%@NL@%
%@AB@%'     Prints the CHR$ values used by PAINT to make pattern%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ShowPattern (OK$) STATIC%@NL@%
SHARED Pattern$, PatternSize%%@NL@%
%@NL@%
%@AB@%   ' Return screen to 80-column text mode:%@AE@%%@NL@%
   SCREEN 0, 0%@NL@%
   WIDTH 80%@NL@%
%@NL@%
   PRINT "The following characters make up your pattern:"%@NL@%
   PRINT%@NL@%
%@NL@%
%@AB@%   ' Print out the value for each pattern byte:%@AE@%%@NL@%
   FOR I% = 1 TO PatternSize%%@NL@%
      PatternByte% = ASC(MID$(Pattern$, I%, 1))%@NL@%
      PRINT "CHR$("; LTRIM$(STR$(PatternByte%)); ")"%@NL@%
   NEXT I%%@NL@%
%@NL@%
   PRINT%@NL@%
   LOCATE , , 1%@NL@%
   PRINT "New pattern? ";%@NL@%
   OK$ = UCASE$(INPUT$(1))%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ENTAB.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\ENTAB.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' ENTAB.BAS%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Replace runs of spaces in a file with tabs.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
DECLARE SUB SetTabPos ()%@NL@%
DECLARE SUB StripCommand (CLine$)%@NL@%
%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
DECLARE FUNCTION ThisIsATab (Column AS INTEGER)%@NL@%
%@NL@%
CONST MAXLINE = 255%@NL@%
CONST TABSPACE = 8%@NL@%
CONST NO = 0, YES = NOT NO%@NL@%
%@NL@%
DIM SHARED TabStops(MAXLINE) AS INTEGER%@NL@%
%@NL@%
StripCommand (COMMAND$)%@NL@%
%@NL@%
%@AB@%' Set the tab positions (uses the global array TabStops).%@AE@%%@NL@%
SetTabPos%@NL@%
%@NL@%
LastColumn = 1%@NL@%
%@NL@%
DO%@NL@%
%@NL@%
   CurrentColumn = LastColumn%@NL@%
%@NL@%
%@AB@%' Replace a run of blanks with a tab when you reach a tab%@AE@%%@NL@%
%@AB@%' column. CurrentColumn is the current column read.%@AE@%%@NL@%
%@AB@%' LastColumn is the last column that was printed.%@AE@%%@NL@%
   DO%@NL@%
      C$ = INPUT$(1,#1)%@NL@%
      IF C$ <> " " AND C$ <> CHR$(9) THEN EXIT DO%@NL@%
      CurrentColumn = CurrentColumn + 1%@NL@%
      IF C$=CHR$(9) OR ThisIsATab(CurrentColumn) THEN%@NL@%
%@AB@%         ' Go to a tab column if we have a tab and this%@AE@%%@NL@%
%@AB@%         ' is not a tab column.%@AE@%%@NL@%
         DO WHILE NOT ThisIsATab(CurrentColumn)%@NL@%
            CurrentColumn=CurrentColumn+1%@NL@%
         LOOP%@NL@%
         PRINT #2, CHR$(9);%@NL@%
         LastColumn = CurrentColumn%@NL@%
      END IF%@NL@%
   LOOP%@NL@%
%@NL@%
%@AB@%' Print out any blanks left over.%@AE@%%@NL@%
   DO WHILE LastColumn < CurrentColumn%@NL@%
      PRINT #2, " ";%@NL@%
      LastColumn = LastColumn + 1%@NL@%
   LOOP%@NL@%
%@NL@%
%@AB@%' Print the non-blank character.%@AE@%%@NL@%
   PRINT #2, C$;%@NL@%
%@NL@%
%@AB@%' Reset the column position if this is the end of a line.%@AE@%%@NL@%
   IF C$ = CHR$(10) THEN%@NL@%
      LastColumn = 1%@NL@%
   ELSE%@NL@%
      LastColumn = LastColumn + 1%@NL@%
   END IF%@NL@%
%@NL@%
LOOP UNTIL EOF(1)%@NL@%
CLOSE #1, #2%@NL@%
END%@NL@%
%@NL@%
%@AB@%'------------------SUB SetTabPos-------------------------%@AE@%%@NL@%
%@AB@%' Set the tab positions in the array TabStops.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB SetTabPos STATIC%@NL@%
   FOR I = 1 TO 255%@NL@%
      TabStops(I) = ((I MOD TABSPACE) = 1)%@NL@%
   NEXT I%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'------------------SUB StripCommand----------------------%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB StripCommand (CommandLine$) STATIC%@NL@%
   IF CommandLine$ = "" THEN%@NL@%
      INPUT "File to entab:   ", InFileName$%@NL@%
      INPUT "Store entabbed file in:   ", OutFileName$%@NL@%
   ELSE%@NL@%
      SpacePos = INSTR(CommandLine$, " ")%@NL@%
      IF SpacePos > 0 THEN%@NL@%
         InFileName$ = LEFT$(CommandLine$, SpacePos - 1)%@NL@%
         OutFileName$ = LTRIM$(MID$(CommandLine$, SpacePos))%@NL@%
      ELSE%@NL@%
         InFileName$ = CommandLine$%@NL@%
         INPUT "Store entabbed file in:   ", OutFileName$%@NL@%
      END IF%@NL@%
   END IF%@NL@%
   OPEN InFileName$ FOR INPUT AS #1%@NL@%
   OPEN OutFileName$ FOR OUTPUT AS #2%@NL@%
END SUB%@NL@%
%@AB@%'---------------FUNCTION ThisIsATab----------------------%@AE@%%@NL@%
%@AB@%' Answer the question, "Is this a tab position?"%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION ThisIsATab (LastColumn AS INTEGER) STATIC%@NL@%
   IF LastColumn > MAXLINE THEN%@NL@%
      ThisIsATab = YES%@NL@%
   ELSE%@NL@%
      ThisIsATab = TabStops(LastColumn)%@NL@%
   END IF%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%ERROR.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\ERROR.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ERROR                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        ERROR.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Subprogram%@AE@%%@NL@%
    DECLARE SUB ErrorMessage (message$)%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the subprogram%@AE@%%@NL@%
%@NL@%
    ErrorMessage "This is a sample message for ErrorMessage"%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ErrorMessage               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        ERROR.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Displays an error message and then exits to the system.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE: ErrorMessage "This is a sample message for ErrorMessage"%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:     message$         String to be displayed in the error box%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      lm%              Length of message$ during processing%@AE@%%@NL@%
%@AB@%  '                 col%             Screen character column for left edge%@AE@%%@NL@%
%@AB@%  '                                  of error box%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '  DECLARATIONS:  DECLARE SUB ErrorMessage (message$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ErrorMessage (message$) STATIC%@NL@%
%@NL@%
%@AB@%      ' Define color constants%@AE@%%@NL@%
        CONST BLACK = 0%@NL@%
        CONST BLUE = 1%@NL@%
        CONST GREEN = 2%@NL@%
        CONST CYAN = 3%@NL@%
        CONST RED = 4%@NL@%
        CONST MAGENTA = 5%@NL@%
        CONST BROWN = 6%@NL@%
        CONST WHITE = 7%@NL@%
        CONST BRIGHT = 8%@NL@%
        CONST BLINK = 16%@NL@%
        CONST YELLOW = BROWN + BRIGHT%@NL@%
%@NL@%
%@AB@%      ' Trim off spaces on each end of message%@AE@%%@NL@%
        message$ = LTRIM$(RTRIM$(message$))%@NL@%
%@NL@%
%@AB@%      ' Make message length an odd number%@AE@%%@NL@%
        IF LEN(message$) MOD 2 = 0 THEN%@NL@%
            message$ = message$ + " "%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Minimum length of message is 9 characters%@AE@%%@NL@%
        DO WHILE LEN(message$) < 9%@NL@%
            message$ = " " + message$ + " "%@NL@%
        LOOP%@NL@%
%@NL@%
%@AB@%      ' Maximum length of message is 75%@AE@%%@NL@%
        message$ = LEFT$(message$, 75)%@NL@%
%@NL@%
%@AB@%      ' Initialization of display%@AE@%%@NL@%
        SCREEN 0%@NL@%
        WIDTH 80%@NL@%
        CLS%@NL@%
%@NL@%
%@AB@%      ' Calculate screen locations%@AE@%%@NL@%
        lm% = LEN(message$)%@NL@%
        col% = 38 - lm% \ 2%@NL@%
%@NL@%
%@AB@%      ' Create the error box%@AE@%%@NL@%
        COLOR RED + BRIGHT, RED%@NL@%
        LOCATE 9, col%%@NL@%
        PRINT CHR$(201); STRING$(lm% + 2, 205); CHR$(187)%@NL@%
        LOCATE 10, col%%@NL@%
        PRINT CHR$(186); SPACE$(lm% + 2); CHR$(186)%@NL@%
        LOCATE 11, col%%@NL@%
        PRINT CHR$(186); SPACE$(lm% + 2); CHR$(186)%@NL@%
        LOCATE 12, col%%@NL@%
        PRINT CHR$(200); STRING$(lm% + 2, 205); CHR$(188)%@NL@%
%@NL@%
%@AB@%      ' The title%@AE@%%@NL@%
        COLOR CYAN + BRIGHT, RED%@NL@%
        LOCATE 10, 36%@NL@%
        PRINT "* ERROR *";%@NL@%
%@NL@%
%@AB@%      ' The message$%@AE@%%@NL@%
        COLOR YELLOW, RED%@NL@%
        LOCATE 11, col% + 2%@NL@%
        PRINT message$;%@NL@%
%@NL@%
%@AB@%      ' System will prompt for "any key"%@AE@%%@NL@%
        COLOR WHITE, BLACK%@NL@%
        LOCATE 22, 1%@NL@%
        SYSTEM%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FIGETPUT.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\FIGETPUT.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FIGETPUT                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FIGETPUT.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Reads itself (FIGETPUT.BAS) into a string,%@AE@%%@NL@%
%@AB@%  ' converts characters to uppercase, counts occurrences of%@AE@%%@NL@%
%@AB@%  ' the characters "A" through "Z," and saves the%@AE@%%@NL@%
%@AB@%  ' result in a file named FIGETPUT.TST.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      filename%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       count%()   Tally array for the 26 alpha characters%@AE@%%@NL@%
%@AB@%  '                  fileName$  Name of file to be processed%@AE@%%@NL@%
%@AB@%  '                  a$         Contents of the file%@AE@%%@NL@%
%@AB@%  '                  i%         Looping index%@AE@%%@NL@%
%@AB@%  '                  c%         ASCII value of each file byte%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION FileGet$ (fileName$)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB FilePut (fileName$, a$)%@NL@%
%@NL@%
%@AB@%  ' Dimension array of counts for each ASCII code "A" to "Z"%@AE@%%@NL@%
    DIM count%(65 TO 90)%@NL@%
%@NL@%
%@AB@%  ' Read in the file (must be no greater than 32767 bytes long)%@AE@%%@NL@%
    a$ = FileGet$("FIGETPUT.BAS")%@NL@%
%@NL@%
%@AB@%  ' Convert to uppercase%@AE@%%@NL@%
    a$ = UCASE$(a$)%@NL@%
%@NL@%
%@AB@%  ' Count the letters%@AE@%%@NL@%
    FOR i% = 1 TO LEN(a$)%@NL@%
        c% = ASC(MID$(a$, i%, 1))%@NL@%
        IF c% >= 65 AND c% <= 90 THEN%@NL@%
            count%(c%) = count%(c%) + 1%@NL@%
        END IF%@NL@%
    NEXT i%%@NL@%
%@NL@%
%@AB@%  ' Output the results%@AE@%%@NL@%
    CLS%@NL@%
    PRINT "Alphabetic character count for FIGETPUT.BAS"%@NL@%
    PRINT%@NL@%
    FOR i% = 65 TO 90%@NL@%
        PRINT CHR$(i%); " -"; count%(i%),%@NL@%
    NEXT i%%@NL@%
%@NL@%
%@AB@%  ' Write out the new file%@AE@%%@NL@%
    FilePut "FIGETPUT.TST", a$%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    END%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FileGet$                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FIGETPUT.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a string containing the contents of a file.%@AE@%%@NL@%
%@AB@%  ' Maximum file length is 32767 bytes.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  a$ = FileGet$(fileName$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      fileName$     Name of file to be accessed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       fileNumber    Next available free file number%@AE@%%@NL@%
%@AB@%  '                  length&       Length of file%@AE@%%@NL@%
%@AB@%  '                  a$            String for binary read of file%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION FileGet$ (fileName$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION FileGet$ (fileName$) STATIC%@NL@%
        fileNumber = FREEFILE%@NL@%
        OPEN fileName$ FOR BINARY AS #fileNumber%@NL@%
        length& = LOF(fileNumber)%@NL@%
        IF length& <= 32767 THEN%@NL@%
            a$ = SPACE$(length&)%@NL@%
            GET #fileNumber, , a$%@NL@%
            FileGet$ = a$%@NL@%
            a$ = ""%@NL@%
        ELSE%@NL@%
            PRINT "FileGet$()... file too large"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
        CLOSE #fileNumber%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FilePut                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FIGETPUT.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Writes contents of a$ into a binary file named fileName$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  FilePut fileName$, a$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      fileName$  Name of file to be written%@AE@%%@NL@%
%@AB@%  '                  a$         Bytes to be placed in the file%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       fileNumber Next available free file number%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB FilePut (fileName$, a$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FilePut (fileName$, a$) STATIC%@NL@%
%@NL@%
%@AB@%      ' Find available file number%@AE@%%@NL@%
        fileNumber = FREEFILE%@NL@%
%@NL@%
%@AB@%      ' Truncate any previous contents%@AE@%%@NL@%
        OPEN fileName$ FOR OUTPUT AS #fileNumber%@NL@%
        CLOSE #fileNumber%@NL@%
%@NL@%
%@AB@%      ' Write string to file%@AE@%%@NL@%
        OPEN fileName$ FOR BINARY AS #fileNumber%@NL@%
        PUT #fileNumber, , a$%@NL@%
%@NL@%
%@AB@%      ' All done%@AE@%%@NL@%
        CLOSE #fileNumber%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FILEINFO.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\FILEINFO.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FILEINFO                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FILEINFO.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Collection of subprograms and functions for accessing%@AE@%%@NL@%
%@AB@%  ' directory information about files.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:    MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       path$      Path to files for gathering directory%@AE@%%@NL@%
%@AB@%  '                             information; wildcard characters accepted%@AE@%%@NL@%
%@AB@%  '                  dta$       Disk transfer area buffer string%@AE@%%@NL@%
%@AB@%  '                  result%    Code returned as result of directory search%@AE@%%@NL@%
%@AB@%  '                  file       Structure of type FileDataType%@AE@%%@NL@%
%@AB@%  '                  n%         File count%@AE@%%@NL@%
%@NL@%
%@AB@%  ' File search attribute bits%@AE@%%@NL@%
    CONST ISNORMAL = 0%@NL@%
    CONST ISREADONLY = 1%@NL@%
    CONST ISHIDDEN = 2%@NL@%
    CONST ISSYSTEM = 4%@NL@%
    CONST ISVOLUMELABEL = 8%@NL@%
    CONST ISSUBDIRECTORY = 16%@NL@%
    CONST ISARCHIVED = 32%@NL@%
%@NL@%
%@AB@%  ' Here we'll search for normal files and subdirectories%@AE@%%@NL@%
    CONST FILEATTRIBUTE = ISNORMAL + ISSUBDIRECTORY%@NL@%
%@NL@%
    TYPE RegTypeX%@NL@%
        ax    AS INTEGER%@NL@%
        bx    AS INTEGER%@NL@%
        cx    AS INTEGER%@NL@%
        dx    AS INTEGER%@NL@%
        bp    AS INTEGER%@NL@%
        si    AS INTEGER%@NL@%
        di    AS INTEGER%@NL@%
        flags AS INTEGER%@NL@%
        ds    AS INTEGER%@NL@%
        es    AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE FileDataType%@NL@%
        finame    AS STRING * 12%@NL@%
        year      AS INTEGER%@NL@%
        month     AS INTEGER%@NL@%
        day       AS INTEGER%@NL@%
        hour      AS INTEGER%@NL@%
        minute    AS INTEGER%@NL@%
        second    AS INTEGER%@NL@%
        attribute AS INTEGER%@NL@%
        size      AS LONG%@NL@%
    END TYPE%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB INTERRUPTX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@NL@%
    DECLARE SUB FindFirstFile (path$, dta$, result%)%@NL@%
    DECLARE SUB FindNextFile (dta$, result%)%@NL@%
    DECLARE SUB GetFileData (dta$, file AS FileDataType)%@NL@%
%@NL@%
%@AB@%  ' Data structures%@AE@%%@NL@%
    DIM file AS FileDataType%@NL@%
%@NL@%
%@AB@%  ' For demonstration purposes, list current directory%@AE@%%@NL@%
    CLS%@NL@%
    path$ = "*.*"%@NL@%
%@NL@%
%@AB@%  ' Always start by finding the first match%@AE@%%@NL@%
    FindFirstFile path$, dta$, result%%@NL@%
%@NL@%
%@AB@%  ' Check that the path$ got us off to a good start%@AE@%%@NL@%
    IF result% THEN%@NL@%
        PRINT "Error: FindFirstFile - found no match for path$"%@NL@%
        SYSTEM%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' List all the files in this directory%@AE@%%@NL@%
    DO%@NL@%
        IF n% MOD 19 = 0 THEN%@NL@%
            CLS%@NL@%
            PRINT TAB(4); "File"; TAB(18); "Date"; TAB(29); "Time";%@NL@%
            PRINT TAB(39); "Size"; TAB(48); "Attributes"%@NL@%
            PRINT%@NL@%
        END IF%@NL@%
        GetFileData dta$, file%@NL@%
        PRINT file.finame;%@NL@%
        PRINT USING "  ##/##/####"; file.month, file.day, file.year;%@NL@%
        PRINT USING "  ##:##:##"; file.hour, file.minute, file.second;%@NL@%
        PRINT USING "  ########"; file.size;%@NL@%
        PRINT SPACE$(6);%@NL@%
        PRINT "&H";%@NL@%
        PRINT RIGHT$("0" + HEX$(file.attribute), 2)%@NL@%
        n% = n% + 1%@NL@%
        FindNextFile dta$, result%%@NL@%
        IF n% MOD 19 = 0 THEN%@NL@%
            PRINT%@NL@%
            PRINT "Press any key to continue"%@NL@%
            DO%@NL@%
            LOOP WHILE INKEY$ = ""%@NL@%
        END IF%@NL@%
    LOOP UNTIL result%%@NL@%
    PRINT%@NL@%
    PRINT n%; "files found"%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FindFirstFile              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FILEINFO.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Finds first file that matches the path$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  FindFirstFile path$, dta$, result%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      path$      Complete path, including wildcard characters if%@AE@%%@NL@%
%@AB@%  '                             desired, for the directory search%@AE@%%@NL@%
%@AB@%  '                  dta$       Disk transfer area buffer space%@AE@%%@NL@%
%@AB@%  '                  result%    Returned result code for the search%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegTypeX%@AE@%%@NL@%
%@AB@%  '                  thePath$   Null terminated version of path$%@AE@%%@NL@%
%@AB@%  '                  sgmt%      Current DTA address segment%@AE@%%@NL@%
%@AB@%  '                  ofst%      Current DTA address offset%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  File search attribute bits%@AE@%%@NL@%
%@AB@%  '                     CONST ISNORMAL = 0%@AE@%%@NL@%
%@AB@%  '                     CONST ISREADONLY = 1%@AE@%%@NL@%
%@AB@%  '                     CONST ISHIDDEN = 2%@AE@%%@NL@%
%@AB@%  '                     CONST ISSYSTEM = 4%@AE@%%@NL@%
%@AB@%  '                     CONST ISVOLUMELABEL = 8%@AE@%%@NL@%
%@AB@%  '                     CONST ISSUBDIRECTORY = 16%@AE@%%@NL@%
%@AB@%  '                     CONST ISARCHIVED = 32%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                     CONST FILEATTRIBUTE = ISNORMAL + ISSUBDIRECTORY%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                     TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                        ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        ds    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        es    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB INTERRUPTX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB FindFirstFile (path$, dta$, result%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FindFirstFile (path$, dta$, result%) STATIC%@NL@%
%@NL@%
%@AB@%      ' Initialization%@AE@%%@NL@%
        DIM reg AS RegTypeX%@NL@%
%@NL@%
%@AB@%      ' The path must be a null terminated string%@AE@%%@NL@%
        thePath$ = path$ + CHR$(0)%@NL@%
%@NL@%
%@AB@%      ' Get current DTA address%@AE@%%@NL@%
        reg.ax = &H2F00%@NL@%
        INTERRUPTX &H21, reg, reg%@NL@%
        sgmt% = reg.es%@NL@%
        ofst% = reg.bx%@NL@%
%@NL@%
%@AB@%      ' Set dta address%@AE@%%@NL@%
        dta$ = SPACE$(43)%@NL@%
        reg.ax = &H1A00%@NL@%
        reg.ds = VARSEG(dta$)%@NL@%
        reg.dx = SADD(dta$)%@NL@%
        INTERRUPTX &H21, reg, reg%@NL@%
%@NL@%
%@AB@%      ' Find first file match%@AE@%%@NL@%
        reg.ax = &H4E00%@NL@%
        reg.cx = FILEATTRIBUTE%@NL@%
        reg.ds = VARSEG(thePath$)%@NL@%
        reg.dx = SADD(thePath$)%@NL@%
        INTERRUPTX &H21, reg, reg%@NL@%
%@NL@%
%@AB@%      ' The carry flag tells if a file was found or not%@AE@%%@NL@%
        result% = reg.flags AND 1%@NL@%
%@NL@%
%@AB@%      ' Reset the original DTA%@AE@%%@NL@%
        reg.ax = &H1A00%@NL@%
        reg.ds = sgmt%%@NL@%
        reg.dx = ofst%%@NL@%
        INTERRUPTX &H21, reg, reg%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FindNextFile               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FILEINFO.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Locates next file. FindFirstFile must be called%@AE@%%@NL@%
%@AB@%  ' before this subprogram is called.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE: FindNextFile dta$, result%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dta$       Previously filled-in Disk Transfer Area%@AE@%%@NL@%
%@AB@%  '                             buffer string%@AE@%%@NL@%
%@AB@%  '                  result%    Result code for the search%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       reg        Structure of type RegTypeX%@AE@%%@NL@%
%@AB@%  '                  thePath$   Null terminated version of path$%@AE@%%@NL@%
%@AB@%  '                  sgmt%      Current DTA address segment%@AE@%%@NL@%
%@AB@%  '                  ofst%      Current DTA address offset%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  CONST ISNORMAL = 0%@AE@%%@NL@%
%@AB@%  '                  CONST ISREADONLY = 1%@AE@%%@NL@%
%@AB@%  '                  CONST ISHIDDEN = 2%@AE@%%@NL@%
%@AB@%  '                  CONST ISSYSTEM = 4%@AE@%%@NL@%
%@AB@%  '                  CONST ISVOLUMELABEL = 8%@AE@%%@NL@%
%@AB@%  '                  CONST ISSUBDIRECTORY = 16%@AE@%%@NL@%
%@AB@%  '                  CONST ISARCHIVED = 32%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  CONST FILEATTRIBUTE = ISNORMAL + ISSUBDIRECTORY%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                     TYPE RegTypeX%@AE@%%@NL@%
%@AB@%  '                        ax    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        bx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        cx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        dx    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        bp    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        si    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        di    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        flags AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        ds    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                        es    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB INTERRUPTX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@AE@%%@NL@%
%@AB@%  '   DECLARE SUB FindNextFile (dta$, result%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FindNextFile (dta$, result%) STATIC%@NL@%
%@NL@%
%@AB@%      ' Initialization%@AE@%%@NL@%
        DIM reg AS RegTypeX%@NL@%
%@NL@%
%@AB@%      ' Be sure dta$ was built (FindFirstFile should have been called)%@AE@%%@NL@%
        IF LEN(dta$) <> 43 THEN%@NL@%
            result% = 2%@NL@%
            EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Get current DTA address%@AE@%%@NL@%
        reg.ax = &H2F00%@NL@%
        INTERRUPTX &H21, reg, reg%@NL@%
        sgmt% = reg.es%@NL@%
        ofst% = reg.bx%@NL@%
%@NL@%
%@AB@%      ' Set dta address%@AE@%%@NL@%
        reg.ax = &H1A00%@NL@%
        reg.ds = VARSEG(dta$)%@NL@%
        reg.dx = SADD(dta$)%@NL@%
        INTERRUPTX &H21, reg, reg%@NL@%
%@NL@%
%@AB@%      ' Find next file match%@AE@%%@NL@%
        reg.ax = &H4F00%@NL@%
        reg.cx = FILEATTRIBUTE%@NL@%
        reg.ds = VARSEG(thePath$)%@NL@%
        reg.dx = SADD(thePath$)%@NL@%
        INTERRUPTX &H21, reg, reg%@NL@%
%@NL@%
%@AB@%      ' The carry flag tells whether a file was found or not%@AE@%%@NL@%
        result% = reg.flags AND 1%@NL@%
%@NL@%
%@AB@%      ' Reset the original DTA%@AE@%%@NL@%
        reg.ax = &H1A00%@NL@%
        reg.ds = sgmt%%@NL@%
        reg.dx = ofst%%@NL@%
        INTERRUPTX &H21, reg, reg%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetFileData                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FILEINFO.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Extracts the file directory information from a Disk%@AE@%%@NL@%
%@AB@%  ' Transfer Area (dta$) that has been filled in by a%@AE@%%@NL@%
%@AB@%  ' call to either FindFirstFile or FindNextFile.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  GetFileData dta$, file%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      dta$       Disk Transfer Area buffer string passed back from%@AE@%%@NL@%
%@AB@%  '                             either FindFirstFile or FindNextFile%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       tim&       Time stamp of the file%@AE@%%@NL@%
%@AB@%  '                  dat&       Date stamp of the file%@AE@%%@NL@%
%@AB@%  '                  f$         Filename during extraction%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE FileDataType%@AE@%%@NL@%
%@AB@%  '                     finame    AS STRING * 12%@AE@%%@NL@%
%@AB@%  '                     year      AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     month     AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     day       AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     hour      AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     minute    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     second    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     attribute AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     size      AS LONG%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB GetFileData (dta$, file AS FileDataType)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB GetFileData (dta$, file AS FileDataType) STATIC%@NL@%
%@NL@%
        file.attribute = ASC(MID$(dta$, 22, 1))%@NL@%
        tim& = CVI(MID$(dta$, 23, 2))%@NL@%
        IF tim& < 0 THEN%@NL@%
            tim& = tim& + 65536%@NL@%
        END IF%@NL@%
        file.second = tim& AND &H1F%@NL@%
        file.minute = (tim& \ 32) AND &H3F%@NL@%
        file.hour = (tim& \ 2048) AND &H1F%@NL@%
        dat& = CVI(MID$(dta$, 25, 2))%@NL@%
        file.day = dat& AND &H1F%@NL@%
        file.month = (dat& \ 32) AND &HF%@NL@%
        file.year = ((dat& \ 512) AND &H1F) + 1980%@NL@%
        file.size = CVL(MID$(dta$, 27, 4))%@NL@%
        f$ = MID$(dta$, 31) + CHR$(0)%@NL@%
        file.finame = LEFT$(f$, INSTR(f$, CHR$(0)) - 1)%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FILERR.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\FILERR.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' Declare symbolic constants used in program:%@AE@%%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE%@NL@%
%@NL@%
DECLARE FUNCTION GetFileName$ ()%@NL@%
%@NL@%
%@AB@%' Set up the ERROR trap, and specify the name of the%@AE@%%@NL@%
%@AB@%' error-handling routine:%@AE@%%@NL@%
ON ERROR GOTO ErrorProc%@NL@%
%@NL@%
DO%@NL@%
   Restart = FALSE%@NL@%
   CLS%@NL@%
%@NL@%
   FileName$ = GetFileName$     ' Input file name.%@NL@%
%@NL@%
   IF FileName$ = "" THEN%@NL@%
      END                       ' End if <ENTER> pressed.%@NL@%
   ELSE%@NL@%
%@NL@%
%@AB@%      ' Otherwise, open the file, assigning it the%@AE@%%@NL@%
%@AB@%      ' next available file number:%@AE@%%@NL@%
      FileNum = FREEFILE%@NL@%
      OPEN FileName$ FOR INPUT AS FileNum%@NL@%
   END IF%@NL@%
%@NL@%
   IF NOT Restart THEN%@NL@%
%@NL@%
%@AB@%      ' Input search string:%@AE@%%@NL@%
      LINE INPUT "Enter string to locate: ", LocString$%@NL@%
      LocString$ = UCASE$(LocString$)%@NL@%
%@NL@%
%@AB@%      ' Loop through the lines in the file, printing them%@AE@%%@NL@%
%@AB@%      ' if they contain the search string:%@AE@%%@NL@%
      LineNum = 1%@NL@%
      DO WHILE NOT EOF(FileNum)%@NL@%
%@NL@%
%@AB@%         ' Input line from file:%@AE@%%@NL@%
         LINE INPUT #FileNum, LineBuffer$%@NL@%
%@NL@%
%@AB@%         ' Check for string, printing the line and its%@AE@%%@NL@%
%@AB@%         ' number if found:%@AE@%%@NL@%
         IF INSTR(UCASE$(LineBuffer$), LocString$) <> 0 THEN%@NL@%
            PRINT USING "#### &"; LineNum, LineBuffer$%@NL@%
         END IF%@NL@%
%@NL@%
         LineNum = LineNum + 1%@NL@%
      LOOP%@NL@%
%@NL@%
      CLOSE FileNum             ' Close the file.%@NL@%
%@NL@%
   END IF%@NL@%
LOOP WHILE Restart = TRUE%@NL@%
%@NL@%
END%@NL@%
%@NL@%
ErrorProc:%@NL@%
%@NL@%
   SELECT CASE ERR%@NL@%
%@NL@%
      CASE 64:                  ' Bad File Name%@NL@%
         PRINT "** ERROR - Invalid file name"%@NL@%
%@NL@%
%@AB@%         ' Get a new file name and try again:%@AE@%%@NL@%
         FileName$ = GetFileName$%@NL@%
%@NL@%
%@AB@%         ' Resume at the statement that caused the error:%@AE@%%@NL@%
         RESUME%@NL@%
%@NL@%
      CASE 71:                  ' Disk not ready%@NL@%
         PRINT "** ERROR - Disk drive not ready"%@NL@%
         PRINT "Press C to continue, R to restart, Q to quit: "%@NL@%
         DO%@NL@%
            Char$ = UCASE$(INPUT$(1))%@NL@%
            IF Char$ = "C" THEN%@NL@%
               RESUME           ' Resume where you left off%@NL@%
%@NL@%
            ELSEIF Char$ = "R" THEN%@NL@%
               Restart = TRUE   ' Resume at beginning%@NL@%
               RESUME NEXT%@NL@%
%@NL@%
            ELSEIF Char$ = "Q" THEN%@NL@%
               END              ' Don't resume at all%@NL@%
            END IF%@NL@%
         LOOP%@NL@%
%@NL@%
      CASE 53, 76:              ' File or path not found%@NL@%
         PRINT "** ERROR - File or path not found"%@NL@%
         FileName$ = GetFileName$%@NL@%
         RESUME%@NL@%
%@NL@%
      CASE ELSE:                ' Unforeseen error%@NL@%
%@NL@%
%@AB@%         ' Disable error trapping and print standard%@AE@%%@NL@%
%@AB@%         ' system message:%@AE@%%@NL@%
         ON ERROR GOTO 0%@NL@%
   END SELECT%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================= GETFILENAME$ =======================%@AE@%%@NL@%
%@AB@%'              Returns a file name from user input%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION GetFileName$ STATIC%@NL@%
   INPUT "Enter file to search (press ENTER to quit): ", FTemp$%@NL@%
   GetFileName$ = FTemp$%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FLPT.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\FLPT.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' FLPT.BAS%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Displays how a given real value is stored in memory.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
DEFINT A-Z%@NL@%
DECLARE FUNCTION MHex$ (X AS INTEGER)%@NL@%
DIM Bytes(3)%@NL@%
%@NL@%
CLS%@NL@%
PRINT "Internal format of IEEE number (all values in hexadecimal)"%@NL@%
PRINT%@NL@%
DO%@NL@%
%@NL@%
%@AB@%   ' Get the value and calculate the address of the variable.%@AE@%%@NL@%
   INPUT "Enter a real number (or END to quit): ", A$%@NL@%
   IF UCASE$(A$) = "END" THEN EXIT DO%@NL@%
   RealValue! = VAL(A$)%@NL@%
%@AB@%   ' Convert the real value to a long without changing any of%@AE@%%@NL@%
%@AB@%   ' the bits.%@AE@%%@NL@%
   AsLong& = CVL(MKS$(RealValue!))%@NL@%
%@AB@%   ' Make a string of hex digits, and add leading zeroes.%@AE@%%@NL@%
   Strout$ = HEX$(AsLong&)%@NL@%
   Strout$ = STRING$(8 - LEN(Strout$), "0") + Strout$%@NL@%
%@NL@%
%@AB@%   ' Save the sign bit, and then eliminate it so it doesn't%@AE@%%@NL@%
%@AB@%   ' affect breaking out the bytes%@AE@%%@NL@%
   SignBit& = AsLong& AND &H80000000%@NL@%
   AsLong& = AsLong& AND &H7FFFFFFF%@NL@%
%@AB@%   ' Split the real value into four separate bytes%@AE@%%@NL@%
%@AB@%   ' --the AND removes unwanted bits; dividing by 256 shifts%@AE@%%@NL@%
%@AB@%   ' the value right 8 bit positions.%@AE@%%@NL@%
   FOR I = 0 TO 3%@NL@%
      Bytes(I) = AsLong& AND &HFF&%@NL@%
      AsLong& = AsLong& \ 256&%@NL@%
   NEXT I%@NL@%
%@AB@%   ' Display how the value appears in memory.%@AE@%%@NL@%
   PRINT%@NL@%
   PRINT "Bytes in Memory"%@NL@%
   PRINT " High    Low"%@NL@%
   FOR I = 1 TO 7 STEP 2%@NL@%
      PRINT " "; MID$(Strout$, I, 2);%@NL@%
   NEXT I%@NL@%
   PRINT : PRINT%@NL@%
%@NL@%
%@AB@%   ' Set the value displayed for the sign bit.%@AE@%%@NL@%
   Sign = ABS(SignBit& <> 0)%@NL@%
%@NL@%
%@AB@%   ' The exponent is the right seven bits of byte 3 and the%@AE@%%@NL@%
%@AB@%   ' leftmost bit of byte 2. Multiplying by 2 shifts left and%@AE@%%@NL@%
%@AB@%   ' makes room for the additional bit from byte 2.%@AE@%%@NL@%
   Exponent = Bytes(3) * 2 + Bytes(2) \ 128%@NL@%
%@NL@%
%@AB@%   ' The first part of the mantissa is the right seven bits%@AE@%%@NL@%
%@AB@%   ' of byte 2.  The OR operation makes sure the implied bit%@AE@%%@NL@%
%@AB@%   ' is displayed by setting the leftmost bit.%@AE@%%@NL@%
   Mant1 = (Bytes(2) OR &H80)%@NL@%
   PRINT " Bit 31    Bits 30-23  Implied Bit & Bits 22-0"%@NL@%
   PRINT "Sign Bit  Exponent Bits     Mantissa Bits"%@NL@%
   PRINT TAB(4); Sign; TAB(17); MHex$(Exponent);%@NL@%
   PRINT TAB(33); MHex$(Mant1); MHex$(Bytes(1)); MHex$(Bytes(0))%@NL@%
   PRINT%@NL@%
%@NL@%
LOOP%@NL@%
%@NL@%
%@AB@%' MHex$ makes sure we always get two hex digits.%@AE@%%@NL@%
FUNCTION MHex$ (X AS INTEGER) STATIC%@NL@%
   D$ = HEX$(X)%@NL@%
   IF LEN(D$) < 2 THEN D$ = "0" + D$%@NL@%
   MHex$ = D$%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%FRACTION.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\FRACTION.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FRACTION                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FRACTION.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Demonstrates a collection of functions and subprograms%@AE@%%@NL@%
%@AB@%  ' for working with fractions.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       a          Structure of type Fraction%@AE@%%@NL@%
%@AB@%  '                  b          Structure of type Fraction%@AE@%%@NL@%
%@AB@%  '                  c          Structure of type Fraction%@AE@%%@NL@%
%@AB@%  '                  f$         Input string for fraction problems%@AE@%%@NL@%
%@AB@%  '                  fa$        First fraction in string format%@AE@%%@NL@%
%@AB@%  '                  fb$        Second fraction in string format%@AE@%%@NL@%
%@AB@%  '                  operator$  Function indicator%@AE@%%@NL@%
%@AB@%  '                  fc$        Resultant fraction in string output form%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Data structure definitions%@AE@%%@NL@%
    TYPE Fraction%@NL@%
        Num AS LONG%@NL@%
        Den AS LONG%@NL@%
    END TYPE%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB FractionReduce (a AS Fraction)%@NL@%
    DECLARE SUB String2Fraction (f$, a AS Fraction)%@NL@%
    DECLARE SUB FractionAdd (a AS Fraction, b AS Fraction, c AS Fraction)%@NL@%
    DECLARE SUB FractionDiv (a AS Fraction, b AS Fraction, c AS Fraction)%@NL@%
    DECLARE SUB FractionMul (a AS Fraction, b AS Fraction, c AS Fraction)%@NL@%
    DECLARE SUB FractionSub (a AS Fraction, b AS Fraction, c AS Fraction)%@NL@%
    DECLARE SUB SplitFractions (f$, fa$, operator$, fb$)%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION Fraction2String$ (a AS Fraction)%@NL@%
    DECLARE FUNCTION GreatestComDiv& (n1&, n2&)%@NL@%
    DECLARE FUNCTION LeastComMul& (n1&, n2&)%@NL@%
%@NL@%
%@AB@%  ' Data structures%@AE@%%@NL@%
    DIM a AS Fraction%@NL@%
    DIM b AS Fraction%@NL@%
    DIM c AS Fraction%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the LeastComMul& function%@AE@%%@NL@%
    CLS%@NL@%
    PRINT "LeastComMul&(21&, 49&)    =", LeastComMul&(21&, 49&)%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the GreatestComDiv& function%@AE@%%@NL@%
    PRINT "GreatestComDiv&(21&, 49&) =", GreatestComDiv&(21&, 49&)%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the fraction routines%@AE@%%@NL@%
    DO%@NL@%
        PRINT%@NL@%
        PRINT "Enter a fraction problem, or simply press Enter"%@NL@%
        PRINT "Example: 2/3 + 4/5"%@NL@%
        PRINT%@NL@%
        LINE INPUT f$%@NL@%
        IF INSTR(f$, "/") = 0 THEN%@NL@%
            EXIT DO%@NL@%
        END IF%@NL@%
        SplitFractions f$, fa$, operator$, fb$%@NL@%
        String2Fraction fa$, a%@NL@%
        String2Fraction fb$, b%@NL@%
        SELECT CASE operator$%@NL@%
        CASE "+"%@NL@%
            FractionAdd a, b, c%@NL@%
        CASE "-"%@NL@%
            FractionSub a, b, c%@NL@%
        CASE "*"%@NL@%
            FractionMul a, b, c%@NL@%
        CASE "/"%@NL@%
            FractionDiv a, b, c%@NL@%
        CASE ELSE%@NL@%
            BEEP%@NL@%
        END SELECT%@NL@%
        fc$ = Fraction2String$(c)%@NL@%
        PRINT "Result (reduced to lowest terms) is "; fc$%@NL@%
    LOOP%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Fraction2String$           **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FRACTION.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Converts a type Fraction variable to a string.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  fa$ = Fraction2String$(a)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          Structure of type Fraction%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Fraction%@AE@%%@NL@%
%@AB@%  '                     Num AS LONG%@AE@%%@NL@%
%@AB@%  '                     Den AS LONG%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  DECLARE FUNCTION Fraction2String$ (a AS Fraction)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Fraction2String$ (a AS Fraction) STATIC%@NL@%
        Fraction2String$ = STR$(a.Num) + "/" + STR$(a.Den)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FractionAdd                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FRACTION.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Adds two fractions and reduces the result to lowest terms.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  FractionAdd a, b, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          First fraction to add%@AE@%%@NL@%
%@AB@%  '                  b          Second fraction to add%@AE@%%@NL@%
%@AB@%  '                  c          Resulting fraction%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Fraction%@AE@%%@NL@%
%@AB@%  '                     Num AS LONG%@AE@%%@NL@%
%@AB@%  '                     Den AS LONG%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '     DECLARE SUB FractionReduce (a AS Fraction)%@AE@%%@NL@%
%@AB@%  '     DECLARE SUB FractionAdd (a AS Fraction, b AS Fraction, c AS Fraction)%@AE@%%@NL@%
%@AB@%  '     DECLARE FUNCTION GreatestComDiv& (n1&, n2&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FractionAdd (a AS Fraction, b AS Fraction, c AS Fraction)%@NL@%
        c.Num = a.Num * b.Den + a.Den * b.Num%@NL@%
        c.Den = a.Den * b.Den%@NL@%
        FractionReduce c%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FractionDiv                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FRACTION.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Divides two fractions and reduces the result to%@AE@%%@NL@%
%@AB@%  ' lowest terms.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  FractionDiv a, b, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          First fraction%@AE@%%@NL@%
%@AB@%  '                  b          Fraction to divide into first%@AE@%%@NL@%
%@AB@%  '                  c          Resulting fraction%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Fraction%@AE@%%@NL@%
%@AB@%  '                     Num AS LONG%@AE@%%@NL@%
%@AB@%  '                     Den AS LONG%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '     DECLARE SUB FractionReduce (a AS Fraction)%@AE@%%@NL@%
%@AB@%  '     DECLARE SUB FractionDiv (a AS Fraction, b AS Fraction, c AS Fraction)%@AE@%%@NL@%
%@AB@%  '     DECLARE FUNCTION GreatestComDiv& (n1&, n2&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FractionDiv (a AS Fraction, b AS Fraction, c AS Fraction)%@NL@%
        c.Num = a.Num * b.Den%@NL@%
        c.Den = a.Den * b.Num%@NL@%
        FractionReduce c%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FractionMul                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FRACTION.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Multiplies two fractions and reduces the result to%@AE@%%@NL@%
%@AB@%  ' lowest terms.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  FractionMul a, b, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          First fraction to multiply%@AE@%%@NL@%
%@AB@%  '                  b          Second fraction to multiply%@AE@%%@NL@%
%@AB@%  '                  c          Resulting fraction%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Fraction%@AE@%%@NL@%
%@AB@%  '                     Num AS LONG%@AE@%%@NL@%
%@AB@%  '                     Den AS LONG%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '     DECLARE SUB FractionReduce (a AS Fraction)%@AE@%%@NL@%
%@AB@%  '     DECLARE SUB FractionMul (a AS Fraction, b AS Fraction, c AS Fraction)%@AE@%%@NL@%
%@AB@%  '     DECLARE FUNCTION GreatestComDiv& (n1&, n2&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FractionMul (a AS Fraction, b AS Fraction, c AS Fraction)%@NL@%
        c.Num = a.Num * b.Num%@NL@%
        c.Den = a.Den * b.Den%@NL@%
        FractionReduce c%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FractionReduce             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FRACTION.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Reduces a fraction to its lowest terms.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  FractionReduce a%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          Fraction to reduce%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       d&         Greatest common divisor of the numerator and%@AE@%%@NL@%
%@AB@%  '                             denominator%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Fraction%@AE@%%@NL@%
%@AB@%  '                     Num AS LONG%@AE@%%@NL@%
%@AB@%  '                     Den AS LONG%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB FractionReduce (a AS Fraction)%@AE@%%@NL@%
%@AB@%  '                  DECLARE FUNCTION GreatestComDiv& (n1&, n2&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FractionReduce (a AS Fraction)%@NL@%
        d& = GreatestComDiv&(a.Num, a.Den)%@NL@%
        a.Num = a.Num / d&%@NL@%
        a.Den = a.Den / d&%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FractionSub                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FRACTION.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Subtracts two fractions and reduces the result to%@AE@%%@NL@%
%@AB@%  ' lowest terms.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  FractionSub a, b, c%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a          First fraction%@AE@%%@NL@%
%@AB@%  '                  b          Fraction to subtract from the first%@AE@%%@NL@%
%@AB@%  '                  c          Resulting fraction%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  TYPE Fraction%@AE@%%@NL@%
%@AB@%  '                     Num AS LONG%@AE@%%@NL@%
%@AB@%  '                     Den AS LONG%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '     DECLARE SUB FractionReduce (a AS Fraction)%@AE@%%@NL@%
%@AB@%  '     DECLARE SUB FractionSub (a AS Fraction, b AS Fraction, c AS Fraction)%@AE@%%@NL@%
%@AB@%  '     DECLARE FUNCTION GreatestComDiv& (n1&, n2&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FractionSub (a AS Fraction, b AS Fraction, c AS Fraction)%@NL@%
        c.Num = a.Num * b.Den - a.Den * b.Num%@NL@%
        c.Den = a.Den * b.Den%@NL@%
        FractionReduce c%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GreatestComDiv&            **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FRACTION.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the greatest common divisor of two long integers.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  gcd& = GreatestComDiv& (n1&, n2&)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      n1&        First long integer%@AE@%%@NL@%
%@AB@%  '                  n2&        Second long integer%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       ta&        Working copy of n1&%@AE@%%@NL@%
%@AB@%  '                  tb&        Working copy of n2&%@AE@%%@NL@%
%@AB@%  '                  tc&        Working variable%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION GreatestComDiv& (n1&, n2&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION GreatestComDiv& (n1&, n2&)%@NL@%
        ta& = n1&%@NL@%
        tb& = n2&%@NL@%
        DO%@NL@%
            tc& = ta& MOD tb&%@NL@%
            ta& = tb&%@NL@%
            tb& = tc&%@NL@%
        LOOP WHILE tc&%@NL@%
        GreatestComDiv& = ta&%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          LeastComMul&               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FRACTION.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the least common multiple of two long integers.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  lcm& = LeastComMul& (n1&, n2&)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      n1&         First long integer%@AE@%%@NL@%
%@AB@%  '                  n2&         Second long integer%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION LeastComMul& (n1&, n2&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION LeastComMul& (n1&, n2&)%@NL@%
        LeastComMul& = ABS(n1& * n2& / GreatestComDiv&(n1&, n2&))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          SplitFractions             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FRACTION.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Splits an input fraction problem string into%@AE@%%@NL@%
%@AB@%  ' three strings representing each of the two%@AE@%%@NL@%
%@AB@%  ' fractions and a one-character string of the%@AE@%%@NL@%
%@AB@%  ' operation given.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE: SplitFractions f$, fa$, operator$, fb$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:     f$         Input string from the FRACTIONS demonstration%@AE@%%@NL@%
%@AB@%  '                            program%@AE@%%@NL@%
%@AB@%  '                 fa$        First fraction, extracted from f$%@AE@%%@NL@%
%@AB@%  '                 operator$  Mathematical operation symbol, from f$%@AE@%%@NL@%
%@AB@%  '                 fb$        Second fraction, extracted from f$%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      i%         Looping index%@AE@%%@NL@%
%@AB@%  '                 ndx%       Index to mathematical operation symbol%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS: DECLARE SUB SplitFractions (f$, fa$, operator$, fb$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB SplitFractions (f$, fa$, operator$, fb$)%@NL@%
        fa$ = ""%@NL@%
        fb$ = ""%@NL@%
        operator$ = ""%@NL@%
        FOR i% = 1 TO 4%@NL@%
            ndx% = INSTR(f$, MID$("+-*/", i%, 1))%@NL@%
            IF ndx% THEN%@NL@%
                IF i% = 4 THEN%@NL@%
                    ndx% = INSTR(ndx% + 1, f$, "/")%@NL@%
                END IF%@NL@%
                fa$ = LEFT$(f$, ndx% - 1)%@NL@%
                fb$ = MID$(f$, ndx% + 1)%@NL@%
                operator$ = MID$(f$, ndx%, 1)%@NL@%
                EXIT FOR%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          String2Fraction            **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FRACTION.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Converts a string to a type Fraction variable.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE: String2Fraction f$, a%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:     f$         String representation of a fraction%@AE@%%@NL@%
%@AB@%  '                 a          Structure of type Fraction%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB String2Fraction (f$, a AS Fraction)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB String2Fraction (f$, a AS Fraction)%@NL@%
        a.Num = VAL(f$)%@NL@%
        a.Den = VAL(MID$(f$, INSTR(f$, "/") + 1))%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%GAMES.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\GAMES.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GAMES                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        GAMES.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:          No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:   CGA%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:      (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:     (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      a$             String containing the 26 letters of the%@AE@%%@NL@%
%@AB@%  '                                alphabet%@AE@%%@NL@%
%@AB@%  '                 x%             Lower bound for array a%()%@AE@%%@NL@%
%@AB@%  '                 y%             Upper bound for array a%()%@AE@%%@NL@%
%@AB@%  '                 a%()           Array of numbers to be shuffled%@AE@%%@NL@%
%@AB@%  '                 i%             Looping index%@AE@%%@NL@%
%@AB@%  '                 size%          Dimension of bouncing ball array%@AE@%%@NL@%
%@AB@%  '                 object%()      Array for GET and PUT of bouncing ball%@AE@%%@NL@%
%@AB@%  '                 backGround%()  Array for GET and PUT of background%@AE@%%@NL@%
%@AB@%  '                 dx%            X velocity of bouncing ball%@AE@%%@NL@%
%@AB@%  '                 dy%            Y velocity of bouncing ball%@AE@%%@NL@%
%@AB@%  '                 px%            X coordinate of bouncing ball%@AE@%%@NL@%
%@AB@%  '                 py%            Y coordinate of bouncing ball%@AE@%%@NL@%
%@AB@%  '                 testNumber%    One of four bounce direction tests%@AE@%%@NL@%
%@AB@%  '                 test%          Result of the Collision% test%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Constants%@AE@%%@NL@%
    CONST FALSE = 0%@NL@%
    CONST TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION Shuffle$ (a$)%@NL@%
    DECLARE FUNCTION Dice% (numberOfDice%)%@NL@%
    DECLARE FUNCTION Card$ (cardNumber%)%@NL@%
    DECLARE FUNCTION Collision% (object%(), backGround%())%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB FillArray (a%())%@NL@%
    DECLARE SUB ShuffleArray (a%())%@NL@%
%@NL@%
%@AB@%  ' Demonstration of the Shuffle$ function%@AE@%%@NL@%
    CLS%@NL@%
    RANDOMIZE TIMER%@NL@%
    a$ = "abcdefghijklmnopqrstuvwxyz"%@NL@%
    PRINT "a$           = "; a$%@NL@%
    PRINT "Shuffle$(a$) = "; Shuffle$(a$)%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Demonstration of the FillArray subprogram%@AE@%%@NL@%
    x% = -7%@NL@%
    y% = 12%@NL@%
    DIM a%(x% TO y%)%@NL@%
    PRINT "FillArray a%()   where DIM a%( -7 TO 12) ..."%@NL@%
    FillArray a%()%@NL@%
    FOR i% = x% TO y%%@NL@%
        PRINT a%(i%);%@NL@%
    NEXT i%%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Demonstration of the ShuffleArray subprogram%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "ShuffleArray a%() ..."%@NL@%
    ShuffleArray a%()%@NL@%
    FOR i% = x% TO y%%@NL@%
        PRINT a%(i%);%@NL@%
    NEXT i%%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Demonstration of the Dice% function%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "Dice%(2)..."%@NL@%
    FOR i% = 1 TO 20%@NL@%
        PRINT Dice%(2);%@NL@%
    NEXT i%%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Deal a hand of seven cards%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "Seven random cards, without replacement..."%@NL@%
    REDIM a%(1 TO 54)%@NL@%
    FillArray a%()%@NL@%
    ShuffleArray a%()%@NL@%
    FOR i% = 1 TO 7%@NL@%
        PRINT Card$(a%(i%))%@NL@%
    NEXT i%%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Wait for user to press a key%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP WHILE INKEY$ = ""%@NL@%
%@NL@%
%@AB@%  ' Demonstration of the Collision% function%@AE@%%@NL@%
    size% = 6%@NL@%
    DIM object%(size%), backGround%(size%)%@NL@%
%@NL@%
%@AB@%  ' Set medium resolution graphics mode%@AE@%%@NL@%
    SCREEN 1%@NL@%
%@NL@%
%@AB@%  ' Create the bouncing ball%@AE@%%@NL@%
    CIRCLE (2, 2), 2, 3%@NL@%
    PAINT (2, 2), 3%@NL@%
    GET (0, 0)-(4, 4), object%%@NL@%
%@NL@%
%@AB@%  ' Make solid border around screen%@AE@%%@NL@%
    LINE (14, 18)-(305, 187), 1, B%@NL@%
    PAINT (0, 0), 1%@NL@%
%@NL@%
    PRINT " Collision% function... Press any key to quit "%@NL@%
%@NL@%
%@AB@%  ' Make three obstacles%@AE@%%@NL@%
    CIRCLE (115, 78), 33, 2, , , .6%@NL@%
    PAINT (115, 78), 2%@NL@%
    CIRCLE (205, 78), 33, 2, , , .6%@NL@%
    PAINT (205, 78), 2%@NL@%
    LINE (90, 145)-(230, 155), 2, BF%@NL@%
%@NL@%
%@AB@%  ' Initialize position and velocity of the object%@AE@%%@NL@%
    dx% = 1%@NL@%
    dy% = 1%@NL@%
    px% = 160%@NL@%
    py% = 44%@NL@%
    PUT (px%, py%), object%%@NL@%
%@NL@%
%@AB@%  ' Move the object around the screen, avoiding collisions,%@AE@%%@NL@%
%@AB@%  ' until any key is pressed%@AE@%%@NL@%
    DO%@NL@%
        testNumber% = 0%@NL@%
        DO%@NL@%
            PUT (px%, py%), object%%@NL@%
            px% = px% + dx%%@NL@%
            py% = py% + dy%%@NL@%
            GET (px%, py%)-(px% + 4, py% + 4), backGround%%@NL@%
            PUT (px%, py%), object%%@NL@%
            test% = Collision%(object%(), backGround%())%@NL@%
            IF test% THEN%@NL@%
                testNumber% = testNumber% + 1%@NL@%
                PUT (px%, py%), object%%@NL@%
                px% = px% - dx%%@NL@%
                py% = py% - dy%%@NL@%
                SELECT CASE testNumber%%@NL@%
                CASE 1%@NL@%
                    dx% = -dx%%@NL@%
                CASE 2%@NL@%
                    dx% = -dx%%@NL@%
                    dy% = -dy%%@NL@%
                CASE 3%@NL@%
                    dy% = -dy%%@NL@%
                CASE ELSE%@NL@%
                END SELECT%@NL@%
                PUT (px%, py%), object%%@NL@%
            END IF%@NL@%
        LOOP UNTIL test% = 0%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%  ' Clean up a little%@AE@%%@NL@%
    SCREEN 0%@NL@%
    WIDTH 80%@NL@%
    CLS%@NL@%
    SYSTEM%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Card$                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        GAMES.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the name of a playing card given a number%@AE@%%@NL@%
%@AB@%  ' from 1 to 52.  Any other number returns "Joker."%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  PRINT Card$(n%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      n%         Number from 1 to 52 representing a card (any%@AE@%%@NL@%
%@AB@%  '                             other number returns a Joker)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       suit$      Name of one of the four card suits%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Card$ (cardNumber%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Card$ (cardNumber%)%@NL@%
%@NL@%
        SELECT CASE (cardNumber% - 1) \ 13      ' Which suit?%@NL@%
        CASE 0%@NL@%
            suit$ = " of Spades"%@NL@%
        CASE 1%@NL@%
            suit$ = " of Clubs"%@NL@%
        CASE 2%@NL@%
            suit$ = " of Hearts"%@NL@%
        CASE 3%@NL@%
            suit$ = " of Diamonds"%@NL@%
        CASE ELSE%@NL@%
            Card$ = "Joker"%@NL@%
            EXIT FUNCTION%@NL@%
        END SELECT%@NL@%
%@NL@%
        SELECT CASE (cardNumber% - 1) MOD 13    ' Which card?%@NL@%
        CASE 0%@NL@%
            Card$ = "Ace" + suit$%@NL@%
        CASE 1 TO 9%@NL@%
            Card$ = MID$(STR$(cardNumber% MOD 13), 2) + suit$%@NL@%
        CASE 10%@NL@%
            Card$ = "Jack" + suit$%@NL@%
        CASE 11%@NL@%
            Card$ = "Queen" + suit$%@NL@%
        CASE 12%@NL@%
            Card$ = "King" + suit$%@NL@%
        END SELECT%@NL@%
%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Collision%                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        GAMES.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns TRUE if any non-zero pixels occur in the%@AE@%%@NL@%
%@AB@%  ' same byte of video memory, as saved in the object%()%@AE@%%@NL@%
%@AB@%  ' and backGround%() arrays.  The arrays must be the%@AE@%%@NL@%
%@AB@%  ' same size.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  test% = Collision%(object%(), backGround%())%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      object%()       First array, filled in with the GET%@AE@%%@NL@%
%@AB@%  '                                  statement%@AE@%%@NL@%
%@AB@%  '                  backGround%()   Second array, filled in with the GET%@AE@%%@NL@%
%@AB@%  '                                  statement%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       lo%             Lower bound of first array%@AE@%%@NL@%
%@AB@%  '                  up%             Upper bound of first array%@AE@%%@NL@%
%@AB@%  '                  lb%             Lower bound of second array%@AE@%%@NL@%
%@AB@%  '                  ub%             Upper bound of second array%@AE@%%@NL@%
%@AB@%  '                  i%              Index to integers in each array%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  CONST FALSE = 0%@AE@%%@NL@%
%@AB@%  '                  CONST TRUE = NOT FALSE%@AE@%%@NL@%
%@AB@%  '                  DECLARE FUNCTION Collision% (object%(), backGround%())%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Collision% (object%(), backGround%()) STATIC%@NL@%
        lo% = LBOUND(object%)%@NL@%
        uo% = UBOUND(object%)%@NL@%
        lb% = LBOUND(backGround%)%@NL@%
        ub% = UBOUND(backGround%)%@NL@%
        IF lo% <> lb% OR uo% <> ub% THEN%@NL@%
            PRINT "Error: Collision - The object and background"%@NL@%
            PRINT "graphics arrays have different dimensions."%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
        FOR i% = lo% + 2 TO uo%%@NL@%
            IF object%(i%) THEN%@NL@%
                IF backGround%(i%) THEN%@NL@%
                    Collision% = TRUE%@NL@%
                    EXIT FUNCTION%@NL@%
                END IF%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
        Collision% = FALSE%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Dice%                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        GAMES.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the total of the dots showing when any%@AE@%%@NL@%
%@AB@%  ' desired number of dice are rolled.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  total% = Dice%(n%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      n%         Number of dice%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       toss%      Loop index for throwing the n% dice%@AE@%%@NL@%
%@AB@%  '                  total%     Total of the dots showing%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Dice% (numberOfDice%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Dice% (numberOfDice%)%@NL@%
        IF numberOfDice% < 1 THEN%@NL@%
            PRINT "Error: Dice%() - Can't throw fewer than one die"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
        FOR toss% = 1 TO numberOfDice%%@NL@%
            total% = total% + INT(RND * 6) + 1%@NL@%
        NEXT toss%%@NL@%
        Dice% = total%%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FillArray                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        GAMES.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Initializes an integer array by putting i% into%@AE@%%@NL@%
%@AB@%  ' each i%th element.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  FillArray a%()%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a%()       Array to be filled with a sequence of numbers%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%         Looping index%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB FillArray (a%())%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FillArray (a%()) STATIC%@NL@%
        FOR i% = LBOUND(a%) TO UBOUND(a%)%@NL@%
            a%(i%) = i%%@NL@%
        NEXT i%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Shuffle$                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        GAMES.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Randomizes the order of the character bytes in a$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = Shuffle$(a$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String to be shuffled%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       x$         Working string space%@AE@%%@NL@%
%@AB@%  '                  lenx%      Number of bytes in the string%@AE@%%@NL@%
%@AB@%  '                  i%         Pointer to each byte%@AE@%%@NL@%
%@AB@%  '                  j%         Pointer to randomly selected byte%@AE@%%@NL@%
%@AB@%  '                  t$         Temporary byte-swapping string%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Shuffle$ (a$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Shuffle$ (a$) STATIC%@NL@%
        x$ = a$%@NL@%
        lenx% = LEN(x$)%@NL@%
        FOR i% = 1 TO lenx%%@NL@%
            j% = INT(RND * lenx% + 1)%@NL@%
            t$ = MID$(x$, i%, 1)%@NL@%
            MID$(x$, i%, 1) = MID$(x$, j%, 1)%@NL@%
            MID$(x$, j%, 1) = t$%@NL@%
        NEXT i%%@NL@%
        Shuffle$ = x$%@NL@%
        x$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ShuffleArray               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        GAMES.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Randomizes the order of the integers in a%()%@AE@%%@NL@%
%@AB@%  ' by swapping contents in a pseudorandom order.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ShuffleArray a%()%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a%()       Array to be shuffled%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       lb%        Lower bound of the array%@AE@%%@NL@%
%@AB@%  '                  ub%        Upper bound of the array%@AE@%%@NL@%
%@AB@%  '                  range%     Number of array entries%@AE@%%@NL@%
%@AB@%  '                  i%         Looping index%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB ShuffleArray (a%())%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ShuffleArray (a%()) STATIC%@NL@%
        lb% = LBOUND(a%)%@NL@%
        ub% = UBOUND(a%)%@NL@%
        range% = ub% - lb% + 1%@NL@%
        FOR i% = lb% TO ub%%@NL@%
            SWAP a%(i%), a%(INT(RND * range% + lb%))%@NL@%
        NEXT i%%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%HEX2BIN.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\HEX2BIN.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          HEX2BIN                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        HEX2BIN.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Reads in a hexadecimal format file and writes out a binary%@AE@%%@NL@%
%@AB@%  ' file created from the hexadecimal byte numbers.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           HEX2BIN inFileName.ext outFileName.ext%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       HEX2BIN.BAS%@AE@%%@NL@%
%@AB@%  '                  PARSE.BAS%@AE@%%@NL@%
%@AB@%  '                  STRINGS.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      inFileName.ext   Name of hexadecimal format file to be read%@AE@%%@NL@%
%@AB@%  '                  outFileName.ext  Name of file to be created%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       cmd$       Working copy of the command line%@AE@%%@NL@%
%@AB@%  '                  inFile$    Name of input file%@AE@%%@NL@%
%@AB@%  '                  outFile$   Name of output file%@AE@%%@NL@%
%@AB@%  '                  h$         Pair of hexadecimal characters representing%@AE@%%@NL@%
%@AB@%  '                             each byte%@AE@%%@NL@%
%@AB@%  '                  i%         Index into list of hexadecimal character pairs%@AE@%%@NL@%
%@AB@%  '                  byte$      Buffer for binary file access%@AE@%%@NL@%
%@NL@%
    DECLARE SUB ParseWord (a$, sep$, word$)%@NL@%
    DECLARE FUNCTION FilterIn$ (a$, set$)%@NL@%
%@NL@%
%@AB@%  ' Get the input and output filenames from the command line%@AE@%%@NL@%
    cmd$ = COMMAND$%@NL@%
    ParseWord cmd$, " ,", inFile$%@NL@%
    ParseWord cmd$, " ,", outFile$%@NL@%
%@NL@%
%@AB@%  ' Verify both filenames were given%@AE@%%@NL@%
    IF outFile$ = "" THEN%@NL@%
        PRINT%@NL@%
        PRINT "Usage: HEX2BIN inFileName.ext outFileName.ext"%@NL@%
        SYSTEM%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Open the input file%@AE@%%@NL@%
    OPEN inFile$ FOR INPUT AS #1%@NL@%
%@NL@%
%@AB@%  ' Truncate the output file if it already exists%@AE@%%@NL@%
    OPEN outFile$ FOR OUTPUT AS #2%@NL@%
    CLOSE #2%@NL@%
%@NL@%
%@AB@%  ' Now open it for binary output%@AE@%%@NL@%
    OPEN outFile$ FOR BINARY AS #2 LEN = 1%@NL@%
%@NL@%
%@AB@%  ' Process each line of the hexadecimal file%@AE@%%@NL@%
    DO%@NL@%
        LINE INPUT #1, h$%@NL@%
        h$ = FilterIn$(UCASE$(h$), "0123456789ABCDEF")%@NL@%
        FOR i% = 1 TO LEN(h$) STEP 2%@NL@%
            byte$ = CHR$(VAL("&H" + MID$(h$, i%, 2)))%@NL@%
            PUT #2, , byte$%@NL@%
        NEXT i%%@NL@%
    LOOP WHILE NOT EOF(1)%@NL@%
%@NL@%
%@AB@%  ' Clean up and quit%@AE@%%@NL@%
    CLOSE%@NL@%
    END%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%IMAGEARY.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\IMAGEARY.BAS%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' imageary%@AE@%%@NL@%
%@AB@%  ' (DRAW$) "r60 u14 l60 d14 r25 u8 r10 d8 l25 bu6 u4 r10 d4 l1"%@AE@%%@NL@%
%@AB@%  ' (DRAW$) "0 br30 u4 r10 d4 l10 br30 bu6 m-40,-8 m-40,8 br20 "%@AE@%%@NL@%
%@AB@%  ' (DRAW$) "bu4 u4 r10 d2"%@AE@%%@NL@%
    DIM imageary%(0 TO 117)%@NL@%
    FOR i% = 0 TO 117%@NL@%
        READ h$%@NL@%
        imageary%(i%) = VAL("&H" + h$)%@NL@%
    NEXT i%%@NL@%
    DATA 51,15,0,FE0F,C007,0,0,0,800,F802,3E,0,0,0,1F08,100,F0%@NL@%
    DATA 0,0,B00,E0,F00,80,0,0,7C,0,7C00,0,0,800F,0,0,E003,0,FF01%@NL@%
    DATA FFFF,FFFF,FFFF,FF,3E00,20,0,0,200,F8,20C0,0,0,0,702,80%@NL@%
    DATA 20,0,0,200,0,2000,FE0F,0,F83F,2,0,820,2,2000,208,0,2000%@NL@%
    DATA 208,FC1F,820,2,0,820,1002,2004,208,0,2000,FE0F,410,F83F%@NL@%
    DATA 2,0,20,1000,4,200,0,2000,0,410,0,2,0,20,1000,4,200,0%@NL@%
    DATA 2000,0,410,0,2,0,20,1000,4,200,0,3F00,FFFF,FFFF,FFFF%@NL@%
    DATA FE,0%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%INDEX.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\INDEX.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
%@AB@%' Define the symbolic constants used globally in the program:%@AE@%%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%' Define a record structure for random-file records:%@AE@%%@NL@%
TYPE StockItem%@NL@%
   PartNumber  AS STRING * 6%@NL@%
   Description AS STRING * 20%@NL@%
   UnitPrice   AS SINGLE%@NL@%
   Quantity    AS INTEGER%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' Define a record structure for each element of the index:%@AE@%%@NL@%
TYPE IndexType%@NL@%
   RecordNumber AS INTEGER%@NL@%
   PartNumber   AS STRING * 6%@NL@%
END TYPE%@NL@%
%@NL@%
%@AB@%' Declare procedures that will be called:%@AE@%%@NL@%
DECLARE FUNCTION Filter$ (Prompt$)%@NL@%
DECLARE FUNCTION FindRecord% (PartNumber$, RecordVar AS StockItem)%@NL@%
%@NL@%
DECLARE SUB AddRecord (RecordVar AS StockItem)%@NL@%
DECLARE SUB InputRecord (RecordVar AS StockItem)%@NL@%
DECLARE SUB PrintRecord (RecordVar AS StockItem)%@NL@%
DECLARE SUB SortIndex ()%@NL@%
DECLARE SUB ShowPartNumbers ()%@NL@%
%@NL@%
%@AB@%' Define a buffer (using the StockItem type) and%@AE@%%@NL@%
%@AB@%' define & dimension the index array:%@AE@%%@NL@%
DIM StockRecord AS StockItem, Index(1 TO 100) AS IndexType%@NL@%
%@NL@%
%@AB@%' Open the random-access file:%@AE@%%@NL@%
OPEN "STOCK.DAT" FOR RANDOM AS #1 LEN = LEN(StockRecord)%@NL@%
%@NL@%
%@AB@%' Calculate number of records in the file:%@AE@%%@NL@%
NumberOfRecords = LOF(1) \ LEN(StockRecord)%@NL@%
%@NL@%
%@AB@%' If there are records, read them and build the index:%@AE@%%@NL@%
IF NumberOfRecords <> 0 THEN%@NL@%
   FOR RecordNumber = 1 TO NumberOfRecords%@NL@%
%@NL@%
%@AB@%      ' Read the data from a new record in the file:%@AE@%%@NL@%
      GET #1, RecordNumber, StockRecord%@NL@%
%@NL@%
%@AB@%      ' Place part number and record number in index:%@AE@%%@NL@%
      Index(RecordNumber).RecordNumber = RecordNumber%@NL@%
      Index(RecordNumber).PartNumber = StockRecord.PartNumber%@NL@%
   NEXT%@NL@%
%@NL@%
   SortIndex            ' Sort index in part-number order.%@NL@%
END IF%@NL@%
%@NL@%
DO                      ' Main-menu loop.%@NL@%
   CLS%@NL@%
   PRINT "(A)dd records."%@NL@%
   PRINT "(L)ook up records."%@NL@%
   PRINT "(Q)uit program."%@NL@%
   PRINT%@NL@%
   LOCATE , , 1%@NL@%
   PRINT "Type your choice (A, L, or Q) here: ";%@NL@%
%@NL@%
%@AB@%   ' Loop until user presses, A, L, or Q:%@AE@%%@NL@%
   DO%@NL@%
      Choice$ = UCASE$(INPUT$(1))%@NL@%
   LOOP WHILE INSTR("ALQ", Choice$) = 0%@NL@%
%@NL@%
%@AB@%   ' Branch according to choice:%@AE@%%@NL@%
   SELECT CASE Choice$%@NL@%
      CASE "A"%@NL@%
         AddRecord StockRecord%@NL@%
      CASE "L"%@NL@%
         IF NumberOfRecords = 0 THEN%@NL@%
            PRINT : PRINT "No records in file yet. ";%@NL@%
            PRINT "Press any key to continue.";%@NL@%
            Pause$ = INPUT$(1)%@NL@%
         ELSE%@NL@%
            InputRecord StockRecord%@NL@%
         END IF%@NL@%
      CASE "Q"          ' End program%@NL@%
   END SELECT%@NL@%
LOOP UNTIL Choice$ = "Q"%@NL@%
%@NL@%
CLOSE #1                ' All done, close file and end.%@NL@%
END%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================== ADDRECORD =========================%@AE@%%@NL@%
%@AB@%'  Adds records to the file from input typed at the keyboard.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB AddRecord (RecordVar AS StockItem) STATIC%@NL@%
   SHARED Index() AS IndexType, NumberOfRecords%@NL@%
   DO%@NL@%
      CLS%@NL@%
      INPUT "Part Number: ", RecordVar.PartNumber%@NL@%
      INPUT "Description: ", RecordVar.Description%@NL@%
      RecordVar.UnitPrice = VAL(Filter$("Unit Price : "))%@NL@%
      RecordVar.Quantity = VAL(Filter$("Quantity   : "))%@NL@%
%@NL@%
      NumberOfRecords = NumberOfRecords + 1%@NL@%
%@NL@%
      PUT #1, NumberOfRecords, RecordVar%@NL@%
%@NL@%
      Index(NumberOfRecords).RecordNumber = NumberOfRecords%@NL@%
      Index(NumberOfRecords).PartNumber = RecordVar.PartNumber%@NL@%
      PRINT : PRINT "Add another? ";%@NL@%
      OK$ = UCASE$(INPUT$(1))%@NL@%
   LOOP WHILE OK$ = "Y"%@NL@%
%@NL@%
   SortIndex            ' Re-sort index file.%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ========================= FILTER ===========================%@AE@%%@NL@%
%@AB@%'       Filters all non-numeric characters from a string%@AE@%%@NL@%
%@AB@%'       and returns the filtered string.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION Filter$ (Prompt$) STATIC%@NL@%
   ValTemp2$ = ""%@NL@%
   PRINT Prompt$;                    ' Print the prompt passed.%@NL@%
   INPUT "", ValTemp1$               ' Input a number as%@NL@%
%@AB@%                                     ' a string.%@AE@%%@NL@%
   StringLength = LEN(ValTemp1$)     ' Get the string's length.%@NL@%
   FOR I% = 1 TO StringLength        ' Go through the string,%@NL@%
      Char$ = MID$(ValTemp1$, I%, 1) ' one character at a time.%@NL@%
%@NL@%
%@AB@%      ' Is the character a valid part of a number (i.e.,%@AE@%%@NL@%
%@AB@%      ' a digit or a decimal point)?  If yes, add it to%@AE@%%@NL@%
%@AB@%      ' the end of a new string:%@AE@%%@NL@%
      IF INSTR(".0123456789", Char$) > 0 THEN%@NL@%
         ValTemp2$ = ValTemp2$ + Char$%@NL@%
%@NL@%
%@AB@%      ' Otherwise, check to see if it's a lowercase "l",%@AE@%%@NL@%
%@AB@%      ' since users used to typewriters may enter a one%@AE@%%@NL@%
%@AB@%      ' value that way:%@AE@%%@NL@%
      ELSEIF Char$ = "l" THEN%@NL@%
         ValTemp2$ = ValTemp2$ + "1" ' Change the "l" to a "1".%@NL@%
      END IF%@NL@%
   NEXT I%%@NL@%
%@NL@%
   Filter$ = ValTemp2$           ' Return filtered string.%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================= FINDRECORD =========================%@AE@%%@NL@%
%@AB@%'     Uses a binary search to locate a record in the index.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION FindRecord% (Part$, RecordVar AS StockItem) STATIC%@NL@%
   SHARED Index() AS IndexType, NumberOfRecords%@NL@%
%@NL@%
%@AB@%   ' Set top and bottom bounds of search:%@AE@%%@NL@%
   TopRecord = NumberOfRecords%@NL@%
   BottomRecord = 1%@NL@%
%@NL@%
%@AB@%   ' Search until top of range is less than bottom:%@AE@%%@NL@%
   DO UNTIL (TopRecord < BottomRecord)%@NL@%
%@NL@%
%@AB@%      ' Choose midpoint:%@AE@%%@NL@%
      Midpoint = (TopRecord + BottomRecord) \ 2%@NL@%
%@NL@%
%@AB@%      ' Test to see if it's the one wanted (RTRIM$() trims%@AE@%%@NL@%
%@AB@%      ' trailing blanks from a fixed string):%@AE@%%@NL@%
      Test$ = RTRIM$(Index(Midpoint).PartNumber)%@NL@%
%@NL@%
%@AB@%      ' If it is, exit loop:%@AE@%%@NL@%
      IF Test$ = Part$ THEN%@NL@%
         EXIT DO%@NL@%
%@NL@%
%@AB@%      ' Otherwise, if what we're looking for is greater,%@AE@%%@NL@%
%@AB@%      ' move bottom up:%@AE@%%@NL@%
      ELSEIF Part$ > Test$ THEN%@NL@%
         BottomRecord = Midpoint + 1%@NL@%
%@NL@%
%@AB@%      ' Otherwise, move the top down:%@AE@%%@NL@%
      ELSE%@NL@%
         TopRecord = Midpoint - 1%@NL@%
      END IF%@NL@%
   LOOP%@NL@%
%@NL@%
%@AB@%   ' If part was found, get record from file using%@AE@%%@NL@%
%@AB@%   ' pointer in index and set FindRecord% to TRUE:%@AE@%%@NL@%
   IF Test$ = Part$ THEN%@NL@%
      GET #1, Index(Midpoint).RecordNumber, RecordVar%@NL@%
      FindRecord% = TRUE%@NL@%
%@NL@%
%@AB@%   ' Otherwise, if part was not found, set FindRecord%%@AE@%%@NL@%
%@AB@%   ' to FALSE:%@AE@%%@NL@%
   ELSE%@NL@%
      FindRecord% = FALSE%@NL@%
   END IF%@NL@%
END FUNCTION%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================= INPUTRECORD ========================%@AE@%%@NL@%
%@AB@%'    First, INPUTRECORD calls SHOWPARTNUMBERS, which%@AE@%%@NL@%
%@AB@%'    prints a menu of part numbers on the top of the screen.%@AE@%%@NL@%
%@AB@%'    Next, INPUTRECORD prompts the user to enter a part%@AE@%%@NL@%
%@AB@%'    number. Finally, it calls the FINDRECORD and PRINTRECORD%@AE@%%@NL@%
%@AB@%'    procedures to find and print the given record.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB InputRecord (RecordVar AS StockItem) STATIC%@NL@%
   CLS%@NL@%
   ShowPartNumbers      ' Call the ShowPartNumbers SUB.%@NL@%
%@NL@%
%@AB@%   ' Print data from specified records on the bottom%@AE@%%@NL@%
%@AB@%   ' part of the screen:%@AE@%%@NL@%
   DO%@NL@%
      PRINT "Type a part number listed above ";%@NL@%
      INPUT "(or Q to quit) and press <ENTER>: ", Part$%@NL@%
      IF UCASE$(Part$) <> "Q" THEN%@NL@%
         IF FindRecord(Part$, RecordVar) THEN%@NL@%
            PrintRecord RecordVar%@NL@%
         ELSE%@NL@%
            PRINT "Part not found."%@NL@%
         END IF%@NL@%
      END IF%@NL@%
      PRINT STRING$(40, "_")%@NL@%
   LOOP WHILE UCASE$(Part$) <> "Q"%@NL@%
%@NL@%
   VIEW PRINT   ' Restore the text viewport to entire screen.%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================= PRINTRECORD ========================%@AE@%%@NL@%
%@AB@%'                Prints a record on the screen%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB PrintRecord (RecordVar AS StockItem) STATIC%@NL@%
   PRINT "Part Number: "; RecordVar.PartNumber%@NL@%
   PRINT "Description: "; RecordVar.Description%@NL@%
   PRINT USING "Unit Price :$$###.##"; RecordVar.UnitPrice%@NL@%
   PRINT "Quantity   :"; RecordVar.Quantity%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ===================== SHOWPARTNUMBERS ======================%@AE@%%@NL@%
%@AB@%'  Prints an index of all the part numbers in the upper part%@AE@%%@NL@%
%@AB@%'  of the screen.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ShowPartNumbers STATIC%@NL@%
   SHARED Index() AS IndexType, NumberOfRecords%@NL@%
%@NL@%
   CONST NUMCOLS = 8, COLWIDTH = 80 \ NUMCOLS%@NL@%
%@NL@%
%@AB@%   ' At the top of the screen, print a menu indexing all%@AE@%%@NL@%
%@AB@%   ' the part numbers for records in the file.  This menu is%@AE@%%@NL@%
%@AB@%   ' printed in columns of equal length (except possibly the%@AE@%%@NL@%
%@AB@%   ' last column, which may be shorter than the others):%@AE@%%@NL@%
   ColumnLength = NumberOfRecords%@NL@%
   DO WHILE ColumnLength MOD NUMCOLS%@NL@%
      ColumnLength = ColumnLength + 1%@NL@%
   LOOP%@NL@%
   ColumnLength = ColumnLength \ NUMCOLS%@NL@%
   Column = 1%@NL@%
   RecordNumber = 1%@NL@%
   DO UNTIL RecordNumber > NumberOfRecords%@NL@%
      FOR Row = 1 TO ColumnLength%@NL@%
         LOCATE Row, Column%@NL@%
         PRINT Index(RecordNumber).PartNumber%@NL@%
         RecordNumber = RecordNumber + 1%@NL@%
         IF RecordNumber > NumberOfRecords THEN EXIT FOR%@NL@%
      NEXT Row%@NL@%
      Column = Column + COLWIDTH%@NL@%
   LOOP%@NL@%
%@NL@%
   LOCATE ColumnLength + 1, 1%@NL@%
   PRINT STRING$(80, "_")       ' Print separator line.%@NL@%
%@NL@%
%@AB@%   ' Scroll information about records below the part-number%@AE@%%@NL@%
%@AB@%   ' menu (this way, the part numbers are not erased):%@AE@%%@NL@%
   VIEW PRINT ColumnLength + 2 TO 24%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ========================= SORTINDEX ========================%@AE@%%@NL@%
%@AB@%'                Sorts the index by part number%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB SortIndex STATIC%@NL@%
   SHARED Index() AS IndexType, NumberOfRecords%@NL@%
%@NL@%
%@AB@%   ' Set comparison offset to half the number of records%@AE@%%@NL@%
%@AB@%   ' in index:%@AE@%%@NL@%
   Offset = NumberOfRecords \ 2%@NL@%
%@NL@%
%@AB@%   ' Loop until offset gets to zero:%@AE@%%@NL@%
   DO WHILE Offset > 0%@NL@%
      Limit = NumberOfRecords - Offset%@NL@%
      DO%@NL@%
%@NL@%
%@AB@%         ' Assume no switches at this offset:%@AE@%%@NL@%
         Switch = FALSE%@NL@%
%@NL@%
%@AB@%         ' Compare elements and switch ones out of order:%@AE@%%@NL@%
         FOR I = 1 TO Limit%@NL@%
            IF Index(I).PartNumber > Index(I + Offset).PartNumber THEN%@NL@%
               SWAP Index(I), Index(I + Offset)%@NL@%
               Switch = I%@NL@%
            END IF%@NL@%
         NEXT I%@NL@%
%@NL@%
%@AB@%         ' Sort on next pass only to where last%@AE@%%@NL@%
%@AB@%         ' switch was made:%@AE@%%@NL@%
         Limit = Switch%@NL@%
      LOOP WHILE Switch%@NL@%
%@NL@%
%@AB@%      ' No switches at last offset, try one half as big:%@AE@%%@NL@%
      Offset = Offset \ 2%@NL@%
   LOOP%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%INTRODEM.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\INTRODEM.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          INTRODEM                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        INTRODEM.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Quick introductory demonstration created from the%@AE@%%@NL@%
%@AB@%  ' QuickBASIC Toolbox routines.%@AE@%%@NL@%
%@AB@%  ' USAGE:  Run as a main program to see the demonstration.%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS: CGA or VGA%@AE@%%@NL@%
%@AB@%  ' .MAK FILE CONTENTS: (none)%@AE@%%@NL@%
%@AB@%  ' FUNCTIONS:    Collision%            Date2Day%           Date2Julian&%@AE@%%@NL@%
%@AB@%  '               Date2Month%           Date2Year%          DayOfTheWeek$%@AE@%%@NL@%
%@AB@%  '               DOSVersion!           GetDirectory$       GetDrive$%@AE@%%@NL@%
%@AB@%  '               GetVerifyState%       InKeyCode%          Julian2Date$%@AE@%%@NL@%
%@AB@%  '               KeyCode%              MDY2Date$           MenuString%%@AE@%%@NL@%
%@AB@%  '               MonthName$%@AE@%%@NL@%
%@AB@%  ' SUBPROGRAMS:  Attrib                DrawBox             EditLine%@AE@%%@NL@%
%@AB@%  '               Equipment             FindFirstFile       FindNextFile%@AE@%%@NL@%
%@AB@%  '               GetDiskFreeSpace      GetFileData         GetShiftStates%@AE@%%@NL@%
%@AB@%  '               Interrupt             InterruptX          Mouse%@AE@%%@NL@%
%@AB@%  '               MouseMickey           OneMonthCalendar    SpaceWorms%@AE@%%@NL@%
%@AB@%  '               TextGet               TextPut             VideoState%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:   (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:    disk          Structure of type DiskFreeSpaceType%@AE@%%@NL@%
%@AB@%  '               equip         Structure of type EquipmentType%@AE@%%@NL@%
%@AB@%  '               file          Structure of type FileDataType%@AE@%%@NL@%
%@AB@%  '               shift         Structure of type ShiftType%@AE@%%@NL@%
%@AB@%  '               wormship1%()  First image of UFO%@AE@%%@NL@%
%@AB@%  '               i%            Looping index%@AE@%%@NL@%
%@AB@%  '               h$            Hexadecimal notation character string%@AE@%%@NL@%
%@AB@%  '               wormship2%()  Second image of UFO%@AE@%%@NL@%
%@AB@%  '               title$()      Storage for title boxes%@AE@%%@NL@%
%@AB@%  '               row%()        Row location of each title box%@AE@%%@NL@%
%@AB@%  '               col%()        Column location of each title box%@AE@%%@NL@%
%@AB@%  '               row2%         Row location at opposite corner of title box%@AE@%%@NL@%
%@AB@%  '               col2%         Column location at opposite corner of title box%@AE@%%@NL@%
%@AB@%  '               t0            Timer value at start of timing loop%@AE@%%@NL@%
%@AB@%  '               path$         String for finding directory contents%@AE@%%@NL@%
%@AB@%  '               result%       Returned code for finding each file name%@AE@%%@NL@%
%@AB@%  '               dta$          Disk transfer area buffer string%@AE@%%@NL@%
%@AB@%  '               mode%         Current video mode number%@AE@%%@NL@%
%@AB@%  '               columns%      Current number of video columns%@AE@%%@NL@%
%@AB@%  '               page%         Current video page number%@AE@%%@NL@%
%@AB@%  '               drive$        Default drive string for getting disk%@AE@%%@NL@%
%@AB@%  '                               information%@AE@%%@NL@%
%@AB@%  '               quitFlag%     Indicates user wants to quit%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Constants%@AE@%%@NL@%
    CONST FALSE = 0%@NL@%
    CONST TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%  ' Define color constants%@AE@%%@NL@%
    CONST BLACK = 0%@NL@%
    CONST BLUE = 1%@NL@%
    CONST GREEN = 2%@NL@%
    CONST CYAN = 3%@NL@%
    CONST RED = 4%@NL@%
    CONST MAGENTA = 5%@NL@%
    CONST BROWN = 6%@NL@%
    CONST WHITE = 7%@NL@%
    CONST BRIGHT = 8%@NL@%
    CONST BLINK = 16%@NL@%
    CONST YELLOW = BROWN + BRIGHT%@NL@%
%@NL@%
%@AB@%  ' Key code numbers%@AE@%%@NL@%
    CONST BACKSPACE = 8%@NL@%
    CONST CTRLLEFTARROW = 29440%@NL@%
    CONST CTRLRIGHTARROW = 29696%@NL@%
    CONST CTRLY = 25%@NL@%
    CONST CTRLQ = 17%@NL@%
    CONST DELETE = 21248%@NL@%
    CONST DOWNARROW = 20480%@NL@%
    CONST ENDKEY = 20224%@NL@%
    CONST ENTER = 13%@NL@%
    CONST ESCAPE = 27%@NL@%
    CONST HOME = 18176%@NL@%
    CONST INSERTKEY = 20992%@NL@%
    CONST LEFTARROW = 19200%@NL@%
    CONST RIGHTARROW = 19712%@NL@%
    CONST TABKEY = 9%@NL@%
    CONST UPARROW = 18432%@NL@%
%@NL@%
%@AB@%  ' File search attribute bits%@AE@%%@NL@%
    CONST ISNORMAL = 0%@NL@%
    CONST ISREADONLY = 1%@NL@%
    CONST ISHIDDEN = 2%@NL@%
    CONST ISSYSTEM = 4%@NL@%
    CONST ISVOLUMELABEL = 8%@NL@%
    CONST ISSUBDIRECTORY = 16%@NL@%
    CONST ISARCHIVED = 32%@NL@%
%@NL@%
%@AB@%  ' Here we'll search for normal files and subdirectories%@AE@%%@NL@%
    CONST FILEATTRIBUTE = ISNORMAL + ISSUBDIRECTORY%@NL@%
%@NL@%
%@AB@%  ' Declare the Type structures%@AE@%%@NL@%
    TYPE RegType%@NL@%
        ax    AS INTEGER%@NL@%
        bx    AS INTEGER%@NL@%
        cx    AS INTEGER%@NL@%
        dx    AS INTEGER%@NL@%
        Bp    AS INTEGER%@NL@%
        si    AS INTEGER%@NL@%
        di    AS INTEGER%@NL@%
        flags AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE RegTypeX%@NL@%
        ax    AS INTEGER%@NL@%
        bx    AS INTEGER%@NL@%
        cx    AS INTEGER%@NL@%
        dx    AS INTEGER%@NL@%
        Bp    AS INTEGER%@NL@%
        si    AS INTEGER%@NL@%
        di    AS INTEGER%@NL@%
        flags AS INTEGER%@NL@%
        ds    AS INTEGER%@NL@%
        es    AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE DiskFreeSpaceType%@NL@%
        sectorsPerCluster AS INTEGER%@NL@%
        bytesPerSector AS INTEGER%@NL@%
        clustersPerDrive AS LONG%@NL@%
        availableClusters AS LONG%@NL@%
        availableBytes AS LONG%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE FileDataType%@NL@%
        finame    AS STRING * 12%@NL@%
        year      AS INTEGER%@NL@%
        month     AS INTEGER%@NL@%
        day       AS INTEGER%@NL@%
        hour      AS INTEGER%@NL@%
        minute    AS INTEGER%@NL@%
        second    AS INTEGER%@NL@%
        attribute AS INTEGER%@NL@%
        size      AS LONG%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE EquipmentType%@NL@%
        printers     AS INTEGER%@NL@%
        gameAdapter  AS INTEGER%@NL@%
        serial       AS INTEGER%@NL@%
        floppies     AS INTEGER%@NL@%
        initialVideo AS INTEGER%@NL@%
        coprocessor  AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE ShiftType%@NL@%
        right           AS INTEGER%@NL@%
        left            AS INTEGER%@NL@%
        ctrl            AS INTEGER%@NL@%
        alt             AS INTEGER%@NL@%
        scrollLockState AS INTEGER%@NL@%
        numLockState    AS INTEGER%@NL@%
        capsLockState   AS INTEGER%@NL@%
        insertState     AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION Collision% (object%(), backGround%())%@NL@%
    DECLARE FUNCTION Date2Day% (dat$)%@NL@%
    DECLARE FUNCTION Date2Julian& (dat$)%@NL@%
    DECLARE FUNCTION Date2Month% (dat$)%@NL@%
    DECLARE FUNCTION Date2Year% (dat$)%@NL@%
    DECLARE FUNCTION DayOfTheWeek$ (dat$)%@NL@%
    DECLARE FUNCTION DOSVersion! ()%@NL@%
    DECLARE FUNCTION GetDirectory$ (drive$)%@NL@%
    DECLARE FUNCTION GetDrive$ ()%@NL@%
    DECLARE FUNCTION GetVerifyState% ()%@NL@%
    DECLARE FUNCTION InKeyCode% ()%@NL@%
    DECLARE FUNCTION Julian2Date$ (julian&)%@NL@%
    DECLARE FUNCTION KeyCode% ()%@NL@%
    DECLARE FUNCTION MDY2Date$ (month%, day%, year%)%@NL@%
    DECLARE FUNCTION MenuString% CDECL (row%, col%, a$)%@NL@%
    DECLARE FUNCTION MonthName$ (dat$)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB Attrib ()%@NL@%
    DECLARE SUB DrawBox (row1%, col1%, row2%, col2%)%@NL@%
    DECLARE SUB EditLine (a$, exitCode%)%@NL@%
    DECLARE SUB Equipment (equip AS ANY)%@NL@%
    DECLARE SUB FindFirstFile (path$, dta$, result%)%@NL@%
    DECLARE SUB FindNextFile (dta$, result%)%@NL@%
    DECLARE SUB GetDiskFreeSpace (drive$, disk AS ANY)%@NL@%
    DECLARE SUB GetFileData (dta$, file AS ANY)%@NL@%
    DECLARE SUB GetShiftStates (shift AS ANY)%@NL@%
    DECLARE SUB Interrupt (intnum%, inreg AS RegType, outreg AS RegType)%@NL@%
    DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@NL@%
    DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@NL@%
    DECLARE SUB MouseMickey (horizontal%, vertical%)%@NL@%
    DECLARE SUB OneMonthCalendar (dat$, row%, col%)%@NL@%
    DECLARE SUB SpaceWorms ()%@NL@%
    DECLARE SUB TextGet CDECL (r1%, c1%, r2%, c2%, a$)%@NL@%
    DECLARE SUB TextPut CDECL (r1%, c1%, r2%, c2%, a$)%@NL@%
    DECLARE SUB VideoState (mode%, columns%, page%)%@NL@%
%@NL@%
%@AB@%  ' Data structures%@AE@%%@NL@%
    DIM disk AS DiskFreeSpaceType%@NL@%
    DIM equip AS EquipmentType%@NL@%
    DIM file AS FileDataType%@NL@%
    DIM shift AS ShiftType%@NL@%
%@NL@%
%@AB@%  ' Worm ship image 1%@AE@%%@NL@%
%@AB@%  ' (DRAW$) "c1u2e2r4f2d2 l8 be1p1,1 bf1br6 c2r6f3g3l20h3e3r18 "%@AE@%%@NL@%
%@AB@%  ' (DRAW$) "bd3 p3,2 c2 l1 bl3 l1 bl3 l1 bl3 l1 bl3 l1 bd7 br1"%@AE@%%@NL@%
%@AB@%  ' (DRAW$) " e3r10 f3"%@AE@%%@NL@%
    DIM wormship1%(0 TO 54)%@NL@%
    FOR i% = 0 TO 54%@NL@%
        READ h$%@NL@%
        wormship1%(i%) = VAL("&H" + h$)%@NL@%
    NEXT i%%@NL@%
    DATA 36,F,0,5501,0,0,500,4055,0,0,5515,50,0,1500,5055,0,AA02%@NL@%
    DATA AAAA,AAAA,B00,FFFF,FFFF,80FF,FF2F,FFFF,FFFF,BFE0,AFAF%@NL@%
    DATA AFAF,F8AF,FF2F,FFFF,FFFF,BE0,FFFF,FFFF,80FF,AA02,AAAA%@NL@%
    DATA AAAA,0,AA00,A8AA,0,200,0,2,0,8,0,80,2000,0,2000,0%@NL@%
%@NL@%
%@AB@%  ' Worm ship image 2%@AE@%%@NL@%
%@AB@%  ' (DRAW$) "c1u2e2r4f2d2 l8 be1p1,1 bf1br6 c2r6f3g3l20h3e3r18 "%@AE@%%@NL@%
%@AB@%  ' (DRAW$) "bd3 p3,2 c2 br2 l1 bl3 l1 bl3 l1 bl3 l1 bl3 l1 bl3"%@AE@%%@NL@%
%@AB@%  ' (DRAW$) " l1 bd7 br3 e3r10 f3"%@AE@%%@NL@%
    DIM wormship2%(0 TO 54)%@NL@%
    FOR i% = 0 TO 54%@NL@%
        READ h$%@NL@%
        wormship2%(i%) = VAL("&H" + h$)%@NL@%
    NEXT i%%@NL@%
    DATA 36,F,0,5501,0,0,400,4000,0,0,10,10,0,1000,1000,0,AA02%@NL@%
    DATA AAAA,AAAA,B00,FFFF,FFFF,80FF,FF2F,FFFF,FFFF,BAE0,FAFA%@NL@%
    DATA FAFA,F8FA,FF2F,FFFF,FFFF,BE0,FFFF,FFFF,80FF,AA02,AAAA%@NL@%
    DATA AAAA,0,AA00,A8AA,0,200,0,2,0,8,0,80,2000,0,2000,0%@NL@%
%@NL@%
%@AB@%  ' Initialization%@AE@%%@NL@%
    DIM title$(0 TO 17), row%(0 TO 17), col%(0 TO 17)%@NL@%
    FOR i% = 0 TO 17%@NL@%
        title$(i%) = SPACE$(432)%@NL@%
    NEXT i%%@NL@%
    COLOR BLACK, WHITE%@NL@%
    CLS%@NL@%
    menu$ = "  Files  Equipment  Game  Attributes  Calendar  Quit  "%@NL@%
%@NL@%
%@AB@%  ' Main loop%@AE@%%@NL@%
    DO%@NL@%
%@NL@%
%@AB@%      ' Create main screen%@AE@%%@NL@%
        COLOR BLACK, WHITE%@NL@%
        DrawBox 1, 1, 25, 80%@NL@%
        DrawBox 2, 3, 24, 78%@NL@%
        DrawBox 3, 5, 23, 76%@NL@%
%@NL@%
%@AB@%      ' Build the title box%@AE@%%@NL@%
        COLOR YELLOW, BLUE%@NL@%
        DrawBox 9, 29, 17, 52%@NL@%
        COLOR BRIGHT + MAGENTA, BLUE%@NL@%
        LOCATE 10, 35%@NL@%
        PRINT "Introducing"%@NL@%
        COLOR BRIGHT + GREEN, BLUE%@NL@%
        LOCATE 12, 39%@NL@%
        PRINT "THE"%@NL@%
        LOCATE 13, 34%@NL@%
        PRINT "QuickBASIC 4.0"%@NL@%
        LOCATE 14, 37%@NL@%
        PRINT "TOOLBOX"%@NL@%
%@NL@%
%@AB@%      ' Grab a copy of the title box%@AE@%%@NL@%
        TextGet 9, 29, 17, 52, title$(0)%@NL@%
        row%(0) = 9%@NL@%
        col%(0) = 29%@NL@%
%@NL@%
%@AB@%      ' Randomly place 17 title boxes, saving the background%@AE@%%@NL@%
        FOR i% = 1 TO 17%@NL@%
            row%(i%) = INT(RND * 16) + 1%@NL@%
            col%(i%) = INT(RND * 56) + 1%@NL@%
            row2% = row%(i%) + 8%@NL@%
            col2% = col%(i%) + 23%@NL@%
            TextGet row%(i%), col%(i%), row2%, col2%, title$(i%)%@NL@%
            TextPut row%(i%), col%(i%), row2%, col2%, title$(0)%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' Delay for half a second%@AE@%%@NL@%
        t0 = TIMER%@NL@%
        DO%@NL@%
        LOOP WHILE TIMER - t0 < .5%@NL@%
%@NL@%
%@AB@%      ' Replace the backgrounds%@AE@%%@NL@%
        FOR i% = 17 TO 0 STEP -1%@NL@%
            row2% = row%(i%) + 8%@NL@%
            col2% = col%(i%) + 23%@NL@%
            TextPut row%(i%), col%(i%), row2%, col2%, title$(i%)%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' Now for the main menu%@AE@%%@NL@%
        LOCATE , , 0%@NL@%
        SELECT CASE MenuString%(6, 12, menu$)%@NL@%
%@NL@%
%@AB@%      ' Current drive, path, and directory listing%@AE@%%@NL@%
        CASE 1%@NL@%
            COLOR BRIGHT + WHITE, CYAN%@NL@%
            CLS%@NL@%
            PRINT "Enter path (or just press ";%@NL@%
            PRINT CHR$(17); CHR$(196); CHR$(217); ")... "%@NL@%
            path$ = GetDirectory$("")%@NL@%
            IF RIGHT$(path$, 1) <> "\" THEN%@NL@%
                path$ = path$ + "\"%@NL@%
            END IF%@NL@%
            path$ = LEFT$(path$ + "*.*" + SPACE$(70), 70)%@NL@%
            COLOR YELLOW, BLUE%@NL@%
            LOCATE 2, 5%@NL@%
            EditLine path$, exitCode%%@NL@%
            path$ = LTRIM$(RTRIM$(path$))%@NL@%
            IF path$ = "" OR RIGHT$(path$, 1) = "\" THEN%@NL@%
                path$ = path$ + "*.*"%@NL@%
            END IF%@NL@%
            COLOR BLACK, CYAN%@NL@%
            PRINT%@NL@%
            PRINT%@NL@%
            FindFirstFile path$, dta$, result%%@NL@%
            DO UNTIL result%%@NL@%
                GetFileData dta$, file%@NL@%
                IF file.attribute AND &H10 THEN%@NL@%
                    PRINT "*"; file.finame,%@NL@%
                ELSE%@NL@%
                    PRINT " "; file.finame,%@NL@%
                END IF%@NL@%
                FindNextFile dta$, result%%@NL@%
            LOOP%@NL@%
            PRINT%@NL@%
            PRINT%@NL@%
            COLOR BRIGHT + WHITE, CYAN%@NL@%
            PRINT "Press any key to continue"%@NL@%
            DO%@NL@%
            LOOP WHILE INKEY$ = ""%@NL@%
            COLOR BLACK, WHITE%@NL@%
            CLS%@NL@%
%@NL@%
%@AB@%      ' Equipment information%@AE@%%@NL@%
        CASE 2%@NL@%
            COLOR BRIGHT + GREEN, BLUE%@NL@%
            CLS%@NL@%
            PRINT "Information about your hardware and software..."%@NL@%
            COLOR YELLOW, BLUE%@NL@%
            PRINT%@NL@%
            PRINT "Current version of DOS is "; DOSVersion!%@NL@%
            Equipment equip%@NL@%
            PRINT "Number of printers", equip.printers%@NL@%
            PRINT "Game adapter", , equip.gameAdapter%@NL@%
            PRINT "Serial I/O ports", equip.serial%@NL@%
            PRINT "Floppy disk drives", equip.floppies%@NL@%
            PRINT "Initial video state", equip.initialVideo%@NL@%
            PRINT "Numerical coprocessor", equip.coprocessor%@NL@%
            VideoState mode%, columns%, page%%@NL@%
            PRINT "Video mode number", mode%%@NL@%
            PRINT "Video width", , columns%%@NL@%
            PRINT "Video page", , page%%@NL@%
            GetShiftStates shift%@NL@%
            PRINT "Scroll lock", , shift.scrollLockState%@NL@%
            PRINT "Num lock", , shift.numLockState%@NL@%
            PRINT "Caps lock", , shift.capsLockState%@NL@%
            PRINT "Insert lock", , shift.insertState%@NL@%
            PRINT "Disk verify state", GetVerifyState%%@NL@%
            GetDiskFreeSpace drive$, disk%@NL@%
            PRINT "Disk sectors per cluster", disk.sectorsPerCluster%@NL@%
            PRINT "Disk bytes per sector", disk.bytesPerSector%@NL@%
            PRINT "Disk clusters on drive", disk.clustersPerDrive%@NL@%
            PRINT "Disk available clusters", disk.availableClusters%@NL@%
            PRINT "Disk available bytes", disk.availableBytes%@NL@%
            PRINT "Current complete path", " "; RTRIM$(GetDirectory$(""))%@NL@%
            LOCATE 15, 45%@NL@%
            COLOR BRIGHT + WHITE, BLACK%@NL@%
            PRINT " Press any key to continue "%@NL@%
            DO%@NL@%
            LOOP WHILE INKEY$ = ""%@NL@%
            COLOR WHITE, BLACK%@NL@%
            CLS%@NL@%
%@NL@%
%@AB@%      ' Worms from space%@AE@%%@NL@%
        CASE 3%@NL@%
            SpaceWorms%@NL@%
%@NL@%
%@AB@%      ' Color attributes%@AE@%%@NL@%
        CASE 4%@NL@%
            Attrib%@NL@%
            LOCATE 23, 1%@NL@%
            PRINT "Press any key to continue"%@NL@%
            DO%@NL@%
            LOOP WHILE INKEY$ = ""%@NL@%
            CLS%@NL@%
%@NL@%
%@AB@%      ' Calendar sheet for this month%@AE@%%@NL@%
        CASE 5%@NL@%
            COLOR YELLOW, CYAN%@NL@%
            CLS%@NL@%
            COLOR YELLOW, BLUE%@NL@%
            DrawBox 6, 21, 19, 60%@NL@%
            COLOR BRIGHT + WHITE, BLUE%@NL@%
            OneMonthCalendar DATE$, 9, 26%@NL@%
            LOCATE 23, 27%@NL@%
            PRINT "Press any key to continue"%@NL@%
            DO%@NL@%
            LOOP WHILE INKEY$ = ""%@NL@%
            COLOR WHITE, BLACK%@NL@%
            CLS%@NL@%
%@NL@%
%@AB@%      ' Must be time to quit%@AE@%%@NL@%
        CASE ELSE%@NL@%
            quitFlag% = TRUE%@NL@%
%@NL@%
        END SELECT%@NL@%
%@NL@%
    LOOP UNTIL quitFlag%%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    COLOR WHITE, BLACK%@NL@%
    CLS%@NL@%
    END%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Attrib                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        ATTRIB.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Displays table of color attributes for text mode%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Attrib STATIC%@NL@%
        SCREEN 0%@NL@%
        CLS%@NL@%
        PRINT "Attributes for the COLOR statement in text mode (SCREEN 0)."%@NL@%
        PRINT "Add 16 to the foreground to cause the character to blink."%@NL@%
        FOR bgd% = 0 TO 7%@NL@%
            COLOR bgd% XOR 7, bgd%%@NL@%
            PRINT%@NL@%
            PRINT "Background%"; STR$(bgd%),%@NL@%
            PRINT "Foreground% ..."; SPACE$(41)%@NL@%
            FOR fgd% = 0 TO 15%@NL@%
                COLOR fgd%, bgd%%@NL@%
                PRINT STR$(fgd%); "  ";%@NL@%
            NEXT fgd%%@NL@%
        NEXT bgd%%@NL@%
        COLOR 7, 0%@NL@%
        PRINT%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Collision%                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        GAMES.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns TRUE if any non-zero pixels occur in the%@AE@%%@NL@%
%@AB@%  ' same byte of video memory, as saved in the object%()%@AE@%%@NL@%
%@AB@%  ' and backGround%() arrays.  The arrays must be the%@AE@%%@NL@%
%@AB@%  ' same size.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Collision% (object%(), backGround%()) STATIC%@NL@%
        lo% = LBOUND(object%)%@NL@%
        uo% = UBOUND(object%)%@NL@%
        lb% = LBOUND(backGround%)%@NL@%
        ub% = UBOUND(backGround%)%@NL@%
        IF lo% <> lb% OR uo% <> ub% THEN%@NL@%
            PRINT "Error: Collision - The object and background"%@NL@%
            PRINT "graphics arrays have different dimensions."%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
        FOR i% = lo% + 2 TO uo%%@NL@%
            IF object%(i%) THEN%@NL@%
                IF backGround%(i%) THEN%@NL@%
                    Collision% = TRUE%@NL@%
                    EXIT FUNCTION%@NL@%
                END IF%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
        Collision% = FALSE%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Date2Day%                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the day number given a date in the%@AE@%%@NL@%
%@AB@%  ' QuickBASIC string format "MM-DD-YYYY".%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Date2Day% (dat$) STATIC%@NL@%
        Date2Day% = VAL(MID$(dat$, 4, 2))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Date2Julian&               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the astronomical Julian day number given a%@AE@%%@NL@%
%@AB@%  ' date in the QuickBASIC string format "MM-DD-YYYY".%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Date2Julian& (dat$) STATIC%@NL@%
        month% = Date2Month%(dat$)%@NL@%
        day% = Date2Day%(dat$)%@NL@%
        year% = Date2Year%(dat$)%@NL@%
        IF year% < 1583 THEN%@NL@%
            PRINT "Date2Julian: Year is less than 1583"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
        IF month% > 2 THEN%@NL@%
            month% = month% - 3%@NL@%
        ELSE%@NL@%
            month% = month% + 9%@NL@%
            year% = year% - 1%@NL@%
        END IF%@NL@%
        ta& = 146097 * (year% \ 100) \ 4%@NL@%
        tb& = 1461& * (year% MOD 100) \ 4%@NL@%
        tc& = (153 * month% + 2) \ 5 + day% + 1721119%@NL@%
        Date2Julian& = ta& + tb& + tc&%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Date2Month%                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the month number given a date in the%@AE@%%@NL@%
%@AB@%  ' QuickBASIC string format "MM-DD-YYYY".%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Date2Month% (dat$) STATIC%@NL@%
        Date2Month% = VAL(MID$(dat$, 1, 2))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Date2Year%                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the year number given a date in the%@AE@%%@NL@%
%@AB@%  ' QuickBASIC string format "MM-DD-YYYY".%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Date2Year% (dat$) STATIC%@NL@%
        Date2Year% = VAL(MID$(dat$, 7))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DayOfTheWeek$              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a string stating the day of the week.%@AE@%%@NL@%
%@AB@%  ' Input is a date expressed in the QuickBASIC string%@AE@%%@NL@%
%@AB@%  ' format "MM-DD-YYYY".%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION DayOfTheWeek$ (dat$) STATIC%@NL@%
        SELECT CASE Date2Julian&(dat$) MOD 7%@NL@%
        CASE 0%@NL@%
            DayOfTheWeek$ = "Monday"%@NL@%
        CASE 1%@NL@%
            DayOfTheWeek$ = "Tuesday"%@NL@%
        CASE 2%@NL@%
            DayOfTheWeek$ = "Wednesday"%@NL@%
        CASE 3%@NL@%
            DayOfTheWeek$ = "Thursday"%@NL@%
        CASE 4%@NL@%
            DayOfTheWeek$ = "Friday"%@NL@%
        CASE 5%@NL@%
            DayOfTheWeek$ = "Saturday"%@NL@%
        CASE 6%@NL@%
            DayOfTheWeek$ = "Sunday"%@NL@%
        END SELECT%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DOSVersion!                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the version number of DOS%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION DOSVersion! STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        reg.ax = &H3000%@NL@%
        Interrupt &H21, reg, reg%@NL@%
        major% = reg.ax MOD 256%@NL@%
        minor% = reg.ax \ 256%@NL@%
        DOSVersion! = major% + minor% / 100!%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DrawBox                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        EDIT.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Draw a double line box%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB DrawBox (row1%, col1%, row2%, col2%) STATIC%@NL@%
%@NL@%
%@AB@%      ' Determine inside width of box%@AE@%%@NL@%
        wide% = col2% - col1% - 1%@NL@%
%@NL@%
%@AB@%      ' Across the top%@AE@%%@NL@%
        LOCATE row1%, col1%, 0%@NL@%
        PRINT CHR$(201);%@NL@%
        PRINT STRING$(wide%, 205);%@NL@%
        PRINT CHR$(187);%@NL@%
%@NL@%
%@AB@%      ' down the sides%@AE@%%@NL@%
        FOR row3% = row1% + 1 TO row2% - 1%@NL@%
            LOCATE row3%, col1%, 0%@NL@%
            PRINT CHR$(186);%@NL@%
            PRINT SPACE$(wide%);%@NL@%
            PRINT CHR$(186);%@NL@%
        NEXT row3%%@NL@%
%@NL@%
%@AB@%      ' Across the bottom%@AE@%%@NL@%
        LOCATE row2%, col1%, 0%@NL@%
        PRINT CHR$(200);%@NL@%
        PRINT STRING$(wide%, 205);%@NL@%
        PRINT CHR$(188);%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          EditLine                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        EDIT.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Allows editing of a string at the current cursor position%@AE@%%@NL@%
%@AB@%  ' on the screen.  Keys acted upon include Right-arrow,%@AE@%%@NL@%
%@AB@%  ' Left-arrow, Ctrl-left-arrow, Ctrl-right-arrow, Home, End,%@AE@%%@NL@%
%@AB@%  ' Insert, Escape, Enter, Backspace, and Delete.%@AE@%%@NL@%
%@AB@%  ' Pressing the Enter, Up-arrow, or Down-arrow terminates%@AE@%%@NL@%
%@AB@%  ' the subprogram and returns exitCode% of 0, +1, or -1.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB EditLine (a$, exitCode%) STATIC%@NL@%
%@NL@%
%@AB@%      ' Set up some variables%@AE@%%@NL@%
        row% = CSRLIN%@NL@%
        col% = POS(0)%@NL@%
        length% = LEN(a$)%@NL@%
        ptr% = 0%@NL@%
        insert% = TRUE%@NL@%
        quit% = FALSE%@NL@%
        original$ = a$%@NL@%
%@NL@%
%@AB@%      ' Main processing loop%@AE@%%@NL@%
        DO%@NL@%
%@NL@%
%@AB@%          ' Display the line%@AE@%%@NL@%
            LOCATE row%, col%, 0%@NL@%
            PRINT a$;%@NL@%
%@NL@%
%@AB@%          ' Show appropriate cursor type%@AE@%%@NL@%
            IF insert% THEN%@NL@%
                LOCATE row%, col% + ptr%, 1, 6, 7%@NL@%
            ELSE%@NL@%
                LOCATE row%, col% + ptr%, 1, 1, 7%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Get next key stroke%@AE@%%@NL@%
            keyNumber% = KeyCode%%@NL@%
%@NL@%
%@AB@%          ' Process the key%@AE@%%@NL@%
            SELECT CASE keyNumber%%@NL@%
%@NL@%
            CASE INSERTKEY%@NL@%
                IF insert% THEN%@NL@%
                    insert% = FALSE%@NL@%
                ELSE%@NL@%
                    insert% = TRUE%@NL@%
                END IF%@NL@%
%@NL@%
            CASE BACKSPACE%@NL@%
                IF ptr% THEN%@NL@%
                    a$ = a$ + " "%@NL@%
                    a$ = LEFT$(a$, ptr% - 1) + MID$(a$, ptr% + 1)%@NL@%
                    ptr% = ptr% - 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE DELETE%@NL@%
                a$ = a$ + " "%@NL@%
                a$ = LEFT$(a$, ptr%) + MID$(a$, ptr% + 2)%@NL@%
%@NL@%
            CASE UPARROW%@NL@%
                exitCode% = 1%@NL@%
                quit% = TRUE%@NL@%
%@NL@%
            CASE DOWNARROW%@NL@%
                exitCode% = -1%@NL@%
                quit% = TRUE%@NL@%
%@NL@%
            CASE LEFTARROW%@NL@%
                IF ptr% THEN%@NL@%
                    ptr% = ptr% - 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE RIGHTARROW%@NL@%
                IF ptr% < length% - 1 THEN%@NL@%
                    ptr% = ptr% + 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE ENTER%@NL@%
                exitCode% = 0%@NL@%
                quit% = TRUE%@NL@%
%@NL@%
            CASE HOME%@NL@%
                ptr% = 0%@NL@%
%@NL@%
            CASE ENDKEY%@NL@%
                ptr% = length% - 1%@NL@%
%@NL@%
            CASE CTRLRIGHTARROW%@NL@%
                DO UNTIL MID$(a$, ptr% + 1, 1) = " " OR ptr% = length% - 1%@NL@%
                    ptr% = ptr% + 1%@NL@%
                LOOP%@NL@%
                DO UNTIL MID$(a$, ptr% + 1, 1) <> " " OR ptr% = length% - 1%@NL@%
                    ptr% = ptr% + 1%@NL@%
                LOOP%@NL@%
%@NL@%
            CASE CTRLLEFTARROW%@NL@%
                DO UNTIL MID$(a$, ptr% + 1, 1) = " " OR ptr% = 0%@NL@%
                    ptr% = ptr% - 1%@NL@%
                LOOP%@NL@%
                DO UNTIL MID$(a$, ptr% + 1, 1) <> " " OR ptr% = 0%@NL@%
                    ptr% = ptr% - 1%@NL@%
                LOOP%@NL@%
                DO UNTIL MID$(a$, ptr% + 1, 1) = " " OR ptr% = 0%@NL@%
                    ptr% = ptr% - 1%@NL@%
                LOOP%@NL@%
                IF ptr% THEN%@NL@%
                    ptr% = ptr% + 1%@NL@%
                END IF%@NL@%
%@NL@%
            CASE CTRLY%@NL@%
                a$ = SPACE$(length%)%@NL@%
                ptr% = 0%@NL@%
%@NL@%
            CASE CTRLQ%@NL@%
                ctrlQflag% = TRUE%@NL@%
%@NL@%
            CASE ESCAPE%@NL@%
                a$ = original$%@NL@%
                ptr% = 0%@NL@%
                insert% = TRUE%@NL@%
%@NL@%
            CASE IS > 255%@NL@%
                SOUND 999, 1%@NL@%
%@NL@%
            CASE IS < 32%@NL@%
                SOUND 999, 1%@NL@%
%@NL@%
            CASE ELSE%@NL@%
%@NL@%
%@AB@%              ' Convert key code to character string%@AE@%%@NL@%
                kee$ = CHR$(keyNumber%)%@NL@%
%@NL@%
%@AB@%              ' Insert or overstrike%@AE@%%@NL@%
                IF insert% THEN%@NL@%
                    a$ = LEFT$(a$, ptr%) + kee$ + MID$(a$, ptr% + 1)%@NL@%
                    a$ = LEFT$(a$, length%)%@NL@%
                ELSE%@NL@%
                    IF ptr% < length% THEN%@NL@%
                        MID$(a$, ptr% + 1, 1) = kee$%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Are we up against the wall?%@AE@%%@NL@%
                IF ptr% < length% THEN%@NL@%
                    ptr% = ptr% + 1%@NL@%
                ELSE%@NL@%
                    SOUND 999, 1%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Special check for Ctrl-q-y (del to end of line)%@AE@%%@NL@%
                IF kee$ = "y" AND ctrlQflag% THEN%@NL@%
                    IF ptr% <= length% THEN%@NL@%
                        sp% = length% - ptr% + 1%@NL@%
                        MID$(a$, ptr%, sp%) = SPACE$(sp%)%@NL@%
                        ptr% = ptr% - 1%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Clear out the Ctrl-q signal%@AE@%%@NL@%
                ctrlQflag% = FALSE%@NL@%
%@NL@%
            END SELECT%@NL@%
%@NL@%
        LOOP UNTIL quit%%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Equipment                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BIOSCALL.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns equipment configuration information from BIOS%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Equipment (equip AS EquipmentType) STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        Interrupt &H11, reg, reg%@NL@%
        equip.printers = (reg.ax AND &HC000&) \ 16384%@NL@%
        equip.gameAdapter = (reg.ax AND &H1000) \ 4096%@NL@%
        equip.serial = (reg.ax AND &HE00) \ 512%@NL@%
        equip.floppies = (reg.ax AND &HC0) \ 64 + 1%@NL@%
        equip.initialVideo = (reg.ax AND &H30) \ 16%@NL@%
        equip.coprocessor = (reg.ax AND 2) \ 2%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FindFirstFile              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FILEINFO.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Finds first file that matches the path$%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FindFirstFile (path$, dta$, result%) STATIC%@NL@%
%@NL@%
%@AB@%      ' Initialization%@AE@%%@NL@%
        DIM reg AS RegTypeX%@NL@%
%@NL@%
%@AB@%      ' The path must be a null terminated string%@AE@%%@NL@%
        thePath$ = path$ + CHR$(0)%@NL@%
%@NL@%
%@AB@%      ' Get current DTA address%@AE@%%@NL@%
        reg.ax = &H2F00%@NL@%
        InterruptX &H21, reg, reg%@NL@%
        sgmt% = reg.es%@NL@%
        ofst% = reg.bx%@NL@%
%@NL@%
%@AB@%      ' Set dta address%@AE@%%@NL@%
        dta$ = SPACE$(43)%@NL@%
        reg.ax = &H1A00%@NL@%
        reg.ds = VARSEG(dta$)%@NL@%
        reg.dx = SADD(dta$)%@NL@%
        InterruptX &H21, reg, reg%@NL@%
%@NL@%
%@AB@%      ' Find first file match%@AE@%%@NL@%
        reg.ax = &H4E00%@NL@%
        reg.cx = FILEATTRIBUTE%@NL@%
        reg.ds = VARSEG(thePath$)%@NL@%
        reg.dx = SADD(thePath$)%@NL@%
        InterruptX &H21, reg, reg%@NL@%
%@NL@%
%@AB@%      ' The carry flag tells if a file was found or not%@AE@%%@NL@%
        result% = reg.flags AND 1%@NL@%
%@NL@%
%@AB@%      ' Reset the original DTA%@AE@%%@NL@%
        reg.ax = &H1A00%@NL@%
        reg.ds = sgmt%%@NL@%
        reg.dx = ofst%%@NL@%
        InterruptX &H21, reg, reg%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FindNextFile               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FILEINFO.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Locates next file. FindFirstFile must be called%@AE@%%@NL@%
%@AB@%  ' before this subprogram is called.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FindNextFile (dta$, result%) STATIC%@NL@%
%@NL@%
%@AB@%      ' Initialization%@AE@%%@NL@%
        DIM reg AS RegTypeX%@NL@%
%@NL@%
%@AB@%      ' Make sure dta$ was built (FindFirstFile should have been called)%@AE@%%@NL@%
        IF LEN(dta$) <> 43 THEN%@NL@%
            result% = 2%@NL@%
            EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Get current DTA address%@AE@%%@NL@%
        reg.ax = &H2F00%@NL@%
        InterruptX &H21, reg, reg%@NL@%
        sgmt% = reg.es%@NL@%
        ofst% = reg.bx%@NL@%
%@NL@%
%@AB@%      ' Set dta address%@AE@%%@NL@%
        reg.ax = &H1A00%@NL@%
        reg.ds = VARSEG(dta$)%@NL@%
        reg.dx = SADD(dta$)%@NL@%
        InterruptX &H21, reg, reg%@NL@%
%@NL@%
%@AB@%      ' Find next file match%@AE@%%@NL@%
        reg.ax = &H4F00%@NL@%
        reg.cx = FILEATTRIBUTE%@NL@%
        reg.ds = VARSEG(thePath$)%@NL@%
        reg.dx = SADD(thePath$)%@NL@%
        InterruptX &H21, reg, reg%@NL@%
%@NL@%
%@AB@%      ' The carry flag tells if a file was found or not%@AE@%%@NL@%
        result% = reg.flags AND 1%@NL@%
%@NL@%
%@AB@%      ' Reset the original DTA%@AE@%%@NL@%
        reg.ax = &H1A00%@NL@%
        reg.ds = sgmt%%@NL@%
        reg.dx = ofst%%@NL@%
        InterruptX &H21, reg, reg%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetDirectory$              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the name of the current directory for any drive.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION GetDirectory$ (drive$) STATIC%@NL@%
        DIM regX AS RegTypeX%@NL@%
        IF drive$ = "" THEN%@NL@%
            d$ = GetDrive$%@NL@%
        ELSE%@NL@%
            d$ = UCASE$(drive$)%@NL@%
        END IF%@NL@%
        drive% = ASC(d$) - 64%@NL@%
        regX.dx = drive%%@NL@%
        regX.ax = &H4700%@NL@%
        p$ = SPACE$(64)%@NL@%
        regX.ds = VARSEG(p$)%@NL@%
        regX.si = SADD(p$)%@NL@%
        InterruptX &H21, regX, regX%@NL@%
        p$ = LEFT$(p$, INSTR(p$, CHR$(0)) - 1)%@NL@%
        GetDirectory$ = LEFT$(d$, 1) + ":\" + p$%@NL@%
        IF regX.flags AND 1 THEN%@NL@%
            GetDirectory$ = ""%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetDiskFreeSpace           **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Get information about a drive's organization, including%@AE@%%@NL@%
%@AB@%  ' total number of bytes available.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB GetDiskFreeSpace (drive$, disk AS DiskFreeSpaceType)%@NL@%
        DIM reg AS RegType%@NL@%
        IF drive$ <> "" THEN%@NL@%
            drive% = ASC(UCASE$(drive$)) - 64%@NL@%
        ELSE%@NL@%
            drive% = 0%@NL@%
        END IF%@NL@%
        IF drive% >= 0 THEN%@NL@%
            reg.dx = drive%%@NL@%
        ELSE%@NL@%
            reg.dx = 0%@NL@%
        END IF%@NL@%
        reg.ax = &H3600%@NL@%
        Interrupt &H21, reg, reg%@NL@%
        disk.sectorsPerCluster = reg.ax%@NL@%
        disk.bytesPerSector = reg.cx%@NL@%
        IF reg.dx >= 0 THEN%@NL@%
            disk.clustersPerDrive = reg.dx%@NL@%
        ELSE%@NL@%
            disk.clustersPerDrive = reg.dx + 65536%@NL@%
        END IF%@NL@%
        IF reg.bx >= 0 THEN%@NL@%
            disk.availableClusters = reg.bx%@NL@%
        ELSE%@NL@%
            disk.availableClusters = reg.bx + 65536%@NL@%
        END IF%@NL@%
        disk.availableBytes = disk.availableClusters * reg.ax * reg.cx%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetDrive$                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the current disk drive name, such as "A:"%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION GetDrive$ STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        reg.ax = &H1900%@NL@%
        Interrupt &H21, reg, reg%@NL@%
        GetDrive$ = CHR$((reg.ax AND &HFF) + 65) + ":"%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetFileData                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        FILEINFO.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Extracts the file directory information from a Disk%@AE@%%@NL@%
%@AB@%  ' Transfer Area (dta$) that has been filled in by a%@AE@%%@NL@%
%@AB@%  ' call to either FindFirstFile or FindNextFile.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB GetFileData (dta$, file AS FileDataType) STATIC%@NL@%
%@NL@%
        file.attribute = ASC(MID$(dta$, 22, 1))%@NL@%
        tim& = CVI(MID$(dta$, 23, 2))%@NL@%
        IF tim& < 0 THEN%@NL@%
            tim& = tim& + 65536%@NL@%
        END IF%@NL@%
        file.second = tim& AND &H1F%@NL@%
        file.minute = (tim& \ 32) AND &H3F%@NL@%
        file.hour = (tim& \ 2048) AND &H1F%@NL@%
        dat& = CVI(MID$(dta$, 25, 2))%@NL@%
        file.day = dat& AND &H1F%@NL@%
        file.month = (dat& \ 32) AND &HF%@NL@%
        file.year = ((dat& \ 512) AND &H1F) + 1980%@NL@%
        file.size = CVL(MID$(dta$, 27, 4))%@NL@%
        f$ = MID$(dta$, 31) + CHR$(0)%@NL@%
        file.finame = LEFT$(f$, INSTR(f$, CHR$(0)) - 1)%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetShiftStates             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BIOSCALL.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns state of the various shift keys and states.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB GetShiftStates (shift AS ShiftType) STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        reg.ax = &H200%@NL@%
        Interrupt &H16, reg, reg%@NL@%
        shift.right = reg.ax AND 1%@NL@%
        shift.left = (reg.ax AND 2) \ 2%@NL@%
        shift.ctrl = (reg.ax AND 4) \ 4%@NL@%
        shift.alt = (reg.ax AND 8) \ 8%@NL@%
        shift.scrollLockState = (reg.ax AND 16) \ 16%@NL@%
        shift.numLockState = (reg.ax AND 32) \ 32%@NL@%
        shift.capsLockState = (reg.ax AND 64) \ 64%@NL@%
        shift.insertState = (reg.ax AND 128) \ 128%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GetVerifyState%            **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        DOSCALLS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%    ' Returns the current state of the DOS "Verify After%@AE@%%@NL@%
%@AB@%    ' Write" flag.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION GetVerifyState% STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        reg.ax = &H5400%@NL@%
        Interrupt &H21, reg, reg%@NL@%
        GetVerifyState% = reg.ax AND &HFF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          InKeyCode%                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        EDIT.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a unique integer for any key pressed, or%@AE@%%@NL@%
%@AB@%  ' a zero if no key has been pressed.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION InKeyCode% STATIC%@NL@%
        InKeyCode% = CVI(INKEY$ + STRING$(2, 0))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Julian2Date$               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a date in the QuickBASIC string format%@AE@%%@NL@%
%@AB@%  ' "MM-DD-YYYY" as calculated from a Julian day number.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Julian2Date$ (julian&) STATIC%@NL@%
%@NL@%
        x& = 4 * julian& - 6884477%@NL@%
        y& = (x& \ 146097) * 100%@NL@%
        d& = (x& MOD 146097) \ 4%@NL@%
%@NL@%
        x& = 4 * d& + 3%@NL@%
        y& = (x& \ 1461) + y&%@NL@%
        d& = (x& MOD 1461) \ 4 + 1%@NL@%
%@NL@%
        x& = 5 * d& - 3%@NL@%
        m& = x& \ 153 + 1%@NL@%
        d& = (x& MOD 153) \ 5 + 1%@NL@%
%@NL@%
        IF m& < 11 THEN%@NL@%
            month% = m& + 2%@NL@%
        ELSE%@NL@%
            month% = m& - 10%@NL@%
        END IF%@NL@%
        day% = d&%@NL@%
        year% = y& + m& \ 11%@NL@%
%@NL@%
        dat$ = MDY2Date$(month%, day%, year%)%@NL@%
        Julian2Date$ = dat$%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          KeyCode%                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        EDIT.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a unique integer for any key pressed.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION KeyCode% STATIC%@NL@%
        DO%@NL@%
            k$ = INKEY$%@NL@%
        LOOP UNTIL k$ <> ""%@NL@%
        KeyCode% = CVI(k$ + CHR$(0))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MDY2Date$                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Converts month%, day%, and year% to a date string%@AE@%%@NL@%
%@AB@%  ' in the QuickBASIC string format "MM-DD-YYYY".%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION MDY2Date$ (month%, day%, year%) STATIC%@NL@%
        y$ = RIGHT$("000" + MID$(STR$(year%), 2), 4)%@NL@%
        m$ = RIGHT$("0" + MID$(STR$(month%), 2), 2)%@NL@%
        d$ = RIGHT$("0" + MID$(STR$(day%), 2), 2)%@NL@%
        MDY2Date$ = m$ + "-" + d$ + "-" + y$%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MonthName$                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a string stating the month as indicated%@AE@%%@NL@%
%@AB@%  ' in dat$ (QuickBASIC string format "MM-DD-YYYY").%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION MonthName$ (dat$) STATIC%@NL@%
%@NL@%
        IF LEN(dat$) <> 10 THEN%@NL@%
            dat$ = "MM-DD-YYYY"%@NL@%
        END IF%@NL@%
%@NL@%
        SELECT CASE LEFT$(dat$, 2)%@NL@%
        CASE "01"%@NL@%
            MonthName$ = "January"%@NL@%
        CASE "02"%@NL@%
            MonthName$ = "February"%@NL@%
        CASE "03"%@NL@%
            MonthName$ = "March"%@NL@%
        CASE "04"%@NL@%
            MonthName$ = "April"%@NL@%
        CASE "05"%@NL@%
            MonthName$ = "May"%@NL@%
        CASE "06"%@NL@%
            MonthName$ = "June"%@NL@%
        CASE "07"%@NL@%
            MonthName$ = "July"%@NL@%
        CASE "08"%@NL@%
            MonthName$ = "August"%@NL@%
        CASE "09"%@NL@%
            MonthName$ = "September"%@NL@%
        CASE "10"%@NL@%
            MonthName$ = "October"%@NL@%
        CASE "11"%@NL@%
            MonthName$ = "November"%@NL@%
        CASE "12"%@NL@%
            MonthName$ = "December"%@NL@%
        CASE ELSE%@NL@%
            MonthName$ = "?MonthName?"%@NL@%
        END SELECT%@NL@%
%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseMickey                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Read mouse mickey counts%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseMickey (horizontal%, vertical%) STATIC%@NL@%
        Mouse 11, 0, horizontal%, vertical%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          OneMonthCalendar           **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        CALENDAR.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Prints a small, one month calendar at the row%%@AE@%%@NL@%
%@AB@%  ' and col% indicated.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB OneMonthCalendar (dat$, row%, col%) STATIC%@NL@%
        mname$ = MonthName$(dat$)%@NL@%
        LOCATE row%, col% + 12 - LEN(mname$) \ 2%@NL@%
        PRINT mname$; ","; Date2Year%(dat$)%@NL@%
        month% = Date2Month%(dat$)%@NL@%
        day% = 1%@NL@%
        year% = Date2Year%(dat$)%@NL@%
        dat1$ = MDY2Date$(month%, day%, year%)%@NL@%
        j& = Date2Julian&(dat1$)%@NL@%
        heading$ = " Sun Mon Tue Wed Thu Fri Sat"%@NL@%
        wa% = INSTR(heading$, LEFT$(DayOfTheWeek$(dat1$), 3)) \ 4%@NL@%
        LOCATE row% + 1, col%%@NL@%
        PRINT heading$%@NL@%
        rowloc% = row% + 2%@NL@%
        LOCATE rowloc%, col% + 4 * wa%%@NL@%
        DO%@NL@%
            PRINT USING "####"; day%;%@NL@%
            IF wa% = 6 THEN%@NL@%
                rowloc% = rowloc% + 1%@NL@%
                LOCATE rowloc%, col%%@NL@%
            END IF%@NL@%
            wa% = (wa% + 1) MOD 7%@NL@%
            j& = j& + 1%@NL@%
            day% = Date2Day%(Julian2Date$(j&))%@NL@%
        LOOP UNTIL day% = 1%@NL@%
        PRINT%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          SpaceWorms                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        INTRODEM.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' A simple game that demonstrates object creation and%@AE@%%@NL@%
%@AB@%  ' collision detection routines.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB SpaceWorms STATIC%@NL@%
%@NL@%
%@AB@%      ' Constants%@AE@%%@NL@%
        CONST WORMS = 2%@NL@%
        CONST WSEGS = 999%@NL@%
        CONST PI = 3.141593%@NL@%
        CONST RADIUS = 2%@NL@%
        CONST MICKFACTOR = 5%@NL@%
        CONST DOWNARROW = 20480%@NL@%
        CONST LEFTARROW = 19200%@NL@%
        CONST RIGHTARROW = 19712%@NL@%
        CONST UPARROW = 18432%@NL@%
        CONST HOMEKEY = 18176%@NL@%
        CONST ENDKEY = 20224%@NL@%
        CONST PGUP = 18688%@NL@%
        CONST PGDN = 20736%@NL@%
%@NL@%
%@AB@%      ' The worm ship arrays were built in module level code%@AE@%%@NL@%
        SHARED wormship1%(), wormship2%()%@NL@%
%@NL@%
%@AB@%      ' Initialization%@AE@%%@NL@%
        SCREEN 1%@NL@%
        COLOR BLUE, 1%@NL@%
        CLS%@NL@%
        RANDOMIZE TIMER%@NL@%
%@NL@%
%@AB@%      ' Dimension arrays for worm data%@AE@%%@NL@%
        REDIM row%(WORMS, WSEGS - 1)%@NL@%
        REDIM col%(WORMS, WSEGS - 1)%@NL@%
        REDIM h(WORMS)%@NL@%
        REDIM p%(WORMS)%@NL@%
        REDIM bgd%(0 TO 54)%@NL@%
%@NL@%
%@AB@%      ' Starting conditions%@AE@%%@NL@%
        t% = 0%@NL@%
        timeStart = TIMER%@NL@%
        t0 = timeStart%@NL@%
        n% = 0%@NL@%
        nseg% = 20%@NL@%
        zapped% = 0%@NL@%
        wx% = 160%@NL@%
        wy% = 100%@NL@%
        newx% = wx%%@NL@%
        newy% = wy%%@NL@%
%@NL@%
%@AB@%      ' Put starting ship image on the screen%@AE@%%@NL@%
        PUT (wx%, wy%), wormship1%%@NL@%
%@NL@%
%@AB@%      ' Set starting random worm headings%@AE@%%@NL@%
        FOR i% = 0 TO WORMS%@NL@%
            h(i%) = RND * PI%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' Main loop%@AE@%%@NL@%
        DO%@NL@%
%@NL@%
%@AB@%          ' Check for mouse movement%@AE@%%@NL@%
            MouseMickey horizontal%, vertical%%@NL@%
            newx% = (newx% + 293 + horizontal% / MICKFACTOR) MOD 293%@NL@%
            newy% = (newy% + 185 + vertical% / MICKFACTOR) MOD 185%@NL@%
%@NL@%
%@AB@%          ' Check for cursor keys%@AE@%%@NL@%
            SELECT CASE InKeyCode%%@NL@%
            CASE UPARROW%@NL@%
                newy% = (newy% + 175) MOD 185%@NL@%
            CASE DOWNARROW%@NL@%
                newy% = (newy% + 10) MOD 185%@NL@%
            CASE LEFTARROW%@NL@%
                newx% = (newx% + 283) MOD 293%@NL@%
            CASE RIGHTARROW%@NL@%
                newx% = (newx% + 10) MOD 293%@NL@%
            CASE HOMEKEY%@NL@%
                newy% = (newy% + 175) MOD 185%@NL@%
                newx% = (newx% + 283) MOD 293%@NL@%
            CASE ENDKEY%@NL@%
                newy% = (newy% + 10) MOD 185%@NL@%
                newx% = (newx% + 283) MOD 293%@NL@%
            CASE PGUP%@NL@%
                newx% = (newx% + 10) MOD 293%@NL@%
                newy% = (newy% + 175) MOD 185%@NL@%
            CASE PGDN%@NL@%
                newx% = (newx% + 10) MOD 293%@NL@%
                newy% = (newy% + 10) MOD 185%@NL@%
            CASE ELSE%@NL@%
            END SELECT%@NL@%
%@NL@%
%@AB@%          ' Draw the worm ship%@AE@%%@NL@%
            t% = NOT t%%@NL@%
            IF t% THEN%@NL@%
                PUT (wx%, wy%), wormship1%%@NL@%
                wx% = newx%%@NL@%
                wy% = newy%%@NL@%
                GET (wx%, wy%)-(wx% + 23, wy% + 14), bgd%%@NL@%
                PUT (wx%, wy%), wormship2%%@NL@%
                zapped% = Collision%(wormship2%(), bgd%())%@NL@%
            ELSE%@NL@%
                PUT (wx%, wy%), wormship2%%@NL@%
                wx% = newx%%@NL@%
                wy% = newy%%@NL@%
                GET (wx%, wy%)-(wx% + 23, wy% + 14), bgd%%@NL@%
                PUT (wx%, wy%), wormship1%%@NL@%
                zapped% = Collision%(wormship1%(), bgd%())%@NL@%
            END IF%@NL@%
%@NL@%
%@NL@%
%@AB@%          ' Sprout new worm or add segments every five seconds%@AE@%%@NL@%
            IF TIMER - t0 > 5 THEN%@NL@%
                IF n% < WORMS THEN%@NL@%
                    n% = n% + 1%@NL@%
                ELSE%@NL@%
                    IF nseg% < WSEGS THEN%@NL@%
                        nseg% = nseg% + 5%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
                t0 = TIMER%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Randomly adjust the worm headings%@AE@%%@NL@%
            FOR i% = 0 TO n%%@NL@%
                h(i%) = h(i%) + RND - .5%@NL@%
            NEXT i%%@NL@%
%@NL@%
%@AB@%          ' Move each worm%@AE@%%@NL@%
            FOR i% = 0 TO n%%@NL@%
                p2% = p%(i%)%@NL@%
                p1% = (p2% + nseg% - 1) MOD nseg%%@NL@%
                p3% = (p2% + nseg% + 1) MOD nseg%%@NL@%
                CIRCLE (row%(i%, p2%), col%(i%, p2%)), RADIUS, 0%@NL@%
                row%(i%, p2%) = (row%(i%, p1%) + COS(h(i%)) * 5 + 320) MOD 320%@NL@%
                col%(i%, p2%) = (col%(i%, p1%) + SIN(h(i%)) * 5 + 200) MOD 200%@NL@%
                CIRCLE (row%(i%, p2%), col%(i%, p2%)), RADIUS, 3%@NL@%
                p%(i%) = p3%%@NL@%
            NEXT i%%@NL@%
%@NL@%
        LOOP UNTIL zapped%%@NL@%
%@NL@%
%@AB@%      ' Display results%@AE@%%@NL@%
        LOCATE 1, 1%@NL@%
        elapsed = TIMER - timeStart%@NL@%
        PRINT USING "You stayed alive for####.# seconds!"; elapsed%@NL@%
        PRINT "Press <Enter> to continue..."%@NL@%
        DO%@NL@%
            backGround% = (backGround% + 1) MOD 8%@NL@%
            COLOR backGround%%@NL@%
            t0 = TIMER%@NL@%
            DO%@NL@%
            LOOP WHILE TIMER - t0 < .3%@NL@%
        LOOP UNTIL INKEY$ = CHR$(13)%@NL@%
%@NL@%
%@AB@%      ' All done%@AE@%%@NL@%
        SCREEN 0%@NL@%
        WIDTH 80%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          VideoState                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        BIOSCALL.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Determines the current video mode parameters.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB VideoState (mode%, columns%, page%) STATIC%@NL@%
        DIM reg AS RegType%@NL@%
        reg.ax = &HF00%@NL@%
        Interrupt &H10, reg, reg%@NL@%
        mode% = reg.ax AND &HFF%@NL@%
        columns% = (CLNG(reg.ax) AND &HFF00) \ 256%@NL@%
        page% = (CLNG(reg.bx) AND &HFF00) \ 256%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%INTRPT.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\INTRPT.ASM%@AE@%%@NL@%
%@NL@%
       TITLE   INTERRUPT - BASCOM software interrupt calling routine%@NL@%
        PAGE    56,132%@NL@%
%@AB@%;***%@AE@%%@NL@%
%@AB@%; INTERRUPT - BASCOM software interrupt calling routine%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       Copyright <C> 1986, 1987 Microsoft Corporation%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;Purpose:%@AE@%%@NL@%
%@AB@%;   Allows a BASIC program to invoke an interrupt through a CALL statement.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;   INTERRUPT allows BASIC to set AX,BX,CX,DX,BP,SI,DI, and the flags%@AE@%%@NL@%
%@AB@%;   before the call.  INTERRUPTX also allows DS and ES to be set.%@AE@%%@NL@%
%@AB@%;   Both routines will return the values of the registers upon the%@AE@%%@NL@%
%@AB@%;   completion of a successful call.  If the interrupt could not%@AE@%%@NL@%
%@AB@%;   be generated (due to a bad interrupt number or an illegal array)%@AE@%%@NL@%
%@AB@%;   then the interrupt number will be set to -1 to indicate an error.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;******************************************************************************%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;Note:%@AE@%%@NL@%
%@AB@%;   The DOSSEG, .MODEL, .CODE, and .DATA? directives used in this program%@AE@%%@NL@%
%@AB@%;   are part of the simplified segment system of MASM 5.0. If you have%@AE@%%@NL@%
%@AB@%;   an earlier version of MASM, you must modify the source to define%@AE@%%@NL@%
%@AB@%;   the segments required by Microsoft high-level languages. These%@AE@%%@NL@%
%@AB@%;   segments are discussed in Appendix C of "Learning and Using QuickBASIC."%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@NL@%
        DOSSEG                  %@AB@%;requires MASM 5.0 or higher%@AE@%%@NL@%
        .MODEL  medium%@NL@%
%@NL@%
%@AB@%;       Define all publicly accessible routines.%@AE@%%@NL@%
%@NL@%
        PUBLIC  INTERRUPT, INTERRUPTX%@NL@%
%@NL@%
%@AB@%;       Frame structure definition%@AE@%%@NL@%
%@NL@%
ARG1    =       0AH             %@AB@%;pointer to first of three arguments%@AE@%%@NL@%
ARG2    =       08H             %@AB@%;pointer to second of three arguments%@AE@%%@NL@%
ARG3    =       06H             %@AB@%;pointer to third of three arguments%@AE@%%@NL@%
%@NL@%
%@AB@%;       Frame temp variables%@AE@%%@NL@%
%@NL@%
UCODE_FLGS =    -02H            %@AB@%;user code flag register value%@AE@%%@NL@%
UCODE_DS =      -04H            %@AB@%;user code DS register value%@AE@%%@NL@%
REG_NUM =       -06H            %@AB@%;number of regs used (INTERRUPT=8, INTERRUPTX=10)%@AE@%%@NL@%
INT_ES  =       -08H            %@AB@%;INT ES register value%@AE@%%@NL@%
INT_DS  =       -0AH            %@AB@%;INT DS register value%@AE@%%@NL@%
INT_FLGS =      -0CH            %@AB@%;INT flags register value%@AE@%%@NL@%
INT_DI  =       -1EH            %@AB@%;INT DI register value%@AE@%%@NL@%
INT_SI  =       -10H            %@AB@%;INT SI register value%@AE@%%@NL@%
INT_BP  =       -12H            %@AB@%;INT BP register value%@AE@%%@NL@%
INT_DX  =       -14H            %@AB@%;INT DX register value%@AE@%%@NL@%
INT_CX  =       -16H            %@AB@%;INT CX register value%@AE@%%@NL@%
INT_BX  =       -18H            %@AB@%;INT BX register value%@AE@%%@NL@%
INT_AX  =       -1AH            %@AB@%;INT AX register value%@AE@%%@NL@%
OLD_SI  =       -1CH            %@AB@%;save old SI for interpreter%@AE@%%@NL@%
OLD_DI  =       -1EH            %@AB@%;save old DI for interpreter%@AE@%%@NL@%
%@NL@%
FRM_SIZ =       -1EH            %@AB@%;negative size of frame temporaries%@AE@%%@NL@%
%@NL@%
%@AB@%;       Locations past frame allocation used to recover post-INT BP value.%@AE@%%@NL@%
%@NL@%
INT_BP_TMP =    -22H            %@AB@%;temp location for INT BP register value%@AE@%%@NL@%
%@NL@%
%@AB@%;***%@AE@%%@NL@%
%@AB@%; INTERRUPT, and INTERRUPTX - BASCOM software interrupt calling interface%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Purpose:%@AE@%%@NL@%
%@AB@%;       To allow a BASIC Compiler program to perform any software%@AE@%%@NL@%
%@AB@%;       interrupt.  The interrupt is executed with the registers%@AE@%%@NL@%
%@AB@%;       set to values specified in a register variable.  The post-%@AE@%%@NL@%
%@AB@%;       interrupt values of the registers are then stored in%@AE@%%@NL@%
%@AB@%;       another register variable.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       CALL INTERRUPT[X] (int_no AS INTEGER,%@AE@%%@NL@%
%@AB@%;                          inreg AS RegType[X],%@AE@%%@NL@%
%@AB@%;                          outreg AS RegType[X])%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Inputs:%@AE@%%@NL@%
%@AB@%;       int_no = interrupt number (range 0 to 255) to execute%@AE@%%@NL@%
%@AB@%;       inreg and outreg are register variables of type RegType[X]%@AE@%%@NL@%
%@AB@%;       defined as follows;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; TYPE RegType%@AE@%%@NL@%
%@AB@%;     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%;     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%;     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%;     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%;     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%;     si    AS INTEGER%@AE@%%@NL@%
%@AB@%;     di    AS INTEGER%@AE@%%@NL@%
%@AB@%;     flags AS INTEGER%@AE@%%@NL@%
%@AB@%; END TYPE%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; TYPE RegTypeX%@AE@%%@NL@%
%@AB@%;     ax    AS INTEGER%@AE@%%@NL@%
%@AB@%;     bx    AS INTEGER%@AE@%%@NL@%
%@AB@%;     cx    AS INTEGER%@AE@%%@NL@%
%@AB@%;     dx    AS INTEGER%@AE@%%@NL@%
%@AB@%;     bp    AS INTEGER%@AE@%%@NL@%
%@AB@%;     si    AS INTEGER%@AE@%%@NL@%
%@AB@%;     di    AS INTEGER%@AE@%%@NL@%
%@AB@%;     flags AS INTEGER%@AE@%%@NL@%
%@AB@%;     ds    AS INTEGER%@AE@%%@NL@%
%@AB@%;     es    AS INTEGER%@AE@%%@NL@%
%@AB@%; END TYPE%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Outputs:%@AE@%%@NL@%
%@AB@%;       If no error:%@AE@%%@NL@%
%@AB@%;               int_no = unchanged (range 0 to 255)%@AE@%%@NL@%
%@AB@%;               outreg: This array will be set to the post-interrupt%@AE@%%@NL@%
%@AB@%;                       register values.  It has the same structure%@AE@%%@NL@%
%@AB@%;                       as inreg.%@AE@%%@NL@%
%@AB@%;       If error:%@AE@%%@NL@%
%@AB@%;               int_no = -1%@AE@%%@NL@%
%@AB@%;               outreg unchanged.  INT call is not performed.%@AE@%%@NL@%
%@AB@%;               error occurs:%@AE@%%@NL@%
%@AB@%;                       first argument not 0 to 255 (2^8-1)%@AE@%%@NL@%
%@AB@%;                       second or third arguments not  0 to 1048575 (2^20-1)%@AE@%%@NL@%
%@AB@%;                               (VARPTR will always be in this range)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Modifies:%@AE@%%@NL@%
%@AB@%;       All, except BP, DS, and flags.%@AE@%%@NL@%
%@AB@%;       Also, possible side effects of INT call.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%; Exceptions:%@AE@%%@NL@%
%@AB@%;       INT 24H call may result from some INT 21H MS-DOS calls.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;******************************************************************************%@AE@%%@NL@%
%@NL@%
        .CODE%@NL@%
%@NL@%
INTERRUPT PROC  FAR%@NL@%
%@NL@%
        PUSH    BP              %@AB@%;save BASCOM frame pointer on stack%@AE@%%@NL@%
        MOV     BP,SP           %@AB@%;establish program frame reference%@AE@%%@NL@%
        ADD     SP,FRM_SIZ      %@AB@%;allocate working space for frame%@AE@%%@NL@%
        MOV     WORD PTR [BP].REG_NUM,08H %@AB@%;eight regs used (not DS or ES)%@AE@%%@NL@%
        JMP     SHORT INTERRUPT_COMMON %@AB@%;jump to common code%@AE@%%@NL@%
%@NL@%
INTERRUPT ENDP%@NL@%
%@NL@%
%@NL@%
INTERRUPTX PROC FAR%@NL@%
%@NL@%
        PUSH    BP              %@AB@%;save BASCOM frame pointer on stack%@AE@%%@NL@%
        MOV     BP,SP           %@AB@%;establish program frame reference%@AE@%%@NL@%
        ADD     SP,FRM_SIZ      %@AB@%;allocate working space for frame%@AE@%%@NL@%
        MOV     WORD PTR [BP].REG_NUM,0AH %@AB@%;ten regs used (including DS and ES)%@AE@%%@NL@%
%@NL@%
%@AB@%;       Save a copy of the processor flags, SI, DI, and DS in the stack frame.%@AE@%%@NL@%
%@NL@%
INTERRUPT_COMMON:%@NL@%
        MOV     [BP].OLD_SI,SI  %@AB@%;save old SI for interpreter%@AE@%%@NL@%
        MOV     [BP].OLD_DI,DI  %@AB@%;save old DI for interpreter%@AE@%%@NL@%
        MOV     [BP].UCODE_DS,DS%@AB@%;save DS for interpreter%@AE@%%@NL@%
        PUSHF                   %@AB@%;push the flags on the stack%@AE@%%@NL@%
        POP     [BP].UCODE_FLGS %@AB@%;put value in the stack frame%@AE@%%@NL@%
%@NL@%
%@AB@%;       Move eight or ten words (depending if executing INTERRUPT or INTERRUPTX)%@AE@%%@NL@%
%@AB@%;       of the integer input array from the far pointer computed to the frame.%@AE@%%@NL@%
%@NL@%
        MOV     SI,[BP].ARG2    %@AB@%;and array offset - pointer in DS:SI%@AE@%%@NL@%
        LEA     DI,[BP].INT_AX  %@AB@%;get start of temporary register storage.%@AE@%%@NL@%
        MOV     CX,[BP].REG_NUM %@AB@%;eight or ten words to move%@AE@%%@NL@%
        CLD                     %@AB@%;movement is to higher memory%@AE@%%@NL@%
        PUSH    SS%@NL@%
        POP     ES%@NL@%
        REP     MOVSW           %@AB@%;move the array into the stack frame%@AE@%%@NL@%
%@NL@%
%@AB@%;       Save stack frame pointer to recover its value after the INT call.%@AE@%%@NL@%
%@NL@%
        PUSH    BP              %@AB@%;saved to first word past the stack frame%@AE@%%@NL@%
%@NL@%
%@AB@%;       Create a two-instruction program on the stack to execute the%@AE@%%@NL@%
%@AB@%;       INT call requested and return with stack cleanup.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       INT     XX      (hex: CD XX)%@AE@%%@NL@%
%@AB@%;       RETF    06      (hex: CA 06 00)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       In the case of INT 25 and 26 (which leave a word of flags on the stack)%@AE@%%@NL@%
%@AB@%;       We generate:%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       INT     XX      (hex: CD XX)%@AE@%%@NL@%
%@AB@%;       ADD     SP,2    (hex: 83 C4 02)%@AE@%%@NL@%
%@AB@%;       RETF    08      (hex: CA 08 00)%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
        MOV     SI,[BP].ARG1    %@AB@%;[SI] = ptr to first CALL arg - interrupt #%@AE@%%@NL@%
        MOV     BX,[SI]         %@AB@%;[BL] = get integer value of INT type%@AE@%%@NL@%
        OR      BH,BH           %@AB@%;test if in range, 00 to FFH is legal%@AE@%%@NL@%
        JZ      NO_INT_ERROR    %@AB@%;if not, then error - jump%@AE@%%@NL@%
        JMP     INT_ERROR       %@AB@%;long jump to error routine%@AE@%%@NL@%
NO_INT_ERROR:%@NL@%
%@NL@%
        CMP     BL,25H          %@AB@%;Interrupt 25 request?%@AE@%%@NL@%
        JZ      Int2526         %@AB@%;Jump if so%@AE@%%@NL@%
        CMP     BL,26H          %@AB@%;Interrupt 26 request?%@AE@%%@NL@%
        JNZ     IntNorm         %@AB@%;Jump if other, "normal" interrupt%@AE@%%@NL@%
Int2526:%@NL@%
        MOV     AX,8            %@AB@%;[AX] = argument of RETF instruction%@AE@%%@NL@%
        PUSH    AX%@NL@%
        MOV     AX,0CA02H       %@AB@%;[AX] = RETF opcode, & arg to ADD SP%@AE@%%@NL@%
        PUSH    AX%@NL@%
        MOV     AX,0C483H       %@AB@%;[AX] = ADD SP, opcode%@AE@%%@NL@%
        PUSH    AX%@NL@%
        JMP     SHORT IntInstruct%@NL@%
%@NL@%
IntNorm:%@NL@%
        XOR     AX,AX           %@AB@%;value of second word past frame%@AE@%%@NL@%
        PUSH    AX              %@AB@%;put on stack - 00 byte of RETF and filler%@AE@%%@NL@%
        MOV     AX,06CAH        %@AB@%;value of third word past frame%@AE@%%@NL@%
        PUSH    AX              %@AB@%;put on stack - CA 06 bytes of RETF%@AE@%%@NL@%
IntInstruct:%@NL@%
        MOV     AH,BL           %@AB@%;move interrupt number to upper byte of AX%@AE@%%@NL@%
        MOV     AL,0CDH         %@AB@%;value of fourth word past frame%@AE@%%@NL@%
        PUSH    AX              %@AB@%;put on stack - CD XX bytes of INT XX%@AE@%%@NL@%
%@NL@%
%@AB@%;       Push far pointer of return address after the stack program%@AE@%%@NL@%
%@AB@%;       executes, which is INT_RET in this code segment.%@AE@%%@NL@%
%@NL@%
        PUSH    CS              %@AB@%;push current code segment for return segment%@AE@%%@NL@%
        MOV     AX,OFFSET INT_RET %@AB@%;offset just after stack program call%@AE@%%@NL@%
        PUSH    AX              %@AB@%;push value for return offset%@AE@%%@NL@%
%@NL@%
%@AB@%;       Push far pointer pointer to the start of the stack program.%@AE@%%@NL@%
%@AB@%;       The stack program will be entered by executing a RETF after the%@AE@%%@NL@%
%@AB@%;       registers are set up.%@AE@%%@NL@%
%@NL@%
        PUSH    SS              %@AB@%;push current stack segment for starting ptr%@AE@%%@NL@%
        MOV     AX,SP           %@AB@%;get current stack offset%@AE@%%@NL@%
        ADD     AX,6            %@AB@%;move past the last three stack entries%@AE@%%@NL@%
        PUSH    AX              %@AB@%;push offset for starting ptr of stack program%@AE@%%@NL@%
%@NL@%
%@AB@%;       Move the input array values from the stack to their actual registers.%@AE@%%@NL@%
%@NL@%
        MOV     AX,[BP].INT_FLGS %@AB@%;get input flag register value%@AE@%%@NL@%
        AND     AX,0000111111010101B %@AB@%;mask out undefined 8086 flags%@AE@%%@NL@%
        PUSH    AX              %@AB@%;push masked flag register value%@AE@%%@NL@%
%@NL@%
        MOV     AX,[BP].INT_AX  %@AB@%;set up input AX value%@AE@%%@NL@%
        MOV     BX,[BP].INT_BX  %@AB@%;set up input BX value%@AE@%%@NL@%
        MOV     CX,[BP].INT_CX  %@AB@%;set up input CX value%@AE@%%@NL@%
        MOV     DX,[BP].INT_DX  %@AB@%;set up input DX value%@AE@%%@NL@%
%@NL@%
        MOV     SI,[BP].INT_SI  %@AB@%;set up input SI value%@AE@%%@NL@%
        MOV     DI,[BP].INT_DI  %@AB@%;set up input DI value%@AE@%%@NL@%
%@NL@%
%@AB@%;       For DS and ES, leave in the compiler data segment values if:%@AE@%%@NL@%
%@AB@%;       executing INTERRUPT; or executing INTERRUPTX with array values of -1.%@AE@%%@NL@%
%@NL@%
        CMP     WORD PTR [BP].REG_NUM,08H %@AB@%;test if executing INTERRUPT%@AE@%%@NL@%
        JE      INT_ES_DEF      %@AB@%;if so, then use both default values%@AE@%%@NL@%
%@NL@%
        CMP     [BP].INT_DS,0FFFFH %@AB@%;test if default DS to be used%@AE@%%@NL@%
        JE      INT_DS_DEF      %@AB@%;if so, then leave it unchanged%@AE@%%@NL@%
        MOV     DS,[BP].INT_DS  %@AB@%;set up input DS value%@AE@%%@NL@%
INT_DS_DEF:%@NL@%
        CMP     [BP].INT_ES,0FFFFH %@AB@%;test if default ES to be used%@AE@%%@NL@%
        JE      INT_ES_DEF      %@AB@%;if so, then leave it unchanged%@AE@%%@NL@%
        MOV     ES,[BP].INT_ES  %@AB@%;set up input ES value%@AE@%%@NL@%
INT_ES_DEF:%@NL@%
%@NL@%
        MOV     BP,[BP].INT_BP  %@AB@%;set up input BP value%@AE@%%@NL@%
                                %@AB@%;must be last move using BP%@AE@%%@NL@%
%@NL@%
        POPF                    %@AB@%;set up input flag register value%@AE@%%@NL@%
%@NL@%
%@AB@%;       With all registers set according to the input array, execute the%@AE@%%@NL@%
%@AB@%;       stack program.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       The following RETF pops the last two stack entries, which are%@AE@%%@NL@%
%@AB@%;       interpreted as a far pointer to the stack program.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       The stack program executes the INT XX call which changes the%@AE@%%@NL@%
%@AB@%;       registers (flags included) to the values to be put into the%@AE@%%@NL@%
%@AB@%;       output array.%@AE@%%@NL@%
%@AB@%;%@AE@%%@NL@%
%@AB@%;       The stack program then executes the RETF 06 instruction which%@AE@%%@NL@%
%@AB@%;       does two operations.  First, the next two entries on stack are%@AE@%%@NL@%
%@AB@%;       popped and interpreted as a far ptr return address, which points%@AE@%%@NL@%
%@AB@%;       the code at INT_RET in this code segment.  Second, the stack%@AE@%%@NL@%
%@AB@%;       pointer is then adjusted by six bytes to remove the six-byte%@AE@%%@NL@%
%@AB@%;       program from the stack.%@AE@%%@NL@%
%@NL@%
        RET                     %@AB@%;far return to execute stack program, etc.%@AE@%%@NL@%
INT_RET:%@NL@%
%@NL@%
%@AB@%;       The stack should now contain only the first entry past the%@AE@%%@NL@%
%@AB@%;       frame, the value of the stack frame pointer itself.  First%@AE@%%@NL@%
%@AB@%;       save the BP value from the INT call, then get the old value%@AE@%%@NL@%
%@AB@%;       to reference the frame.%@AE@%%@NL@%
%@NL@%
        PUSH    BP              %@AB@%;save post-INT value of BP%@AE@%%@NL@%
        MOV     BP,SP           %@AB@%;temporary frame is second word past frame%@AE@%%@NL@%
        MOV     BP,[BP+02H]     %@AB@%;get real frame reference value%@AE@%%@NL@%
%@NL@%
%@AB@%;       Put post-INT value of all registers into the frame variables%@AE@%%@NL@%
%@AB@%;       to be subsequently written into the output array.%@AE@%%@NL@%
%@NL@%
        PUSHF                   %@AB@%;put flags on the stack%@AE@%%@NL@%
        POP     [BP].INT_FLGS   %@AB@%;put in post-INT flag register value%@AE@%%@NL@%
%@NL@%
        PUSH    [BP].UCODE_FLGS %@AB@%;get old copy of flags from frame%@AE@%%@NL@%
        POPF                    %@AB@%;and restore the old flag values%@AE@%%@NL@%
%@NL@%
        MOV     [BP].INT_AX,AX  %@AB@%;put in post-INT AX value%@AE@%%@NL@%
        MOV     [BP].INT_BX,BX  %@AB@%;put in post-INT BX value%@AE@%%@NL@%
        MOV     [BP].INT_CX,CX  %@AB@%;put in post-INT CX value%@AE@%%@NL@%
        MOV     [BP].INT_DX,DX  %@AB@%;put in post-INT DX value%@AE@%%@NL@%
%@NL@%
        MOV     AX,[BP].INT_BP_TMP %@AB@%;get post-INT BP value (one entry past frame)%@AE@%%@NL@%
        MOV     [BP].INT_BP,AX  %@AB@%;put in post-INT BP value%@AE@%%@NL@%
%@NL@%
        MOV     [BP].INT_SI,SI  %@AB@%;put in post-INT SI value%@AE@%%@NL@%
        MOV     [BP].INT_DI,DI  %@AB@%;put in post-INT DI value%@AE@%%@NL@%
%@NL@%
        MOV     [BP].INT_DS,DS  %@AB@%;put in post-INT DS value%@AE@%%@NL@%
        MOV     [BP].INT_ES,ES  %@AB@%;put in post-INT ES value%@AE@%%@NL@%
%@NL@%
%@AB@%;       Move frame register values to the output array whose%@AE@%%@NL@%
%@AB@%;       far pointer is in the frame.%@AE@%%@NL@%
%@NL@%
        MOV     DS,[BP].UCODE_DS%@AB@%;replace original DS value%@AE@%%@NL@%
%@NL@%
        LEA     SI,[BP].INT_AX  %@AB@%;get start of register area in frame%@AE@%%@NL@%
%@NL@%
        PUSH    DS%@NL@%
        POP     ES%@NL@%
        MOV     DI,[BP].ARG3    %@AB@%;get output array offset%@AE@%%@NL@%
        MOV     CX,[BP].REG_NUM %@AB@%;eight or ten words to move%@AE@%%@NL@%
        CLD                     %@AB@%;movement is toward upper memory%@AE@%%@NL@%
        REP     MOVSW           %@AB@%;perform the transfer%@AE@%%@NL@%
%@NL@%
%@AB@%;       Clean up stack to remove frame.  Remove CALL arguments with RETF.%@AE@%%@NL@%
%@NL@%
        MOV     SI,[BP].OLD_SI  %@AB@%;replace old SI for interpreter%@AE@%%@NL@%
        MOV     DI,[BP].OLD_DI  %@AB@%;replace old DI for interpreter%@AE@%%@NL@%
        MOV     SP,BP           %@AB@%;deallocate temporary frame variables%@AE@%%@NL@%
        POP     BP              %@AB@%;return compiler frame pointer%@AE@%%@NL@%
        RET     06              %@AB@%;remove three CALL arguments and far return%@AE@%%@NL@%
%@NL@%
%@AB@%;       If error, then restore DS, set int_no to -1 to report error,%@AE@%%@NL@%
%@AB@%;       clean up, and exit.%@AE@%%@NL@%
%@NL@%
INT_ERROR:%@NL@%
        MOV     SI,[BP].ARG1    %@AB@%;ptr to first CALL arg - interrupt number%@AE@%%@NL@%
        MOV     [SI],0FFFFH     %@AB@%;set interrupt number to -1 for error%@AE@%%@NL@%
        MOV     SI,[BP].OLD_SI  %@AB@%;replace old SI for interpreter%@AE@%%@NL@%
        MOV     DI,[BP].OLD_DI  %@AB@%;replace old DI for interpreter%@AE@%%@NL@%
        MOV     DS,[BP].UCODE_DS%@AB@%;replace original DS value%@AE@%%@NL@%
        MOV     SP,BP           %@AB@%;deallocate temporary frame variables%@AE@%%@NL@%
        POP     BP              %@AB@%;return compiler frame pointer%@AE@%%@NL@%
        RET     06              %@AB@%;remove three CALL arguments and far return%@AE@%%@NL@%
%@NL@%
INTERRUPTX ENDP%@NL@%
%@NL@%
        END%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%JUSTIFY.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\JUSTIFY.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          JUSTIFY                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        JUSTIFY.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Demonstrates the Justify subprogram.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       JUSTIFY.BAS%@AE@%%@NL@%
%@AB@%  '                  EDIT.BAS%@AE@%%@NL@%
%@AB@%  '                  PARSE.BAS%@AE@%%@NL@%
%@AB@%  '                  KEYS.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       a$         String to be justified%@AE@%%@NL@%
%@AB@%  '                  col%       Number of columns for each example of Justify%@AE@%%@NL@%
%@AB@%  '                  x$         Working copy of a$%@AE@%%@NL@%
%@AB@%  '                  y$         Working string space%@AE@%%@NL@%
%@NL@%
%@NL@%
    DECLARE SUB Justify (a$, n%)%@NL@%
    DECLARE SUB ParseLine (x$, sep$, a$())%@NL@%
    DECLARE SUB FormatTwo (a$, b$, col%)%@NL@%
%@NL@%
    CLS%@NL@%
    a$ = ""%@NL@%
    a$ = a$ + "This paragraph is used to demonstrate the Justify "%@NL@%
    a$ = a$ + "subprogram.  First, the entire paragraph is "%@NL@%
    a$ = a$ + "placed in a single string variable.  This string "%@NL@%
    a$ = a$ + "is then split between words into shorter strings, "%@NL@%
    a$ = a$ + "and these shorter strings are then justified in "%@NL@%
    a$ = a$ + "order to align both the left and right edges of "%@NL@%
    a$ = a$ + "the text."%@NL@%
%@NL@%
    FOR col% = 50 TO 70 STEP 10%@NL@%
        x$ = a$%@NL@%
        DO%@NL@%
            FormatTwo x$, y$, col%%@NL@%
            IF y$ <> "" THEN%@NL@%
                Justify x$, col%%@NL@%
            END IF%@NL@%
            PRINT x$%@NL@%
            x$ = y$%@NL@%
        LOOP WHILE y$ <> ""%@NL@%
        PRINT%@NL@%
    NEXT col%%@NL@%
%@NL@%
    END%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Justify                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        JUSTIFY.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Spaces words with extra spaces until line%@AE@%%@NL@%
%@AB@%  ' is n% characters long.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Justify a$, n%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String to be justified%@AE@%%@NL@%
%@AB@%  '                  n%         Desired string length%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       ary$()     Array to store individual words from the string%@AE@%%@NL@%
%@AB@%  '                  cnt%       Count of non-space characters%@AE@%%@NL@%
%@AB@%  '                  i%         Looping index%@AE@%%@NL@%
%@AB@%  '                  j%         Count of words%@AE@%%@NL@%
%@AB@%  '                  each%      Minimum space count to insert between words%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Justify (a$, n%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB ParseLine (x$, sep$, a$())%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB FormatTwo (a$, b$, col%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Justify (a$, n%) STATIC%@NL@%
%@NL@%
%@AB@%      ' If string is shorter than n%, don't bother%@AE@%%@NL@%
        IF LEN(a$) < n% THEN%@NL@%
            EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Array for list of words from original string%@AE@%%@NL@%
        REDIM ary$(1 TO n%)%@NL@%
%@NL@%
%@AB@%      ' Split line up into individual words%@AE@%%@NL@%
        ParseLine a$, " ", ary$()%@NL@%
%@NL@%
%@AB@%      ' Count the words and total of non-space characters%@AE@%%@NL@%
        cnt% = 0%@NL@%
        FOR i% = n% TO 1 STEP -1%@NL@%
            cnt% = cnt% + LEN(ary$(i%))%@NL@%
            IF ary$(i%) = "" THEN%@NL@%
                j% = i% - 1%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' If only one or zero words, there's not much we can do%@AE@%%@NL@%
        IF j% < 2 THEN%@NL@%
            a$ = LEFT$(ary$(1) + SPACE$(n%), n%)%@NL@%
            EXIT SUB%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' We want an extra space at the ends of sentences, questions, etc.%@AE@%%@NL@%
        FOR i% = 1 TO j% - 1%@NL@%
            IF INSTR(".!?", RIGHT$(ary$(i%), 1)) THEN%@NL@%
                ary$(i%) = ary$(i%) + " "%@NL@%
                cnt% = cnt% + 1%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' How many spaces minimum to add to each word?%@AE@%%@NL@%
        each% = (n% - cnt%) \ (j% - 1)%@NL@%
%@NL@%
%@AB@%      ' Tack on the minimum spaces to each word%@AE@%%@NL@%
        FOR i% = 1 TO j% - 1%@NL@%
            ary$(i%) = ary$(i%) + SPACE$(each%)%@NL@%
            cnt% = cnt% + each%%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' Which is quicker, adding remaining spaces, or%@AE@%%@NL@%
%@AB@%      ' adding spaces to all and removing a few of them?%@AE@%%@NL@%
        IF (n% - cnt%) < j% \ 2 THEN%@NL@%
%@NL@%
%@AB@%          ' We'll add a few spaces at random%@AE@%%@NL@%
            DO UNTIL cnt% = n%%@NL@%
                DO%@NL@%
                    i% = INT(RND * (j% - 1) + 2)%@NL@%
                LOOP UNTIL LEFT$(ary$(i%), 1) <> " "%@NL@%
                ary$(i%) = " " + ary$(i%)%@NL@%
                cnt% = cnt% + 1%@NL@%
            LOOP%@NL@%
%@NL@%
        ELSE%@NL@%
%@NL@%
%@AB@%          ' We'll add a space to each, and then remove some at random%@AE@%%@NL@%
            FOR i% = 2 TO j%%@NL@%
                ary$(i%) = " " + ary$(i%)%@NL@%
                cnt% = cnt% + 1%@NL@%
            NEXT i%%@NL@%
%@NL@%
%@AB@%          ' Now we'll take a few away at random%@AE@%%@NL@%
            DO UNTIL cnt% = n%%@NL@%
                DO%@NL@%
                    i% = INT(RND * (j% - 1) + 2)%@NL@%
                LOOP UNTIL LEFT$(ary$(i%), 1) = " "%@NL@%
                ary$(i%) = MID$(ary$(i%), 2)%@NL@%
                cnt% = cnt% - 1%@NL@%
            LOOP%@NL@%
%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Glue it all back together%@AE@%%@NL@%
        a$ = ary$(1)%@NL@%
        FOR i% = 2 TO j%%@NL@%
            a$ = a$ + ary$(i%)%@NL@%
        NEXT i%%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%KEYS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\KEYS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          KEYS                       **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        KEYS.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Demonstrates keyboard access functions.%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       kee%       Unique integer returned by KeyCode% and%@AE@%%@NL@%
%@AB@%  '                             InKeyCode%%@AE@%%@NL@%
%@NL@%
    DECLARE FUNCTION KeyCode% ()%@NL@%
    DECLARE FUNCTION InKeyCode% ()%@NL@%
%@NL@%
    CLS%@NL@%
    PRINT "Press any key to see the unique number returned by KeyCode%."%@NL@%
    PRINT "Press Esc to see InKeyCode% results for 1 second."%@NL@%
    PRINT "Press Esc twice in a row to quit."%@NL@%
    PRINT%@NL@%
%@NL@%
    DO%@NL@%
        kee% = KeyCode%%@NL@%
        PRINT kee%%@NL@%
        IF kee% = 27 THEN%@NL@%
            t0 = TIMER%@NL@%
            DO%@NL@%
                kee% = InKeyCode%%@NL@%
                PRINT kee%;%@NL@%
                IF kee% THEN%@NL@%
                    PRINT%@NL@%
                END IF%@NL@%
                IF kee% = 27 THEN%@NL@%
                    quitFlag% = -1%@NL@%
                    t0 = t0 - 1%@NL@%
                END IF%@NL@%
            LOOP UNTIL TIMER - t0 > 1%@NL@%
            PRINT%@NL@%
        END IF%@NL@%
    LOOP UNTIL quitFlag%%@NL@%
%@NL@%
    END%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          InKeyCode%                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        KEYS.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a unique integer for any key pressed or%@AE@%%@NL@%
%@AB@%  ' a zero if no key was pressed.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  k% = InKeyCode%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION KeyCode% ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION InKeyCode% STATIC%@NL@%
        InKeyCode% = CVI(INKEY$ + STRING$(2, 0))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          KeyCode%                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        KEYS.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a unique integer for any key pressed.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  k% = KeyCode%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION KeyCode% ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION KeyCode% STATIC%@NL@%
        DO%@NL@%
            k$ = INKEY$%@NL@%
        LOOP UNTIL k$ <> ""%@NL@%
        KeyCode% = CVI(k$ + CHR$(0))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%LOOK.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\LOOK.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          LOOK                       **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        LOOK.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           LOOK filename.ext%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       LOOK.BAS%@AE@%%@NL@%
%@AB@%  '                  KEYS.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      filename.ext  Name of file to view%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       a$()          Array of lines from the file%@AE@%%@NL@%
%@AB@%  '                  fileName$     Name of file, from the command line%@AE@%%@NL@%
%@AB@%  '                  lineCount%    Count of lines read from the file%@AE@%%@NL@%
%@AB@%  '                  linePtr%      First file line currently on the display%@AE@%%@NL@%
%@AB@%  '                  i%            Loop index for printing 24 lines%@AE@%%@NL@%
%@AB@%  '                  quitFlag%     Indicates Escape key press%@AE@%%@NL@%
%@AB@%  '                  updateFlag%   Indicates if update of screen is necessary%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Constants%@AE@%%@NL@%
    CONST FALSE = 0%@NL@%
    CONST TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%  ' Key code numbers%@AE@%%@NL@%
    CONST UPARROW = 18432%@NL@%
    CONST DOWNARROW = 20480%@NL@%
    CONST PGUP = 18688%@NL@%
    CONST PGDN = 20736%@NL@%
    CONST HOME = 18176%@NL@%
    CONST ENDKEY = 20224%@NL@%
    CONST ESCAPE = 27%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION KeyCode% ()%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB FileRead (fileName$, lineCount%, a$())%@NL@%
%@NL@%
%@AB@%  ' Dimension string array%@AE@%%@NL@%
%@AB@%  ' NOTE:%@AE@%%@NL@%
%@AB@%  ' Must be dimensioned big enough to read in all lines from the file%@AE@%%@NL@%
    DIM a$(1 TO 2000)%@NL@%
%@NL@%
%@AB@%  ' Get the command line parameters%@AE@%%@NL@%
    fileName$ = COMMAND$%@NL@%
%@NL@%
%@AB@%  ' Read in the file%@AE@%%@NL@%
    ON ERROR GOTO FileError%@NL@%
    FileRead fileName$, lineCount%, a$()%@NL@%
    ON ERROR GOTO 0%@NL@%
%@NL@%
%@AB@%  ' Prepare the screen%@AE@%%@NL@%
    SCREEN 0, 0, 0, 0%@NL@%
    CLS%@NL@%
%@NL@%
%@AB@%  ' Set line pointer%@AE@%%@NL@%
    linePtr% = 1%@NL@%
%@NL@%
%@AB@%  ' Main loop%@AE@%%@NL@%
    DO%@NL@%
%@NL@%
%@AB@%      ' Print information bar at top%@AE@%%@NL@%
        VIEW PRINT 1 TO 1%@NL@%
        COLOR 0, 3%@NL@%
        LOCATE 1, 1%@NL@%
        PRINT " Line:"; LEFT$(STR$(linePtr%) + SPACE$(7), 8);%@NL@%
        PRINT "File: "; LEFT$(fileName$ + SPACE$(19), 19);%@NL@%
        PRINT "Quit: ESC"; SPACE$(3);%@NL@%
        PRINT "Move: "; CHR$(24); " "; CHR$(25); " PGUP PGDN HOME END ";%@NL@%
%@NL@%
%@AB@%      ' Update the 24 lines of text%@AE@%%@NL@%
        VIEW PRINT 2 TO 25%@NL@%
        COLOR 7, 1%@NL@%
        FOR i% = 0 TO 23%@NL@%
            LOCATE i% + 2, 1%@NL@%
            PRINT LEFT$(a$(i% + linePtr%) + SPACE$(80), 80);%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' Wait for a meaningful key to be pressed%@AE@%%@NL@%
        SELECT CASE KeyCode%%@NL@%
        CASE UPARROW%@NL@%
            IF linePtr% > 1 THEN%@NL@%
                linePtr% = linePtr% - 1%@NL@%
            END IF%@NL@%
        CASE DOWNARROW%@NL@%
            IF linePtr% < lineCount% THEN%@NL@%
                linePtr% = linePtr% + 1%@NL@%
            END IF%@NL@%
        CASE PGUP%@NL@%
            IF linePtr% > 1 THEN%@NL@%
                linePtr% = linePtr% - 24%@NL@%
                IF linePtr% < 1 THEN%@NL@%
                    linePtr% = 1%@NL@%
                END IF%@NL@%
            END IF%@NL@%
        CASE PGDN%@NL@%
            IF linePtr% < lineCount% - 24 THEN%@NL@%
                linePtr% = linePtr% + 24%@NL@%
                IF linePtr% > lineCount% THEN%@NL@%
                    linePtr% = lineCount%%@NL@%
                END IF%@NL@%
            END IF%@NL@%
        CASE HOME%@NL@%
            IF linePtr% > 1 THEN%@NL@%
                linePtr% = 1%@NL@%
            END IF%@NL@%
        CASE ENDKEY%@NL@%
            IF linePtr% < lineCount% - 24 THEN%@NL@%
                linePtr% = lineCount% - 24%@NL@%
            END IF%@NL@%
        CASE ESCAPE%@NL@%
            quitFlag% = TRUE%@NL@%
        CASE ELSE%@NL@%
            updateFlag% = FALSE%@NL@%
        END SELECT%@NL@%
%@NL@%
    LOOP UNTIL quitFlag%%@NL@%
%@NL@%
%@AB@%  ' Set color back to normal%@AE@%%@NL@%
    COLOR 7, 0%@NL@%
    END%@NL@%
%@NL@%
FileError:%@NL@%
    PRINT%@NL@%
    PRINT "Usage: LOOK filename.ext"%@NL@%
    SYSTEM%@NL@%
    RESUME NEXT%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FileRead                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        LOOK.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Reads lines of an ASCII file into a$().  The%@AE@%%@NL@%
%@AB@%  ' lineCount% is set to the number of lines read%@AE@%%@NL@%
%@AB@%  ' in.  If a$() wasn't dimensioned large enough,%@AE@%%@NL@%
%@AB@%  ' then lineCount% will be set to -1.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  FileRead fileName$, lineCount%, a$()%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      fileName$     Name of file to be read into the array%@AE@%%@NL@%
%@AB@%  '                  lineCount%    Returned count of lines read from the file%@AE@%%@NL@%
%@AB@%  '                  a$()          String array of file contents%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       FileNumber%   Next available free file number%@AE@%%@NL@%
%@AB@%  '                  i%            Index for string array%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:    DECLARE SUB FileRead (fileName$, lineCount%, a$())%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FileRead (fileName$, lineCount%, a$()) STATIC%@NL@%
        FileNumber% = FREEFILE%@NL@%
        OPEN fileName$ FOR INPUT AS FileNumber%%@NL@%
        FOR i% = LBOUND(a$) TO UBOUND(a$)%@NL@%
            LINE INPUT #FileNumber%, a$(i%)%@NL@%
            lineCount% = i%%@NL@%
            IF EOF(FileNumber%) THEN%@NL@%
                EXIT FOR%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
        IF NOT EOF(FileNumber%) THEN%@NL@%
            lineCount% = -1%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MANDEL.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\MANDEL.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z         ' Default variable type is integer%@NL@%
%@NL@%
DECLARE SUB ShiftPalette ()%@NL@%
DECLARE SUB WindowVals (WL%, WR%, WT%, WB%)%@NL@%
DECLARE SUB ScreenTest (EM%, CR%, VL%, VR%, VT%, VB%)%@NL@%
%@NL@%
CONST FALSE = 0, TRUE = NOT FALSE       ' Boolean constants%@NL@%
%@NL@%
%@AB@%' Set maximum number of iterations per point:%@AE@%%@NL@%
CONST MAXLOOP = 30, MAXSIZE = 1000000%@NL@%
%@NL@%
DIM PaletteArray(15)%@NL@%
FOR I = 0 TO 15 : PaletteArray(I) = I : NEXT I%@NL@%
%@NL@%
%@AB@%' Call WindowVals to get coordinates of window corners:%@AE@%%@NL@%
WindowVals WLeft, WRight, WTop, WBottom%@NL@%
%@NL@%
%@AB@%' Call ScreenTest to find out if this is an EGA machine,%@AE@%%@NL@%
%@AB@%' and get coordinates of viewport corners:%@AE@%%@NL@%
ScreenTest EgaMode, ColorRange, VLeft, VRight, VTop, VBottom%@NL@%
%@NL@%
%@AB@%' Define viewport and corresponding window:%@AE@%%@NL@%
VIEW (VLeft, VTop)-(VRight, VBottom), 0, ColorRange%@NL@%
WINDOW (WLeft, WTop)-(WRight, WBottom)%@NL@%
%@NL@%
LOCATE 24, 10 : PRINT "Press any key to quit.";%@NL@%
%@NL@%
XLength = VRight - VLeft%@NL@%
YLength = VBottom - VTop%@NL@%
ColorWidth = MAXLOOP \ ColorRange%@NL@%
%@NL@%
%@AB@%' Loop through each pixel in viewport and calculate%@AE@%%@NL@%
%@AB@%' whether or not it is in the Mandelbrot Set:%@AE@%%@NL@%
FOR Y = 0 TO YLength       ' Loop through every line in%@NL@%
%@AB@%                           ' the viewport.%@AE@%%@NL@%
   LogicY = PMAP(Y, 3)     ' Get the pixel's logical y%@NL@%
%@AB@%                           ' coordinate.%@AE@%%@NL@%
   PSET (WLeft, LogicY)    ' Plot leftmost pixel in the line.%@NL@%
   OldColor = 0            ' Start with background color.%@NL@%
%@NL@%
   FOR X = 0 TO XLength    ' Loop through every pixel in%@NL@%
%@AB@%                           ' the line.%@AE@%%@NL@%
      LogicX = PMAP(X, 2)  ' Get the pixel's logical x%@NL@%
%@AB@%                           ' coordinate .%@AE@%%@NL@%
      MandelX& = LogicX%@NL@%
      MandelY& = LogicY%@NL@%
%@NL@%
%@AB@%      ' Do the calculations to see if this point is in%@AE@%%@NL@%
%@AB@%      ' the Mandelbrot Set:%@AE@%%@NL@%
      FOR I = 1 TO MAXLOOP%@NL@%
         RealNum& = MandelX& * MandelX&%@NL@%
         ImagNum& = MandelY& * MandelY&%@NL@%
         IF (RealNum& + ImagNum&) >= MAXSIZE THEN EXIT  FOR%@NL@%
         MandelY& = (MandelX& * MandelY&) \ 250 + LogicY%@NL@%
         MandelX& = (RealNum& - ImagNum&) \ 500 + LogicX%@NL@%
      NEXT I%@NL@%
%@NL@%
%@AB@%      ' Assign a color to the point:%@AE@%%@NL@%
      PColor = I \ ColorWidth%@NL@%
%@NL@%
%@AB@%      ' If color has changed, draw a line from the%@AE@%%@NL@%
%@AB@%      ' last point referenced to the new point,%@AE@%%@NL@%
%@AB@%      ' using the old color:%@AE@%%@NL@%
      IF PColor <> OldColor THEN%@NL@%
         LINE -(LogicX, LogicY), (ColorRange - OldColor)%@NL@%
         OldColor = PColor%@NL@%
      END IF%@NL@%
%@NL@%
      IF INKEY$ <> "" THEN END%@NL@%
   NEXT X%@NL@%
%@NL@%
%@AB@%   ' Draw the last line segment to the right edge of%@AE@%%@NL@%
%@AB@%   ' the viewport:%@AE@%%@NL@%
   LINE -(LogicX, LogicY), (ColorRange - OldColor)%@NL@%
%@NL@%
%@AB@%   ' If this is an EGA machine, shift the palette after%@AE@%%@NL@%
%@AB@%   ' drawing each line:%@AE@%%@NL@%
   IF EgaMode THEN ShiftPalette%@NL@%
NEXT Y%@NL@%
%@NL@%
DO%@NL@%
%@AB@%   ' Continue shifting the palette until the user%@AE@%%@NL@%
%@AB@%   ' presses a key:%@AE@%%@NL@%
   IF EgaMode THEN ShiftPalette%@NL@%
LOOP WHILE INKEY$ = ""%@NL@%
%@NL@%
SCREEN 0, 0             ' Restore the screen to text mode,%@NL@%
WIDTH 80                ' 80 columns.%@NL@%
END%@NL@%
%@NL@%
BadScreen:              ' Error handler that is invoked if%@NL@%
   EgaMode = FALSE      ' there is no EGA graphics card%@NL@%
   RESUME NEXT%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================= ShiftPalette =======================%@AE@%%@NL@%
%@AB@%' Rotates the palette by one each time it is called.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ShiftPalette STATIC%@NL@%
   SHARED PaletteArray(), ColorRange%@NL@%
%@NL@%
   FOR I = 1 TO ColorRange%@NL@%
      PaletteArray(I) = (PaletteArray(I) MOD ColorRange) + 1%@NL@%
   NEXT I%@NL@%
   PALETTE USING PaletteArray(0)%@NL@%
%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================== ScreenTest ========================%@AE@%%@NL@%
%@AB@%'    Tests to see if user has EGA hardware with SCREEN 8.%@AE@%%@NL@%
%@AB@%'    If this causes an error, the EM flag is set to FALSE,%@AE@%%@NL@%
%@AB@%'    and the screen is set with SCREEN 1.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'    Also sets values for corners of viewport (VL = left,%@AE@%%@NL@%
%@AB@%'    VR = right, VT = top, VB = bottom), scaled with the%@AE@%%@NL@%
%@AB@%'    correct aspect ratio so viewport is a perfect square.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ScreenTest (EM, CR, VL, VR, VT, VB) STATIC%@NL@%
   EM = TRUE%@NL@%
   ON ERROR GOTO BadScreen%@NL@%
   SCREEN 8, 1%@NL@%
   ON ERROR GOTO 0%@NL@%
%@NL@%
   IF EM THEN           ' No error, so SCREEN 8 is OK%@NL@%
      VL = 110  : VR = 529%@NL@%
      VT = 5    : VB = 179%@NL@%
      CR = 15           ' 16 colors (0 - 15)%@NL@%
%@NL@%
   ELSE                 ' Error, so use SCREEN 1%@NL@%
      SCREEN 1, 1%@NL@%
      VL = 55   : VR = 264%@NL@%
      VT = 5    : VB = 179%@NL@%
      CR = 3            ' 4 colors (0 - 3)%@NL@%
   END IF%@NL@%
%@NL@%
END SUB%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================== WindowVals ========================%@AE@%%@NL@%
%@AB@%'     Gets window corners as input from the user, or sets%@AE@%%@NL@%
%@AB@%'     values for the corners if there is no input.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB WindowVals (WL, WR, WT, WB) STATIC%@NL@%
   CLS%@NL@%
   PRINT "This program prints the graphic representation of"%@NL@%
   PRINT "the complete Mandelbrot Set. The default window is"%@NL@%
   PRINT "from (-1000,625) to (250,-625). To zoom in on part"%@NL@%
   PRINT "of the figure, input coordinates inside this window."%@NL@%
   PRINT%@NL@%
   PRINT "Press <ENTER> to see the default window. Press any"%@NL@%
   PRINT "other key to input your own window coordinates: ";%@NL@%
   LOCATE , , 1%@NL@%
   Resp$ = INPUT$(1)%@NL@%
%@NL@%
%@AB@%   ' User didn't press ENTER, so input window corners:%@AE@%%@NL@%
   IF Resp$ <> CHR$(13) THEN%@NL@%
      PRINT%@NL@%
      INPUT "X coordinate of upper left corner: ", WL%@NL@%
      DO%@NL@%
         INPUT "X coordinate of lower right corner: ", WR%@NL@%
         IF WR <= WL THEN%@NL@%
         PRINT "Right corner must be greater than left corner."%@NL@%
         END IF%@NL@%
      LOOP WHILE WR <= WL%@NL@%
      INPUT "Y coordinate of upper left corner: ", WT%@NL@%
      DO%@NL@%
         INPUT "Y coordinate of lower right corner: ", WB%@NL@%
         IF WB >= WT THEN%@NL@%
         PRINT "Bottom corner must be less than top corner."%@NL@%
         END IF%@NL@%
      LOOP WHILE WB >= WT%@NL@%
%@NL@%
   ELSE         ' Pressed ENTER, so set default values.%@NL@%
      WL = -1000%@NL@%
      WR = 250%@NL@%
      WT = 625%@NL@%
      WB = -625%@NL@%
   END IF%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MONTH.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\MONTH.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MONTH                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MONTH.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Creates and displays a three-month calendar.%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       MONTH.BAS%@AE@%%@NL@%
%@AB@%  '                  CALENDAR.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       year%      Year of concern%@AE@%%@NL@%
%@AB@%  '                  month%     Month of concern%@AE@%%@NL@%
%@AB@%  '                  quitFlag%  Indicates that program is to terminate%@AE@%%@NL@%
%@AB@%  '                  day%       Day near middle of the month%@AE@%%@NL@%
%@AB@%  '                  d2$        Date for second calendar month%@AE@%%@NL@%
%@AB@%  '                  j2&        Julian day number for second calendar month%@AE@%%@NL@%
%@AB@%  '                  d1$        Date for first calendar month%@AE@%%@NL@%
%@AB@%  '                  j1&        Julian day number for first calendar month%@AE@%%@NL@%
%@AB@%  '                  d3$        Date for third calendar month%@AE@%%@NL@%
%@AB@%  '                  j3&        Julian day number for third calendar month%@AE@%%@NL@%
%@AB@%  '                  k$         Key press character%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Constants%@AE@%%@NL@%
    CONST FALSE = 0%@NL@%
    CONST TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION Date2Julian& (dat$)%@NL@%
    DECLARE FUNCTION MDY2Date$ (month%, day%, year%)%@NL@%
    DECLARE FUNCTION Date2Year% (dat$)%@NL@%
    DECLARE FUNCTION Date2Month% (dat$)%@NL@%
    DECLARE FUNCTION Julian2Date$ (julian&)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB OneMonthCalendar (dat$, row%, col%)%@NL@%
%@NL@%
%@AB@%  ' Get today's month and year%@AE@%%@NL@%
    year% = Date2Year%(DATE$)%@NL@%
    month% = Date2Month%(DATE$)%@NL@%
%@NL@%
%@AB@%  ' Make calendars until the Esc key is pressed%@AE@%%@NL@%
    DO UNTIL quitFlag%%@NL@%
%@NL@%
%@AB@%      ' Get Julian day number for about the middle of the month%@AE@%%@NL@%
        day% = 15%@NL@%
        d2$ = MDY2Date$(month%, day%, year%)%@NL@%
        j2& = Date2Julian&(d2$)%@NL@%
%@NL@%
%@AB@%      ' Get last month's date%@AE@%%@NL@%
        j1& = j2& - 30%@NL@%
        d1$ = Julian2Date$(j1&)%@NL@%
%@NL@%
%@AB@%      ' Get next month's date%@AE@%%@NL@%
        j3& = j2& + 30%@NL@%
        d3$ = Julian2Date$(j3&)%@NL@%
%@NL@%
%@AB@%      ' Display the heading%@AE@%%@NL@%
        CLS%@NL@%
        LOCATE 1, 57%@NL@%
        PRINT "THREE-MONTH CALENDAR"%@NL@%
        LOCATE 2, 57%@NL@%
        PRINT "QuickBASIC 4.0"%@NL@%
%@NL@%
%@AB@%      ' Create the three calendar sheets%@AE@%%@NL@%
        OneMonthCalendar d1$, 1, 1%@NL@%
        OneMonthCalendar d2$, 8, 25%@NL@%
        OneMonthCalendar d3$, 15, 49%@NL@%
%@NL@%
%@AB@%      ' Display the instructions%@AE@%%@NL@%
        LOCATE 17, 1%@NL@%
        PRINT "Press <Y> to increment the year"%@NL@%
        LOCATE 18, 1%@NL@%
        PRINT "Press <y> to decrement the year"%@NL@%
        LOCATE 19, 1%@NL@%
        PRINT "Press <M> to increment the months"%@NL@%
        LOCATE 20, 1%@NL@%
        PRINT "Press <m> to decrement the months"%@NL@%
        LOCATE 22, 1%@NL@%
        PRINT "Press the Esc key to quit"%@NL@%
%@NL@%
%@AB@%      ' Wait for a keystroke%@AE@%%@NL@%
        DO%@NL@%
            k$ = INKEY$%@NL@%
        LOOP UNTIL k$ <> ""%@NL@%
%@NL@%
%@AB@%      ' Check for appropriate keystroke%@AE@%%@NL@%
        SELECT CASE k$%@NL@%
        CASE "y"%@NL@%
            year% = year% - 1%@NL@%
        CASE "Y"%@NL@%
            year% = year% + 1%@NL@%
        CASE "m"%@NL@%
            month% = month% - 3%@NL@%
        CASE "M"%@NL@%
            month% = month% + 3%@NL@%
        CASE CHR$(27)%@NL@%
            quitFlag% = TRUE%@NL@%
        CASE ELSE%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%      ' Adjust month for proper range%@AE@%%@NL@%
        IF month% < 1 THEN%@NL@%
            month% = month% + 12%@NL@%
            year% = year% - 1%@NL@%
        ELSEIF month% > 12 THEN%@NL@%
            month% = month% - 12%@NL@%
            year% = year% + 1%@NL@%
        END IF%@NL@%
%@NL@%
    LOOP%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    END%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MOUSE.ASM%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\MOUSE.ASM%@AE@%%@NL@%
%@NL@%
 %@AB@%; **********************************************%@AE@%%@NL@%
 %@AB@%; **  MOUSE.ASM              Macro Assembler  **%@AE@%%@NL@%
 %@AB@%; **                                          **%@AE@%%@NL@%
 %@AB@%; **  Assembly subprogram for accessing the   **%@AE@%%@NL@%
 %@AB@%; **  Microsoft Mouse from QuickBASIC 4.00    **%@AE@%%@NL@%
 %@AB@%; **                                          **%@AE@%%@NL@%
 %@AB@%; **  Use:  CALL MOUSE (M1%, M2%, M3%, M4%)   **%@AE@%%@NL@%
 %@AB@%; **********************************************%@AE@%%@NL@%
 %@AB@%;%@AE@%%@NL@%
 %@AB@%; EXAMPLE OF USE:  CALL Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
 %@AB@%; PARAMETERS:      m1%        Passed in AX to the mouse driver%@AE@%%@NL@%
 %@AB@%;                  m2%        Passed in BX to the mouse driver%@AE@%%@NL@%
 %@AB@%;                  m3%        Passed in CX to the mouse driver%@AE@%%@NL@%
 %@AB@%;                  m4%        Passed in DX to the mouse driver%@AE@%%@NL@%
 %@AB@%; VARIABLES:       (none)%@AE@%%@NL@%
 %@AB@%; MODULE LEVEL%@AE@%%@NL@%
 %@AB@%;   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@NL@%
.MODEL  MEDIUM%@NL@%
.CODE%@NL@%
        public  mouse%@NL@%
%@NL@%
mouse   proc%@NL@%
%@NL@%
%@AB@%; Standard entry%@AE@%%@NL@%
        push    bp%@NL@%
        mov     bp,sp%@NL@%
%@NL@%
%@AB@%; Get M1% and store it on the stack%@AE@%%@NL@%
        mov     bx,[bp+12]%@NL@%
        mov     ax,[bx]%@NL@%
        push    ax%@NL@%
%@NL@%
%@AB@%; Get M2% and store it on the stack%@AE@%%@NL@%
        mov     bx,[bp+10]%@NL@%
        mov     ax,[bx]%@NL@%
        push    ax%@NL@%
%@NL@%
%@AB@%; Get M3% into CX register%@AE@%%@NL@%
        mov     bx,[bp+8]%@NL@%
        mov     cx,[bx]%@NL@%
%@NL@%
%@AB@%; Get M4% into DX register%@AE@%%@NL@%
        mov     bx,[bp+6]%@NL@%
        mov     dx,[bx]%@NL@%
%@NL@%
%@AB@%; Move M2% from stack into BX register%@AE@%%@NL@%
        pop     bx%@NL@%
%@NL@%
%@AB@%; Move M1% from stack into AX register%@AE@%%@NL@%
        pop     ax%@NL@%
%@NL@%
%@AB@%; Set ES to same as DS (for mouse function 9)%@AE@%%@NL@%
        push    ds%@NL@%
        pop     es%@NL@%
%@NL@%
%@AB@%; Do the mouse interrupt%@AE@%%@NL@%
        int     33h%@NL@%
%@NL@%
%@AB@%; Save BX (M2%) on stack to free register%@AE@%%@NL@%
        push    bx%@NL@%
%@NL@%
%@AB@%; Return M1% from AX%@AE@%%@NL@%
        mov     bx,[bp+12]%@NL@%
        mov     [bx],ax%@NL@%
%@NL@%
%@AB@%; Return M2% from stack (was BX)%@AE@%%@NL@%
        pop     ax%@NL@%
        mov     bx,[bp+10]%@NL@%
        mov     [bx],ax%@NL@%
%@NL@%
%@AB@%; Return M3% from CX%@AE@%%@NL@%
        mov     bx,[bp+8]%@NL@%
        mov     [bx],cx%@NL@%
%@NL@%
%@AB@%; Return M4% from DX%@AE@%%@NL@%
        mov     bx,[bp+6]%@NL@%
        mov     [bx],dx%@NL@%
%@NL@%
%@AB@%; Standard exit, assumes four variables passed%@AE@%%@NL@%
        pop     bp%@NL@%
        ret     8%@NL@%
%@NL@%
%@AB@%; End of this procedure%@AE@%%@NL@%
mouse   endp%@NL@%
        end%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MOUSGCRS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK1\MOUSGCRS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MOUSGCRS                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSGCRS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Program for the interactive design of graphics-%@AE@%%@NL@%
%@AB@%  ' mode mouse cursor subroutines.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:          No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:   CGA%@AE@%%@NL@%
%@AB@%  '                 MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  '                 Mouse%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:      MOUSGCRS.BAS%@AE@%%@NL@%
%@AB@%  '                 BITS.BAS%@AE@%%@NL@%
%@AB@%  '                 MOUSSUBS.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:     (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      curs$()       Array of binary cursor string data%@AE@%%@NL@%
%@AB@%  '                 defaultMask$  Pattern mask for the default cursor%@AE@%%@NL@%
%@AB@%  '                 xdef%         Default hot spot X value%@AE@%%@NL@%
%@AB@%  '                 ydef%         Default hot spot Y value%@AE@%%@NL@%
%@AB@%  '                 mask$         Pattern mask for a cursor%@AE@%%@NL@%
%@AB@%  '                 xHot%         Hot spot X value%@AE@%%@NL@%
%@AB@%  '                 yHot%         Hot spot Y value%@AE@%%@NL@%
%@AB@%  '                 maskChr%      Index into the pattern mask%@AE@%%@NL@%
%@AB@%  '                 maskPtr%      Index to the background or foreground mask%@AE@%%@NL@%
%@AB@%  '                               pattern%@AE@%%@NL@%
%@AB@%  '                 y%            Cursor bit pointer, vertical%@AE@%%@NL@%
%@AB@%  '                 x%            Cursor bit pointer, horizontal%@AE@%%@NL@%
%@AB@%  '                 xbox%         X location on screen for cursor bit box%@AE@%%@NL@%
%@AB@%  '                 ybox%         Y location on screen for cursor bit box%@AE@%%@NL@%
%@AB@%  '                 xh%           Screen X location for hot spot%@AE@%%@NL@%
%@AB@%  '                 yh%           Screen Y location for hot spot%@AE@%%@NL@%
%@AB@%  '                 click$        DRAW string for creating the click boxes%@AE@%%@NL@%
%@AB@%  '                 quitFlag%     Indication that user wants to quit%@AE@%%@NL@%
%@AB@%  '                 t$            Copy of TIME$%@AE@%%@NL@%
%@AB@%  '                 toggle%       Once per second toggle for hot spot visibility%@AE@%%@NL@%
%@AB@%  '                 pxl%          Pixel value at the hot spot%@AE@%%@NL@%
%@AB@%  '                 leftButton%   Current state of the left mouse button%@AE@%%@NL@%
%@AB@%  '                 rightButton%  Current state of the right mouse button%@AE@%%@NL@%
%@AB@%  '                 resetBox%     Indicates cursor is in the "Try standard%@AE@%%@NL@%
%@AB@%  '                               cursors" box%@AE@%%@NL@%
%@AB@%  '                 tryBox%       Indicates cursor is in the "Try new cursor"%@AE@%%@NL@%
%@AB@%  '                               box%@AE@%%@NL@%
%@AB@%  '                 subBox%       Indicates cursor is in the "Create cursor%@AE@%%@NL@%
%@AB@%  '                               subroutine" box%@AE@%%@NL@%
%@AB@%  '                 quitBox%      Indicates cursor is in the "Quit" box%@AE@%%@NL@%
%@AB@%  '                 xold%         X location of just-modified pixel box%@AE@%%@NL@%
%@AB@%  '                 yold%         Y location of just-modified pixel box%@AE@%%@NL@%
%@AB@%  '                 ix%           X bit pointer for pixel change%@AE@%%@NL@%
%@AB@%  '                 iy%           Y bit pointer for pixel change%@AE@%%@NL@%
%@AB@%  '                 q$            Double-quote character%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Define constants%@AE@%%@NL@%
    CONST FALSE = 0%@NL@%
    CONST TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB Cursdflt (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Curschek (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Curshand (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Curshour (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Cursjet (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Cursleft (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Cursplus (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Cursup (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Cursx (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB MouseShow ()%@NL@%
    DECLARE SUB MouseNow (lbutton%, rbutton%, xMouse%, yMouse%)%@NL@%
    DECLARE SUB MouseHide ()%@NL@%
    DECLARE SUB MouseMaskTranslate (mask$, xHot%, yHot%, cursor$)%@NL@%
    DECLARE SUB MouseSetGcursor (cursor$)%@NL@%
%@NL@%
%@AB@%  ' Arrays%@AE@%%@NL@%
    DIM curs$(0 TO 8)%@NL@%
%@NL@%
%@AB@%  ' Initialization%@AE@%%@NL@%
    SCREEN 2%@NL@%
    CLS%@NL@%
%@NL@%
%@AB@%  ' Create set of cursors%@AE@%%@NL@%
    Cursdflt defaultMask$, xdef%, ydef%%@NL@%
    MouseMaskTranslate defaultMask$, xdef%, ydef%, curs$(0)%@NL@%
%@NL@%
    Curschek mask$, xHot%, yHot%%@NL@%
    MouseMaskTranslate mask$, xHot%, yHot%, curs$(1)%@NL@%
%@NL@%
    Curshand mask$, xHot%, yHot%%@NL@%
    MouseMaskTranslate mask$, xHot%, yHot%, curs$(2)%@NL@%
%@NL@%
    Curshour mask$, xHot%, yHot%%@NL@%
    MouseMaskTranslate mask$, xHot%, yHot%, curs$(3)%@NL@%
%@NL@%
    Cursjet mask$, xHot%, yHot%%@NL@%
    MouseMaskTranslate mask$, xHot%, yHot%, curs$(4)%@NL@%
%@NL@%
    Cursleft mask$, xHot%, yHot%%@NL@%
    MouseMaskTranslate mask$, xHot%, yHot%, curs$(5)%@NL@%
%@NL@%
    Cursplus mask$, xHot%, yHot%%@NL@%
    MouseMaskTranslate mask$, xHot%, yHot%, curs$(6)%@NL@%
%@NL@%
    Cursup mask$, xHot%, yHot%%@NL@%
    MouseMaskTranslate mask$, xHot%, yHot%, curs$(7)%@NL@%
%@NL@%
    Cursx mask$, xHot%, yHot%%@NL@%
    MouseMaskTranslate mask$, xHot%, yHot%, curs$(8)%@NL@%
%@NL@%
%@AB@%  ' Set the default cursor%@AE@%%@NL@%
    MouseSetGcursor curs$(0)%@NL@%
%@NL@%
%@AB@%  ' Make the default cursor the starting point for editing%@AE@%%@NL@%
    mask$ = defaultMask$%@NL@%
    xHot% = xdef%%@NL@%
    yHot% = ydef%%@NL@%
%@NL@%
%@AB@%  ' Place titles above pixel boxes%@AE@%%@NL@%
    LOCATE 2, 22, 0%@NL@%
    PRINT "Screen mask";%@NL@%
    LOCATE 2, 50, 0%@NL@%
    PRINT "Cursor mask";%@NL@%
%@NL@%
%@AB@%  ' Outline the pixel boxes, filling the "ones" using the Mask$%@AE@%%@NL@%
    maskChr% = 0%@NL@%
    FOR maskPtr% = 0 TO 1%@NL@%
        FOR y% = 1 TO 16%@NL@%
            FOR x% = 1 TO 16%@NL@%
                xbox% = x% * 12 + maskPtr% * 222 + 107%@NL@%
                ybox% = y% * 9 + 10%@NL@%
                maskChr% = maskChr% + 1%@NL@%
                LINE (xbox%, ybox%)-(xbox% + 12, ybox% + 9), 1, B%@NL@%
                IF MID$(mask$, maskChr%, 1) = "1" THEN%@NL@%
                    LINE (xbox% + 3, ybox% + 2)-(xbox% + 9, ybox% + 7), 1, BF%@NL@%
                END IF%@NL@%
                IF maskPtr% = 0 THEN%@NL@%
                    IF x% = xHot% + 1 AND y% = yHot% + 1 THEN%@NL@%
                        xh% = xbox%%@NL@%
                        yh% = ybox%%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
            NEXT x%%@NL@%
        NEXT y%%@NL@%
    NEXT maskPtr%%@NL@%
%@NL@%
%@AB@%  ' Instruction text at bottom of display%@AE@%%@NL@%
    LOCATE 23, 1%@NL@%
    PRINT TAB(16); "Left button       Right button         Both buttons"%@NL@%
    PRINT TAB(16); "to set pixel      to clear pixel       for hot spot";%@NL@%
%@NL@%
%@AB@%  ' Print menu items%@AE@%%@NL@%
    LOCATE 3, 2, 0%@NL@%
    PRINT "Try";%@NL@%
    LOCATE 4, 2, 0%@NL@%
    PRINT "standard";%@NL@%
    LOCATE 5, 2, 0%@NL@%
    PRINT "cursors";%@NL@%
    LOCATE 9, 2, 0%@NL@%
    PRINT "Try new";%@NL@%
    LOCATE 10, 2, 0%@NL@%
    PRINT "cursor";%@NL@%
    LOCATE 14, 2, 0%@NL@%
    PRINT "Create"%@NL@%
    LOCATE 15, 2, 0%@NL@%
    PRINT "cursor";%@NL@%
    LOCATE 16, 2, 0%@NL@%
    PRINT "subroutine";%@NL@%
    LOCATE 16, 74, 0%@NL@%
    PRINT "Quit";%@NL@%
%@NL@%
%@AB@%  ' Make click box draw string%@AE@%%@NL@%
    click$ = "R20D10L20U10BF5BR1F3E6"%@NL@%
%@NL@%
%@AB@%  ' Draw the click boxes%@AE@%%@NL@%
    DRAW "BM20,45" + click$%@NL@%
    DRAW "BM20,85" + click$%@NL@%
    DRAW "BM20,132" + click$%@NL@%
    DRAW "BM592,132" + click$%@NL@%
%@NL@%
%@AB@%  ' Make a white cursor testing area%@AE@%%@NL@%
    LOCATE 5, 71%@NL@%
    PRINT "Cursor";%@NL@%
    LOCATE 6, 71%@NL@%
    PRINT "viewing";%@NL@%
    LOCATE 7, 71%@NL@%
    PRINT "area";%@NL@%
    LINE (560, 60)-(610, 100), 1, BF%@NL@%
%@NL@%
%@AB@%  ' Turn on the mouse%@AE@%%@NL@%
    MouseShow%@NL@%
%@NL@%
%@AB@%  ' Main processing loop control%@AE@%%@NL@%
    DO%@NL@%
        GOSUB MainLoop%@NL@%
    LOOP UNTIL quitFlag%%@NL@%
%@NL@%
%@AB@%  ' Exit the loop and end program because Quitflag% has been set%@AE@%%@NL@%
    CLS%@NL@%
    SYSTEM%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Main processing loop%@AE@%%@NL@%
MainLoop:%@NL@%
%@NL@%
%@AB@%  ' Toggle the hot spot once per second%@AE@%%@NL@%
    IF t$ <> TIME$ THEN%@NL@%
        t$ = TIME$%@NL@%
        IF toggle% = 1 THEN%@NL@%
            toggle% = 0%@NL@%
        ELSE%@NL@%
            toggle% = 1%@NL@%
        END IF%@NL@%
        pxl% = POINT(xh% + 3, yh% + 2) XOR toggle%%@NL@%
        LINE (xh% + 5, yh% + 3)-(xh% + 7, yh% + 6), pxl%, BF%@NL@%
        pxl% = POINT(xh% + 3 + 222, yh% + 2) XOR toggle%%@NL@%
        LINE (xh% + 5 + 222, yh% + 3)-(xh% + 7 + 222, yh% + 6), pxl%, BF%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' What is the mouse location and button state right now?%@AE@%%@NL@%
    MouseNow leftButton%, rightButton%, x%, y%%@NL@%
%@NL@%
%@AB@%  ' Are both buttons being pressed right now?%@AE@%%@NL@%
    IF leftButton% AND rightButton% THEN%@NL@%
        GOSUB WhichBox%@NL@%
        IF xbox% THEN%@NL@%
            GOSUB SetHotSpot%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Are we traversing the "Try standard cursors" click box?%@AE@%%@NL@%
    IF x% > 20 AND x% < 40 AND y% > 45 AND y% < 55 THEN%@NL@%
        IF resetBox% = 0 THEN%@NL@%
            MouseHide%@NL@%
            resetBox% = 1%@NL@%
            LINE (17, 43)-(43, 57), 1, B%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
        IF resetBox% = 1 THEN%@NL@%
            MouseHide%@NL@%
            resetBox% = 0%@NL@%
            LINE (17, 43)-(43, 57), 0, B%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Are we traversing the "Try new cursor" click box?%@AE@%%@NL@%
    IF x% > 20 AND x% < 40 AND y% > 85 AND y% < 95 THEN%@NL@%
        IF tryBox% = 0 THEN%@NL@%
            MouseHide%@NL@%
            tryBox% = 1%@NL@%
            LINE (17, 83)-(43, 97), 1, B%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
        IF tryBox% = 1 THEN%@NL@%
            MouseHide%@NL@%
            tryBox% = 0%@NL@%
            LINE (17, 83)-(43, 97), 0, B%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Are we traversing the "Create cursor subroutine" click box?%@AE@%%@NL@%
    IF x% > 20 AND x% < 40 AND y% > 132 AND y% < 142 THEN%@NL@%
        IF subBox% = 0 THEN%@NL@%
            MouseHide%@NL@%
            subBox% = 1%@NL@%
            LINE (17, 130)-(43, 144), 1, B%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
        IF subBox% = 1 THEN%@NL@%
            MouseHide%@NL@%
            subBox% = 0%@NL@%
            LINE (17, 130)-(43, 144), 0, B%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Are we traversing the "Quit" click box?%@AE@%%@NL@%
    IF x% > 592 AND x% < 612 AND y% > 132 AND y% < 142 THEN%@NL@%
        IF quitBox% = 0 THEN%@NL@%
            MouseHide%@NL@%
            quitBox% = 1%@NL@%
            LINE (589, 130)-(615, 144), 1, B%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    ELSE%@NL@%
        IF quitBox% = 1 THEN%@NL@%
            MouseHide%@NL@%
            quitBox% = 0%@NL@%
            LINE (589, 130)-(615, 144), 0, B%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' If just one button or the other is pressed, then check further%@AE@%%@NL@%
    IF leftButton% XOR rightButton% THEN%@NL@%
        GOSUB ButtonWasPressed%@NL@%
    ELSE%@NL@%
        xold% = 0%@NL@%
        yold% = 0%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' End of main loop%@AE@%%@NL@%
    RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Is the mouse currently pointing at a pixel box?%@AE@%%@NL@%
WhichBox:%@NL@%
    IF x% > 320 THEN%@NL@%
        maskPtr% = 1%@NL@%
        x% = x% - 222%@NL@%
    ELSE%@NL@%
        maskPtr% = 0%@NL@%
    END IF%@NL@%
    ix% = (x% - 107) \ 12%@NL@%
    iy% = (y% - 10) \ 9%@NL@%
    xbox% = 0%@NL@%
    ybox% = 0%@NL@%
    IF ix% >= 1 AND ix% <= 16 THEN%@NL@%
        IF iy% >= 1 AND iy% <= 16 THEN%@NL@%
            xbox% = ix% * 12 + maskPtr% * 222 + 107%@NL@%
            ybox% = iy% * 9 + 10%@NL@%
        END IF%@NL@%
    END IF%@NL@%
    RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Move the hot spot to the current pixel box%@AE@%%@NL@%
SetHotSpot:%@NL@%
    IF (xbox% <> xh% AND xbox% - 222 <> xh%) OR ybox% <> yh% THEN%@NL@%
        MouseHide%@NL@%
        pxl% = POINT(xh% + 3, yh% + 2)%@NL@%
        LINE (xh% + 5, yh% + 3)-(xh% + 7, yh% + 6), pxl%, BF%@NL@%
        pxl% = POINT(xh% + 3 + 222, yh% + 2)%@NL@%
        LINE (xh% + 5 + 222, yh% + 3)-(xh% + 7 + 222, yh% + 6), pxl%, BF%@NL@%
        MouseShow%@NL@%
        IF xbox% > 320 THEN%@NL@%
            xh% = xbox% - 222%@NL@%
        ELSE%@NL@%
            xh% = xbox%%@NL@%
        END IF%@NL@%
        yh% = ybox%%@NL@%
    END IF%@NL@%
    RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Process the button press depending on mouse location%@AE@%%@NL@%
ButtonWasPressed:%@NL@%
    IF quitBox% THEN%@NL@%
        GOSUB DoQuitBox%@NL@%
    ELSEIF resetBox% THEN%@NL@%
        GOSUB DoResetCursor%@NL@%
    ELSEIF tryBox% THEN%@NL@%
        GOSUB DoSetNewCursor%@NL@%
    ELSEIF subBox% THEN%@NL@%
        GOSUB DoSetNewCursor%@NL@%
        GOSUB DoCreateSub%@NL@%
    ELSE%@NL@%
        GOSUB DoPixelControl%@NL@%
    END IF%@NL@%
    RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Button was pressed while mouse was in the "Quit" box%@AE@%%@NL@%
DoQuitBox:%@NL@%
    MouseHide%@NL@%
    quitFlag% = TRUE%@NL@%
    RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Button was pressed while mouse was in the "Try new cursor" box%@AE@%%@NL@%
DoSetNewCursor:%@NL@%
    MouseHide%@NL@%
    maskChr% = 0%@NL@%
    FOR maskPtr% = 0 TO 1%@NL@%
        FOR y% = 1 TO 16%@NL@%
            FOR x% = 1 TO 16%@NL@%
                xbox% = x% * 12 + maskPtr% * 222 + 107%@NL@%
                ybox% = y% * 9 + 10%@NL@%
                maskChr% = maskChr% + 1%@NL@%
                IF POINT(xbox% + 3, ybox% + 2) THEN%@NL@%
                    MID$(mask$, maskChr%, 1) = "1"%@NL@%
                ELSE%@NL@%
                    MID$(mask$, maskChr%, 1) = "0"%@NL@%
                END IF%@NL@%
                IF xbox% = xh% AND ybox% = yh% THEN%@NL@%
                    xHot% = x% - 1%@NL@%
                    yHot% = y% - 1%@NL@%
                END IF%@NL@%
            NEXT x%%@NL@%
        NEXT y%%@NL@%
    NEXT maskPtr%%@NL@%
    MouseMaskTranslate mask$, xHot%, yHot%, cursor$%@NL@%
    MouseSetGcursor cursor$%@NL@%
    MouseShow%@NL@%
    RETURN%@NL@%
%@NL@%
%@AB@%  ' Button was pressed while mouse was in the "Try standard cursors" box%@AE@%%@NL@%
DoResetCursor:%@NL@%
    MouseHide%@NL@%
    cursorIndex% = (cursorIndex% + 1) MOD 9%@NL@%
    MouseSetGcursor curs$(cursorIndex%)%@NL@%
    MouseShow%@NL@%
    DO%@NL@%
        MouseNow leftButton%, rightButton%, xMouse%, yMouse%%@NL@%
    LOOP UNTIL leftButton% = 0 AND rightButton% = 0%@NL@%
    RETURN%@NL@%
%@NL@%
%@AB@%  ' Button was pressed while mouse was in the "Create cursor subroutine" box%@AE@%%@NL@%
DoCreateSub:%@NL@%
    q$ = CHR$(34)%@NL@%
    OPEN "GCURSOR.BAS" FOR OUTPUT AS #1%@NL@%
    PRINT #1, "   ' ************************************************"%@NL@%
    PRINT #1, "   ' **  Name:          Gcursor                    **"%@NL@%
    PRINT #1, "   ' **  Type:          Subprogram                 **"%@NL@%
    PRINT #1, "   ' **  Module:        GCURSOR.BAS                **"%@NL@%
    PRINT #1, "   ' **  Language:      Microsoft QuickBASIC 4.00  **"%@NL@%
    PRINT #1, "   ' ************************************************"%@NL@%
    PRINT #1, "   '"%@NL@%
    PRINT #1, "   SUB Gcursor (mask$, xHot%, yHot%) STATIC"%@NL@%
    PRINT #1, ""%@NL@%
    PRINT #1, "       mask$ = "; q$; q$%@NL@%
    FOR i% = 0 TO 31%@NL@%
        PRINT #1, "       mask$ = mask$ + ";%@NL@%
        PRINT #1, q$; MID$(mask$, 16 * i% + 1, 16); q$%@NL@%
        IF i% = 15 THEN%@NL@%
            PRINT #1, ""%@NL@%
        END IF%@NL@%
    NEXT i%%@NL@%
    PRINT #1, ""%@NL@%
    PRINT #1, "       xHot% ="; STR$(xHot%)%@NL@%
    PRINT #1, "       yHot% ="; STR$(yHot%)%@NL@%
    PRINT #1, ""%@NL@%
    PRINT #1, "   END SUB"%@NL@%
    RETURN%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Set or clear pixel box if mouse is on one%@AE@%%@NL@%
DoPixelControl:%@NL@%
    GOSUB WhichBox%@NL@%
    IF xbox% THEN%@NL@%
        IF xold% <> xbox% OR yold% <> ybox% THEN%@NL@%
            xold% = xbox%%@NL@%
            yold% = ybox%%@NL@%
            MouseHide%@NL@%
            IF leftButton% THEN%@NL@%
                LINE (xbox% + 3, ybox% + 2)-(xbox% + 9, ybox% + 7), 1, BF%@NL@%
            ELSE%@NL@%
                LINE (xbox% + 3, ybox% + 2)-(xbox% + 9, ybox% + 7), 0, BF%@NL@%
            END IF%@NL@%
            MouseShow%@NL@%
        END IF%@NL@%
    END IF%@NL@%
    RETURN%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MOUSSUBS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\MOUSSUBS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MOUSSUBS                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Collection of subprograms for using the Microsoft Mouse.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Note:         The assembly-language subroutine named MOUSE.ASM%@AE@%%@NL@%
%@AB@%  '               must be assembled and linked with these routines%@AE@%%@NL@%
%@AB@%  '               or included in the user library loaded with%@AE@%%@NL@%
%@AB@%  '               QuickBASIC.%@AE@%%@NL@%
%@AB@%  ' USAGE:        No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS: CGA%@AE@%%@NL@%
%@AB@%  '               MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  '               Mouse%@AE@%%@NL@%
%@AB@%  '.MAK FILE:     MOUSSUBS.BAS%@AE@%%@NL@%
%@AB@%  '               BITS.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:   (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:    i%            Looping index%@AE@%%@NL@%
%@AB@%  '               mask$         Pattern mask for each graphics mouse cursor%@AE@%%@NL@%
%@AB@%  '               xHot%         X hot spot location%@AE@%%@NL@%
%@AB@%  '               yHot%         Y hot spot location%@AE@%%@NL@%
%@AB@%  '               curs$         Binary bit pattern for defining mouse cursor%@AE@%%@NL@%
%@AB@%  '               j%            Test for left mouse button press and release%@AE@%%@NL@%
%@AB@%  '               leftButton%   State of left mouse button%@AE@%%@NL@%
%@AB@%  '               rightButton%  State of right mouse button%@AE@%%@NL@%
%@AB@%  '               xMouse%       X location of mouse%@AE@%%@NL@%
%@AB@%  '               yMouse%       Y location of mouse%@AE@%%@NL@%
%@AB@%  '               mflag%        Indicates mouse is available%@AE@%%@NL@%
%@AB@%  '               horizontal%   Horizontal mouse mickies%@AE@%%@NL@%
%@AB@%  '               vertical%     Vertical mouse mickies%@AE@%%@NL@%
%@AB@%  '               xpLeft%       X location of last left button press%@AE@%%@NL@%
%@AB@%  '               ypLeft%       Y location of last left button press%@AE@%%@NL@%
%@AB@%  '               xrLeft%       X location of last left button release%@AE@%%@NL@%
%@AB@%  '               yrLeft%       Y location of last left button release%@AE@%%@NL@%
%@AB@%  '               xpRight%      X location of last right button press%@AE@%%@NL@%
%@AB@%  '               ypRight%      Y location of last right button press%@AE@%%@NL@%
%@AB@%  '               xrRight%      X location of last right button release%@AE@%%@NL@%
%@AB@%  '               yrRight%      Y location of last right button release%@AE@%%@NL@%
%@AB@%  '               t0            Timer value%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION BinStr2Bin% (b$)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@NL@%
    DECLARE SUB MouseRange (x1%, y1%, x2%, y2%)%@NL@%
    DECLARE SUB MousePut (xMouse%, yMouse%)%@NL@%
    DECLARE SUB MouseHide ()%@NL@%
    DECLARE SUB MouseInches (horizontal%, vertical%)%@NL@%
    DECLARE SUB MouseInstall (mflag%)%@NL@%
    DECLARE SUB MouseMickey (horizontal%, vertical%)%@NL@%
    DECLARE SUB MousePressLeft (leftCount%, xMouse%, yMouse%)%@NL@%
    DECLARE SUB MousePressRight (rightCount%, xMouse%, yMouse%)%@NL@%
    DECLARE SUB MouseReleaseLeft (leftCount%, xMouse%, yMouse%)%@NL@%
    DECLARE SUB MouseReleaseRight (rightCount%, xMouse%, yMouse%)%@NL@%
    DECLARE SUB MouseWarp (threshold%)%@NL@%
    DECLARE SUB Cursdflt (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Curschek (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Curshand (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Curshour (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Cursjet (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Cursleft (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Cursplus (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Cursup (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB Cursx (mask$, xHot%, yHot%)%@NL@%
    DECLARE SUB MouseMaskTranslate (mask$, xHot%, yHot%, cursor$)%@NL@%
    DECLARE SUB MouseNow (leftButton%, rightButton%, xMouse%, yMouse%)%@NL@%
    DECLARE SUB MouseSetGcursor (cursor$)%@NL@%
    DECLARE SUB MouseShow ()%@NL@%
%@NL@%
%@AB@%  ' Check for mouse%@AE@%%@NL@%
    SCREEN 2%@NL@%
    CLS%@NL@%
    MouseInstall mflag%%@NL@%
    PRINT "MouseInstall ... "; mflag%%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the available graphics-mode cursors%@AE@%%@NL@%
    PRINT%@NL@%
    PRINT "Click left mouse button to see the graphics-mode cursors..."%@NL@%
    MouseShow%@NL@%
%@NL@%
    FOR i% = 1 TO 9%@NL@%
        SELECT CASE i%%@NL@%
        CASE 1%@NL@%
            Curschek mask$, xHot%, yHot%%@NL@%
        CASE 2%@NL@%
            Curshand mask$, xHot%, yHot%%@NL@%
        CASE 3%@NL@%
            Curshour mask$, xHot%, yHot%%@NL@%
        CASE 4%@NL@%
            Cursjet mask$, xHot%, yHot%%@NL@%
        CASE 5%@NL@%
            Cursleft mask$, xHot%, yHot%%@NL@%
        CASE 6%@NL@%
            Cursplus mask$, xHot%, yHot%%@NL@%
        CASE 7%@NL@%
            Cursup mask$, xHot%, yHot%%@NL@%
        CASE 8%@NL@%
            Cursx mask$, xHot%, yHot%%@NL@%
        CASE ELSE%@NL@%
            Cursdflt mask$, xHot%, yHot%%@NL@%
        END SELECT%@NL@%
        MouseMaskTranslate mask$, xHot%, yHot%, curs$%@NL@%
        FOR j% = -1 TO 0%@NL@%
            DO%@NL@%
                MouseNow leftButton%, rightButton%, xMouse%, yMouse%%@NL@%
            LOOP UNTIL leftButton% = j%%@NL@%
        NEXT j%%@NL@%
        MouseSetGcursor curs$%@NL@%
    NEXT i%%@NL@%
%@NL@%
%@AB@%  ' Mouse hide and show%@AE@%%@NL@%
    PRINT "MouseHide ... (Press any key to continue)"%@NL@%
    MouseHide%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
    PRINT "MouseShow ... (Press any key to continue)"%@NL@%
    MouseShow%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%  ' Mouse inches per screen%@AE@%%@NL@%
    MouseHide%@NL@%
    PRINT%@NL@%
    PRINT "Setting MouseWarp to 9999 to prevent doubling of speed."%@NL@%
    MouseWarp 9999%@NL@%
    PRINT%@NL@%
    PRINT "Setting MouseInches to 8 by 11. (8 inches of mouse motion"%@NL@%
    PRINT "across desk to move across screen, and 11 inches vertical"%@NL@%
    PRINT "mouse motion from top to bottom of screen) ..."%@NL@%
    PRINT%@NL@%
    PRINT "Press any key to continue"%@NL@%
    MouseInches 8, 11%@NL@%
    MouseShow%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%  ' Resetting the mouse%@AE@%%@NL@%
    MouseHide%@NL@%
    PRINT%@NL@%
    PRINT "Resetting the mouse"%@NL@%
    MouseInstall mflag%%@NL@%
%@NL@%
%@AB@%  ' Show realtime mouse data%@AE@%%@NL@%
    CLS%@NL@%
    PRINT "Instantaneous mouse information (Press any key to continue)"%@NL@%
    MouseShow%@NL@%
    DO%@NL@%
        MouseMickey horizontal%, vertical%%@NL@%
        MouseNow leftButton%, rightButton%, xMouse%, yMouse%%@NL@%
        MousePressLeft leftCount%, xpLeft%, ypLeft%%@NL@%
        MouseReleaseLeft leftCount%, xrLeft%, yrLeft%%@NL@%
        MousePressRight rightCount%, xpRight%, ypRight%%@NL@%
        MouseReleaseRight rightCount%, xrRight%, yrRight%%@NL@%
        LOCATE 3, 1%@NL@%
        PRINT "Mickies       ";%@NL@%
        PRINT USING "#######, #######"; horizontal%, vertical%%@NL@%
        PRINT "Position      ";%@NL@%
        PRINT USING "#######, #######"; xMouse%, yMouse%%@NL@%
        PRINT%@NL@%
        PRINT "Buttons       ";%@NL@%
        PRINT USING "#######, #######"; leftButton%, rightButton%%@NL@%
        PRINT%@NL@%
        PRINT "Left Press    ";%@NL@%
        PRINT USING "#######, #######"; xpLeft%, ypLeft%%@NL@%
        PRINT "Left Release  ";%@NL@%
        PRINT USING "#######, #######"; xrLeft%, yrLeft%%@NL@%
        PRINT%@NL@%
        PRINT "Right Press   ";%@NL@%
        PRINT USING "#######, #######"; xpRight%, ypRight%%@NL@%
        PRINT "Right Release ";%@NL@%
        PRINT USING "#######, #######"; xrRight%, yrRight%%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%  ' Mouse placement%@AE@%%@NL@%
    CLS%@NL@%
    MouseHide%@NL@%
    PRINT "MousePut..."%@NL@%
    MouseShow%@NL@%
    FOR i% = 1 TO 20%@NL@%
        xMouse% = RND * 639%@NL@%
        yMouse% = RND * 199%@NL@%
        MousePut xMouse%, yMouse%%@NL@%
        t0 = TIMER%@NL@%
        DO%@NL@%
        LOOP UNTIL TIMER - t0 > .2%@NL@%
    NEXT i%%@NL@%
%@NL@%
%@AB@%  ' Range limiting%@AE@%%@NL@%
    CLS%@NL@%
    MouseHide%@NL@%
    PRINT "Range limited to a rectangular area ..."%@NL@%
    PRINT "Press any key to continue"%@NL@%
    MouseShow%@NL@%
    MouseRange 200, 50, 400, 100%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    SCREEN 0%@NL@%
    CLS%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Curschek                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Defines a graphics-mode mouse cursor (check mark).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Curschek mask$, xHot%, yHot%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mask$      Pattern mask for creating cursor%@AE@%%@NL@%
%@AB@%  '                  xHot%      X location for cursor hot spot%@AE@%%@NL@%
%@AB@%  '                  yHot%      Y location for cursor hot spot%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Curschek (mask$, xHot%, yHot%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Curschek (mask$, xHot%, yHot%) STATIC%@NL@%
%@NL@%
        mask$ = ""%@NL@%
        mask$ = mask$ + "1111111111110000"%@NL@%
        mask$ = mask$ + "1111111111100000"%@NL@%
        mask$ = mask$ + "1111111111000000"%@NL@%
        mask$ = mask$ + "1111111110000001"%@NL@%
        mask$ = mask$ + "1111111100000011"%@NL@%
        mask$ = mask$ + "0000011000000111"%@NL@%
        mask$ = mask$ + "0000000000001111"%@NL@%
        mask$ = mask$ + "0000000000011111"%@NL@%
        mask$ = mask$ + "1100000000111111"%@NL@%
        mask$ = mask$ + "1111000001111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000110"%@NL@%
        mask$ = mask$ + "0000000000001100"%@NL@%
        mask$ = mask$ + "0000000000011000"%@NL@%
        mask$ = mask$ + "0000000000110000"%@NL@%
        mask$ = mask$ + "0000000001100000"%@NL@%
        mask$ = mask$ + "0111000011000000"%@NL@%
        mask$ = mask$ + "0001110110000000"%@NL@%
        mask$ = mask$ + "0000011100000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
%@NL@%
        xHot% = 6%@NL@%
        yHot% = 7%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Cursdflt                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Defines a default graphics-mode mouse cursor (arrow pointing up and left).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Cursdflt mask$, xHot%, yHot%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mask$      Pattern mask for creating cursor%@AE@%%@NL@%
%@AB@%  '                  xHot%      X location for cursor hot spot%@AE@%%@NL@%
%@AB@%  '                  yHot%      Y location for cursor hot spot%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATION:   DECLARE SUB Cursdflt (mask$, xHot%, yHot%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Cursdflt (mask$, xHot%, yHot%) STATIC%@NL@%
%@NL@%
        mask$ = ""%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1001111111111111"%@NL@%
        mask$ = mask$ + "1000111111111111"%@NL@%
        mask$ = mask$ + "1000011111111111"%@NL@%
        mask$ = mask$ + "1000001111111111"%@NL@%
        mask$ = mask$ + "1000000111111111"%@NL@%
        mask$ = mask$ + "1000000011111111"%@NL@%
        mask$ = mask$ + "1000000001111111"%@NL@%
        mask$ = mask$ + "1000000000111111"%@NL@%
        mask$ = mask$ + "1000000000011111"%@NL@%
        mask$ = mask$ + "1000000000001111"%@NL@%
        mask$ = mask$ + "1000000000000111"%@NL@%
        mask$ = mask$ + "1000100001111111"%@NL@%
        mask$ = mask$ + "1001100001111111"%@NL@%
        mask$ = mask$ + "1111110000111111"%@NL@%
        mask$ = mask$ + "1111110000111111"%@NL@%
%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0010000000000000"%@NL@%
        mask$ = mask$ + "0011000000000000"%@NL@%
        mask$ = mask$ + "0011100000000000"%@NL@%
        mask$ = mask$ + "0011110000000000"%@NL@%
        mask$ = mask$ + "0011111000000000"%@NL@%
        mask$ = mask$ + "0011111100000000"%@NL@%
        mask$ = mask$ + "0011111110000000"%@NL@%
        mask$ = mask$ + "0011111111000000"%@NL@%
        mask$ = mask$ + "0011111111100000"%@NL@%
        mask$ = mask$ + "0011111000000000"%@NL@%
        mask$ = mask$ + "0010001100000000"%@NL@%
        mask$ = mask$ + "0000001100000000"%@NL@%
        mask$ = mask$ + "0000000110000000"%@NL@%
        mask$ = mask$ + "0000000110000000"%@NL@%
%@NL@%
        xHot% = 1%@NL@%
        yHot% = 1%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Curshand                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Defines a graphics-mode mouse cursor (pointing hand).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Curshand mask$, xHot%, yHot%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mask$      Pattern mask for creating cursor%@AE@%%@NL@%
%@AB@%  '                  xHot%      X location for cursor hot spot%@AE@%%@NL@%
%@AB@%  '                  yHot%      Y location for cursor hot spot%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Curshand (mask$, xHot%, yHot%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Curshand (mask$, xHot%, yHot%) STATIC%@NL@%
%@NL@%
        mask$ = ""%@NL@%
        mask$ = mask$ + "1110000111111111"%@NL@%
        mask$ = mask$ + "1110000111111111"%@NL@%
        mask$ = mask$ + "1110000111111111"%@NL@%
        mask$ = mask$ + "1110000111111111"%@NL@%
        mask$ = mask$ + "1110000111111111"%@NL@%
        mask$ = mask$ + "1110000000000000"%@NL@%
        mask$ = mask$ + "1110000000000000"%@NL@%
        mask$ = mask$ + "1110000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
%@NL@%
        mask$ = mask$ + "0001111000000000"%@NL@%
        mask$ = mask$ + "0001001000000000"%@NL@%
        mask$ = mask$ + "0001001000000000"%@NL@%
        mask$ = mask$ + "0001001000000000"%@NL@%
        mask$ = mask$ + "0001001000000000"%@NL@%
        mask$ = mask$ + "0001001111111111"%@NL@%
        mask$ = mask$ + "0001001001001001"%@NL@%
        mask$ = mask$ + "0001001001001001"%@NL@%
        mask$ = mask$ + "1111001001001001"%@NL@%
        mask$ = mask$ + "1001000000000001"%@NL@%
        mask$ = mask$ + "1001000000000001"%@NL@%
        mask$ = mask$ + "1001000000000001"%@NL@%
        mask$ = mask$ + "1000000000000001"%@NL@%
        mask$ = mask$ + "1000000000000001"%@NL@%
        mask$ = mask$ + "1000000000000001"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
%@NL@%
        xHot% = 5%@NL@%
        yHot% = 0%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Curshour                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Defines a graphics-mode mouse cursor (hourglass).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Curshour mask$, xHot%, yHot%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mask$      Pattern mask for creating cursor%@AE@%%@NL@%
%@AB@%  '                  xHot%      X location for cursor hot spot%@AE@%%@NL@%
%@AB@%  '                  yHot%      Y location for cursor hot spot%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:    DECLARE SUB Curshour (mask$, xHot%, yHot%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Curshour (mask$, xHot%, yHot%) STATIC%@NL@%
%@NL@%
        mask$ = ""%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "1000000000000001"%@NL@%
        mask$ = mask$ + "1100000000000011"%@NL@%
        mask$ = mask$ + "1110000000000111"%@NL@%
        mask$ = mask$ + "1111000000001111"%@NL@%
        mask$ = mask$ + "1110000000000111"%@NL@%
        mask$ = mask$ + "1100000000000011"%@NL@%
        mask$ = mask$ + "1000000000000001"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0111111111111110"%@NL@%
        mask$ = mask$ + "0110000000000110"%@NL@%
        mask$ = mask$ + "0011000000001100"%@NL@%
        mask$ = mask$ + "0001100000011000"%@NL@%
        mask$ = mask$ + "0000110000110000"%@NL@%
        mask$ = mask$ + "0000011001100000"%@NL@%
        mask$ = mask$ + "0000001111000000"%@NL@%
        mask$ = mask$ + "0000011001100000"%@NL@%
        mask$ = mask$ + "0000110000110000"%@NL@%
        mask$ = mask$ + "0001100110011000"%@NL@%
        mask$ = mask$ + "0011001111001100"%@NL@%
        mask$ = mask$ + "0110011111100110"%@NL@%
        mask$ = mask$ + "0111111111111110"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
%@NL@%
        xHot% = 7%@NL@%
        yHot% = 7%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Cursjet                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Defines a graphics-mode mouse cursor (jet aircraft).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Cursjet mask$, xHot%, yHot%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mask$      Pattern mask for creating cursor%@AE@%%@NL@%
%@AB@%  '                  xHot%      X location for cursor hot spot%@AE@%%@NL@%
%@AB@%  '                  yHot%      Y location for cursor hot spot%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Cursjet (mask$, xHot%, yHot%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Cursjet (mask$, xHot%, yHot%) STATIC%@NL@%
%@NL@%
        mask$ = ""%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111011111111"%@NL@%
        mask$ = mask$ + "1111110001111111"%@NL@%
        mask$ = mask$ + "1111100000111111"%@NL@%
        mask$ = mask$ + "1111100000111111"%@NL@%
        mask$ = mask$ + "1111100000111111"%@NL@%
        mask$ = mask$ + "1111000000011111"%@NL@%
        mask$ = mask$ + "1110000000001111"%@NL@%
        mask$ = mask$ + "1100000000000111"%@NL@%
        mask$ = mask$ + "1000000000000011"%@NL@%
        mask$ = mask$ + "1000000000000011"%@NL@%
        mask$ = mask$ + "1111100000111111"%@NL@%
        mask$ = mask$ + "1111100000111111"%@NL@%
        mask$ = mask$ + "1111000000011111"%@NL@%
        mask$ = mask$ + "1110000000001111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000100000000"%@NL@%
        mask$ = mask$ + "0000001110000000"%@NL@%
        mask$ = mask$ + "0000001110000000"%@NL@%
        mask$ = mask$ + "0000001110000000"%@NL@%
        mask$ = mask$ + "0000011111000000"%@NL@%
        mask$ = mask$ + "0000111111100000"%@NL@%
        mask$ = mask$ + "0001111111110000"%@NL@%
        mask$ = mask$ + "0011111111111000"%@NL@%
        mask$ = mask$ + "0110001110001100"%@NL@%
        mask$ = mask$ + "0000001110000000"%@NL@%
        mask$ = mask$ + "0000001110000000"%@NL@%
        mask$ = mask$ + "0000011111000000"%@NL@%
        mask$ = mask$ + "0000110001100000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
%@NL@%
        xHot% = 7%@NL@%
        yHot% = 1%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Cursleft                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Defines a graphics-mode mouse cursor (left arrow).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Cursleft mask$, xHot%, yHot%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mask$      Pattern mask for creating cursor%@AE@%%@NL@%
%@AB@%  '                  xHot%      X location for cursor hot spot%@AE@%%@NL@%
%@AB@%  '                  yHot%      Y location for cursor hot spot%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:    DECLARE SUB Cursleft (mask$, xHot%, yHot%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Cursleft (mask$, xHot%, yHot%) STATIC%@NL@%
%@NL@%
        mask$ = ""%@NL@%
        mask$ = mask$ + "1111111000011111"%@NL@%
        mask$ = mask$ + "1111000000011111"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "1111000000011111"%@NL@%
        mask$ = mask$ + "1111111000011111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000011000000"%@NL@%
        mask$ = mask$ + "0000011111000000"%@NL@%
        mask$ = mask$ + "0111111111111110"%@NL@%
        mask$ = mask$ + "0000011111000000"%@NL@%
        mask$ = mask$ + "0000000011000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
%@NL@%
        xHot% = 0%@NL@%
        yHot% = 3%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Cursplus                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Defines a graphics-mode mouse cursor (plus sign).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Cursplus mask$, xHot%, yHot%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mask$      Pattern mask for creating cursor%@AE@%%@NL@%
%@AB@%  '                  xHot%      X location for cursor hot spot%@AE@%%@NL@%
%@AB@%  '                  yHot%      Y location for cursor hot spot%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Cursplus (mask$, xHot%, yHot%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Cursplus (mask$, xHot%, yHot%) STATIC%@NL@%
%@NL@%
        mask$ = ""%@NL@%
        mask$ = mask$ + "1111110000111111"%@NL@%
        mask$ = mask$ + "1111110000111111"%@NL@%
        mask$ = mask$ + "1111110000111111"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "1111110000111111"%@NL@%
        mask$ = mask$ + "1111110000111111"%@NL@%
        mask$ = mask$ + "1111110000111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000110000000"%@NL@%
        mask$ = mask$ + "0000000110000000"%@NL@%
        mask$ = mask$ + "0000000110000000"%@NL@%
        mask$ = mask$ + "0111111111111110"%@NL@%
        mask$ = mask$ + "0000000110000000"%@NL@%
        mask$ = mask$ + "0000000110000000"%@NL@%
        mask$ = mask$ + "0000000110000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
%@NL@%
        xHot% = 7%@NL@%
        yHot% = 4%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Cursup                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Defines a graphics-mode mouse cursor (up arrow).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Cursup mask$, xHot%, yHot%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mask$      Pattern mask for creating cursor%@AE@%%@NL@%
%@AB@%  '                  xHot%      X location for cursor hot spot%@AE@%%@NL@%
%@AB@%  '                  yHot%      Y location for cursor hot spot%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Cursup (mask$, xHot%, yHot%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Cursup (mask$, xHot%, yHot%) STATIC%@NL@%
%@NL@%
        mask$ = ""%@NL@%
        mask$ = mask$ + "1111100111111111"%@NL@%
        mask$ = mask$ + "1111000011111111"%@NL@%
        mask$ = mask$ + "1110000001111111"%@NL@%
        mask$ = mask$ + "1110000001111111"%@NL@%
        mask$ = mask$ + "1100000000111111"%@NL@%
        mask$ = mask$ + "1100000000111111"%@NL@%
        mask$ = mask$ + "1000000000011111"%@NL@%
        mask$ = mask$ + "1000000000011111"%@NL@%
        mask$ = mask$ + "0000000000001111"%@NL@%
        mask$ = mask$ + "0000000000001111"%@NL@%
        mask$ = mask$ + "1111000011111111"%@NL@%
        mask$ = mask$ + "1111000011111111"%@NL@%
        mask$ = mask$ + "1111000011111111"%@NL@%
        mask$ = mask$ + "1111000011111111"%@NL@%
        mask$ = mask$ + "1111000011111111"%@NL@%
        mask$ = mask$ + "1111000011111111"%@NL@%
%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000011000000000"%@NL@%
        mask$ = mask$ + "0000111100000000"%@NL@%
        mask$ = mask$ + "0000111100000000"%@NL@%
        mask$ = mask$ + "0001111110000000"%@NL@%
        mask$ = mask$ + "0001111110000000"%@NL@%
        mask$ = mask$ + "0011111111000000"%@NL@%
        mask$ = mask$ + "0011111111000000"%@NL@%
        mask$ = mask$ + "0111111111100000"%@NL@%
        mask$ = mask$ + "0000011000000000"%@NL@%
        mask$ = mask$ + "0000011000000000"%@NL@%
        mask$ = mask$ + "0000011000000000"%@NL@%
        mask$ = mask$ + "0000011000000000"%@NL@%
        mask$ = mask$ + "0000011000000000"%@NL@%
        mask$ = mask$ + "0000011000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
%@NL@%
        xHot% = 5%@NL@%
        yHot% = 0%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Cursx                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Defines a graphics-mode mouse cursor (X mark).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Cursx mask$, xHot%, yHot%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mask$      Pattern mask for creating cursor%@AE@%%@NL@%
%@AB@%  '                  xHot%      X location for cursor hot spot%@AE@%%@NL@%
%@AB@%  '                  yHot%      Y location for cursor hot spot%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Cursx (mask$, xHot%, yHot%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Cursx (mask$, xHot%, yHot%) STATIC%@NL@%
%@NL@%
        mask$ = ""%@NL@%
        mask$ = mask$ + "0000011111100000"%@NL@%
        mask$ = mask$ + "0000000110000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "1100000000000011"%@NL@%
        mask$ = mask$ + "1111000000001111"%@NL@%
        mask$ = mask$ + "1100000000000011"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000110000000"%@NL@%
        mask$ = mask$ + "0000001111000000"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
        mask$ = mask$ + "1111111111111111"%@NL@%
%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0111000000001110"%@NL@%
        mask$ = mask$ + "0001110000111000"%@NL@%
        mask$ = mask$ + "0000011001100000"%@NL@%
        mask$ = mask$ + "0000001111000000"%@NL@%
        mask$ = mask$ + "0000011001100000"%@NL@%
        mask$ = mask$ + "0001110000111000"%@NL@%
        mask$ = mask$ + "0111000000001110"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
        mask$ = mask$ + "0000000000000000"%@NL@%
%@NL@%
        xHot% = 7%@NL@%
        yHot% = 4%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseHide                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Hides the mouse cursor.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseHide%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB MouseHide ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseHide STATIC%@NL@%
        Mouse 2, 0, 0, 0%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseInches                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Sets mouse motion ratio in inches per screen.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseInches horizontal%, vertical%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      horizontal%   Inches of horizontal mouse motion per%@AE@%%@NL@%
%@AB@%  '                                screen width%@AE@%%@NL@%
%@AB@%  '                  vertical%     Inches of vertical% mouse motion per%@AE@%%@NL@%
%@AB@%  '                                screen height%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       h%            Calculated value to pass to mouse driver%@AE@%%@NL@%
%@AB@%  '                  v%            Calculated value to pass to mouse driver%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB MouseInches (horizontal%, vertical%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseInches (horizontal%, vertical%) STATIC%@NL@%
        IF horizontal% > 100 THEN%@NL@%
            horizontal% = 100%@NL@%
        END IF%@NL@%
        IF vertical% > 100 THEN%@NL@%
            vertical% = 100%@NL@%
        END IF%@NL@%
        h% = horizontal% * 5 \ 2%@NL@%
        v% = vertical% * 8%@NL@%
        Mouse 15, 0, h%, v%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseInstall               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Determines whether mouse is available and resets all mouse parameters.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseInstall mflag%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mflag%     Returned indication of mouse availability%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB MouseInstall (mflag%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseInstall (mflag%) STATIC%@NL@%
        mflag% = 0%@NL@%
        Mouse mflag%, 0, 0, 0%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseLightPen              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Activates and deactivates lightpen emulation mode.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseLightPen switch%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      switch%    non-zero to activate lightpen emulation,%@AE@%%@NL@%
%@AB@%  '                             zero to deactivate%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB MouseLightPen (switch%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseLightPen (switch%) STATIC%@NL@%
        IF switch% THEN%@NL@%
            Mouse 13, 0, 0, 0%@NL@%
        ELSE%@NL@%
            Mouse 14, 0, 0, 0%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseMaskTranslate         **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Translates mouse graphics cursor Mask$ to Cursor$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseMaskTranslate mask$, xHot%, yHot%, cursor$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mask$      Pattern mask that defines a mouse%@AE@%%@NL@%
%@AB@%  '                             graphics-mode cursor%@AE@%%@NL@%
%@AB@%  '                  xHot%      X location of the hot spot%@AE@%%@NL@%
%@AB@%  '                  yHot%      Y location of the hot spot%@AE@%%@NL@%
%@AB@%  '                  cursor$    The returned binary buffer string%@AE@%%@NL@%
%@AB@%  '                             for the cursor%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%         Looping index%@AE@%%@NL@%
%@AB@%  '                  b%         Integer formed from string bit representations%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB MouseMaskTranslate (mask$, xHot%, yHot%,%@AE@%%@NL@%
%@AB@%  '                              cursor$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseMaskTranslate (mask$, xHot%, yHot%, cursor$) STATIC%@NL@%
        cursor$ = CHR$(xHot%) + CHR$(yHot%) + STRING$(64, 0)%@NL@%
        IF LEN(mask$) = 512 THEN%@NL@%
            FOR i% = 1 TO 32%@NL@%
                b% = BinStr2Bin%(MID$(mask$, i% * 16 - 15, 16))%@NL@%
                MID$(cursor$, i% + i% + 1, 2) = MKI$(b%)%@NL@%
            NEXT i%%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseMickey                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Reads mouse mickey counts.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseMickey horizontal%, vertical%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      horizontal%   Horizontal motion mickey counts%@AE@%%@NL@%
%@AB@%  '                  vertical%     Vertical motion mickey counts%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB MouseMickey (horizontal, vertical%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseMickey (horizontal%, vertical%) STATIC%@NL@%
        Mouse 11, 0, horizontal%, vertical%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseNow                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the instantaneous state of the mouse.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseNow leftButton%, rightButton%, xMouse%, yMouse%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      leftButton%   Indicates left mouse button state%@AE@%%@NL@%
%@AB@%  '                  rightButton%  Indicates right mouse button state%@AE@%%@NL@%
%@AB@%  '                  xMouse%       X location of mouse%@AE@%%@NL@%
%@AB@%  '                  yMouse%       Y location of mouse%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       m2%           Mouse driver parameter containing button%@AE@%%@NL@%
%@AB@%  '                                press information%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB MouseNow (leftButton%, rightButton%,%@AE@%%@NL@%
%@AB@%  '                                        xMouse%, yMouse%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseNow (leftButton%, rightButton%, xMouse%, yMouse%) STATIC%@NL@%
        Mouse 3, m2%, xMouse%, yMouse%%@NL@%
        leftButton% = ((m2% AND 1) <> 0)%@NL@%
        rightButton% = ((m2% AND 2) <> 0)%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MousePressLeft             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the mouse state at last press of left button.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MousePressLeft leftCount%, xMouse%, yMouse%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      leftCount%    Number of times the left button has been%@AE@%%@NL@%
%@AB@%  '                                pressed since the last call to this%@AE@%%@NL@%
%@AB@%  '                                subprogram%@AE@%%@NL@%
%@AB@%  '                  xMouse%       X location of the mouse at the last press%@AE@%%@NL@%
%@AB@%  '                                of the left button%@AE@%%@NL@%
%@AB@%  '                  yMouse%       Y location of the mouse at the last press%@AE@%%@NL@%
%@AB@%  '                                of the left button%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       m1%           Parameter for call to mouse driver%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:    DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                    DECLARE SUB MousePressLeft (leftCount%, xMouse%, yMouse%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MousePressLeft (leftCount%, xMouse%, yMouse%) STATIC%@NL@%
        m1% = 5%@NL@%
        leftCount% = 0%@NL@%
        Mouse m1%, leftCount%, xMouse%, yMouse%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MousePressRight            **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the mouse state at last press of right button.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MousePressRight (rightCount%, xMouse%, yMouse%) STATIC%@NL@%
        m1% = 5%@NL@%
        rightCount% = 1%@NL@%
        Mouse m1%, rightCount%, xMouse%, yMouse%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MousePut                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Sets the mouse position.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MousePut xMouse%, yMouse%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      xMouse%    Horizontal location to place cursor%@AE@%%@NL@%
%@AB@%  '                  yMouse%    Vertical location to place cursor%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:   DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                   DECLARE SUB MousePut (xMouse%, yMouse%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MousePut (xMouse%, yMouse%) STATIC%@NL@%
        Mouse 4, 0, xMouse%, yMouse%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseRange                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Sets mouse range of motion.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseRange x1%, y1%, x2%, y2%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x1%        Upper left corner X coordinate%@AE@%%@NL@%
%@AB@%  '                  y1%        Upper left corner Y coordinate%@AE@%%@NL@%
%@AB@%  '                  x2%        Lower right corner X coordinate%@AE@%%@NL@%
%@AB@%  '                  y2%        Lower right corner Y coordinate%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:   DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                   DECLARE SUB MouseRange (x1%, y1%, x2%, y2%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseRange (x1%, y1%, x2%, y2%) STATIC%@NL@%
        Mouse 7, 0, x1%, x2%%@NL@%
        Mouse 8, 0, y1%, y2%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseReleaseLeft           **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the mouse state at last release of left button.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseReleaseLeft leftCount%, xMouse%, yMouse%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      leftCount%    Number of times the left button has been%@AE@%%@NL@%
%@AB@%  '                                released since the last call to this%@AE@%%@NL@%
%@AB@%  '                                subprogram%@AE@%%@NL@%
%@AB@%  '                  xMouse%       X location of the mouse at the last%@AE@%%@NL@%
%@AB@%  '                                release of the left button%@AE@%%@NL@%
%@AB@%  '                  yMouse%       Y location of the mouse at the last%@AE@%%@NL@%
%@AB@%  '                                release of the left button%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       m1%           Parameter for call to mouse driver%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB MouseReleaseLeft (leftCount%, xMouse%,%@AE@%%@NL@%
%@AB@%  '                                               yMouse%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseReleaseLeft (leftCount%, xMouse%, yMouse%) STATIC%@NL@%
        m1% = 6%@NL@%
        leftCount% = 0%@NL@%
        Mouse m1%, leftCount%, xMouse%, yMouse%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseReleaseRight          **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the mouse state at last release of right button.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseReleaseRight rightCount%, xMouse%, yMouse%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      rightCount%   Number of times the right button has been%@AE@%%@NL@%
%@AB@%  '                                released since the last call to this%@AE@%%@NL@%
%@AB@%  '                                subprogram%@AE@%%@NL@%
%@AB@%  '                  xMouse%       X location of the mouse at the last%@AE@%%@NL@%
%@AB@%  '                                release of the right button%@AE@%%@NL@%
%@AB@%  '                  yMouse%       Y location of the mouse at the last%@AE@%%@NL@%
%@AB@%  '                                release of the right button%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       m1%           Parameter for call to mouse driver%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB MouseReleaseRight (rightCount%, xMouse%,%@AE@%%@NL@%
%@AB@%  '                                                 yMouse%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseReleaseRight (rightCount%, xMouse%, yMouse%) STATIC%@NL@%
        m1% = 6%@NL@%
        rightCount% = 1%@NL@%
        Mouse m1%, rightCount%, xMouse%, yMouse%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseSetGcursor            **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Sets mouse graphics cursor using cursor$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseSetGcursor cursor$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      cursor$    Binary format cursor string%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       xHot%      X hot spot location%@AE@%%@NL@%
%@AB@%  '                  yHot%      Y hot spot location%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB MouseSetGcursor (cursor$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseSetGcursor (cursor$) STATIC%@NL@%
        xHot% = ASC(LEFT$(cursor$, 1))%@NL@%
        yHot% = ASC(MID$(cursor$, 2, 1))%@NL@%
        Mouse 9, xHot%, yHot%, SADD(cursor$) + 2%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseShow                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Shows the mouse cursor.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseShow%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB MouseShow ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseShow STATIC%@NL@%
        Mouse 1, 0, 0, 0%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseSoftCursor            **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Sets text-mode software cursor.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseSoftCursor screenMask%, cursorMask%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      screenMask%   Integer bit pattern for the screen mask%@AE@%%@NL@%
%@AB@%  '                  cursorMask%   Integer bit pattern for the cursor mask%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB MouseSoftCursor (screenMaks%, cursorMask%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseSoftCursor (screenMask%, cursorMask%) STATIC%@NL@%
        Mouse 10, 0, screenMask%, cursorMask%%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MouseWarp                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSSUBS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Sets double-speed threshold.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  MouseWarp threshold%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      threshold%    Mickies per second rate of threshold%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB MouseWarp (threshold%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB MouseWarp (threshold%) STATIC%@NL@%
        Mouse 19, 0, 0, threshold%%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%MOUSTCRS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\MOUSTCRS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          MOUSTCRS                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        MOUSTCRS.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:    MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  '                  Mouse%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       MOUSTCRS.BAS%@AE@%%@NL@%
%@AB@%  '                  MOUSSUBS.BAS%@AE@%%@NL@%
%@AB@%  '                  BITS.BAS%@AE@%%@NL@%
%@AB@%  '                  ATTRIB.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       screenMask%   Integer bit mask for screen mask%@AE@%%@NL@%
%@AB@%  '                  cursorMask%   Integer bit mask for cursor mask%@AE@%%@NL@%
%@AB@%  '                  leftCount%    Count of left mouse button presses%@AE@%%@NL@%
%@AB@%  '                  xm%           Mouse X position at last left button press%@AE@%%@NL@%
%@AB@%  '                  ym%           Mouse Y position at last left button press%@AE@%%@NL@%
%@AB@%  '                  row%          Code for which screen bit row was selected%@AE@%%@NL@%
%@AB@%  '                  bit%          Bit pattern determined by screen column%@AE@%%@NL@%
%@AB@%  '                                click on%@AE@%%@NL@%
%@AB@%  '                  screenMask$   String of 0s and 1s for bit pattern display%@AE@%%@NL@%
%@AB@%  '                  cursorMask$   String of 0s and 1s for bit pattern display%@AE@%%@NL@%
%@AB@%  '                  i%            Looping index%@AE@%%@NL@%
%@AB@%  '                  Shex$         Hexadecimal representation of the screen mask%@AE@%%@NL@%
%@AB@%  '                  Chex$         Hexadecimal representation of the cursor mask%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Define constants%@AE@%%@NL@%
    CONST FALSE = 0%@NL@%
    CONST TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION Bin2BinStr$ (b%)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB Attrib ()%@NL@%
    DECLARE SUB MouseHide ()%@NL@%
    DECLARE SUB MouseInstall (mouseFlag%)%@NL@%
    DECLARE SUB MousePressLeft (leftCount%, xMouse%, yMouse%)%@NL@%
    DECLARE SUB MouseShow ()%@NL@%
    DECLARE SUB MouseSoftCursor (screenMask%, cursorMask%)%@NL@%
%@NL@%
%@AB@%  ' Is the mouse out there?%@AE@%%@NL@%
    MouseInstall mouseFlag%%@NL@%
    IF mouseFlag% = 0 THEN%@NL@%
        PRINT "Mouse does not appear to be installed.  Check"%@NL@%
        PRINT "your mouse documentation for proper installation."%@NL@%
        PRINT%@NL@%
        SYSTEM%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Put all attributes on the screen%@AE@%%@NL@%
    Attrib%@NL@%
%@NL@%
%@AB@%  ' Set masks to initial state%@AE@%%@NL@%
    screenMask% = &H77FF%@NL@%
    cursorMask% = &H7700%@NL@%
%@NL@%
%@AB@%  ' Create the outlined boxes%@AE@%%@NL@%
    COLOR 14, 0%@NL@%
    PRINT "                  +---+-------+---+--------+----------+--------+"%@NL@%
    PRINT "                  | b | bckgd | i | foregd |   char   |   =    |"%@NL@%
    PRINT "    +-------------+---+-------+---+--------+----------+--------+"%@NL@%
    PRINT "    | screen mask | 0 |  111  | 0 |  111   | 11111111 | &H77FF |"%@NL@%
    PRINT "    | cursor mask | 0 |  111  | 0 |  111   | 00000000 | &H7700 |"%@NL@%
    PRINT "    +-------------+---+-------+---+--------+----------+--------+"%@NL@%
%@NL@%
%@AB@%  ' Print the instructions%@AE@%%@NL@%
    COLOR 11, 0%@NL@%
    PRINT "Click the mouse on any of the mask bits shown.  Then, try the"%@NL@%
    PRINT "new cursor by moving across the attribute fields above.";%@NL@%
%@NL@%
%@AB@%  ' Special indication for quitting%@AE@%%@NL@%
    COLOR 15, 0%@NL@%
    LOCATE 17, 1, 0%@NL@%
    PRINT "Click here";%@NL@%
    LOCATE 18, 1, 0%@NL@%
    PRINT "to Quit - ";%@NL@%
    COLOR 10, 0%@NL@%
    PRINT "X";%@NL@%
%@NL@%
%@AB@%  ' Put mask bits into boxes on screen%@AE@%%@NL@%
    GOSUB PrintScreenMask%@NL@%
    GOSUB PrintCursorMask%@NL@%
%@NL@%
%@AB@%  ' Activate the mouse%@AE@%%@NL@%
    MouseShow%@NL@%
%@NL@%
%@AB@%  ' Do the main processing loop until the quit flag is set%@AE@%%@NL@%
    DO%@NL@%
        GOSUB MainLoop%@NL@%
    LOOP UNTIL quitFlag%%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    MouseHide%@NL@%
    CLS%@NL@%
    SYSTEM%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Main processing loop%@AE@%%@NL@%
MainLoop:%@NL@%
%@NL@%
%@AB@%  ' Where was mouse when left button was last pressed?%@AE@%%@NL@%
    MousePressLeft leftCount%, xm%, ym%%@NL@%
%@NL@%
%@AB@%  ' Was it on one of the two important rows of the screen?%@AE@%%@NL@%
    SELECT CASE ym%%@NL@%
    CASE 152%@NL@%
        row% = 1%@NL@%
    CASE 160%@NL@%
        row% = 2%@NL@%
    CASE ELSE%@NL@%
        row% = 0%@NL@%
    END SELECT%@NL@%
%@NL@%
%@AB@%  ' Was it on an important column?%@AE@%%@NL@%
    SELECT CASE xm%%@NL@%
    CASE 80%@NL@%
        IF ym% = 136 THEN%@NL@%
            quitFlag% = TRUE%@NL@%
        END IF%@NL@%
    CASE 160%@NL@%
        bit% = &H8000%@NL@%
    CASE 200%@NL@%
        bit% = &H4000%@NL@%
    CASE 208%@NL@%
        bit% = &H2000%@NL@%
    CASE 216%@NL@%
        bit% = &H1000%@NL@%
    CASE 256%@NL@%
        bit% = &H800%@NL@%
    CASE 296%@NL@%
        bit% = &H400%@NL@%
    CASE 304%@NL@%
        bit% = &H200%@NL@%
    CASE 312%@NL@%
        bit% = &H100%@NL@%
    CASE 360%@NL@%
        bit% = &H80%@NL@%
    CASE 368%@NL@%
        bit% = &H40%@NL@%
    CASE 376%@NL@%
        bit% = &H20%@NL@%
    CASE 384%@NL@%
        bit% = &H10%@NL@%
    CASE 392%@NL@%
        bit% = &H8%@NL@%
    CASE 400%@NL@%
        bit% = &H4%@NL@%
    CASE 408%@NL@%
        bit% = &H2%@NL@%
    CASE 416%@NL@%
        bit% = &H1%@NL@%
    CASE ELSE%@NL@%
        bit% = 0%@NL@%
    END SELECT%@NL@%
%@NL@%
%@AB@%  ' Modify the masks and update the cursor%@AE@%%@NL@%
    IF leftCount% THEN%@NL@%
        SELECT CASE row%%@NL@%
        CASE 1%@NL@%
            screenMask% = screenMask% XOR bit%%@NL@%
        CASE 2%@NL@%
            cursorMask% = cursorMask% XOR bit%%@NL@%
        CASE ELSE%@NL@%
        END SELECT%@NL@%
        MouseSoftCursor screenMask%, cursorMask%%@NL@%
        GOSUB PrintScreenMask%@NL@%
        GOSUB PrintCursorMask%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' End of main processing loop%@AE@%%@NL@%
    RETURN%@NL@%
%@NL@%
%@AB@%  ' Put screen mask bits on the screen%@AE@%%@NL@%
PrintScreenMask:%@NL@%
    COLOR 12, 0%@NL@%
    screenMask$ = ""%@NL@%
    screenMask$ = Bin2BinStr$(screenMask%)%@NL@%
    MouseHide%@NL@%
    FOR i% = 0 TO 15%@NL@%
        SELECT CASE i%%@NL@%
        CASE 0 TO 7%@NL@%
            LOCATE 20, 53 - i%, 0%@NL@%
            PRINT MID$(screenMask$, 16 - i%, 1);%@NL@%
        CASE 8 TO 10%@NL@%
            LOCATE 20, 48 - i%, 0%@NL@%
            PRINT MID$(screenMask$, 16 - i%, 1);%@NL@%
        CASE 11%@NL@%
            LOCATE 20, 44 - i%, 0%@NL@%
            PRINT MID$(screenMask$, 16 - i%, 1);%@NL@%
        CASE 12 TO 14%@NL@%
            LOCATE 20, 40 - i%, 0%@NL@%
            PRINT MID$(screenMask$, 16 - i%, 1);%@NL@%
        CASE 15%@NL@%
            LOCATE 20, 36 - i%, 0%@NL@%
            PRINT MID$(screenMask$, 16 - i%, 1);%@NL@%
        CASE ELSE%@NL@%
        END SELECT%@NL@%
    NEXT i%%@NL@%
    shex$ = "&H" + RIGHT$("000" + HEX$(screenMask%), 4)%@NL@%
    LOCATE 20, 57, 0%@NL@%
    COLOR 10, 0%@NL@%
    PRINT shex$;%@NL@%
    MouseShow%@NL@%
    RETURN%@NL@%
%@NL@%
%@AB@%  ' Put cursor mask bits on the screen%@AE@%%@NL@%
PrintCursorMask:%@NL@%
    COLOR 12, 0%@NL@%
    cursorMask$ = ""%@NL@%
    cursorMask$ = Bin2BinStr$(cursorMask%)%@NL@%
    MouseHide%@NL@%
    FOR i% = 0 TO 15%@NL@%
        SELECT CASE i%%@NL@%
        CASE 0 TO 7%@NL@%
            LOCATE 21, 53 - i%, 0%@NL@%
            PRINT MID$(cursorMask$, 16 - i%, 1);%@NL@%
        CASE 8 TO 10%@NL@%
            LOCATE 21, 48 - i%, 0%@NL@%
            PRINT MID$(cursorMask$, 16 - i%, 1);%@NL@%
        CASE 11%@NL@%
            LOCATE 21, 44 - i%, 0%@NL@%
            PRINT MID$(cursorMask$, 16 - i%, 1);%@NL@%
        CASE 12 TO 14%@NL@%
            LOCATE 21, 40 - i%, 0%@NL@%
            PRINT MID$(cursorMask$, 16 - i%, 1);%@NL@%
        CASE 15%@NL@%
            LOCATE 21, 36 - i%, 0%@NL@%
            PRINT MID$(cursorMask$, 16 - i%, 1);%@NL@%
        CASE ELSE%@NL@%
        END SELECT%@NL@%
    NEXT i%%@NL@%
    chex$ = "&H" + RIGHT$("000" + HEX$(cursorMask%), 4)%@NL@%
    LOCATE 21, 57, 0%@NL@%
    COLOR 10, 0%@NL@%
    PRINT chex$;%@NL@%
    MouseShow%@NL@%
    RETURN%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%OBJECT.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\OBJECT.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          OBJECT                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        OBJECT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Allows interactive graphics object creation.%@AE@%%@NL@%
%@AB@%  ' Dumps code for another program to be able to create%@AE@%%@NL@%
%@AB@%  ' the graphics object "PUT array" directly.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:    CGA%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       OBJECT.BAS%@AE@%%@NL@%
%@AB@%  '                  KEYS.BAS%@AE@%%@NL@%
%@AB@%  '                  EDIT.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       quitFlag%     Indicates user is ready to quit%@AE@%%@NL@%
%@AB@%  '                  modeFlag%     Indicates a valid graphics mode was selected%@AE@%%@NL@%
%@AB@%  '                  mode%         Graphics mode%@AE@%%@NL@%
%@AB@%  '                  xMax%         Maximum screen X coordinate%@AE@%%@NL@%
%@AB@%  '                  yMax%         Maximum screen Y coordinate%@AE@%%@NL@%
%@AB@%  '                  fileName$     Name of object creation subprogram file%@AE@%%@NL@%
%@AB@%  '                  exitCode%     Return code from EditLine subprogram%@AE@%%@NL@%
%@AB@%  '                  t$            Temporary work string while reading file%@AE@%%@NL@%
%@AB@%  '                                contents%@AE@%%@NL@%
%@AB@%  '                  a$            The DRAW string%@AE@%%@NL@%
%@AB@%  '                  editFlag%     Indicates an edit of the string is desired%@AE@%%@NL@%
%@AB@%  '               drawErrorFlag%   Indicates an error occurred during the DRAW%@AE@%%@NL@%
%@AB@%  '                  keyNumber%    Integer key code returned by KeyCode%%@AE@%%@NL@%
%@AB@%  '                                function%@AE@%%@NL@%
%@AB@%  '                  okayFlag%     Shared flag for determining array dimensions%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Logical constants%@AE@%%@NL@%
    CONST FALSE = 0%@NL@%
    CONST TRUE = NOT FALSE%@NL@%
%@NL@%
%@AB@%  ' Key code constants%@AE@%%@NL@%
    CONST SKEYLC = 115%@NL@%
    CONST SKEYUC = SKEYLC - 32%@NL@%
    CONST QKEYLC = 113%@NL@%
    CONST QKEYUC = QKEYLC - 32%@NL@%
    CONST ESC = 27%@NL@%
%@NL@%
%@AB@%  ' Color constants%@AE@%%@NL@%
    CONST BLACK = 0%@NL@%
    CONST BLUE = 1%@NL@%
    CONST GREEN = 2%@NL@%
    CONST CYAN = 3%@NL@%
    CONST RED = 4%@NL@%
    CONST MAGENTA = 5%@NL@%
    CONST BROWN = 6%@NL@%
    CONST WHITE = 7%@NL@%
    CONST BRIGHT = 8%@NL@%
    CONST BLINK = 16%@NL@%
    CONST YELLOW = BROWN + BRIGHT%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION KeyCode% ()%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB DrawBox (row1%, col1%, row2%, col2%)%@NL@%
    DECLARE SUB EditBox (a$, row1%, col1%, row2%, col2%)%@NL@%
    DECLARE SUB EditLine (a$, exitCode%)%@NL@%
    DECLARE SUB SaveObject (mode%, xMax%, yMax%, fileName$, a$)%@NL@%
%@NL@%
%@AB@%  ' Initialization%@AE@%%@NL@%
    SCREEN 0%@NL@%
    CLS%@NL@%
    quitFlag% = FALSE%@NL@%
%@NL@%
%@AB@%  ' Title%@AE@%%@NL@%
    PRINT "OBJECT - Interactive graphics object editor"%@NL@%
    PRINT%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Display screen mode table%@AE@%%@NL@%
    PRINT "Adapter       SCREEN modes allowed"%@NL@%
    PRINT "----------    --------------------"%@NL@%
    PRINT "Monochrome    (none)"%@NL@%
    PRINT "Hercules      3"%@NL@%
    PRINT "CGA           1,2"%@NL@%
    PRINT "EGA           1,2,7,8,9"%@NL@%
    PRINT "MCGA          1,2,11,13"%@NL@%
    PRINT "VGA           1,2,7,8,9,10,11,12,13"%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Ask user for the graphics screen mode%@AE@%%@NL@%
    DO%@NL@%
        PRINT "Enter a SCREEN mode number, ";%@NL@%
        INPUT "based on your graphics adapter "; mode%%@NL@%
        modeFlag% = TRUE%@NL@%
        SELECT CASE mode%%@NL@%
        CASE 1, 7, 13%@NL@%
            xMax% = 319%@NL@%
            yMax% = 199%@NL@%
        CASE 2, 8%@NL@%
            xMax% = 639%@NL@%
            yMax% = 199%@NL@%
        CASE 9, 10%@NL@%
            xMax% = 639%@NL@%
            yMax% = 349%@NL@%
        CASE 11, 12%@NL@%
            xMax% = 639%@NL@%
            yMax% = 479%@NL@%
        CASE 3%@NL@%
            xMax% = 719%@NL@%
            yMax% = 347%@NL@%
        CASE ELSE%@NL@%
            modeFlag% = FALSE%@NL@%
        END SELECT%@NL@%
    LOOP UNTIL modeFlag% = TRUE%@NL@%
%@NL@%
%@AB@%  ' Ask user for the filename%@AE@%%@NL@%
    fileName$ = "IMAGEARY.BAS" + SPACE$(20)%@NL@%
    SCREEN 0%@NL@%
    WIDTH 80%@NL@%
    CLS%@NL@%
    COLOR WHITE, BLACK%@NL@%
    PRINT "Name of the file where source code will be written:"%@NL@%
    PRINT%@NL@%
    PRINT "Edit the default filename IMAGEARY.BAS ";%@NL@%
    PRINT "if desired, and then press Enter ..."%@NL@%
    PRINT%@NL@%
    PRINT SPACE$(12);%@NL@%
    COLOR YELLOW, BLUE%@NL@%
    EditLine fileName$, exitCode%%@NL@%
    COLOR WHITE, BLACK%@NL@%
%@NL@%
%@AB@%  ' Try to read in previous contents of the file%@AE@%%@NL@%
    ON ERROR GOTO FileError%@NL@%
    OPEN fileName$ FOR INPUT AS #1%@NL@%
    ON ERROR GOTO 0%@NL@%
    DO UNTIL EOF(1)%@NL@%
        LINE INPUT #1, t$%@NL@%
        IF INSTR(t$, "(DRAW$)") THEN%@NL@%
            t$ = MID$(t$, INSTR(t$, CHR$(34)) + 1)%@NL@%
            t$ = LEFT$(t$, INSTR(t$, CHR$(34)) - 1)%@NL@%
            a$ = a$ + t$%@NL@%
        END IF%@NL@%
    LOOP%@NL@%
    CLOSE #1%@NL@%
%@NL@%
%@AB@%  ' Main loop%@AE@%%@NL@%
    DO%@NL@%
%@NL@%
%@AB@%      ' Prepare for DRAW string editing by the user%@AE@%%@NL@%
        SCREEN 0%@NL@%
        WIDTH 80%@NL@%
        CLS%@NL@%
        editFlag% = FALSE%@NL@%
%@NL@%
%@AB@%      ' Display useful information%@AE@%%@NL@%
        PRINT "OBJECT - Screen mode"; mode%%@NL@%
        PRINT%@NL@%
        PRINT "Edit the DRAW string workspace; then press"%@NL@%
        PRINT "the Esc key to try out your creation..."%@NL@%
        PRINT%@NL@%
        PRINT , "                Cn      Color"%@NL@%
        PRINT , " H   U   E      Mx,y    Move absolute"%@NL@%
        PRINT , "   \ | /        M+|-x,y Move relative"%@NL@%
        PRINT , " L -   - R      An      Angle (1=90,2=180...)"%@NL@%
        PRINT , "   / | \        TAn     Turn angle (-360 to 360)"%@NL@%
        PRINT , " G   D   F      Sn      Scale factor"%@NL@%
        PRINT , "                Pc,b    Paint (color, border)"%@NL@%
        PRINT "(These commands are described in detail in the ";%@NL@%
        PRINT "Microsoft QuickBASIC Language Reference)"%@NL@%
%@NL@%
%@AB@%      ' Input DRAW string via EditBox subprogram%@AE@%%@NL@%
        COLOR GREEN + BRIGHT, BLUE%@NL@%
        DrawBox 15, 1, 24, 80%@NL@%
        COLOR YELLOW, BLUE%@NL@%
        EditBox a$, 15, 1, 24, 80%@NL@%
%@NL@%
%@AB@%      ' Try out the DRAW string%@AE@%%@NL@%
        SCREEN mode%%@NL@%
        drawErrorFlag% = FALSE%@NL@%
        ON ERROR GOTO DrawError%@NL@%
        DRAW a$%@NL@%
        ON ERROR GOTO 0%@NL@%
%@NL@%
%@AB@%      ' Give user idea of what to do%@AE@%%@NL@%
        LOCATE 1, 1%@NL@%
        PRINT "<S>ave, <Esc> to edit, or <Q>uit"%@NL@%
%@NL@%
%@AB@%      ' Get next valid keystroke%@AE@%%@NL@%
        DO UNTIL editFlag% OR drawErrorFlag% OR quitFlag%%@NL@%
%@NL@%
%@AB@%          ' Grab key code%@AE@%%@NL@%
            keyNumber% = KeyCode%%@NL@%
%@NL@%
%@AB@%          ' Process the keystroke%@AE@%%@NL@%
            SELECT CASE keyNumber%%@NL@%
%@NL@%
            CASE ESC%@NL@%
                editFlag% = TRUE%@NL@%
%@NL@%
            CASE QKEYLC, QKEYUC%@NL@%
                quitFlag% = TRUE%@NL@%
%@NL@%
            CASE SKEYLC, SKEYUC%@NL@%
                SaveObject mode%, xMax%, yMax%, fileName$, a$%@NL@%
%@NL@%
            CASE ELSE%@NL@%
            END SELECT%@NL@%
%@NL@%
        LOOP%@NL@%
%@NL@%
    LOOP UNTIL quitFlag%%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    CLS%@NL@%
    SCREEN 0%@NL@%
    WIDTH 80%@NL@%
    END%@NL@%
%@NL@%
FileError:%@NL@%
%@AB@%  ' Create the new file%@AE@%%@NL@%
    OPEN fileName$ FOR OUTPUT AS #1%@NL@%
    CLOSE #1%@NL@%
    OPEN fileName$ FOR INPUT AS #1%@NL@%
    RESUME NEXT%@NL@%
%@NL@%
DrawError:%@NL@%
    drawErrorFlag% = TRUE%@NL@%
    SCREEN 0%@NL@%
    CLS%@NL@%
    PRINT "Your DRAW string caused an error"%@NL@%
    PRINT%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
    RESUME NEXT%@NL@%
%@NL@%
ArrayError:%@NL@%
    okayFlag% = FALSE%@NL@%
    RESUME NEXT%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          SaveObject                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        OBJECT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Creates source code file for creating graphics mode%@AE@%%@NL@%
%@AB@%  ' objects for efficient "PUT" graphics.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:   SaveObject mode%, xMax%, yMax%, fileName$, a$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:       mode%      Graphics mode%@AE@%%@NL@%
%@AB@%  '                   xMax%      Maximum X screen coordinate for given%@AE@%%@NL@%
%@AB@%  '                              graphics mode%@AE@%%@NL@%
%@AB@%  '                   yMax%      Maximum Y screen coordinate for given%@AE@%%@NL@%
%@AB@%  '                              graphics mode%@AE@%%@NL@%
%@AB@%  '                   fileName$  Name of source code file to edit and/or%@AE@%%@NL@%
%@AB@%  '                              create%@AE@%%@NL@%
%@AB@%  '                   a$         The DRAW string that creates the object%@AE@%%@NL@%
%@AB@%  '                              initially%@AE@%%@NL@%
%@AB@%  ' VARIABLES:        okayFlag%  Shared flag used to determine array size%@AE@%%@NL@%
%@AB@%  '                   size%      Array sizing%@AE@%%@NL@%
%@AB@%  '                   edge%      Array for efficiently finding edges of object%@AE@%%@NL@%
%@AB@%  '                   stepSize%  Scanning step for search for object edges%@AE@%%@NL@%
%@AB@%  '                   yTop%      Y coordinate at top edge of object%@AE@%%@NL@%
%@AB@%  '                   yBot%      Y coordinate at bottom edge of object%@AE@%%@NL@%
%@AB@%  '                   y1%        Starting edge search Y coordinate%@AE@%%@NL@%
%@AB@%  '                   y2%        Ending edge search Y coordinate%@AE@%%@NL@%
%@AB@%  '                   i%         Looping index%@AE@%%@NL@%
%@AB@%  '                   xLeft%     X coordinate at left edge of object%@AE@%%@NL@%
%@AB@%  '                   xRight%    X coordinate at right edge of object%@AE@%%@NL@%
%@AB@%  '                   x1%        Starting edge search X coordinate%@AE@%%@NL@%
%@AB@%  '                   x2%        Ending edge search X coordinate%@AE@%%@NL@%
%@AB@%  '                   object%()  Array to hold GET object from screen%@AE@%%@NL@%
%@AB@%  '                   objName$   Name of object, derived from filename%@AE@%%@NL@%
%@AB@%  '                   ndx%       Index to any special characters in objName$%@AE@%%@NL@%
%@AB@%  '                   ary$       Name of array, derived from filename%@AE@%%@NL@%
%@AB@%  '                   d$         Works string for building lines for file%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS: DECLARE FUNCTION SaveObject (mode%, xMax%, yMax%,%@AE@%%@NL@%
%@AB@%  '                                              fileName$, a$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB SaveObject (mode%, xMax%, yMax%, fileName$, a$) STATIC%@NL@%
%@NL@%
%@AB@%      ' Shared error trap variable%@AE@%%@NL@%
        SHARED okayFlag%%@NL@%
%@NL@%
%@AB@%      ' Select the right array size for the mode%@AE@%%@NL@%
        SELECT CASE mode%%@NL@%
        CASE 1, 2%@NL@%
            size% = 93%@NL@%
        CASE 7, 8%@NL@%
            size% = 367%@NL@%
        CASE 9%@NL@%
            size% = 667%@NL@%
        CASE 10%@NL@%
            size% = 334%@NL@%
        CASE 11%@NL@%
            size% = 233%@NL@%
        CASE 12%@NL@%
            size% = 927%@NL@%
        CASE 13%@NL@%
            size% = 161%@NL@%
        CASE ELSE%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%      ' Build the array space%@AE@%%@NL@%
        DIM edge%(size%)%@NL@%
%@NL@%
%@AB@%      ' Scan to find top and bottom edges of the object%@AE@%%@NL@%
        stepSize% = 32%@NL@%
        yTop% = yMax%%@NL@%
        yBot% = 0%@NL@%
        y1% = 17%@NL@%
        y2% = yMax%%@NL@%
        DO%@NL@%
            FOR y% = y1% TO y2% STEP stepSize%%@NL@%
                IF y% < yTop% OR y% > yBot% THEN%@NL@%
                    GET (0, y%)-(xMax%, y%), edge%%@NL@%
                    LINE (0, y%)-(xMax%, y%)%@NL@%
                    FOR i% = 2 TO size%%@NL@%
                        IF edge%(i%) THEN%@NL@%
                            IF y% < yTop% THEN%@NL@%
                                yTop% = y%%@NL@%
                            END IF%@NL@%
                            IF y% > yBot% THEN%@NL@%
                                yBot% = y%%@NL@%
                            END IF%@NL@%
                            i% = size%%@NL@%
                        END IF%@NL@%
                    NEXT i%%@NL@%
                    PUT (0, y%), edge%, PSET%@NL@%
                END IF%@NL@%
            NEXT y%%@NL@%
            IF yTop% <= yBot% THEN%@NL@%
                y1% = yTop% - stepSize% * 2%@NL@%
                y2% = yBot% + stepSize% * 2%@NL@%
                IF y1% < 17 THEN%@NL@%
                    y1% = 17%@NL@%
                END IF%@NL@%
                IF y2% > yMax% THEN%@NL@%
                    y2% = yMax%%@NL@%
                END IF%@NL@%
            END IF%@NL@%
            stepSize% = stepSize% \ 2%@NL@%
        LOOP UNTIL stepSize% = 0%@NL@%
%@NL@%
%@AB@%      ' Scan to find left and right edges of the object%@AE@%%@NL@%
        stepSize% = 32%@NL@%
        xLeft% = xMax%%@NL@%
        xRight% = 0%@NL@%
        x1% = 0%@NL@%
        x2% = xMax%%@NL@%
        DO%@NL@%
            FOR x% = x1% TO x2% STEP stepSize%%@NL@%
                IF x% < xLeft% OR x% > xRight% THEN%@NL@%
                    GET (x%, yTop%)-(x%, yBot%), edge%%@NL@%
                    LINE (x%, yTop%)-(x%, yBot%)%@NL@%
                    FOR i% = 2 TO size%%@NL@%
                        IF edge%(i%) THEN%@NL@%
                            IF x% < xLeft% THEN%@NL@%
                                xLeft% = x%%@NL@%
                            END IF%@NL@%
                            IF x% > xRight% THEN%@NL@%
                                xRight% = x%%@NL@%
                            END IF%@NL@%
                            i% = size%%@NL@%
                        END IF%@NL@%
                    NEXT i%%@NL@%
                    PUT (x%, yTop%), edge%, PSET%@NL@%
                END IF%@NL@%
            NEXT x%%@NL@%
            IF xLeft% <= xRight% THEN%@NL@%
                x1% = xLeft% - stepSize% * 2%@NL@%
                x2% = xRight% + stepSize% * 2%@NL@%
                IF x1% < 0 THEN%@NL@%
                    x1% = 0%@NL@%
                END IF%@NL@%
                IF x2% > xMax% THEN%@NL@%
                    x2% = xMax%%@NL@%
                END IF%@NL@%
            END IF%@NL@%
            stepSize% = stepSize% \ 2%@NL@%
        LOOP UNTIL stepSize% = 0%@NL@%
%@NL@%
%@AB@%      ' Draw border around the object%@AE@%%@NL@%
        LINE (xLeft% - 1, yTop% - 1)-(xRight% + 1, yBot% + 1), , B%@NL@%
%@NL@%
%@AB@%      ' Build the right size integer array%@AE@%%@NL@%
        stepSize% = 256%@NL@%
        size% = 3%@NL@%
        DO%@NL@%
            DO%@NL@%
                IF size% < 3 THEN%@NL@%
                    size% = 3%@NL@%
                END IF%@NL@%
                REDIM object%(size%)%@NL@%
                okayFlag% = TRUE%@NL@%
                ON ERROR GOTO ArrayError%@NL@%
                GET (xLeft%, yTop%)-(xRight%, yBot%), object%%@NL@%
                ON ERROR GOTO 0%@NL@%
                IF okayFlag% = FALSE THEN%@NL@%
                    size% = size% + stepSize%%@NL@%
                ELSE%@NL@%
                    IF stepSize% > 1 THEN%@NL@%
                        size% = size% - stepSize%%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
            LOOP UNTIL okayFlag%%@NL@%
            stepSize% = stepSize% \ 2%@NL@%
        LOOP UNTIL stepSize% = 0%@NL@%
%@NL@%
%@AB@%      ' Make the name of the object%@AE@%%@NL@%
        objName$ = LTRIM$(RTRIM$(fileName$)) + "."%@NL@%
        ndx% = INSTR(objName$, "\")%@NL@%
        DO WHILE ndx%%@NL@%
            objName$ = MID$(objName$, ndx% + 1)%@NL@%
            ndx% = INSTR(objName$, "\")%@NL@%
        LOOP%@NL@%
        ndx% = INSTR(objName$, ":")%@NL@%
        DO WHILE ndx%%@NL@%
            objName$ = MID$(objName$, ndx% + 1)%@NL@%
            ndx% = INSTR(objName$, ":")%@NL@%
        LOOP%@NL@%
        ndx% = INSTR(objName$, ".")%@NL@%
        objName$ = LCASE$(LEFT$(objName$, ndx% - 1))%@NL@%
        IF objName$ = "" THEN%@NL@%
            objName$ = "xxxxxx"%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Make array name%@AE@%%@NL@%
        ary$ = objName$ + "%("%@NL@%
%@NL@%
%@AB@%      ' Open the file for the new source lines%@AE@%%@NL@%
        OPEN fileName$ FOR OUTPUT AS #1%@NL@%
%@NL@%
%@AB@%      ' Print the lines%@AE@%%@NL@%
        PRINT #1, " "%@NL@%
        PRINT #1, "  ' " + objName$%@NL@%
        FOR i% = 1 TO LEN(a$) STEP 50%@NL@%
            PRINT #1, "  ' (DRAW$) "; CHR$(34);%@NL@%
            PRINT #1, MID$(a$, i%, 50); CHR$(34)%@NL@%
        NEXT i%%@NL@%
        PRINT #1, "    DIM " + ary$; "0 TO";%@NL@%
        PRINT #1, STR$(size%) + ")"%@NL@%
        PRINT #1, "    FOR i% = 0 TO"; size%%@NL@%
        PRINT #1, "        READ h$"%@NL@%
        PRINT #1, "        " + ary$ + "i%) = VAL(";%@NL@%
        PRINT #1, CHR$(34) + "&H" + CHR$(34);%@NL@%
        PRINT #1, " + h$)"%@NL@%
        PRINT #1, "    NEXT i%"%@NL@%
        FOR i% = 0 TO size%%@NL@%
            IF d$ = "" THEN%@NL@%
                d$ = "    DATA "%@NL@%
            ELSE%@NL@%
                d$ = d$ + ","%@NL@%
            END IF%@NL@%
            d$ = d$ + HEX$(object%(i%))%@NL@%
            IF LEN(d$) > 60 OR i% = size% THEN%@NL@%
                PRINT #1, d$%@NL@%
                d$ = ""%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
        PRINT #1, " "%@NL@%
%@NL@%
%@AB@%      ' Close the file%@AE@%%@NL@%
        CLOSE%@NL@%
%@NL@%
%@AB@%      ' Erase the border around the object%@AE@%%@NL@%
        LINE (xLeft% - 1, yTop% - 1)-(xRight% + 1, yBot% + 1), 0, B%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PALETTE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\PALETTE.BAS%@AE@%%@NL@%
%@NL@%
DECLARE SUB InitPalette ()%@NL@%
DECLARE SUB ChangePalette ()%@NL@%
DECLARE SUB DrawEllipses ()%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
DIM SHARED PaletteArray(15)%@NL@%
%@NL@%
SCREEN 8                 ' 640 x 200 resolution; 16 colors%@NL@%
%@NL@%
InitPalette%@NL@%
DrawEllipses%@NL@%
%@NL@%
DO%@NL@%
   ChangePalette%@NL@%
LOOP WHILE INKEY$ = ""   ' Shift palette until key pressed%@NL@%
%@NL@%
END%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================= InitPalette ========================%@AE@%%@NL@%
%@AB@%'    This procedure initializes the integer array used to%@AE@%%@NL@%
%@AB@%'    change the palette.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB InitPalette STATIC%@NL@%
   FOR I = 0 TO 15%@NL@%
      PaletteArray(I) = I%@NL@%
   NEXT I%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ====================== DrawEllipses ========================%@AE@%%@NL@%
%@AB@%'    This procedure draws fifteen concentric ellipses, and%@AE@%%@NL@%
%@AB@%'    paints the interior of each with a different color.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB DrawEllipses STATIC%@NL@%
   CONST ASPECT = 1 / 3%@NL@%
   FOR ColorVal = 15 TO 1 STEP -1%@NL@%
      Radius = 20 * ColorVal%@NL@%
      CIRCLE (320, 100), Radius, ColorVal, , , ASPECT%@NL@%
      PAINT (320, 100), ColorVal%@NL@%
   NEXT%@NL@%
END SUB%@NL@%
%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ====================== ChangePalette =======================%@AE@%%@NL@%
%@AB@%'    This procedure rotates the palette by one each time it%@AE@%%@NL@%
%@AB@%'    is called.  For example, after the first call to%@AE@%%@NL@%
%@AB@%'    ChangePalette, PaletteArray(1) = 2, PaletteArray(2) = 3,%@AE@%%@NL@%
%@AB@%'    . . . , PaletteArray(14) = 15, and PaletteArray(15) = 1%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ChangePalette STATIC%@NL@%
   FOR I = 1 TO 15%@NL@%
      PaletteArray(I) = (PaletteArray(I) MOD 15) + 1%@NL@%
   NEXT I%@NL@%
%@NL@%
%@AB@%   ' Shift the color displayed by each of the attributes from%@AE@%%@NL@%
%@AB@%   ' one to fifteen:%@AE@%%@NL@%
   PALETTE USING PaletteArray(0)%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PARSE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\PARSE.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          PARSE                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        PARSE.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       a$()       Array of words parsed from x$%@AE@%%@NL@%
%@AB@%  '                  x$         String to be parsed%@AE@%%@NL@%
%@AB@%  '                  sep$       Characters defining word separation%@AE@%%@NL@%
%@AB@%  '                  word$      Each word from the string%@AE@%%@NL@%
%@AB@%  '                  n%         Index to each word in array%@AE@%%@NL@%
%@NL@%
    DECLARE SUB ParseLine (x$, sep$, a$())%@NL@%
    DECLARE SUB ParseWord (a$, sep$, word$)%@NL@%
%@NL@%
%@AB@%  ' Initialization%@AE@%%@NL@%
    CLS%@NL@%
    DIM a$(1 TO 99)%@NL@%
%@NL@%
%@AB@%  ' Demonstrate ParseWord%@AE@%%@NL@%
    x$ = "This is a test line. A,B,C, etc."%@NL@%
    sep$ = " ,"%@NL@%
    PRINT "x$:", x$%@NL@%
    PRINT "sep$:", CHR$(34); sep$; CHR$(34)%@NL@%
    ParseWord x$, sep$, word$%@NL@%
    PRINT "ParseWord x$, sep$, word$"%@NL@%
    PRINT "x$:", x$%@NL@%
    PRINT "word$:", word$%@NL@%
%@NL@%
%@AB@%  ' Demonstrate ParseLine%@AE@%%@NL@%
    PRINT%@NL@%
    x$ = "This is a test line. A,B,C, etc."%@NL@%
    sep$ = " ,"%@NL@%
    PRINT "x$:", x$%@NL@%
    PRINT "sep$:", CHR$(34); sep$; CHR$(34)%@NL@%
    ParseLine x$, sep$, a$()%@NL@%
    PRINT "ParseLine x$, sep$, a$()"%@NL@%
    PRINT "a$()..."%@NL@%
    DO%@NL@%
        n% = n% + 1%@NL@%
        PRINT n%, a$(n%)%@NL@%
    LOOP UNTIL a$(n% + 1) = ""%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    END%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ParseLine                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        PARSE.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Breaks a string into an array of words, as defined%@AE@%%@NL@%
%@AB@%  ' by any characters listed in sep$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ParseLine x$, sep$, a$()%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x$      String to be parsed%@AE@%%@NL@%
%@AB@%  '                  sep$    List of characters defined as word separators%@AE@%%@NL@%
%@AB@%  '                  a$()    Returned array of words%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       t$      Temporary work string%@AE@%%@NL@%
%@AB@%  '                  i%      Index to array entries%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB ParseLine (x$, sep$, a$())%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ParseLine (x$, sep$, a$()) STATIC%@NL@%
        t$ = x$%@NL@%
        FOR i% = LBOUND(a$) TO UBOUND(a$)%@NL@%
            ParseWord t$, sep$, a$(i%)%@NL@%
            IF a$(i%) = "" THEN%@NL@%
                EXIT FOR%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
        t$ = ""%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ParseWord                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        PARSE.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Breaks off the first word in a$, as delimited by%@AE@%%@NL@%
%@AB@%  ' any characters listed in sep$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ParseWord a$, sep$, word$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String to be parsed%@AE@%%@NL@%
%@AB@%  '                  sep$       List of characters defined as word separators%@AE@%%@NL@%
%@AB@%  '                  word$      Returned first word parsed from a$%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       lena%      Length of a$%@AE@%%@NL@%
%@AB@%  '                  i%         Looping index%@AE@%%@NL@%
%@AB@%  '                  j%         Looping index%@AE@%%@NL@%
%@AB@%  '                  k%         Looping index%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB ParseWord (a$, sep$, word$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ParseWord (a$, sep$, word$) STATIC%@NL@%
        word$ = ""%@NL@%
        lena% = LEN(a$)%@NL@%
        IF a$ = "" THEN%@NL@%
            EXIT SUB%@NL@%
        END IF%@NL@%
        FOR i% = 1 TO lena%%@NL@%
            IF INSTR(sep$, MID$(a$, i%, 1)) = 0 THEN%@NL@%
                EXIT FOR%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
        FOR j% = i% TO lena%%@NL@%
            IF INSTR(sep$, MID$(a$, j%, 1)) THEN%@NL@%
                EXIT FOR%@NL@%
            END IF%@NL@%
        NEXT j%%@NL@%
        FOR k% = j% TO lena%%@NL@%
            IF INSTR(sep$, MID$(a$, k%, 1)) = 0 THEN%@NL@%
                EXIT FOR%@NL@%
            END IF%@NL@%
        NEXT k%%@NL@%
        IF i% > lena% THEN%@NL@%
            a$ = ""%@NL@%
            EXIT SUB%@NL@%
        END IF%@NL@%
        IF j% > lena% THEN%@NL@%
            word$ = MID$(a$, i%)%@NL@%
            a$ = ""%@NL@%
            EXIT SUB%@NL@%
        END IF%@NL@%
        word$ = MID$(a$, i%, j% - i%)%@NL@%
        IF k% > lena% THEN%@NL@%
            a$ = ""%@NL@%
        ELSE%@NL@%
            a$ = MID$(a$, k%)%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PLOTTER.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\PLOTTER.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' Values for keys on the numeric keypad and the spacebar:%@AE@%%@NL@%
CONST UP = 72, DOWN = 80, LFT = 75, RGHT = 77%@NL@%
CONST UPLFT = 71, UPRGHT = 73, DOWNLFT = 79, DOWNRGHT = 81%@NL@%
CONST SPACEBAR = " "%@NL@%
%@NL@%
%@AB@%' Null$ is the first character of the two-character INKEY$%@AE@%%@NL@%
%@AB@%' value returned for direction keys such as UP and DOWN:%@AE@%%@NL@%
Null$ = CHR$(0)%@NL@%
%@NL@%
%@AB@%' Plot$ = "" means draw lines; Plot$ = "B" means move%@AE@%%@NL@%
%@AB@%' graphics cursor, but don't draw lines:%@AE@%%@NL@%
Plot$ = ""%@NL@%
%@NL@%
PRINT "Use the cursor movement keys to draw lines."%@NL@%
PRINT "Press the spacebar to toggle line drawing on and off."%@NL@%
PRINT "Press <ENTER> to begin. Press q to end the program."%@NL@%
DO: LOOP WHILE INKEY$ = ""%@NL@%
%@NL@%
SCREEN 1%@NL@%
CLS%@NL@%
%@NL@%
DO%@NL@%
   SELECT CASE KeyVal$%@NL@%
      CASE Null$ + CHR$(UP)%@NL@%
         DRAW Plot$ + "C1 U2"%@NL@%
      CASE Null$ + CHR$(DOWN)%@NL@%
         DRAW Plot$ + "C1 D2"%@NL@%
      CASE Null$ + CHR$(LFT)%@NL@%
         DRAW Plot$ + "C2 L2"%@NL@%
      CASE Null$ + CHR$(RGHT)%@NL@%
         DRAW Plot$ + "C2 R2"%@NL@%
      CASE Null$ + CHR$(UPLFT)%@NL@%
         DRAW Plot$ + "C3 H2"%@NL@%
      CASE Null$ + CHR$(UPRGHT)%@NL@%
         DRAW Plot$ + "C3 E2"%@NL@%
      CASE Null$ + CHR$(DOWNLFT)%@NL@%
         DRAW Plot$ + "C3 G2"%@NL@%
      CASE Null$ + CHR$(DOWNRGHT)%@NL@%
         DRAW Plot$ + "C3 F2"%@NL@%
      CASE SPACEBAR%@NL@%
         IF Plot$ = "" THEN Plot$ = "B " ELSE Plot$ = ""%@NL@%
      CASE ELSE%@NL@%
%@AB@%         ' The user pressed some key other than one of the%@AE@%%@NL@%
%@AB@%         ' direction keys, the  spacebar, or "q", so%@AE@%%@NL@%
%@AB@%         ' don't do anything.%@AE@%%@NL@%
   END SELECT%@NL@%
%@NL@%
   KeyVal$ = INKEY$%@NL@%
%@NL@%
LOOP UNTIL KeyVal$ = "q"%@NL@%
%@NL@%
SCREEN 0, 0%@NL@%
WIDTH 80%@NL@%
END%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%PROBSTAT.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\PROBSTAT.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          PROBSTAT                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        PROBSTAT.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Demonstrates several probability and statistics-%@AE@%%@NL@%
%@AB@%  ' related mathematical functions.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:          No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:      (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:     (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      a#()       Array of numbers to be processed%@AE@%%@NL@%
%@AB@%  '                 i%         Index into array%@AE@%%@NL@%
%@AB@%  '                 n&         Number of items for combinations and permutations%@AE@%%@NL@%
%@AB@%  '                 r&         Quantity for combinations and permutations%@AE@%%@NL@%
%@NL@%
%@NL@%
    DECLARE FUNCTION Combinations# (n&, r&)%@NL@%
    DECLARE FUNCTION Factorial# (n&)%@NL@%
    DECLARE FUNCTION Permutations# (n&, r&)%@NL@%
    DECLARE FUNCTION GeometricMean# (a#())%@NL@%
    DECLARE FUNCTION HarmonicMean# (a#())%@NL@%
    DECLARE FUNCTION ArithmeticMean# (a#())%@NL@%
    DECLARE FUNCTION QuadraticMean# (a#())%@NL@%
%@NL@%
%@AB@%  ' Demonstrations%@AE@%%@NL@%
    CLS%@NL@%
    PRINT "PROBSTAT"%@NL@%
    PRINT%@NL@%
    PRINT "Array of numbers..."%@NL@%
    DIM a#(-3 TO 6)%@NL@%
    FOR i% = -3 TO 6%@NL@%
        READ a#(i%)%@NL@%
        PRINT a#(i%),%@NL@%
    NEXT i%%@NL@%
    PRINT%@NL@%
    DATA  1.2,3.4,5.6,7.8,9.1,2.3,4.5,6.7,8.9,1.2%@NL@%
%@NL@%
    PRINT%@NL@%
    PRINT "Arithmetic mean = "; ArithmeticMean#(a#())%@NL@%
    PRINT "Geometric mean  = "; GeometricMean#(a#())%@NL@%
    PRINT "Harmonic mean   = "; HarmonicMean#(a#())%@NL@%
    PRINT "Quadratic mean  = "; QuadraticMean#(a#())%@NL@%
    PRINT%@NL@%
%@NL@%
    n& = 17%@NL@%
    r& = 5%@NL@%
    PRINT "Combinations of"; n&; "objects taken";%@NL@%
    PRINT r&; "at a time = "; Combinations#(n&, r&)%@NL@%
%@NL@%
    PRINT "Permutations of"; n&; "objects taken";%@NL@%
    PRINT r&; "at a time = "; Permutations#(n&, r&)%@NL@%
%@NL@%
    PRINT%@NL@%
    PRINT "Factorial of 17 = "; Factorial#(17&)%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    END%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ArithmeticMean#            **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        PROBSTAT.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the arithmetic mean of an array of numbers.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ArithmeticMean# a#()%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a#()       Array of double-precision numbers to be%@AE@%%@NL@%
%@AB@%  '                             processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       n%         Count of array entries%@AE@%%@NL@%
%@AB@%  '                  sum#       Sum of the array entries%@AE@%%@NL@%
%@AB@%  '                  i%         Looping index%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION ArithmeticMean# (a#())%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION ArithmeticMean# (a#()) STATIC%@NL@%
        n% = 0%@NL@%
        sum# = 0%@NL@%
        FOR i% = LBOUND(a#) TO UBOUND(a#)%@NL@%
            n% = n% + 1%@NL@%
            sum# = sum# + a#(i%)%@NL@%
        NEXT i%%@NL@%
        ArithmeticMean# = sum# / n%%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Combinations#              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        PROBSTAT.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the number of combinations of n& items%@AE@%%@NL@%
%@AB@%  ' taken r& at a time.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  c# = Combinations#(n&, r&)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      n&         Number of items%@AE@%%@NL@%
%@AB@%  '                  r&         Taken r& at a time%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       result#    Working result variable%@AE@%%@NL@%
%@AB@%  '                  j&         Working copy of r&%@AE@%%@NL@%
%@AB@%  '                  k&         Difference between n& and r&%@AE@%%@NL@%
%@AB@%  '                  h&         Values from r& through n&%@AE@%%@NL@%
%@AB@%  '                  i&         Values from 1 through j&%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Combinations# (n&, r&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Combinations# (n&, r&) STATIC%@NL@%
        result# = 1%@NL@%
        j& = r&%@NL@%
        k& = n& - r&%@NL@%
        h& = n&%@NL@%
        IF j& > k& THEN%@NL@%
            SWAP j&, k&%@NL@%
        END IF%@NL@%
        FOR i& = 1 TO j&%@NL@%
            result# = (result# * h&) / i&%@NL@%
            h& = h& - 1%@NL@%
        NEXT i&%@NL@%
        Combinations# = result#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Factorial#                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        PROBSTAT.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the factorial of n& (recursive).%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  f# = Factorial#(n&)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      n&         Number to be evaluated%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Factorial# (n&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Factorial# (n&)%@NL@%
        IF n& > 1 THEN%@NL@%
            Factorial# = n& * Factorial#(n& - 1)%@NL@%
        ELSE%@NL@%
            Factorial# = 1%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          GeometricMean#             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        PROBSTAT.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the geometric mean of an array of numbers.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  gm# = GeometricMean#(a#())%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a#()       Array of numbers to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       n%         Count of numbers%@AE@%%@NL@%
%@AB@%  '                  product#   Product of all the numbers%@AE@%%@NL@%
%@AB@%  '                  i%         Index to array entries%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION GeometricMean# (a#())%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION GeometricMean# (a#()) STATIC%@NL@%
        n% = 0%@NL@%
        product# = 1%@NL@%
        FOR i% = LBOUND(a#) TO UBOUND(a#)%@NL@%
            n% = n% + 1%@NL@%
            product# = product# * a#(i%)%@NL@%
        NEXT i%%@NL@%
        GeometricMean# = product# ^ (1 / n%)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          HarmonicMean#              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        PROBSTAT.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the harmonic mean of an array of numbers.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  hm# = HarmonicMean#(a#())%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a#()       Array of numbers to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       n%         Number of array entries%@AE@%%@NL@%
%@AB@%  '                  sum#       Sum of the reciprocal of each number%@AE@%%@NL@%
%@AB@%  '                  i%         Index to each array entry%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION HarmonicMean# (a#())%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION HarmonicMean# (a#()) STATIC%@NL@%
        n% = 0%@NL@%
        sum# = 0%@NL@%
        FOR i% = LBOUND(a#) TO UBOUND(a#)%@NL@%
            n% = n% + 1%@NL@%
            sum# = sum# + 1# / a#(i%)%@NL@%
        NEXT i%%@NL@%
        HarmonicMean# = n% / sum#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Permutations#              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        PROBSTAT.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the permutations of n& items taken r& at a time.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  perm# = Permutations#(n&, r&)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      n&         Number of items%@AE@%%@NL@%
%@AB@%  '                  r&         Taken r& at a time%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       p#         Working variable for permutations%@AE@%%@NL@%
%@AB@%  '                  i&         Loop index%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Permutations# (n&, r&)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Permutations# (n&, r&) STATIC%@NL@%
        p# = 1%@NL@%
        FOR i& = n& - r& + 1 TO n&%@NL@%
            p# = p# * i&%@NL@%
        NEXT i&%@NL@%
        Permutations# = p#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          QuadraticMean#             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        PROBSTAT.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the quadratic mean of an array of numbers.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  qm# = QuadraticMean#(a#())%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a#()       Array of numbers to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       n%         Count of array entries%@AE@%%@NL@%
%@AB@%  '                  sum#       Sum of the square of each number%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION QuadraticMean# (a#())%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION QuadraticMean# (a#()) STATIC%@NL@%
        n% = 0%@NL@%
        sum# = 0%@NL@%
        FOR i% = LBOUND(a#) TO UBOUND(a#)%@NL@%
            n% = n% + 1%@NL@%
            sum# = sum# + a#(i%) ^ 2%@NL@%
        NEXT i%%@NL@%
        QuadraticMean# = SQR(sum# / n%)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%QBFMT.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\QBFMT.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          QBFMT                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QBFMT.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Reformats a QuickBASIC program by indenting%@AE@%%@NL@%
%@AB@%  ' lines according to the structure of the statements.  The%@AE@%%@NL@%
%@AB@%  ' default amount is 4 spaces if no indention parameter%@AE@%%@NL@%
%@AB@%  ' is given on the command line.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:  QBFMT filename [indention]%@AE@%%@NL@%
%@AB@%  '         Command$ = filename [indention]%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:   QBFMT.BAS%@AE@%%@NL@%
%@AB@%  '              PARSE.BAS%@AE@%%@NL@%
%@AB@%  '              STRINGS.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:  filename(.BAS)   Name of QuickBASIC module to be formatted;%@AE@%%@NL@%
%@AB@%  '                               the module must be saved in "Text" format%@AE@%%@NL@%
%@AB@%  ' VARIABLES:   md$              Working copy of COMMAND$ contents%@AE@%%@NL@%
%@AB@%  '              fileName$        Name of QuickBASIC module to be formatted%@AE@%%@NL@%
%@AB@%  '              dpoint%          Position of the decimal point character%@AE@%%@NL@%
%@AB@%  '                               in cmd$%@AE@%%@NL@%
%@AB@%  '              ndent$           Part of cmd$ dealing with optional%@AE@%%@NL@%
%@AB@%  '                               indention amount%@AE@%%@NL@%
%@AB@%  '              indention%       Number of character columns per%@AE@%%@NL@%
%@AB@%  '                               indention level%@AE@%%@NL@%
%@AB@%  '              progline$        Each line of the file being processed%@AE@%%@NL@%
%@AB@%  '              indentLevel%     Keeps track of current indention amount%@AE@%%@NL@%
%@AB@%  '              nest$            Message placed in file if faulty structure%@AE@%%@NL@%
%@AB@%  '                               detected%@AE@%%@NL@%
%@NL@%
    DECLARE FUNCTION LtrimSet$ (a$, set$)%@NL@%
    DECLARE FUNCTION RtrimSet$ (a$, set$)%@NL@%
    DECLARE SUB Indent (a$, indention%, indentLevel%)%@NL@%
    DECLARE SUB ParseWord (a$, sep$, word$)%@NL@%
    DECLARE SUB SetCode (a$, keyWord$, code%)%@NL@%
    DECLARE SUB SplitUp (a$, comment$, keyWord$)%@NL@%
%@NL@%
%@AB@%  ' Decipher the user command line%@AE@%%@NL@%
    cmd$ = COMMAND$%@NL@%
    IF cmd$ = "" THEN%@NL@%
        PRINT%@NL@%
        PRINT "Usage:  QBFMT filename(.BAS) [indention]"%@NL@%
        SYSTEM%@NL@%
    ELSE%@NL@%
        ParseWord cmd$, " ,", fileName$%@NL@%
        dpoint% = INSTR(fileName$, ".")%@NL@%
        IF dpoint% THEN%@NL@%
            fileName$ = LEFT$(fileName$, dpoint% - 1)%@NL@%
        END IF%@NL@%
        ParseWord cmd$, " ,", ndent$%@NL@%
        indention% = VAL(ndent$)%@NL@%
        IF indention% < 1 THEN%@NL@%
            indention% = 4%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Try to open the indicated files%@AE@%%@NL@%
    PRINT%@NL@%
    ON ERROR GOTO ErrorTrapOne%@NL@%
    OPEN fileName$ + ".BAS" FOR INPUT AS #1%@NL@%
    OPEN fileName$ + ".@$@" FOR OUTPUT AS #2%@NL@%
    ON ERROR GOTO 0%@NL@%
%@NL@%
%@AB@%  ' Process each line of the file%@AE@%%@NL@%
    DO%@NL@%
        LINE INPUT #1, progLine$%@NL@%
        Indent progLine$, indention%, indentLevel%%@NL@%
        PRINT progLine$%@NL@%
        PRINT #2, progLine$%@NL@%
        IF indentLevel% < 0 OR (EOF(1) AND indentLevel% <> 0) THEN%@NL@%
            SOUND 555, 5%@NL@%
            SOUND 333, 9%@NL@%
            nest$ = "'<<<<<<<<<<<<<<<<<<<<< Nesting error detected!"%@NL@%
            PRINT nest$%@NL@%
            PRINT #2, nest$%@NL@%
            indentLevel% = 0%@NL@%
        END IF%@NL@%
    LOOP UNTIL EOF(1)%@NL@%
%@NL@%
%@AB@%  ' Close all files%@AE@%%@NL@%
    CLOSE%@NL@%
%@NL@%
%@AB@%  ' Delete any old .BAK file%@AE@%%@NL@%
    ON ERROR GOTO ErrorTrapTwo%@NL@%
    KILL fileName$ + ".BAK"%@NL@%
    ON ERROR GOTO 0%@NL@%
%@NL@%
%@AB@%  ' Rename the files%@AE@%%@NL@%
    NAME fileName$ + ".BAS" AS fileName$ + ".BAK"%@NL@%
    NAME fileName$ + ".@$@" AS fileName$ + ".BAS"%@NL@%
%@NL@%
%@AB@%  ' We're done%@AE@%%@NL@%
    END%@NL@%
%@NL@%
%@AB@%  '----------- Error trapping routines%@AE@%%@NL@%
%@NL@%
ErrorTrapOne:%@NL@%
    PRINT "Error while opening files"%@NL@%
    SYSTEM%@NL@%
%@NL@%
ErrorTrapTwo:%@NL@%
    RESUME NEXT%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Indent                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QBFMT.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Determines the indention for each line.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Indent a$, indention%, indentLevel%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$             Program line to be indented%@AE@%%@NL@%
%@AB@%  '                  indention%     Spaces to add for each indention level%@AE@%%@NL@%
%@AB@%  '                  indentLevel%   Level of indention%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       comment$       Part of program line that represents a%@AE@%%@NL@%
%@AB@%  '                                 REMARK%@AE@%%@NL@%
%@AB@%  '                  keyWord$       First word of the program line%@AE@%%@NL@%
%@AB@%  '                  code%          Indention control code determined by%@AE@%%@NL@%
%@AB@%  '                                 keyWord$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Indent (a$, indention%, indentLevel%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Indent (a$, indention%, indentLevel%) STATIC%@NL@%
%@NL@%
%@AB@%      ' Break line into manageable parts%@AE@%%@NL@%
        SplitUp a$, comment$, keyWord$%@NL@%
%@NL@%
        IF keyWord$ <> "" THEN%@NL@%
%@NL@%
%@AB@%          ' Set indention code according to type of keyword%@AE@%%@NL@%
            SetCode a$, keyWord$, code%%@NL@%
%@NL@%
%@AB@%          ' Build a string of spaces for the indicated indention%@AE@%%@NL@%
            SELECT CASE code%%@NL@%
            CASE -2%@NL@%
                a$ = SPACE$(indention% * indentLevel%) + a$%@NL@%
            CASE -1%@NL@%
                a$ = SPACE$(indention% * indentLevel%) + a$%@NL@%
                indentLevel% = indentLevel% - 1%@NL@%
            CASE 0%@NL@%
                a$ = SPACE$(indention% * (indentLevel% + 1)) + a$%@NL@%
            CASE 1%@NL@%
                indentLevel% = indentLevel% + 1%@NL@%
                a$ = SPACE$(indention% * indentLevel%) + a$%@NL@%
            CASE ELSE%@NL@%
            END SELECT%@NL@%
        ELSE%@NL@%
            a$ = SPACE$(indention% * indentLevel% + 2)%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Round out the position of trailing comments%@AE@%%@NL@%
        IF comment$ <> "" THEN%@NL@%
            IF a$ <> SPACE$(LEN(a$)) AND a$ <> "" THEN%@NL@%
                a$ = a$ + SPACE$(16 - (LEN(a$) MOD 16))%@NL@%
            END IF%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Tack the comment back onto the end of the line%@AE@%%@NL@%
        a$ = a$ + comment$%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          SetCode                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QBFMT.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Determines a code number for the type of indention%@AE@%%@NL@%
%@AB@%  ' implied by the various types of keywords that begin%@AE@%%@NL@%
%@AB@%  ' each line of QuickBASIC programs.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:   SetCode a$, keyWord$, code%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:       a$         Program line to indent%@AE@%%@NL@%
%@AB@%  '                   keyWord$   First word of the program line%@AE@%%@NL@%
%@AB@%  '                   code%      Returned code indicating the action to be taken%@AE@%%@NL@%
%@AB@%  ' VARIABLES:        (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:   DECLARE SUB SetCode (a$, keyWord$, code%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB SetCode (a$, keyWord$, code%) STATIC%@NL@%
        SELECT CASE keyWord$%@NL@%
        CASE "DEF"%@NL@%
            IF INSTR(a$, "=") THEN%@NL@%
                code% = 0%@NL@%
            ELSE%@NL@%
                IF INSTR(a$, " SEG") = 0 THEN%@NL@%
                    code% = 1%@NL@%
                END IF%@NL@%
            END IF%@NL@%
        CASE "ELSE"%@NL@%
            code% = -2%@NL@%
        CASE "ELSEIF"%@NL@%
            code% = -2%@NL@%
        CASE "CASE"%@NL@%
            code% = -2%@NL@%
        CASE "END"%@NL@%
            IF a$ <> "END" THEN%@NL@%
                code% = -1%@NL@%
            ELSE%@NL@%
                code% = 0%@NL@%
            END IF%@NL@%
        CASE "FOR"%@NL@%
            code% = 1%@NL@%
        CASE "DO"%@NL@%
            code% = 1%@NL@%
        CASE "SELECT"%@NL@%
            code% = 1%@NL@%
        CASE "IF"%@NL@%
            IF RIGHT$(a$, 4) = "THEN" THEN%@NL@%
                code% = 1%@NL@%
            ELSE%@NL@%
                code% = 0%@NL@%
            END IF%@NL@%
        CASE "NEXT"%@NL@%
            code% = -1%@NL@%
        CASE "LOOP"%@NL@%
            code% = -1%@NL@%
        CASE "SUB"%@NL@%
            code% = 1%@NL@%
        CASE "FUNCTION"%@NL@%
            code% = 1%@NL@%
        CASE "TYPE"%@NL@%
            code% = 1%@NL@%
        CASE "WHILE"%@NL@%
            code% = 1%@NL@%
        CASE "WEND"%@NL@%
            code% = -1%@NL@%
        CASE ELSE%@NL@%
            code% = 0%@NL@%
        END SELECT%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          SplitUp                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QBFMT.BAS                  **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Splits the line into statement, comment, and keyword.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  SplitUp a$, comment$, keyWord$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         Program line to be split up%@AE@%%@NL@%
%@AB@%  '                  comment$   Part of line following "REM" or "'"%@AE@%%@NL@%
%@AB@%  '                  keyWord$   First word of program line%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       set$       Characters to be trimmed, space and tab%@AE@%%@NL@%
%@AB@%  '                  strFlag%   Indication of a quoted string%@AE@%%@NL@%
%@AB@%  '                  k%         Index to start of REMARK%@AE@%%@NL@%
%@AB@%  '                  i%         Looping index%@AE@%%@NL@%
%@AB@%  '                  m%         Pointer to REMARK%@AE@%%@NL@%
%@AB@%  '                  sptr%      Pointer to first space following the%@AE@%%@NL@%
%@AB@%  '                             first word in a$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB SplitUp (a$, comment$, keyWord$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB SplitUp (a$, comment$, keyWord$) STATIC%@NL@%
        set$ = " " + CHR$(9)%@NL@%
        strFlag% = 0%@NL@%
        k% = 0%@NL@%
        FOR i% = LEN(a$) TO 1 STEP -1%@NL@%
            IF MID$(a$, i%, 1) = CHR$(34) THEN%@NL@%
                IF strFlag% = 0 THEN%@NL@%
                    strFlag% = 1%@NL@%
                ELSE%@NL@%
                    strFlag% = 0%@NL@%
                END IF%@NL@%
            END IF%@NL@%
            IF MID$(a$, i%, 1) = "'" OR MID$(a$, i%, 3) = "REM" THEN%@NL@%
                IF strFlag% = 0 THEN%@NL@%
                    k% = i%%@NL@%
                END IF%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
        IF k% > 0 THEN%@NL@%
            m% = 0%@NL@%
            FOR j% = k% - 1 TO 1 STEP -1%@NL@%
                IF INSTR(set$, MID$(a$, j%, 1)) = 0 THEN%@NL@%
                    IF m% = 0 THEN m% = j%%@NL@%
                END IF%@NL@%
            NEXT j%%@NL@%
            IF m% THEN%@NL@%
                comment$ = MID$(a$, m% + 1)%@NL@%
                a$ = LEFT$(a$, m%)%@NL@%
            ELSE%@NL@%
                comment$ = a$%@NL@%
                a$ = ""%@NL@%
            END IF%@NL@%
        ELSE%@NL@%
            comment$ = ""%@NL@%
        END IF%@NL@%
        a$ = LtrimSet$(a$, set$)%@NL@%
        a$ = RtrimSet$(a$, set$)%@NL@%
        comment$ = LtrimSet$(comment$, set$)%@NL@%
        comment$ = RtrimSet$(comment$, set$)%@NL@%
        sptr% = INSTR(a$, " ")%@NL@%
        IF sptr% THEN%@NL@%
            keyWord$ = UCASE$(LEFT$(a$, sptr% - 1))%@NL@%
        ELSE%@NL@%
            keyWord$ = UCASE$(a$)%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%QBTREE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\QBTREE.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          QBTREE                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QBTREE.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' This program creates a list of directories and%@AE@%%@NL@%
%@AB@%  ' subdirectories, and all files in them.  If no%@AE@%%@NL@%
%@AB@%  ' command line path is given, the search%@AE@%%@NL@%
%@AB@%  ' begins with the current directory.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:          QBTREE [path]%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:   MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:      QBTREE.BAS%@AE@%%@NL@%
%@AB@%  '                 FILEINFO.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:     path       Path for starting directory search%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      path$      Path string, from the command line, or set%@AE@%%@NL@%
%@AB@%  '                            to "*.*"%@AE@%%@NL@%
%@AB@%  '                 indent%    Indention amount for printing%@AE@%%@NL@%
%@NL@%
%@NL@%
    TYPE RegTypeX%@NL@%
        ax    AS INTEGER%@NL@%
        bx    AS INTEGER%@NL@%
        cx    AS INTEGER%@NL@%
        dx    AS INTEGER%@NL@%
        bp    AS INTEGER%@NL@%
        si    AS INTEGER%@NL@%
        di    AS INTEGER%@NL@%
        flags AS INTEGER%@NL@%
        ds    AS INTEGER%@NL@%
        es    AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
    TYPE FileDataType%@NL@%
        finame    AS STRING * 12%@NL@%
        year      AS INTEGER%@NL@%
        month     AS INTEGER%@NL@%
        day       AS INTEGER%@NL@%
        hour      AS INTEGER%@NL@%
        minute    AS INTEGER%@NL@%
        second    AS INTEGER%@NL@%
        attribute AS INTEGER%@NL@%
        size      AS LONG%@NL@%
    END TYPE%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB INTERRUPTX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@NL@%
    DECLARE SUB FindFirstFile (path$, dta$, result%)%@NL@%
    DECLARE SUB FindNextFile (dta$, result%)%@NL@%
    DECLARE SUB GetFileData (dta$, file AS FileDataType)%@NL@%
    DECLARE SUB FileTreeSearch (path$, indent%)%@NL@%
%@NL@%
%@AB@%  ' Create structure for deciphering the DTA file search results%@AE@%%@NL@%
    DIM file AS FileDataType%@NL@%
%@NL@%
%@AB@%  ' Get the command line path for starting the file search%@AE@%%@NL@%
    path$ = COMMAND$%@NL@%
%@NL@%
%@AB@%  ' If no path was given, then use "*.*" to search the current directory%@AE@%%@NL@%
    IF path$ = "" THEN%@NL@%
        path$ = "*.*"%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' If only a drive was given, then add "*.*"%@AE@%%@NL@%
    IF LEN(path$) = 2 AND RIGHT$(path$, 1) = ":" THEN%@NL@%
        path$ = path$ + "*.*"%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Adjust the given path if necessary%@AE@%%@NL@%
    IF INSTR(path$, "*") = 0 AND INSTR(path$, "?") = 0 THEN%@NL@%
        FindFirstFile path$, dta$, result%%@NL@%
        IF result% = 0 OR RIGHT$(path$, 1) = "\" THEN%@NL@%
            IF RIGHT$(path$, 1) <> "\" THEN%@NL@%
                path$ = path$ + "\"%@NL@%
            END IF%@NL@%
            path$ = path$ + "*.*"%@NL@%
        END IF%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Start with a clean slate%@AE@%%@NL@%
    CLS%@NL@%
%@NL@%
%@AB@%  ' Call the recursive search subprogram%@AE@%%@NL@%
    FileTreeSearch path$, indent%%@NL@%
%@NL@%
%@AB@%  ' That's all there is to it%@AE@%%@NL@%
    END%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FileTreeSearch             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QBTREE.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Directory searching and listing subprogram for%@AE@%%@NL@%
%@AB@%  ' the QBTREE program.  (recursive)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  FileTreeSearch path$, indent%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      path$      Path for search of files%@AE@%%@NL@%
%@AB@%  '                  indent%    Level of indention, function of recursion%@AE@%%@NL@%
%@AB@%  '                             level%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       file       Structure of type FileDataType%@AE@%%@NL@%
%@AB@%  '                  path$      Path for search of files%@AE@%%@NL@%
%@AB@%  '                  dta$       Disk Transfer Area buffer string%@AE@%%@NL@%
%@AB@%  '                  result%    Returned result code from FindFirstFile or%@AE@%%@NL@%
%@AB@%  '                             FindNextFile%@AE@%%@NL@%
%@AB@%  '                  newPath$   Path with added subdirectory for recursive%@AE@%%@NL@%
%@AB@%  '                             search%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS: TYPE FileDataType%@AE@%%@NL@%
%@AB@%  '                     finame    AS STRING * 12%@AE@%%@NL@%
%@AB@%  '                     year      AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     month     AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     day       AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     hour      AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     minute    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     second    AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     attribute AS INTEGER%@AE@%%@NL@%
%@AB@%  '                     size      AS LONG%@AE@%%@NL@%
%@AB@%  '                  END TYPE%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB FindFirstFile (path$, dta$, result%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB FindNextFile (dta$, result%)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB GetFileData (dta$, file AS FileDataType)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB FileTreeSearch (path$, indent%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB FileTreeSearch (path$, indent%)%@NL@%
%@NL@%
%@AB@%      ' Create structure for deciphering the DTA file search results%@AE@%%@NL@%
        DIM file AS FileDataType%@NL@%
%@NL@%
%@AB@%      ' Find the first file given the current search path%@AE@%%@NL@%
        FindFirstFile path$, dta$, result%%@NL@%
%@NL@%
%@AB@%      ' Search through the directory for all files%@AE@%%@NL@%
        DO UNTIL result%%@NL@%
%@NL@%
%@AB@%          ' Unpack the Disk Transfer Area for file information%@AE@%%@NL@%
            GetFileData dta$, file%@NL@%
%@NL@%
%@AB@%          ' Skip the "." and ".." files%@AE@%%@NL@%
            IF LEFT$(file.finame, 1) <> "." THEN%@NL@%
%@NL@%
%@AB@%              ' Print the filename, indented to show tree structure%@AE@%%@NL@%
                PRINT SPACE$(indent% * 4); file.finame;%@NL@%
%@NL@%
%@AB@%              ' Print any other desired file information here%@AE@%%@NL@%
                PRINT TAB(50); file.size;%@NL@%
                PRINT TAB(58); file.attribute%@NL@%
%@NL@%
%@AB@%              ' If we found a directory, then recursively search through it%@AE@%%@NL@%
                IF file.attribute AND &H10 THEN%@NL@%
%@NL@%
%@AB@%                  ' Modify path$ to add this new directory to the search path%@AE@%%@NL@%
                    newPath$ = path$%@NL@%
                    IF INSTR(newPath$, "\") = 0 THEN%@NL@%
                        newPath$ = "\" + newPath$%@NL@%
                    END IF%@NL@%
                    DO WHILE RIGHT$(newPath$, 1) <> "\"%@NL@%
                        newPath$ = LEFT$(newPath$, LEN(newPath$) - 1)%@NL@%
                    LOOP%@NL@%
                    newPath$ = newPath$ + file.finame + "\*.*"%@NL@%
%@NL@%
%@AB@%                  ' Example of recursion here%@AE@%%@NL@%
                    FileTreeSearch newPath$, indent% + 1%@NL@%
%@NL@%
                END IF%@NL@%
%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Try to find the next file in this directory%@AE@%%@NL@%
            FindNextFile dta$, result%%@NL@%
%@NL@%
        LOOP%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%QCAL.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\QCAL.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          QCAL                       **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Program                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCAL.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           QCAL [number] [function] [...]%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       QCAL.BAS%@AE@%%@NL@%
%@AB@%  '                  QCALMATH.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      [number]      Numbers to be placed on the stack%@AE@%%@NL@%
%@AB@%  '                  [function]    Operations to be performed on the stack%@AE@%%@NL@%
%@AB@%  '                                contents%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       cmd$          Working copy of COMMAND$%@AE@%%@NL@%
%@AB@%  '                  stack#()      Array representing the numeric stack%@AE@%%@NL@%
%@AB@%  '                  ptr%          Index into the stack%@AE@%%@NL@%
%@AB@%  '                  parm$         Each number of command extracted from cmd$%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Constants%@AE@%%@NL@%
    CONST PI = 3.141592653589793#%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION AbsoluteX# (x#)%@NL@%
    DECLARE FUNCTION Add# (y#, x#)%@NL@%
    DECLARE FUNCTION ArcCosine# (x#)%@NL@%
    DECLARE FUNCTION ArcHypCosine# (x#)%@NL@%
    DECLARE FUNCTION ArcHypSine# (x#)%@NL@%
    DECLARE FUNCTION ArcHypTangent# (x#)%@NL@%
    DECLARE FUNCTION ArcSine# (x#)%@NL@%
    DECLARE FUNCTION ArcTangent# (x#)%@NL@%
    DECLARE FUNCTION Ceil# (x#)%@NL@%
    DECLARE FUNCTION ChangeSign# (x#)%@NL@%
    DECLARE FUNCTION Cosine# (x#)%@NL@%
    DECLARE FUNCTION Divide# (y#, x#)%@NL@%
    DECLARE FUNCTION Exponential# (x#)%@NL@%
    DECLARE FUNCTION FractionalPart# (x#)%@NL@%
    DECLARE FUNCTION HypCosine# (x#)%@NL@%
    DECLARE FUNCTION HypSine# (x#)%@NL@%
    DECLARE FUNCTION HypTangent# (x#)%@NL@%
    DECLARE FUNCTION IntegerPart# (x#)%@NL@%
    DECLARE FUNCTION LogBase10# (x#)%@NL@%
    DECLARE FUNCTION LogBaseN# (y#, x#)%@NL@%
    DECLARE FUNCTION LogE# (x#)%@NL@%
    DECLARE FUNCTION Modulus# (y#, x#)%@NL@%
    DECLARE FUNCTION Multiply# (y#, x#)%@NL@%
    DECLARE FUNCTION NextParameter$ (cmd$)%@NL@%
    DECLARE FUNCTION OneOverX# (x#)%@NL@%
    DECLARE FUNCTION Sign# (x#)%@NL@%
    DECLARE FUNCTION Sine# (x#)%@NL@%
    DECLARE FUNCTION SquareRoot# (x#)%@NL@%
    DECLARE FUNCTION Subtract# (y#, x#)%@NL@%
    DECLARE FUNCTION Tangent# (x#)%@NL@%
    DECLARE FUNCTION Xsquared# (x#)%@NL@%
    DECLARE FUNCTION YRaisedToX# (y#, x#)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB QcalHelp ()%@NL@%
    DECLARE SUB Process (parm$, stack#(), ptr%)%@NL@%
    DECLARE SUB DisplayStack (stack#(), ptr%)%@NL@%
    DECLARE SUB SwapXY (stack#(), ptr%)%@NL@%
%@NL@%
%@AB@%  ' Get the command line%@AE@%%@NL@%
    cmd$ = COMMAND$%@NL@%
%@NL@%
%@AB@%  ' First check if user is asking for help%@AE@%%@NL@%
    IF cmd$ = "" OR cmd$ = "HELP" OR cmd$ = "?" THEN%@NL@%
        QcalHelp%@NL@%
        SYSTEM%@NL@%
    END IF%@NL@%
%@NL@%
%@AB@%  ' Create a pseudo stack%@AE@%%@NL@%
    DIM stack#(1 TO 20)%@NL@%
    ptr% = 0%@NL@%
%@NL@%
%@AB@%  ' Process each part of the command line%@AE@%%@NL@%
    DO UNTIL cmd$ = ""%@NL@%
        parm$ = NextParameter$(cmd$)%@NL@%
        Process parm$, stack#(), ptr%%@NL@%
        IF ptr% < 1 THEN%@NL@%
            PRINT "Not enough stack values"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    LOOP%@NL@%
%@NL@%
%@AB@%  ' Display results%@AE@%%@NL@%
    DisplayStack stack#(), ptr%%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    END%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          DisplayStack               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCAL.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Displays the value(s) left on the stack when QCAL%@AE@%%@NL@%
%@AB@%  ' is finished processing the command line.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  DisplayStack stack#(), ptr%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      stack#()   Array of numbers representing the stack%@AE@%%@NL@%
%@AB@%  '                  ptr%       Index into the stack%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%         Looping index%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB DisplayStack (stack#(), ptr%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB DisplayStack (stack#(), ptr%) STATIC%@NL@%
        PRINT%@NL@%
        IF ptr% > 1 THEN%@NL@%
            PRINT "Stack ... ",%@NL@%
        ELSE%@NL@%
            PRINT "Result... ",%@NL@%
        END IF%@NL@%
        FOR i% = 1 TO ptr%%@NL@%
            PRINT stack#(i%),%@NL@%
        NEXT i%%@NL@%
        PRINT%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          NextParameter$             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCAL.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Extracts parameters from the front of the%@AE@%%@NL@%
%@AB@%  ' command line.  Parameters are groups of any%@AE@%%@NL@%
%@AB@%  ' characters separated by spaces.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  parm$ = NextParameter$(cmd$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      cmd$       The working copy of COMMAND$%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       parm$      Each number or command from cmd$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION NextParameter$ (cmd$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION NextParameter$ (cmd$) STATIC%@NL@%
        parm$ = ""%@NL@%
        DO WHILE LEFT$(cmd$, 1) <> " " AND cmd$ <> ""%@NL@%
            parm$ = parm$ + LEFT$(cmd$, 1)%@NL@%
            cmd$ = MID$(cmd$, 2)%@NL@%
        LOOP%@NL@%
        DO WHILE LEFT$(cmd$, 1) = " " AND cmd$ <> ""%@NL@%
            cmd$ = MID$(cmd$, 2)%@NL@%
        LOOP%@NL@%
        NextParameter$ = parm$%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Process                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCAL.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Processes each command parameter for the QCAL%@AE@%%@NL@%
%@AB@%  ' program.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Process parm$, stack#(), ptr%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      parm$      The command line parameter to be processed%@AE@%%@NL@%
%@AB@%  '                  stack#()   Array of numbers representing the stack%@AE@%%@NL@%
%@AB@%  '                  ptr%       Index pointing to last stack entry%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Process (parm$, stack#(), ptr%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Process (parm$, stack#(), ptr%) STATIC%@NL@%
        SELECT CASE parm$%@NL@%
        CASE "+"%@NL@%
            ptr% = ptr% - 1%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Add#(stack#(ptr%), stack#(ptr% + 1))%@NL@%
            END IF%@NL@%
        CASE "-"%@NL@%
            ptr% = ptr% - 1%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Subtract#(stack#(ptr%), stack#(ptr% + 1))%@NL@%
            END IF%@NL@%
        CASE "*"%@NL@%
            ptr% = ptr% - 1%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Multiply#(stack#(ptr%), stack#(ptr% + 1))%@NL@%
            END IF%@NL@%
        CASE "/"%@NL@%
            ptr% = ptr% - 1%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Divide#(stack#(ptr%), stack#(ptr% + 1))%@NL@%
            END IF%@NL@%
        CASE "CHS"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = ChangeSign#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "ABS"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = AbsoluteX#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "SGN"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Sign#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "INT"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = IntegerPart#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "MOD"%@NL@%
            ptr% = ptr% - 1%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Modulus#(stack#(ptr%), stack#(ptr% + 1))%@NL@%
            END IF%@NL@%
        CASE "FRC"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = FractionalPart#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "1/X"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = OneOverX#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "SQR"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = SquareRoot#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "X2"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Xsquared#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "SIN"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Sine#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "COS"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Cosine#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "TAN"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Tangent#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "ASN"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = ArcSine#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "ACS"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = ArcCosine#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "ATN"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = ArcTangent#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "HSN"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = HypSine#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "HCS"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = HypCosine#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "HTN"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = HypTangent#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "AHS"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = ArcHypSine#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "AHC"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = ArcHypCosine#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "AHT"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = ArcHypTangent#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "LOG"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = LogE#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "LOG10"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = LogBase10#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "LOGN"%@NL@%
            ptr% = ptr% - 1%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = LogBaseN#(stack#(ptr%), stack#(ptr% + 1))%@NL@%
            END IF%@NL@%
        CASE "EXP"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Exponential#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "CEIL"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = Ceil#(stack#(ptr%))%@NL@%
            END IF%@NL@%
        CASE "Y^X"%@NL@%
            ptr% = ptr% - 1%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr%) = YRaisedToX#(stack#(ptr%), stack#(ptr% + 1))%@NL@%
            END IF%@NL@%
        CASE "PI"%@NL@%
            ptr% = ptr% + 1%@NL@%
            stack#(ptr%) = PI%@NL@%
        CASE "SWAP"%@NL@%
            SwapXY stack#(), ptr%%@NL@%
        CASE "DUP"%@NL@%
            IF ptr% > 0 THEN%@NL@%
                stack#(ptr% + 1) = stack#(ptr%)%@NL@%
                ptr% = ptr% + 1%@NL@%
            END IF%@NL@%
        CASE ELSE%@NL@%
            ptr% = ptr% + 1%@NL@%
            stack#(ptr%) = VAL(parm$)%@NL@%
        END SELECT%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          QcalHelp                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCAL.BAS                   **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Displays a help screen when QCAL is run with no%@AE@%%@NL@%
%@AB@%  ' parameters or with a parameter of ? or HELP.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  QcalHelp%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB QcalHelp ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB QcalHelp STATIC%@NL@%
        PRINT%@NL@%
        PRINT "Usage:  QCAL [number] [function] [...] <Enter>"%@NL@%
        PRINT%@NL@%
        PRINT "Numbers are placed on an RPN stack, and functions operate"%@NL@%
        PRINT "on the stacked quantities.  When the program is finished,"%@NL@%
        PRINT "whatever is left on the stack is displayed."%@NL@%
        PRINT%@NL@%
        PRINT "List of available functions..."%@NL@%
        PRINT%@NL@%
        PRINT "Two numbers:     +  -  *  /"%@NL@%
        PRINT "One number:      CHS ABS SGN INT MOD FRC CHS 1/X SQR X2 CEIL"%@NL@%
        PRINT "Trigonometric:   SIN COS TAN ASN ACS ATN"%@NL@%
        PRINT "Hyperbolic:      HSN HCS HTN AHS AHC AHT"%@NL@%
        PRINT "Logarithmic:     LOG LOG10 LOGN EXP Y^X"%@NL@%
        PRINT "Constants:       PI"%@NL@%
        PRINT "Stack:           SWAP DUP"%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%QCALMATH.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\QCALMATH.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          QCALMATH                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Collection of math functions and subprograms for%@AE@%%@NL@%
%@AB@%  ' the QCAL program.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:         (loaded by the QCAL program)%@AE@%%@NL@%
%@AB@%  '.MAK FILE:      (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:    (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:     (none)%@AE@%%@NL@%
%@AB@%  ' Constants%@AE@%%@NL@%
    CONST PI = 3.141592653589793#%@NL@%
    CONST L10 = 2.302585092994046#%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION AbsoluteX# (x#)%@NL@%
    DECLARE FUNCTION Add# (y#, x#)%@NL@%
    DECLARE FUNCTION ArcCosine# (x#)%@NL@%
    DECLARE FUNCTION ArcHypCosine# (x#)%@NL@%
    DECLARE FUNCTION ArcHypSine# (x#)%@NL@%
    DECLARE FUNCTION ArcHypTangent# (x#)%@NL@%
    DECLARE FUNCTION ArcSine# (x#)%@NL@%
    DECLARE FUNCTION ArcTangent# (x#)%@NL@%
    DECLARE FUNCTION Ceil# (x#)%@NL@%
    DECLARE FUNCTION ChangeSign# (x#)%@NL@%
    DECLARE FUNCTION Cosine# (x#)%@NL@%
    DECLARE FUNCTION Divide# (y#, x#)%@NL@%
    DECLARE FUNCTION Exponential# (x#)%@NL@%
    DECLARE FUNCTION FractionalPart# (x#)%@NL@%
    DECLARE FUNCTION HypCosine# (x#)%@NL@%
    DECLARE FUNCTION HypSine# (x#)%@NL@%
    DECLARE FUNCTION HypTangent# (x#)%@NL@%
    DECLARE FUNCTION IntegerPart# (x#)%@NL@%
    DECLARE FUNCTION LogBase10# (x#)%@NL@%
    DECLARE FUNCTION LogBaseN# (y#, x#)%@NL@%
    DECLARE FUNCTION LogE# (x#)%@NL@%
    DECLARE FUNCTION Modulus# (y#, x#)%@NL@%
    DECLARE FUNCTION Multiply# (y#, x#)%@NL@%
    DECLARE FUNCTION OneOverX# (x#)%@NL@%
    DECLARE FUNCTION Sign# (x#)%@NL@%
    DECLARE FUNCTION Sine# (x#)%@NL@%
    DECLARE FUNCTION SquareRoot# (x#)%@NL@%
    DECLARE FUNCTION Subtract# (y#, x#)%@NL@%
    DECLARE FUNCTION Tangent# (x#)%@NL@%
    DECLARE FUNCTION Xsquared# (x#)%@NL@%
    DECLARE FUNCTION YRaisedToX# (y#, x#)%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          AbsoluteX#                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = AbsoluteX#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Double-precision value to be evaluated%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION AbsoluteX# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION AbsoluteX# (x#) STATIC%@NL@%
        AbsoluteX# = ABS(x#)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Add#                       **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  z# = Add#(y#, x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      y#         First number%@AE@%%@NL@%
%@AB@%  '                  x#         Second number%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Add# (y#, x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Add# (y#, x#) STATIC%@NL@%
        Add# = y# + x#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ArcCosine#                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = ArcCosine#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be evaluated%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION ArcCosine# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION ArcCosine# (x#) STATIC%@NL@%
        x2# = x# * x#%@NL@%
        IF x2# < 1# THEN%@NL@%
            ArcCosine# = PI / 2# - ATN(x# / SQR(1# - x# * x#))%@NL@%
        ELSE%@NL@%
            PRINT "Error: ACS(x#) where x# < 1"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ArcHypCosine#              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = ArcHypCosine#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be evaluated%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION ArcHypCosine# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION ArcHypCosine# (x#) STATIC%@NL@%
        IF ABS(x#) > 1# THEN%@NL@%
            ArcHypCosine# = LOG(x# + SQR(x# * x# - 1#))%@NL@%
        ELSE%@NL@%
            PRINT "Error: AHS(x#) where -1 <= x# <= +1"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ArcHypSine#                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = ArcHypSine#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#    Number to be evaluated%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION AryHypSine# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION ArcHypSine# (x#) STATIC%@NL@%
        ArcHypSine# = LOG(x# + SQR(1# + x# * x#))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ArcHypTangent#             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = ArcHypTangent#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be evaluated%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION ArcHypTangent# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION ArcHypTangent# (x#) STATIC%@NL@%
        IF ABS(x#) < 1 THEN%@NL@%
            ArcHypTangent# = LOG((1# + x#) / (1# - x#)) / 2#%@NL@%
        ELSE%@NL@%
            PRINT "Error: AHT(x#) where x# <= -1 or x# >= +1"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ArcSine#                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = ArcSine#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be evaluated%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION ArcSine# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION ArcSine# (x#) STATIC%@NL@%
        x2# = x# * x#%@NL@%
        IF x2# < 1# THEN%@NL@%
            ArcSine# = ATN(x# / SQR(1# - x# * x#))%@NL@%
        ELSE%@NL@%
            PRINT "Error: ASN(x#) where x# >= 1"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ArcTangent#                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = ArcTangent#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be evaluated%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION ArcTangent# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION ArcTangent# (x#) STATIC%@NL@%
        ArcTangent# = ATN(x#)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Ceil#                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = Ceil#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be evaluated%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Ceil# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Ceil# (x#) STATIC%@NL@%
        Ceil# = -INT(-x#)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ChangeSign#                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = ChangeSign#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be evaluated%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION ChangeSign# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION ChangeSign# (x#) STATIC%@NL@%
        ChangeSign# = -x#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Cosine#                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = Cosine#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Angle to be evaluated%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Cosine# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Cosine# (x#) STATIC%@NL@%
        Cosine# = COS(x#)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Divide#                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = Divide#(y#, x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      y#         Number to be processed%@AE@%%@NL@%
%@AB@%  '                  x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Divide# (y#, x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Divide# (y#, x#) STATIC%@NL@%
        IF x# <> 0 THEN%@NL@%
            Divide# = y# / x#%@NL@%
        ELSE%@NL@%
            PRINT "Error: Division by zero"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Dup                        **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Dup stack#(), ptr%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      stack#()   Numeric stack%@AE@%%@NL@%
%@AB@%  '                  ptr%       Index to last entry on stack%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Dup (Stack#(), ptr%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Dup (stack#(), ptr%) STATIC%@NL@%
        IF ptr% THEN%@NL@%
            ptr% = ptr% + 1%@NL@%
            stack#(ptr%) = stack#(ptr% - 1)%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Exponential#               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = Exponential#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Exponential# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Exponential# (x#) STATIC%@NL@%
        Exponential# = EXP(x#)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FractionalPart#            **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = FractionalPart#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION FractionalPart# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION FractionalPart# (x#) STATIC%@NL@%
        IF x# >= 0 THEN%@NL@%
            FractionalPart# = x# - INT(x#)%@NL@%
        ELSE%@NL@%
            FractionalPart# = x# - INT(x#) - 1#%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          HypCosine#                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = HypCosine#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION HypCosine# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION HypCosine# (x#) STATIC%@NL@%
        HypCosine# = (EXP(x#) + EXP(-x#)) / 2#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          HypSine#                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = HypSine#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION HypSine# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION HypSine# (x#) STATIC%@NL@%
        HypSine# = (EXP(x#) - EXP(-x#)) / 2#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          HypTangent#                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = HypTangent#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION HypTangent# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION HypTangent# (x#) STATIC%@NL@%
        HypTangent# = (EXP(x#) - EXP(-x#)) / (EXP(x#) + EXP(-x#))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          IntegerPart#               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = IntegerPart#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION IntegerPart# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION IntegerPart# (x#) STATIC%@NL@%
        IntegerPart# = INT(x#)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          LogBase10#                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = Log10#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION LogBase10# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION LogBase10# (x#) STATIC%@NL@%
        IF x# > 0 THEN%@NL@%
            LogBase10# = LOG(x#) / L10%@NL@%
        ELSE%@NL@%
            PRINT "Error: LOG10(x#) where x# <= 0"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          LogBaseN#                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = LogBaseN#(y#, x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      y#         Number to be processed%@AE@%%@NL@%
%@AB@%  '                  x#         The base for finding the logarithm%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION LogBaseN# (y#, x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION LogBaseN# (y#, x#) STATIC%@NL@%
        IF x# <= 0 THEN%@NL@%
            PRINT "Error: LOGN(y#, x#) where x# <= 0"%@NL@%
            SYSTEM%@NL@%
        ELSEIF x# = 1# THEN%@NL@%
            PRINT "Error: LOGN(y#, x#) where x# = 1"%@NL@%
            SYSTEM%@NL@%
        ELSEIF y# <= 0 THEN%@NL@%
            PRINT "Error: LOGN(y#, x#) where y# is <= 0"%@NL@%
            SYSTEM%@NL@%
        ELSE%@NL@%
            LogBaseN# = LOG(y#) / LOG(x#)%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          LogE#                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = LogE#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION LogE# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION LogE# (x#) STATIC%@NL@%
        IF x# > 0 THEN%@NL@%
            LogE# = LOG(x#)%@NL@%
        ELSE%@NL@%
            PRINT "Error: LOGE(x#) where x# <= 0"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Modulus#                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = Modulus#(y#, x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      y#         Number to be divided%@AE@%%@NL@%
%@AB@%  '                  x#         Number for dividing by%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Modulus# (y#, x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Modulus# (y#, x#) STATIC%@NL@%
        IF x# <> 0 THEN%@NL@%
            Modulus# = y# - INT(y# / x#) * x#%@NL@%
        ELSE%@NL@%
            PRINT "Error: MOD(y#, x#) where x# = 0"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Multiply#                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = Multiply#(y#, x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      y#         First number to be processed%@AE@%%@NL@%
%@AB@%  '                  x#         Second number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Multiply# (y#, x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Multiply# (y#, x#) STATIC%@NL@%
        Multiply# = y# * x#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          OneOverX#                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = OneOverX#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION OneOverX# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION OneOverX# (x#) STATIC%@NL@%
        IF x# <> 0 THEN%@NL@%
            OneOverX# = 1# / x#%@NL@%
        ELSE%@NL@%
            PRINT "Error: 1/x where x = 0"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Sign#                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = Sign#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Sign# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Sign# (x#) STATIC%@NL@%
        Sign# = SGN(x#)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Sine#                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = Sine#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Angle, expressed in radians%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Sine# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Sine# (x#) STATIC%@NL@%
        Sine# = SIN(x#)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          SquareRoot#                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = SquareRoot#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION SquareRoot# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION SquareRoot# (x#) STATIC%@NL@%
        IF x# >= 0 THEN%@NL@%
            SquareRoot# = SQR(x#)%@NL@%
        ELSE%@NL@%
            PRINT "Error: SQR(x#) where x# < 0"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Subtract#                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:   y# = Subtract#(y#, x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:       y#         Number to be processed%@AE@%%@NL@%
%@AB@%  '                   x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:        (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:   DECLARE FUNCTION Subtract# (y#, x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Subtract# (y#, x#) STATIC%@NL@%
        Subtract# = y# - x#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          SwapXY                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  SwapXY stack#(), ptr%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      stack#()   Numeric stack%@AE@%%@NL@%
%@AB@%  '                  ptr%       Pointer to top of stack%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB SwapXY (stack#(), ptr%%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB SwapXY (stack#(), ptr%) STATIC%@NL@%
        IF ptr% > 1 THEN%@NL@%
            SWAP stack#(ptr%), stack#(ptr% - 1)%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Tangent#                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = Tangent#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Angle, expressed in radians%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Tangent# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Tangent# (x#) STATIC%@NL@%
        Tangent# = TAN(x#)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Xsquared#                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  y# = Xsquared#(x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x#         Number to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Xsquared# (x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Xsquared# (x#) STATIC%@NL@%
        Xsquared# = x# * x#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          YRaisedToX#                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        QCALMATH.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  z# = YRaisedToX#(y#, x#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      y#         Number to be raised to a power%@AE@%%@NL@%
%@AB@%  '                  x#         Power to raise the other number to%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION YRaisedToX# (y#, x#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION YRaisedToX# (y#, x#) STATIC%@NL@%
        YRaisedToX# = y# ^ x#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%QLBDUMP.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\QLBDUMP.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' This program prints the names of QuickLibrary procedures%@AE@%%@NL@%
%@NL@%
DECLARE SUB DumpSym (SymStart AS INTEGER, QHdrPos AS LONG)%@NL@%
%@NL@%
TYPE ExeHdr                  ' Part of DOS .EXE header%@NL@%
    other1    AS STRING * 8  ' Other header information%@NL@%
    CParHdr   AS INTEGER     ' Size of header in paragraphs%@NL@%
    other2    AS STRING * 10 ' Other header information%@NL@%
    IP        AS INTEGER     ' Initial IP value%@NL@%
    CS        AS INTEGER     ' Initial (relative) CS value%@NL@%
END TYPE%@NL@%
%@NL@%
TYPE QBHdr                   ' QLB header%@NL@%
    QBHead    AS STRING * 6  ' QB specific heading%@NL@%
    Magic     AS INTEGER     ' Magic word: identifies file as%@NL@%
%@AB@%                             ' a Quick library%@AE@%%@NL@%
    SymStart  AS INTEGER     ' Offset from header to first code symbol%@NL@%
    DatStart  AS INTEGER     ' Offset from header to first data symbol%@NL@%
END TYPE%@NL@%
%@NL@%
TYPE QbSym                   ' QuickLib symbol entry%@NL@%
    Flags     AS INTEGER     ' Symbol flags%@NL@%
    NameStart AS INTEGER     ' Offset into name table%@NL@%
    other     AS STRING * 4  ' Other header info%@NL@%
END TYPE%@NL@%
%@NL@%
DIM EHdr AS ExeHdr, Qhdr AS QBHdr, QHdrPos AS LONG%@NL@%
%@NL@%
INPUT "Enter QuickLibrary file name: ", FileName$%@NL@%
FileName$ = UCASE$(FileName$)%@NL@%
IF INSTR(FileName$, ".QLB") = 0 THEN FileName$ = FileName$ + ".QLB"%@NL@%
%@NL@%
INPUT "Enter output file name or press ENTER for screen: ", OutFile$%@NL@%
OutFile$ = UCASE$(OutFile$)%@NL@%
IF OutFile$ = "" THEN OutFile$ = "CON"%@NL@%
%@NL@%
OPEN FileName$ FOR BINARY AS #1%@NL@%
OPEN OutFile$ FOR OUTPUT AS #2%@NL@%
%@NL@%
GET #1, , EHdr               ' Read the EXE format header.%@NL@%
%@NL@%
QHdrPos = (EHdr.CParHdr + EHdr.CS) * 16 + EHdr.IP + 1%@NL@%
%@NL@%
GET #1, QHdrPos, Qhdr        ' Read the QuickLib format header.%@NL@%
%@NL@%
IF Qhdr.Magic <> &H6C75 THEN PRINT "Not a QB UserLibrary": END%@NL@%
%@NL@%
PRINT #2, "Code Symbols:": PRINT #2,%@NL@%
DumpSym Qhdr.SymStart, QHdrPos ' dump code symbols%@NL@%
PRINT #2,%@NL@%
%@NL@%
PRINT #2, "Data Symbols:": PRINT #2, ""%@NL@%
DumpSym Qhdr.DatStart, QHdrPos ' dump data symbols%@NL@%
PRINT #2,%@NL@%
%@NL@%
END%@NL@%
%@NL@%
SUB DumpSym (SymStart AS INTEGER, QHdrPos AS LONG)%@NL@%
   DIM QlbSym AS QbSym%@NL@%
   DIM NextSym AS LONG, CurrentSym AS LONG%@NL@%
%@NL@%
%@AB@%   ' Calculate the location of the first symbol entry, then read that entry:%@AE@%%@NL@%
   NextSym = QHdrPos + SymStart%@NL@%
   GET #1, NextSym, QlbSym%@NL@%
%@NL@%
   DO%@NL@%
      NextSym = SEEK(1)          ' Save the location of the next%@NL@%
%@AB@%                                 ' symbol.%@AE@%%@NL@%
      CurrentSym = QHdrPos + QlbSym.NameStart%@NL@%
      SEEK #1, CurrentSym        ' Use SEEK to move to the name%@NL@%
%@AB@%                                 ' for the current symbol entry.%@AE@%%@NL@%
      Prospect$ = INPUT$(40, 1)  ' Read the longest legal string,%@NL@%
%@AB@%                                 ' plus one additonal byte for the%@AE@%%@NL@%
%@AB@%                                 ' final null character (CHR$(0)).%@AE@%%@NL@%
%@NL@%
%@AB@%      ' Extract the null-terminated name:%@AE@%%@NL@%
      SName$ = LEFT$(Prospect$, INSTR(Prospect$, CHR$(0)))%@NL@%
%@NL@%
%@AB@%      ' Print only those names that do not begin with "__", "$", or "b$"%@AE@%%@NL@%
%@AB@%      ' as these names are usually considered reserved:%@AE@%%@NL@%
      IF LEFT$(SName$, 2) <> "__" AND LEFT$(SName$, 1) <> "$" AND UCASE$(LEFT$(SName$, 2)) <> "B$" THEN%@NL@%
         PRINT #2, "  " + SName$%@NL@%
      END IF%@NL@%
%@NL@%
      GET #1, NextSym, QlbSym    ' Read a symbol entry.%@NL@%
   LOOP WHILE QlbSym.Flags       ' Flags=0 (false) means end of table.%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%RANDOMS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\RANDOMS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          RANDOMS                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        RANDOMS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%      Loop index for generating pseudorandom numbers%@AE@%%@NL@%
%@NL@%
    DECLARE FUNCTION Rand& ()%@NL@%
    DECLARE FUNCTION RandExponential! (mean!)%@NL@%
    DECLARE FUNCTION RandFrac! ()%@NL@%
    DECLARE FUNCTION RandInteger% (a%, b%)%@NL@%
    DECLARE FUNCTION RandNormal! (mean!, stddev!)%@NL@%
    DECLARE FUNCTION RandReal! (x!, y!)%@NL@%
%@NL@%
    DECLARE SUB RandShuffle (key$)%@NL@%
%@NL@%
%@AB@%  ' Array of long integers for generating all randoms%@AE@%%@NL@%
    DIM SHARED r&(1 TO 100)%@NL@%
%@NL@%
%@AB@%  ' Clear the screen%@AE@%%@NL@%
    CLS%@NL@%
%@NL@%
%@AB@%  ' Shuffle the random number generator, creating a%@AE@%%@NL@%
%@AB@%  ' unique sequence for every possible second%@AE@%%@NL@%
    RandShuffle DATE$ + TIME$%@NL@%
%@NL@%
    PRINT "Rand&"%@NL@%
    FOR i% = 1 TO 5%@NL@%
        PRINT Rand&,%@NL@%
    NEXT i%%@NL@%
    PRINT%@NL@%
%@NL@%
    PRINT "RandInteger%(0, 9)"%@NL@%
    FOR i% = 1 TO 5%@NL@%
        PRINT RandInteger%(0, 9),%@NL@%
    NEXT i%%@NL@%
    PRINT%@NL@%
%@NL@%
    PRINT "RandReal!(-10!, 10!)"%@NL@%
    FOR i% = 1 TO 5%@NL@%
        PRINT RandReal!(-10!, 10!),%@NL@%
    NEXT i%%@NL@%
    PRINT%@NL@%
%@NL@%
    PRINT "RandExponential!(100!)"%@NL@%
    FOR i% = 1 TO 5%@NL@%
        PRINT RandExponential!(100!),%@NL@%
    NEXT i%%@NL@%
    PRINT%@NL@%
%@NL@%
    PRINT "RandNormal!(100!, 10!)"%@NL@%
    FOR i% = 1 TO 5%@NL@%
        PRINT RandNormal!(100!, 10!),%@NL@%
    NEXT i%%@NL@%
    PRINT%@NL@%
%@NL@%
    PRINT "RandFrac!"%@NL@%
    FOR i% = 1 TO 5%@NL@%
        PRINT RandFrac!,%@NL@%
    NEXT i%%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Rand&                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        RANDOMS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a pseudorandom long integer in the range%@AE@%%@NL@%
%@AB@%  ' 0 through 999999999.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  n& = Rand&%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%         First index into random number table%@AE@%%@NL@%
%@AB@%  '                  j%         Second index into random number table%@AE@%%@NL@%
%@AB@%  '                  t&         Working variable%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Rand& ()%@AE@%%@NL@%
%@AB@%  '                  DIM SHARED r&(1 TO 100)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Rand& STATIC%@NL@%
%@NL@%
%@AB@%      ' Get the pointers into the table%@AE@%%@NL@%
        i% = r&(98)%@NL@%
        j% = r&(99)%@NL@%
%@NL@%
%@AB@%      ' Subtract the two table values%@AE@%%@NL@%
        t& = r&(i%) - r&(j%)%@NL@%
%@NL@%
%@AB@%      ' Adjust result if less than zero%@AE@%%@NL@%
        IF t& < 0 THEN%@NL@%
            t& = t& + 1000000000%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Replace table entry with new random number%@AE@%%@NL@%
        r&(i%) = t&%@NL@%
%@NL@%
%@AB@%      ' Decrement first index, keeping in range 1 through 55%@AE@%%@NL@%
        IF i% > 1 THEN%@NL@%
            r&(98) = i% - 1%@NL@%
        ELSE%@NL@%
            r&(98) = 55%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Decrement second index, keeping in range 1 through 55%@AE@%%@NL@%
        IF j% > 1 THEN%@NL@%
            r&(99) = j% - 1%@NL@%
        ELSE%@NL@%
            r&(99) = 55%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Use last random number to index into shuffle table%@AE@%%@NL@%
        i% = r&(100) MOD 42 + 56%@NL@%
%@NL@%
%@AB@%      ' Grab random from table as current random number%@AE@%%@NL@%
        r&(100) = r&(i%)%@NL@%
%@NL@%
%@AB@%      ' Put new calculated random into table%@AE@%%@NL@%
        r&(i%) = t&%@NL@%
%@NL@%
%@AB@%      ' Return the random number grabbed from the table%@AE@%%@NL@%
        Rand& = r&(100)%@NL@%
%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          RandExponential!           **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        RANDOMS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns an exponentially distributed pseudorandom,%@AE@%%@NL@%
%@AB@%  ' single-precision number given the mean of the%@AE@%%@NL@%
%@AB@%  ' distribution.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  x! = RandExponential!(mean!)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mean!          The mean of the exponential distribution%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION RandExponential! (mean!)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION RandExponential! (mean!) STATIC%@NL@%
        RandExponential! = -mean! * LOG(RandFrac!)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          RandFrac!                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        RANDOMS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a pseudorandom, single-precision number%@AE@%%@NL@%
%@AB@%  ' in the range 0 through 1.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  x! = RandFrac!%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION RandFrac! ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION RandFrac! STATIC%@NL@%
        RandFrac! = Rand& / 1E+09%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          RandInteger%               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        RANDOMS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a pseudorandom integer in the range%@AE@%%@NL@%
%@AB@%  ' a% to b% inclusive.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  n% = RandInteger%(a%, b%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a%           Minimum value for returned integer%@AE@%%@NL@%
%@AB@%  '                  b%           Maximum value for returned integer%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION RandInteger% (a%, b%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION RandInteger% (a%, b%) STATIC%@NL@%
        RandInteger% = a% + (Rand& MOD (b% - a% + 1))%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          RandNormal!                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        RANDOMS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a normally distributed single-precision,%@AE@%%@NL@%
%@AB@%  ' pseudorandom number given the mean and standard deviation.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  x! = RandNormal!(mean!, stddev!)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      mean!           Mean of the distribution of returned%@AE@%%@NL@%
%@AB@%  '                                  values%@AE@%%@NL@%
%@AB@%  '                  stddev!         Standard deviation of the distribution%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       u1!             Pseudorandom positive real value%@AE@%%@NL@%
%@AB@%  '                                  less than 1%@AE@%%@NL@%
%@AB@%  '                  u2!             Pseudorandom positive real value%@AE@%%@NL@%
%@AB@%  '                                  less than 1%@AE@%%@NL@%
%@AB@%  '                  x!              Working value%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION RandNormal! (mean!, stddev!)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION RandNormal! (mean!, stddev!) STATIC%@NL@%
        u1! = RandFrac!%@NL@%
        u2! = RandFrac!%@NL@%
        x! = SQR(-2! * LOG(u1!)) * COS(6.283185 * u2)%@NL@%
        RandNormal! = mean! + stddev! * x!%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          RandReal!                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        RANDOMS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a pseudorandom, single-precision real%@AE@%%@NL@%
%@AB@%  ' number in the range x! to y!.%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  z! = RandReal!(x!, y!)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      x!           Minimum for returned value%@AE@%%@NL@%
%@AB@%  '                  y!           Maximum for returned value%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION RandReal! (x!, y!)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION RandReal! (x!, y!) STATIC%@NL@%
        RandReal! = x! + (y! - x!) * (Rand& / 1E+09)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          RandShuffle                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        RANDOMS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Creates original table of pseudorandom long integers%@AE@%%@NL@%
%@AB@%  ' for use by the function Rand&.  The contents of key$%@AE@%%@NL@%
%@AB@%  ' are used to seed the table.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  RandShuffle(key$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      key$            String used to seed the generator%@AE@%%@NL@%
%@AB@%  '          r&(1 TO 100) (shared)   Array of long integers for%@AE@%%@NL@%
%@AB@%  '                                  generating pseudorandom numbers%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       k$              Modified key string%@AE@%%@NL@%
%@AB@%  '                  i%              Index into k$, index into table%@AE@%%@NL@%
%@AB@%  '                  j%              Index into table%@AE@%%@NL@%
%@AB@%  '                  k%              Loop count for warming up generator%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB RandShuffle (key$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB RandShuffle (key$) STATIC%@NL@%
%@NL@%
%@AB@%      ' Form 97-character string, with key$ as part of it%@AE@%%@NL@%
        k$ = LEFT$("Abra Ca Da Bra" + key$ + SPACE$(83), 97)%@NL@%
%@NL@%
%@AB@%      ' Use each character to seed table%@AE@%%@NL@%
        FOR i% = 1 TO 97%@NL@%
            r&(i%) = ASC(MID$(k$, i%, 1)) * 8171717 + i% * 997&%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' Preserve string space%@AE@%%@NL@%
        k$ = ""%@NL@%
%@NL@%
%@AB@%      ' Initialize pointers into table%@AE@%%@NL@%
        i% = 97%@NL@%
        j% = 12%@NL@%
%@NL@%
%@AB@%      ' Randomize the table to get it warmed up%@AE@%%@NL@%
        FOR k% = 1 TO 997%@NL@%
%@NL@%
%@AB@%          ' Subtract entries pointed to by i% and j%%@AE@%%@NL@%
            r&(i%) = r&(i%) - r&(j%)%@NL@%
%@NL@%
%@AB@%          ' Adjust result if less than zero%@AE@%%@NL@%
            IF r&(i%) < 0 THEN%@NL@%
                r&(i%) = r&(i%) + 1000000000%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Decrement first index, keeping in range of 1 through 97%@AE@%%@NL@%
            IF i% > 1 THEN%@NL@%
                i% = i% - 1%@NL@%
            ELSE%@NL@%
                i% = 97%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Decrement second index, keeping in range of 1 through 97%@AE@%%@NL@%
            IF j% > 1 THEN%@NL@%
                j% = j% - 1%@NL@%
            ELSE%@NL@%
                j% = 97%@NL@%
            END IF%@NL@%
%@NL@%
        NEXT k%%@NL@%
%@NL@%
%@AB@%      ' Initialize pointers for use by Rand& function%@AE@%%@NL@%
        r&(98) = 55%@NL@%
        r&(99) = 24%@NL@%
%@NL@%
%@AB@%      ' Initialize pointer for shuffle table lookup by Rand& function%@AE@%%@NL@%
        r&(100) = 77%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SEARCH.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\SEARCH.BAS%@AE@%%@NL@%
%@NL@%
DEFLNG A-Z              ' Default variable type is long integer.%@NL@%
LINE INPUT "File to search: ", FileName$%@NL@%
LINE INPUT "Pattern to search for: ", Pattern$%@NL@%
OPEN FileName$ FOR BINARY AS #1%@NL@%
%@NL@%
CONST PACKETSIZE = 10000, TRUE = -1%@NL@%
PatternLength% = LEN(Pattern$)%@NL@%
FileLength = LOF(1)%@NL@%
BytesLeft = FileLength%@NL@%
FileOffset = 0%@NL@%
%@NL@%
%@AB@%' Keep searching as long as there are enough bytes left in%@AE@%%@NL@%
%@AB@%' the file to contain the pattern you're searching for:%@AE@%%@NL@%
DO WHILE BytesLeft > PatternLength%%@NL@%
%@NL@%
%@AB@%   ' Read either 10,000 bytes or the number of bytes left in the file,%@AE@%%@NL@%
%@AB@%   ' whichever is smaller, then store them in Buffer$. (If the number%@AE@%%@NL@%
%@AB@%   ' of bytes left is less than PACKETSIZE, the following statement%@AE@%%@NL@%
%@AB@%   ' still reads just the remaining bytes, since binary I/O doesn't%@AE@%%@NL@%
%@AB@%   ' give "read past end" errors):%@AE@%%@NL@%
   Buffer$ = INPUT$(PACKETSIZE, #1)%@NL@%
%@NL@%
%@AB@%   ' Find every occurrence of the pattern in Buffer$:%@AE@%%@NL@%
   Start% = 1%@NL@%
   DO%@NL@%
      StringPos% = INSTR(Start%, Buffer$, Pattern$)%@NL@%
      IF StringPos% > 0 THEN%@NL@%
%@NL@%
%@AB@%         ' Found the pattern, so print the byte position in the file%@AE@%%@NL@%
%@AB@%         ' where the pattern starts:%@AE@%%@NL@%
         PRINT "Found pattern at byte number";%@NL@%
         PRINT FileOffset + StringPos%%@NL@%
         Start% = StringPos% + 1%@NL@%
         FoundIt% = TRUE%@NL@%
      END IF%@NL@%
   LOOP WHILE StringPos% > 0%@NL@%
%@NL@%
%@AB@%   ' Find the byte position where the next I/O operation would take place,%@AE@%%@NL@%
%@AB@%   ' then back up the file pointer a distance equal to the length of the%@AE@%%@NL@%
%@AB@%   ' pattern (in case the pattern straddles a 10,000-byte boundary):%@AE@%%@NL@%
   FileOffset = SEEK(1) - PatternLength%%@NL@%
   SEEK #1, FileOffset + 1%@NL@%
%@NL@%
   BytesLeft = FileLength - FileOffset%@NL@%
LOOP%@NL@%
%@NL@%
CLOSE #1%@NL@%
%@NL@%
IF NOT FoundIt% THEN PRINT "Pattern not found."%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%SINEWAVE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\SINEWAVE.BAS%@AE@%%@NL@%
%@NL@%
SCREEN 2%@NL@%
%@NL@%
%@AB@%' View port sized to proper scale for graph:%@AE@%%@NL@%
VIEW (20, 2)-(620, 172), , 1%@NL@%
%@NL@%
CONST PI = 3.141592653589#%@NL@%
%@NL@%
%@AB@%' Make window large enough to graph sine wave from%@AE@%%@NL@%
%@AB@%' 0 radians to 2 radians:%@AE@%%@NL@%
WINDOW (0, -1.1)-(2 * PI, 1.1)%@NL@%
%@NL@%
Style% = &HFF00                 ' Use to make dashed line.%@NL@%
%@NL@%
VIEW PRINT 23 TO 24             ' Scroll printed output in%@NL@%
%@AB@%                                ' rows 23 and 24.%@AE@%%@NL@%
DO%@NL@%
   PRINT TAB(20);%@NL@%
   INPUT "Number of cycles (0 to end): ", Cycles%@NL@%
   CLS%@NL@%
   LINE (2 * PI, 0)-(0, 0), , , Style%  ' Draw the x (horizontal) axis.%@NL@%
   IF Cycles > 0 THEN%@NL@%
%@AB@%      ' Start at (0,0) and plot the graph:%@AE@%%@NL@%
      FOR X = 0 TO 2 * PI STEP .01%@NL@%
         Y = SIN(Cycles * X)    ' Calculate the y coordinate.%@NL@%
         LINE -(X, Y)           ' Draw a line from the last%@NL@%
%@AB@%                                ' point to the new point.%@AE@%%@NL@%
      NEXT X%@NL@%
   END IF%@NL@%
LOOP WHILE Cycles > 0%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%STDOUT.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\STDOUT.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          STDOUT                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:            No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:     MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  '                   ANSI.SYS%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:        (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:       (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:        t0         Timer variable%@AE@%%@NL@%
%@AB@%  '                   bell$      ASCII character 7 (bell)%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Attribute definitions%@AE@%%@NL@%
    CONST NORMAL = 0%@NL@%
    CONST BRIGHT = 1%@NL@%
    CONST UNDERSCORE = 4%@NL@%
    CONST BLINK = 5%@NL@%
    CONST REVERSE = 7%@NL@%
    CONST INVISIBLE = 8%@NL@%
    CONST BLACKFOREGROUND = 30%@NL@%
    CONST REDFOREGROUND = 31%@NL@%
    CONST GREENFOREGROUND = 32%@NL@%
    CONST YELLOWFOREGROUND = 33%@NL@%
    CONST BLUEFOREGROUND = 34%@NL@%
    CONST MAGENTAFOREGROUND = 35%@NL@%
    CONST CYANFOREGROUND = 36%@NL@%
    CONST WHITEFOREGROUND = 37%@NL@%
    CONST BLACKBACKGROUND = 40%@NL@%
    CONST REDBACKGROUND = 41%@NL@%
    CONST GREENBACKGROUND = 42%@NL@%
    CONST YELLOWBACKGROUND = 43%@NL@%
    CONST BLUEBACKGROUND = 44%@NL@%
    CONST MAGENTABACKGROUND = 45%@NL@%
    CONST CYANBACKGROUND = 46%@NL@%
    CONST WHITEBACKGROUND = 47%@NL@%
%@NL@%
    TYPE RegTypeX%@NL@%
        ax    AS INTEGER%@NL@%
        bx    AS INTEGER%@NL@%
        cx    AS INTEGER%@NL@%
        dx    AS INTEGER%@NL@%
        Bp    AS INTEGER%@NL@%
        si    AS INTEGER%@NL@%
        di    AS INTEGER%@NL@%
        flags AS INTEGER%@NL@%
        ds    AS INTEGER%@NL@%
        es    AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX, outreg AS RegTypeX)%@NL@%
    DECLARE SUB ClearLine ()%@NL@%
    DECLARE SUB ClearScreen ()%@NL@%
    DECLARE SUB StdOut (a$)%@NL@%
    DECLARE SUB CrLf ()%@NL@%
    DECLARE SUB CursorPosition (row%, col%)%@NL@%
    DECLARE SUB CursorDown (n%)%@NL@%
    DECLARE SUB CursorLeft (n%)%@NL@%
    DECLARE SUB CursorRight (n%)%@NL@%
    DECLARE SUB CursorUp (n%)%@NL@%
    DECLARE SUB AssignKey (keyCode%, assign$)%@NL@%
    DECLARE SUB Attribute (attr%)%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the ClearLine and ClearScreen routines%@AE@%%@NL@%
    CLS%@NL@%
    PRINT "This will be erased quickly, in two steps..."%@NL@%
    t0 = TIMER%@NL@%
    DO%@NL@%
    LOOP UNTIL TIMER - t0 > 2%@NL@%
    LOCATE 1, 27%@NL@%
    ClearLine%@NL@%
    t0 = TIMER%@NL@%
    DO%@NL@%
    LOOP UNTIL TIMER - t0 > 2%@NL@%
    LOCATE 15, 1%@NL@%
    ClearScreen%@NL@%
%@NL@%
%@AB@%  ' Demonstrate the StdOut routine%@AE@%%@NL@%
    bell$ = CHR$(7)%@NL@%
    StdOut "Sending a 'Bell' to StdOut" + bell$%@NL@%
    CrLf%@NL@%
%@NL@%
%@AB@%  ' Set cursor position%@AE@%%@NL@%
    CursorPosition 3, 20%@NL@%
    StdOut "* CursorPosition 3, 20"%@NL@%
    CrLf%@NL@%
%@NL@%
%@AB@%  ' Move the cursor around the screen%@AE@%%@NL@%
    StdOut "Cursor movements..."%@NL@%
    CrLf%@NL@%
    CursorDown 1%@NL@%
    StdOut "Down 1"%@NL@%
    CursorRight 12%@NL@%
    StdOut "Right 12"%@NL@%
    CursorDown 2%@NL@%
    StdOut "Down 2"%@NL@%
    CursorLeft 99%@NL@%
    StdOut "Left 99"%@NL@%
    CrLf%@NL@%
%@NL@%
%@AB@%  ' Character attributes%@AE@%%@NL@%
    CrLf%@NL@%
    Attribute YELLOWFOREGROUND%@NL@%
    Attribute BRIGHT%@NL@%
    Attribute BLUEBACKGROUND%@NL@%
    StdOut "Bright yellow on blue"%@NL@%
    CrLf%@NL@%
    Attribute NORMAL%@NL@%
    StdOut "Back to normal attributes"%@NL@%
    CrLf%@NL@%
%@NL@%
%@AB@%  ' Key reassignment%@AE@%%@NL@%
    AssignKey 97, "REM The 'a' and 'b' keys have been redefined" + CHR$(13)%@NL@%
    AssignKey 98, "EXIT" + CHR$(13)%@NL@%
    CursorDown 1%@NL@%
    Attribute BRIGHT%@NL@%
    Attribute YELLOWFOREGROUND%@NL@%
    StdOut "NOTE:"%@NL@%
    CrLf%@NL@%
    StdOut "Press the 'a' key and then the 'b' key ... "%@NL@%
    CrLf%@NL@%
    StdOut "The program will then continue ........ "%@NL@%
    Attribute NORMAL%@NL@%
    CrLf%@NL@%
    SHELL%@NL@%
    AssignKey 97, ""%@NL@%
    AssignKey 98, ""%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          AssignKey                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Assigns a string to any key using ANSI.SYS driver.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  AssignKey keyCode%, assign$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      keyCode%   ASCII number for key to be reassigned%@AE@%%@NL@%
%@AB@%  '                  assign$    String to assign to key%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       k$         Command string for ANSI.SYS driver%@AE@%%@NL@%
%@AB@%  '                  i%         Index to each character of assign$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB AssignKey (keyCode%, assign$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB AssignKey (keyCode%, assign$) STATIC%@NL@%
        IF keyCode% <= 0 THEN%@NL@%
            k$ = "[0;"%@NL@%
        ELSE%@NL@%
            k$ = "["%@NL@%
        END IF%@NL@%
        k$ = k$ + MID$(STR$(keyCode%), 2)%@NL@%
        IF assign$ <> "" THEN%@NL@%
            FOR i% = 1 TO LEN(assign$)%@NL@%
                k$ = k$ + ";" + MID$(STR$(ASC(MID$(assign$, i%))), 2)%@NL@%
            NEXT i%%@NL@%
        END IF%@NL@%
        StdOut CHR$(27) + k$ + "p"%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Attribute                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Sets the foreground, background, and other color%@AE@%%@NL@%
%@AB@%  ' attributes.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Attribute attr%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      attr%      Number for attribute to be set%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB StdOut (a$)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB Attribute (attr%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Attribute (attr%) STATIC%@NL@%
        StdOut CHR$(27) + "[" + MID$(STR$(attr%), 2) + "m"%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ClearLine                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Clears the display line from the current cursor%@AE@%%@NL@%
%@AB@%  ' position to the end of the line.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ClearLine%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB ClearLine ()%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB StdOut (a$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ClearLine STATIC%@NL@%
        StdOut CHR$(27) + "[K"%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ClearScreen                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Clears the screen and moves the cursor to the%@AE@%%@NL@%
%@AB@%  ' home position.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  ClearScreen%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB ClearScreen ()%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB StdOut (a$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB ClearScreen STATIC%@NL@%
        StdOut CHR$(27) + "[2J"%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CrLf                       **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Sends line feed and carriage return characters%@AE@%%@NL@%
%@AB@%  ' to standard output.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  CrLf%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB StdOut (a$)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB CrLf ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB CrLf STATIC%@NL@%
        StdOut CHR$(13) + CHR$(10)%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CursorDown                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Moves the cursor n% lines down the screen.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:   CursorDown n%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:       n%         Number of lines to move the cursor down%@AE@%%@NL@%
%@AB@%  ' VARIABLES:        (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:   DECLARE SUB StdOut (a$)%@AE@%%@NL@%
%@AB@%  '                   DECLARE SUB CursorDown (n%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB CursorDown (n%) STATIC%@NL@%
        StdOut CHR$(27) + "[" + MID$(STR$(n%), 2) + "B"%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CursorHome                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Moves the cursor to the top left of the%@AE@%%@NL@%
%@AB@%  ' screen.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  CursorHome%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB CursorHome%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB CursorHome STATIC%@NL@%
        StdOut CHR$(27) + "[H"%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CursorLeft                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Moves the cursor n% columns left on the screen.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  CursorLeft n%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      n%      Number of columns to move the cursor left%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB CursorLeft (n%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB CursorLeft (n%) STATIC%@NL@%
        StdOut CHR$(27) + "[" + MID$(STR$(n%), 2) + "D"%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CursorPosition             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Moves the cursor to the indicated row and column.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  CursorPosition row%, col%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      row%       Row to move the cursor to%@AE@%%@NL@%
%@AB@%  '                  col%       Column to move the cursor to%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       row$       String representation of row%%@AE@%%@NL@%
%@AB@%  '                  col$       String representation of col%%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB CursorPosition (row%, col%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB CursorPosition (row%, col%) STATIC%@NL@%
        row$ = MID$(STR$(row%), 2)%@NL@%
        col$ = MID$(STR$(col%), 2)%@NL@%
        StdOut CHR$(27) + "[" + row$ + ";" + col$ + "H"%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CursorRight                **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Moves the cursor n% columns right on the screen.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  CursorRight n%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      n%     Number of columns to move the cursor right%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB CursorRight (n%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB CursorRight (n%) STATIC%@NL@%
        StdOut CHR$(27) + "[" + MID$(STR$(n%), 2) + "C"%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          CursorUp                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Moves the cursor n% lines up the screen.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  CursorUp n%%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      n%         Number of lines to move the cursor up%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB CursorUp (n%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB CursorUp (n%) STATIC%@NL@%
        StdOut CHR$(27) + "[" + MID$(STR$(n%), 2) + "A"%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          StdOut                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STDOUT.BAS                 **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Writes string to the MS-DOS standard output.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  StdOut a$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String to be output%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       regX       Structure of type RegTypeX%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:    DECLARE SUB InterruptX (intnum%, inreg AS RegTypeX,%@AE@%%@NL@%
%@AB@%  '                                          outreg AS RegTypeX)%@AE@%%@NL@%
%@AB@%  '                  DECLARE SUB StdOut (a$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB StdOut (a$) STATIC%@NL@%
        DIM regX AS RegTypeX%@NL@%
        regX.ax = &H4000%@NL@%
        regX.cx = LEN(a$)%@NL@%
        regX.bx = 1%@NL@%
        regX.ds = VARSEG(a$)%@NL@%
        regX.dx = SADD(a$)%@NL@%
        InterruptX &H21, regX, regX%@NL@%
        IF regX.flags AND 1 THEN%@NL@%
            PRINT "Error while calling StdOut:"; regX.ax%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%STRINGS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\STRINGS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          STRINGS                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       a$       Working string for demonstrations%@AE@%%@NL@%
%@AB@%  '                  b$       Working string for demonstrations%@AE@%%@NL@%
%@AB@%  '                  c$       Working string for demonstrations%@AE@%%@NL@%
%@AB@%  '                  x$       Working string for demonstrations%@AE@%%@NL@%
%@AB@%  '                  y$       Working string for demonstrations%@AE@%%@NL@%
%@AB@%  '                  set$     Set of characters that define word separations%@AE@%%@NL@%
%@NL@%
    DECLARE FUNCTION Ascii2Ebcdic$ (a$)%@NL@%
    DECLARE FUNCTION BestMatch$ (a$, x$, y$)%@NL@%
    DECLARE FUNCTION Center$ (a$, n%)%@NL@%
    DECLARE FUNCTION Detab$ (a$, tabs%)%@NL@%
    DECLARE FUNCTION Ebcdic2Ascii$ (e$)%@NL@%
    DECLARE FUNCTION Entab$ (a$, tabs%)%@NL@%
    DECLARE FUNCTION FilterIn$ (a$, set$)%@NL@%
    DECLARE FUNCTION FilterOut$ (a$, set$)%@NL@%
    DECLARE FUNCTION Lpad$ (a$, n%)%@NL@%
    DECLARE FUNCTION LtrimSet$ (a$, set$)%@NL@%
    DECLARE FUNCTION Ord% (a$)%@NL@%
    DECLARE FUNCTION Repeat$ (a$, n%)%@NL@%
    DECLARE FUNCTION Replace$ (a$, find$, substitute$)%@NL@%
    DECLARE FUNCTION Reverse$ (a$)%@NL@%
    DECLARE FUNCTION ReverseCase$ (a$)%@NL@%
    DECLARE FUNCTION Rpad$ (a$, n%)%@NL@%
    DECLARE FUNCTION RtrimSet$ (a$, set$)%@NL@%
    DECLARE FUNCTION Translate$ (a$, f$, t$)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB BuildAEStrings ()%@NL@%
%@NL@%
%@AB@%  ' Quick demonstrations%@AE@%%@NL@%
    CLS%@NL@%
    a$ = "This is a test"%@NL@%
    PRINT "a$", , a$%@NL@%
    PRINT "ReverseCase$(a$)", ReverseCase$(a$)%@NL@%
    PRINT "Reverse$(a$)", , Reverse$(a$)%@NL@%
    PRINT "Repeat$(a$, 3)", Repeat$(a$, 3)%@NL@%
    PRINT%@NL@%
%@NL@%
    set$ = "T this"%@NL@%
    PRINT "set$", , set$%@NL@%
    PRINT "LtrimSet$(a$, set$)", LtrimSet$(a$, set$)%@NL@%
    PRINT "RtrimSet$(a$, set$)", RtrimSet$(a$, set$)%@NL@%
    PRINT "FilterOut$(a$, set$)", FilterOut$(a$, set$)%@NL@%
    PRINT "FilterIn$(a$, set$)", FilterIn$(a$, set$)%@NL@%
    PRINT%@NL@%
%@NL@%
    a$ = "elephant"%@NL@%
    x$ = "alpha"%@NL@%
    y$ = "omega"%@NL@%
    PRINT "a$", , a$%@NL@%
    PRINT "x$", , x$%@NL@%
    PRINT "y$", , y$%@NL@%
    PRINT "BestMatch$(a$, x$, y$)", BestMatch$(a$, x$, y$)%@NL@%
    PRINT%@NL@%
%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
    CLS%@NL@%
    a$ = "BEL"%@NL@%
    PRINT "a$", , a$%@NL@%
    PRINT "Ord%(a$)", , Ord%(a$)%@NL@%
    PRINT%@NL@%
%@NL@%
    a$ = "This is a test"%@NL@%
    find$ = "s"%@NL@%
    substitute$ = "<s>"%@NL@%
    PRINT "a$", , , a$%@NL@%
    PRINT "find$", , , find$%@NL@%
    PRINT "substitute$", , , substitute$%@NL@%
    PRINT "Replace$(a$, find$, substitute$)", Replace$(a$, find$, substitute$)%@NL@%
    PRINT%@NL@%
%@NL@%
    PRINT "a$", , a$%@NL@%
    PRINT "Lpad$(a$, 40)", , ":"; Lpad$(a$, 40); ":"%@NL@%
    PRINT "Rpad$(a$, 40)", , ":"; Rpad$(a$, 40); ":"%@NL@%
    PRINT "Center$(a$, 40)", ":"; Center$(a$, 40); ":"%@NL@%
    PRINT%@NL@%
%@NL@%
    a$ = "a$ character" + STRING$(2, 9) + "count" + CHR$(9) + "is"%@NL@%
    PRINT a$; LEN(a$)%@NL@%
    PRINT "a$ = Detab$(a$, 8)"%@NL@%
    a$ = Detab$(a$, 8)%@NL@%
    PRINT a$; LEN(a$)%@NL@%
    PRINT "a$ = Entab$(a$, 8)"%@NL@%
    a$ = Entab$(a$, 8)%@NL@%
    PRINT a$; LEN(a$)%@NL@%
    PRINT%@NL@%
%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
    CLS%@NL@%
    a$ = "You know this test string has vowels."%@NL@%
    x$ = "aeiou"%@NL@%
    y$ = "eioua"%@NL@%
    PRINT "a$", , a$%@NL@%
    PRINT "x$", , x$%@NL@%
    PRINT "y$", , y$%@NL@%
    PRINT "Translate$(a$, x$, y$)", Translate$(a$, x$, y$)%@NL@%
    PRINT%@NL@%
%@NL@%
    a$ = "This is a test."%@NL@%
    b$ = Ascii2Ebcdic$(a$)%@NL@%
    c$ = Ebcdic2Ascii$(b$)%@NL@%
    PRINT "a$", , a$%@NL@%
    PRINT "b$ = Ascii2Ebcdic$(a$)", b$%@NL@%
    PRINT "c$ = Ebcdic2Ascii$(b$)", c$%@NL@%
    PRINT%@NL@%
%@NL@%
    END%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Ascii2Ebcdic$              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a$ with each character translated from ASCII to EBCDIC.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  e$ = Ascii2Ebcdic$(a$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String of ASCII characters to be%@AE@%%@NL@%
%@AB@%  '                             converted%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       ebcdic$    Table of translation characters%@AE@%%@NL@%
%@AB@%  '                  ascii$     Table of translation characters%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Ascii2Ebcdic$ (a$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Ascii2Ebcdic$ (a$) STATIC%@NL@%
        SHARED ebcdic$, ascii$%@NL@%
        IF ebcdic$ = "" THEN%@NL@%
            BuildAEStrings%@NL@%
        END IF%@NL@%
        Ascii2Ebcdic$ = Translate$(a$, ascii$, ebcdic$)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          BestMatch$                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns either x$ or y$, whichever is a best match to a$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = BestMatch$(a$, x$, y$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$          The string to be matched%@AE@%%@NL@%
%@AB@%  '                  x$          The first string to compare with a$%@AE@%%@NL@%
%@AB@%  '                  y$          The second string to compare with a$%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       ua$         Uppercase working copy of a$%@AE@%%@NL@%
%@AB@%  '                  ux$         Uppercase working copy of x$%@AE@%%@NL@%
%@AB@%  '                  uy$         Uppercase working copy of y$%@AE@%%@NL@%
%@AB@%  '                  lena%       Length of a$%@AE@%%@NL@%
%@AB@%  '                  i%          Length of substrings of ua$%@AE@%%@NL@%
%@AB@%  '                  j%          Index into ua$%@AE@%%@NL@%
%@AB@%  '                  t$          Substrings of ua$%@AE@%%@NL@%
%@AB@%  '                  xscore%     Accumulated score for substring matches%@AE@%%@NL@%
%@AB@%  '                              found in ux$%@AE@%%@NL@%
%@AB@%  '                  yscore%     Accumulated score for substring matches%@AE@%%@NL@%
%@AB@%  '                              found in uy$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION BestMatch$ (a$, x$, y$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION BestMatch$ (a$, x$, y$) STATIC%@NL@%
        ua$ = UCASE$(a$)%@NL@%
        ux$ = UCASE$(x$)%@NL@%
        uy$ = UCASE$(y$)%@NL@%
        lena% = LEN(ua$)%@NL@%
        FOR i% = 1 TO lena%%@NL@%
            FOR j% = 1 TO lena% - i% + 1%@NL@%
                t$ = MID$(ua$, j%, i%)%@NL@%
                IF INSTR(ux$, t$) THEN%@NL@%
                    xscore% = xscore% + i% + i%%@NL@%
                END IF%@NL@%
                IF INSTR(uy$, t$) THEN%@NL@%
                    yscore% = yscore% + i% + i%%@NL@%
                END IF%@NL@%
            NEXT j%%@NL@%
        NEXT i%%@NL@%
        IF xscore% > yscore% THEN%@NL@%
            BestMatch$ = x$%@NL@%
        ELSE%@NL@%
            BestMatch$ = y$%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          BuildAEStrings             **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Called by the Ascii2Ebcdic$ and Ebcdic2Ascii$%@AE@%%@NL@%
%@AB@%  ' functions to build the translation strings.%@AE@%%@NL@%
%@AB@%  ' This subprogram is called only once.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Called automatically by either the Ascii2Ebcdic$ or%@AE@%%@NL@%
%@AB@%  '                  Ebcdic2Ascii$ function%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      ascii$     Shared by Ascii2Ebcdic$, Ebcdic2Ascii$, and%@AE@%%@NL@%
%@AB@%  '                             BuildAEStrings%@AE@%%@NL@%
%@AB@%  '                  ebcdic$    Shared by Ascii2Ebcdic$, Ebcdic2Ascii$, and%@AE@%%@NL@%
%@AB@%  '                             BuildAEStrings%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%         Index into strings%@AE@%%@NL@%
%@AB@%  '                  byte%      Binary value of character byte%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB BuildAEStrings ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB BuildAEStrings STATIC%@NL@%
        SHARED ebcdic$, ascii$%@NL@%
        ascii$ = SPACE$(128)%@NL@%
        ebcdic$ = ebcdic$ + "00010203372D2E2F1605250B0C0D0E0F"%@NL@%
        ebcdic$ = ebcdic$ + "101112133C3D322618193F271C1D1E1F"%@NL@%
        ebcdic$ = ebcdic$ + "404F7F7B5B6C507D4D5D5C4E6B604B61"%@NL@%
        ebcdic$ = ebcdic$ + "F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F"%@NL@%
        ebcdic$ = ebcdic$ + "7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6"%@NL@%
        ebcdic$ = ebcdic$ + "D7D8D9E2E3E4E5E6E7E8E94AE05A5F6D"%@NL@%
        ebcdic$ = ebcdic$ + "79818283848586878889919293949596"%@NL@%
        ebcdic$ = ebcdic$ + "979899A2A3A4A5A6A7A8A9C06AD0A107"%@NL@%
        FOR i% = 0 TO 127%@NL@%
            MID$(ascii$, i% + 1, 1) = CHR$(i%)%@NL@%
            byte% = VAL("&H" + MID$(ebcdic$, i% + i% + 1, 2))%@NL@%
            MID$(ebcdic$, i% + 1, 1) = CHR$(byte%)%@NL@%
        NEXT i%%@NL@%
        ebcdic$ = LEFT$(ebcdic$, 128)%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Center$                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Pads a$ with spaces on both ends until text is%@AE@%%@NL@%
%@AB@%  ' centered and the string length is n%.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = Center$(a$, n%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String of characters to be padded with spaces%@AE@%%@NL@%
%@AB@%  '                  n%         Desired length of resulting string%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       pad%       Number of spaces to pad at ends of string%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Center$ (a$, n%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Center$ (a$, n%) STATIC%@NL@%
        a$ = LTRIM$(RTRIM$(a$))%@NL@%
        pad% = n% - LEN(a$)%@NL@%
        IF pad% > 0 THEN%@NL@%
            Center$ = SPACE$(pad% \ 2) + a$ + SPACE$(pad% - pad% \ 2)%@NL@%
        ELSE%@NL@%
            Center$ = a$%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name           Detab$                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Replaces all tab characters with spaces, using%@AE@%%@NL@%
%@AB@%  ' tabs% to determine proper alignment.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = Detab$(a$, tabs%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$           String with possible tab characters%@AE@%%@NL@%
%@AB@%  '                  tabs%        Tab spacing%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       t$           Working copy of a$%@AE@%%@NL@%
%@AB@%  '                  tb$          Tab character%@AE@%%@NL@%
%@AB@%  '                  tp%          Pointer to position in t$ of a tab character%@AE@%%@NL@%
%@AB@%  '                  sp$          Spaces to replace a given tab character%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Detab$ (a$, tabs%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Detab$ (a$, tabs%) STATIC%@NL@%
        t$ = a$%@NL@%
        tb$ = CHR$(9)%@NL@%
        DO%@NL@%
            tp% = INSTR(t$, tb$)%@NL@%
            IF tp% THEN%@NL@%
                Sp$ = SPACE$(tabs% - ((tp% - 1) MOD tabs%))%@NL@%
                t$ = LEFT$(t$, tp% - 1) + Sp$ + MID$(t$, tp% + 1)%@NL@%
            END IF%@NL@%
        LOOP UNTIL tp% = 0%@NL@%
        Detab$ = t$%@NL@%
        t$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Ebcdic2Ascii$              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a$ with each character translated from%@AE@%%@NL@%
%@AB@%  ' EBCDIC to ASCII.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = Ascii2Ebcdic$(a$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$          String of EBCDIC characters to be converted%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       ebcdic$     Table of translation characters%@AE@%%@NL@%
%@AB@%  '                  ascii$      Table of translation characters%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Ebcdic2Ascii$ (e$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Ebcdic2Ascii$ (e$) STATIC%@NL@%
        SHARED ebcdic$, ascii$%@NL@%
        IF ebcdic$ = "" THEN%@NL@%
            BuildAEStrings%@NL@%
        END IF%@NL@%
        Ebcdic2Ascii$ = Translate$(e$, ebcdic$, ascii$)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Entab$                     **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Replaces groups of spaces, where possible, with%@AE@%%@NL@%
%@AB@%  ' tab characters, keeping the alignment indicated%@AE@%%@NL@%
%@AB@%  ' by the value of tabs%.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = Entab$(a$, tabs%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$            String with possible tab characters%@AE@%%@NL@%
%@AB@%  '                  tabs%         Tab spacing%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       t$            Working copy of a$%@AE@%%@NL@%
%@AB@%  '                  tb$           Tab character%@AE@%%@NL@%
%@AB@%  '                  i%            Index into t$%@AE@%%@NL@%
%@AB@%  '                  k%            Count of spaces being replaced%@AE@%%@NL@%
%@AB@%  '                  j%            Index into t$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Entab$ (a$, tabs%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Entab$ (a$, tabs%) STATIC%@NL@%
        t$ = a$%@NL@%
        tb$ = CHR$(9)%@NL@%
        FOR i% = (LEN(t$) \ tabs%) * tabs% + 1 TO tabs% STEP -tabs%%@NL@%
            IF MID$(t$, i% - 1, 1) = " " THEN%@NL@%
                k% = 0%@NL@%
                FOR j% = 1 TO tabs%%@NL@%
                    IF MID$(t$, i% - j%, 1) <> " " THEN%@NL@%
                        k% = i% - j%%@NL@%
                        EXIT FOR%@NL@%
                    END IF%@NL@%
                NEXT j%%@NL@%
                IF k% = 0 THEN%@NL@%
                    k% = i% - tabs% - 1%@NL@%
                END IF%@NL@%
                t$ = LEFT$(t$, k%) + tb$ + MID$(t$, i%)%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
        Entab$ = t$%@NL@%
        t$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FilterIn$                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a$ with all occurrences of any characters%@AE@%%@NL@%
%@AB@%  ' that are not in set$ deleted.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = FilterIn$(a$, set$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$          String to be processed%@AE@%%@NL@%
%@AB@%  '                  set$        Set of characters to be retained%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%          Index into a$%@AE@%%@NL@%
%@AB@%  '                  j%          Count of characters retained%@AE@%%@NL@%
%@AB@%  '                  lena%       Length of a$%@AE@%%@NL@%
%@AB@%  '                  t$          Working string space%@AE@%%@NL@%
%@AB@%  '                  c$          Each character of a$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION FilterIn$ (a$, set$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION FilterIn$ (a$, set$) STATIC%@NL@%
        i% = 1%@NL@%
        j% = 0%@NL@%
        lena% = LEN(a$)%@NL@%
        t$ = a$%@NL@%
        DO UNTIL i% > lena%%@NL@%
            c$ = MID$(a$, i%, 1)%@NL@%
            IF INSTR(set$, c$) THEN%@NL@%
                j% = j% + 1%@NL@%
                MID$(t$, j%, 1) = c$%@NL@%
            END IF%@NL@%
            i% = i% + 1%@NL@%
        LOOP%@NL@%
        FilterIn$ = LEFT$(t$, j%)%@NL@%
        t$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          FilterOut$                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a$ with all occurrences of any characters%@AE@%%@NL@%
%@AB@%  ' from set$ deleted.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = FilterOut$(a$, set$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$           String to be processed%@AE@%%@NL@%
%@AB@%  '                  set$         Set of characters to be retained%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%           Index into a$%@AE@%%@NL@%
%@AB@%  '                  j%           Count of characters retained%@AE@%%@NL@%
%@AB@%  '                  lena%        Length of a$%@AE@%%@NL@%
%@AB@%  '                  t$           Working string space%@AE@%%@NL@%
%@AB@%  '                  c$           Each character of a$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION FilterOut$ (a$, set$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION FilterOut$ (a$, set$) STATIC%@NL@%
        i% = 1%@NL@%
        j% = 0%@NL@%
        lena% = LEN(a$)%@NL@%
        t$ = a$%@NL@%
        DO UNTIL i% > lena%%@NL@%
            c$ = MID$(a$, i%, 1)%@NL@%
            IF INSTR(set$, c$) = 0 THEN%@NL@%
                j% = j% + 1%@NL@%
                MID$(t$, j%, 1) = c$%@NL@%
            END IF%@NL@%
            i% = i% + 1%@NL@%
        LOOP%@NL@%
        FilterOut$ = LEFT$(t$, j%)%@NL@%
        t$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Lpad$                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a string of length n%, with a$ left justified%@AE@%%@NL@%
%@AB@%  ' and padded on the right with spaces.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = Lpad$(a$, n%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$          String to be left justified and padded%@AE@%%@NL@%
%@AB@%  '                  n%          Length of string result%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Lpad$ (a$, n%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Lpad$ (a$, n%) STATIC%@NL@%
        Lpad$ = LEFT$(LTRIM$(a$) + SPACE$(n%), n%)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          LtrimSet$                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Trims occurrences of any characters in set$%@AE@%%@NL@%
%@AB@%  ' from the left of a$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = LtrimSet$(a$, set$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$           String to be trimmed%@AE@%%@NL@%
%@AB@%  '                  set$         Set of characters to be trimmed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%           Index into a$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION LtrimSet$ (a$, set$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION LtrimSet$ (a$, set$) STATIC%@NL@%
        IF a$ <> "" THEN%@NL@%
            FOR i% = 1 TO LEN(a$)%@NL@%
                IF INSTR(set$, MID$(a$, i%, 1)) = 0 THEN%@NL@%
                    LtrimSet$ = MID$(a$, i%)%@NL@%
                    EXIT FUNCTION%@NL@%
                END IF%@NL@%
            NEXT i%%@NL@%
        END IF%@NL@%
        LtrimSet$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Ord%                       **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Similar to ASC() function; returns%@AE@%%@NL@%
%@AB@%  ' numeric byte values for the ANSI standard%@AE@%%@NL@%
%@AB@%  ' mnemonics for control characters.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  byte% = Ord%(a$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$          ANSI standard character mnemonic string%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Ord% (a$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Ord% (a$) STATIC%@NL@%
        SELECT CASE UCASE$(a$)%@NL@%
        CASE "NUL"              'Null%@NL@%
            Ord% = 0%@NL@%
        CASE "SOH"              'Start of heading%@NL@%
            Ord% = 1%@NL@%
        CASE "STX"              'Start of text%@NL@%
            Ord% = 2%@NL@%
        CASE "ETX"              'End of text%@NL@%
            Ord% = 3%@NL@%
        CASE "EOT"              'End of transmission%@NL@%
            Ord% = 4%@NL@%
        CASE "ENQ"              'Enquiry%@NL@%
            Ord% = 5%@NL@%
        CASE "ACK"              'Acknowledge%@NL@%
            Ord% = 6%@NL@%
        CASE "BEL"              'Bell%@NL@%
            Ord% = 7%@NL@%
        CASE "BS"               'Backspace%@NL@%
            Ord% = 8%@NL@%
        CASE "HT"               'Horizontal tab%@NL@%
            Ord% = 9%@NL@%
        CASE "LF"               'Line feed%@NL@%
            Ord% = 10%@NL@%
        CASE "VT"               'Vertical tab%@NL@%
            Ord% = 11%@NL@%
        CASE "FF"               'Form feed%@NL@%
            Ord% = 12%@NL@%
        CASE "CR"               'Carriage return%@NL@%
            Ord% = 13%@NL@%
        CASE "SO"               'Shift out%@NL@%
            Ord% = 14%@NL@%
        CASE "SI"               'Shift in%@NL@%
            Ord% = 15%@NL@%
        CASE "DLE"              'Data link escape%@NL@%
            Ord% = 16%@NL@%
        CASE "DC1"              'Device control 1%@NL@%
            Ord% = 17%@NL@%
        CASE "DC2"              'Device control 2%@NL@%
            Ord% = 18%@NL@%
        CASE "DC3"              'Device control 3%@NL@%
            Ord% = 19%@NL@%
        CASE "DC4"              'Device control 4%@NL@%
            Ord% = 20%@NL@%
        CASE "NAK"              'Negative acknowledge%@NL@%
            Ord% = 21%@NL@%
        CASE "SYN"              'Synchronous idle%@NL@%
            Ord% = 22%@NL@%
        CASE "ETB"              'End of transmission block%@NL@%
            Ord% = 23%@NL@%
        CASE "CAN"              'Cancel%@NL@%
            Ord% = 24%@NL@%
        CASE "EM"               'End of medium%@NL@%
            Ord% = 25%@NL@%
        CASE "SUB"              'Substitute%@NL@%
            Ord% = 26%@NL@%
        CASE "ESC"              'Escape%@NL@%
            Ord% = 27%@NL@%
        CASE "FS"               'File separator%@NL@%
            Ord% = 28%@NL@%
        CASE "GS"               'Group separator%@NL@%
            Ord% = 29%@NL@%
        CASE "RS"               'Record separator%@NL@%
            Ord% = 30%@NL@%
        CASE "US"               'Unit separator%@NL@%
            Ord% = 31%@NL@%
        CASE "SP"               'Space%@NL@%
            Ord% = 32%@NL@%
        CASE "UND"              'Underline%@NL@%
            Ord% = 95%@NL@%
        CASE "GRA"              'Grave accent%@NL@%
            Ord% = 96%@NL@%
        CASE "LCA"              'Lowercase a%@NL@%
            Ord% = 97%@NL@%
        CASE "LCB"              'Lowercase b%@NL@%
            Ord% = 98%@NL@%
        CASE "LCC"              'Lowercase c%@NL@%
            Ord% = 99%@NL@%
        CASE "LCD"              'Lowercase d%@NL@%
            Ord% = 100%@NL@%
        CASE "LCE"              'Lowercase e%@NL@%
            Ord% = 101%@NL@%
        CASE "LCF"              'Lowercase f%@NL@%
            Ord% = 102%@NL@%
        CASE "LCG"              'Lowercase g%@NL@%
            Ord% = 103%@NL@%
        CASE "LCH"              'Lowercase h%@NL@%
            Ord% = 104%@NL@%
        CASE "LCI"              'Lowercase i%@NL@%
            Ord% = 105%@NL@%
        CASE "LCJ"              'Lowercase j%@NL@%
            Ord% = 106%@NL@%
        CASE "LCK"              'Lowercase k%@NL@%
            Ord% = 107%@NL@%
        CASE "LCL"              'Lowercase l%@NL@%
            Ord% = 108%@NL@%
        CASE "LCM"              'Lowercase m%@NL@%
            Ord% = 109%@NL@%
        CASE "LCN"              'Lowercase n%@NL@%
            Ord% = 110%@NL@%
        CASE "LCO"              'Lowercase o%@NL@%
            Ord% = 111%@NL@%
        CASE "LCP"              'Lowercase p%@NL@%
            Ord% = 112%@NL@%
        CASE "LCQ"              'Lowercase q%@NL@%
            Ord% = 113%@NL@%
        CASE "LCR"              'Lowercase r%@NL@%
            Ord% = 114%@NL@%
        CASE "LCS"              'Lowercase s%@NL@%
            Ord% = 115%@NL@%
        CASE "LCT"              'Lowercase t%@NL@%
            Ord% = 116%@NL@%
        CASE "LCU"              'Lowercase u%@NL@%
            Ord% = 117%@NL@%
        CASE "LCV"              'Lowercase v%@NL@%
            Ord% = 118%@NL@%
        CASE "LCW"              'Lowercase w%@NL@%
            Ord% = 119%@NL@%
        CASE "LCX"              'Lowercase x%@NL@%
            Ord% = 120%@NL@%
        CASE "LCY"              'Lowercase y%@NL@%
            Ord% = 121%@NL@%
        CASE "LCZ"              'Lowercase z%@NL@%
            Ord% = 122%@NL@%
        CASE "LBR"              'Left brace%@NL@%
            Ord% = 123%@NL@%
        CASE "VLN"              'Vertical line%@NL@%
            Ord% = 124%@NL@%
        CASE "RBR"              'Right brace%@NL@%
            Ord% = 125%@NL@%
        CASE "TIL"              'Tilde%@NL@%
            Ord% = 126%@NL@%
        CASE "DEL"              'Delete%@NL@%
            Ord% = 127%@NL@%
        CASE ELSE               'Not ANSI Standard ORD mnemonic%@NL@%
            Ord% = -1%@NL@%
        END SELECT%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Repeat$                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a string formed by concatenating n%%@AE@%%@NL@%
%@AB@%  ' copies of a$ together.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = Repeat$(a$, n%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$           String to be repeated%@AE@%%@NL@%
%@AB@%  '                  n%           Number of copies of a$ to concatenate%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       lena%        Length of a$%@AE@%%@NL@%
%@AB@%  '                  lent&        Length of result%@AE@%%@NL@%
%@AB@%  '                  t$           Work space for building result%@AE@%%@NL@%
%@AB@%  '                  ndx%         Index into t$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Repeat$ (a$, n%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Repeat$ (a$, n%) STATIC%@NL@%
        lena% = LEN(a$)%@NL@%
        lent& = n% * lena%%@NL@%
        IF lent& < 0 OR lent& > 32767 THEN%@NL@%
            PRINT "ERROR: Repeat$ - Negative repetition, or result too long"%@NL@%
            SYSTEM%@NL@%
        ELSEIF lent& = 0 THEN%@NL@%
            Repeat$ = ""%@NL@%
        ELSE%@NL@%
            t$ = SPACE$(lent&)%@NL@%
            ndx% = 1%@NL@%
            DO%@NL@%
                MID$(t$, ndx%, lena%) = a$%@NL@%
                ndx% = ndx% + lena%%@NL@%
            LOOP UNTIL ndx% > lent&%@NL@%
            Repeat$ = t$%@NL@%
            t$ = ""%@NL@%
        END IF%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Replace$                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Replaces all occurrences of find$ in a$ with substitute$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = Replace$(a$, find$, substitute$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$            String to make substring replacements in%@AE@%%@NL@%
%@AB@%  '                  find$         Substring to be searched for%@AE@%%@NL@%
%@AB@%  '                  substitutes$  String for replacing the found%@AE@%%@NL@%
%@AB@%  '                                substrings%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       t$            Working copy of a$%@AE@%%@NL@%
%@AB@%  '                  lenf%         Length of find$%@AE@%%@NL@%
%@AB@%  '                  lens%         Length of substitute$%@AE@%%@NL@%
%@AB@%  '                  i%            Index into a$, pointing at substrings%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Replace$ (a$, find$, substitute$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Replace$ (a$, find$, substitute$) STATIC%@NL@%
        t$ = a$%@NL@%
        lenf% = LEN(find$)%@NL@%
        lens% = LEN(substitute$)%@NL@%
        i% = 1%@NL@%
        DO%@NL@%
            i% = INSTR(i%, t$, find$)%@NL@%
            IF i% = 0 THEN%@NL@%
                EXIT DO%@NL@%
            END IF%@NL@%
            t$ = LEFT$(t$, i% - 1) + substitute$ + MID$(t$, i% + lenf%)%@NL@%
            i% = i% + lens%%@NL@%
        LOOP%@NL@%
        Replace$ = t$%@NL@%
        t$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Reverse$                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Reverses the order of all characters in a$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = Reverse$(a$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       n%         Length of the string%@AE@%%@NL@%
%@AB@%  '                  r$         Working string space%@AE@%%@NL@%
%@AB@%  '                  i%         Index into the string%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Reverse$ (a$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Reverse$ (a$) STATIC%@NL@%
        n% = LEN(a$)%@NL@%
        r$ = a$%@NL@%
        FOR i% = 1 TO n%%@NL@%
            MID$(r$, i%, 1) = MID$(a$, n% - i% + 1, 1)%@NL@%
        NEXT i%%@NL@%
        Reverse$ = r$%@NL@%
        r$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          ReverseCase$               **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Changes all lowercase characters to uppercase%@AE@%%@NL@%
%@AB@%  ' and all uppercase characters to lowercase.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = ReverseCase$(a$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       r$         Working copy of a$%@AE@%%@NL@%
%@AB@%  '                  i%         Index into r$%@AE@%%@NL@%
%@AB@%  '                  t$         Character from middle of a$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION ReverseCase$ (a$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION ReverseCase$ (a$) STATIC%@NL@%
        r$ = a$%@NL@%
        FOR i% = 1 TO LEN(a$)%@NL@%
            t$ = MID$(a$, i%, 1)%@NL@%
            IF LCASE$(t$) <> t$ THEN%@NL@%
                MID$(r$, i%, 1) = LCASE$(t$)%@NL@%
            ELSE%@NL@%
                MID$(r$, i%, 1) = UCASE$(t$)%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
        ReverseCase$ = r$%@NL@%
        r$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Rpad$                      **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns string of length n%, with a$ right justified%@AE@%%@NL@%
%@AB@%  ' and padded on the left with spaces.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = Rpad$(a$, n%)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$           String to be right justified and padded%@AE@%%@NL@%
%@AB@%  '                  n%           Length of string result%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Rpad$ (a$, n%)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Rpad$ (a$, n%) STATIC%@NL@%
        Rpad$ = RIGHT$(SPACE$(n%) + RTRIM$(a$), n%)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          RtrimSet$                  **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Trims occurrences of any characters in set$%@AE@%%@NL@%
%@AB@%  ' from the right of a$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = LtrimSet$(a$, set$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$           String to be trimmed%@AE@%%@NL@%
%@AB@%  '                  set$         Set of characters to be trimmed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%           Index into a$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION RtrimSet$ (a$, set$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION RtrimSet$ (a$, set$) STATIC%@NL@%
        IF a$ <> "" THEN%@NL@%
            FOR i% = LEN(a$) TO 1 STEP -1%@NL@%
                IF INSTR(set$, MID$(a$, i%, 1)) = 0 THEN%@NL@%
                    RtrimSet$ = LEFT$(a$, i%)%@NL@%
                    EXIT FUNCTION%@NL@%
                END IF%@NL@%
            NEXT i%%@NL@%
        END IF%@NL@%
        RtrimSet$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Translate$                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        STRINGS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns a$ with each character translated from%@AE@%%@NL@%
%@AB@%  ' f$ to t$.  If a character from a$ is found in f$,%@AE@%%@NL@%
%@AB@%  ' it is replaced with the character located%@AE@%%@NL@%
%@AB@%  ' in the same position in t$.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  b$ = Translate$ (a$, f$, t$)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String to be translated%@AE@%%@NL@%
%@AB@%  '                  f$         Table of lookup characters%@AE@%%@NL@%
%@AB@%  '                  t$         Table of replacement characters%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       ta$        Working copy of a$%@AE@%%@NL@%
%@AB@%  '                  lena%      Length of a$%@AE@%%@NL@%
%@AB@%  '                  lenf%      Length of f$%@AE@%%@NL@%
%@AB@%  '                  lent%      Length of t$%@AE@%%@NL@%
%@AB@%  '                  i%         Index into ta$%@AE@%%@NL@%
%@AB@%  '                  ptr%       Pointer into f$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Translate$ (a$, f$, t$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Translate$ (a$, f$, t$) STATIC%@NL@%
        ta$ = a$%@NL@%
        lena% = LEN(ta$)%@NL@%
        lenf% = LEN(f$)%@NL@%
        lent% = LEN(t$)%@NL@%
        IF lena% > 0 AND lenf% > 0 AND lent% > 0 THEN%@NL@%
            FOR i% = 1 TO lena%%@NL@%
                ptr% = INSTR(f$, MID$(ta$, i%, 1))%@NL@%
                IF ptr% THEN%@NL@%
                    MID$(ta$, i%, 1) = MID$(t$, ptr%, 1)%@NL@%
                END IF%@NL@%
            NEXT i%%@NL@%
        END IF%@NL@%
        Translate$ = ta$%@NL@%
        ta$ = ""%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%STRTONUM.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\STRTONUM.BAS%@AE@%%@NL@%
%@NL@%
DECLARE FUNCTION Filter$ (Txt$, FilterString$)%@NL@%
%@NL@%
%@AB@%' Input a line:%@AE@%%@NL@%
LINE INPUT "Enter a number with commas: ", A$%@NL@%
%@NL@%
%@AB@%' Look for only valid numeric characters (0123456789.-) in the%@AE@%%@NL@%
%@AB@%' input string:%@AE@%%@NL@%
CleanNum$ = Filter$(A$, "0123456789.-")%@NL@%
%@NL@%
%@AB@%' Convert the string to a number:%@AE@%%@NL@%
PRINT "The number's value = "; VAL(CleanNum$)%@NL@%
END%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ========================== FILTER ==========================%@AE@%%@NL@%
%@AB@%'         Takes unwanted characters out of a string by%@AE@%%@NL@%
%@AB@%'        comparing them with a filter string containing%@AE@%%@NL@%
%@AB@%'             only acceptable numeric characters%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION Filter$ (Txt$, FilterString$) STATIC%@NL@%
   Temp$ = ""%@NL@%
   TxtLength = LEN(Txt$)%@NL@%
%@NL@%
   FOR I = 1 TO TxtLength     ' Isolate each character in%@NL@%
      C$ = MID$(Txt$, I, 1)   ' the string.%@NL@%
%@NL@%
%@AB@%      ' If the character is in the filter string, save it:%@AE@%%@NL@%
      IF INSTR(FilterString$, C$) <> 0 THEN%@NL@%
         Temp$ = Temp$ + C$%@NL@%
      END IF%@NL@%
   NEXT I%@NL@%
%@NL@%
   Filter$ = Temp$%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TERMINAL.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\TERMINAL.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
DECLARE SUB Filter (InString$)%@NL@%
%@NL@%
COLOR 7, 1                      ' Set screen color.%@NL@%
CLS%@NL@%
%@NL@%
Quit$ = CHR$(0) + CHR$(16)      ' Value returned by INKEY$%@NL@%
%@AB@%                                ' when ALT+q is pressed.%@AE@%%@NL@%
%@NL@%
%@AB@%' Set up prompt on bottom line of screen and turn cursor on:%@AE@%%@NL@%
LOCATE 24, 1, 1%@NL@%
PRINT STRING$(80, "_");%@NL@%
LOCATE 25, 1%@NL@%
PRINT TAB(30); "Press ALT+q to quit";%@NL@%
%@NL@%
VIEW PRINT 1 TO 23              ' Print between lines 1 & 23.%@NL@%
%@NL@%
%@AB@%' Open communications (1200 baud, no parity, 8-bit data,%@AE@%%@NL@%
%@AB@%' 1 stop bit, 256-byte input buffer):%@AE@%%@NL@%
OPEN "COM1:1200,N,8,1" FOR RANDOM AS #1 LEN = 256%@NL@%
%@NL@%
DO                              ' Main communications loop.%@NL@%
%@NL@%
   KeyInput$ = INKEY$           ' Check the keyboard.%@NL@%
%@NL@%
   IF KeyInput$ = Quit$ THEN    ' Exit the loop if the user%@NL@%
      EXIT DO                   ' pressed ALT+q.%@NL@%
%@NL@%
   ELSEIF KeyInput$ <> "" THEN  ' Otherwise, if the user has%@NL@%
      PRINT #1, KeyInput$;      ' pressed a key, send the%@NL@%
   END IF                       ' character typed to the modem.%@NL@%
%@NL@%
%@AB@%   ' Check the modem. If characters are waiting (EOF(1) is%@AE@%%@NL@%
%@AB@%   ' true), get them and print them to the screen:%@AE@%%@NL@%
   IF NOT EOF(1) THEN%@NL@%
%@NL@%
%@AB@%      ' LOC(1) gives the number of characters waiting:%@AE@%%@NL@%
      ModemInput$ = INPUT$(LOC(1), #1)%@NL@%
%@NL@%
      Filter ModemInput$        ' Filter out line feeds and%@NL@%
      PRINT ModemInput$;        ' backspaces, then print.%@NL@%
   END IF%@NL@%
LOOP%@NL@%
%@NL@%
CLOSE                           ' End communications.%@NL@%
CLS%@NL@%
END%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ========================= FILTER ==========================%@AE@%%@NL@%
%@AB@%'     Filters characters in an input string.%@AE@%%@NL@%
%@AB@%' ============================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB Filter (InString$) STATIC%@NL@%
%@NL@%
%@AB@%   ' Look for backspace characters and recode them to%@AE@%%@NL@%
%@AB@%   ' CHR$(29) (the LEFT cursor key):%@AE@%%@NL@%
   DO%@NL@%
      BackSpace = INSTR(Instring$, CHR$(8))%@NL@%
      IF BackSpace THEN%@NL@%
         MID$(InString$, BackSpace) = CHR$(29)%@NL@%
      END IF%@NL@%
   LOOP WHILE BackSpace%@NL@%
%@NL@%
%@AB@%   ' Look for line-feed characters and remove any found:%@AE@%%@NL@%
   DO%@NL@%
      LineFeed = INSTR(Instring$, CHR$(10))%@NL@%
      IF LineFeed THEN%@NL@%
         InString$ = LEFT$(InString$, LineFeed - 1) + _%@NL@%
                      MID$(InString$, LineFeed + 1)%@NL@%
      END IF%@NL@%
   LOOP WHILE LineFeed%@NL@%
%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TOKEN.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\TOKEN.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%' TOKEN.BAS%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' Demonstrates a BASIC version of the strtok C function.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
DECLARE FUNCTION StrTok$(Source$,Delimiters$)%@NL@%
%@NL@%
LINE INPUT "Enter string: ",P$%@NL@%
%@AB@%' Set up the characters that separate tokens.%@AE@%%@NL@%
Delimiters$=" ,;:().?"+CHR$(9)+CHR$(34)%@NL@%
%@AB@%' Invoke StrTok$ with the string to tokenize.%@AE@%%@NL@%
Token$=StrTok$(P$,Delimiters$)%@NL@%
WHILE Token$<>""%@NL@%
   PRINT Token$%@NL@%
%@AB@%   ' Call StrTok$ with a null string so it knows this%@AE@%%@NL@%
%@AB@%   ' isn't the first call.%@AE@%%@NL@%
   Token$=StrTok$("",Delimiters$)%@NL@%
WEND%@NL@%
%@NL@%
FUNCTION StrTok$(Srce$,Delim$)%@NL@%
STATIC Start%, SaveStr$%@NL@%
%@NL@%
%@AB@%   ' If first call, make a copy of the string.%@AE@%%@NL@%
   IF Srce$<>"" THEN%@NL@%
      Start%=1 : SaveStr$=Srce$%@NL@%
   END IF%@NL@%
%@NL@%
   BegPos%=Start% : Ln%=LEN(SaveStr$)%@NL@%
%@AB@%   ' Look for start of a token (character that isn't delimiter).%@AE@%%@NL@%
   WHILE BegPos%<=Ln% AND INSTR(Delim$,MID$(SaveStr$,BegPos%,1))<>0%@NL@%
      BegPos%=BegPos%+1%@NL@%
   WEND%@NL@%
%@AB@%   ' Test for token start found.%@AE@%%@NL@%
   IF BegPos% > Ln% THEN%@NL@%
      StrTok$="" : EXIT FUNCTION%@NL@%
   END IF%@NL@%
%@AB@%   ' Find the end of the token.%@AE@%%@NL@%
   EndPos%=BegPos%%@NL@%
   WHILE EndPos% <= Ln% AND INSTR(Delim$,MID$(SaveStr$,EndPos%,1))=0%@NL@%
      EndPos%=EndPos%+1%@NL@%
   WEND%@NL@%
   StrTok$=MID$(SaveStr$,BegPos%,EndPos%-BegPos%)%@NL@%
%@AB@%   ' Set starting point for search for next token.%@AE@%%@NL@%
   Start%=EndPos%%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%TRIANGLE.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\TRIANGLE.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          TRIANGLE                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        TRIANGLE.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:          No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:   CGA%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:      TRIANGLE.BAS%@AE@%%@NL@%
%@AB@%  '                 QCALMATH.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:     (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:      sA$        User input of side a%@AE@%%@NL@%
%@AB@%  '                 sB$        User input of side b%@AE@%%@NL@%
%@AB@%  '                 sC$        User input of side c%@AE@%%@NL@%
%@AB@%  '                 aA$        User input of angle A%@AE@%%@NL@%
%@AB@%  '                 aB$        User input of angle B%@AE@%%@NL@%
%@AB@%  '                 aC$        User input of angle C%@AE@%%@NL@%
%@AB@%  '                 sA#        Side A%@AE@%%@NL@%
%@AB@%  '                 sB#        Side B%@AE@%%@NL@%
%@AB@%  '                 sC#        Side C%@AE@%%@NL@%
%@AB@%  '                 aA#        Angle A%@AE@%%@NL@%
%@AB@%  '                 aB#        Angle B%@AE@%%@NL@%
%@AB@%  '                 aC#        Angle C%@AE@%%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION Deg2Rad# (deg#)%@NL@%
    DECLARE FUNCTION Rad2Deg# (rad#)%@NL@%
    DECLARE FUNCTION ArcCosine# (x#)%@NL@%
    DECLARE FUNCTION ArcSine# (x#)%@NL@%
    DECLARE FUNCTION TriangleArea# (sA#, sB#, sC#)%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB Triangle (sA#, sB#, sC#, aA#, aB#, aC#)%@NL@%
%@NL@%
%@AB@%  ' Initialization%@AE@%%@NL@%
    SCREEN 2%@NL@%
    CLS%@NL@%
    PRINT "TRIANGLE"%@NL@%
%@NL@%
%@AB@%  ' Draw a representative triangle%@AE@%%@NL@%
    WINDOW (0, 0)-(1, 1)%@NL@%
    LINE (.3, .7)-(.8, .7)%@NL@%
    LINE -(.4, 1)%@NL@%
    LINE -(.3, .7)%@NL@%
%@NL@%
%@AB@%  ' Label the triangle sides%@AE@%%@NL@%
    LOCATE 4, 26%@NL@%
    PRINT "a"%@NL@%
    LOCATE 3, 48%@NL@%
    PRINT "b"%@NL@%
    LOCATE 9, 42%@NL@%
    PRINT "c"%@NL@%
%@NL@%
%@AB@%  ' Label the triangle angles%@AE@%%@NL@%
    LOCATE 7, 55%@NL@%
    PRINT "A"%@NL@%
    LOCATE 7, 28%@NL@%
    PRINT "B"%@NL@%
    LOCATE 2, 33%@NL@%
    PRINT "C"%@NL@%
%@NL@%
%@AB@%  ' Ask user for the known data%@AE@%%@NL@%
    LOCATE 12, 1%@NL@%
    PRINT "Enter known sides and angles (deg),"%@NL@%
    PRINT "and press Enter for unknowns..."%@NL@%
    LOCATE 16, 1%@NL@%
    LINE INPUT "Side  a  "; sA$%@NL@%
    LINE INPUT "Side  b  "; sB$%@NL@%
    LINE INPUT "Side  c  "; sC$%@NL@%
    PRINT%@NL@%
    LINE INPUT "Angle A  "; aA$%@NL@%
    LINE INPUT "Angle B  "; aB$%@NL@%
    LINE INPUT "Angle C  "; aC$%@NL@%
    PRINT%@NL@%
%@NL@%
%@AB@%  ' Convert to numeric values%@AE@%%@NL@%
    sA# = VAL(sA$)%@NL@%
    sB# = VAL(sB$)%@NL@%
    sC# = VAL(sC$)%@NL@%
    aA# = Deg2Rad#(VAL(aA$))%@NL@%
    aB# = Deg2Rad#(VAL(aB$))%@NL@%
    aC# = Deg2Rad#(VAL(aC$))%@NL@%
%@NL@%
%@AB@%  ' Solve for the unknowns%@AE@%%@NL@%
    Triangle sA#, sB#, sC#, aA#, aB#, aC#%@NL@%
%@NL@%
%@AB@%  ' Output the results%@AE@%%@NL@%
    LOCATE 16, 1%@NL@%
    PRINT "Side  a  "; sA#%@NL@%
    PRINT "Side  b  "; sB#%@NL@%
    PRINT "Side  c  "; sC#%@NL@%
    PRINT%@NL@%
    PRINT "Angle A  "; Rad2Deg#(aA#); "Deg"%@NL@%
    PRINT "Angle B  "; Rad2Deg#(aB#); "Deg"%@NL@%
    PRINT "Angle C  "; Rad2Deg#(aC#); "Deg"%@NL@%
    LOCATE 20, 40%@NL@%
    PRINT "Area = "; TriangleArea#(sA#, sB#, sC#)%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    LOCATE 24, 1%@NL@%
    PRINT "Press any key to continue";%@NL@%
    DO%@NL@%
    LOOP WHILE INKEY$ = ""%@NL@%
    SCREEN 0%@NL@%
    END%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Deg2Rad#                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        TRIANGLE.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Converts degree angular units to radians.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  r# = Deg2Rad#(deg#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      deg#       Degrees%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Deg2Rad# (deg#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Deg2Rad# (deg#) STATIC%@NL@%
        Deg2Rad# = deg# / 57.29577951308232#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Rad2Deg#                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        TRIANGLE.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Converts radian angular units to degrees.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  d# = Rad2Deg#(rad#)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      rad#       Radians%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       (none)%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION Rad2Deg# (rad#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION Rad2Deg# (rad#) STATIC%@NL@%
        Rad2Deg# = rad# * 57.29577951308232#%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Triangle                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        TRIANGLE.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Calculates all sides and angles of a triangle,%@AE@%%@NL@%
%@AB@%  ' assuming enough sides and angles are given.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Triangle sA#, sB#, sC#, aA#, aB#, aC#%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      sA#        Side A%@AE@%%@NL@%
%@AB@%  '                  sB#        Side B%@AE@%%@NL@%
%@AB@%  '                  sC#        Side C%@AE@%%@NL@%
%@AB@%  '                  aA#        Angle A%@AE@%%@NL@%
%@AB@%  '                  aB#        Angle B%@AE@%%@NL@%
%@AB@%  '                  aC#        Angle C%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       i%         Looping index%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB Triangle (sA#, sB#, sC#, aA#, aB#, aC#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Triangle (sA#, sB#, sC#, aA#, aB#, aC#) STATIC%@NL@%
%@NL@%
        FOR i% = 1 TO 18%@NL@%
%@NL@%
            IF aA# = 0# THEN%@NL@%
                IF sA# <> 0# AND sB# <> 0# AND sC# <> 0# THEN%@NL@%
                    t# = sB# * sB# + sC# * sC# - sA# * sA#%@NL@%
                    aA# = ArcCosine#(t# / 2# / sB# / sC#)%@NL@%
                END IF%@NL@%
            END IF%@NL@%
%@NL@%
            IF aB# = 0# THEN%@NL@%
                IF sA# <> 0# AND sB# <> 0# AND aA# <> 0# THEN%@NL@%
                    aB# = ArcSine#(sB# * SIN(aA#) / sA#)%@NL@%
                END IF%@NL@%
            END IF%@NL@%
%@NL@%
            IF aC# = 0# THEN%@NL@%
                IF aA# <> 0# AND aB# <> 0# THEN%@NL@%
                    aC# = 3.141592653589793# - aA# - aB#%@NL@%
                END IF%@NL@%
            END IF%@NL@%
%@NL@%
            IF sB# = 0# THEN%@NL@%
                IF sA# <> 0# AND aB# <> 0# AND aA# <> 0# THEN%@NL@%
                    sB# = sA# * SIN(aB#) / SIN(aA#)%@NL@%
                END IF%@NL@%
            END IF%@NL@%
%@NL@%
            IF sC# = 0# THEN%@NL@%
                IF sA# <> 0# AND sB# <> 0# AND aC# <> 0# THEN%@NL@%
                    t# = sA# * sA# + sB# * sB#%@NL@%
                    sC# = SQR(t# - 2# * sA# * sB# * COS(aC#))%@NL@%
                END IF%@NL@%
            END IF%@NL@%
%@NL@%
            IF i% MOD 2 THEN%@NL@%
                SWAP sB#, sC#%@NL@%
                SWAP aB#, aC#%@NL@%
            ELSE%@NL@%
                SWAP sA#, sB#%@NL@%
                SWAP aA#, aB#%@NL@%
            END IF%@NL@%
%@NL@%
        NEXT i%%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          TriangleArea#              **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        TRIANGLE.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the area of a triangle given the three sides.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  TriangleArea# sA#, sB#, sC#%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      sA#        Side A%@AE@%%@NL@%
%@AB@%  '                  sB#        Side B%@AE@%%@NL@%
%@AB@%  '                  sC#        Side C%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       s#         Sum of the three sides of the triangle%@AE@%%@NL@%
%@AB@%  '                             divided by two%@AE@%%@NL@%
%@AB@%  '                  t1#        Temporary variable%@AE@%%@NL@%
%@AB@%  '                  t2#        Temporary variable%@AE@%%@NL@%
%@AB@%  '                  t3#        Temporary variable%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION TriangleArea# (sA#, sB#, sC#)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION TriangleArea# (sA#, sB#, sC#) STATIC%@NL@%
        s# = (sA# + sB# + sC#) / 2#%@NL@%
        t1# = s# - sA#%@NL@%
        t2# = s# - sB#%@NL@%
        t3# = s# - sC#%@NL@%
        TriangleArea# = SQR(s# * t1# * t2# * t3#)%@NL@%
    END FUNCTION%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WHEREIS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\SRCDISK\WHEREIS.BAS%@AE@%%@NL@%
%@NL@%
DEFINT A-Z%@NL@%
%@NL@%
%@AB@%' Declare symbolic constants used in program:%@AE@%%@NL@%
CONST EOFTYPE = 0, FILETYPE = 1, DIRTYPE = 2, ROOT = "TWH"%@NL@%
%@NL@%
DECLARE SUB ScanDir (PathSpec$, Level, FileSpec$, Row)%@NL@%
%@NL@%
DECLARE FUNCTION MakeFileName$ (Num)%@NL@%
DECLARE FUNCTION GetEntry$ (FileNum, EntryType)%@NL@%
%@NL@%
CLS%@NL@%
INPUT "File to look for"; FileSpec$%@NL@%
PRINT%@NL@%
PRINT "Enter the directory where the search should start"%@NL@%
PRINT "(optional drive + directories). Press <ENTER> to begin"%@NL@%
PRINT "the search in the root directory of the current drive."%@NL@%
PRINT%@NL@%
INPUT "Starting directory"; PathSpec$%@NL@%
CLS%@NL@%
%@NL@%
RightCh$ = RIGHT$(PathSpec$, 1)%@NL@%
%@NL@%
IF PathSpec$ = "" OR RightCh$ = ":" OR RightCh$ <> "\" THEN%@NL@%
   PathSpec$ = PathSpec$ + "\"%@NL@%
END IF%@NL@%
%@NL@%
FileSpec$ = UCASE$(FileSpec$)%@NL@%
PathSpec$ = UCASE$(PathSpec$)%@NL@%
Level = 1%@NL@%
Row = 3%@NL@%
%@NL@%
%@AB@%' Make the top level call (level 1) to begin the search:%@AE@%%@NL@%
ScanDir PathSpec$, Level, FileSpec$, Row%@NL@%
%@NL@%
KILL ROOT + ".*"        ' Delete all temporary files created%@NL@%
%@AB@%                        ' by the program.%@AE@%%@NL@%
%@NL@%
LOCATE Row + 1, 1: PRINT "Search complete."%@NL@%
END%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================= GETENTRY ==========================%@AE@%%@NL@%
%@AB@%'    This procedure processes entry lines in a DIR listing%@AE@%%@NL@%
%@AB@%'    saved to a file.%@AE@%%@NL@%
%@AB@%' ===========================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION GetEntry$ (FileNum, EntryType) STATIC%@NL@%
%@NL@%
%@AB@%   ' Loop until a valid entry or end-of-file (EOF) is read:%@AE@%%@NL@%
   DO UNTIL EOF(FileNum)%@NL@%
      LINE INPUT #FileNum, EntryLine$%@NL@%
      IF EntryLine$ <> "" THEN%@NL@%
%@NL@%
%@AB@%         ' Get first character from the line for test:%@AE@%%@NL@%
         TestCh$ = LEFT$(EntryLine$, 1)%@NL@%
         IF TestCh$ <> " " AND TestCh$ <> "." THEN EXIT DO%@NL@%
      END IF%@NL@%
   LOOP%@NL@%
%@NL@%
%@AB@%   ' Entry or EOF found, decide which:%@AE@%%@NL@%
   IF EOF(FileNum) THEN%@NL@%
      EntryType = EOFTYPE%@NL@%
      GetEntry$ = ""%@NL@%
%@NL@%
   ELSE           ' Not EOF, either a file or a directory.%@NL@%
%@NL@%
%@AB@%      ' Build and return the entry name:%@AE@%%@NL@%
      EntryName$ = RTRIM$(LEFT$(EntryLine$, 8))%@NL@%
%@NL@%
%@AB@%      ' Test for extension and add to name if there is one:%@AE@%%@NL@%
      EntryExt$ = RTRIM$(MID$(EntryLine$, 10, 3))%@NL@%
      IF EntryExt$ <> "" THEN%@NL@%
         GetEntry$ = EntryName$ + "." + EntryExt$%@NL@%
      ELSE%@NL@%
         GetEntry$ = EntryName$%@NL@%
      END IF%@NL@%
%@NL@%
%@AB@%      ' Determine the entry type, and return that%@AE@%%@NL@%
%@AB@%      ' value to the point where GetEntry$ was called:%@AE@%%@NL@%
      IF MID$(EntryLine$, 15, 3) = "DIR" THEN%@NL@%
         EntryType = DIRTYPE            ' Directory%@NL@%
      ELSE%@NL@%
         EntryType = FILETYPE           ' File%@NL@%
      END IF%@NL@%
%@NL@%
   END IF%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ===================== MAKEFILENAME$ =======================%@AE@%%@NL@%
%@AB@%'    This procedure makes a file name from a root string%@AE@%%@NL@%
%@AB@%'    ("TWH" - defined as a symbolic constant at the module%@AE@%%@NL@%
%@AB@%'    level) and a number passed to it as an argument (Num).%@AE@%%@NL@%
%@AB@%' ===========================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
FUNCTION MakeFileName$ (Num) STATIC%@NL@%
%@NL@%
   MakeFileName$ = ROOT + "." + LTRIM$(STR$(Num))%@NL@%
%@NL@%
END FUNCTION%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%' ======================= SCANDIR ===========================%@AE@%%@NL@%
%@AB@%'   This procedure recursively scans a directory for the%@AE@%%@NL@%
%@AB@%'   file name entered by the user.%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
%@AB@%'   NOTE: The SUB header doesn't use the STATIC keyword%@AE@%%@NL@%
%@AB@%'         since this procedure needs a new set of variables%@AE@%%@NL@%
%@AB@%'         each time it is invoked.%@AE@%%@NL@%
%@AB@%' ===========================================================%@AE@%%@NL@%
%@AB@%'%@AE@%%@NL@%
SUB ScanDir (PathSpec$, Level, FileSpec$, Row)%@NL@%
%@NL@%
   LOCATE 1, 1: PRINT "Now searching"; SPACE$(50);%@NL@%
   LOCATE 1, 15: PRINT PathSpec$;%@NL@%
%@NL@%
%@AB@%   ' Make a file specification for the temporary file:%@AE@%%@NL@%
   TempSpec$ = MakeFileName$(Level)%@NL@%
%@NL@%
%@AB@%   ' Get a directory listing of the current directory, and%@AE@%%@NL@%
%@AB@%   ' save it in the temporary file:%@AE@%%@NL@%
   SHELL "DIR " + PathSpec$ + " > " + TempSpec$%@NL@%
%@NL@%
%@AB@%   ' Get the next available file number:%@AE@%%@NL@%
   FileNum = FREEFILE%@NL@%
%@NL@%
%@AB@%   ' Open the DIR listing file and scan it:%@AE@%%@NL@%
   OPEN TempSpec$ FOR INPUT AS #FileNum%@NL@%
%@NL@%
%@AB@%   ' Process the file, one line at a time:%@AE@%%@NL@%
   DO%@NL@%
%@NL@%
%@AB@%      ' Get an entry from the DIR listing:%@AE@%%@NL@%
      DirEntry$ = GetEntry$(FileNum, EntryType)%@NL@%
%@NL@%
%@AB@%      ' If entry is a file:%@AE@%%@NL@%
      IF EntryType = FILETYPE THEN%@NL@%
%@NL@%
%@AB@%         ' If the FileSpec$ string matches, print entry and%@AE@%%@NL@%
%@AB@%         ' exit this loop:%@AE@%%@NL@%
         IF DirEntry$ = FileSpec$ THEN%@NL@%
            LOCATE Row, 1: PRINT PathSpec$; DirEntry$;%@NL@%
            Row = Row + 1%@NL@%
            EntryType = EOFTYPE%@NL@%
         END IF%@NL@%
%@NL@%
%@AB@%      ' If the entry is a directory, then make a recursive%@AE@%%@NL@%
%@AB@%      ' call to ScanDir with the new directory:%@AE@%%@NL@%
      ELSEIF EntryType = DIRTYPE THEN%@NL@%
         NewPath$ = PathSpec$ + DirEntry$ + "\"%@NL@%
         ScanDir NewPath$, Level + 1, FileSpec$, Row%@NL@%
         LOCATE 1, 1: PRINT "Now searching"; SPACE$(50);%@NL@%
         LOCATE 1, 15: PRINT PathSpec$;%@NL@%
      END IF%@NL@%
%@NL@%
   LOOP UNTIL EntryType = EOFTYPE%@NL@%
%@NL@%
%@AB@%   ' Scan on this DIR listing file is finished, so close it:%@AE@%%@NL@%
   CLOSE FileNum%@NL@%
END SUB%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WINDOWS.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\WINDOWS.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          WINDOWS                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        WINDOWS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' USAGE:           No command line parameters%@AE@%%@NL@%
%@AB@%  ' REQUIREMENTS:    MIXED.QLB/.LIB%@AE@%%@NL@%
%@AB@%  '                  Mouse (optional)%@AE@%%@NL@%
%@AB@%  ' .MAK FILES:      WINDOWS.BAS%@AE@%%@NL@%
%@AB@%  '                  BITS.BAS%@AE@%%@NL@%
%@AB@%  '                  BIOSCALL.BAS%@AE@%%@NL@%
%@AB@%  '                  MOUSSUBS.BAS%@AE@%%@NL@%
%@AB@%  '                  KEYS.BAS%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       w1         Structure of type WindowsType%@AE@%%@NL@%
%@AB@%  '                  w2         Structure of type WindowsType%@AE@%%@NL@%
%@AB@%  '                  w3         Structure of type WindowsType%@AE@%%@NL@%
%@AB@%  '                  w1Text$()  Strings to display in first window%@AE@%%@NL@%
%@AB@%  '                  w2Text$()  Strings to display in second window%@AE@%%@NL@%
%@AB@%  '                  w3Text$()  Strings to display in third window%@AE@%%@NL@%
%@AB@%  '                  w1Title$   Title string for first window%@AE@%%@NL@%
%@AB@%  '                  w1Prompt$  Prompt string for first window%@AE@%%@NL@%
%@AB@%  '                  w2Title$   Title string for second window%@AE@%%@NL@%
%@AB@%  '                  w2Prompt$  Prompt string for second window%@AE@%%@NL@%
%@AB@%  '                  w3Title$   Title string for third window%@AE@%%@NL@%
%@AB@%  '                  arrow$     String showing up and down arrows%@AE@%%@NL@%
%@AB@%  '                  entSymbol$ String showing the Enter key symbol%@AE@%%@NL@%
%@AB@%  '                  w3Prompt$  Prompt string for third window%@AE@%%@NL@%
%@AB@%  '                  i%         Looping index%@AE@%%@NL@%
%@AB@%  '                  t0         Timer value%@AE@%%@NL@%
%@NL@%
%@NL@%
%@AB@%  ' Define color constants%@AE@%%@NL@%
    CONST BLACK = 0%@NL@%
    CONST BLUE = 1%@NL@%
    CONST GREEN = 2%@NL@%
    CONST CYAN = 3%@NL@%
    CONST RED = 4%@NL@%
    CONST MAGENTA = 5%@NL@%
    CONST BROWN = 6%@NL@%
    CONST WHITE = 7%@NL@%
    CONST BRIGHT = 8%@NL@%
    CONST BLINK = 16%@NL@%
    CONST YELLOW = BROWN + BRIGHT%@NL@%
%@NL@%
    TYPE WindowsType%@NL@%
        action       AS INTEGER%@NL@%
        edgeLine     AS INTEGER%@NL@%
        row          AS INTEGER%@NL@%
        col          AS INTEGER%@NL@%
        fgdEdge      AS INTEGER%@NL@%
        bgdEdge      AS INTEGER%@NL@%
        fgdBody      AS INTEGER%@NL@%
        bgdBody      AS INTEGER%@NL@%
        fgdHighlight AS INTEGER%@NL@%
        bgdHighlight AS INTEGER%@NL@%
        fgdTitle     AS INTEGER%@NL@%
        bgdTitle     AS INTEGER%@NL@%
        fgdPrompt    AS INTEGER%@NL@%
        bgdPrompt    AS INTEGER%@NL@%
        returnCode   AS INTEGER%@NL@%
    END TYPE%@NL@%
%@NL@%
%@AB@%  ' Functions%@AE@%%@NL@%
    DECLARE FUNCTION InKeyCode% ()%@NL@%
%@NL@%
%@AB@%  ' Subprograms%@AE@%%@NL@%
    DECLARE SUB Windows (w AS WindowsType, wText$(), wTitle$, wPrompt$)%@NL@%
    DECLARE SUB WindowsPop ()%@NL@%
    DECLARE SUB VideoState (mode%, columns%, page%)%@NL@%
    DECLARE SUB Mouse (m1%, m2%, m3%, m4%)%@NL@%
    DECLARE SUB MouseMickey (horizontal%, vertical%)%@NL@%
    DECLARE SUB MouseNow (leftButton%, rightButton%, xMouse%, yMouse%)%@NL@%
%@NL@%
%@AB@%  ' Data structures%@AE@%%@NL@%
    DIM w1 AS WindowsType%@NL@%
    DIM w2 AS WindowsType%@NL@%
    DIM w3 AS WindowsType%@NL@%
%@NL@%
%@AB@%  ' Arrays%@AE@%%@NL@%
    DIM w1Text$(1 TO 5)%@NL@%
    DIM w2Text$(1 TO 3)%@NL@%
    DIM w3Text$(1 TO 9)%@NL@%
%@NL@%
%@AB@%  ' Define first window%@AE@%%@NL@%
    w1.action = 0%@NL@%
    w1.edgeLine = 1%@NL@%
    w1.row = 2%@NL@%
    w1.col = 3%@NL@%
    w1.fgdEdge = YELLOW%@NL@%
    w1.bgdEdge = BLUE%@NL@%
    w1.fgdBody = BRIGHT + WHITE%@NL@%
    w1.bgdBody = BLUE%@NL@%
    w1.fgdHighlight = 0%@NL@%
    w1.bgdHighlight = 0%@NL@%
    w1.fgdTitle = YELLOW%@NL@%
    w1.bgdTitle = BLUE%@NL@%
    w1.fgdPrompt = YELLOW%@NL@%
    w1.bgdPrompt = BLUE%@NL@%
    w1Title$ = " First Window "%@NL@%
    w1Text$(1) = "This window demonstrates how information"%@NL@%
    w1Text$(2) = "can be displayed without requesting any"%@NL@%
    w1Text$(3) = "response from the user.  The action code"%@NL@%
    w1Text$(4) = "is 0, causing an immediate return to the"%@NL@%
    w1Text$(5) = "program after the window is displayed."%@NL@%
    w1Prompt$ = ""%@NL@%
%@NL@%
%@AB@%  ' Define second window%@AE@%%@NL@%
    w2.action = 1%@NL@%
    w2.edgeLine = 2%@NL@%
    w2.row = 10%@NL@%
    w2.col = 12%@NL@%
    w2.fgdEdge = CYAN + BRIGHT%@NL@%
    w2.bgdEdge = BLACK%@NL@%
    w2.fgdBody = YELLOW%@NL@%
    w2.bgdBody = BLACK%@NL@%
    w2.fgdHighlight = 0%@NL@%
    w2.bgdHighlight = 0%@NL@%
    w2.fgdTitle = CYAN + BRIGHT%@NL@%
    w2.bgdTitle = BLUE%@NL@%
    w2.fgdPrompt = CYAN + BRIGHT%@NL@%
    w2.bgdPrompt = BLUE%@NL@%
    w2Title$ = " Second window, action code is 1 "%@NL@%
    w2Text$(1) = "This window waits for the user to press"%@NL@%
    w2Text$(2) = "any key before continuing.  The key code"%@NL@%
    w2Text$(3) = "is passed back to the calling program."%@NL@%
    w2Prompt$ = " Press any key to continue. "%@NL@%
%@NL@%
%@AB@%  ' Define third window%@AE@%%@NL@%
    w3.action = 2%@NL@%
    w3.edgeLine = 2%@NL@%
    w3.row = 7%@NL@%
    w3.col = 15%@NL@%
    w3.fgdEdge = YELLOW%@NL@%
    w3.bgdEdge = WHITE%@NL@%
    w3.fgdBody = BLACK%@NL@%
    w3.bgdBody = WHITE%@NL@%
    w3.fgdHighlight = WHITE + BRIGHT%@NL@%
    w3.bgdHighlight = BLACK%@NL@%
    w3.fgdTitle = YELLOW%@NL@%
    w3.bgdTitle = WHITE%@NL@%
    w3.fgdPrompt = YELLOW%@NL@%
    w3.bgdPrompt = WHITE%@NL@%
    w3Title$ = " Third window, action is 2 (menu selection) "%@NL@%
    arrows$ = CHR$(24) + " " + CHR$(25) + " "%@NL@%
    entSymbol$ = CHR$(17) + CHR$(196) + CHR$(217)%@NL@%
    w3Prompt$ = " <Character> " + arrows$ + entSymbol$ + " or use mouse "%@NL@%
    w3Text$(1) = "1. This is the first line in the window."%@NL@%
    w3Text$(2) = "2. This is the second."%@NL@%
    w3Text$(3) = "3. This is the third line."%@NL@%
    w3Text$(4) = "4. The fourth."%@NL@%
    w3Text$(5) = "5. The fifth."%@NL@%
    w3Text$(6) = "A. You can press <A> or <a> to select this line."%@NL@%
    w3Text$(7) = "B. You can press <1> to <5> for one of the first 5 lines."%@NL@%
    w3Text$(8) = "C. Try moving the cursor up or down and pressing Enter."%@NL@%
    w3Text$(9) = "D. Also, try the mouse. Click with left button."%@NL@%
%@NL@%
%@AB@%  ' Initialize the display%@AE@%%@NL@%
    SCREEN 0, , 0, 0%@NL@%
    WIDTH 80%@NL@%
    CLS%@NL@%
    FOR i% = 1 TO 20%@NL@%
        PRINT STRING$(80, 178)%@NL@%
    NEXT i%%@NL@%
    LOCATE 6, 24%@NL@%
    PRINT " * Windows toolbox demonstration * "%@NL@%
%@NL@%
%@AB@%  ' Wait for any key to be pressed%@AE@%%@NL@%
    LOCATE 22, 1%@NL@%
    PRINT "Press any key to continue"%@NL@%
    DO%@NL@%
    LOOP UNTIL INKEY$ <> ""%@NL@%
%@NL@%
%@AB@%  ' Clear the "press any key" prompt%@AE@%%@NL@%
    LOCATE 22, 1%@NL@%
    PRINT SPACE$(25)%@NL@%
%@NL@%
%@AB@%  ' Create the three windows%@AE@%%@NL@%
    Windows w1, w1Text$(), w1Title$, w1Prompt$%@NL@%
    Windows w2, w2Text$(), w2Title$, w2Prompt$%@NL@%
    Windows w3, w3Text$(), w3Title$, w3Prompt$%@NL@%
%@NL@%
%@AB@%  ' Display the result codes, and erase each window%@AE@%%@NL@%
    FOR i% = 1 TO 4%@NL@%
        LOCATE 21, 1%@NL@%
        COLOR WHITE, BLACK%@NL@%
        PRINT "The three return codes...";%@NL@%
        PRINT w1.returnCode; w2.returnCode; w3.returnCode%@NL@%
        COLOR YELLOW%@NL@%
        PRINT "Every five seconds another window will disappear..."%@NL@%
        COLOR WHITE, BLACK%@NL@%
        t0 = TIMER%@NL@%
        DO%@NL@%
        LOOP UNTIL TIMER - t0 > 5%@NL@%
        WindowsPop%@NL@%
    NEXT i%%@NL@%
%@NL@%
%@AB@%  ' All done%@AE@%%@NL@%
    CLS%@NL@%
    END%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Windows                    **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        WINDOWS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Displays a rectangular window for information display%@AE@%%@NL@%
%@AB@%  ' or menu selection.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  Windows w1, wText$(), wTitle$, wPrompt$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      w1            Structure of type WindowsType%@AE@%%@NL@%
%@AB@%  '                  wTest$()      Array of strings to be displayed%@AE@%%@NL@%
%@AB@%  '                  wTitle$       Title string%@AE@%%@NL@%
%@AB@%  '                  wPrompt$      Prompt string%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       mode%         Current video mode%@AE@%%@NL@%
%@AB@%  '                  columns%      Current number of character columns%@AE@%%@NL@%
%@AB@%  '                  page%         Current video page%@AE@%%@NL@%
%@AB@%  '                  cursorRow%    Saved cursor row position%@AE@%%@NL@%
%@AB@%  '                  cursorCol%    Saved cursor column position%@AE@%%@NL@%
%@AB@%  '                  newpage%      Next video page%@AE@%%@NL@%
%@AB@%  '                  lbText%       Lower boundary of array of text lines%@AE@%%@NL@%
%@AB@%  '                  ubText%       Upper boundary of array of text lines%@AE@%%@NL@%
%@AB@%  '                  i%            Looping index%@AE@%%@NL@%
%@AB@%  '                  maxlen%       Length of longest string to display%@AE@%%@NL@%
%@AB@%  '                  length%       Length of each array string%@AE@%%@NL@%
%@AB@%  '                  row2%         Row number at bottom right corner of window%@AE@%%@NL@%
%@AB@%  '                  col2%         Column number at bottom right corner of%@AE@%%@NL@%
%@AB@%  '                                window%@AE@%%@NL@%
%@AB@%  '                  ul%           Upper left corner border character code%@AE@%%@NL@%
%@AB@%  '                  ur%           Upper right corner border character code%@AE@%%@NL@%
%@AB@%  '                  ll%           Lower left corner border character code%@AE@%%@NL@%
%@AB@%  '                  lr%           Lower right corner border character code%@AE@%%@NL@%
%@AB@%  '                  vl%           Vertical border character code%@AE@%%@NL@%
%@AB@%  '                  hl%           Horizontal border character code%@AE@%%@NL@%
%@AB@%  '                  r%            Index to each line of text%@AE@%%@NL@%
%@AB@%  '                  ptr%          Highlighted line pointer%@AE@%%@NL@%
%@AB@%  '                  lastPtr%      Last highlighted line%@AE@%%@NL@%
%@AB@%  '                  horizontal%   Horizontal mouse mickies%@AE@%%@NL@%
%@AB@%  '                  vertical%     Vertical mouse mickies%@AE@%%@NL@%
%@AB@%  '                  mickies       Accumulated vertical mickies%@AE@%%@NL@%
%@AB@%  '                  choice$       Set of unique characters for each menu line%@AE@%%@NL@%
%@AB@%  '                  tmp$          Work string%@AE@%%@NL@%
%@AB@%  '                  kee%          Key code returned by InKeyCode% function%@AE@%%@NL@%
%@AB@%  '                  leftButton%   Mouse left button state%@AE@%%@NL@%
%@AB@%  '                  rightButton%  Mouse right button state%@AE@%%@NL@%
%@AB@%  '                  xMouse%       Mouse X position%@AE@%%@NL@%
%@AB@%  '                  yMouse%       Mouse Y position%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  SUB Windows (w AS WindowsType, wText$(), wTitle$,%@AE@%%@NL@%
%@AB@%  '                               wPrompt$) STATIC%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB Windows (w AS WindowsType, wText$(), wTitle$, wPrompt$) STATIC%@NL@%
%@AB@%      ' Key code numbers%@AE@%%@NL@%
        CONST DOWNARROW = 20480%@NL@%
        CONST ENTER = 13%@NL@%
        CONST ESCAPE = 27%@NL@%
        CONST UPARROW = 18432%@NL@%
%@NL@%
%@AB@%      ' Determine current video page%@AE@%%@NL@%
        VideoState mode%, columns%, page%%@NL@%
%@NL@%
%@AB@%      ' Record current cursor location%@AE@%%@NL@%
        cursorRow% = CSRLIN%@NL@%
        cursorCol% = POS(0)%@NL@%
%@NL@%
%@AB@%      ' Window will be on the next page, if available%@AE@%%@NL@%
        newpage% = page% + 1%@NL@%
        IF newpage% > 7 THEN%@NL@%
            SCREEN , , 0, 0%@NL@%
            PRINT "Error: Windows - not enough video pages"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Copy current page to new page%@AE@%%@NL@%
        PCOPY page%, newpage%%@NL@%
%@NL@%
%@AB@%      ' Show the current page while building window on new page%@AE@%%@NL@%
        SCREEN , , newpage%, page%%@NL@%
%@NL@%
%@AB@%      ' Determine array bounds%@AE@%%@NL@%
        lbText% = LBOUND(wText$)%@NL@%
        ubText% = UBOUND(wText$)%@NL@%
%@NL@%
%@AB@%      ' Check the text array bounds, lower always 1, upper > 0%@AE@%%@NL@%
        IF lbText% <> 1 OR ubText% < 1 THEN%@NL@%
            SCREEN , , 0, 0%@NL@%
            PRINT "Error: Windows - text array dimensioned incorrectly"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Determine longest string in the text array%@AE@%%@NL@%
        maxLen% = 0%@NL@%
        FOR i% = lbText% TO ubText%%@NL@%
            length% = LEN(wText$(i%))%@NL@%
            IF length% > maxLen% THEN%@NL@%
                maxLen% = length%%@NL@%
            END IF%@NL@%
        NEXT i%%@NL@%
%@NL@%
%@AB@%      ' Determine the bottom right corner of window%@AE@%%@NL@%
        row2% = w.row + ubText% + 1%@NL@%
        col2% = w.col + maxLen% + 3%@NL@%
%@NL@%
%@AB@%      ' Check that window is on screen%@AE@%%@NL@%
        IF w.row < 1 OR w.col < 1 OR row2% > 25 OR col2% > columns% THEN%@NL@%
            SCREEN , , 0, 0%@NL@%
            PRINT "Error: Windows - part of window is off screen"%@NL@%
            SYSTEM%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Set the edge characters%@AE@%%@NL@%
        SELECT CASE w.edgeLine%@NL@%
        CASE 0%@NL@%
            ul% = 32%@NL@%
            ur% = 32%@NL@%
            ll% = 32%@NL@%
            lr% = 32%@NL@%
            vl% = 32%@NL@%
            hl% = 32%@NL@%
        CASE 1%@NL@%
            ul% = 218%@NL@%
            ur% = 191%@NL@%
            ll% = 192%@NL@%
            lr% = 217%@NL@%
            vl% = 179%@NL@%
            hl% = 196%@NL@%
        CASE 2%@NL@%
            ul% = 201%@NL@%
            ur% = 187%@NL@%
            ll% = 200%@NL@%
            lr% = 188%@NL@%
            vl% = 186%@NL@%
            hl% = 205%@NL@%
        CASE ELSE%@NL@%
            SCREEN , , 0, 0%@NL@%
            PRINT "Error: Windows - Edge line type incorrect"%@NL@%
            SYSTEM%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%      ' Draw top edge of the box%@AE@%%@NL@%
        LOCATE w.row, w.col, 0%@NL@%
        COLOR w.fgdEdge, w.bgdEdge%@NL@%
        PRINT CHR$(ul%); STRING$(maxLen% + 2, hl%); CHR$(ur%);%@NL@%
%@NL@%
%@AB@%      ' Draw the body of the window%@AE@%%@NL@%
        FOR r% = w.row + 1 TO row2% - 1%@NL@%
            LOCATE r%, w.col, 0%@NL@%
            COLOR w.fgdEdge, w.bgdEdge%@NL@%
            PRINT CHR$(vl%);%@NL@%
            COLOR w.fgdBody, w.bgdBody%@NL@%
            tmp$ = LEFT$(wText$(r% - w.row) + SPACE$(maxLen%), maxLen%)%@NL@%
            PRINT " "; tmp$; " ";%@NL@%
            COLOR w.fgdEdge, w.bgdEdge%@NL@%
            PRINT CHR$(vl%);%@NL@%
        NEXT r%%@NL@%
%@NL@%
%@AB@%      ' Draw bottom edge of the box%@AE@%%@NL@%
        LOCATE row2%, w.col, 0%@NL@%
        COLOR w.fgdEdge, w.bgdEdge%@NL@%
        PRINT CHR$(ll%); STRING$(maxLen% + 2, hl%); CHR$(lr%);%@NL@%
%@NL@%
%@AB@%      ' Center and print top title if present%@AE@%%@NL@%
        IF wTitle$ <> "" THEN%@NL@%
            LOCATE w.row, (w.col + col2% - LEN(wTitle$) + 1) \ 2, 0%@NL@%
            COLOR w.fgdTitle, w.bgdTitle%@NL@%
            PRINT wTitle$;%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Center and print prompt if present%@AE@%%@NL@%
        IF wPrompt$ <> "" THEN%@NL@%
            LOCATE row2%, (w.col + col2% - LEN(wPrompt$) + 1) \ 2, 0%@NL@%
            COLOR w.fgdPrompt, w.bgdPrompt%@NL@%
            PRINT wPrompt$;%@NL@%
        END IF%@NL@%
%@NL@%
%@AB@%      ' Now make the new page visible and active%@AE@%%@NL@%
        SCREEN , , newpage%, newpage%%@NL@%
%@NL@%
%@AB@%      ' Take next action based on action code%@AE@%%@NL@%
        SELECT CASE w.action%@NL@%
        CASE 1%@NL@%
%@NL@%
%@AB@%          ' Get a key code number and return it%@AE@%%@NL@%
            DO%@NL@%
                w.returnCode = InKeyCode%%@NL@%
            LOOP UNTIL w.returnCode%@NL@%
%@NL@%
        CASE 2%@NL@%
%@NL@%
%@AB@%          ' Set choice pointer to last selection if known%@AE@%%@NL@%
            IF w.returnCode > 0 AND w.returnCode < ubText% THEN%@NL@%
                ptr% = w.returnCode%@NL@%
            ELSE%@NL@%
                ptr% = 1%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Start with last pointer different, to update highlighting%@AE@%%@NL@%
            IF ptr% > 1 THEN%@NL@%
                lastPtr% = 1%@NL@%
            ELSE%@NL@%
                lastPtr% = 2%@NL@%
            END IF%@NL@%
%@NL@%
%@AB@%          ' Clear any mouse mickey counts%@AE@%%@NL@%
            MouseMickey horizontal%, vertical%%@NL@%
            mickies% = 0%@NL@%
%@NL@%
%@AB@%          ' Create unique key selection string%@AE@%%@NL@%
            choice$ = ""%@NL@%
            FOR i% = 1 TO ubText%%@NL@%
                tmp$ = UCASE$(LTRIM$(wText$(i%)))%@NL@%
                DO%@NL@%
                    IF tmp$ <> "" THEN%@NL@%
                        t$ = LEFT$(tmp$, 1)%@NL@%
                        tmp$ = MID$(tmp$, 2)%@NL@%
                        IF INSTR(choice$, t$) = 0 THEN%@NL@%
                            choice$ = choice$ + t$%@NL@%
                        END IF%@NL@%
                    ELSE%@NL@%
                        SCREEN 0, , 0%@NL@%
                        PRINT "Error: Windows - No unique character"%@NL@%
                        SYSTEM%@NL@%
                    END IF%@NL@%
                LOOP UNTIL LEN(choice$) = i%%@NL@%
            NEXT i%%@NL@%
%@NL@%
%@AB@%          ' Main loop, monitor mouse and keyboard%@AE@%%@NL@%
            DO%@NL@%
%@NL@%
%@AB@%              ' Add the mouse mickies%@AE@%%@NL@%
                MouseMickey horizontal%, vertical%%@NL@%
                mickies% = mickies% + vertical%%@NL@%
%@NL@%
%@AB@%              ' Check for enough mickies%@AE@%%@NL@%
                IF mickies% < -17 THEN%@NL@%
                    mickies% = 0%@NL@%
                    IF ptr% > 1 THEN%@NL@%
                        ptr% = ptr% - 1%@NL@%
                    END IF%@NL@%
                ELSEIF mickies% > 17 THEN%@NL@%
                    mickies% = 0%@NL@%
                    IF ptr% < ubText% THEN%@NL@%
                        ptr% = ptr% + 1%@NL@%
                    END IF%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Check keyboard%@AE@%%@NL@%
                kee% = InKeyCode%%@NL@%
                IF kee% >= ASC("a") AND kee% <= ASC("z") THEN%@NL@%
                    kee% = ASC(UCASE$(CHR$(kee%)))%@NL@%
                END IF%@NL@%
                SELECT CASE kee%%@NL@%
                CASE UPARROW%@NL@%
                    IF ptr% > 1 THEN%@NL@%
                        ptr% = ptr% - 1%@NL@%
                    END IF%@NL@%
                CASE DOWNARROW%@NL@%
                    IF ptr% < ubText% THEN%@NL@%
                        ptr% = ptr% + 1%@NL@%
                    END IF%@NL@%
                CASE ENTER%@NL@%
                    w.returnCode = ptr%%@NL@%
                CASE ESCAPE%@NL@%
                    w.returnCode = -1%@NL@%
                CASE ELSE%@NL@%
                    w.returnCode = INSTR(choice$, CHR$(kee%))%@NL@%
                    IF w.returnCode THEN%@NL@%
                        ptr% = w.returnCode%@NL@%
                    END IF%@NL@%
                END SELECT%@NL@%
%@NL@%
%@AB@%              ' Check the left mouse button%@AE@%%@NL@%
                MouseNow leftButton%, rightButton%, xMouse%, yMouse%%@NL@%
                IF leftButton% THEN%@NL@%
                    w.returnCode = ptr%%@NL@%
                END IF%@NL@%
%@NL@%
%@AB@%              ' Update the highlight if line has changed%@AE@%%@NL@%
                IF ptr% <> lastPtr% THEN%@NL@%
                    LOCATE lastPtr% + w.row, w.col + 2, 0%@NL@%
                    COLOR w.fgdBody, w.bgdBody%@NL@%
                    tmp$ = LEFT$(wText$(lastPtr%) + SPACE$(maxLen%), maxLen%)%@NL@%
                    PRINT tmp$;%@NL@%
                    LOCATE ptr% + w.row, w.col + 2, 0%@NL@%
                    COLOR w.fgdHighlight, w.bgdHighlight%@NL@%
                    tmp$ = LEFT$(wText$(ptr%) + SPACE$(maxLen%), maxLen%)%@NL@%
                    PRINT tmp$;%@NL@%
                    lastPtr% = ptr%%@NL@%
                END IF%@NL@%
%@NL@%
            LOOP WHILE w.returnCode = 0%@NL@%
%@NL@%
        CASE ELSE%@NL@%
            w.returnCode = 0%@NL@%
        END SELECT%@NL@%
%@NL@%
%@AB@%      ' Reset the cursor position%@AE@%%@NL@%
        LOCATE cursorRow%, cursorCol%%@NL@%
%@NL@%
    END SUB%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          WindowsPop                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Subprogram                 **%@AE@%%@NL@%
%@AB@%  ' **  Module:        WINDOWS.BAS                **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Removes last displayed window.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  WindowsPop%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      (none)%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       mode%      Current video mode%@AE@%%@NL@%
%@AB@%  '                  columns%   Current number of display columns%@AE@%%@NL@%
%@AB@%  '                  page%      Current display page%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE SUB WindowsPop ()%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    SUB WindowsPop STATIC%@NL@%
        VideoState mode%, columns%, page%%@NL@%
        IF page% THEN%@NL@%
            SCREEN 0, , page% - 1, page% - 1%@NL@%
        END IF%@NL@%
    END SUB%@NL@%
%@NL@%
%@NL@%
%@NL@%
%@2@%%@AH@%WORDCOUN.BAS%@AE@%%@EH@%%@NL@%
%@AS@%CD-ROM Disc Path:   \SAMPCODE\QB\TOOLBOX\DISK2\WORDCOUN.BAS%@AE@%%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          WORDCOUN                   **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Toolbox                    **%@AE@%%@NL@%
%@AB@%  ' **  Module:        WORDCOUN.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' USAGE:           WORDCOUN filename%@AE@%%@NL@%
%@AB@%  ' .MAK FILE:       (none)%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      filename      Name of file to be processed%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       fileName$     Name of file from the command line%@AE@%%@NL@%
%@AB@%  '                  sep$          List of characters defined as word separators%@AE@%%@NL@%
%@AB@%  '                  a$            Each line from the file%@AE@%%@NL@%
%@AB@%  '                  totalCount&   Total count of words%@AE@%%@NL@%
%@NL@%
    DECLARE FUNCTION WordCount% (a$, sep$)%@NL@%
%@NL@%
%@AB@%  ' Assume a filename has been given on the command line%@AE@%%@NL@%
    fileName$ = COMMAND$%@NL@%
%@NL@%
%@AB@%  ' Open the file%@AE@%%@NL@%
    OPEN fileName$ FOR INPUT AS #1%@NL@%
%@NL@%
%@AB@%  ' Define the word-separating characters as space, tab, and comma%@AE@%%@NL@%
    sep$ = " " + CHR$(9) + ","%@NL@%
%@NL@%
%@AB@%  ' Read in and process each line%@AE@%%@NL@%
    DO%@NL@%
        LINE INPUT #1, a$%@NL@%
        totalCount& = totalCount& + WordCount%(a$, sep$)%@NL@%
    LOOP UNTIL EOF(1)%@NL@%
%@NL@%
%@AB@%  ' Print the results%@AE@%%@NL@%
    PRINT "There are"; totalCount&; "words in "; fileName$%@NL@%
%@NL@%
%@AB@%  ' That's all%@AE@%%@NL@%
    END%@NL@%
%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  ' **  Name:          Wordcount%                 **%@AE@%%@NL@%
%@AB@%  ' **  Type:          Function                   **%@AE@%%@NL@%
%@AB@%  ' **  Module:        WORDCOUN.BAS               **%@AE@%%@NL@%
%@AB@%  ' **  Language:      Microsoft QuickBASIC 4.00  **%@AE@%%@NL@%
%@AB@%  ' ************************************************%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' Returns the number of words in a string.%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
%@AB@%  ' EXAMPLE OF USE:  WordCount% a$, sep$%@AE@%%@NL@%
%@AB@%  ' PARAMETERS:      a$         String containing words to be counted%@AE@%%@NL@%
%@AB@%  '                  sep$       List of word separation characters%@AE@%%@NL@%
%@AB@%  ' VARIABLES:       count%     Count of words%@AE@%%@NL@%
%@AB@%  '                  flag%      Indicates if scanning is currently inside of a%@AE@%%@NL@%
%@AB@%  '                             word%@AE@%%@NL@%
%@AB@%  '                  la%        length of a$%@AE@%%@NL@%
%@AB@%  '                  i%         Index to each character of a$%@AE@%%@NL@%
%@AB@%  ' MODULE LEVEL%@AE@%%@NL@%
%@AB@%  '   DECLARATIONS:  DECLARE FUNCTION WordCount% (a$, sep$)%@AE@%%@NL@%
%@AB@%  '%@AE@%%@NL@%
    FUNCTION WordCount% (a$, sep$) STATIC%@NL@%
        count% = 0%@NL@%
        flag% = 0%@NL@%
        la% = LEN(a$)%@NL@%
        IF la% > 0 AND sep$ <> "" THEN%@NL@%
            FOR i% = 1 TO la%%@NL@%
                IF INSTR(sep$, MID$(a$, i%, 1)) THEN%@NL@%
                    IF flag% THEN%@NL@%
                        flag% = 0%@NL@%
                        count% = count% + 1%@NL@%
                    END IF%@NL@%
                ELSE%@NL@%
                    flag% = 1%@NL@%
                END IF%@NL@%
            NEXT i%%@NL@%
        END IF%@NL@%
        WordCount% = count% + flag%%@NL@%
%@NL@%
    END FUNCTION%@NL@%
%@NL@%
